[
    {
        "title": "Incorrect whitelist check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap - CrossChain_en-us.pdf",
        "body": "In the CrossFarmingVault contract, the owner can add a new pool through the add function and check if it is in the whitelist. However, the non-whitelisted pool is allowed to enter by mistake, but the whitelisted pool cannot be successfully added. ",
        "labels": [
            "SlowMist",
            "PancakeSwap - CrossChain",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Redundant balance checks",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap - CrossChain_en-us.pdf",
        "body": "In the CrossFarmingVault contract, the owner can add a new pool through the add function and check whether the balance of the LP tokens added in the current contract is greater than or equal to 0. In theory, the balance of each account will be greater than or equal to 0, so this check is redundant. ",
        "labels": [
            "SlowMist",
            "PancakeSwap - CrossChain",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Gas optimization",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap - CrossChain_en-us.pdf",
        "body": "In the CrossFarmingVault contract, the deposit, withdraw and emergencyWithdraw functions use low-level calls to make external function calls, which will consume more gas than using the interface method. The same is true for the executeMessage function in the CrossFarmingReceiver contract. 11 ",
        "labels": [
            "SlowMist",
            "PancakeSwap - CrossChain",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Potential fake mining risk",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap - CrossChain_en-us.pdf",
        "body": "In the protocol, if the user's deposit in the src chain is successful, but the deposit in the dest chain fails, the operator role can return the LP tokens to the user through the fallbackDeposit function. However, if the user successfully deposits in the dest chain, but the operator role still triggers the fallbackDeposit function to refund, this will cause the user to still receive CAKE token rewards in the dest chain. 13 ",
        "labels": [
            "SlowMist",
            "PancakeSwap - CrossChain",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Incorrect function state",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap - CrossChain_en-us.pdf",
        "body": "In the CrossFarmingVault, the calcFee function is used to calculate the fee required for the message cross-chain, and the encodeMessage function is used to encode the message. Both can use the view function. ",
        "labels": [
            "SlowMist",
            "PancakeSwap - CrossChain",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Inappropriate exchange rate decimal",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap - CrossChain_en-us.pdf",
        "body": "In the CrossFarmingSender contract, the exchange rate is obtained by multiplying the BNB price by EXCHANGE_RATE_PRECISION and dividing the ETH price. In the future, if the price of ETH is greater than 1e5 times the price of BNB, the result of this algorithm will be 0. ",
        "labels": [
            "SlowMist",
            "PancakeSwap - CrossChain",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Redundant payable label",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap - CrossChain_en-us.pdf",
        "body": "In the CrossFarmingSender and CrossFarmingReceiver contract, the claimFee function user transfers the native tokens in the contract, so this function does not need the payable label. ",
        "labels": [
            "SlowMist",
            "PancakeSwap - CrossChain",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Potential duplicate deposit and withdrawal issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap - CrossChain_en-us.pdf",
        "body": "In the protocol, the deposit function of CrossFarmingProxy is indirectly triggered by SGN's MessageBus to make deposits for users. If SGN repeatedly executes the message due to failure, the message of the same nonce will be executed multiple times.",
        "labels": [
            "SlowMist",
            "PancakeSwap - CrossChain",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Allowance depletion issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap - CrossChain_en-us.pdf",
        "body": "In the CrossFarmingProxy contract, the deposit function is used to deposit LP tokens into the MASTER_CHEF_V2 contract. MASTER_CHEF_V2 will be approved before depositing, and approved[lpToken] will be set to true after approval, and will never be approved again in the future. Although the approved amount is uint256, the allowance may still be exhausted in the future, and after the allowance is exhausted, it will no longer be possible to approve. This will make the proxy contract unavailable. ",
        "labels": [
            "SlowMist",
            "PancakeSwap - CrossChain",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Incorrect interface call",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap - CrossChain_en-us.pdf",
        "body": "In the executeMessage function of the CrossFarmingReceiver contract, when the msgType is Withdraw and EmergencyWithdraw, the sender contract that is not deployed in the BSC chain is called by mistake. ",
        "labels": [
            "SlowMist",
            "PancakeSwap - CrossChain",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Function visibility issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Alpaca Finance Oracle_en-us.pdf",
        "body": "In the OracleMedianizer contract, the user can get the price of the pair token through the getPrice function. The getPrice function will call the _getPrice function to get the price, but the visibility of the _getPrice function is public. ",
        "labels": [
            "SlowMist",
            "Alpaca Finance Oracle",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "The Token Pair Check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Alpaca Finance Oracle_en-us.pdf",
        "body": "There is a _setPriceFeed function in the ChainLinkPriceOracle contract, which is used to set the source of the token pair. In the function, check whether priceFeeds[token1][token0] already exists, but then set the source for priceFeeds[token0][token1] . ",
        "labels": [
            "SlowMist",
            "Alpaca Finance Oracle",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "4.3.1.1 Risk of Oracle Manipulation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Shield_en-us.pdf",
        "body": "In DDSContracts, the price is obtained from Uniswap's getAmountsIn through the getPriceByWBTCDAI function, but this interface obtains the real-time price of the WBTC/DAI pool, and there is a risk of malicious manipulation. 6 Fix suggestion: It is recommended to use Uniswap's delayed price feed oracle for acquisition. ",
        "labels": [
            "SlowMist",
            "Shield",
            "Severity: Critical"
        ]
    },
    {
        "title": "4.3.1.2 Price acquisition issue when opening and closing positions",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Shield_en-us.pdf",
        "body": "In the DDSContracts contract, the price used when opening and closing a position is passed in from the outside, which will cause the user to pass in any price when opening and closing a position. After communicating with the project party, this is the test code, and the oracle will be used to feed the price during the formal deployment. Fix suggestion: It is recommended to use Uniswap's delayed price feed oracle for acquisition. ",
        "labels": [
            "SlowMist",
            "Shield",
            "Severity: Critical"
        ]
    },
    {
        "title": "4.3.2.1 The available funds were not processed when the riskControl",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Shield_en-us.pdf",
        "body": "closed the position In the Pool contract, when riskClose is triggered when the risk control liquidation is triggered, if the margin is insufficient and the pool order transfer fails, risk funds will be used to make up for the insufficient part, and all available funds of the user will be deducted. However, the user's available funds are not actually set to 0. Fix suggestion: It is recommended that the available funds should be emptied after the transfer of insurance funds. ",
        "labels": [
            "SlowMist",
            "Shield",
            "Severity: High"
        ]
    },
    {
        "title": "4.3.3.1 Insecure random number",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Shield_en-us.pdf",
        "body": "In the Pool contract, the getMatchLp2Object function uses block difficulty and block time now as the random number seed to participate in the calculation of random numbers. But block difficulty and time can be predicted or manipulated. Fix suggestion: It is recommended to use the random number provided by chainlink that cannot be manipulated. ",
        "labels": [
            "SlowMist",
            "Shield",
            "Severity: Low"
        ]
    },
    {
        "title": "4.3.4.1 Event missing",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Shield_en-us.pdf",
        "body": "In the DDSContracts contract, the owner can set the key parameters of the contract through the setExchageAddress, setPoolTokenAddr, setPrivatePool, setPublicPool, setFormular, and setrepayFudAddr functions, but no event recording is performed. Fix suggestion: In order to facilitate follow-up records and community viewing, it is recommended to record events for sensitive parameter modifications. ",
        "labels": [
            "SlowMist",
            "Shield",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.3.4.2 Does not follow the `Checks-effects-interactions` model",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Shield_en-us.pdf",
        "body": "In Contracts and Pool2 contracts, when deposit and provide functions are used to recharge, the state is changed first, and then the corresponding tokens are transferred to the contract. Fix suggestion: It is recommended to follow the Checks-effects-interactions model, first transfer the corresponding tokens and then change the state. 10 ",
        "labels": [
            "SlowMist",
            "Shield",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.3.4.3 Redundant code",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Shield_en-us.pdf",
        "body": "Provide price feed interfaces such as updateImpliedVolrate and updatePriceByOwner in the DDSFormular contract to update the price. However, these interfaces are not used by the Contracts contract, and these price-feeding interfaces have no permission control and can be called by any user. 11 Fix suggestion: If this interface is a test interface, it is recommended to remove it during formal deployment. If it will use the suggestions in subsequent iterations for permission control. ",
        "labels": [
            "SlowMist",
            "Shield",
            "Severity: Informational"
        ]
    },
    {
        "title": "Event log missing",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - earning.farm_en-us.pdf",
        "body": "12 contracts/core/EFLeverVault.sol Modifying important variables in the contract requires corresponding event records. function initAddresses(address[7] memory addr) public onlyOwner{ aave = addr[0]; balancer = addr[1]; balancer_fee = addr[2]; lido = addr[3]; asteth = addr[4]; curve_pool = addr[5]; weth = addr[6]; } contracts/core/EFCRVVault.sol Modifying important variables in the contract requires corresponding event records. function initAddresses(address[11] memory addr) public onlyOwner{ crv = addr[0]; usdc = addr[1]; eth_usdc_router = addr[2]; weth = addr[3]; cvxcrv = addr[4]; eth_crv_router = addr[5]; crv_cvxcrv_router = addr[6]; eth_usdt_router = addr[7]; usdt = addr[8]; oracle = addr[9]; staker = addr[10]; }",
        "labels": [
            "SlowMist",
            "earning.farm",
            "Type: Malicious Event Log Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - earning.farm_en-us.pdf",
        "body": "contracts/core/EFLeverVault.sol The owner's authority is too large. If the private key is lost, the attacker can use the pause function to transfer the funds in the contract through callWithData ,or directly transfer astheth. function callWithData(address payable to, bytes memory data, uint256 amount)public payable onlyOwner{ (bool status, ) = to.call.value(amount)(data); require(status, \"call failed\"); } function delegateCallWithData(address payable to, bytes memory data)public payable onlyOwner{ (bool status, ) = to.delegatecall(data); require(status, \"call failed\"); }",
        "labels": [
            "SlowMist",
            "earning.farm",
            "Type: Authority Control Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Potential Sandwich Attack Risk",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - earning.farm_en-us.pdf",
        "body": "contracts/core/EFCRVVault.sol 14 it will perform the token swap operation through the swapExactTokensForTokens function. But the incoming minAmountOut is 0 , which will not do slippage checking,There is a risk of being attacked by sandwiches. function depositStable(uint256 _amount) public payable nonReentrant{ require(!is_paused, \"paused\"); require(IERC20(usdc).allowance(msg.sender, address(this)) >= _amount, \"CFVault: not enough allowance\"); IERC20(usdc).safeTransferFrom(msg.sender, address(this), _amount); if (IERC20(usdc).allowance(address(this), eth_usdc_router) != 0){ IERC20(usdc).approve(eth_usdc_router, 0); } IERC20(usdc).approve(eth_usdc_router, _amount); uint256 weth_before = IERC20(weth).balanceOf(address(this)); address[] memory t = new address[](2); t[0] = usdc; t[1] = weth; UniswapV3Interface(eth_usdc_router).swapExactTokensForTokens(_amount, 0, t, address(this)); uint256 weth_amount = IERC20(weth).balanceOf(address(this)).safeSub(weth_before); if (IERC20(weth).allowance(address(this), eth_crv_router) != 0){ IERC20(weth).approve(eth_crv_router, 0); } IERC20(weth).approve(eth_crv_router, weth_amount); uint256 tt_before = IERC20(crv).balanceOf(address(this)); CurveInterface256(eth_crv_router).exchange(0, 1, weth_amount, 0); uint256 tt_amount = IERC20(crv).balanceOf(address(this)).safeSub(tt_before); _deposit(_amount, tt_amount); }",
        "labels": [
            "SlowMist",
            "earning.farm",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Potential Sandwich Attack Risk",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - earning.farm_en-us.pdf",
        "body": "contracts/core/EFCRVVault.sol it will perform the token swap operation through the swapExactTokensForTokens function. But the incoming minAmountOut is 0 , which will not do slippage checking,There is a risk of being attacked by sandwiches. function withdraw(uint256 _amount, bool _use_stable) public nonReentrant{ require(!is_paused, \"paused\"); { uint256 total_balance = IERC20(ef_token).balanceOf(msg.sender); require(total_balance >= _amount, \"not enough LP tokens\"); } uint256 target_amount; { //if (IERC20(ef_token).totalSupply() == 0) require(false, \"000\"); uint256 lp_amount = _amount.safeMul(lp_balance).safeDiv(IERC20(ef_token).totalSupply()); uint256 target_before = IERC20(crv).balanceOf(address(this)); _withdraw(lp_amount); target_amount = IERC20(crv).balanceOf(address(this)).safeSub(target_before); } uint256 f = 0; if(withdraw_fee_ratio != 0 && fee_pool != address(0x0)){ f = target_amount.safeMul(withdraw_fee_ratio).safeDiv(ratio_base); target_amount = target_amount.safeSub(f); IERC20(crv).transfer(fee_pool, f); TokenInterfaceERC20(ef_token).destroyTokens(msg.sender, _amount); }else{ TokenInterfaceERC20(ef_token).destroyTokens(msg.sender, _amount); } if (!_use_stable){ IERC20(crv).transfer(msg.sender, target_amount); emit CFFWithdraw(msg.sender, target_amount, target_amount.safeMul(uint256(ChainlinkInterface(oracle).latestAnswer())).safeDiv(1e2 16 0), _amount, f, getVirtualPrice()); } else{ if (IERC20(crv).allowance(address(this), eth_crv_router) != 0){ IERC20(crv).approve(eth_crv_router, 0); } IERC20(crv).approve(eth_crv_router, target_amount); uint256 weth_amount; { uint256 weth_before = IERC20(weth).balanceOf(address(this)); CurveInterface256(eth_crv_router).exchange(1, 0, target_amount, 0); weth_amount = IERC20(weth).balanceOf(address(this)).safeSub(weth_before); } if (IERC20(weth).allowance(address(this), eth_usdc_router) != 0){ IERC20(weth).approve(eth_usdc_router, 0); } IERC20(weth).approve(eth_usdc_router, weth_amount); uint256 usdc_amount; { address[] memory t = new address[](2); t[0] = weth; t[1] = usdc; uint256 usdc_before = IERC20(usdc).balanceOf(address(this)); UniswapV3Interface(eth_usdc_router).swapExactTokensForTokens(weth_amount, 0, t, address(this)); usdc_amount = IERC20(usdc).balanceOf(address(this)).safeSub(usdc_before); } IERC20(usdc).transfer(msg.sender, usdc_amount); emit CFFWithdraw(msg.sender, target_amount, usdc_amount, _amount, f, getVirtualPrice()); } }",
        "labels": [
            "SlowMist",
            "earning.farm",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Redundant code",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - earning.farm_en-us.pdf",
        "body": "contracts/erc20/ERC20Impl.sol onTransferDone function not being called function onTransferDone(address _from, address _to, uint256 _amount) internal { for(uint i = 0; i < transferListeners.length; i++){ TransferEventCallBack t = TransferEventCallBack(transferListeners[i]); t.onTransfer(_from, _to, _amount); } }",
        "labels": [
            "SlowMist",
            "earning.farm",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Redundant code",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - earning.farm_en-us.pdf",
        "body": "contracts/core/EFLeverVault.sol IERC20(weth).balanceOf(address(this)) return result unused. function raiseActualLTV(uint256 lt) public onlyOwner{//take lt = 7500 uint256 e = getDebt(); uint256 st = getCollecteral(); require(e.safeMul(10000) < st.safeMul(mlr), \"no need to raise\"); uint256 x = st.safeMul(mlr).safeSub(e.safeMul(10000)).safeDiv(uint256(10000).safeSub(mlr));//x = 18 (mST-E)/(1-m) uint256 y = st.safeMul(lt).safeDiv(10000).safeSub(e).safeSub(1); if (x > y) {x = y;} IAAVE(aave).borrow(weth, x, 2, 0, address(this)); IWETH(weth).withdraw(IERC20(weth).balanceOf(address(this))); ILido(lido).submit.value(address(this).balance)(address(this)); IERC20(weth).balanceOf(address(this));//SlowMist//return result unused if (IERC20(lido).allowance(address(this), aave) != 0) {IERC20(lido).safeApprove(aave, 0);} IERC20(lido).safeApprove(aave, IERC20(lido).balanceOf(address(this))); IAAVE(aave).deposit(lido, IERC20(lido).balanceOf(address(this)), address(this), 0); emit ActualLTVChanged(e, st, getDebt(), getCollecteral()); }",
        "labels": [
            "SlowMist",
            "earning.farm",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - earning.farm_en-us.pdf",
        "body": "contracts/core/EFLeverVault.sol If the owner permission is lost, the attacker can achieve free recharge by changing the address of the token, thereby taking away the funds in the contract. function initAddresses(address[7] memory addr) public onlyOwner{ aave = addr[0]; balancer = addr[1]; balancer_fee = addr[2]; lido = addr[3]; 19 asteth = addr[4]; curve_pool = addr[5]; weth = addr[6]; emit CFFNewAddress(addr); } contracts/core/EFCRVVault.sol function initAddresses(address[11] memory addr) public onlyOwner{ crv = addr[0]; usdc = addr[1]; eth_usdc_router = addr[2]; weth = addr[3]; cvxcrv = addr[4]; eth_crv_router = addr[5]; crv_cvxcrv_router = addr[6]; eth_usdt_router = addr[7]; usdt = addr[8]; oracle = addr[9]; staker = addr[10]; emit CFFNewAddress(addr); }",
        "labels": [
            "SlowMist",
            "earning.farm",
            "Type: Authority Control Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - earning.farm_en-us.pdf",
        "body": "contracts/core/EFCRVVault.sol 20 delegateCallWithData is an arbitrary external call, if the private key is lost the attacker can unstake and transfer the funds And for users who have previously authorized the current contract, the attacker can transfer funds that are not operated by the user himself by constructing a malicious contract. function delegateCallWithData(address payable to, bytes memory data)public payable onlyOwner{ (bool status, ) = to.delegatecall(data); require(status, \"call failed\"); }",
        "labels": [
            "SlowMist",
            "earning.farm",
            "Type: Authority Control Vulnerability",
            "Severity: Critical"
        ]
    },
    {
        "title": "Pages calculation issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SubDao_en-us.pdf",
        "body": "In the DaoFactory contract, calculatePages is used to calculate the start index and end index of a page. The size, start index and end index are checked in the function size <= 0 || start >= total || start < end , but in fact, size should not be less than 0, and start should not be greater than total. ",
        "labels": [
            "SlowMist",
            "SubDao",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Missing event records",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SubDao_en-us.pdf",
        "body": "In the DaoTemplate contract, the user can modify the actionCong parameter through the setActionCong function, but no event recording is performed. The same is true for the setActionCong function in the VentureTemplate contract. The same is true for the setCanFreeAddMember, transferOwner and updateOwnership functions in the OrgManager contract. ",
        "labels": [
            "SlowMist",
            "SubDao",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Owner update issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SubDao_en-us.pdf",
        "body": "In the DaoTemplate contract, the owner can update the owner of all components through the updateOwnership function. But it calls the updateOwnership interface of the templateCong contract by mistake. The same is true for the updateOwnership function in the VentureTemplate contract. ",
        "labels": [
            "SlowMist",
            "SubDao",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "State Coverage Risk",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SubDao_en-us.pdf",
        "body": "In the GrantMethodManager contract, DaoTemplate can operate the applyOp and setUserOpByOwner functions through the action contract. Since the parameters it receives are all passed in from the outside, if the incoming data is repeated, the encoded key will be repeated, which will cause the existing data to be overwritten. ",
        "labels": [
            "SlowMist",
            "SubDao",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "TODO label issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SubDao_en-us.pdf",
        "body": "There is still a TODO label in the spendTokenInLimit function of the GrantMethodManager contract. Is there still a function not perfect? The same is true for the _unsafeCancelVote function in the VoteManager contract. ",
        "labels": [
            "SlowMist",
            "SubDao",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Length check issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SubDao_en-us.pdf",
        "body": "The initialize function exists in the VenturesStockManager , VenturesManager and GovTokenManager contracts to initialize the contract according to the incoming parameters. It checks the byte length of the incoming parameter, but because some parameters are variable-length data, forcing an equals check will lead to unsuccessful initialization. ",
        "labels": [
            "SlowMist",
            "SubDao",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Vote check issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SubDao_en-us.pdf",
        "body": "In the VoteManager contract, the _canExecute function is used to check whether the proposal can be executed, but it does not check whether the number of yes votes is greater than the number of negative votes. ",
        "labels": [
            "SlowMist",
            "SubDao",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Cancel voting issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SubDao_en-us.pdf",
        "body": "29 In the VoteManager contract, the _canCancel function user checks whether the current vote can be cancelled. If the voting period for a proposal has passed, but the execution conditions are still not met, the proposal cannot be executed or cancelled. ",
        "labels": [
            "SlowMist",
            "SubDao",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Risk of Governance Attacks",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SubDao_en-us.pdf",
        "body": "DAO members can create new proposals through ActionVoteNew , ActionGrantMethodRegister , ActionVoteTransferPeriodRegister and other contracts. However, the proposal does not contain the data that needs to be executed. After the proposal is passed, the community members will pass in the specic execution data for execution. If malicious data is passed in, there is a risk that the protocol will be maliciously broken during proposal execution.",
        "labels": [
            "SlowMist",
            "SubDao",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Potential Fund Theft Risk",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SubDao_en-us.pdf",
        "body": "As mentioned in N12, when a DAO member creates an Operation through ActionGrantMethodRegister, the user's specic execution data is not recorded in the newVote operation. Although registerOp records the extra data passed in by the user, it is not used op_.extra in actual execution. Therefore, the user can pass in valid execution data when performing the registerOp operation. And malicious data is passed in during the ActionVaultUniswapV2Router02Swap operation. This will result in funds managed by the DAO being approved for malicious router contracts, or swapping through extremely illiquid pools, allowing malicious users to easily arbitrage. This would create huge risks for DAOs. The same is true in the ActionVaultUniswapV2SwapToken contract. ",
        "labels": [
            "SlowMist",
            "SubDao",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Lack of access control",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SubDao_en-us.pdf",
        "body": "In the VenturesManager contract, the gpRaiseMoney and lpRaiseMoney functions are not restricted to be called by the owner. ",
        "labels": [
            "SlowMist",
            "SubDao",
            "Type: Authority Control Vulnerability",
            "Severity: High"
        ]
    },
    {
        "title": "Period transfer issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SubDao_en-us.pdf",
        "body": "In the ActionVoteTransferPeriodApply contract, when performing a period transfer, the period will be obtained through the transferPeriodStates function of the VoteExecutionManager contract, and then the period will be transferred through the transferVenturePeriod function of the VenturesManager contract. But in the current action, period is directly transferred to SettlementPeriod. ",
        "labels": [
            "SlowMist",
            "SubDao",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Redundant parameter issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ENF_WBTC_Borrow_ETH_en-us.pdf",
        "body": "In the PriceOracle contract, the getAssetPrice function is used to obtain the relative price of WBTC and ETH. But the _asset parameter it receives is not used. ",
        "labels": [
            "SlowMist",
            "ENF_WBTC_Borrow_ETH",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Token swap defect when withdrawing",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ENF_WBTC_Borrow_ETH_en-us.pdf",
        "body": "In the WBTCBorrowETH contract, the withdraw function is used to withdraw WBTC tokens. When the repayable amount of the contract is less than the required loan amount (ethWithdrawn < ethDebt), the contract will withdraw wbtcToSwap amount of WBTC from AAVE to swap it into WETH, and use the wbtcAmt value as the amountInMaximum in the Swap exchange. However, since the wbtcAmt value is indirectly calculated through the ChainLink price, there may be a deviation from the price in Uniswap v3, so using the wbtcAmt value as the amountInMaximum parameter may not be successfully swapped due to the price deviation. ",
        "labels": [
            "SlowMist",
            "ENF_WBTC_Borrow_ETH",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Swap balance has not been processed",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ENF_WBTC_Borrow_ETH_en-us.pdf",
        "body": "In the _withdraw function of the WBTCBorrowETH contract, when ethWithdrawn < ethDebt , the contract will withdraw WBTC tokens from AAVE and swap them into ETH to repay the loan. If the amount of ETH is greater than the amount of debt required to be repaid (ethBal > ethDebt), the contract will swap the excess part into WBTC, but these excess WBTC tokens have not been sent to the user, nor have they been re-staked into AAVE. It was left in the SS contract. When the next user deposit, it will be billed as part of the user's deposit. And when ethWithdrawn >= ethDebt , the contract will convert the excess ETH to WBTC, but the contract has not yet processed these WBTC. ",
        "labels": [
            "SlowMist",
            "ENF_WBTC_Borrow_ETH",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Defects in LTV operation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ENF_WBTC_Borrow_ETH_en-us.pdf",
        "body": "In the reduceLTV operation, the contract will rst extract x amount of WBTC from AAVE and exchange it into WETH 12 for repayment. In this operation, although the liabilities of the contract are reduced, the amount of collateral of the contract is also reduced. At the same time, due to the impact of the slippage of the swap operation, the reduceLTV operation may not be able to eectively control the risk as expected. ",
        "labels": [
            "SlowMist",
            "ENF_WBTC_Borrow_ETH",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Reduced availability for LTV operations 13",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ENF_WBTC_Borrow_ETH_en-us.pdf",
        "body": "In the protocol, the raiseLTV and reduceLTV functions are important means to improve capital utilization and prevent bad debts, but in these two functions, the token exchange is performed through the _swapExactInput function. The _swapExactInput function does not check for slippage, which will reduce the availability of raiseLTV and reduceLTV for the protocol. ",
        "labels": [
            "SlowMist",
            "ENF_WBTC_Borrow_ETH",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "The withdraw function will not work when the market is extreme",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ENF_WBTC_Borrow_ETH_en-us.pdf",
        "body": "In the protocol, when extreme market conditions occur (such as a sharp unilateral drop of BTC) and the owner has no time to adjust the protocol LTV through the reduceLTV function, the protocols WBTC position will be liquidated. If 14 the protocol's liabilities are fully liquidated (getDebt will become 0), ethDebt will be 0. This will cause the _withdraw function to fail to perform the repay operation, and the emergencyWithdraw operation will also not work. Users' funds will be locked in the protocol. In the repay operation of AAVE, if the repayment amount is 0, it will fail the validateRepay check.",
        "labels": [
            "SlowMist",
            "ENF_WBTC_Borrow_ETH",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Risk of multiple leverages in unilateral market conditions",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ENF_WBTC_Borrow_ETH_en-us.pdf",
        "body": "The protocol deposits WBTC tokens deposited by users into AAVE and lends ETH, and then deposits the loaned ETH into the ENF_ETH_Leverage protocol. The ENF_ETH_Leverage protocol also creates positions in AAVE via ETH/stETH. This makes the ENF_WBTC_Borrow_ETH protocol have multiple leverages, which means it is extremely sensitive to market stability. Once the agreement does not manage LTV properly, it will lead to risks such as bad debts of the agreement. ",
        "labels": [
            "SlowMist",
            "ENF_WBTC_Borrow_ETH",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of excessive authority 16",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ENF_WBTC_Borrow_ETH_en-us.pdf",
        "body": "In the protocol, the owner role has many permissions, such as the owner can set sensitive parameters, can suspend the contract, can make emergency withdrawals, etc. It is obviously inappropriate to give all the permissions of the protocol to the owner, which will greatly increase the single point of risk.",
        "labels": [
            "SlowMist",
            "ENF_WBTC_Borrow_ETH",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Overow issues",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - WombatExchange_en-us.pdf",
        "body": "The data type of priceStruct.expo is int32, and the return result is negative, so uint256(int256(priceStruct.expo)) will get a large value, and 10 ** uint256(int256(priceStruct.expo) will overflow. Because the compiler version used is pragma solidity ^0.8.5;`. ",
        "labels": [
            "SlowMist",
            "WombatExchange",
            "Type: Integer Overow and Underow Vulnerability",
            "Severity: Critical"
        ]
    },
    {
        "title": "Missing event record",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - WombatExchange_en-us.pdf",
        "body": "The owner has the ability to modify the values of the maxPriceAge, shouldCapEquilCovRatio, startCovRatio, endCovRatio parameters, etc. which are global variables, but any modications made to them are not recorded with events. ",
        "labels": [
            "SlowMist",
            "WombatExchange",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Excessive authority issues",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - WombatExchange_en-us.pdf",
        "body": "The Owner can modify priceIDs[_token], priceFeed, fallbackPriceFeed. This will aect the price at which the project gets oracle. The wrong price will lead to a fatal vulnerability in the project. ",
        "labels": [
            "SlowMist",
            "WombatExchange",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Redundant judgment",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - WombatExchange_en-us.pdf",
        "body": "If fromAmount is 0, the code will revert, so if (fromAmount >= 0) should be changed to if (fromAmount > 0). ",
        "labels": [
            "SlowMist",
            "WombatExchange",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "fee management suggestions",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - WombatExchange_en-us.pdf",
        "body": "If the receiving address of fee is an EOA address, there will be a single point risk of private key management. ",
        "labels": [
            "SlowMist",
            "WombatExchange",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "conditional competition issues",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - WombatExchange_en-us.pdf",
        "body": "The llPool function and the transferTipBucket function are controlled by the two roles of dev and owner respectively. When the opinions of the dev and owner are inconsistent, there will be conditional competition issues. ",
        "labels": [
            "SlowMist",
            "WombatExchange",
            "Type: Race Conditions Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Suggestions for variable type conversion",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - WombatExchange_en-us.pdf",
        "body": "The following functions when using uint256 to convert int256, it is not judged whether the variable to be converted is less than type(int256).max, and when using int256 to convert uint256, it is not judged whether the variable is greater than 0. CoreV3.quoteDepositLiquidity CoreV3.quoteWithdrawAmount CoreV3.quoteWithdrawAmountFromOtherAsset CoreV3.quoteSwap CoreV3.quoteSwapTokensForCredit CoreV3.quoteSwapCreditForTokens PoolV3._globalInvariantFunc PoolV3.globalEquilCovRatioWithCredit DynamicPoolV3._globalInvariantFunc PythPriceFeed.getLatestPrice",
        "labels": [
            "SlowMist",
            "WombatExchange",
            "Type: Others",
            "Severity: Low"
        ]
    },
    {
        "title": "Business logic is unclear",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - WombatExchange_en-us.pdf",
        "body": "The _quoteFactor function returns a xed value of 1e18, but the function receives parameters, and the parameters do not need to be used. ",
        "labels": [
            "SlowMist",
            "WombatExchange",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Token compatibility issues",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - WombatExchange_en-us.pdf",
        "body": "When the project is transferred to the token, it does not judge the balance change before and after the transfer of the target address receiving the token, so it is incompatible with reective tokens (deation/ination type tokens), which will cause the balance of the transfer to be inconsistent with the balance actually received, which will lead to calculation errors. ",
        "labels": [
            "SlowMist",
            "WombatExchange",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Redundant type conversion code",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - WombatExchange_en-us.pdf",
        "body": "The _quoteFrom function is using uint256 nalToAssetCovRatio = (toAssetCash + uint256(actualToAmount)).wdiv(toAssetLiability); to convert uint256(actualToAmount), But actualToAmount is of the type uint256, it is no need to convert. ",
        "labels": [
            "SlowMist",
            "WombatExchange",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Wrong slippage check issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cook Index_en-us.pdf",
        "body": "In the IssuanceModule contract, the _createTradeInfo function is used to create a structure containing trade data. Among them, it will obtain the thresholdAmounts parameter oset by slippage through the getMinAmountsOut function and the getMaxAmountsIn function. After the trade data is created, the trade operation will be executed 8 through the _executeTrade function, which will use the thresholdAmounts parameter as the minimum amounts to receive for trading on uniswap. However, since slippage check and trade execution are carried out in the same transaction, the thresholdAmounts parameter will still be aected by the last swap transaction of uniswap. Therefore, the slippage check cannot play a protective role. ",
        "labels": [
            "SlowMist",
            "Cook Index",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Logical redundancy issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cook Index_en-us.pdf",
        "body": "In the VesperWrapAdapter contract, getSpenderAddress is used to obtain the source token address of the wrap token, but the actual function logic directly returns the passed _wrappedToken parameter. This seems to be dierent from what the function comments indicate. ",
        "labels": [
            "SlowMist",
            "Cook Index",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of external calls 11",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cook Index_en-us.pdf",
        "body": "There are a large number of external calls in the IssuanceModule contract, but the external call part is not within the scope of this audit. It is necessary to pay attention to the unknown risks of external calls.",
        "labels": [
            "SlowMist",
            "Cook Index",
            "Type: Unsafe External Call Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "4.2.1.1 Sandwich attacks issues",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - autofarm_en-us.pdf",
        "body": "The earn(), buyBack(), convertDustToEarned(), _convertMDXToEarned functions no limit slippage, there is a sandwich attacks issues. It is recommended to add a slippage limit, and the slippage parameter can only be modified by the Owner.  AutofarmV2_CrossChain/StratVLEV2.sol function earn() external whenNotPaused { if (onlyGov) { require(msg.sender == govAddress, \"!gov\"); } 6 IVenusDistribution(venusDistributionAddress).claimVenus(address(this)); uint256 earnedAmt = IERC20(venusAddress).balanceOf(address(this)); earnedAmt = distributeFees(earnedAmt); earnedAmt = buyBack(earnedAmt); if (venusAddress != wantAddress) { IPancakeRouter02(uniRouterAddress).swapExactTokensForTokens( earnedAmt, 0, venusToWantPath, address(this), now.add(600) ); } lastEarnBlock = block.number; _farm(false); //SupplywantTokenwithoutleverage,tocaterfornet-veinterestrates. }  AutofarmV2_CrossChain/StratVLEV2.sol function buyBack(uint256 _earnedAmt) internal returns (uint256) { if (buyBackRate <= 0) { return _earnedAmt; } uint256 buyBackAmt = _earnedAmt.mul(buyBackRate).div(buyBackRateMax); IPancakeRouter02(uniRouterAddress).swapExactTokensForTokens( buyBackAmt, 0, earnedToAUTOPath, buyBackAddress, now + 600 ); return _earnedAmt.sub(buyBackAmt); 7 }  AutofarmV2_CrossChain/StratX2_MDEX.sol function convertDustToEarned() public whenNotPaused { require(isAutoComp, \"!isAutoComp\"); require(!isCAKEStaking, \"isCAKEStaking\"); //Convertsdusttokensintoearnedtokens,whichwillbereinvestedonthenextearn(). //Convertstoken0dust(ifany)toearnedtokens uint256 token0Amt = IERC20(token0Address).balanceOf(address(this)); if (token0Address != earnedAddress && token0Amt > 0) { IERC20(token0Address).safeIncreaseAllowance( uniRouterAddress, token0Amt ); //Swapalldusttokenstoearnedtokens IPancakeRouter02(uniRouterAddress) .swapExactTokensForTokensSupportingFeeOnTransferTokens( token0Amt, 0, token0ToEarnedPath, address(this), now + 600 ); } //Convertstoken1dust(ifany)toearnedtokens uint256 token1Amt = IERC20(token1Address).balanceOf(address(this)); if (token1Address != earnedAddress && token1Amt > 0) { IERC20(token1Address).safeIncreaseAllowance( uniRouterAddress, token1Amt ); //Swapalldusttokenstoearnedtokens IPancakeRouter02(uniRouterAddress) .swapExactTokensForTokensSupportingFeeOnTransferTokens( 8 token1Amt, 0, token1ToEarnedPath, address(this), now + 600 ); } }  AutofarmV2_CrossChain/StratX2_MDEX.sol function _convertMDXToEarned() internal { //ConvertsMDX(ifany)toearnedtokens uint256 MDXAmt = IERC20(MDXAddress).balanceOf(address(this)); if (MDXAddress != earnedAddress && MDXAmt > 0) { IERC20(MDXAddress).safeIncreaseAllowance(uniRouterAddress, MDXAmt); //Swapalldusttokenstoearnedtokens IPancakeRouter02(uniRouterAddress) .swapExactTokensForTokensSupportingFeeOnTransferTokens( MDXAmt, 0, MDXToEarnedPath, address(this), now + 60 ); } }  AutofarmV2_CrossChain/StratX2_MDEX.sol function buyBack(uint256 _earnedAmt) internal returns (uint256) { if (buyBackRate <= 0) { return _earnedAmt; } uint256 buyBackAmt = _earnedAmt.mul(buyBackRate).div(buyBackRateMax); if (earnedAddress == AUTOAddress) { IERC20(earnedAddress).safeTransfer(buyBackAddress, buyBackAmt); } else { IERC20(earnedAddress).safeIncreaseAllowance( uniRouterAddress, 9 buyBackAmt ); IPancakeRouter02(uniRouterAddress) .swapExactTokensForTokensSupportingFeeOnTransferTokens( buyBackAmt, 0, earnedToAUTOPath, buyBackAddress, now + 600 ); } return _earnedAmt.sub(buyBackAmt); }  AutofarmV2_CrossChain/StratVLEV2.sol function earn() external whenNotPaused { if (onlyGov) { require(msg.sender == govAddress, \"!gov\"); } IVenusDistribution(venusDistributionAddress).claimVenus(address(this)); uint256 earnedAmt = IERC20(venusAddress).balanceOf(address(this)); earnedAmt = distributeFees(earnedAmt); earnedAmt = buyBack(earnedAmt); if (venusAddress != wantAddress) { IPancakeRouter02(uniRouterAddress).swapExactTokensForTokens( earnedAmt, 0, venusToWantPath, address(this), now.add(600) ); } lastEarnBlock = block.number; 10 _farm(false); //SupplywantTokenwithoutleverage,tocaterfornet-veinterestrates. } Fix Status: The issue has been fixed in this commit: b27f2cafcf51667726bd70220420707c89b75975",
        "labels": [
            "SlowMist",
            "autofarm",
            "Severity: High"
        ]
    },
    {
        "title": "4.2.2.1 Excessive authority issues",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - autofarm_en-us.pdf",
        "body": "The add function has excessive authority issues, Owner can add mining pool arbitrarily, there is a risk of stealing mining by himself, and _strat is the destination address of the final sending of funds, the owner can set this address arbitrarily, pay attention to compatibility issues with external contracts, it is recommended to set the ownership to the timelock contract, and add events to record in the add function.  AutofarmV2_CrossChain/AutoFarmV2_CrossChain.sol function add( uint256 _allocPoint, IERC20 _want, bool _withUpdate, address _strat ) public onlyOwner { if (_withUpdate) { massUpdatePools(); } totalAllocPoint = totalAllocPoint.add(_allocPoint); poolInfo.push( PoolInfo({ want: _want, allocPoint: _allocPoint, lastRewardBlock: 0, accAUTOPerShare: 0, 11 strat: _strat }) ); } Fix Status: The ownership has been transfer to timelock contract. Reference https://hecoinfo.com/tx/0xbe90b5dba8315b30a010ea957e9631154857b93d84cdb344c11b339b 5f3e5421 The authority of the Gov role is large, and the address of the external contract can be set arbitrarily. Malicious and wrong external contracts will cause the user's funds to be lost, and there is a issues of excessive authorityit is recommended to set the gov to the timelock contract.  AutofarmV2_CrossChain/StratX2.sol function setEntranceFeeFactor(uint256 _entranceFeeFactor) public { require(msg.sender == govAddress, \"!gov\"); require(_entranceFeeFactor >= entranceFeeFactorLL, \"!safe - too low\"); require(_entranceFeeFactor <= entranceFeeFactorMax, \"!safe - too high\"); entranceFeeFactor = _entranceFeeFactor; } function setWithdrawFeeFactor(uint256 _withdrawFeeFactor) public { require(msg.sender == govAddress, \"!gov\"); require(_withdrawFeeFactor >= withdrawFeeFactorLL, \"!safe - too low\"); require(_withdrawFeeFactor <= withdrawFeeFactorMax, \"!safe - too high\"); withdrawFeeFactor = _withdrawFeeFactor; } function setControllerFee(uint256 _controllerFee) public { require(msg.sender == govAddress, \"!gov\"); require(_controllerFee <= controllerFeeUL, \"too high\"); controllerFee = _controllerFee; } function setbuyBackRate(uint256 _buyBackRate) public { require(msg.sender == govAddress, \"!gov\"); 12 require(buyBackRate <= buyBackRateUL, \"too high\"); buyBackRate = _buyBackRate; } function setGov(address _govAddress) public { require(msg.sender == govAddress, \"!gov\"); govAddress = _govAddress; } function setOnlyGov(bool _onlyGov) public { require(msg.sender == govAddress, \"!gov\"); onlyGov = _onlyGov; } function setUniRouterAddress(address _uniRouterAddress) public { require(msg.sender == govAddress, \"!gov\"); uniRouterAddress = _uniRouterAddress; } function setBuyBackAddress(address _buyBackAddress) public { require(msg.sender == govAddress, \"!gov\"); buyBackAddress = _buyBackAddress; } function setRewardsAddress(address _rewardsAddress) public { require(msg.sender == govAddress, \"!gov\"); rewardsAddress = _rewardsAddress; } Fix Status: The Gov has been transfer to timelock contract. Reference https://hecoinfo.com/tx/0xfdf183915b5659473f9e8e3438c295cb859e022faa073a0a8f12c38e0a 4c257d",
        "labels": [
            "SlowMist",
            "autofarm",
            "Severity: Medium"
        ]
    },
    {
        "title": "4.2.2.2 DoS issues",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - autofarm_en-us.pdf",
        "body": "In the massUpdatePools function, if the length of poolInfo is too large, there is a risk of DoS. It is 13 recommended to limit poolInfo.length to avoid DoS caused by too large length.  AutofarmV2_CrossChain/AutoFarmV2_CrossChain.sol function massUpdatePools() public { uint256 length = poolInfo.length; for (uint256 pid = 0; pid < length; ++pid) { updatePool(pid); } } Fix Status: The issue has been fixed in this commit: b27f2cafcf51667726bd70220420707c89b75975",
        "labels": [
            "SlowMist",
            "autofarm",
            "Severity: Medium"
        ]
    },
    {
        "title": "4.2.3.1 Missing event log",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - autofarm_en-us.pdf",
        "body": "\"setEntranceFeeFactor\" function, \"setWithdrawFeeFactor\" function, \"setControllerFee\" function, \"setbuyBackRate\" function, \"setGov\" function, \"setOnlyGov\" function, \"setUniRouterAddress\" function, \"setBuyBackAddress\" function, \"setRewardsAddress\" function, no events are added to record. It is recommended to add events for recording.  AutofarmV2_CrossChain/StratX2_MDEX.sol  AutofarmV2_CrossChain/StratVLEV2.sol function setEntranceFeeFactor(uint256 _entranceFeeFactor) public { require(msg.sender == govAddress, \"!gov\"); require(_entranceFeeFactor >= entranceFeeFactorLL, \"!safe - too low\"); require(_entranceFeeFactor <= entranceFeeFactorMax, \"!safe - too high\"); entranceFeeFactor = _entranceFeeFactor; } function setWithdrawFeeFactor(uint256 _withdrawFeeFactor) public { require(msg.sender == govAddress, \"!gov\"); require(_withdrawFeeFactor >= withdrawFeeFactorLL, \"!safe - too low\"); 14 require(_withdrawFeeFactor <= withdrawFeeFactorMax, \"!safe - too high\"); withdrawFeeFactor = _withdrawFeeFactor; } function setControllerFee(uint256 _controllerFee) public { require(msg.sender == govAddress, \"!gov\"); require(_controllerFee <= controllerFeeUL, \"too high\"); controllerFee = _controllerFee; } function setbuyBackRate(uint256 _buyBackRate) public { require(msg.sender == govAddress, \"!gov\"); require(buyBackRate <= buyBackRateUL, \"too high\"); buyBackRate = _buyBackRate; } function setGov(address _govAddress) public { require(msg.sender == govAddress, \"!gov\"); govAddress = _govAddress; } function setOnlyGov(bool _onlyGov) public { require(msg.sender == govAddress, \"!gov\"); onlyGov = _onlyGov; } function setUniRouterAddress(address _uniRouterAddress) public { require(msg.sender == govAddress, \"!gov\"); uniRouterAddress = _uniRouterAddress; } function setBuyBackAddress(address _buyBackAddress) public { require(msg.sender == govAddress, \"!gov\"); buyBackAddress = _buyBackAddress; } function setRewardsAddress(address _rewardsAddress) public { require(msg.sender == govAddress, \"!gov\"); rewardsAddress = _rewardsAddress; } Fix Status: 15 The issue has been fixed in this commit: b27f2cafcf51667726bd70220420707c89b75975",
        "labels": [
            "SlowMist",
            "autofarm",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.2.3.2 Missing nonReentrant modifier",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - autofarm_en-us.pdf",
        "body": "The deposit function missing the nonReentrant modifier, it is recommended to add the nonReentrant modifier.  AutofarmV2_CrossChain/StratX2_MDEX.sol function deposit(address _userAddress, uint256 _wantAmt) public onlyOwner whenNotPaused returns (uint256) IERC20(wantAddress).safeTransferFrom( address(msg.sender), address(this), _wantAmt ); uint256 sharesAdded = _wantAmt; if (wantLockedTotal > 0 && sharesTotal > 0) { sharesAdded = _wantAmt .mul(sharesTotal) .mul(entranceFeeFactor) .div(wantLockedTotal) .div(entranceFeeFactorMax); } sharesTotal = sharesTotal.add(sharesAdded); if (isAutoComp) { _farm(); } else { wantLockedTotal = wantLockedTotal.add(_wantAmt); } return sharesAdded; 16 { } Fix Status: The issue has been fixed in this commit: b27f2cafcf51667726bd70220420707c89b75975 5.",
        "labels": [
            "SlowMist",
            "autofarm",
            "Severity: Informational"
        ]
    },
    {
        "title": "Risk of external call",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cook Finance_en-us.pdf",
        "body": "BasicIssuanceModule has many external call, it suggested to be aware of the risk of external call e.g. initialize function function initialize( ICKToken _ckToken, IManagerIssuanceHook _preIssueHook ) external onlyCKManager(_ckToken, msg.sender) onlyValidAndPendingCK(_ckToken) 10 { managerIssuanceHook[_ckToken] = _preIssueHook; //SlowMist// Please be aware of the risk of external call _ckToken.initializeModule(); }",
        "labels": [
            "SlowMist",
            "Cook Finance",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of sandwich attack",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cook Finance_en-us.pdf",
        "body": "In SingleIndexModule, the trade function does not set a slippage protection when trade, which may results in sandwich attack. function trade(address _component) external nonReentrant onlyAllowedTrader(msg.sender) onlyEOA() virtual { _validateTradeParameters(_component); //@audit not check assetInfo[component] before trade. ( bool isBuy, uint256 tradeAmount //SlowMist// There is no slippage protection inside _calculateTradeSizeAndDirection ) = _calculateTradeSizeAndDirection(_component); if (isBuy) { //@audit no check if tradeAmount is larger than component _buyUnderweight(_component, tradeAmount); } else { _sellOverweight(_component, tradeAmount); } assetInfo[_component].lastTradeTimestamp = block.timestamp; } 11",
        "labels": [
            "SlowMist",
            "Cook Finance",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Risk of re-initialization",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cook Finance_en-us.pdf",
        "body": "The initialize function of SingleIndexModule, TradeModule and WarpModule were not restricted to can only be called once. //SlowMist// No restriction on initialization function initialize(ICKToken _index) external onlyCKManager(_index, msg.sender) onlyValidAndPendingCK(_index) { require(address(index) == address(0), \"Module already in use\"); ICKToken.Position[] memory positions = _index.getPositions(); for (uint256 i = 0; i < positions.length; i++) { ICKToken.Position memory position = positions[i]; assetInfo[position.component].targetUnit = position.unit.toUint256(); assetInfo[position.component].lastTradeTimestamp = 0; } index = _index; _index.initializeModule(); }",
        "labels": [
            "SlowMist",
            "Cook Finance",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "No check the _receiveToken address",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cook Finance_en-us.pdf",
        "body": "The trade function of TradeModule does not check if _receiveToken is allowed to trade. function trade( ICKToken _ckToken, string memory _exchangeName, address _sendToken, uint256 _sendQuantity, address _receiveToken, uint256 _minReceiveQuantity, bytes memory _data ) external nonReentrant onlyManagerAndValidCK(_ckToken) { TradeInfo memory tradeInfo = _createTradeInfo( _ckToken, _exchangeName, _sendToken, _receiveToken, _sendQuantity, _minReceiveQuantity ); _validatePreTradeData(tradeInfo, _sendQuantity); _executeTrade(tradeInfo, _data); uint256 exchangedQuantity = _validatePostTrade(tradeInfo); uint256 protocolFee = _accrueProtocolFee(tradeInfo, exchangedQuantity); ( 13 uint256 netSendAmount, uint256 netReceiveAmount ) = _updateCKTokenPositions(tradeInfo); emit ComponentExchanged( _ckToken, _sendToken, _receiveToken, tradeInfo.exchangeAdapter, netSendAmount, netReceiveAmount, protocolFee ); }",
        "labels": [
            "SlowMist",
            "Cook Finance",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Risk of replay attack",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Coordinape protocol_en-us.pdf",
        "body": "In the ApeToken contract, DOMAIN_SEPARATOR is dened when the contract is initialized, but it is not reimplemented when DOMAIN_SEPARATOR is used in the permit function. So the DOMAIN_SEPARATOR contains 15 the chainId and is dened at contract deployment instead of reconstructed for every signature, there is a risk of possible replay attacks between chains in the event of a future chain split. coordinape-protocol/contracts/ApeProtocol/token/ApeToken.sol#L18 constructor() { uint chainId = block.chainid; DOMAIN_SEPARATOR = keccak256( abi.encode( keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'), keccak256(bytes(\"coordinape.com\")), keccak256(bytes('1')), chainId, address(this) ) ); } coordinape-protocol/contracts/ApeProtocol/token/ApeToken.sol#L42 function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public { require(block.timestamp <= deadline, \"COToken: expired deadline\"); require(owner != address(0), \"COToken: owner can't be ZERO address \"); bytes32 digest = keccak256( abi.encode( DOMAIN_SEPARATOR, '\\x19\\x01', keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline)) ) ); address signer = ECDSA.recover(digest, v, r, s); require(signer == owner, \"COToken: invalid signature\"); 16 _approve(owner, spender, value); }",
        "labels": [
            "SlowMist",
            "Coordinape protocol",
            "Type: Replay Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing event records",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Coordinape protocol_en-us.pdf",
        "body": "Missing event records are not conducive to the review of community users. coordinape-protocol/contracts/ApeProtocol/token/TokenAccessControl.sol#L32-47 function disableAllowlist() external onlyOwner { require(!allowlistDisabled, \"AccessControl: Allowlist already disabled\"); } allowlistDisabled = true; function changePauseStatus(bool _status) external onlyOwner { require(!foreverUnpaused, \"AccessControl: Contract is unpaused forever\"); } paused = _status; function disablePausingForever() external onlyOwner { require(!foreverUnpaused, \"AccessControl: Contract is unpaused forever\"); } foreverUnpaused = true; paused = false; 17 coordinape-protocol/contracts/ApeProtocol/token/TokenAccessControl.sol#L81-84 function disableMintingForever() external onlyOwner { require(!mintingDisabled, \"AccessControl: Contract cannot mint anymore\"); } mintingDisabled = true; coordinape-protocol/contracts/ApeProtocol/wrapper/beacon/ApeBeacon.sol#L23-28 function transferProxyOwnership(address _newOwner) external { require(msg.sender == proxyOwner()); assembly { sstore(_OWNER_SLOT, _newOwner) } } coordinape-protocol/contracts/ApeProtocol/wrapper/beacon/ApeRegistryBeacon.sol#37-L40 function pushNewImplementation(address _newImplementation) public itself { require(Address.isContract(_newImplementation), \"ApeRegistryBeacon: implementaion is not a contract\"); deployments[++deploymentCount] = _newImplementation; } coordinape-protocol/contracts/ApeProtocol/ApeRegistry.sol#L17-L35 function setFeeRegistry(address _registry) external itself { feeRegistry = _registry; } function setRouter(address _router) external itself { router = _router; } function setDistributor(address _distributor) external itself { distributor = _distributor; } 18 function setFactory(address _factory) external itself { factory = _factory; } function setTreasury(address _treasury) external itself { treasury = _treasury; } coordinape-protocol/contracts/ApeProtocol/ApeRouter.sol#L87-L89 function setRegistry(address _registry) external itself { yearnRegistry = _registry; }",
        "labels": [
            "SlowMist",
            "Coordinape protocol",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Coding optimization",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Coordinape protocol_en-us.pdf",
        "body": "getVariableFee function does not modify contract data, but does not use view. coordinape-protocol/contracts/ApeProtocol/FeeRegistry.sol#L24 function getVariableFee(uint256 _yield, uint256 _tapTotal) external returns(uint256 variableFee) { if (!on) return 0; uint256 yieldRatio = _yield * 1000 / _tapTotal; uint256 baseFee = 100; if (yieldRatio >= 900) variableFee = baseFee; // 1% @ 90% yield ratio else if (yieldRatio >= 800) variableFee = baseFee + 25; // 1.25% @ 80% yield ratio 19 else if (yieldRatio >= 700) variableFee = baseFee + 50; // 1.50% @ 70% yield ratio else if (yieldRatio >= 600) variableFee = baseFee + 75; // 1.75% @ 60% yield ratio else if (yieldRatio >= 500) variableFee = baseFee + 100; // 2.00% @ 80% yield ratio else if (yieldRatio >= 400) variableFee = baseFee + 125; // 2.25% @ 80% yield ratio else if (yieldRatio >= 300) variableFee = baseFee + 150; // 2.50% @ 80% yield ratio else if (yieldRatio >= 200) variableFee = baseFee + 175; // 2.75% @ 80% yield ratio else if (yieldRatio >= 100) variableFee = baseFee + 200; // 3.00% @ 80% yield ratio else } variableFee = baseFee + 250; // 3.50% @ 0% yield ratio",
        "labels": [
            "SlowMist",
            "Coordinape protocol",
            "Type: Authority Control Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Business logic is not clear",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Coordinape protocol_en-us.pdf",
        "body": "The _issueInvite function will execute the mint logic, but the burn is annotated in _revokeInvite, the business logic is not clear. coordinape-protocol/contracts/circles_obsolete/CoordinapeCircle.sol#L158-L175 function _issueInvite(address recipient, uint8 role) internal { Counters.increment(_inviteIds); uint256 tokenId = Counters.current(_inviteIds); _mint(recipient, tokenId); _roles[tokenId] = role; 20 _invites[recipient] = tokenId; _vouches[recipient] = 0; emit InviteIssued(recipient, role); } function _revokeInvite(address recipient) internal { uint256 tokenId = _invites[recipient]; _inactiveMembers.increment(); //_burn(tokenId); _roles[tokenId] = 0; _invites[recipient] = 0; emit InviteRevoked(recipient, 0); } _epochEnds is never initialized, and used in _epochInProgress function. coordinape-protocol/contracts/circles_obsolete/CoordinapeCircle.sol#L155 function _epochInProgress() internal view returns (bool) { uint256 epochId = Counters.current(_epochIds); // return epochId > 0 && !CoordinapeEpoch(_epochs[epochId]).ended(); return epochId > 0 && block.number < _epochEnds[epochId]; } _epochState is never initialized. and it is used in state function. coordinape-protocol/contracts/circles_obsolete/CoordinapeCircle.sol#L105 function state(uint256 _epoch) external view returns (uint8) { return _epochState[_epoch]; } The address passed in by the _migrate function is address(this), which means migrating to the address(this) contract, the logic here is not clear. coordinape-protocol/contracts/ApeProtocol/wrapper/beacon/ApeVault.sol#L166-L169 21 function apeMigrate() external onlyOwner returns(uint256 migrated){ migrated = _migrate(address(this)); vault = VaultAPI(registry.latestVault(address(token))); } migrated = _deposit(address(this), account, withdrawn, false); account is address(this), the logic here is wrong coordinape-protocol/contracts/ApeProtocol/wrapper/beacon/BaseWrapperImplementation.sol#L387-L427 function _migrate(address account) internal returns (uint256) { return _migrate(account, MIGRATE_EVERYTHING); } function _migrate(address account, uint256 amount) internal returns (uint256) { // NOTE: In practice, it was discovered that <50 was the maximum we've see for this variance return _migrate(account, amount, 0); } function _migrate( address account, uint256 amount, uint256 maxMigrationLoss ) internal returns (uint256 migrated) { VaultAPI _bestVault = bestVault(); // NOTE: Only override if we aren't migrating everything uint256 _depositLimit = _bestVault.depositLimit(); uint256 _totalAssets = _bestVault.totalAssets(); if (_depositLimit <= _totalAssets) return 0; // Nothing to migrate (not a failure) uint256 _amount = amount; if (_depositLimit < UNCAPPED_DEPOSITS && _amount < WITHDRAW_EVERYTHING) { // Can only deposit up to this amount uint256 _depositLeft = _depositLimit.sub(_totalAssets); if (_amount > _depositLeft) _amount = _depositLeft; } 22 if (_amount > 0) { // NOTE: `false` = don't withdraw from `_bestVault` uint256 withdrawn = _withdraw(account, address(this), _amount, false); if (withdrawn == 0) return 0; // Nothing to migrate (not a failure) // NOTE: `false` = don't do `transferFrom` because it's already local migrated = _deposit(address(this), account, withdrawn, false); // NOTE: Due to the precision loss of certain calculations, there is a small inefficency // on how migrations are calculated, and this could lead to a DoS issue. Hence, this // value is made to be configurable to allow the user to specify how much is acceptable require(withdrawn.sub(migrated) <= maxMigrationLoss); } // else: nothing to migrate! (not a failure) } The return value of decimals is 0, and developers need to conrm the business logic here. coordinape-protocol/contracts/circles_obsolete/CoordinapeEpoch.sol#L143-L145 function decimals() public pure override returns (uint8) { return 0; }",
        "labels": [
            "SlowMist",
            "Coordinape protocol",
            "Type: Others",
            "Severity: High"
        ]
    },
    {
        "title": "Coding standards issues 23",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Coordinape protocol_en-us.pdf",
        "body": "Executed rst _call(id, _target, _data); and then executed timestamps[id] = _DONE_TIMESTAMP; , which does not meet the specication(Checks-Eects-Interactions). coordinape-protocol/contracts/ApeProtocol/TimeLock.sol#L72-L73 function execute(address _target, bytes calldata _data, bytes32 _predecessor, bytes32 _salt, uint256 _delay) external onlyOwner { bytes32 id = hashOperation(_target, _data, _predecessor, _salt); require(isReadyCall(id), \"TimeLock: Not ready for execution or executed\"); require(_predecessor == bytes32(0) || isDoneCall(_predecessor), \"TimeLock: Predecessor call not executed\"); _call(id, _target, _data); timestamps[id] = _DONE_TIMESTAMP; } function _call( bytes32 id, address target, bytes calldata data ) internal { (bool success, ) = target.call(data); require(success, \"Timelock: underlying transaction reverted\"); emit CallExecuted(id, target, data); }",
        "labels": [
            "SlowMist",
            "Coordinape protocol",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "The external call does not judge the return value 24",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Coordinape protocol_en-us.pdf",
        "body": "The external call in the _withdraw function does not evaluate the return value E.g vaults[id].transferFrom , vault.transfer , IERC20(_token).transfer If the transferFrom function and transfer of the externally called token contract return false, the code logic will be wrong. coordinape-protocol/contracts/ApeProtocol/wrapper/beacon/BaseWrapperImplementation.sol#L353-L362 function _withdraw( address sender, address receiver, uint256 amount, // if `MAX_UINT256`, just withdraw everything bool withdrawFromBest // If true, also withdraw from `_bestVault` ) internal returns (uint256 withdrawn) { VaultAPI _bestVault = bestVault(); VaultAPI[] memory vaults = allVaults(); _updateVaultCache(vaults); // NOTE: This loop will attempt to withdraw from each Vault in `allVaults` that `sender` // is deposited in, up to `amount` tokens. The withdraw action can be expensive, // so it if there is a denial of service issue in withdrawing, the downstream usage // of this wrapper contract must give an alternative method of withdrawing using // this function so that `amount` is less than the full amount requested to withdraw // (e.g. \"piece-wise withdrawals\"), leading to less loop iterations such that the // DoS issue is mitigated (at a tradeoff of requiring more txns from the end user). for (uint256 id = 0; id < vaults.length; id++) { if (!withdrawFromBest && vaults[id] == _bestVault) { continue; // Don't withdraw from the best } 25 // Start with the total shares that `sender` has uint256 availableShares = vaults[id].balanceOf(sender); // Restrict by the allowance that `sender` has to this contract // NOTE: No need for allowance check if `sender` is this contract if (sender != address(this)) { availableShares = Math.min(availableShares, vaults[id].allowance(sender, address(this))); } // Limit by maximum withdrawal size from each vault availableShares = Math.min(availableShares, vaults[id].maxAvailableShares()); if (availableShares > 0) { // Intermediate step to move shares to this contract before withdrawing // NOTE: No need for share transfer if this contract is `sender` // if (sender != address(this)) vaults[id].transferFrom(sender, address(this), availableShares); if (amount != WITHDRAW_EVERYTHING) { // Compute amount to withdraw fully to satisfy the request uint256 estimatedShares = amount .sub(withdrawn) // NOTE: Changes every iteration .mul(10**uint256(vaults[id].decimals())) .div(vaults[id].pricePerShare()); // NOTE: Every Vault is different // Limit amount to withdraw to the maximum made available to this contract // NOTE: Avoid corner case where `estimatedShares` isn't precise enough // NOTE: If `0 < estimatedShares < 1` but `availableShares > 1`, this will withdraw more than necessary if (estimatedShares > 0 && estimatedShares < availableShares) { if (sender != address(this)) vaults[id].transferFrom(sender, address(this), estimatedShares); withdrawn = withdrawn.add(vaults[id].withdraw(estimatedShares)); } else { if (sender != address(this)) vaults[id].transferFrom(sender, address(this), availableShares); 26 withdrawn = withdrawn.add(vaults[id].withdraw(availableShares)); } } else { if (sender != address(this)) vaults[id].transferFrom(sender, address(this), availableShares); withdrawn = withdrawn.add(vaults[id].withdraw()); } // Check if we have fully satisfied the request // NOTE: use `amount = WITHDRAW_EVERYTHING` for withdrawing everything if (amount <= withdrawn) break; // withdrawn as much as we needed } } // If we have extra, deposit back into `_bestVault` for `sender` // NOTE: Invariant is `withdrawn <= amount` if (withdrawn > amount && withdrawn.sub(amount) > _bestVault.pricePerShare().div(10**_bestVault.decimals())) { // Don't forget to approve the deposit if (token.allowance(address(this), address(_bestVault)) < withdrawn.sub(amount)) { token.safeApprove(address(_bestVault), UNLIMITED_APPROVAL); // Vaults are trusted } _bestVault.deposit(withdrawn.sub(amount), sender); withdrawn = amount; } // `receiver` now has `withdrawn` tokens as balance if (receiver != address(this)) token.safeTransfer(receiver, withdrawn); } coordinape-protocol/contracts/ApeProtocol/ApeDistributor.sol#L147 function tapEpochAndDistribute( address _vault, bytes32 _circle, address _token, address[] calldata _users, 27 uint256[] calldata _amounts, uint256 _amount, uint8 _tapType) external { require(_users.length == _amounts.length, \"ApeDistributor: Array lengths do not match\"); require(sum(_amounts) == _amount, \"ApeDistributor: Amount does not match sum of values\"); _tap(_vault, _circle, _token, _amount, _tapType, bytes32(type(uint256).max)); for (uint256 i = 0; i < _users.length; i++) IERC20(_token).transfer(_users[i], _amounts[i]); } coordinape-vesting-contracts/contracts/Vesting.sol#L77-L99 function fetchTokens(uint256 _amount) external onlyOwner { IERC20(co).transfer(msg.sender, _amount); } function claim(uint256 _index) external override { uint256 _now = block.timestamp; Vehicule storage vehicule = vehicules[msg.sender][_index]; uint256 upfront = _claimUpfront(vehicule); uint256 start = vehicule.start; if (start == 0) revert(\"Vesting: vehicule does not exist\"); require(_now > start, \"Vesting: cliff !started\"); uint256 end = vehicule.end; uint256 elapsed = min(end, _now) - start; uint256 maxDelta = end - start; // yield = amount * delta / vest_duration - claimed_amount uint256 yield = (vehicule.amount * elapsed / maxDelta) - vehicule.claimed; vehicule.claimed += yield; IERC20(co).transfer(msg.sender, yield + upfront); 28 emit YieldClaimed(msg.sender, yield); }",
        "labels": [
            "SlowMist",
            "Coordinape protocol",
            "Type: Unsafe External Call Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Excessive authority issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Coordinape protocol_en-us.pdf",
        "body": "Owner can transfer assets in the contract. coordinape-protocol/contracts/ApeProtocol/wrapper/beacon/ApeVault.sol#L129 function apeWithdrawSimpleToken(uint256 _amount) public onlyOwner { simpleToken.safeTransfer(msg.sender, _amount); } coordinape-protocol/contracts/ApeProtocol/wrapper/beacon/ApeVault.sol#L139 function apeWithdraw(uint256 _shareAmount, bool _underlying) external onlyOwner { uint256 underlyingAmount = shareValue(_shareAmount); require(underlyingAmount <= underlyingValue, \"underlying amount higher than vault value\"); address router = ApeRegistry(apeRegistry).router(); underlyingValue -= underlyingAmount; vault.safeTransfer(router, _shareAmount); ApeRouter(router).delegateWithdrawal(owner(), address(this), vault.token(), _shareAmount, _underlying); } 29 coordinape-protocol/contracts/ApeProtocol/wrapper/beacon/ApeVault.sol#L154 function exitVaultToken(bool _underlying) external onlyOwner { underlyingValue = 0; uint256 totalShares = vault.balanceOf(address(this)); address router = ApeRegistry(apeRegistry).router(); vault.safeTransfer(router, totalShares); ApeRouter(router).delegateWithdrawal(owner(), address(this), vault.token(), totalShares, _underlying); } Owner can transfer the tokens in the contract. coordinape-vesting-contracts/contracts/Vesting.sol#L77 function fetchTokens(uint256 _amount) external onlyOwner { IERC20(co).transfer(msg.sender, _amount); }",
        "labels": [
            "SlowMist",
            "Coordinape protocol",
            "Type: Authority Control Vulnerability",
            "Severity: High"
        ]
    },
    {
        "title": "Lack of permission checks 30",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Coordinape protocol_en-us.pdf",
        "body": "The createApeVault function does not perform permission checks. Anyone can create ApeVault. If the incoming parameters are malicious (malicious Token or incompatible Token), it will aect the funds in the project. coordinape-protocol/contracts/ApeProtocol/wrapper/beacon/ApeVaultFactory.sol#L22-L27 function createApeVault(address _token, address _simpleToken) external { bytes memory data = abi.encodeWithSignature(\"init(address,address,address,address,address)\", apeRegistry, _token, yearnRegistry, _simpleToken, msg.sender); ApeBeacon proxy = new ApeBeacon(beacon, msg.sender, data); vaultRegistry[address(proxy)] = true; emit VaultCreated(address(proxy)); }",
        "labels": [
            "SlowMist",
            "Coordinape protocol",
            "Type: Authority Control Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Low-level call issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - CFFv2_en-us.pdf",
        "body": "In the CRVExchangeV2 contract, the handleExtraToken function is used to perform the token transfer operation after the token swap. Low-level calls are used when transferring native tokens, but the amount of gas usage is not limited, which may lead to unknown security risks. ",
        "labels": [
            "SlowMist",
            "CFFv2",
            "Type: Others",
            "Severity: Low"
        ]
    },
    {
        "title": "Contract variable usage issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - CFFv2_en-us.pdf",
        "body": "In the IWbtcPoolBase contract, when the Controller role calls the deposit function, the deposit_wbtc_amount parameter will increase, but when the Controller role calls the withdraw function, the deposit_wbtc_amount parameter does not decrease accordingly. And the withdraw_wbtc_amount parameter in the contract is not used. 16 The deposit_eth_amount and withdraw_eth_amount parameters in the IETHPoolBase contract are the same. The deposit_usdc_amount and withdraw_usdc_amount parameters in the IUSDCPoolBase contract are the same. ",
        "labels": [
            "SlowMist",
            "CFFv2",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing event record",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - CFFv2_en-us.pdf",
        "body": "In the IWbtcPoolBase contract, the owner can modify the controller and vault addresses through the setController function, but no event recording is performed. ",
        "labels": [
            "SlowMist",
            "CFFv2",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Logical redundancy issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - CFFv2_en-us.pdf",
        "body": "In the AavePool contract, the withdraw_from_curve function will rst authorize the lp_token_addr token to the pool_deposit contract and then call the remove_liquidity_one_coin function of the pool_deposit contract to remove liquidity. However, since the minter role of the lp_token_addr contract is the pool_deposit contract, there is no need to perform an approve operation. ",
        "labels": [
            "SlowMist",
            "CFFv2",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Reentrancy risk 20",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - CFFv2_en-us.pdf",
        "body": "In the CFVaultV2 contract, the user can withdraw assets through the withdraw function, but in the withdraw function, it will rst transfer the assets to the user and then destroy the user's credentials through the destroyTokens function. If the transfer is native tokens, this will lead to a risk of reentrancy. ",
        "labels": [
            "SlowMist",
            "CFFv2",
            "Type: Reentrancy Vulnerability",
            "Severity: Critical"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - CFFv2_en-us.pdf",
        "body": "In the IWbtcPoolBase, IETHPoolBase and IUSDCPoolBase contracts, the owner can call any data through the callWithData function. Since these strategies contracts indirectly keep the user's assets, any data call will cause the risk of excessive owner authority. ",
        "labels": [
            "SlowMist",
            "CFFv2",
            "Type: Authority Control Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "4.2.1.1 __Guard_init function was not call when initialize",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Hot Cross BSC Bridge V1.0.0_en-us.pdf",
        "body": "ForeignProcessor contract and HomeRequest contract are inherit the Guard contract but dost not call the __Gurad_init function function __ForeignProcessor_init( IERC20 token, ValidatorRegistry validatorRegistry_ ) internal initializer { //SlowMist// Missing call of __Guard_init function require( address(token) != address(0) && Misc.isContract(address(token)), \"ForeignProcessor:Invalid erc20 address provided\" 10 ); require( address(validatorRegistry_) != address(0) && Misc.isContract(address(validatorRegistry_)), \"ForeignProcessor:Invalid validator registry address\" ); erc20 = token; validatorRegistry = validatorRegistry_; } function __HomeRequest_init( BEP20 token, ValidatorRegistry validatorRegistry_ ) internal initializer { //SlowMist// Missing call of __Guard_init function require( address(token) != address(0) && Misc.isContract(address(token)), \"HomeRequest:Invalid BEP20 address\" ); require( address(validatorRegistry_) != address(0) && Misc.isContract(address(validatorRegistry_)), \"HomeRequest:Invalid validator registry address\" ); bep20 = token; validatorRegistry = validatorRegistry_; } Fix status: fixed. 11 5.",
        "labels": [
            "SlowMist",
            "Hot Cross BSC Bridge V1.0.0",
            "Severity: Informational"
        ]
    },
    {
        "title": "Missing Checking",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap_en-us.pdf",
        "body": "In PancakeSwapRouter contract, the removeLiquidity / removeLiquidityETH / removeLiquidityWithPermit function does not check whether a pair is exist, which will leads to gas wasting when a pair does not exist. eg. removeLiquidity function function removeLiquidity( address tokenA, address tokenB, uint liquidity, uint amountAMin, uint amountBMin, address to, uint deadline ) public virtual override ensure(deadline) returns (uint amountA, uint amountB) { 13 address pair = PancakeLibrary.pairFor(factory, tokenA, tokenB); IPancakePair(pair).transferFrom(msg.sender, pair, liquidity); // send liquidity to pair (uint amount0, uint amount1) = IPancakePair(pair).burn(to); (address token0,) = PancakeLibrary.sortTokens(tokenA, tokenB); (amountA, amountB) = tokenA == token0 ? (amount0, amount1) : (amount1, amount0); require(amountA >= amountAMin, 'PancakeRouter: INSUFFICIENT_A_AMOUNT'); require(amountB >= amountBMin, 'PancakeRouter: INSUFFICIENT_B_AMOUNT'); }",
        "labels": [
            "SlowMist",
            "PancakeSwap",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Re-initialize issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cook Distribution and Reward_en-us.pdf",
        "body": "In RewardVesting contract, the Governance role can re-initialize the the contract through initialize function Location function initialize(IERC20 _cookReward) external onlyGovernance { cookReward = _cookReward; }",
        "labels": [
            "SlowMist",
            "Cook Distribution and Reward",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing authority check 7",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cook Distribution and Reward_en-us.pdf",
        "body": "The addEarning function exists in the RewardVesting contract. When the claim operation is performed in the StakingPool contract, if the corresponding reward needs to be time locked, the addEarning function of the RewardVesting contract will be called to perform the locking operation. However, the visibility of this function is external, which will cause any user to perform the addEarning operation.  function addEarning(address user, uint256 amount, uint256 durationInSecs) external { _addPendingEarning(user, amount, durationInSecs); cookReward.safeTransferFrom(msg.sender, address(this), amount); }",
        "labels": [
            "SlowMist",
            "Cook Distribution and Reward",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Gas optimization",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Laqira NFT marketplace_en-us.pdf",
        "body": "Using assert will consume the remaining gas when the transaction fails to execute. ",
        "labels": [
            "SlowMist",
            "Laqira NFT marketplace",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Unused return",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Laqira NFT marketplace_en-us.pdf",
        "body": "There is a return value in the setRoyalties function in the RoyaltiesProvider contract, and the function is called here without checking its return value. Laqira-Collectibles-and-NFT-Marketplace/contracts/LaqiraNFT.sol #L58-L76 function mint(string memory _tokenURI, address[] memory royaltyOwners, uint96[] memory values) public virtual payable { uint256 transferredAmount = msg.value; require(transferredAmount >= mintingFee, 'Insufficient paid amount'); (bool success, ) = feeAddress.call{value: transferredAmount}(new bytes(0)); 14 require(success, 'Transfer failed'); _tokenIds.increment(); uint256 newTokenId = _tokenIds.current(); pendingRequests.push(newTokenId); _pendingIds[newTokenId].owner = _msgSender(); _pendingIds[newTokenId].tokenURI = _tokenURI; _userPendingIds[_msgSender()].push(newTokenId); IRoyaltiesProvider(royaltiesProviderAddress).setRoyalties(newTokenId, royaltyOwners, values); }",
        "labels": [
            "SlowMist",
            "Laqira NFT marketplace",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing event record",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Laqira NFT marketplace_en-us.pdf",
        "body": "Modifying sensitive parameters in the contract does not log an event. Laqira-Collectibles-and-NFT-Marketplace/contracts/LaqiraNFT.sol #L123-L133 function setMintingFeeAmount(uint256 _amount) public virtual onlyOwner { mintingFee = _amount; } function setAsOperator(address _operator) public virtual onlyOwner { operators[_operator] = true; } function removeOperator(address _operator) public virtual onlyOwner { operators[_operator] = false; } 15 ",
        "labels": [
            "SlowMist",
            "Laqira NFT marketplace",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing zero address validation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Laqira NFT marketplace_en-us.pdf",
        "body": "Missing zero address validation when setting the address in the function. ",
        "labels": [
            "SlowMist",
            "Laqira NFT marketplace",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Gas optimization",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Starcrazy_en-us.pdf",
        "body": "Using assert in the contract will consume all the Gas. ",
        "labels": [
            "SlowMist",
            "Starcrazy",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Overow reminder",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Starcrazy_en-us.pdf",
        "body": "There are many places in the contract that do not use safe-math for operations, which may cause overow.",
        "labels": [
            "SlowMist",
            "Starcrazy",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Hardcoded reminders",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Starcrazy_en-us.pdf",
        "body": "The address in the contract is hardcoded and cannot be modied. ",
        "labels": [
            "SlowMist",
            "Starcrazy",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Return value not checked",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Starcrazy_en-us.pdf",
        "body": "The _depositFrom function calls the insert function to insert data. There is a return value in the insert function but the return value is not checked when it is called. ",
        "labels": [
            "SlowMist",
            "Starcrazy",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Authority control issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Starcrazy_en-us.pdf",
        "body": "The CEO has the right to modify the address of the genScience contract. If the modied genScience contract is an unaudited contract, there may be security risks. ",
        "labels": [
            "SlowMist",
            "Starcrazy",
            "Type: Authority Control Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "lack of authorization",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Starcrazy_en-us.pdf",
        "body": "49 In the AlianaMinting contract, the CEO has the right to call the withdrawsByCEO function (this function will calculate the reward) and emergencyWithdrawByCEO function (this function will not calculate the reward) to withdraw the tokens for the user without the user's authorization, and the withdrawn tokens will be in the same way returned to the user. ",
        "labels": [
            "SlowMist",
            "Starcrazy",
            "Type: Authority Control Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Business logic issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Starcrazy_en-us.pdf",
        "body": "The receiveApproval function exists in multiple contracts. The function is public and can be called by anyone. Anyone can use these functions to manipulate other users' assets, as long as the user has an authorization limit to the contract. However, this authorization limit is not set by the user. The authorization limit for each transaction of the user is calculated o-chain by the project team. The code here is not within the scope of this audit, so we will not be able to guarantee the security here. If there is an error in the calculation of the authorization limit.Anyone can call the receiveApproval function to deposit any user's tokens without authorization. ",
        "labels": [
            "SlowMist",
            "Starcrazy",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Redundant code",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Starcrazy_en-us.pdf",
        "body": "The require check for the action parameter in the following function is redundant. The location of redundant code will be marked with (//Slowmist// Redundant code here). ",
        "labels": [
            "SlowMist",
            "Starcrazy",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Parameter modication issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Starcrazy_en-us.pdf",
        "body": "The NFT in the project can be auctioned, and the CEO has the right to modify some sensitive parameters in the auction information, which will aect the results of the auction. ",
        "labels": [
            "SlowMist",
            "Starcrazy",
            "Type: Authority Control Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Missing event record",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Starcrazy_en-us.pdf",
        "body": "Events are not logged when sensitive parameters are modied in several places in the contract. ",
        "labels": [
            "SlowMist",
            "Starcrazy",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Partial logic not implemented",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Das Contract Reverse_en-us.pdf",
        "body": "In the setReverseName function of the ReverseLogic contract, after the previous check, the specic check logic when the owner is still 0 address is not implemented. ",
        "labels": [
            "SlowMist",
            "Das Contract Reverse",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Potential risk of arbitrarily setting reverse name",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Das Contract Reverse_en-us.pdf",
        "body": "In the ReverseLogic contract, the user can set the reverse name through the setReverseName function, which allows the contract to set itself. However, some contracts have the feature of arbitrary external calls, which will allow any user to set the reverse name of the contract. ",
        "labels": [
            "SlowMist",
            "Das Contract Reverse",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Redundant code",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - IHO V1.0.0_en-us.pdf",
        "body": "Ether is not accepted by default, which is a redundant code. cross-send/contracts/CrossSend.sol#L41-L47 initial-hotcross-oering/contracts/BaseIHO.sol#L67-L73 fallback () external payable { revert(\"cannot directly accept currency transfers\"); } receive () external payable { revert(\"cannot directly receive currency transfers\"); 15 }",
        "labels": [
            "SlowMist",
            "IHO V1.0.0",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Gas optimization",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - IHO V1.0.0_en-us.pdf",
        "body": "If one of the batch transfers fails, the transaction that was previously transferred normally will be reverted, but Gas has been consumed. It is a gas optimization issue here. cross-send/contracts/CrossSend.sol#L175-L210 function sendToken( IERC20 token, address[] memory recipients, uint256[] memory amounts ) private returns(uint256) { uint256 total = 0; for (uint256 i = 0; i < recipients.length ; i++) { require(_msgSender() != recipients[i], \"sender != recipient\"); token.safeTransferFrom(_msgSender(), recipients[i], amounts[i]); total += amounts[i]; } return total; } function sendNative( address[] memory recipients, uint256[] memory amounts ) private returns(uint256) { uint256 total = 0; 16 for (uint256 i = 0; i < recipients.length ; i++) { total += amounts[i]; (bool success, ) = payable(recipients[i]).call{value: amounts[i]}(\"\"); require(success, \"native transfer failed\"); } return total; }",
        "labels": [
            "SlowMist",
            "IHO V1.0.0",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of allowance amount abuse",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - IHO V1.0.0_en-us.pdf",
        "body": "There have an allowance amount in the contract, but the distributeTokenFee function does not limit the caller, and there is an issue of being called arbitrarily, but it can only transfer the balance of the sender to the feeCollector. cross-send/contracts/fee-managers/RecipientCountFee.sol#L65-L83 function distributeTokenFee( uint256 txRecipientCount, uint256, uint256, uint256, uint256, address sender ) public override { uint256 payableFee = txRecipientCount * tokenFeePerRecipient; 17 if(payableFee < minTokenFee) { payableFee = minTokenFee; } else if (payableFee > maxTokenFee) { payableFee = maxTokenFee; } token.safeTransferFrom(sender, feeCollector, payableFee); }",
        "labels": [
            "SlowMist",
            "IHO V1.0.0",
            "Type: Authority Control Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Price manipulation issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - IHO V1.0.0_en-us.pdf",
        "body": "The IOUPrice is calculated using totalFarmingTokenBalance. Attackers can control totalFarmingTokenBalance to manipulate IOUPrice. The current code does not nd the location where IOUPrice is used. Referencehttps://slowmist.medium.com/cream-hacked-analysis-us-130-million-hacked-95c9410320ca cross-yield/contracts/core/CrossYield.sol#L95-L101 function IOUPrice() public view returns (uint256) { uint256 IOUSupply = totalSupply(); return IOUSupply == 0 ? 1e18 : (totalFarmingTokenBalance() * 1e18) / IOUSupply; } 18 cross-yield/contracts/core/CrossYield.sol#L65-L67 function totalFarmingTokenBalance() public view returns (uint256) { return farmingToken().balanceOf(address(this)) + strategy.balanceOf(); }",
        "labels": [
            "SlowMist",
            "IHO V1.0.0",
            "Type: Others",
            "Severity: Medium"
        ]
    },
    {
        "title": "Sandwich attacks issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - IHO V1.0.0_en-us.pdf",
        "body": "There is no slippage check during swap, and there is a risk of sandwich attack. IPancakeRouter02(pcsRouter).swapExactTokensForTokens(cakeBalance, 0,cakeToBaseRoute, address(this), block.timestamp); IPancakeRouter02(pcsRouter) .swapExactTokensForTokens(toSwap, 0, route, address(this), block.timestamp); Reference https://medium.com/coinmonks/demystify-the-dark-forest-on-ethereum-sandwich-attacks-5a3aec9fa33e cross-yield/contracts/libs/OptimalSwap.sol#L14-L63 function prepareLiquidity( address cake, address[2] memory lpTokens, 19 address wbnb, address busd, address farmingToken, address pcsRouter, uint256 fee ) external { uint256 cakeBalance = IERC20(cake).balanceOf(address(this)); bool isCakeInLp = lpTokens[0] == cake || lpTokens[1] == cake; bool isWbnbBased = lpTokens[0] == wbnb || lpTokens[1] == wbnb; address baseToken = isWbnbBased ? wbnb : busd; // if cake is not part of the lp token, swap all cake for the base token if (!isCakeInLp) { address[] memory cakeToBaseRoute = new address[](2); cakeToBaseRoute[0] = cake; cakeToBaseRoute[1] = baseToken; IPancakeRouter02(pcsRouter) .swapExactTokensForTokens(cakeBalance, 0, cakeToBaseRoute, address(this), block.timestamp); } (uint256 reserve0, uint256 reserve1,) = IPancakePair(farmingToken).getReserves(); address[] memory route = new address[](2); uint256 lp0Bal = IERC20(lpTokens[0]).balanceOf(address(this)); uint256 lp1Bal = IERC20(lpTokens[1]).balanceOf(address(this)); uint256 toSwap; // The possible cases here are: // - Cake was not part of the LP token, so we swap for baseToken which could either be lpToken0 or lpToken // - Cake was part of the LP token, so it can either be lpTokens[0] or lpTokens[1] // So, depending on which token we have the highest balance for, we swap for the other one. if (lp0Bal > lp1Bal) { toSwap = SwapAmount.getSwapAmount(lp0Bal, reserve0, fee); route[0] = lpTokens[0]; route[1] = lpTokens[1]; } else { toSwap = SwapAmount.getSwapAmount(lp1Bal, reserve1, fee); route[0] = lpTokens[1]; route[1] = lpTokens[0]; 20 } // Perform the swap IPancakeRouter02(pcsRouter) .swapExactTokensForTokens(toSwap, 0, route, address(this), block.timestamp); } IPancakeRouter02(pcsRouter).swapExactTokensForTokens(toWbnb, 0, cakeToWbnbRoute, address(this), block.timestamp); cross-yield/contracts/strategies/StrategyCake.sol#L131 function collectFees() internal { // a percentant of the cake we get from the masterchef will be used to buy BNB and transfer to this address // this is the total fees that will be shared amongst the protocol, stategy dev and the harvester uint256 toWbnb = feeManager.calculateTotalFee(IERC20(farmingToken).balanceOf(address(this))); IPancakeRouter02(pcsRouter).swapExactTokensForTokens(toWbnb, 0, cakeToWbnbRoute, address(this), block.timestamp); uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this)); // distribute hervester fee uint256 harvesterFeeAmount = feeManager.calculateHarvestFee(wbnbBal); // collectFees is called indirectly from the CrossYield contract via the beforeDeposit hook. // This means that _msgSender() is the CrossYield contract and not the actuall EOA account // that send the transaction IERC20(wbnb).safeTransfer(tx.origin, harvesterFeeAmount); // distribute protocol fee uint256 protocolFeeAmount = feeManager.calculateProtocolFee(wbnbBal); // IERC20(wbnb).safeTransfer(protocolFeeRecipient, protocolFeeAmount); feeProcessor.process(protocolFeeAmount); // distribute strategy dev fee uint256 strategyDevFeeAmount = feeManager.calculateStrategyDevFee(wbnbBal); IERC20(wbnb).safeTransfer(feeManager.strategyDev(), strategyDevFeeAmount); emit FeeCollected( toWbnb, 21 harvesterFeeAmount, protocolFeeAmount, strategyDevFeeAmount, _msgSender() ); } cross-yield/contracts/strategies/StrategyCakeLP.sol#L174 function collectFees() internal { // a percentant of the cake we get from the masterchef will be used to buy BNB and transfer to this address // this is the total fees that will be shared amongst the protocol, stategy dev and the harvester uint256 toWbnb = feeManager.calculateTotalFee(IERC20(cake).balanceOf(address(this))); IPancakeRouter02(pcsRouter).swapExactTokensForTokens(toWbnb, 0, cakeToWbnbRoute, address(this), block.timestamp); uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this)); // distribute hervester fee uint256 harvesterFeeAmount = feeManager.calculateHarvestFee(wbnbBal); IERC20(wbnb).safeTransfer(_msgSender(), harvesterFeeAmount); // distribute protocol fee uint256 protocolFeeAmount = feeManager.calculateProtocolFee(wbnbBal); feeProcessor.process(protocolFeeAmount); // distribute strategy dev fee uint256 strategyDevFeeAmount = feeManager.calculateStrategyDevFee(wbnbBal); IERC20(wbnb).safeTransfer(feeManager.strategyDev(), strategyDevFeeAmount); emit FeeCollected( toWbnb, harvesterFeeAmount, protocolFeeAmount, strategyDevFeeAmount, _msgSender() ); } cross-yield/contracts/strategies/StrategyCake.sol 22 function harvest() public override whenNotPaused { // claim rewards IMasterChef(masterchef).leaveStaking(0); // because harvest can automatically be called after each user deposit // we might end up having multiple deposits in the same block and only one // would return rewards from masterchef so the rest will have 0 cake so // we don't need to waste gas to collect fees and call deposit uint256 farmingTokenBalance = balanceOfFarmingToken(); if(farmingTokenBalance > 0) { collectFees(); deposit(); emit HarvestTriggered(_msgSender(), farmingTokenBalance); } } cross-yield/contracts/strategies/StrategyCakeLP.sol#l137-L148 function harvest() external override whenNotPaused { // claim rewards IMasterChef(masterchef).deposit(poolId, 0); uint256 harvestedAmount = IERC20(cake).balanceOf(address(this)); collectFees(); addLiquidity(); deposit(); emit HarvestTriggered(_msgSender(), harvestedAmount); }",
        "labels": [
            "SlowMist",
            "IHO V1.0.0",
            "Type: Reordering Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Missing slippage check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - IHO V1.0.0_en-us.pdf",
        "body": "The addLiquidity function without slippage check, it doesn't have an impermanent loss check. cross-yield/contracts/strategies/StrategyCakeLP.sol#L218 function addLiquidity() internal { OptimalSwap.prepareLiquidity( cake, [lpToken0, lpToken1], wbnb, busd, farmingToken, pcsRouter, swapFee ); // add liquidity to AMM on PCS uint256 lp0Bal = IERC20(lpToken0).balanceOf(address(this)); uint256 lp1Bal = IERC20(lpToken1).balanceOf(address(this)); IPancakeRouter02(pcsRouter) .addLiquidity(lpToken0, lpToken1, lp0Bal, lp1Bal, 0, 0, address(this), block.timestamp); emit LiquidityAdded(lpToken0, lpToken1, lp0Bal, lp1Bal, _msgSender()); }",
        "labels": [
            "SlowMist",
            "IHO V1.0.0",
            "Type: Reordering Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Permission check Missing",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - IHO V1.0.0_en-us.pdf",
        "body": "There is no permission check for deposit function. The function is called by the CrossYieid contract. cross-yield/contracts/strategies/StrategyCakeLP.sol#L225-L231 function deposit() public override whenNotPaused { uint256 farmingTokenBalance = balanceOfFarmingToken(); if (farmingTokenBalance > 0) { IMasterChef(masterchef).deposit(poolId, farmingTokenBalance); } } cross-yield/contracts/strategies/StrategyCake.sol#L169-L175 function deposit() public override whenNotPaused { uint256 farmingTokenBalance = balanceOfFarmingToken(); if (farmingTokenBalance > 0) { IMasterChef(masterchef).enterStaking(farmingTokenBalance); } }",
        "labels": [
            "SlowMist",
            "IHO V1.0.0",
            "Type: Authority Control Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Excessive authority issue 25",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - IHO V1.0.0_en-us.pdf",
        "body": "Owner can modify the address of the strategy. The new strategy may have security risks if it is not audited, which will aect the user's funds. If the private key is leaked, it will aect the user's funds. cross-yield/contracts/core/CrossYield.sol#L224-L236 function upgradeStrategy() public onlyOwner { require(stratCandidate.strategy != address(0), \"No proposal exists\"); require(block.number > stratCandidate.proposedBlock + stratUpgradableAfter, \"Strategy cannot be replaced yet\"); emit NewStrategy(stratCandidate.strategy); strategy.retireStrategy(); strategy = IStrategy(stratCandidate.strategy); stratCandidate.strategy = address(0); stratCandidate.proposedBlock = 0; putFundsToWork(); } cross-yield/contracts/core/CrossYield.sol#L211-L220 function proposeStrategy(address _strategy) public onlyOwner { require(address(this) == IStrategy(_strategy).vault(), \"Invalid new strategy\"); stratCandidate = StrategyCandidate({ strategy: _strategy, proposedBlock: block.number }); emit NewStratCandidate(_strategy); }",
        "labels": [
            "SlowMist",
            "IHO V1.0.0",
            "Type: Authority Control Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Repeatable claims issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - IHO V1.0.0_en-us.pdf",
        "body": "After the claim, lottery.status is not set as claimed, and it is also necessary to check whether lotteryId has been claimed when the claim is executed. hotdrop/contracts/HotDrop.sol#L261-L274 function claim(uint256 lotteryId) external nonReentrant { Lottery storage lottery = lotteries[lotteryId]; require(lottery.status == Status.WinnerDrawn, \"winner not drawn\"); // if there is no winner transfer the total amount to the treasury if(tickets[lotteryId][lottery.winningNumber] == address(0)) { lottery.purchaseToken.safeTransfer(treasury, lottery.purchaseToken.balanceOf(address(this))); } else if(tickets[lotteryId][lottery.winningNumber] == _msgSender()) { // if the ticket is the winning ticket and belongs to the user then split the pot uint256 treasuryAmount = (lottery.totalRaised * lottery.treasuryFee) / FEE_BASE; lottery.purchaseToken.safeTransfer(treasury, treasuryAmount); lottery.purchaseToken.safeTransfer(_msgSender(), lottery.totalRaised - treasuryAmount); } }",
        "labels": [
            "SlowMist",
            "IHO V1.0.0",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Round plan security reminder",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - IHO V1.0.0_en-us.pdf",
        "body": "And the new round of lottery can only be opened when the last round of lottery is in WinnerDrawn, otherwise randomGenerator.latestLotteryId will be updated, which will cause the old lottery round to fail to execute drawWinner function due to this check. require(lotteryId == randomGenerator.latestLotteryId(), \"numbers not drawn\"); hotdrop/contracts/HotDrop.sol#L44-L256 function drawWinner(uint256 lotteryId) external nonReentrant { Lottery storage lottery = lotteries[lotteryId]; require(lottery.status == Status.Close, \"lottery still active\"); require(lotteryId == randomGenerator.latestLotteryId(), \"numbers not drawn\"); // get the winning number based on the randomResult generated by ChainLink's fallback uint256 winningNumber = randomGenerator.randomResult(); lottery.winningNumber = winningNumber; lottery.status = Status.WinnerDrawn; emit LotteryNumberDrawn(lotteryId, winningNumber); }",
        "labels": [
            "SlowMist",
            "IHO V1.0.0",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Authorization limit issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - TransitSwap v4 Core_en-us.pdf",
        "body": "There are two roles Owner and Executor in the contract, and the permissions of the two roles are not clearly divided.",
        "labels": [
            "SlowMist",
            "TransitSwap v4 Core",
            "Type: Authority Control Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Security suggestion",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - TransitSwap v4 Core_en-us.pdf",
        "body": "Since the TransitSwapRouter contract will retain the user's authorization limit, it is recommended to allow the user to allocate on demand during the front-end authorization, and do not authorize the maximum value at one time to prevent the user's funds from being stolen. 11",
        "labels": [
            "SlowMist",
            "TransitSwap v4 Core",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing zero address check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - TransitSwap v4 Core_en-us.pdf",
        "body": "When modifying important addresses in the contract, it is not checked whether the incoming address is a zero address. ",
        "labels": [
            "SlowMist",
            "TransitSwap v4 Core",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - TransitSwap v4 Core_en-us.pdf",
        "body": "The Owner has the risk of over-authorization, and this role can withdraw the tokens in the contract to any address. ",
        "labels": [
            "SlowMist",
            "TransitSwap v4 Core",
            "Type: Authority Control Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Authority control issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - TransitSwap v4 Core_en-us.pdf",
        "body": "The contract adopts a completely open calling logic. There is an operation to authorize the approveAddress address in the _beforeSwap function. The calling path of this function is TransitSwapRouter.swap() -> TransitSwap.swap() -> TransitSwap._beforeSwap(). The calldata parameter is also passed in when calling the top-level function TransitSwapRouter.swap(). The code does not check whether the approveAddress is legal. If a malicious approveAddress is passed in, the contract will be incorrectly authorized and the tokens in the contract will be lost. ",
        "labels": [
            "SlowMist",
            "TransitSwap v4 Core",
            "Type: Authority Control Vulnerability",
            "Severity: High"
        ]
    },
    {
        "title": "Uninitialized parameter",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - TransitSwap v4 Core_en-us.pdf",
        "body": "The swapAmount parameter is declared in the contract but not initialized. ",
        "labels": [
            "SlowMist",
            "TransitSwap v4 Core",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Unsafe external call",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - TransitSwap v4 Core_en-us.pdf",
        "body": "The path and pair parameters in the supportingFeeOn function are controllable. If an attacker passes in malicious path and pair parameters, it may cause unexpected errors. ",
        "labels": [
            "SlowMist",
            "TransitSwap v4 Core",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing Approve amount reset",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - TransitSwap v4 Core_en-us.pdf",
        "body": "The _beforeSwap function in the TransitSwap contract will set the authorization limit to the maximum value when accessing the token for the rst time, but the function to remake the authorization is not found in the contract. When the authorization limit is used up, it will not be able to remake and the token cannot be used.",
        "labels": [
            "SlowMist",
            "TransitSwap v4 Core",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "4.3.1.2 Risk of loss of user funds",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DODOV2_en-us.pdf",
        "body": "In the LockTokenVault contract, when transferring the user's locked token, it did not check whether the _to address is msg.sender itself, which caused the user to abuse the transfer and cause a loss of funds. function transferLockedToken(address to) external { originBalances[to] = originBalances[to].add(originBalances[msg.sender]); claimedBalances[to] = claimedBalances[to].add(claimedBalances[msg.sender]); originBalances[msg.sender] = 0; claimedBalances[msg.sender] = 0; } Fix status: fixed, repair commit: main-08a06609604779c31db493bc0d755efa1c3f0a61.",
        "labels": [
            "SlowMist",
            "DODOV2",
            "Severity: Low"
        ]
    },
    {
        "title": "4.2.2.1 Missing events",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DODOV2_en-us.pdf",
        "body": "Contract  DODOApproveProxy  Function list  init / unlockAddProxy / addDODOProxy / LockAddProxy / removeDODOProxy ContractDODOApproveFunction listinit / unlockSetProxy / setDODOProxy / LockSetProxy ContractDODV2Proxy02Function listaddWhiteList / removeWhiteList / updateGasReturn ContractDVMFactorFunction listupdateDvmTemplate ContractDPPAdvanceFunction listtunePrice ContractDPPAdvance Function listsetOperator / setFreezeTimestamp ContractDPPVaultFunction listratioSync / retrieve 6 ContractDVMVault Function list_setReserve_sync The above functions does not have an event declaration, it is recommended to add the corresponding event declaration Fix status: After communicating with the project party, it is confirmed that the above event statement is not currently used in business and will be fixed in subsequent iterations.",
        "labels": [
            "SlowMist",
            "DODOV2",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.2.2.2 The contract balance was not verified when the reward was distributed",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DODOV2_en-us.pdf",
        "body": "In the RewardVault contract, the contract balance is not verified when the reward is distributed, which may cause the contract balance to fail to be distributed function reward(address to, uint256 amount) external onlyOwner { //SlowMist// Not verify if contract balance is larger than the transfer amount IERC20(dodoToken).safeTransfer(to, amount); } Fix situation: After confirming with the project party, they ignore this problem.",
        "labels": [
            "SlowMist",
            "DODOV2",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.2.2.3 Unchecked array length",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DODOV2_en-us.pdf",
        "body": "a. The getPendingReward function in the BaseMine contract did not verify whether the value of i passed in was less than the length of the array when obtaining the reward of the pool, which resulted in the failure to obtain the reward. function getPendingReward(address user, uint256 i) public view returns (uint256) { //SlowMist// Not verify the array length RewardTokenInfo storage rt = rewardTokenInfos[i]; uint256 accRewardPerShare = rt.accRewardPerShare; if (rt.lastRewardBlock != block.number) { accRewardPerShare = _getAccRewardPerShare(i); } return 7 DecimalMath.mulFloor( balanceOf(user), accRewardPerShare.sub(rt.userRewardPerSharePaid[user]) ).add(rt.userRewards[user]); } Fix status: fixed, repair commit: feature/mineV2AndDSP- 5917c95439cac06241f108038043d2 2348c863e6. b. The claimReward function in the BaseMine contract does not verify whether the value of i passed in is less than the length of the array, resulting in failure to obtain rewards function claimReward(uint256 i) public { require(i<rewardTokenInfos.length, \"DODOMineV2: REWARD_ID_NOT_FOUND\"); _updateReward(msg.sender, i); RewardTokenInfo storage rt = rewardTokenInfos[i]; uint256 reward = rt.userRewards[msg.sender]; if (reward > 0) { rt.userRewards[msg.sender] = 0; IRewardVault(rt.rewardVault).reward(msg.sender, reward); emit Claim(i, msg.sender, reward); } } Fix status: fixed, repair commit: feature/mineV2AndDSP- 5917c95439cac06241f108038043d2 2348c863e6.",
        "labels": [
            "SlowMist",
            "DODOV2",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.2.2.4 Compatibility risk of rebasing tokens",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DODOV2_en-us.pdf",
        "body": "The deposit function of the ERC20Mine contract does not verify the incoming amount. When it is compatible with rebasing tokens, it will cause an error to obtain the transfer amount. function claimReward(uint256 i) public { require(i<rewardTokenInfos.length, \"DODOMineV2: REWARD_ID_NOT_FOUND\"); _updateReward(msg.sender, i); 8 RewardTokenInfo storage rt = rewardTokenInfos[i]; uint256 reward = rt.userRewards[msg.sender]; if (reward > 0) { rt.userRewards[msg.sender] = 0; IRewardVault(rt.rewardVault).reward(msg.sender, reward); emit Claim(i, msg.sender, reward); } } Fix status: fixed, fix commit: main-d26b21bd814d4bfcc702521d52f6cb3af4f86e5c. 5.",
        "labels": [
            "SlowMist",
            "DODOV2",
            "Severity: Informational"
        ]
    },
    {
        "title": "Missing event log",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Arowana_en-us.pdf",
        "body": "The owner role can call the addToken and removeToken functions to add and remove the specied token address into the _addresses and _indexes . If there is no event record, it is not conducive to the review of community users. ",
        "labels": [
            "SlowMist",
            "Arowana",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing event log",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Arowana_en-us.pdf",
        "body": "7 The owner role can call the setValut function to set the source of reward token distribution. If there is no event record, it is not conducive to the review of community users. ",
        "labels": [
            "SlowMist",
            "Arowana",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing balance change",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Arowana_en-us.pdf",
        "body": "When the user calls the withdraw function for withdrawal ( block.timestap >= pool.end ), the balance of pool is not changed here. ",
        "labels": [
            "SlowMist",
            "Arowana",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Missing balance check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Arowana_en-us.pdf",
        "body": "When the user calls the withdraw function for withdrawal ( block.timestap >= pool.end ), there is a lack of judgment on the balance of valut. If the token balance of valut is not enough to pay the user's reward, the transaction will be rolled back and the user's principal and reward cannot be withdrawn. ",
        "labels": [
            "SlowMist",
            "Arowana",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Missing event record",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cell Core_en-us.pdf",
        "body": "The following functions do not log events. contracts/Cell.sol updateStageRecordMaxCount updateStageRecordCostPoint updateStageRecordIncPoint updateStageRecordValid addSigner removeSigner setProxyer contracts/Nucleus.sol setOracleAddress contracts/Oracle.sol addOracleAddress removeOracleAddress setTokenNameAddress setRates setRatePeriod setFixedPrice revokeFixedPrice contracts/Proxy.sol setOracleAddress setCellAddress setMintPrice",
        "labels": [
            "SlowMist",
            "Cell Core",
            "Type: Malicious Event Log Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Safe transfer issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cell Core_en-us.pdf",
        "body": "contracts/Nucleus.sol Use transferFrom in the claim function to transfer the token. If the token in the operation does not meet the eip20 standard, the transaction may fail. contracts/Proxy.sol Use transferFrom in the mint function to transfer the token. If the token in the operation does not meet the eip20 standard, the transaction may fail.",
        "labels": [
            "SlowMist",
            "Cell Core",
            "Type: Others",
            "Severity: Low"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cell Core_en-us.pdf",
        "body": "contracts/Cell.sol The owner has too much authority, and if the owner's private key is leaked, the attacker can control the casting of NFT. contracts/Oracle.sol The owner has too much authority. If the owner's private key is leaked, the attacker can manipulate the price by setting setRates and setFixedPrice . contracts/Proxy.sol The owner's authority is too large. If the owner's private key is leaked, the attacker can withdraw the revenue in the contract. You can also set a malicious Oracle contract through setOracleAddress to control the price. contracts/Nucleus.sol The owner has too much authority. If the owner's private key is leaked, the attacker can set a malicious Oracle contract through setOracleAddress to control the price.",
        "labels": [
            "SlowMist",
            "Cell Core",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Excessive Authority Issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - wault.finance(WEXPolyMaster)_en-us.pdf",
        "body": "The owner can set the value of wexPerBlock arbitrarily, which will affect the profit of wexReward, and there is no limit on the value range of wexPerBlock, and there is a issue of excessive authority. https://polygonscan.com/address/0xC8Bd86E5a132Ac0bf10134e270De06A8Ba317BFe#code function setWexPerBlock(uint256 _wexPerBlock) public onlyOwner { require(_wexPerBlock > 0, \"!wexPerBlock-0\"); wexPerBlock = _wexPerBlock; } Owner can add pool, can set the allocPoint of pool, there is a issue of selfish mining. function add( uint256 _allocPoint, IERC20 _lpToken, bool _withUpdate ) public onlyOwner { if (_withUpdate) { massUpdatePools(); } uint256 lastRewardBlock = block.number > startBlock ? block.number : startBlock; totalAllocPoint = totalAllocPoint.add(_allocPoint); poolInfo.push( 6 PoolInfo({ lpToken: _lpToken, allocPoint: _allocPoint, lastRewardBlock: lastRewardBlock, accWexPerShare: 0 }) ); function set( uint256 _pid, uint256 _allocPoint, bool _withUpdate ) public onlyOwner { if (_withUpdate) { massUpdatePools(); } totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add( _allocPoint ); poolInfo[_pid].allocPoint = _allocPoint; }",
        "labels": [
            "SlowMist",
            "wault.finance(WEXPolyMaster)",
            "Type: Others",
            "Severity: Low"
        ]
    },
    {
        "title": "No value is assigned to the fee parameter",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap Lottery_en-us.pdf",
        "body": "The fee parameter is dened in the RandomNumberGenerator contract and is used in the getRandomNumber function, but the contract is initialized without assigning a value to the fee parameter. ",
        "labels": [
            "SlowMist",
            "PancakeSwap Lottery",
            "Type: Others",
            "Severity: Low"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Helio Money_en-us.pdf",
        "body": "Owner or special administrator accounts can operate the key functions. - auth auth auth auth auth auth auth auth - - auth auth auth - auth auth CeToken burn CeToken mint CeToken changeVault hBNB hBNB hBNB burn mint changeMinter HelioProvider liquidation HelioProvider daoBurn HelioProvider daoMint HelioProvider changeDao HelioProvider changeCeToken HelioProvider changeProxy HelioProvider changeCollateralToken HelioProvider changeOperator CerosRouter changeVault CerosRouter changeDex CerosRouter changePool CerosRouter changeProvider OwnableUpgradeable renounceOwnership OwnableUpgradeable transferOwnership CeVaultV2 updateStorage MasterVault _updateCerosStrategyDebt MasterVault depositAllToStrategy MasterVault depositToStrategy MasterVault withdrawFromStrategy MasterVault withdrawAllFromStrategy MasterVault setStrategy MasterVault retireStrat MasterVault migrateStrategy MasterVault withdrawFee MasterVault setDepositFee MasterVault setWithdrawalFee MasterVault addManager MasterVault removeManager MasterVault changeProvider MasterVault changeFeeReceiver MasterVault changeStrategyAllocation WaitingPool addToQueue WaitingPool tryRemove WaitingPool setCapLimit SlidingWindowOracle _authorizeUpgrade UUPSUpgradeable upgradeTo UUPSUpgradeable upgradeToAndCall PriceOracleTestnet _authorizeUpgrade PriceOracle _authorizeUpgrade BaseStrategy setStrategist BaseStrategy setRewards BnbxYieldConverterStrategy changeStakeManager CerosYieldConverterStrategy changeBinancePool CerosYieldConverterStrategy changeCeRouter EmergencyShutdown setMultiSig Ownable renounceOwnership Ownable transferOwnership Interaction addToWhitelist Interaction removeFromWhitelist Jar Jar Jar replenish setSpread setExitDelay",
        "labels": [
            "SlowMist",
            "Helio Money",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Sandwich attacks can aect slippage scope",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Helio Money_en-us.pdf",
        "body": "contracts/ceros/CerosRouter.sol function deposit() external payable override nonReentrant returns (uint256 value) { //...snip code...// uint256[] memory outAmounts = _dex.getAmountsOut(amount, path); //...snip code...// uint256[] memory amounts = _dex.swapExactETHForTokens{ value: amount }(dexABNBcAmount, path, address(this), block.timestamp + 300); realAmount = amounts[1]; //...snip code...// } function withdrawWithSlippage( address recipient, uint256 amount, uint256 outAmount ) external override nonReentrant returns (uint256 realAmount) { //...snip code...// uint256[] memory amounts = _dex.swapExactTokensForETH( realAmount, outAmount, path, recipient, block.timestamp + 300 ); //...snip code...// } Sandwich attacks, also known as MEV attacks, refer to attackers using the transaction order and execution results on the blockchain to gain additional value. This type of attack is usually carried out by miners or transaction order executors, who can gain additional value by reordering transactions or selectively including or excluding them.",
        "labels": [
            "SlowMist",
            "Helio Money",
            "Type: Reordering Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Ratio arbitrage attack vulnerability",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Helio Money_en-us.pdf",
        "body": "contracts/ceros/CeVault.sol contracts/ceros/upgrades/CeVaultV2.sol function _deposit(address account, uint256 amount) private returns (uint256) { uint256 ratio = _aBNBc.ratio(); _aBNBc.transferFrom(msg.sender, address(this), amount); uint256 toMint = (amount * 1e18) / ratio; //SlowMist// _depositors[account] += amount; // aBNBc _ceTokenBalances[account] += toMint; // mint ceToken to recipient ICertToken(_ceToken).mint(account, toMint); emit Deposited(msg.sender, account, toMint); return toMint; } function _withdraw( address owner, address recipient, uint256 amount ) private returns (uint256) { uint256 ratio = _aBNBc.ratio(); uint256 realAmount = (amount * ratio) / 1e18;//SlowMist// require( _aBNBc.balanceOf(address(this)) >= realAmount, \"not such amount in the vault\" ); uint256 balance = _ceTokenBalances[owner]; require(balance >= amount, \"insufficient balance\"); _ceTokenBalances[owner] -= amount; // BNB // burn ceToken from owner ICertToken(_ceToken).burn(owner, amount); _depositors[owner] -= realAmount; // aBNBc _aBNBc.transfer(recipient, realAmount); emit Withdrawn(owner, recipient, realAmount); return realAmount; } Here we can see that the amount of deposit and withdraw is related to the ratio. We can query the implementation of the ratio from the call chain: _aBNBc: function ratio() public view returns (uint256) { return IBondToken(_bondToken).ratio(); } _bondToken: function ratio() public view override returns (uint256) { return _ratio; } function repairRatio(uint256 newRatio) external onlyOwner { _ratio = newRatio; emit RatioUpdated(_ratio); } function updateRatio(uint256 totalRewards) external onlyOperator { uint256 totalShares = totalSharesSupply(); uint256 denominator = _totalStaked + totalRewards - _totalUnbondedBonds; _ratio = multiplyAndDivideFloor(totalShares, 1e18, denominator); // (totalShares * 1e18) / denominator; if (historicalRatios.length == 0) { historicalRatios = new uint256[](8); } if (block.timestamp - _lastUpdate > 1 days - 1 minutes) { uint256 _latestOffset = latestOffset; historicalRatios[((_latestOffset + 1) % 8)] = _ratio; latestOffset = _latestOffset + 1; _lastUpdate = block.timestamp; } emit RatioUpdated(_ratio); } The value of the ratio can be modied by Owner or through other mechanisms. We may trust the operations of the Owner, but changes in the ratio can cause serious arbitrage attacks that can be implemented without the Owner's permission. The main idea is to use MEV attacks by monitoring the transaction memory pool on the blockchain. When a transaction that increases the ratio is found, one transaction deposits the CeVault contract, and another transaction calls the withdraw function of CeVault. By adjusting the form of the transaction fees, these two transactions are placed before and after the ratio change transaction, allowing direct get aBNBc in CeVault. Asset changes like this: Tx1: deposit: 100 aBNBc Tx2: repairRatio: 1-->1.2 Tx3: withdraw: 120 aBNBc",
        "labels": [
            "SlowMist",
            "Helio Money",
            "Type: Unsafe External Call Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Missing check return value",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Helio Money_en-us.pdf",
        "body": "Code location: _aBNBc.transferFrom(msg.sender,address(this),amount) (CeVault.sol#70) _aBNBc.transfer(recipient,availableYields) (CeVault.sol#105) _aBNBc.transfer(recipient,realAmount) (CeVault.sol#143) _certToken.transferFrom(owner,address(this),amount) (CerosRouter.sol#125) _certToken.transfer(recipient,profit) (CerosRouter.sol#165) IERC20(wBnbToken).approve(dexAddress,type()(uint256).max) (CerosRouter.sol#59) IERC20(certToken).approve(dexAddress,type()(uint256).max) (CerosRouter.sol#60) IERC20(certToken).approve(bondToken,type()(uint256).max) (CerosRouter.sol#61) IERC20(certToken).approve(pool,type()(uint256).max) (CerosRouter.sol#62) IERC20(certToken).approve(vault,type()(uint256).max) (CerosRouter.sol#63) _certToken.approve(address(_vault),0) (CerosRouter.sol#250) _certToken.approve(address(_vault),type()(uint256).max) (CerosRouter.sol#252) IERC20(_wBnbAddress).approve(address(_dex),0) (CerosRouter.sol#256) _certToken.approve(address(_dex),0) (CerosRouter.sol#257) IERC20(_wBnbAddress).approve(address(_dex),type()(uint256).max) (CerosRouter.sol#260) _certToken.approve(address(_dex),type()(uint256).max) (CerosRouter.sol#261) _certToken.approve(address(_pool),0) (CerosRouter.sol#266) _certToken.approve(address(_pool),type()(uint256).max) (CerosRouter.sol#268) IERC20(_ceToken).approve(daoAddress,type()(uint256).max) (HelioProvider.sol#67) _ceRouter.withdrawABNBc(recipient,amount) (HelioProvider.sol#155) _dao.deposit(account,address(_ceToken),amount) (HelioProvider.sol#174) _dao.withdraw(account,address(_ceToken),amount) (HelioProvider.sol#178) IERC20(_ceToken).approve(address(_dao),0) (HelioProvider.sol#194) IERC20(_ceToken).approve(address(_dao),type()(uint256).max) (HelioProvider.sol#196) IERC20(_ceToken).approve(address(_dao),0) (HelioProvider.sol#200) IERC20(_ceToken).approve(address(_dao),type()(uint256).max) (HelioProvider.sol#202) IERC20Upgradeable(_rewardsToken).approve(address(target),reward) (mediator/ElipsisMediator.sol#59) _bnbxToken.approve(destination,type()(uint256).max) (strategy/BnbxYieldConverterStrategy.sol#58) _bnbxToken.approve(address(_stakeManager),0) (strategy/BnbxYieldConverterStrategy.sol#313) _bnbxToken.approve(address(_stakeManager),type()(uint256).max) (strategy/BnbxYieldConverterStrategy.sol#315) _certToken.approve(binancePool,type()(uint256).max) (strategy/CerosYieldConverterStrategy.sol#40) _certToken.approve(address(_binancePool),0) (strategy/CerosYieldConverterStrategy.sol#146) _certToken.approve(address(_binancePool),type()(uint256).max) (strategy/CerosYieldConverterStrategy.sol#148) _snBnbToken.approve(destination,type()(uint256).max) (strategy/SnBnbYieldConverterStrategy.sol#57) _snBnbToken.approve(address(_stakeManager),0) (strategy/SnBnbYieldConverterStrategy.sol#309) _snBnbToken.approve(address(_stakeManager),type()(uint256).max) (strategy/SnBnbYieldConverterStrategy.sol#311) hay.transferFrom(address(receiver), address(this), total)(contracts/flash.sol#110) hay.transfer(keeper,hayBal) (libraries/AuctionProxy.sol#39) hay.transfer(keeper,hayBal) (libraries/AuctionProxy.sol#62) hay.transferFrom(msg.sender,address(this),hayMaxAmount) (libraries/AuctionProxy.sol#83) hay.transfer(receiverAddress,hayBal) (libraries/AuctionProxy.sol#99) hay.approve(hayJoin_,type()(uint256).max) (Interaction.sol#103) hay.approve(address(hayJoin),0) (Interaction.sol#109) hay.approve(hayJoin_,type()(uint256).max) (Interaction.sol#118) hay.approve(address(hayJoin),type()(uint256).max) (Interaction.sol#122) IERC20Upgradeable(hay).transferFrom(msg.sender,address(this),wad) (vow.sol#99) Not verifying the return value may lead to logical errors.",
        "labels": [
            "SlowMist",
            "Helio Money",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Missing zero address validation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Helio Money_en-us.pdf",
        "body": "Code locations: CeToken.changeVault(address).vault (CeToken.sol#47) CeVault.changeRouter(address).router (CeVault.sol#194) CerosRouter.changeProvider(address).provider (CerosRouter.sol#271) hBNB.changeMinter(address).minter (hBNB.sol#42) HelioProvider.initialize(address,address,address,address,address,address).certToken (HelioProvider.sol#51) HelioProvider.initialize(address,address,address,address,address,address).ceToken (HelioProvider.sol#52) HelioProvider.changeCeToken(address).ceToken (HelioProvider.sol#199) HelioProvider.changeProxy(address).auctionProxy (HelioProvider.sol#205) HelioProvider.changeOperator(address).operator (HelioProvider.sol#213) MasterVault.initialize(uint256,uint256,uint8,address,address).ceToken (masterVault/MasterVault.sol#86) MasterVault.withdrawETH(address,uint256).account (masterVault/MasterVault.sol#126) PriceOracle.initialize(address,IMovingWindowOracle,bool,address,address)._tokenIn (oracle/PriceOracle.sol#22) PriceOracle.initialize(address,IMovingWindowOracle,bool,address,address)._wbnb (oracle/PriceOracle.sol#25) PriceOracle.initialize(address,IMovingWindowOracle,bool,address,address)._usd (oracle/PriceOracle.sol#26) PriceOracleTestnet.initialize(address,IMovingWindowOracle,bool)._tokenIn (oracle/PriceOracleTestnet.sol#31) SlidingWindowOracle.initialize(address,uint256,uint8).factory_ (oracle/SlidingWindowOracle.sol#46) BnbxYieldConverterStrategy.distributeManual(address).recipient (strategy/BnbxYieldConverterStrategy.sol#253) SnBnbYieldConverterStrategy.distributeManual(address).recipient (strategy/SnBnbYieldConverterStrategy.sol#253) StkBnbStrategy.distributeManual(address).recipient (strategy/StkBnbStrategy.sol#280) Interaction.setWhitelistOperator(address).usr (Interaction.sol#59) Interaction.initialize(address,address,address,address,address,address,address).dog_ (Interaction.sol#86) Jar.initialize(string,string,address,uint256,uint256,uint256)._hayToken (jar.sol#88) Clipper.file(bytes32,address).data (clip.sol#166) Dog.file(bytes32,address).data (dog.sol#133) EmergencyShutdown.constructor(address,address)._vat (es.sol#19) EmergencyShutdown.constructor(address,address)._multisig (es.sol#19) EmergencyShutdown.setMultiSig(address)._multisig (es.sol#28) Vow.initialize(address,address,address)._hayJoin (vow.sol#59) Vow.initialize(address,address,address).multisig_ (vow.sol#59) Vow.file(bytes32,address).data (vow.sol#78)",
        "labels": [
            "SlowMist",
            "Helio Money",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Performs a multiplication on the result of a division",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Helio Money_en-us.pdf",
        "body": "- price = oneTokenOut / amountOut * 10 ** 18 (oracle/PriceOracleTestnet.sol#55) - d /= pow2 (oracle/libraries/FullMath.sol#23) - r *= 2 - d * r (oracle/libraries/FullMath.sol#27) - d /= pow2 (oracle/libraries/FullMath.sol#23) - r *= 2 - d * r (oracle/libraries/FullMath.sol#28) - d /= pow2 (oracle/libraries/FullMath.sol#23) - r *= 2 - d * r (oracle/libraries/FullMath.sol#29) - d /= pow2 (oracle/libraries/FullMath.sol#23) - r *= 2 - d * r (oracle/libraries/FullMath.sol#30) - d /= pow2 (oracle/libraries/FullMath.sol#23) - r *= 2 - d * r (oracle/libraries/FullMath.sol#31) - d /= pow2 (oracle/libraries/FullMath.sol#23) - r *= 2 - d * r (oracle/libraries/FullMath.sol#32) - d /= pow2 (oracle/libraries/FullMath.sol#23) - r *= 2 - d * r (oracle/libraries/FullMath.sol#33) - d /= pow2 (oracle/libraries/FullMath.sol#23) - r *= 2 - d * r (oracle/libraries/FullMath.sol#34) - l /= pow2 (oracle/libraries/FullMath.sol#24) - l * r (oracle/libraries/FullMath.sol#35) - poolTokens = (poolTokensToBurn * 1e11) / (1e11 - stakePool.config().fee.withdraw) (strategy/StkBnbStrategy.sol#188) - poolTokensFee = (poolTokens * stakePool.config().fee.withdraw) / 1e11 (strategy/StkBnbStrategy.sol#198) - x = xxRound_rpow_asm_0 / b (hMath.sol#19) - zx_rpow_asm_0 = z * x (hMath.sol#21) - d /= pow2 (oracle/libraries/FullMath.sol#23) - r *= 2 - d * r (oracle/libraries/FullMath.sol#27) - d /= pow2 (oracle/libraries/FullMath.sol#23) - r *= 2 - d * r (oracle/libraries/FullMath.sol#28) - d /= pow2 (oracle/libraries/FullMath.sol#23) - r *= 2 - d * r (oracle/libraries/FullMath.sol#29) - d /= pow2 (oracle/libraries/FullMath.sol#23) - r *= 2 - d * r (oracle/libraries/FullMath.sol#30) - d /= pow2 (oracle/libraries/FullMath.sol#23) - r *= 2 - d * r (oracle/libraries/FullMath.sol#31) - d /= pow2 (oracle/libraries/FullMath.sol#23) - r *= 2 - d * r (oracle/libraries/FullMath.sol#32) - d /= pow2 (oracle/libraries/FullMath.sol#23) - r *= 2 - d * r (oracle/libraries/FullMath.sol#33) - d /= pow2 (oracle/libraries/FullMath.sol#23) - r *= 2 - d * r (oracle/libraries/FullMath.sol#34) - l /= pow2 (oracle/libraries/FullMath.sol#24) - l * r (oracle/libraries/FullMath.sol#35) - x = xxRound_rpow_asm_0 / b (abaci.sol#159) - zx_rpow_asm_0 = z * x (abaci.sol#161) - x = xxRound_rpow_asm_0 / b (abaci.sol#249) - zx_rpow_asm_0 = z * x (abaci.sol#251) - rate = wad / timeline (jar.sol#141) - leftover = remaining * rate (jar.sol#144) - x = xxRound_rpow_asm_0 / b (hMath.sol#19) - zx_rpow_asm_0 = z * x (hMath.sol#21) Solidity's integer division truncates. Thus, performing division before multiplication can lead to precision loss.",
        "labels": [
            "SlowMist",
            "Helio Money",
            "Type: Arithmetic Accuracy Deviation Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Anyone can call initialize on the logic contract",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Helio Money_en-us.pdf",
        "body": "contracts/ceros/upgrades/CeVaultV2.sol 33,5: function initialize( contracts/ceros/upgrades/HelioProviderV2.sol 43,5: function initialize( contracts/ceros/CerosRouter.sol 41,5: function initialize( contracts/ceros/CeToken.sol 31,5: function initialize(string calldata _name, string calldata _symbol) contracts/ceros/CeVault.sol 33,5: function initialize( contracts/ceros/hBNB.sol 29,5: function initialize() external initializer { contracts/ceros/HelioProvider.sol 49,5: function initialize( contracts/masterVault/MasterVault.sol 82,5: function initialize( contracts/masterVault/WaitingPool.sol 28,5: function initialize(address _masterVault, uint256 _capLimit) external initializer { contracts/mediator/ElipsisMediator.sol 43,5: function initialize(address targetContract) public initializer { contracts/oracle/interfaces/IUniswapV2Pair.sol 96,3: function initialize(address, address) external; contracts/oracle/BnbOracle.sol 11,5: function initialize(address aggregatorAddress) external initializer { contracts/oracle/BusdOracle.sol 11,5: function initialize(address aggregatorAddress) external initializer { contracts/oracle/HelioOracle.sol 17,5: function initialize(uint256 initialPrice) public initializer { contracts/oracle/PriceOracle.sol 21,3: function initialize( contracts/oracle/PriceOracleTestnet.sol 30,3: function initialize( contracts/oracle/SlidingWindowOracle.sol 45,3: function initialize( contracts/strategy/BnbxYieldConverterStrategy.sol 46,5: function initialize( contracts/strategy/CerosYieldConverterStrategy.sol 27,5: function initialize( contracts/strategy/SnBnbYieldConverterStrategy.sol 45,5: function initialize( contracts/strategy/StkBnbStrategy.sol 58,5: function initialize( contracts/abaci.sol 52,5: function initialize() external initializer { 123,5: function initialize() external initializer { 214,5: function initialize() external initializer { contracts/clip.sol 127,5: function initialize(address vat_, address spotter_, address dog_, bytes32 ilk_) external initializer { contracts/dog.sol 103,5: function initialize(address vat_) external initializer { contracts/flash.sol 58,5: function initialize(address _vat, address _hay, address _hayJoin, address _vow) external initializer { contracts/hay.sol 59,5: function initialize(uint256 chainId_, string memory symbol_, uint256 supplyCap_) external initializer { contracts/HelioRewards.sol 65,5: function initialize(address vat_, uint256 poolLimit_ ) public initializer { contracts/HelioToken.sol 28,5: function initialize(uint256 rewardsSupply_, address rewards_) public initializer { contracts/Interaction.sol 80,5: function initialize( contracts/jar.sol 88,5: function initialize(string memory _name, string memory _symbol, address _hayToken, uint _spread, uint _exitDelay, uint _flashLoanDelay) external initializer { contracts/join.sol 89,5: function initialize(address vat_, bytes32 ilk_, address gem_) external initializer { 149,5: function initialize(address vat_, address hay_) external initializer { contracts/jug.sol 54,5: function initialize(address vat_) external initializer { contracts/lock.sol 64,5: function initialize() external initializer { contracts/spot.sol 56,5: function initialize(address vat_) external initializer { contracts/vat.sol 74,5: function initialize() public initializer { contracts/vow.sol 59,5: function initialize(address vat_, address _hayJoin, address multisig_) external initializer { Anyone can call initialize on the logic contract.",
        "labels": [
            "SlowMist",
            "Helio Money",
            "Type: Race Conditions Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "vaultToken burned may exceed the actual number needed",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Helio Money_en-us.pdf",
        "body": "contracts/masterVault/MasterVault.sol function withdrawETH(address account, uint256 amount) external override nonReentrant whenNotPaused onlyProvider returns (uint256 shares) { address src = msg.sender; ICertToken(vaultToken).burn(src, amount); uint256 ethBalance = totalAssetInVault(); shares = _assessFee(amount, withdrawalFee); if(ethBalance < shares) { payable(account).transfer(ethBalance); uint256 withdrawn = withdrawFromActiveStrategies(account, shares - ethBalance); shares = ethBalance + withdrawn; } else { payable(account).transfer(shares); } emit Withdraw(src, src, src, amount, shares); return amount; } When Strategy balance is not enough, the actual withdrawn amount return by withdrawFromActiveStrategies will lower than shares - ethBalance passed, it means the provider burn amount but do not get enough native token.",
        "labels": [
            "SlowMist",
            "Helio Money",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Missing check BnbOracle status",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Helio Money_en-us.pdf",
        "body": "contracts/oracle/BnbOracle.sol function peek() public view returns (bytes32, bool) { ( /*uint80 roundID*/, int price, /*uint startedAt*/, /*uint timeStamp*/, /*uint80 answeredInRound*/ ) = priceFeed.latestRoundData(); if (price < 0) { return (0, false); } return (bytes32(uint(price) * (10**10)), true); } In order to get a correct price, we need to check key values returned by priceFeed.",
        "labels": [
            "SlowMist",
            "Helio Money",
            "Type: Unsafe External Call Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Upgrading contracts may introduce new risks",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Helio Money_en-us.pdf",
        "body": "contracts/oracle/HelioOracle.sol contracts/oracle/PriceOracle.sol contracts/oracle/SlidingWindowOracle.sol The Proxy can upgrade the contract by calling upgradeTo/upgradeToAndCall , and upgrading the contract may introduce new risks.",
        "labels": [
            "SlowMist",
            "Helio Money",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "HelioOracle owner is never initialized",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Helio Money_en-us.pdf",
        "body": "contracts/oracle/HelioOracle.sol function changePriceToken(uint256 price_) external { require(msg.sender == _owner, \"HelioOracle/forbidden\"); price = price_; emit PriceChanged(price); } _owner is never initialized, changePriceToken call will fail in any condition.",
        "labels": [
            "SlowMist",
            "Helio Money",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "HelioOracle price oracle is not rigorous",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Helio Money_en-us.pdf",
        "body": "contracts/oracle/HelioOracle.sol function changePriceToken(uint256 price_) external { require(msg.sender == _owner, \"HelioOracle/forbidden\"); price = price_; emit PriceChanged(price); } This oracle price is too simple, there is not parameters for determining the validity of prices, such as timestamp.",
        "labels": [
            "SlowMist",
            "Helio Money",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Oracle price should not return 0",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Helio Money_en-us.pdf",
        "body": "contracts/HelioRewards.sol function helioPrice() public view returns(uint256) { // 1 HAY is helioPrice() helios (bytes32 price, bool has) = oracle.peek(); if (has) { return uint256(price); } else { return 0; } } contracts/Interaction.sol function collateralPrice(address token) public view returns (uint256) { CollateralType memory collateralType = collaterals[token]; _checkIsLive(collateralType.live); (PipLike pip,) = spotter.ilks(collateralType.ilk); (bytes32 price, bool has) = pip.peek(); if (has) { return uint256(price); } else { return 0; } } Price oracle should break the operation when peek an error, instead of return 0.",
        "labels": [
            "SlowMist",
            "Helio Money",
            "Type: Unsafe External Call Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "ERC777 reentrancy risks",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Helio Money_en-us.pdf",
        "body": "contracts/strategy/StkBnbStrategy.sol function _withdraw(address recipient, uint256 amount) internal returns (uint256) { //... stkBNB.send(address(stakePool), poolTokens, \"\"); // save it so that we can later dispatch the amount to the recipient on claim withdrawReqs[_endIndex++] = WithdrawRequest(recipient, value); // keep track of _netDeposits in StakePool _bnbDepositsInStakePool -= value; return value + ethBalance; } stkBNB is a ERC777 token , ERC777 tokens are vulnerable to reentrancy attacks due to a design aw.",
        "labels": [
            "SlowMist",
            "Helio Money",
            "Type: Reentrancy Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Missing events access control",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Helio Money_en-us.pdf",
        "body": "MasterVault._updateCerosStrategyDebt() MasterVault.withdrawFee() BnbxYieldConverterStrategy._deposit() BnbxYieldConverterStrategy._withdraw() BnbxYieldConverterStrategy._distributeFund() BnbxYieldConverterStrategy._harvestTo() CerosYieldConverterStrategy._deposit() CerosYieldConverterStrategy._withdraw() CerosYieldConverterStrategy._harvestTo() SnBnbYieldConverterStrategy._deposit() SnBnbYieldConverterStrategy.withdrawInToken() SnBnbYieldConverterStrategy._withdraw() SnBnbYieldConverterStrategy._distributeFund() SnBnbYieldConverterStrategy._harvestTo() StkBnbStrategy._deposit() StkBnbStrategy.withdrawInToken() StkBnbStrategy._withdraw() StkBnbStrategy.harvest()",
        "labels": [
            "SlowMist",
            "Helio Money",
            "Type: Malicious Event Log Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Reentry prevention best practices",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Helio Money_en-us.pdf",
        "body": "contracts/HelioRewards.sol function claim(uint256 amount) external { //... } contracts/Interaction.sol function deposit( address participant, address token, uint256 dink ) external whitelisted(participant) returns (uint256) { } function borrow(address token, uint256 hayAmount) external returns (uint256) { //... } function payback(address token, uint256 hayAmount) external returns (int256) { //... } Not apply check-eects-interactions pattern when making external calls in these functions.",
        "labels": [
            "SlowMist",
            "Helio Money",
            "Type: Reentrancy Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing check return value",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Helio Money_en-us.pdf",
        "body": "Code location: jug.drip(collateralType.ilk) (Interaction.sol#145) jug.drip(collateralType.ilk) (Interaction.sol#309) _deactivateStrategy(strategy)(contracts/masterVault/MasterVault.sol#315) _depositToStrategy(strategies[i], depositAmount) (contracts/masterVault/MasterVault.sol#342) Not verifying the return value may lead to logical errors.",
        "labels": [
            "SlowMist",
            "Helio Money",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Deposit defect issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "In the EFVault contract, it is not restricted to call the deposit function only by the DepositApprover contract. If the user transfers funds to the EFVault contract by mistake, any user can call the deposit function to deposit for himself. 19 ",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Incorrect withdrawal amount check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "In the vault contract, users can withdraw funds through the withdraw function. It will check if the funds withdrawn by the user is less than the user's total deposit, but this will prevent the user from withdrawing all of their total deposit. ",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Risk of overburning shares",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "In the vault contract, users can burn their shares to withdraw funds through the withdraw function. However, when calculating the required burning share, it incorrectly divides the user's total deposit. This will cause the number of shares to be burned to be much larger than expected. ",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Small deposit issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "When a user makes a deposit, the vault contract will deposit the user's funds into the strategy pool and then mint the 21 corresponding share to the user. If the total deposit of the contract is very large at this time, when the user deposits a small amount of funds, the nal result of the division operation will be 0 when the amount is too small when withdrawing. Causes the problem that small assets cannot be withdrawn.",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "The deationary token issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "In the DepositApprover contract, the amount of the deposit is the amount passed in by the user. If the tokens supported by the protocol become deationary tokens in the future (for example, USDT enables the transfer fee function), this will cause the actual number of tokens received by the protocol to be inconsistent with the number of dedicated incoming tokens. The same is true for Controller and SS contracts. ",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of share manipulation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "When the user deposits in the agreement, the contract will mint the corresponding share to the user, and when the user withdraws, the corresponding share will be burned. The totalAssets function is used to participate in the calculation when calculating the share, and in the SS contract of the convex, the totalAssets are obtained through the calc_withdraw_one_coin function of the Curve Pool. However, the calc_withdraw_one_coin function is vulnerable to the balance in the Curve Pool, so malicious users can manipulate the calc_withdraw_one_coin function to aect the number of shares minted by the contract. ",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Missing event records 23",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "In the vault contract, the owner can modify the maxDeposit, maxWithdraw, controller and depositApprover parameters through the setMaxDeposit, setMaxWithdraw, setController and setDepositApprover functions respectively. But event logging is not used. In the Controller contract, the owner can modify the vault, apySort, treasury, exchange, withdrawFee, defaultDepositSS and isDefault parameters through the setVault, setAPYSort, setTreasury, setExchange, setWithdrawFee, setDefaultDepositSS and setDefaultOption functions. But event logging is not used. In the contracts under the exchanges folder, the owner can set the exchange contract address through the setExchange function. But event logging is not used. In the contracts under the subStrategies/convex folder, the owner can modify the controller, depositSlippage, pId, lpToken, curvePool, harvestGap, maxDeposit, rewardTokens parameters through the setController, setDepositSlippage, setWithdrawSlippage, setPoolId, setLPToken, setCurvePool, setHarvestGap, setMaxDeposit, addRewardToken and removeRewardToken functions. But event logging is not used. In the cusdc contract, the owner can modify the controller, depositSlippage, withdrawSlippage, harvestGap and maxDeposit parameters through the setController, setDepositSlippage, setWithdrawSlippage, setHarvestGap and setMaxDeposit functions. But event logging is not used. ",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "AllocPoint deposit issue 28",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "In the Controller contract, deposits are made according to the allocPoint of each SS, which calculates the number of tokens transferred to each SS through the following algorithm amountForSS = (_amount * subStrategies[i].allocPoint) / totalAllocPoint; However, due to the loss of precision in the division calculation, a small amount of funds cannot be transferred into SS. ",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "check withdrawal amount issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "After the Controller contract withdraws from SS, it will check whether withdrawAmt is greater than 0. But since the protocol will havest periodically, theoretically withdrawAmt should be greater than or equal to the _amount parameter passed in by the user. ",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Risks of fake routers",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "In the Controller contract, the owner role can compound interest through the harvest function. However, it is not checked whether the router list passed in by owner is as expected. If an unexpected router is passed in, it may lead to failure to harvest normally or loss of funds. ",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Loss of computational precision",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "In the vault contract, the convertToAssets function is used to convert shares to corresponding asset amounts. 31 However, it performs the calculation by performing the division operation rst and then the multiplication operation, which will result in loss of calculation accuracy. ",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Risks of strict equality checks",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "In Convex's SS contract, when the user makes a withdrawal, it is checked whether the LP balance of the current contract is strictly equal to the LP amount required by the user. If a malicious user intentionally transfers any amount of LP tokens to the current contract, this will cause the SS contract to become unusable. ",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Negative number check issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "In the Cusdc contract, the _totalAssets function is used to obtain the total collateralized assets. It is calculated by multiplying the number of nTokens held by the protocol by the price of nTokens and dividing the total supply of nTokens. The price of nToken is obtained through the getPresentValueUnderlyingDenominated function, but the return value of the getPresentValueUnderlyingDenominated function is int256, while the return value of the INusdc interface is dened as uint256. If it returns a negative number, it will overow. ",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "In the Controller contract, the owner can set allocation point of a sub strategy, register the substrategies to the controller contract and withdraw the assets from one SS and deposit to other SS. This will have an impact on the user's deposit and withdrawal operations. ",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Authority Control Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Code redundancy issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "In the vault contract, the convertToShares function is dened, but it is not actually used in the contract. ",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Invalid minimum output calculation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "In the SS contract, the calc_token_amount function will be used to calculate the minimum amount of LP tokens received during the deposit operation; the minimum amount of staking tokens received will be calculated through the calc_withdraw_one_coin function during the withdrawal operation. However, the calc_token_amount function and the calc_withdraw_one_coin function are easily aected by the last transaction of CurvePool, so they cannot play the role of slippage protection. Lusd and Tri contracts also have slippage issue, but the slippage check is annotated in the deposit function. ",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Risk of pid acquisition",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "In the Alusd contract, the getPID function user obtains the corresponding LP pool address in the ConvexBooster contract. It will return 0 if LpToken does not exist, but pid0 has a value in the ConvexBooster contract. So when getPID returns 0, it will be hard to tell if pid exists. 37 ",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Redundant approval issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "In the swapExactTokenInput function of the Exchange contract, it will rst transfer the tokens that need to be swapped from the controller contract to the router contract. But the swapExactTokenInput function approves the router contract again, which is unnecessary. ",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Incorrect storage of temporary variables",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "In the router contract, the removePath function is used to remove the swap path recorded in the contract. It will rst store the balancerBatchAssets variable through storage, then delete it, and then use this variable for event recording after deletion. ",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Compound interest slippage check issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "In the router contract, no slippage check is performed during the swap operation. If there are more funds with compound interest, there will be a risk of being attacked by sandwiches. ",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Lack of access control",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "The swap function in the UniswapV3 contract is not subject to permission control, which will allow any user to call it. ",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Authority Control Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Random can be predicted issue 15",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DODO-MiningV3 and NFT_en-us.pdf",
        "body": "The random number is uncertain when buying a ticket. However, there is no separate operation of using the redeeming tickets and determining the random number when redeeming tickets, and there is an issue that the random number can be predicted. https://github.com/DODOEX/contractV2/blob/453e323af6/contracts/DODODrops/DODODropsV2/DODODro ps.sol#L114 function buyTickets(address ticketTo, uint256 ticketAmount) payable external preventReentrant { (uint256 curPrice, uint256 sellAmount, uint256 index) = getSellingInfo(); require(curPrice > 0 && sellAmount > 0, \"CAN_NOT_BUY\"); require(ticketAmount <= sellAmount, \"TICKETS_NOT_ENOUGH\"); (uint256 payAmount, uint256 feeAmount) = IDropsFeeModel(_FEE_MODEL_).getPayAmount(address(this), ticketTo, curPrice, ticketAmount); require(payAmount > 0, \"UnQualified\"); uint256 baseBalance = IERC20(_BUY_TOKEN_).universalBalanceOf(address(this)); uint256 buyInput = baseBalance.sub(_BUY_TOKEN_RESERVE_); require(payAmount <= buyInput, \"PAY_AMOUNT_NOT_ENOUGH\"); _SELLING_AMOUNT_SET_[index] = sellAmount.sub(ticketAmount); _BUY_TOKEN_RESERVE_ = baseBalance.sub(feeAmount); IERC20(_BUY_TOKEN_).universalTransfer(_MAINTAINER_,feeAmount); _mint(ticketTo, ticketAmount); emit BuyTicket(ticketTo, payAmount, feeAmount, ticketAmount); } The owner determines the value of _REVEAL_RN_ by calling the setRevealRn function. The value of _REVEAL_RN_ will affect the result of the random number. https://github.com/DODOEX/contractV2/blob/453e323af6/contracts/DODODrops/DODODropsV2/DODODro ps.sol#L229 function setRevealRn() external onlyOwner { require(_REVEAL_RN_ == 0, \"ALREADY_SET\"); 16 _REVEAL_RN_ = uint256(keccak256(abi.encodePacked(blockhash(block.number - 1)))); emit SetReveal(); } The value of random is related to _REVEAL_RN_ , msg.sender , balanceOf(msg.sender) and curNo in REVEAL_MODE mode when users use wallets for transactions. Attackers can generate addresses and balances values to control the random number. In non-REVEAL_MODE mode, the value of random is related to _RNG_ , block.number , and gasleft . The attackers can sort transactions through pre-execution or in cooperation with miners. In this way, they can manipulate block.number and gasleft to control random numbers. https://github.com/DODOEX/contractV2/blob/453e323af6/contracts/DODODrops/DODODropsV2/DODODro ps.sol#L154-L159 function _redeemSinglePrize(address to, uint256 curNo, address referer) internal { require(block.timestamp >= _REDEEM_ALLOWED_TIME_ && _REDEEM_ALLOWED_TIME_ != 0, \"REDEEM_CLOSE\"); uint256 range; if(_IS_PROB_MODE_) { range = _PROB_INTERVAL_[_PROB_INTERVAL_.length - 1]; }else { range = _TOKEN_ID_LIST_.length; } uint256 random; if(_IS_REVEAL_MODE_) { require(_REVEAL_RN_ != 0, \"REVEAL_NOT_SET\"); random = uint256(keccak256(abi.encodePacked(_REVEAL_RN_, msg.sender, balanceOf(msg.sender).add(curNo + 1)))) % range; }else { random = IRandomGenerator(_RNG_).random(gasleft() + block.number) % range; } uint256 tokenId; if(_IS_PROB_MODE_) { uint256 i; for (i = 0; i < _PROB_INTERVAL_.length; i++) { if (random <= _PROB_INTERVAL_[i]) { break; } } require(_TOKEN_ID_MAP_[i].length > 0, \"EMPTY_TOKEN_ID_MAP\"); 17 tokenId = _TOKEN_ID_MAP_[i][random % _TOKEN_ID_MAP_[i].length]; IDropsNft(_NFT_TOKEN_).mint(to, tokenId, 1, \"\"); } else { tokenId = _TOKEN_ID_LIST_[random]; if(random != range - 1) { _TOKEN_ID_LIST_[random] = _TOKEN_ID_LIST_[range - 1]; } _TOKEN_ID_LIST_.pop(); IDropsNft(_NFT_TOKEN_).mint(to, tokenId); } emit RedeemPrize(to, tokenId, referer); }",
        "labels": [
            "SlowMist",
            "DODO-MiningV3 and NFT",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "isContract can be bypassed",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DODO-MiningV3 and NFT_en-us.pdf",
        "body": "When redeeming tickets isContract is used to determine whether the caller msg.sender is a contract. The contract is not allowed to be called, but the implementation of this check has flaws and can be bypassed. https://github.com/DODOEX/contractV2/blob/453e323af6/contracts/DODODrops/DODODropsV2/DODODro ps.sol#L135 18 function redeemTicket(uint256 ticketNum, address referer) external { require(!address(msg.sender).isContract(), \"ONLY_ALLOW_EOA\"); require(ticketNum >= 1 && ticketNum <= balanceOf(msg.sender), \"TICKET_NUM_INVALID\"); _burn(msg.sender,ticketNum); for (uint256 i = 0; i < ticketNum; i++) { _redeemSinglePrize(msg.sender, i, referer); } } https://github.com/DODOEX/contractV2/blob/453e323af6/contracts/external/utils/Address.sol#L27 function isContract(address account) internal view returns (bool) { // This method relies on extcodesize, which returns 0 for contracts in // construction, since the code is only stored at the end of the // constructor execution. uint256 size; // solhint-disable-next-line no-inline-assembly assembly { size := extcodesize(account) } return size > 0; }",
        "labels": [
            "SlowMist",
            "DODO-MiningV3 and NFT",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Excessive authority issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DODO-MiningV3 and NFT_en-us.pdf",
        "body": "The owner can control the source of the seed of the random number. The seed of the random number will affect the value of the random number and affect the probability of redeeming the ticket. 19 https://github.com/DODOEX/contractV2/blob/453e323af6/contracts/DODODrops/DODODropsV2/DODODro ps.sol#L227 function setRevealRn() external onlyOwner { require(_REVEAL_RN_ == 0, \"ALREADY_SET\"); _REVEAL_RN_ = uint256(keccak256(abi.encodePacked(blockhash(block.number - 1)))); emit SetReveal(); } The owner can change the value of _RNG_ , which will affect the random number of the redemption ticket if it is not REVEAL_MODE. https://github.com/DODOEX/contractV2/blob/453e323af6/contracts/DODODrops/DODODropsV2/DODODro ps.sol#L259 function updateRNG(address newRNG) external onlyOwner { require(newRNG != address(0)); _RNG_ = newRNG; emit ChangeRNG(newRNG); } The owner can transfer _REWARD_TOKEN_ to any address. The current design framework Owner address will be sent to the address of the Mine contract. https://github.com/DODOEX/contractV2/blob/c7202eeae7/contracts/DODOToken/DODOMineV3/RewardVau lt.sol#L38-L49 function reward(address to, uint256 amount) external onlyOwner { require(_REWARD_RESERVE_ >= amount, \"VAULT_NOT_ENOUGH\"); _REWARD_RESERVE_ = _REWARD_RESERVE_.sub(amount); IERC20(_REWARD_TOKEN_).safeTransfer(to, amount); } function withdrawLeftOver(address to,uint256 amount) external onlyOwner { require(_REWARD_RESERVE_ >= amount, \"VAULT_NOT_ENOUGH\"); 20 _REWARD_RESERVE_ = _REWARD_RESERVE_.sub(amount); IERC20(_REWARD_TOKEN_).safeTransfer(to, amount); } The owner can mint tokens for any user and burn any user's tokens. https://github.com/DODOEX/contractV2/blob/c7202eeae7/contracts/external/ERC20/CustomERC20.sol#L12 3-L138 function mint(address user, uint256 value) external onlyOwner { require(isMintable, \"NOT_MINTABEL_TOKEN\"); balances[user] = balances[user].add(value); totalSupply = totalSupply.add(value); emit Mint(user, value); emit Transfer(address(0), user, value); } function burn(address user, uint256 value) external onlyOwner { require(isMintable, \"NOT_MINTABEL_TOKEN\"); balances[user] = balances[user].sub(value); totalSupply = totalSupply.sub(value); emit Burn(user, value); emit Transfer(user, address(0), value); } The owner can update the template contract. If an unaudited template contract is updated, this will affect the assets of the new user in the newly created contract. https://github.com/DODOEX/contractV2/blob/c7202eeae7/contracts/SmartRoute/proxies/DODOMineV3Prox y.sol#L128 function updateMineV2Template(address _newMineV3Template) external onlyOwner { _MINEV3_TEMPLATE_ = _newMineV3Template; } https://github.com/DODOEX/contractV2/blob/7e629d0e58/contracts/Factory/ERC20V2Factory.sol 21 function updateStdTemplate(address newStdTemplate) external onlyOwner { _ERC20_TEMPLATE_ = newStdTemplate; emit ChangeStdTemplate(newStdTemplate); } function updateCustomTemplate(address newCustomTemplate) external onlyOwner { _CUSTOM_ERC20_TEMPLATE_ = newCustomTemplate; emit ChangeCustomTemplate(newCustomTemplate); }",
        "labels": [
            "SlowMist",
            "DODO-MiningV3 and NFT",
            "Type: Authority Control Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "The DoS risk",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DODO-MiningV3 and NFT_en-us.pdf",
        "body": "Use a for loop to traverse the array. If the number of loops is large, it will cause an out of gas. After communication and feedback, the project team will ensure that the number of rewardTokenInfos will not be too much. 22 https://github.com/DODOEX/contractV2/blob/c7202eeae7/contracts/DODOToken/DODOMineV3/BaseMine.s ol#L258 function _updateAllReward(address user) internal { uint256 len = rewardTokenInfos.length; for (uint256 i = 0; i < len; i++) { _updateReward(user, i); } }",
        "labels": [
            "SlowMist",
            "DODO-MiningV3 and NFT",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Event log missing",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DODO-MiningV3 and NFT_en-us.pdf",
        "body": "The owner can arbitrarily set an external contract address as a template contract. When a user creates a new contract, it will be created based on the template contract. After creation, the asset needs to be recharged to the new contract. There is no event record, which is unfavorable for review by community users. https://github.com/DODOEX/contractV2/blob/c7202eeae7/contracts/SmartRoute/proxies/DODOMineV3Prox y.sol#L128 function updateMineV2Template(address _newMineV3Template) external onlyOwner { _MINEV3_TEMPLATE_ = _newMineV3Template; } The owner can modify the configuration of the contract, but there is no event record, which is unfavorable for review by community users. 23 https://github.com/DODOEX/contractV2/blob/c7202eeae7/contracts/Factory/Registries/DODOMineV3Registr y.sol#L87-L101 function addAdminList (address contractAddr) external onlyOwner { isAdminListed[contractAddr] = true; } function removeAdminList (address contractAddr) external onlyOwner { isAdminListed[contractAddr] = false; } function addSingleTokenList(address token) external onlyOwner { singleTokenList[token] = true; } function removeSingleTokenList(address token) external onlyOwner { singleTokenList[token] = false; }",
        "labels": [
            "SlowMist",
            "DODO-MiningV3 and NFT",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Check enhancement of isLpToken",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DODO-MiningV3 and NFT_en-us.pdf",
        "body": "Admin can add non-LPtoken assets but isLpToken is True, or belong to LPtoken assets but isLpToken is False Pool, which will affect the actual business logic. This part of the inspection is not implemented in the contract. https://github.com/DODOEX/contractV2/blob/c7202eeae7/contracts/Factory/Registries/DODOMineV3Registr y.sol#L44 function addMineV3( address mine, 24 bool isLpToken, address stakeToken ) override external { require(isAdminListed[msg.sender], \"ACCESS_DENIED\"); _MINE_REGISTRY_[mine] = stakeToken; if(isLpToken) { _LP_REGISTRY_[stakeToken] = mine; }else { require(_SINGLE_REGISTRY_[stakeToken].length == 0 || singleTokenList[stakeToken], \"ALREADY_EXSIT_POOL\"); _SINGLE_REGISTRY_[stakeToken].push(mine); } emit NewMineV3(mine, stakeToken, isLpToken); }",
        "labels": [
            "SlowMist",
            "DODO-MiningV3 and NFT",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Security reminder on architecture design",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DODO-MiningV3 and NFT_en-us.pdf",
        "body": "createStdERC20 and createMintableERC20 are open-ended calls. The user creates a contract using the createStdERC20 function to record the created information in _USER_STD_REGISTRY_ , and then can get the information through getTokenByUser. Because it is an open call, it is not recommended to use the data obtained by getTokenByUser. As input for other businesses, after communication and feedback, the project party will not rely on the data obtained by getTokenByUser in the business logic of the project. https://github.com/DODOEX/contractV2/blob/c7202eeae7/contracts/Factory/ERC20V2Factory.sol#L72-L123 function createStdERC20( uint256 totalSupply, string memory name, 25 string memory symbol, uint256 decimals ) external returns (address newERC20) { newERC20 = ICloneFactory(_CLONE_FACTORY_).clone(_ERC20_TEMPLATE_); IStdERC20(newERC20).init(msg.sender, totalSupply, name, symbol, decimals); _USER_STD_REGISTRY_[msg.sender].push(newERC20); emit NewERC20(newERC20, msg.sender, 0); } function createCustomERC20( uint256 initSupply, string memory name, string memory symbol, uint256 decimals, uint256 tradeBurnRatio, uint256 tradeFeeRatio, address teamAccount, bool isMintable ) external returns (address newCustomERC20) { newCustomERC20 = ICloneFactory(_CLONE_FACTORY_).clone(_CUSTOM_ERC20_TEMPLATE_); ICustomERC20(newCustomERC20).init( msg.sender, initSupply, name, symbol, decimals, tradeBurnRatio, tradeFeeRatio, teamAccount, isMintable ); _USER_CUSTOM_REGISTRY_[msg.sender].push(newCustomERC20); if(isMintable) emit NewERC20(newCustomERC20, msg.sender, 2); else emit NewERC20(newCustomERC20, msg.sender, 1); } // ============ View ============ function getTokenByUser(address user) external 26 view returns (address[] memory stds,address[] memory customs) { return (_USER_STD_REGISTRY_[user], _USER_CUSTOM_REGISTRY_[user]); }",
        "labels": [
            "SlowMist",
            "DODO-MiningV3 and NFT",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing event record",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - CheersUp_en-us.pdf",
        "body": "Modifying sensitive parameters in contracts lacks corresponding event records. function setProvenance(string memory provenance_) external onlyOwner { provenance = provenance_; } function setCUCPContractAddress(address address_) public onlyOwner { cucpContractAddress = address_; } function setWhitelistSaleConfig(WhitelistSaleConfig calldata config_) external onlyOwner { require(config_.price > 0, \"sale price must greater than zero\"); whitelistSaleConfig = config_; } function setPublicSaleConfig(PublicSaleConfig calldata config_) external onlyOwner { require(config_.price > 0, \"sale price must greater than zero\"); publicSaleConfig = config_; } function setRevealConfig(RevealConfig calldata config_) external onlyOwner { revealConfig = config_; }",
        "labels": [
            "SlowMist",
            "CheersUp",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Access control issue 9",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - CheersUp_en-us.pdf",
        "body": "The Owner role has the right to call the giveaway function to airdrop any number of blind boxes to any address at any time. function giveaway(address address_, uint64 numberOfTokens_) external onlyOwner nonReentrant { require(address_ != address(0), \"zero address\"); require(numberOfTokens_ > 0, \"invalid number of tokens\"); require(totalMinted() + numberOfTokens_ <= MAX_TOKEN, \"max supply exceeded\"); _safeMint(address_, numberOfTokens_); } The Owner role has the right to modify the cucpContractAddress contract address through the setCUCPContractAddress function, and unauthorized modication will result in the user's blind box being unable to be opened or arbitrarily modifying the blind box. function setCUCPContractAddress(address address_) public onlyOwner { cucpContractAddress = address_; } The Owner role has the right to modify the price of the blind box purchased by the user through the setWhitelistSaleCong function and the setPublicSaleCong function at any time. If the price of the blind box is modied after the sale starts, the user's transaction will fail. function setWhitelistSaleConfig(WhitelistSaleConfig calldata config_) external onlyOwner { require(config_.price > 0, \"sale price must greater than zero\"); whitelistSaleConfig = config_; } function setPublicSaleConfig(PublicSaleConfig calldata config_) external onlyOwner { require(config_.price > 0, \"sale price must greater than zero\"); publicSaleConfig = config_; } 10 The Owner has the right to modify the revealCong parameter through the setRevealCong function, which includes the address of the contract that opens the blind box, and the time and closing time of the blind box sale. function setRevealConfig(RevealConfig calldata config_) external onlyOwner { revealConfig = config_; }",
        "labels": [
            "SlowMist",
            "CheersUp",
            "Type: Authority Control Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Random number problem",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - CheersUp_en-us.pdf",
        "body": "The tokenId in the contract is related to the properties of the NFT. The tokenId is randomly generated through the random number on the chain, which will cause the random number to be predicted. function mint(address address_, uint256 cucpTokenId_) public returns(uint256) { require(_msgSender() == cucpContractAddress, \"not authorized\"); require(_numberMinted + 1 <= MAX_TOKEN, \"mint would exceed max supply\"); uint256 tokenId = randomToken(address_); _safeMint(address_, tokenId); unchecked { _numberMinted += 1; 11 } emit CheersUpRevealed(cucpTokenId_, tokenId); return tokenId; } function randomToken(address address_) internal returns (uint256) { unchecked { uint totalSize = MAX_TOKEN - _numberMinted; uint index = uint(keccak256(abi.encodePacked(_numberMinted, address_, block.difficulty, block.timestamp))) % totalSize; uint value = 0; if (randIndices[index] != 0) { value = randIndices[index]; } else { value = index; } if (randIndices[totalSize - 1] == 0) { randIndices[index] = totalSize - 1; } else { randIndices[index] = randIndices[totalSize - 1]; } return value; } }",
        "labels": [
            "SlowMist",
            "CheersUp",
            "Type: Others",
            "Severity: Low"
        ]
    },
    {
        "title": "4.2.1.1 Excessive auditing authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - MoonSwap_en-us.pdf",
        "body": "The owner in MasterStar contract can add a new lpToken through the add function, but if there is a black swan event, such as the addition of a malicious lpToken, there will be useless lpToken to recharge to get rewards. It is suggested that the owner can be handed over to the governance contract or time lock contract for management. function add(uint256 _allocPoint, IERC20 _lpToken, bool _withUpdate) public onlyOwner { if (_withUpdate) { massUpdatePools(); } require(poolIndexs[address(_lpToken)] < 1, \"LpToken exists\"); uint256 lastRewardBlock = block.number > startBlock ? block.number : startBlock; totalAllocPoint = totalAllocPoint.add(_allocPoint); poolInfo.push(PoolInfo({ lpToken: _lpToken, allocPoint: _allocPoint, lastRewardBlock: lastRewardBlock, tokenPerBlock: currentTokenPerBlock, accTokenPerShare: 0, finishMigrate: false, lockCrosschainAmount:0, crosschain_enable: false })); poolIndexs[address(_lpToken)] = poolInfo.length; } Owner can set migrator , It is suggested that the owner can be handed over to the governance contract or time lock contract for management. function setMigrator(IMigratorStar _migrator) public onlyOwner { migrator = _migrator; 7 } //Migratelptokentoanotherlpcontract.Canbecalledbyanyone.Wetrustthatmigratorcontractisgood. function migrate(uint256 _pid) public { require(address(migrator) != address(0), \"migrate: no migrator\"); PoolInfo storage pool = poolInfo[_pid]; IERC20 lpToken = pool.lpToken; uint256 bal = lpToken.balanceOf(address(this)); lpToken.safeApprove(address(migrator), bal); IERC20 newLpToken = migrator.migrate(lpToken); require(bal == newLpToken.balanceOf(address(this)), \"migrate: bad\"); pool.lpToken = newLpToken; pool.finishMigrate = true; } Fixed: The owner authority has been transferred to the timelock contract. Reference: https://etherscan.io/tx/0x3e8be2489c824906c7fe1abe376ccea198e3cd28cb225dee91d4f9c3e9 62a889",
        "labels": [
            "SlowMist",
            "MoonSwap",
            "Severity: Low"
        ]
    },
    {
        "title": "4.2.2.1 Compiler version is inconsistent",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - MoonSwap_en-us.pdf",
        "body": "The compiler version used by the imported contract is inconsistent. It is recommended to use a unified fixed compiler version when deploying. pragma solidity ^0.6.0; pragma solidity ^0.6.2; pragma solidity 0.6.12;",
        "labels": [
            "SlowMist",
            "MoonSwap",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.2.2.2 Better handling of ownership transfers",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - MoonSwap_en-us.pdf",
        "body": "When using the transferOwnership function to change the owner, it is recommended to add a 8 confirmation method that newOwner accepts the owner. The real authority transfer is performed after the new address is signed and confirmed to avoid the loss of authority. function transferOwnership(address newOwner) public virtual onlyOwner { require(newOwner != address(0), \"Ownable: new owner is the zero address\"); emit OwnershipTransferred(_owner, newOwner); _owner = newOwner; }",
        "labels": [
            "SlowMist",
            "MoonSwap",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.2.2.3 Enhancement point of delegateBySig function",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - MoonSwap_en-us.pdf",
        "body": "The nonce in the delegateBySig function is input by the user. When the user input a larger nonce, the current transaction cannot be success but the relevant signature data will still remain on the chain, causing this signature to be available for some time in the future. It is recommended to fix it according to EIP-2612. Reference: https://github.com/ethereum/EIPs/blob/master/EIPS/eip-2612.md#implementation. function delegateBySig( address delegatee, uint nonce, uint expiry, uint8 v, bytes32 r, bytes32 s external ) { bytes32 domainSeparator = keccak256( abi.encode( DOMAIN_TYPEHASH, keccak256(bytes(name())), getChainId(), address(this) ) ); 9 bytes32 structHash = keccak256( abi.encode( DELEGATION_TYPEHASH, delegatee, nonce, expiry ) ); bytes32 digest = keccak256( abi.encodePacked( \"\\x19\\x01\", domainSeparator, structHash ) ); address signatory = ecrecover(digest, v, r, s); require(signatory != address(0), \"MOON::delegateBySig: invalid signature\"); require(nonce == nonces[signatory]++, \"MOON::delegateBySig: invalid nonce\"); require(now <= expiry, \"MOON::delegateBySig: signature expired\"); return _delegate(signatory, delegatee); }",
        "labels": [
            "SlowMist",
            "MoonSwap",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.2.2.4 Mint issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - MoonSwap_en-us.pdf",
        "body": "The owner can mint tokens unlimitedly through mint function, but the owner's authority of the token contract is changed to MasterStar contract for the first time. function mint(address _to, uint256 _amount) public onlyOwner { _mint(_to, _amount); _moveDelegates(address(0), _delegates[_to], _amount); } Fixed: The owner authority has actually been transferred to the MasterStar contract. Reference: 10 https://etherscan.io/tx/0x0303672ee5045cd01102fdb50787541d11bddc3e1bfc446d4f6b46db85 e65bff",
        "labels": [
            "SlowMist",
            "MoonSwap",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.2.2.5 Using now globally available variables that will be deprecated",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - MoonSwap_en-us.pdf",
        "body": "The now globally available variables is used, which has been deprecated in compiler solidity 0.7.0. require(signatory != address(0), \"MOON::delegateBySig: invalid signature\"); require(nonce == nonces[signatory]++, \"MOON::delegateBySig: invalid nonce\"); require(now <= expiry, \"MOON::delegateBySig: signature expired\");",
        "labels": [
            "SlowMist",
            "MoonSwap",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.2.2.6 0 value is not checked",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - MoonSwap_en-us.pdf",
        "body": "The withdraw function suggests adding a check of _amount> 0, which can optimize the gas consumption when _amount is 0. function withdraw(uint256 _pid, uint256 _amount) public { PoolInfo storage pool = poolInfo[_pid]; require(!pool.finishMigrate, \"migrate not withdraw\"); UserInfo storage user = userInfo[_pid][msg.sender]; require(user.amount >= _amount, \"withdraw: not good\"); updatePool(_pid); uint256 pending = user.amount.mul(pool.accTokenPerShare).div(1e12).sub(user.rewardDebt); safeTokenTransfer(msg.sender, pending); user.amount = user.amount.sub(_amount); user.rewardDebt = user.amount.mul(pool.accTokenPerShare).div(1e12); pool.lpToken.safeTransfer(address(msg.sender), _amount); emit Withdraw(msg.sender, _pid, _amount); }",
        "labels": [
            "SlowMist",
            "MoonSwap",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.2.2.7 Prompt Error",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - MoonSwap_en-us.pdf",
        "body": "The prompt of setCrosschain function require has an error \"migrate not deposit\", it is recommended to modify the prompt to \"migrate not setCrosschain\". 11 function setCrosschain(uint256 _pid, bool isOk, address cmoonAddr) public onlyOwner { PoolInfo storage pool = poolInfo[_pid]; require(pool.finishMigrate, \"migrate not deposit\"); pool.crosschain_enable = isOk; require(cmoonAddr != address(0), \"address invalid\"); migratePoolAddrs[_pid] = cmoonAddr; } Fixed: The issue has been fixed by this commit: ef19afe4b6bfd624dd79903c36ea335be6a7b283.",
        "labels": [
            "SlowMist",
            "MoonSwap",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.2.2.8 Better handling of devaddr transfers",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - MoonSwap_en-us.pdf",
        "body": "When changing devaddr in the dev function, it is recommended to add newDevaddr to accept the replacement confirmation method. After the new address is signed and confirmed, the real change to devaddr can be made to avoid setting errors and the income cannot be normally obtained. function dev(address _devaddr) public { require(msg.sender == devaddr, \"dev: wut?\"); devaddr = _devaddr; }",
        "labels": [
            "SlowMist",
            "MoonSwap",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.2.2.9 Coding Standards",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - MoonSwap_en-us.pdf",
        "body": "The coding style of emergencyWithdraw function is to make an external call first, and then change the value of the contract variable. This way of writing, because lpToken is considered safe, there is no reentrancy problem, but it is recommended to use the correct coding standard: The variable is changed, and then an external call is made. A lock modifier for reentrancy prevention can also be added. function emergencyWithdraw(uint256 _pid) public { PoolInfo storage pool = poolInfo[_pid]; require(!pool.finishMigrate, \"migrate not withdraw\"); UserInfo storage user = userInfo[_pid][msg.sender]; pool.lpToken.safeTransfer(address(msg.sender), user.amount); 12 emit EmergencyWithdraw(msg.sender, _pid, user.amount); user.amount = 0; user.rewardDebt = 0; } Fixed: The issue has been fixed by this commit: ef19afe4b6bfd624dd79903c36ea335be6a7b283 5.",
        "labels": [
            "SlowMist",
            "MoonSwap",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.3.1.1 Reordering attack risk",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - InsurAce_en-us.pdf",
        "body": "When the owner calls preparePaymentForPayout, it will go to uniswap to calculate the required amountIn, and then perform the swap operation according to the amountIn. There is a risk of rearrangement attacks that may cause losses in the InsurAce pool. It is recommended to check the slippage of swap. Reference https://www.odaily.com/post/5162888 https://medium.com/coinmonks/demystify-the-dark-forest-on-ethereum-sandwich-attacks-5a3ae c9fa33e  contracts/pool/StakersPool.sol function claimPayout( address _fromToken, address _paymentToken, uint256 _settleAmtPT, address _claimTo, uint256 _claimId ) external override allowedCaller { require(_fromToken == poolToken, \"CP:1\"); 23 if (_settleAmtPT == 0) { return; } uint256 temp = _getTokenforExactPaymentToken(_fromToken, _paymentToken, _settleAmtPT); uint256 amountInMax = Math.min(stakedAmount, temp.mul(11).div(10)); uint256 convertOut = _convertTokenforExactPaymentToken(_fromToken, _paymentToken, _settleAmtPT, amountInMax); stakedAmount = stakedAmount.sub(convertOut); claimPayouts.push(convertOut); claimPayoutsClaimId.push(_claimId); _transferTokenTo(_paymentToken, _settleAmtPT, _claimTo, _claimId); } function _convertTokenforExactPaymentToken( address _tokenFrom, address _tokenTo, uint256 _amountOut, uint256 _amountInMax ) private returns (uint256) { require(_tokenFrom != _tokenTo, \"CT2EPT:1\"); address[] memory path = new address[](2); uint256[] memory ret; if (_tokenFrom == Constant.ETHTOKENADDRESS) { path[0] = uniswapRouter.WETH(); path[1] = _tokenTo; ret = uniswapRouter.swapETHForExactTokens{value: _amountInMax}( _amountOut, path, address(this), block.timestamp + 120 //solhint-disable-linenot-rely-on-time ); return ret[0]; } if (_tokenTo == Constant.ETHTOKENADDRESS) { path[0] = _tokenFrom; path[1] = uniswapRouter.WETH(); IERC20Upgradeable(path[0]).approve(Constant.UNISWAPV2_ROUTER_ADDRESS, _amountInMax); ret = uniswapRouter.swapTokensForExactETH( _amountOut, _amountInMax, path, 24 address(this), block.timestamp + 120 //solhint-disable-linenot-rely-on-time ); return ret[0]; } path[0] = _tokenFrom; path[1] = _tokenTo; IERC20Upgradeable(path[0]).approve(Constant.UNISWAPV2_ROUTER_ADDRESS, _amountInMax); ret = uniswapRouter.swapTokensForExactTokens( _amountOut, _amountInMax, path, address(this), block.timestamp + 120 //solhint-disable-linenot-rely-on-time ); return ret[0]; }  contracts/pool/StakersPool.sol function _getTokenforExactPaymentToken( address _tokenFrom, address _tokenTo, uint256 _amount ) private view returns (uint256) { if (_tokenFrom == _tokenTo) { return _amount; } address[] memory path = new address[](2); if (_tokenFrom == Constant.ETHTOKENADDRESS) { path[0] = uniswapRouter.WETH(); } else { path[0] = _tokenFrom; } if (_tokenTo == Constant.ETHTOKENADDRESS) { path[1] = uniswapRouter.WETH(); } else { path[1] = _tokenTo; } 25 uint256[] memory ret = uniswapRouter.getAmountsIn(_amount, path); return ret[0]; } Fix Status: The issues has been fixed.",
        "labels": [
            "SlowMist",
            "InsurAce",
            "Severity: High"
        ]
    },
    {
        "title": "4.3.1.2 Missing permission check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - InsurAce_en-us.pdf",
        "body": "The addCoverOwner function does not perform permission checking, any user can call this function to add owner. It is recommended to add permission check code.  contracts/cover/CoverData.sol function addCoverOwner(address owner) public { require(owner != address(0), \"ACO: 1\"); require(!allCoverOwnerFlagMap[owner], \"ACO: 2\"); allCoverOwnerList.push(owner); allCoverOwnerFlagMap[owner] = true; } Fix Status: The issues has been fixed.",
        "labels": [
            "SlowMist",
            "InsurAce",
            "Severity: High"
        ]
    },
    {
        "title": "4.3.2.1 DoS issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - InsurAce_en-us.pdf",
        "body": "_getDelAccuRwAmtPS has 3 while loop nestings, which will be affected by the parameters of lastScheduleCounter, gRewardTokenRatePerStakedTokenArray, _unstakeLockArrayBlockPerStaker, and dos due to more users or more mining cycles added.  contracts/staking/ScheduledMiningProgram.sol function _getDelAccuRwAmtPS( uint256 _lastCalculatedBlockPerStaker, uint256 _stakedAmtPerStaker, uint256[] memory _unstakeLockArrayBlockPerStaker, uint256[] memory _unstakeLockArrayAmtPerStaker 26 ) private view returns (uint256) { console.log(\"getDeltaAccumulativeRewardAmtPerStaker++\"); console.log(_lastCalculatedBlockPerStaker); console.log(_stakedAmtPerStaker); console.log(_unstakeLockArrayBlockPerStaker.length); uint256 retV = 0; //gothruthelistofallschedules uint256 scheduleIndex = lastScheduleCounter; while (scheduleIndex >= 1) { if (_lastCalculatedBlockPerStaker >= endMiningBlockPerSchedule[scheduleIndex]) { break; } //narrowdownblockdelta uint256 minWall = Math.max(_lastCalculatedBlockPerStaker, startMiningBlockPerSchedule[scheduleIndex]); uint256 maxWall = Math.min(block.number, endMiningBlockPerSchedule[scheduleIndex]); console.log(\"minWall: \", minWall); console.log(\"maxWall: \", maxWall); if (minWall >= maxWall) { scheduleIndex = scheduleIndex.sub(1); continue; } uint256 rateChangeIndex = gRewardTokenRatePerStakedTokenArray.length; if (rateChangeIndex == 0) { break; } uint256 rewardAccumulatedBetweenWalls = 0; while (rateChangeIndex > 0) { uint256 blockNumber = gRewardTokenRatePerStakedTokenArray[rateChangeIndex - 1]; console.log(\"blockNumber: \", blockNumber); if (blockNumber >= maxWall) { rateChangeIndex = rateChangeIndex.sub(1); continue; } if (blockNumber >= minWall) { uint256 delta = _getDeltaAccumulativeRewardsWithFixRatePerStaker(blockNumber, maxWall, gRewardTokenRatePerStakedTokenMap[blockNumber], _stakedAmtPerStaker, _unstakeLockArrayBlockPerStaker, _unstakeLockArrayAmtPerStaker); rewardAccumulatedBetweenWalls = delta.add(rewardAccumulatedBetweenWalls); maxWall = blockNumber; rateChangeIndex = rateChangeIndex.sub(1); continue; 27 } if (blockNumber < minWall) { uint256 delta = _getDeltaAccumulativeRewardsWithFixRatePerStaker(minWall, maxWall, gRewardTokenRatePerStakedTokenMap[blockNumber], _stakedAmtPerStaker, _unstakeLockArrayBlockPerStaker, _unstakeLockArrayAmtPerStaker); rewardAccumulatedBetweenWalls = delta.add(rewardAccumulatedBetweenWalls); break; } } retV = rewardAccumulatedBetweenWalls.add(retV); scheduleIndex = scheduleIndex.sub(1); } return retV; } Fix Status: This issue has been fixed",
        "labels": [
            "SlowMist",
            "InsurAce",
            "Severity: Medium"
        ]
    },
    {
        "title": "4.3.3.1 Excessive authority issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - InsurAce_en-us.pdf",
        "body": "Admin has permission to add sender, There is a issues of excessive authority. It is recommended to set Owner to Timelock contract or governance contract.  contracts/token/INSURToken.sol function addSender(address _from) external onlyAdmin { if (1 == transferFromAllowedList[_from]) { return; } membersFrom.push(_from); transferFromAllowedList[_from] = 1; } The admin can remove the sender arbitrarily, and there is a risk of denial of service. When the admin adds too many senders, the data in the memberFrom array will be very large, so when the removeSender is removed, the depth of the for loop call will be too large, resulting in The call fails. It 28 is recommended to change memberFrom to storage in the way of mapping, and use address as the key to avoid dos caused by this type of looping to obtain data.  contracts/token/INSURToken.sol function removeSender(address _from) external onlyAdmin { uint256 arrayLength = membersFrom.length; uint256 indexToBeDeleted; bool toDelete = false; for (uint256 i = 0; i < arrayLength; i++) { if (membersFrom[i] == _from) { indexToBeDeleted = i; toDelete = true; break; } } if (!toDelete) { return; } //ifindextobedeletedisnotthelastindex,swapposition. if (indexToBeDeleted < arrayLength - 1) { membersFrom[indexToBeDeleted] = membersFrom[arrayLength - 1]; } //wecannowreducethearraylengthby1 membersFrom.pop(); delete transferFromAllowedList[_from]; } MINTER can call mint arbitrarily, and there is no upper limit for minting.  contracts/token/INSURToken.sol function mint(address to, uint256 amount) public virtual { require(hasRole(MINTER_ROLE, _msgSender()), \"ERC20PresetMinterPauser: must have minter role to mint\"); _mint(to, amount); } Fix Status: This issue has been confirmed  after communication and feedback, the minting and Owner permissions may be transferred to address(0) in the future. 29 Owner can set lpTokenMinter and lpTokenBurner. The roles of lpTokenMinter and lpTokenBurner can mint and burn the user's LP. There is a issues of excessive authority. It is recommended to set Owner to Timelock contract or governance contract. And make sure the lpTokenMinter and lpTokenBurner cannot be EOA account.  contracts/token/LPToken.sol function setup(address _lpTokenMinter, address _lpTokenBurner) external onlyOwner { require(_lpTokenMinter != address(0), \"S:1\"); lpTokenMinter = _lpTokenMinter; require(_lpTokenBurner != address(0), \"S:2\"); lpTokenBurner = _lpTokenBurner; } Fix Status: This issue has been communicated back to the project team. The project team is aware of this and will adopt governance mechanism to secure the permission when the governance module goes live.",
        "labels": [
            "SlowMist",
            "InsurAce",
            "Severity: Low"
        ]
    },
    {
        "title": "4.3.3.2 DoS issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - InsurAce_en-us.pdf",
        "body": "The incoming _callers will add data to allowedCallersArray[_callee]. If too many _callers are added at one time, it will cause Out of Gas. When there are too many data in allowedCallersArray[_callee], the setAllowdCallersPerCallee function will DoS. It is recommended to set the data Use the mapping method to store instead, avoid using the for loop to find the value.  contracts/secmatrix/SecurityMatrix.sol function addAllowdCallersPerCallee(address _callee, address[] memory _callers) external onlyOwner { require(_callers.length != 0, \"AACPC:1\"); require(allowedCallersArray[_callee].length != 0, \"AACPC:2\"); for (uint256 index = 0; index < _callers.length; index++) { console.log(\"_callers index: \", _callers[index], index); allowedCallersArray[_callee].push(_callers[index]); 30 allowedCallersMap[_callee][_callers[index]] = 1; } }  contracts/secmatrix/SecurityMatrix.sol function setAllowdCallersPerCallee(address _callee, address[] memory _callers) external onlyOwner { console.log(\"_callee: \", _callee); console.log(\"_callers.length: \", _callers.length); require(_callers.length != 0, \"SACPC:1\"); //checkifcalleeexist if (allowedCallersArray[_callee].length == 0) { //notexist,soaddcallee allowedCallees.push(_callee); } else { //ifcalleeexist,thenpurgedata for (uint256 i = 0; i < allowedCallersArray[_callee].length; i++) { delete allowedCallersMap[_callee][allowedCallersArray[_callee][i]]; } delete allowedCallersArray[_callee]; } //andoverwrite for (uint256 index = 0; index < _callers.length; index++) { console.log(\"_callers index: \", _callers[index], index); allowedCallersArray[_callee].push(_callers[index]); allowedCallersMap[_callee][_callers[index]] = 1; } } Fix Status: This issue has been communicated back to project team. The project team is aware of this issue and the method will only be used by admin when setting up security matrix. The setAllowdCallersPerCallee method will be used to create security matrix entries, and the addAllowdCallersPerCallee method will be used to add delta matrix if needed.",
        "labels": [
            "SlowMist",
            "InsurAce",
            "Severity: Low"
        ]
    },
    {
        "title": "4.3.3.3 Repeatable call risk",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - InsurAce_en-us.pdf",
        "body": "If Owner call setupVestors function multiple times, there will be duplicate vestors in the vestor 31 array.When the setupVestors is called multiple times, if the vestor calls withdrawRewardPV intentionally or unintentionally during the calling process, initRewardPV and insurVestingTotalPV may get unexpected values. If setupVestors can be called multiple times, then when the owner is called, the vestor also calls withdrawRewardPV. In this case, the gas price of calling withdrawRewardPV is higher than that of calling setupVestors. Will execute withdrawRewardPV first, and then execute setupVestors, the data will appear unexpected. Competitive conditions similar to approve.  contracts/fixedvesting/FixedVesting.sol function setupVestors( address[] memory _vestors, uint256[] memory _vestingRewardPV, uint256[] memory _initRewardPV ) external onlyOwner { require(_vestors.length == _vestingRewardPV.length, \"AV:1\"); require(_initRewardPV.length == _vestingRewardPV.length, \"AV:2\"); for (uint256 i = 0; i < _vestors.length; i++) { address vestor = _vestors[i]; vestors.push(vestor); initRewardPV[vestor] = _initRewardPV[i]; insurVestingTotalPV[vestor] = _vestingRewardPV[i]; } } Fix Status: This issue has been fixed.",
        "labels": [
            "SlowMist",
            "InsurAce",
            "Severity: Low"
        ]
    },
    {
        "title": "4.3.3.4 Overflow risk",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - InsurAce_en-us.pdf",
        "body": "safemath should be used to calculate the length of the array to avoid overflow issues: if Currency is not added, the removal may cause overflow issues.  contracts/cover/CoverConfig.sol 32 function removeCurrency(address currency) external allowedCaller { require(currency != address(0), \"RC: 1\"); uint256 arrayLength = currencyValidAddressArray.length; uint256 indexToBeDeleted; bool toDelete = false; for (uint256 i = 0; i < arrayLength; i++) { if (currencyValidAddressArray[i] == currency) { indexToBeDeleted = i; toDelete = true; break; } } if (!toDelete) { require(toDelete, \"RC: 1\"); } //ifindextobedeletedisnotthelastindex,swapposition. if (indexToBeDeleted < arrayLength - 1) { currencyValidAddressArray[indexToBeDeleted] = currencyValidAddressArray[arrayLength - 1]; } //wecannowreducethearraylengthby1 currencyValidAddressArray.pop(); delete currencyValidAddressMap[currency]; } Fix Status: This issue has been fixed.",
        "labels": [
            "SlowMist",
            "InsurAce",
            "Severity: Low"
        ]
    },
    {
        "title": "4.3.3.5 FlashLoan attack risk",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - InsurAce_en-us.pdf",
        "body": "Unstake is judged by >= when there are already voting tasks. If claimsAssessorMinUnstakeTime is 0, then there will be a issue of using flashloan to vote.  contracts/claim/Claim.sol function unstake(address insurTokenAddress, uint256 insurAmount) external payable whenNotPaused nonReentrant { require(insurTokenAddress != address(0), \"USTK: 1\"); address payable assessor = _msgSender(); ClaimReward(crw).recalculateAssessor(assessor); bool canUnstake = false; 33 uint256 latestVoteTimestamp = ClaimAssessor(asr).getLatestVoteTimestamp(assessor); if (latestVoteTimestamp == 0) { canUnstake = true; } else { if ( block.timestamp >= ClaimAssessor(asr).getVoteStakePeriodEndTime(assessor) //solhint-disable-line not-rely-on-time canUnstake = true; ) { } } require(canUnstake, \"USTK: 2\"); require(insurAmount <= ClaimAssessor(asr).getNumOfVotes(assessor), \"USTK: 3\"); require(IERC20Upgradeable(insurTokenAddress).balanceOf(address(this)) >= insurAmount, \"USTK: 4\"); ClaimAssessor(asr).decreaseVotes(assessor, insurAmount); IERC20Upgradeable(insurTokenAddress).safeTransfer(assessor, insurAmount); } Fix Status: This issue has been fixed.",
        "labels": [
            "SlowMist",
            "InsurAce",
            "Severity: Low"
        ]
    },
    {
        "title": "4.3.4.1 Token compatibility risk",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - InsurAce_en-us.pdf",
        "body": "IERC20Upgradeable(stakedToken).safeTransferFrom(_msgSender(), address(this), _amount); The transfer operation of an external token is adopted. It is recommended to pay attention to the compatibility of the project and the token when adding a new token, such as: token return Value issues, fake token recharge issues, compatibility issues with deflationary tokens, etc.  contracts/staking/StakeOps.sol function stakeTokens(uint256 _amount, address _token) external payable whenNotPaused nonReentrant { require(IMiningProgram(iMiningProgram).canStake(_amount), \"ST:1\"); address stakedToken = StakersData(stakerDataAddr).stakedToken(); require(_token == stakedToken, \"ST:2\"); 34 if (stakedToken == Constant.ETHTOKENADDRESS) { require(_amount <= msg.value, \"ST:3\"); } else { require(IERC20Upgradeable(stakedToken).balanceOf(_msgSender()) >= _amount, \"ST:4\"); uint256 allowanceAmt = IERC20Upgradeable(stakedToken).allowance(_msgSender(), address(this)); require(allowanceAmt >= _amount, \"ST:5\"); } _reCalcPerStaker(); if (stakedToken != Constant.ETHTOKENADDRESS) { IERC20Upgradeable(stakedToken).safeTransferFrom(_msgSender(), address(this), _amount); } //dispatchtokentopool if (stakedToken == Constant.ETHTOKENADDRESS) { IStakersPool(iStakersPool).addStkAmount{value: _amount}(stakedToken, _amount); } else { IERC20Upgradeable(stakedToken).safeTransfer(iStakersPool, _amount); Fix Status: This issue has been communicated back to project team. The project team is aware of this and has already performed compatibility checks on the staking tokens, such as ETH, WETH, USDC, USDT, DAI, and INSUR, which are all compatible with the relevant standards.",
        "labels": [
            "SlowMist",
            "InsurAce",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.3.4.2 Event log is missing",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - InsurAce_en-us.pdf",
        "body": "It is recommended to add an event to record securityMatrix changes, applicable to all set functions. function setup(address _securityMatrix) external onlyOwner { require(_securityMatrix != address(0), \"S:1\"); securityMatrix = _securityMatrix; } Fix Status: This issue has been communicated back to project team. The project team will add more event logs in their development, including not limited to \"setup\".",
        "labels": [
            "SlowMist",
            "InsurAce",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.3.4.3 Redundant code",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - InsurAce_en-us.pdf",
        "body": "The `if (!toDelete) {require(toDelete, \"RC: 1\"); }` code can be simplified to `require(toDelete, \"RC: 1\");`. 35  contracts/cover/CoverConfig.sol function removeCurrency(address currency) external allowedCaller { require(currency != address(0), \"RC: 1\"); uint256 arrayLength = currencyValidAddressArray.length; uint256 indexToBeDeleted; bool toDelete = false; for (uint256 i = 0; i < arrayLength; i++) { if (currencyValidAddressArray[i] == currency) { indexToBeDeleted = i; toDelete = true; break; } } if (!toDelete) { require(toDelete, \"RC: 1\"); } //ifindextobedeletedisnotthelastindex,swapposition. if (indexToBeDeleted < arrayLength - 1) { currencyValidAddressArray[indexToBeDeleted] = currencyValidAddressArray[arrayLength - 1]; } //wecannowreducethearraylengthby1 currencyValidAddressArray.pop(); delete currencyValidAddressMap[currency]; } Fix Status: This issue has been fixed.",
        "labels": [
            "SlowMist",
            "InsurAce",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.3.4.4 Hard coded issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - InsurAce_en-us.pdf",
        "body": "The external contract address is hard-coded and cannot be modified. It is recommended that the external contract adopts a changeable method to avoid the problem that the project cannot operate normally due to the upgrade of the external contract.  common/Constant.sol address public constant UNISWAPV2_ROUTER_ADDRESS = address(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D); 36 Fix Status: This issue has been communicated back to project team. The project team is aware of this issue, and made design changes, such as adding exchange library lately, which will include token to token exchange queries from 1inch and Uniswap. In the case of address change, the ABI of the address may change accordingly, as such the project team will need to double check, and/or extend exchange library in tandem. 5.",
        "labels": [
            "SlowMist",
            "InsurAce",
            "Severity: Informational"
        ]
    },
    {
        "title": "Missing event record",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap_Pottery_en-us.pdf",
        "body": "When the sensitive parameters of the contract are modied, the corresponding events are not recorded, which is not conducive to the supervision of the community and users. ",
        "labels": [
            "SlowMist",
            "PancakeSwap_Pottery",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Business logic problem",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap_Pottery_en-us.pdf",
        "body": "The contract does not check whether the incoming address and ID exist. If the wrong data is passed in in the actual operation, it will lead to waste of resources. ",
        "labels": [
            "SlowMist",
            "PancakeSwap_Pottery",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap_Pottery_en-us.pdf",
        "body": "The Owner has the right to modify the address of the contract to any address. ",
        "labels": [
            "SlowMist",
            "PancakeSwap_Pottery",
            "Type: Authority Control Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "4.2.1.1 __Guard_init function was not call when initialize",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Hot Cross BSC Bridge V1.0.1_en-us.pdf",
        "body": "ForeignProcessor contract and HomeRequest contract are inherit the Guard contract but dost not call the __Gurad_init function function __ForeignProcessor_init( IERC20 token, ValidatorRegistry validatorRegistry_ ) internal initializer { //SlowMist// Missing call of __Guard_init function require( address(token) != address(0) && Misc.isContract(address(token)), \"ForeignProcessor:Invalid erc20 address provided\" 10 ); require( address(validatorRegistry_) != address(0) && Misc.isContract(address(validatorRegistry_)), \"ForeignProcessor:Invalid validator registry address\" ); erc20 = token; validatorRegistry = validatorRegistry_; } function __HomeRequest_init( BEP20 token, ValidatorRegistry validatorRegistry_ ) internal initializer { //SlowMist// Missing call of __Guard_init function require( address(token) != address(0) && Misc.isContract(address(token)), \"HomeRequest:Invalid BEP20 address\" ); require( address(validatorRegistry_) != address(0) && Misc.isContract(address(validatorRegistry_)), \"HomeRequest:Invalid validator registry address\" ); bep20 = token; validatorRegistry = validatorRegistry_; } Fix status: fixed. 11 5.",
        "labels": [
            "SlowMist",
            "Hot Cross BSC Bridge V1.0.1",
            "Severity: Informational"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - X2Y2 - NFT Lending_en-us.pdf",
        "body": "1.In the Cong contract, the owner role can add manager role and can update the adminShare, and the manager role can set or remove the ERC20 and ERC721 tokens through the setERC20Permits and setERC721Permits functions. If the ERC20 and ERC721 on the loan list, the manager sets these permit as false may cause the risk of excessive authority. ",
        "labels": [
            "SlowMist",
            "X2Y2 - NFT Lending",
            "Type: Authority Control Vulnerability",
            "Severity: High"
        ]
    },
    {
        "title": "Token compatibility issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - X2Y2 - NFT Lending_en-us.pdf",
        "body": "In the XY3 contract, the lender will transfer the ERC20 token to the borrower in the borrow function also to the lender and adminFeeReceiver in the repay function. And this transfer is used the SafeER20 safeTransferFrom function and transfer the exact amount of the borrowAmount, payoAmount and adminFee. If the borrowAsset ERC20 tokens are the deationary tokens (or other tokens that require a transfer fee) which will cause the call failed. ",
        "labels": [
            "SlowMist",
            "X2Y2 - NFT Lending",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Dev address setting enhancement suggestions",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - X2Y2 - NFT Lending_en-us.pdf",
        "body": "In the Cong contract, the manager role can update the adminFeeReceiver in the updateAdminFeeReceiver function to receive the adminFee. If the adminFeeReceiver address is an EOA address, in a scenario where the private key is leaked, the teams revenue will be stolen. ",
        "labels": [
            "SlowMist",
            "X2Y2 - NFT Lending",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Did not check whether the pair exists",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - O3 swap_en-us.pdf",
        "body": "The _swapSupportingFeeOnTransferTokens function of the O3swapBSCPancakeBridge / O3swapETHUniswapBridge / O3swapHecoMdexBridge contract did not verify the existence of the pair, which caused the exchange to fail function _swapSupportingFeeOnTransferTokens(address[] memory path, address _to) internal virtual { for (uint i; i < path.length - 1; i++) { (address input, address output) = (path[i], path[i + 1]); (address token0,) = PancakeLibrary.sortTokens(input, output); //SlowMist// There is no check to see if the pair exists, which causes the exchange to fail 18 IPancakePair pair = IPancakePair(PancakeLibrary.pairFor(pancakeFactory, input, output)); uint amountInput; uint amountOutput; { // scope to avoid stack too deep errors (uint reserve0, uint reserve1,) = pair.getReserves(); (uint reserveInput, uint reserveOutput) = input == token0 ? (reserve0, reserve1) : (reserve1, reserve0); amountInput = IBEP20(input).balanceOf(address(pair)).sub(reserveInput); amountOutput = PancakeLibrary.getAmountOut(amountInput, reserveInput, reserveOutput); } (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0)); address to = i < path.length - 2 ? PancakeLibrary.pairFor(pancakeFactory, output, path[i + 2]) : _to; pair.swap(amount0Out, amount1Out, to, new bytes(0)); } }",
        "labels": [
            "SlowMist",
            "O3 swap",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Excessive permissions",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - O3 swap_en-us.pdf",
        "body": "The collect function of the O3 staking contract can transfer any tokens in the contract, including the users assets. There is a problem of excessive authority. It is recommended to limit the token != stakingToken function collect(address token, address to) external nonReentrant onlyOwner _logs_ { //SlowMist// Excessive authority issues, should be restricted token != staking Token uint balance = IERC20(token).balanceOf(address(this)); _pushToken(token, to, balance); }",
        "labels": [
            "SlowMist",
            "O3 swap",
            "Type: Authority Control Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap_v3_Phase2_en-us.pdf",
        "body": "1.The owner role can change the external part contract FARM_BOOSTER through the updateFarmBoostContract function and the external part contract can aect the boostMultiplier . ",
        "labels": [
            "SlowMist",
            "PancakeSwap_v3_Phase2",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "LP token locking issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap_v3_Phase2_en-us.pdf",
        "body": "In the MasterChefV3 contract, users will transfer their ERC721 LP tokens for staking to get the CAKE as reward. Users can only call the safeTransferFrom function to transfer their ERC721 LP token in the MasterChefV3 contract to trigger the _checkOnERC721Received hook to let the NonfungiblePositionManager contract call back the onERC721Received function. After this, the positionInfo can be recorded and make the staking eective. If users miss transferring the LP token by using the transferFrom function, the LP tokens will be locked in this contract. ",
        "labels": [
            "SlowMist",
            "PancakeSwap_v3_Phase2",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Cast truncation issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap_v3_Phase2_en-us.pdf",
        "body": "In the PancakeV3LmPool contract, the Pool or MasterChef will calculate the reward through the accumulateReward function. The uint256 endTime is assigned by getLatestPeriodInfo in the MasterChef contract and the endTime is assigned by an uint256 value latestPeriodEndTime , then the endTime will cast to an uint32 to endTimestamp . If the latestPeriodEndTime is larger than type(uin32).max , there will be a cast truncation issue. And PancakeV3LmPool contract imports the SafeCast contract but doesnt use it for the uin32 cast. ",
        "labels": [
            "SlowMist",
            "PancakeSwap_v3_Phase2",
            "Type: Arithmetic Accuracy Deviation Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Pancakeswap-CakePool_en-us.pdf",
        "body": "In the cakePool contract, the owner role can set the DURATION_FACTOR and DURATION_FACTOR_OVERDUE by 7 calling the setDurationFactor and setDurationFactorOverdue. If these values are set too large or too small, this may aect the calculation of user.shares when calling the deposit and withdraw function. ",
        "labels": [
            "SlowMist",
            "Pancakeswap-CakePool",
            "Type: Authority Control Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Missing event records",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Pancakeswap-CakePool_en-us.pdf",
        "body": "In the cakePool contract, the owner role can set admin, treasury, operator, boostContract, freeFeeUsers, performanceFee, performanceFeeContract, withdrawFee, withdrawFeeContract, withdrawFeePeriod, MAX_LOCK_DURATION, DURATION_FACTOR, DURATION_FACTOR_OVERDUE, UNLOCK_FREE_DURATION and 8 BOOST_WEIGHT by calling the setAdmin, setTreasury, setOperator, setBoostContract, setFreeFeeUser, setPerformanceFee, setPerformanceFeeContract, setWithdrawFee, setWithdrawFeeContract, setWithdrawFeePeriod, setMaxLockDuration, setDurationFactor, setDurationFactorOverdue, setUnlockFreeDuration and setBoostWeight. but there no event logging is preformed. ",
        "labels": [
            "SlowMist",
            "Pancakeswap-CakePool",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Excessive Authority Issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - wault.finance(WSwap)_en-us.pdf",
        "body": "The owner can set the value of wexPerBlock arbitrarily, which will affect the profit of wexReward, and there is no limit on the value range of wexPerBlock, and there is a issue of excessive authority. https://bscscan.com/address/0x22fB2663C7ca71Adc2cc99481C77Aaf21E152e2D function setWexPerBlock(uint256 _wexPerBlock) public onlyOwner { require(_wexPerBlock > 0, \"!wexPerBlock-0\"); wexPerBlock = _wexPerBlock; } Owner can add pool, can set the allocPoint of pool, there is a issue of selfish mining. function add( uint256 _allocPoint, IERC20 _lpToken, bool _withUpdate ) public onlyOwner { if (_withUpdate) { massUpdatePools(); } uint256 lastRewardBlock = block.number > startBlock ? block.number : startBlock; totalAllocPoint = totalAllocPoint.add(_allocPoint); poolInfo.push( PoolInfo({ lpToken: _lpToken, allocPoint: _allocPoint, lastRewardBlock: lastRewardBlock, accWexPerShare: 0 }) ); 12 function set( uint256 _pid, uint256 _allocPoint, bool _withUpdate ) public onlyOwner { if (_withUpdate) { massUpdatePools(); } totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add( _allocPoint ); poolInfo[_pid].allocPoint = _allocPoint; }",
        "labels": [
            "SlowMist",
            "wault.finance(WSwap)",
            "Type: Others",
            "Severity: Low"
        ]
    },
    {
        "title": "Repeatable initialization issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap_MOVE_en-us.pdf",
        "body": "In the swap module RESOURCE_ACCOUNT can initialize SwapInfo through the init_storage function, but the function does not check for repeated initialization. ",
        "labels": [
            "SlowMist",
            "PancakeSwap_MOVE",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Gas optimization",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap_MOVE_en-us.pdf",
        "body": "In the swap module, the add_liquidity function is used to add liquidity and return the remaining tokens to the user. But without checking whether the token value to be returned is greater than 0, the coin::deposit function is called. If the returned token value is 0, this will cause unnecessary gas consumption. ",
        "labels": [
            "SlowMist",
            "PancakeSwap_MOVE",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Architecture optimization",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap_MOVE_en-us.pdf",
        "body": "The storage of LP tokens is realized through storage.move in the protocol. But the creation of Pair is realized through the create_pair of the swap module and the resource storage is carried out by TokenPairMetadata and TokenPairReserve. So LPToken can be implemented directly in swap module without having to implement it in storage.move separately. ",
        "labels": [
            "SlowMist",
            "PancakeSwap_MOVE",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Assertion aw issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap_MOVE_en-us.pdf",
        "body": "In the swap module, the mint function is used to mint LP tokens when liquidity is added. When adding liquidity for the rst time, the liquidity amount needs to meet MINIMUM_LIQUIDITY. If the MINIMUM_LIQUIDITY is not met, the 12 transaction will be revet. In this case the protocol will throw an overow error instead of ERROR_INSUFFICIENT_LIQUIDITY_MINTED. ",
        "labels": [
            "SlowMist",
            "PancakeSwap_MOVE",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Not checked if pair has been created",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap_MOVE_en-us.pdf",
        "body": "In the router module contract, users can remove liquidity and exchange tokens through the functions remove_liquidity, swap_exact_input, swap_exact_output, swap_exact_input_doublehop, 13 swap_exact_output_doublehop, swap_exact_input_triplehop and swap_exact_output_triplehop respectively, but do not check whether a pair is created rst. ",
        "labels": [
            "SlowMist",
            "PancakeSwap_MOVE",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Redundant code",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap_MOVE_en-us.pdf",
        "body": "In the Swap module, the quote_x_to_y_after_fees, quote_y_to_x_after_fees, transfer_x and transfer_y functions are all internal functions, but no other public functions call them. ",
        "labels": [
            "SlowMist",
            "PancakeSwap_MOVE",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "k value check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap_MOVE_en-us.pdf",
        "body": "During the swap process, it is necessary to check whether the multiplication of the token balance of the pair after the swap is strictly greater than or equal to the k value. However, due to the fee charged during the swap process, in theory, the multiplication of the token balance of the pair after swap must be strictly greater than the k value. While using u256 avoids close rounding errors it is still not necessary to check if it is equal to the k value. ",
        "labels": [
            "SlowMist",
            "PancakeSwap_MOVE",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap_MOVE_en-us.pdf",
        "body": "In the swap module contract, the admin role can call the upgrade_swap function to upgrade the entire contract. If administrator privileges are stolen, it may have an impact on the normal operation of the contract. ",
        "labels": [
            "SlowMist",
            "PancakeSwap_MOVE",
            "Type: Excessive Authority Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "4.2.1.1 The settleHolderInterest is not used to update user interest before Withdraw",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - dFuture_en-us.pdf",
        "body": "The code uses payOffInterest to process the user's interest when processing the user's withdraw, but it did not use settleHolderInterest to update the user's interest situation before, resulting in a deviation in the interest payment. ",
        "labels": [
            "SlowMist",
            "dFuture",
            "Severity: Low"
        ]
    },
    {
        "title": "4.2.1.2 The global status is not updated when using the getMarginRatioOf function",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - dFuture_en-us.pdf",
        "body": "to calculate the user's position When using the getMarginRationOf function to calculate the user's position, the global state is not updated with updateGlobalInterestRate first, which may cause calculation errors. ",
        "labels": [
            "SlowMist",
            "dFuture",
            "Severity: Low"
        ]
    },
    {
        "title": "4.2.1.3 When calculating the user's position,",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - dFuture_en-us.pdf",
        "body": "the user's intereset <0 is not considered When using the getMarginRationOf function to calculate the user's position, the case of rate <0 is not 22 processed. ",
        "labels": [
            "SlowMist",
            "dFuture",
            "Severity: Low"
        ]
    },
    {
        "title": "4.2.2.1 did not consider the issue of system compensation, and did not limit the",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - dFuture_en-us.pdf",
        "body": "maximum benefits of users The system code does not consider whether the system can pay for this when processing the user's position closing. When this happens, it will cause an unknown error. ",
        "labels": [
            "SlowMist",
            "dFuture",
            "Severity: Low"
        ]
    },
    {
        "title": "Access control issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - CheersUp_alpha8_en-us.pdf",
        "body": "The Owner role has the right to call the giveaway function to airdrop any number of blind boxes to any address at any time. function giveaway(address address_, uint64 numberOfTokens_) external onlyOwner nonReentrant { require(address_ != address(0), \"zero address\"); require(numberOfTokens_ > 0, \"invalid number of tokens\"); require(totalMinted() + numberOfTokens_ <= MAX_TOKEN, \"max supply exceeded\"); _safeMint(address_, numberOfTokens_); } The Owner role has the right to modify the cucpContractAddress contract address through the setCUCPContractAddress function, and unauthorized modication will result in the user's blind box being unable to be opened or arbitrarily modifying the blind box. function setCUCPContractAddress(address address_) public onlyOwner { cucpContractAddress = address_; } The Owner role has the right to modify the price of the blind box purchased by the user through the setWhitelistSaleCong function and the setPublicSaleCong function at any time. If the price of the blind box is modied after the sale starts, the user's transaction will fail. function setWhitelistSaleConfig(WhitelistSaleConfig calldata config_) external onlyOwner { require(config_.price > 0, \"sale price must greater than zero\"); whitelistSaleConfig = config_; } 9 function setPublicSaleConfig(PublicSaleConfig calldata config_) external onlyOwner { require(config_.price > 0, \"sale price must greater than zero\"); publicSaleConfig = config_; } The Owner has the right to modify the revealCong parameter through the setRevealCong function, which includes the address of the contract that opens the blind box, and the time and closing time of the blind box sale. function setRevealConfig(RevealConfig calldata config_) external onlyOwner { revealConfig = config_; }",
        "labels": [
            "SlowMist",
            "CheersUp_alpha8",
            "Type: Authority Control Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Random number problem",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - CheersUp_alpha8_en-us.pdf",
        "body": "The tokenId in the contract is related to the properties of the NFT. The tokenId is randomly generated through the random number on the chain, which will cause the random number to be predicted. function mint(address address_, uint256 cucpTokenId_) public returns(uint256) { require(_msgSender() == cucpContractAddress, \"not authorized\"); 10 require(_numberMinted + 1 <= MAX_TOKEN, \"mint would exceed max supply\"); uint256 tokenId = randomToken(address_); _safeMint(address_, tokenId); unchecked { _numberMinted += 1; } emit CheersUpRevealed(cucpTokenId_, tokenId); return tokenId; } function getRandomTokenId() internal returns (uint256) { unchecked { uint256 remain = MAX_TOKEN - _numberMinted; uint256 pos = unsafeRandom() % remain; uint256 val = _randIndices[pos] == 0 ? pos : _randIndices[pos]; _randIndices[pos] = _randIndices[remain - 1] == 0 ? remain - 1 : _randIndices[remain - 1]; return val; } } /** * @notice unsafeRandom is used to generate a random number by on-chain randomness. * Please note that on-chain random is potentially manipulated by miners, and most scenarios suggest using VRF. * @return randomly generated number. */ function unsafeRandom() internal view returns (uint256) { unchecked { return uint256(keccak256(abi.encodePacked( blockhash(block.number-1), block.difficulty, block.timestamp, _numberMinted, tx.origin ))); } }",
        "labels": [
            "SlowMist",
            "CheersUp_alpha8",
            "Type: Others",
            "Severity: Low"
        ]
    },
    {
        "title": "Redundant code",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Yield V1.0.0_en-us.pdf",
        "body": "Ether is not accepted by default, which is a redundant code. cross-send/contracts/CrossSend.sol#L41-L47 initial-hotcross-oering/contracts/BaseIHO.sol#L67-L73 fallback () external payable { revert(\"cannot directly accept currency transfers\"); } receive () external payable { revert(\"cannot directly receive currency transfers\"); 15 }",
        "labels": [
            "SlowMist",
            "Cross Yield V1.0.0",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Gas optimization",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Yield V1.0.0_en-us.pdf",
        "body": "If one of the batch transfers fails, the transaction that was previously transferred normally will be reverted, but Gas has been consumed. It is a gas optimization issue here. cross-send/contracts/CrossSend.sol#L175-L210 function sendToken( IERC20 token, address[] memory recipients, uint256[] memory amounts ) private returns(uint256) { uint256 total = 0; for (uint256 i = 0; i < recipients.length ; i++) { require(_msgSender() != recipients[i], \"sender != recipient\"); token.safeTransferFrom(_msgSender(), recipients[i], amounts[i]); total += amounts[i]; } return total; } function sendNative( address[] memory recipients, uint256[] memory amounts ) private returns(uint256) { uint256 total = 0; 16 for (uint256 i = 0; i < recipients.length ; i++) { total += amounts[i]; (bool success, ) = payable(recipients[i]).call{value: amounts[i]}(\"\"); require(success, \"native transfer failed\"); } return total; }",
        "labels": [
            "SlowMist",
            "Cross Yield V1.0.0",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of allowance amount abuse",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Yield V1.0.0_en-us.pdf",
        "body": "There have an allowance amount in the contract, but the distributeTokenFee function does not limit the caller, and there is an issue of being called arbitrarily, but it can only transfer the balance of the sender to the feeCollector. cross-send/contracts/fee-managers/RecipientCountFee.sol#L65-L83 function distributeTokenFee( uint256 txRecipientCount, uint256, uint256, uint256, uint256, address sender ) public override { uint256 payableFee = txRecipientCount * tokenFeePerRecipient; 17 if(payableFee < minTokenFee) { payableFee = minTokenFee; } else if (payableFee > maxTokenFee) { payableFee = maxTokenFee; } token.safeTransferFrom(sender, feeCollector, payableFee); }",
        "labels": [
            "SlowMist",
            "Cross Yield V1.0.0",
            "Type: Authority Control Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Price manipulation issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Yield V1.0.0_en-us.pdf",
        "body": "The IOUPrice is calculated using totalFarmingTokenBalance. Attackers can control totalFarmingTokenBalance to manipulate IOUPrice. The current code does not nd the location where IOUPrice is used. Referencehttps://slowmist.medium.com/cream-hacked-analysis-us-130-million-hacked-95c9410320ca cross-yield/contracts/core/CrossYield.sol#L95-L101 function IOUPrice() public view returns (uint256) { uint256 IOUSupply = totalSupply(); return IOUSupply == 0 ? 1e18 : (totalFarmingTokenBalance() * 1e18) / IOUSupply; } 18 cross-yield/contracts/core/CrossYield.sol#L65-L67 function totalFarmingTokenBalance() public view returns (uint256) { return farmingToken().balanceOf(address(this)) + strategy.balanceOf(); }",
        "labels": [
            "SlowMist",
            "Cross Yield V1.0.0",
            "Type: Others",
            "Severity: Medium"
        ]
    },
    {
        "title": "Sandwich attacks issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Yield V1.0.0_en-us.pdf",
        "body": "There is no slippage check during swap, and there is a risk of sandwich attack. IPancakeRouter02(pcsRouter).swapExactTokensForTokens(cakeBalance, 0,cakeToBaseRoute, address(this), block.timestamp); IPancakeRouter02(pcsRouter) .swapExactTokensForTokens(toSwap, 0, route, address(this), block.timestamp); Reference https://medium.com/coinmonks/demystify-the-dark-forest-on-ethereum-sandwich-attacks-5a3aec9fa33e cross-yield/contracts/libs/OptimalSwap.sol#L14-L63 function prepareLiquidity( address cake, address[2] memory lpTokens, 19 address wbnb, address busd, address farmingToken, address pcsRouter, uint256 fee ) external { uint256 cakeBalance = IERC20(cake).balanceOf(address(this)); bool isCakeInLp = lpTokens[0] == cake || lpTokens[1] == cake; bool isWbnbBased = lpTokens[0] == wbnb || lpTokens[1] == wbnb; address baseToken = isWbnbBased ? wbnb : busd; // if cake is not part of the lp token, swap all cake for the base token if (!isCakeInLp) { address[] memory cakeToBaseRoute = new address[](2); cakeToBaseRoute[0] = cake; cakeToBaseRoute[1] = baseToken; IPancakeRouter02(pcsRouter) .swapExactTokensForTokens(cakeBalance, 0, cakeToBaseRoute, address(this), block.timestamp); } (uint256 reserve0, uint256 reserve1,) = IPancakePair(farmingToken).getReserves(); address[] memory route = new address[](2); uint256 lp0Bal = IERC20(lpTokens[0]).balanceOf(address(this)); uint256 lp1Bal = IERC20(lpTokens[1]).balanceOf(address(this)); uint256 toSwap; // The possible cases here are: // - Cake was not part of the LP token, so we swap for baseToken which could either be lpToken0 or lpToken // - Cake was part of the LP token, so it can either be lpTokens[0] or lpTokens[1] // So, depending on which token we have the highest balance for, we swap for the other one. if (lp0Bal > lp1Bal) { toSwap = SwapAmount.getSwapAmount(lp0Bal, reserve0, fee); route[0] = lpTokens[0]; route[1] = lpTokens[1]; } else { toSwap = SwapAmount.getSwapAmount(lp1Bal, reserve1, fee); route[0] = lpTokens[1]; route[1] = lpTokens[0]; 20 } // Perform the swap IPancakeRouter02(pcsRouter) .swapExactTokensForTokens(toSwap, 0, route, address(this), block.timestamp); } IPancakeRouter02(pcsRouter).swapExactTokensForTokens(toWbnb, 0, cakeToWbnbRoute, address(this), block.timestamp); cross-yield/contracts/strategies/StrategyCake.sol#L131 function collectFees() internal { // a percentant of the cake we get from the masterchef will be used to buy BNB and transfer to this address // this is the total fees that will be shared amongst the protocol, stategy dev and the harvester uint256 toWbnb = feeManager.calculateTotalFee(IERC20(farmingToken).balanceOf(address(this))); IPancakeRouter02(pcsRouter).swapExactTokensForTokens(toWbnb, 0, cakeToWbnbRoute, address(this), block.timestamp); uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this)); // distribute hervester fee uint256 harvesterFeeAmount = feeManager.calculateHarvestFee(wbnbBal); // collectFees is called indirectly from the CrossYield contract via the beforeDeposit hook. // This means that _msgSender() is the CrossYield contract and not the actuall EOA account // that send the transaction IERC20(wbnb).safeTransfer(tx.origin, harvesterFeeAmount); // distribute protocol fee uint256 protocolFeeAmount = feeManager.calculateProtocolFee(wbnbBal); // IERC20(wbnb).safeTransfer(protocolFeeRecipient, protocolFeeAmount); feeProcessor.process(protocolFeeAmount); // distribute strategy dev fee uint256 strategyDevFeeAmount = feeManager.calculateStrategyDevFee(wbnbBal); IERC20(wbnb).safeTransfer(feeManager.strategyDev(), strategyDevFeeAmount); emit FeeCollected( toWbnb, 21 harvesterFeeAmount, protocolFeeAmount, strategyDevFeeAmount, _msgSender() ); } cross-yield/contracts/strategies/StrategyCakeLP.sol#L174 function collectFees() internal { // a percentant of the cake we get from the masterchef will be used to buy BNB and transfer to this address // this is the total fees that will be shared amongst the protocol, stategy dev and the harvester uint256 toWbnb = feeManager.calculateTotalFee(IERC20(cake).balanceOf(address(this))); IPancakeRouter02(pcsRouter).swapExactTokensForTokens(toWbnb, 0, cakeToWbnbRoute, address(this), block.timestamp); uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this)); // distribute hervester fee uint256 harvesterFeeAmount = feeManager.calculateHarvestFee(wbnbBal); IERC20(wbnb).safeTransfer(_msgSender(), harvesterFeeAmount); // distribute protocol fee uint256 protocolFeeAmount = feeManager.calculateProtocolFee(wbnbBal); feeProcessor.process(protocolFeeAmount); // distribute strategy dev fee uint256 strategyDevFeeAmount = feeManager.calculateStrategyDevFee(wbnbBal); IERC20(wbnb).safeTransfer(feeManager.strategyDev(), strategyDevFeeAmount); emit FeeCollected( toWbnb, harvesterFeeAmount, protocolFeeAmount, strategyDevFeeAmount, _msgSender() ); } cross-yield/contracts/strategies/StrategyCake.sol 22 function harvest() public override whenNotPaused { // claim rewards IMasterChef(masterchef).leaveStaking(0); // because harvest can automatically be called after each user deposit // we might end up having multiple deposits in the same block and only one // would return rewards from masterchef so the rest will have 0 cake so // we don't need to waste gas to collect fees and call deposit uint256 farmingTokenBalance = balanceOfFarmingToken(); if(farmingTokenBalance > 0) { collectFees(); deposit(); emit HarvestTriggered(_msgSender(), farmingTokenBalance); } } cross-yield/contracts/strategies/StrategyCakeLP.sol#l137-L148 function harvest() external override whenNotPaused { // claim rewards IMasterChef(masterchef).deposit(poolId, 0); uint256 harvestedAmount = IERC20(cake).balanceOf(address(this)); collectFees(); addLiquidity(); deposit(); emit HarvestTriggered(_msgSender(), harvestedAmount); }",
        "labels": [
            "SlowMist",
            "Cross Yield V1.0.0",
            "Type: Reordering Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Missing slippage check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Yield V1.0.0_en-us.pdf",
        "body": "The addLiquidity function without slippage check, it doesn't have an impermanent loss check. cross-yield/contracts/strategies/StrategyCakeLP.sol#L218 function addLiquidity() internal { OptimalSwap.prepareLiquidity( cake, [lpToken0, lpToken1], wbnb, busd, farmingToken, pcsRouter, swapFee ); // add liquidity to AMM on PCS uint256 lp0Bal = IERC20(lpToken0).balanceOf(address(this)); uint256 lp1Bal = IERC20(lpToken1).balanceOf(address(this)); IPancakeRouter02(pcsRouter) .addLiquidity(lpToken0, lpToken1, lp0Bal, lp1Bal, 0, 0, address(this), block.timestamp); emit LiquidityAdded(lpToken0, lpToken1, lp0Bal, lp1Bal, _msgSender()); }",
        "labels": [
            "SlowMist",
            "Cross Yield V1.0.0",
            "Type: Reordering Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Permission check Missing",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Yield V1.0.0_en-us.pdf",
        "body": "There is no permission check for deposit function. The function is called by the CrossYieid contract. cross-yield/contracts/strategies/StrategyCakeLP.sol#L225-L231 function deposit() public override whenNotPaused { uint256 farmingTokenBalance = balanceOfFarmingToken(); if (farmingTokenBalance > 0) { IMasterChef(masterchef).deposit(poolId, farmingTokenBalance); } } cross-yield/contracts/strategies/StrategyCake.sol#L169-L175 function deposit() public override whenNotPaused { uint256 farmingTokenBalance = balanceOfFarmingToken(); if (farmingTokenBalance > 0) { IMasterChef(masterchef).enterStaking(farmingTokenBalance); } }",
        "labels": [
            "SlowMist",
            "Cross Yield V1.0.0",
            "Type: Authority Control Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Excessive authority issue 25",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Yield V1.0.0_en-us.pdf",
        "body": "Owner can modify the address of the strategy. The new strategy may have security risks if it is not audited, which will aect the user's funds. If the private key is leaked, it will aect the user's funds. cross-yield/contracts/core/CrossYield.sol#L224-L236 function upgradeStrategy() public onlyOwner { require(stratCandidate.strategy != address(0), \"No proposal exists\"); require(block.number > stratCandidate.proposedBlock + stratUpgradableAfter, \"Strategy cannot be replaced yet\"); emit NewStrategy(stratCandidate.strategy); strategy.retireStrategy(); strategy = IStrategy(stratCandidate.strategy); stratCandidate.strategy = address(0); stratCandidate.proposedBlock = 0; putFundsToWork(); } cross-yield/contracts/core/CrossYield.sol#L211-L220 function proposeStrategy(address _strategy) public onlyOwner { require(address(this) == IStrategy(_strategy).vault(), \"Invalid new strategy\"); stratCandidate = StrategyCandidate({ strategy: _strategy, proposedBlock: block.number }); emit NewStratCandidate(_strategy); }",
        "labels": [
            "SlowMist",
            "Cross Yield V1.0.0",
            "Type: Authority Control Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Repeatable claims issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Yield V1.0.0_en-us.pdf",
        "body": "After the claim, lottery.status is not set as claimed, and it is also necessary to check whether lotteryId has been claimed when the claim is executed. hotdrop/contracts/HotDrop.sol#L261-L274 function claim(uint256 lotteryId) external nonReentrant { Lottery storage lottery = lotteries[lotteryId]; require(lottery.status == Status.WinnerDrawn, \"winner not drawn\"); // if there is no winner transfer the total amount to the treasury if(tickets[lotteryId][lottery.winningNumber] == address(0)) { lottery.purchaseToken.safeTransfer(treasury, lottery.purchaseToken.balanceOf(address(this))); } else if(tickets[lotteryId][lottery.winningNumber] == _msgSender()) { // if the ticket is the winning ticket and belongs to the user then split the pot uint256 treasuryAmount = (lottery.totalRaised * lottery.treasuryFee) / FEE_BASE; lottery.purchaseToken.safeTransfer(treasury, treasuryAmount); lottery.purchaseToken.safeTransfer(_msgSender(), lottery.totalRaised - treasuryAmount); } }",
        "labels": [
            "SlowMist",
            "Cross Yield V1.0.0",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Round plan security reminder",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Yield V1.0.0_en-us.pdf",
        "body": "And the new round of lottery can only be opened when the last round of lottery is in WinnerDrawn, otherwise randomGenerator.latestLotteryId will be updated, which will cause the old lottery round to fail to execute drawWinner function due to this check. require(lotteryId == randomGenerator.latestLotteryId(), \"numbers not drawn\"); hotdrop/contracts/HotDrop.sol#L44-L256 function drawWinner(uint256 lotteryId) external nonReentrant { Lottery storage lottery = lotteries[lotteryId]; require(lottery.status == Status.Close, \"lottery still active\"); require(lotteryId == randomGenerator.latestLotteryId(), \"numbers not drawn\"); // get the winning number based on the randomResult generated by ChainLink's fallback uint256 winningNumber = randomGenerator.randomResult(); lottery.winningNumber = winningNumber; lottery.status = Status.WinnerDrawn; emit LotteryNumberDrawn(lotteryId, winningNumber); }",
        "labels": [
            "SlowMist",
            "Cross Yield V1.0.0",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing event records",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap Stable Swap_en-us.pdf",
        "body": "In the PancakeStableSwap contract, the owner can set the is_killed, balances and admin_actions_deadline parameters respectively through the kill_me, unkill_me, donate_admin_fees and revert_new_parameters functions, but no event recording is performed. ",
        "labels": [
            "SlowMist",
            "PancakeSwap Stable Swap",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - EarningFarm v3 Iterative_en-us.pdf",
        "body": "In the Exchange contract, the owner role can set swapCaller and router through the setSwapCaller and listRouter functions. If it is set to a malicious address, funds will be lost. In the CDai contract, the owner role can set sensitive parameters through the setSwapPath function. This will lead to the risk of excessive owner permissions. ",
        "labels": [
            "SlowMist",
            "EarningFarm v3 Iterative",
            "Type: Authority Control Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Variable storage issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - EarningFarm v3 Iterative_en-us.pdf",
        "body": "In the Curve3Pool contract, the swap function is used for token exchange. When fetching pools[_index], it uses storage to store the curve variable, but in this function there is no need to modify pools[_index], so this will consume more gas. ",
        "labels": [
            "SlowMist",
            "EarningFarm v3 Iterative",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Slippage issue 9",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - EarningFarm v3 Iterative_en-us.pdf",
        "body": "In the Curve3Pool contract, the swap function is used to exchange tokens in 3pool, but the _min_received passed in during the exchange is 0, which will cause the exchange process to be subject to a sandwich attack. ",
        "labels": [
            "SlowMist",
            "EarningFarm v3 Iterative",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "get_dy index issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - EarningFarm v3 Iterative_en-us.pdf",
        "body": "In the CDai contract, the _totalAssets function converts DAI to USDC as total assets via CurvePool's get_dy. But Calculate withdraw amout of usdc - from Dai (j) to USDC(i) is stated in the comments, while according to the get_dy function description (https://curve.readthedocs.io/factory-pools.html#StableSwap.get_dy ), the i index should be DAI, and the j index should be USDC. ",
        "labels": [
            "SlowMist",
            "EarningFarm v3 Iterative",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of breaching contract integrity",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - EarningFarm v3 Iterative_en-us.pdf",
        "body": "When the user makes a withdrawal, the protocol will withdraw from the SS contract through the controller contract, and then burn the user's share. 11 In the withdraw function of the SS contract, it will rst calculate the number of LPs that the user can withdraw (lpAmt), then extract the LP tokens from the convex, and then use balanceOf(address(this)) to obtain the LP balance of this contract as lpWithdrawn. TotalLP will then subtract lpWithdrawn and remove liquidity from CurvePool. The amount to remove liquidity is also lpWithdrawn. Then transfer all USDC tokens in the SS contract to the controller. Finally, the controller contract transfers the USDC token to the user. In the withdraw function of the vault contract, after the controller completes the withdrawal, the number of burned shares is calculated based on the assets passed in by the user. This will lead to the destruction of the totalLP value if a malicious user transfers a large amount of LP tokens to the SS contract and withdraws them after depositing. ",
        "labels": [
            "SlowMist",
            "EarningFarm v3 Iterative",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Risk of slippage checks being bypassed",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - EarningFarm v3 Iterative_en-us.pdf",
        "body": "In the CDai contract, the totalAssets function calculates the total collateral amount of the SS contract in the strategy through the get_dy function of CurvePool. When the user withdraws, the contract will participate in the calculation of 12 the nDAI value to be withdrawn through totalAssets. Unfortunately, a malicious user can manipulate the CurvePool with large sums of money so that the value obtained by the get_dy function is much smaller than expected, which will cause the nDAI value to be much larger than expected when withdrawing. Malicious users can deplete the liquidity in CDai by stealing collateral that does not belong to them. ",
        "labels": [
            "SlowMist",
            "EarningFarm v3 Iterative",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Code redundancy issue 9",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Mint V1.0.1_en-us.pdf",
        "body": "The _beforeTokenTransfer function exists in the CrossMint1155 contract, but this function does not implement any logic and belongs to redundant code. In the CrossMint1155BaseURI contract, there is a _clearTokenURI function to clear tokenId . The visibility of this function is internal, but no other function calls this internal visibility function. Code loction: function _beforeTokenTransfer( address operator, address from, address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data ) internal virtual override { // noop } function _clearTokenURI(uint256 tokenId) internal { if (bytes(_tokenURIs[tokenId]).length != 0) { delete _tokenURIs[tokenId]; } }",
        "labels": [
            "SlowMist",
            "Cross Mint V1.0.1",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing event records 10",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Mint V1.0.1_en-us.pdf",
        "body": "In the CrossMint1155BaseURI contract, the _setBaseURI function is used to set the baseURI , but no event recording is performed. In the CrossMint contract, the owner can set baseURI and feeManager through the setBaseURI function and setFeeManager function respectively, but no event recording is performed. ",
        "labels": [
            "SlowMist",
            "Cross Mint V1.0.1",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Permission control issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Mint V1.0.1_en-us.pdf",
        "body": "In the CrossMint721Factory library, any user can create a new CrossMint721 contract through the deployCrossMint721 function; in the CrossMint1155Factory library, any user can create a new deployCrossMint1155 contract through the deployCrossMint721 function; ",
        "labels": [
            "SlowMist",
            "Cross Mint V1.0.1",
            "Type: Authority Control Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Return value checking issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Mint V1.0.1_en-us.pdf",
        "body": "There are the withMintFee modier and withCollectionFee modier in the CrossMint contract, which respectively call the distributeMintFee function and the distributeCollectionFee function to distribute fees, and check the results of their execution. However, the distributeMintFee function and the distributeCollectionFee function both have return values, so it may be better to check the return value while checking the execution result. ",
        "labels": [
            "SlowMist",
            "Cross Mint V1.0.1",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Swap Path Issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Oddz Finance_en-us.pdf",
        "body": "In the PancakeSwapForUnderlyingAsset contract, the owner can swap fromToken to toToken through the 11 swapTokensForUA function. The path set is [fromToken, toToken] . If fromToken and toToken in PancakeSwap do not have a directly related token pair, then using this path will not be able to successfully swap. contracts/Integrations/Dex/PancakeSwap/PancakeSwapForUnderlyingAsset.sol#L29-L44 function swapTokensForUA( address _fromToken, address _toToken, address _account, uint256 _amountIn, uint256 _amountOutMin, uint256 _deadline ) public override onlyOwner returns (uint256[] memory result) { address[] memory path = new address[](2); path[0] = _fromToken; path[1] = _toToken; ERC20(_fromToken).safeApprove(address(pancakeSwap), _amountIn); result = pancakeSwap.swapExactTokensForTokens(_amountIn, _amountOutMin, path, address(this), _deadline); // converting address to address payable ERC20(address(uint160(_toToken))).safeTransfer(_account, result[1]); }",
        "labels": [
            "SlowMist",
            "Oddz Finance",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Missing event records",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Oddz Finance_en-us.pdf",
        "body": "12 In the ChainlinkIVOracle contract, the owner can set allowedPeriods, minVolatilityBound, maxVolatilityBound and other parameters at will, but no event recording is performed. contracts/Integrations/VolatilityOracle/Chainlink/ChainlinkIVOracle.sol function addAllowedPeriods(uint8 _ivAgg) public onlyOwner(msg.sender) { allowedPeriods[_ivAgg] = true; } function setMinVolatilityBound(uint256 _minVolatility) public onlyOwner(msg.sender) { minVolatilityBound = _minVolatility; } function setMaxVolatilityBound(uint256 _maxVolatility) public onlyOwner(msg.sender) { maxVolatilityBound = _maxVolatility; } function setDelay(uint256 _delay) public onlyOwner(msg.sender) { delayInSeconds = _delay; } function setVolatilityPrecision(uint8 _precision) public onlyOwner(msg.sender) { volatilityPrecision = _precision; }",
        "labels": [
            "SlowMist",
            "Oddz Finance",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "The deationary token docking issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Oddz Finance_en-us.pdf",
        "body": "13 Users can transfer the staking token into the staking contract through the deposit function. Under normal circumstances, the number of staking tokens transferred by the user is the same as the _amount parameter passed in. But if the staking token is a deationary token, the number of tokens transferred by the user may be dierent from the number of tokens actually received in the contract. contracts/Staking/OddzStakingManager.sol, OddzTokenStaking.sol, OUsdTokenStaking function stake(IERC20 _token, uint256 _amount) external override validToken(_token) { require(_amount > 0, \"Staking: invalid amount\"); tokens[_token]._stakingContract.stake(msg.sender, _amount); emit Stake(msg.sender, address(_token), _amount); } function stake(address _staker, uint256 _amount) external override onlyOwner { _stake(_staker, _amount); _mint(_staker, _amount); IERC20(token).safeTransferFrom(_staker, address(this), _amount); }",
        "labels": [
            "SlowMist",
            "Oddz Finance",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Token active status change issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Oddz Finance_en-us.pdf",
        "body": "In the OddzStakingManager contract, the owner can set the active state of the token to true through the activateToken function, and the timelock contract can set the active state to false through the deactivateToken 14 function. But after the state change, the txnFeeReward, settlementFeeReward, and allotedReward parameters of each valid token did not change accordingly, so the totalTxnFee, totalSettlementFee, and totalAllotedFee parameters are not equal to 100. contracts/Staking/OddzStakingManager.sol function deactivateToken(IERC20 _token) external onlyTimeLocker(msg.sender) validToken(_token) { tokens[_token]._active = false; emit TokenDeactivate(address(_token)); } function activateToken(IERC20 _token) external onlyOwner(msg.sender) inactiveToken(_token) { tokens[_token]._active = true; emit TokenActivate(address(_token)); }",
        "labels": [
            "SlowMist",
            "Oddz Finance",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Redundant code",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Oddz Finance_en-us.pdf",
        "body": "There is _transferRewards function in the OddzStakingManager contract, which checks whether the staker's collateral time is greater than rewardsLockupDuration, while the actual _transferRewards function is only called by the withdraw function and the claimRewards function. But in both withdraw and claimRewards functions, there is a check to see if the staker's collateral time is greater than 15 rewardsLockupDuration. So the _transferRewards function does not need to check again if the staker's collateral time is greater than the rewardsLockupDuration. contracts/Staking/OddzStakingManager.sol function _transferRewards( address _staker, IERC20 _token, uint256 _date ) private returns (uint256 reward) { if (_date - tokens[_token]._stakingContract.getLastStakedAt(_staker) >= tokens[_token]._rewardsLockupDuration) { reward = tokens[_token]._stakingContract.withdrawRewards(_staker); oddzToken.safeTransfer(_staker, reward); emit TransferReward(_staker, address(_token), reward); } }",
        "labels": [
            "SlowMist",
            "Oddz Finance",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Unsafe External Call",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Oddz Finance_en-us.pdf",
        "body": "_pool is entered by the user. When the user enters a malicious contract address and returns the malicious premium through the malicious contract, the tokens in the OddzLiquidityPoolManager contract can be transferred to a malicious address. 16 contracts/Pool/OddzLiquidityPoolManager.sol#L300 function withdrawProfits(IOddzLiquidityPool _pool) external { uint256 premium = _pool.collectPremium(msg.sender, premiumLockupDuration); require(premium > 0, \"LP Error: No premium allocated\"); token.safeTransfer(msg.sender, premium); } The getSortedEligiblePools function does not check the input _liquidityParams and does not ensure that allPools is in the whitelist. When other functions depend on the data of getSortedEligiblePools, the same issues may occur. contracts/Pool/OddzLiquidityPoolManager.sol#L341 function getSortedEligiblePools(LiquidityParams memory _liquidityParams) public view returns (address[] memory pools, uint256[] memory poolBalance) { // if _expiration is 86401 i.e. 1 day 1 second, then max 1 day expiration pool will not be eligible IOddzLiquidityPool[] memory allPools = poolMapper[ keccak256( abi.encode( _liquidityParams._pair, _liquidityParams._type, _liquidityParams._model, periodMapper[getActiveDayTimestamp(_liquidityParams._expiration) / 1 days] ) ) ]; uint256 count = 0; for (uint8 i = 0; i < allPools.length; i++) { if (allPools[i].availableBalance() > 0) { count++; } } poolBalance = new uint256[](count); pools = new address[](count); uint256 j = 0; 17 uint256 balance = 0; for (uint256 i = 0; i < allPools.length; i++) { if (allPools[i].availableBalance() > 0) { pools[j] = address(allPools[i]); poolBalance[j] = allPools[i].availableBalance(); balance += poolBalance[j]; j++; } } (poolBalance, pools) = _sort(poolBalance, pools); require(balance > _liquidityParams._amount, \"LP Error: Amount is too large\"); }",
        "labels": [
            "SlowMist",
            "Oddz Finance",
            "Type: Unsafe External Call Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Race conditions issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Oddz Finance_en-us.pdf",
        "body": "The enableOptionTransfer function can be called repeatedly, When the attacker calls enableOptionTransfer to set a small value of _minAmount.The user does not need to enter minAmount to check when calling the optionTransfer function.Therefore, the attacker can call enableOptionTransfer again with a higher gas price to set a new minAmount, so that if the allowance is greater than the minAmount + transferFee , the user can normally execute optionTransfer calls and trade with a larger amount, and the attacker can prot. contracts/Option/OddzOptionManager.sol function enableOptionTransfer(uint256 _optionId, uint256 _minAmount) external { Option storage option = options[_optionId]; require( option.expiration > (block.timestamp + 18 assetManager.getMinPeriod(option.pair)), \"Option not eligble for transfer\" ); require(option.holder == msg.sender, \"Invalid Caller\"); require(option.state == State.Active, \"Invalid state\"); require(_minAmount >= minimumPremium, \"amount is lower than minimum premium\"); optionTransferMap[_optionId] = _minAmount; emit OptionTransferEnabled(_optionId, _minAmount); } function optionTransfer(uint256 _optionId) external { Option storage option = options[_optionId]; require( option.expiration > (block.timestamp + assetManager.getMinPeriod(option.pair)), \"Option not eligble for transfer\" ); uint256 minAmount = optionTransferMap[_optionId]; require(minAmount > 0, \"Option not enabled for transfer\"); require(option.state == State.Active, \"Invalid state\"); require(option.holder != msg.sender, \"Self option transfer is not allowed\"); // once transfer initiated update option tranfer map delete optionTransferMap[_optionId]; uint256 transferFee = _getTransactionFee(minAmount, msg.sender); txnFeeAggregate += transferFee; _validateOptionAmount(token.allowance(msg.sender, address(this)), minAmount + transferFee); token.safeTransferFrom(msg.sender, option.holder, minAmount); token.safeTransferFrom(msg.sender, address(this), transferFee); address oldHolder = option.holder; option.holder = msg.sender; emit OptionTransfer(_optionId, oldHolder, msg.sender, minAmount, transferFee); } 19",
        "labels": [
            "SlowMist",
            "Oddz Finance",
            "Type: Reordering Vulnerability",
            "Severity: Critical"
        ]
    },
    {
        "title": "Excessive authority issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Oddz Finance_en-us.pdf",
        "body": "(1) The owner of the OddzIVOracleManager and OddzPriceOracleManager contracts can change the conguration of the contract and does not use timelock for management, there is a risk of excessive authority. The oracle aects the price of the asset. When the oracle contract is maliciously manipulated, it will cause the user's asset to be damaged. (2) After the contracts are deployed, it is necessary to check whether TimeLocker is set correctly.",
        "labels": [
            "SlowMist",
            "Oddz Finance",
            "Type: Authority Control Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Redundant logic issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - MasterChef v2_en-us.pdf",
        "body": "In the add function, the owner can add new pools. It will rst check whether the number of newly added lpTokens in the contract is greater than or equal to 0. But in fact, the number of lpTokens in the contract will be greater than or equal to 0 in any case, so this check is redundant. ",
        "labels": [
            "SlowMist",
            "MasterChef v2",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Permission control issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - MasterChef v2_en-us.pdf",
        "body": "If any user holds the dummy token, the user can stake the dummy token to the MasterChef v1 contract through the init function, which will cause the lastBurnedBlock parameter to be updated unexpectedly, and nally lead to an error in the calculation of the number of CAKE tokens waiting to be burned. ",
        "labels": [
            "SlowMist",
            "MasterChef v2",
            "Type: Authority Control Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "The number of pendingCakeToBurn is not checked",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - MasterChef v2_en-us.pdf",
        "body": "In the burnCake function, if the number of CAKE tokens in the contract is less than pendingCakeToBurn, it will harvest CAKE tokens from MasterChef v1 via the harvestFromMasterChef function. But it does not check if the balance of CAKE tokens in the contract after harvesting is greater than or equal to pendingCakeToBurn. ",
        "labels": [
            "SlowMist",
            "MasterChef v2",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Lack of access control issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning Farm - ETH Leverage_en-us.pdf",
        "body": "In the BalancerReceiver contract, the SS contract can initiate WETH ash loans through the ashLoan function, but the ashLoan function allows any user to call. Although the loanFallback function of the SS contract checks curState, it is undoubtedly more expected that the ashLoan function can only be called by the SS contract. 10 ",
        "labels": [
            "SlowMist",
            "Earning Farm - ETH Leverage",
            "Type: Authority Control Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Gas optimization",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning Farm - ETH Leverage_en-us.pdf",
        "body": "In the ETHLeverage contract, the _harvest function is used to collect fees, which will only be charged when lastEarnBlock and block.number are used. But the function does not check whether the dierence between lastEarnBlock and block.number is 0. If multiple users in the same block trigger the _harvest function, it will cause unnecessary gas consumption. ",
        "labels": [
            "SlowMist",
            "Earning Farm - ETH Leverage",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Redundant logic issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning Farm - ETH Leverage_en-us.pdf",
        "body": "In the Controller contract, the owner can set the exchange and harvestFee parameters respectively through the setExchange and setHarvestFee functions. But in this contract the exchange and harvestFee parameters are not used. ",
        "labels": [
            "SlowMist",
            "Earning Farm - ETH Leverage",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "The problem of checking the number of swaps",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning Farm - ETH Leverage_en-us.pdf",
        "body": "In the ETHLeverExchange contract, the swapExactETH function is used to exchange stETH to ETH during emergency withdrawal. It will get the amount of ETH that can be exchanged through the get_dy function and check if the swap amount is larger than the expected required amount. But in theory it is acceptable for the number of swaps to be equal to what is expected to be required. ",
        "labels": [
            "SlowMist",
            "Earning Farm - ETH Leverage",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning Farm - ETH Leverage_en-us.pdf",
        "body": "In the protocol, the owner role has many permissions, such as: the owner can set sensitive parameters, can suspend the contract, can make emergency withdrawals, can migrate the funds of the SS contract, etc. It is obviously inappropriate to give all the permissions of the protocol to the owner, which will greatly increase the single point of 13 risk.",
        "labels": [
            "SlowMist",
            "Earning Farm - ETH Leverage",
            "Type: Authority Control Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Risk of exchange slippage",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning Farm - ETH Leverage_en-us.pdf",
        "body": "When users make withdrawals in the protocol, they need to exchange stETH tokens for ETH tokens through CurvePool. However, the exchange slippage is not limited in the ETHLeverExchange contract, which will make users vulnerable to sandwich attacks when withdrawing. ",
        "labels": [
            "SlowMist",
            "Earning Farm - ETH Leverage",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Arbitrary permission initialization of lend/oracle contract",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Larix Obsolete_en-us.pdf",
        "body": "Anyone can initialize the lend/oracle contract, which may lead to the illegal use of the contract, and malicious users may use the ocially deployed Program to conduct fraudulent activities.",
        "labels": [
            "SlowMist",
            "Larix Obsolete",
            "Type: Authority Control Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Flash loan repayment detection bypass",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Larix Obsolete_en-us.pdf",
        "body": "After the attacker calls process_flash_loan to borrow, he uses the borrowed funds to recharge to the contract. In this way, the ash loan will detect that the funds have been returned during the repayment check, which leads to the success of the ash loan, but the funds are not actually returned. Instead, the attacker get a deposit position is established, and the attacker can withdraw this fund at any time, thereby stealing all the funds in the fund pool.",
        "labels": [
            "SlowMist",
            "Larix Obsolete",
            "Type: Reentrancy Vulnerability",
            "Severity: Critical"
        ]
    },
    {
        "title": "Process_ash_loan forged account risk 7",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Larix Obsolete_en-us.pdf",
        "body": "Code location: larix-lending/src/processor.rs fn process_flash_loan( program_id: &Pubkey, liquidity_amount: u64, accounts: &[AccountInfo], ) If the owner or key of the reserve_info account is not veried, the attacker may attack the contract by maliciously constructing the data stored in the account.",
        "labels": [
            "SlowMist",
            "Larix Obsolete",
            "Type: Forged account attack",
            "Severity: Critical"
        ]
    },
    {
        "title": "Process_reserve forged account risk",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Larix Obsolete_en-us.pdf",
        "body": "Code location: larix-lending/src/cong/cong_process.rs fn process_reserve(program_id: & Pubkey, accounts: & [AccountInfo],reserve_type:ConfigReserveType) If the owner or key of the reserve_info account is not veried, the attacker may attack the contract by maliciously constructing the data stored in the account.",
        "labels": [
            "SlowMist",
            "Larix Obsolete",
            "Type: Forged account attack",
            "Severity: Critical"
        ]
    },
    {
        "title": "process_borrow_obligation_liquidity host_fee transfer target is not veried",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Larix Obsolete_en-us.pdf",
        "body": "Code location: larix-lending/src/processor.rs if let Ok(host_fee_receiver_info) = next_account_info(account_info_iter) { if host_fee > 0 { owner_fee = owner_fee .checked_sub(host_fee) .ok_or(LendingError::MathOverflow)?; spl_token_transfer(TokenTransferParams { source: source_liquidity_info.clone(), destination: host_fee_receiver_info.clone(), amount: host_fee, authority: lending_market_authority_info.clone(), authority_signer_seeds, token_program: token_program_id.clone(), })?; } } The owner or key of the host_fee_receiver_info account is not veried, and the user can steal host_fee by specifying host_fee_receiver_info .",
        "labels": [
            "SlowMist",
            "Larix Obsolete",
            "Type: Forged account attack",
            "Severity: Critical"
        ]
    },
    {
        "title": "DoS issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Flurry Bridge_en-us.pdf",
        "body": "The getVoteCount function uses a for loop to count members votes. When the number of members is large, it will cause DoS due to the increased number of for loops. bridge/contracts/contracts/Federation.sol#L242-L249 function getVoteCount(bytes32 processId) public view override returns(uint) { uint count = 0; for (uint i = 0; i < members.length; i++) { if (votes[processId][members[i]]) count += 1; } return count; }",
        "labels": [
            "SlowMist",
            "Flurry Bridge",
            "Type: Denial of Service Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Safety Reminders",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Flurry Bridge_en-us.pdf",
        "body": "To capture events in the cross-chain bridge, the implementation of subscribing to the events of the specied contract should be adopted to avoid the attacks of fake contract events.",
        "labels": [
            "SlowMist",
            "Flurry Bridge",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Limit of value range",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Flurry Bridge_en-us.pdf",
        "body": "Owner can set fee arbitrarily, and there is no restriction on the value range. and the fee variable is not used in the contract code. bridge/contracts/contracts/Registry.sol#L87-L91 function setFee(address localaddr_, uint256 fee_) external override onlyOwner { require(fee_ > 0, \"Registry: Fee Should be> 0\"); fee[localaddr_] = fee_; emit FeeChanged(localaddr_, fee_); } 8",
        "labels": [
            "SlowMist",
            "Flurry Bridge",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Useless code",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Flurry Bridge_en-us.pdf",
        "body": "There are a lot of comment codes in the contract. It is necessary to conrm whether the comment codes are redundant codes. bridge/contracts/contracts/Registry.sol#L43-L85 // function registerCall( // uint256 alienChainId_, // address alienChainContractAddr_, // address localChainContractAddr_, // bytes4 callSig_ // ) external onlyOwner { // bytes32 callRegistryID = Utils.getCallRegistryId( // alienChainId_, // alienChainContractAddr_, // localChainContractAddr_, // callSig_ // ); // require(!callRegistry[callRegistryID], \"Registry: Call already exists in callRegistry\"); // callRegistry[callRegistryID] = true; // emit CallRegistered( // alienChainId_, // alienChainContractAddr_, // localChainContractAddr_, // callSig_ // ); // } // function unregisterCall( 9 // uint256 alienChainId_, // address alienChainContractAddr_, // address localChainContractAddr_, // bytes4 callSig_ // ) external onlyOwner { // bytes32 callRegistryID = Utils.getCallRegistryId( // alienChainId_, // alienChainContractAddr_, // localChainContractAddr_, // callSig_ // ); // require(callRegistry[callRegistryID], \"Registry: Call not registered\"); // delete callRegistry[callRegistryID]; // emit CallUnregistered( // alienChainId_, // alienChainContractAddr_, // localChainContractAddr_, // callSig_ // ); // } bridge/contracts/contracts/Federation.sol#L159-L240 // function voteCall( // uint256 srcChainID_, // address srcChainContractAddress_, // address dstChainContractAddress_, // bytes32 transactionHash_, // uint32 logIndex_, // bytes calldata payload // ) external override onlyMember { // if (bridge.isCallProcessed( // srcChainID_, // srcChainContractAddress_, // dstChainContractAddress_, // transactionHash_, // logIndex_, // payload // )) { // return; // } // bytes32 callId = Utils.getCallId( 10 // srcChainID_, // srcChainContractAddress_, // dstChainContractAddress_, // transactionHash_, // logIndex_, // payload // ); // if (votes[callId][_msgSender()]) // return; // votes[callId][_msgSender()] = true; // emit VotedCall( // srcChainID_, // srcChainContractAddress_, // dstChainContractAddress_, // transactionHash_, // logIndex_, // _msgSender(), // callId, // payload // ); // uint voteCount = getVoteCount(callId); // if ((voteCount >= required) && (voteCount >= members.length / 2 + 1)) { // bridge.acceptCall( // srcChainID_, // srcChainContractAddress_, // dstChainContractAddress_, // transactionHash_, // logIndex_, // payload // ); // emit ExecutedCall(callId); // } // } // function hasVotedCall( // uint256 srcChainID_, // address srcChainContractAddress_, // address dstChainContractAddress_, // bytes32 transactionHash_, // uint32 logIndex_, // bytes calldata payload // ) external view override returns(bool) { // bytes32 callId = Utils.getCallId( 11 // srcChainID_, // srcChainContractAddress_, // dstChainContractAddress_, // transactionHash_, // logIndex_, // payload // ); // return votes[callId][_msgSender()]; // } // function isCallProcessed( // uint256 srcChainID_, // address srcChainContractAddress_, // address dstChainContractAddress_, // bytes32 transactionHash_, // uint32 logIndex_, // bytes calldata payload // ) external view override returns(bool) { // return bridge.isCallProcessed(srcChainID_, srcChainContractAddress_, dstChainContractAddress_, transactionHash_, logIndex_, payload); // } bridge/contracts/contracts/Bridge.sol#L114-L154 // function acceptCall( // uint256 srcChainID_, // address srcChainTokenAddress_, // address dstChainTokenAddress_, // bytes32 transactionHash_, // uint32 logIndex_, // bytes calldata payload // ) external override onlyFederation nonReentrant { // require(dstChainTokenAddress_ != address(0), \"Bridge: destination chain token address is null\"); // require(srcChainTokenAddress_ != address(0), \"Bridge: src chain token address is null\"); // require(transactionHash_ != bytes32(0), \"Bridge: Transaction is null\"); // require(srcChainTokenAddress_ != address(0), \"src token address is null\"); // bytes4 sig = // payload[0] | // (bytes4(payload[1]) >> 8) | // (bytes4(payload[2]) >> 16) | // (bytes4(payload[3]) >> 24); 12 // bytes32 callRegistryID = Utils.getCallRegistryId( // srcChainID_, // srcChainTokenAddress_, // dstChainTokenAddress_, // sig // ); // require(tokenRegistry.callRegistry(callRegistryID), \"Call Not Registered\"); // bytes32 callId = Utils.getCallId( // srcChainID_, // srcChainTokenAddress_, // dstChainTokenAddress_, // transactionHash_, // logIndex_, // payload // ); // require(processed[callId] == 0, \"Bridge: Already processed\"); // processed[callId] = block.number; // // call the function // (bool success, ) = dstChainTokenAddress_.call(payload); // require(success, \"call fail\"); // } bridge/contracts/libraries/Utils.sol#L6-L18 // function getCallRegistryId( // uint256 alienChainId_, // address alienChainContractAddr_, // address localChainContractAddr_, // bytes4 callSig_ // ) internal pure returns(bytes32) { // return keccak256(abi.encodePacked( // alienChainId_, // alienChainContractAddr_, // localChainContractAddr_, // callSig_ // )); // } 13 bridge/contracts/libraries/Utils.sol#L50-L67 // function getCallId( // uint256 srcChainID_, // address srcChainTokenAddress_, // address dstChainTokenAddress_, // bytes32 transactionHash_, // uint32 logIndex_, // bytes calldata payload // ) internal pure returns (bytes32) { // return keccak256(abi.encodePacked( // \"Call\", // srcChainID_, // srcChainTokenAddress_, // dstChainTokenAddress_, // transactionHash_, // logIndex_, // payload // )); // }",
        "labels": [
            "SlowMist",
            "Flurry Bridge",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Defects in the defaultDepositSS check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ENF_ETH_Lowrisk_en-us.pdf",
        "body": "In the harvest function of the Controller contract, before re-depositing the protocol income into the strategy, it will check whether the default SS exists through subStrategies.length > defaultDepositSS . But actually, defaultDepositSS will be 0 when the default SS does not exist, so the subStrategies.length > defaultDepositSS check will always pass. Eventually the protocol will fail to re-deposit. ",
        "labels": [
            "SlowMist",
            "ENF_ETH_Lowrisk",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "ownerDeposit remaining deposit issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ENF_ETH_Lowrisk_en-us.pdf",
        "body": "In the ownerDeposit function of the StETH contract, the owner role will directly deposit ETH into the strategy. It checks that msg.value must be greater than or equal to the amount to be deposited through _amount <= msg.value . But when the owner's msg.value is greater than _amount , the ownerDeposit function does not implement the refund of excess ETH. This will result in funds being locked. The same is true for the ownerDeposit function of the CEth contract. ",
        "labels": [
            "SlowMist",
            "ENF_ETH_Lowrisk",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Redundant variable",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ENF_ETH_Lowrisk_en-us.pdf",
        "body": "There is a weth global variable in the CEth contract, but this variable is not used in the contract. ",
        "labels": [
            "SlowMist",
            "ENF_ETH_Lowrisk",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ENF_ETH_Lowrisk_en-us.pdf",
        "body": "10 In the protocol, the owner role has many permissions, such as: the owner can set sensitive parameters, can suspend the contract, can make emergency withdrawals, can migrate the funds of the SS contract, etc. It is obviously inappropriate to give all the permissions of the protocol to the owner, which will greatly increase the single point of risk.",
        "labels": [
            "SlowMist",
            "ENF_ETH_Lowrisk",
            "Type: Authority Control Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Compound interest slippage check issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ENF_ETH_Lowrisk_en-us.pdf",
        "body": "In the router contract, no slippage check is performed during the swap operation. If there are more funds with compound interest, there will be a risk of being attacked by sandwiches. ",
        "labels": [
            "SlowMist",
            "ENF_ETH_Lowrisk",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Deation token compatibility issues",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - eden-network_en-us.pdf",
        "body": "If the number of deationary token records is smaller than the actual number of receipts, if malicious users continue to deposit and withdraw , the pool of deationary tokens will be exhausted. contracts/RewardsManager.sol function _deposit( uint256 pid, uint256 amount, PoolInfo storage pool, UserInfo storage user ) internal { updatePool(pid); uint256 sushiPid = sushiPools[address(pool.token)]; uint256 pendingSushiTokens = 0; 17 if (user.amount > 0) { uint256 pendingRewards = user.amount * pool.accRewardsPerShare / 1e12 - user.rewardTokenDebt; if (pendingRewards > 0) { _distributeRewards(msg.sender, pendingRewards, pool.vestingPercent, pool.vestingPeriod, pool.vestingCliff, pool.vpForVesting); } if (sushiPid != uint256(0)) { masterChef.updatePool(sushiPid); pendingSushiTokens = user.amount * masterChef.poolInfo(sushiPid).accSushiPerShare / 1e12 - user.sushiRewardDebt; } } pool.token.safeTransferFrom(msg.sender, address(this), amount); pool.totalStaked = pool.totalStaked + amount; user.amount = user.amount + amount; //SlowMist Incompatible with deflationary currencies user.rewardTokenDebt = user.amount * pool.accRewardsPerShare / 1e12; if (sushiPid != uint256(0)) { masterChef.updatePool(sushiPid); user.sushiRewardDebt = user.amount * masterChef.poolInfo(sushiPid).accSushiPerShare / 1e12; masterChef.deposit(sushiPid, amount); } if (amount > 0 && pool.vpForDeposit) { lockManager.grantVotingPower(msg.sender, address(pool.token), amount); } if (pendingSushiTokens > 0) { _safeSushiTransfer(msg.sender, pendingSushiTokens); } emit Deposit(msg.sender, pid, amount); }",
        "labels": [
            "SlowMist",
            "eden-network",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - eden-network_en-us.pdf",
        "body": "These functions may cause the project party to take away the tokens pledged by the user in the pool. contracts/RewardsManager.sol function setMasterChef(address newAddress) external onlyOwner { emit ChangedAddress(\"MASTER_CHEF\", address(masterChef), newAddress); masterChef = IMasterChef(newAddress); } function setVault(address newAddress) external onlyOwner { emit ChangedAddress(\"VAULT\", address(vault), newAddress); vault = IVault(newAddress); } function setLockManager(address newAddress) external onlyOwner { emit ChangedAddress(\"LOCK_MANAGER\", address(lockManager), newAddress); lockManager = ILockManager(newAddress); } function rescueTokens( address[] calldata tokens, uint256[] calldata amounts, address receiver ) external onlyOwner { require(tokens.length == amounts.length, \"RM::rescueTokens: not same length\"); for (uint i = 0; i < tokens.length; i++) { IERC20Extended token = IERC20Extended(tokens[i]); uint256 withdrawalAmount; uint256 tokenBalance = token.balanceOf(address(this)); uint256 tokenAllowance = token.allowance(address(this), receiver); if (amounts[i] == 0) { if (tokenBalance > tokenAllowance) { withdrawalAmount = tokenAllowance; 19 } else { withdrawalAmount = tokenBalance; } } else { require(tokenBalance >= amounts[i], \"RM::rescueTokens: contract balance too low\"); require(tokenAllowance >= amounts[i], \"RM::rescueTokens: increase token allowance\"); withdrawalAmount = amounts[i]; } token.safeTransferFrom(address(this), receiver, withdrawalAmount); } }",
        "labels": [
            "SlowMist",
            "eden-network",
            "Type: Authority Control Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Payments Contract Deation token compatibility issues",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - eden-network_en-us.pdf",
        "body": "If it is a deationary currency, the actual number of tokens received at this time is less than the incoming amount. contracts/Payments.sol function _createPayment( address token, address payer, address receiver, uint48 startTime, uint256 amount, uint256 paymentDurationInSecs, uint16 cliffDurationInDays ) internal { // Transfer the tokens under the control of the payment contract IERC20(token).safeTransferFrom(payer, address(this), amount); uint48 paymentStartTime = startTime == 0 ? uint48(block.timestamp) : startTime; // Create payment Payment memory payment = Payment({ token: token, receiver: receiver, payer: payer, startTime: paymentStartTime, stopTime: 0, paymentDurationInSecs: paymentDurationInSecs, cliffDurationInDays: cliffDurationInDays, amount: amount,// SlowMist Incompatible with deflationary currencies amountClaimed: 0 }); tokenPayments[numPayments] = payment;//SlowMist Incompatible with deflationary currencies paymentIds[receiver].push(numPayments); emit PaymentCreated(token, payer, receiver, numPayments, amount, paymentStartTime, paymentDurationInSecs, cliffDurationInDays); 21 // Increment payment id numPayments++; }",
        "labels": [
            "SlowMist",
            "eden-network",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "User voting rights are lost",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - eden-network_en-us.pdf",
        "body": "This is an externally called function. There may be a risk of LOCKER_ROLE removing the voting rights of locked users in batches. contracts/Vault.sol function claimAllUnlockedTokens(uint256[] memory locks) external { for (uint i = 0; i < locks.length; i++) { uint256 claimableAmount = claimableBalance(locks[i]); require(claimableAmount > 0, \"Vault::claimAllUnlockedTokens: claimableAmount is 0\"); _claimTokens(locks[i], claimableAmount); } } function _claimTokens(uint256 lockId, uint256 claimAmount) internal { Lock storage lock = tokenLocks[lockId]; uint256 votingPowerRemoved; // Remove voting power, if exists if (lock.votingPower > 0) { votingPowerRemoved = lockManager.removeVotingPower(lock.receiver, lock.token, claimAmount); lock.votingPower = lock.votingPower - votingPowerRemoved; 22 } // Update claimed amount lock.amountClaimed = lock.amountClaimed + claimAmount; // Release tokens IERC20Permit(lock.token).safeTransfer(lock.receiver, claimAmount); emit UnlockedTokensClaimed(lock.receiver, lock.token, lockId, claimAmount, votingPowerRemoved); }",
        "labels": [
            "SlowMist",
            "eden-network",
            "Type: Others",
            "Severity: Medium"
        ]
    },
    {
        "title": "Out of gas in the loop",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - eden-network_en-us.pdf",
        "body": "The delegate is an external function. If too many producers are added by malicious calls, it will cause the execution of delegateBatch and cause out of gas in the loop. contracts/DistributorGovernance.sol /// @notice Only addresses with delegator role or block producer modifier onlyDelegatorOrProducer(address producer) { require(hasRole(DELEGATOR_ROLE, msg.sender) || msg.sender == producer, \"must be producer or delegator\"); _;//SlowMist If msg.sender = producer is satisfied, the judgment can be passed } function delegate(address producer, address collector) external onlyDelegatorOrProducer(producer) { rewardCollector[producer] = collector; emit BlockProducerRewardCollectorChanged(producer, collector); 23 } function delegateBatch(address[] memory producers, address[] memory collectors) external onlyDelegator { require(producers.length == collectors.length, \"length mismatch\"); for(uint i; i< producers.length; i++) { rewardCollector[producers[i]] = collectors[i]; emit BlockProducerRewardCollectorChanged(producers[i], collectors[i]); } }",
        "labels": [
            "SlowMist",
            "eden-network",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "The new variable is not assigned",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - eden-network_en-us.pdf",
        "body": "newCliffDuration This variable was not stored at the end. contracts/LockManager.sol function extendLock(uint256 lockId, uint16 vestingDaysToAdd, uint16 cliffDaysToAdd) external { Lock storage lock = tokenLocks[lockId]; require(msg.sender == lock.receiver, \"Vault::extendLock: msg.sender must be receiver\"); uint16 oldVestingDuration = lock.vestingDurationInDays; uint16 newVestingDuration = _add16(oldVestingDuration, vestingDaysToAdd, \"Vault::extendLock: vesting max days exceeded\"); uint16 oldCliffDuration = lock.cliffDurationInDays; uint16 newCliffDuration = _add16(oldCliffDuration, cliffDaysToAdd, \"Vault::extendLock: cliff max days exceeded\");//SlowMist newCliffDuration This variable was not stored at the end require(newCliffDuration <= 10*365, \"Vault::extendLock: cliff more than 10 years\"); require(newVestingDuration <= 25*365, \"Vault::extendLock: vesting duration 24 more than 25 years\"); require(newVestingDuration >= newCliffDuration, \"Vault::extendLock: duration < cliff\"); lock.vestingDurationInDays = newVestingDuration; emit LockExtended(lockId, oldVestingDuration, newVestingDuration, oldCliffDuration, newCliffDuration, lock.startTime); }",
        "labels": [
            "SlowMist",
            "eden-network",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Restrictions can be bypassed",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - eden-network_en-us.pdf",
        "body": "When existingBidAmount and existingSlotBalance are 0 . bid >= MIN_BID This condition can be bypassed. contracts/EdenNetwork.sol function _claimSlot(uint8 slot, uint128 bid, address delegate) internal { require(delegate != address(0), \"cannot delegate to 0 address\"); Bid storage currentBid = slotBid[slot]; uint128 existingBidAmount = currentBid.bidAmount; uint128 existingSlotBalance = slotBalance(slot); uint128 taxedBalance = existingBidAmount - existingSlotBalance; require((existingSlotBalance == 0 && bid >= MIN_BID) || bid >= existingBidAmount * 110 / 100, \"bid too small\");//slowmist uint128 bidderLockedBalance = lockedBalance[msg.sender]; uint128 bidIncrement = currentBid.bidder == msg.sender ? bid - existingSlotBalance : bid; if (bidderLockedBalance > 0) { if (bidderLockedBalance >= bidIncrement) { lockedBalance[msg.sender] -= bidIncrement; } else { lockedBalance[msg.sender] = 0; token.transferFrom(msg.sender, address(this), bidIncrement - 25 bidderLockedBalance); } } else { token.transferFrom(msg.sender, address(this), bidIncrement); } if (currentBid.bidder != msg.sender) { lockedBalance[currentBid.bidder] += existingSlotBalance; } if (taxedBalance > 0) { token.burn(taxedBalance); } _slotOwner[slot] = msg.sender; _slotDelegate[slot] = delegate; currentBid.bidder = msg.sender; currentBid.periodStart = uint64(block.timestamp); currentBid.bidAmount = bid; currentBid.taxNumerator = taxNumerator; currentBid.taxDenominator = taxDenominator; slotExpiration[slot] = uint64(block.timestamp + uint256(taxDenominator) * 86400 / uint256(taxNumerator)); emit SlotClaimed(slot, msg.sender, delegate, bid, existingBidAmount, taxNumerator, taxDenominator); }",
        "labels": [
            "SlowMist",
            "eden-network",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - eden-network_en-us.pdf",
        "body": "26 Since most of the contract settings only need to be modied by the admin, they can take eect immediately. If the admin address is hacked, it will cause some serious consequences. For example: contracts/VotingPowerPrism.sol The admin has the authority to modify the pointed logical contract immediately. It may cause abnormal voting rights after the admin address is stolen. contracts/EdenNetworkProxy.sol The admin has the authority to modify the pointed logical contract immediately. It may cause the loss of the token of the contract address after the admin address is stolen. contracts/TokenRegistry.sol If the admin address is hacked, you can also modify the TokenFormula immediately. This will cause abnormal voting rights.",
        "labels": [
            "SlowMist",
            "eden-network",
            "Type: Authority Control Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Redundant code",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Send V1.0.1_en-us.pdf",
        "body": "Ether is not accepted by default, which is a redundant code. cross-send/contracts/CrossSend.sol#L41-L47 initial-hotcross-oering/contracts/BaseIHO.sol#L67-L73 fallback () external payable { revert(\"cannot directly accept currency transfers\"); } receive () external payable { revert(\"cannot directly receive currency transfers\"); 15 }",
        "labels": [
            "SlowMist",
            "Cross Send V1.0.1",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Gas optimization",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Send V1.0.1_en-us.pdf",
        "body": "If one of the batch transfers fails, the transaction that was previously transferred normally will be reverted, but Gas has been consumed. It is a gas optimization issue here. cross-send/contracts/CrossSend.sol#L175-L210 function sendToken( IERC20 token, address[] memory recipients, uint256[] memory amounts ) private returns(uint256) { uint256 total = 0; for (uint256 i = 0; i < recipients.length ; i++) { require(_msgSender() != recipients[i], \"sender != recipient\"); token.safeTransferFrom(_msgSender(), recipients[i], amounts[i]); total += amounts[i]; } return total; } function sendNative( address[] memory recipients, uint256[] memory amounts ) private returns(uint256) { uint256 total = 0; 16 for (uint256 i = 0; i < recipients.length ; i++) { total += amounts[i]; (bool success, ) = payable(recipients[i]).call{value: amounts[i]}(\"\"); require(success, \"native transfer failed\"); } return total; }",
        "labels": [
            "SlowMist",
            "Cross Send V1.0.1",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of allowance amount abuse",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Send V1.0.1_en-us.pdf",
        "body": "There have an allowance amount in the contract, but the distributeTokenFee function does not limit the caller, and there is an issue of being called arbitrarily, but it can only transfer the balance of the sender to the feeCollector. cross-send/contracts/fee-managers/RecipientCountFee.sol#L65-L83 function distributeTokenFee( uint256 txRecipientCount, uint256, uint256, uint256, uint256, address sender ) public override { uint256 payableFee = txRecipientCount * tokenFeePerRecipient; 17 if(payableFee < minTokenFee) { payableFee = minTokenFee; } else if (payableFee > maxTokenFee) { payableFee = maxTokenFee; } token.safeTransferFrom(sender, feeCollector, payableFee); }",
        "labels": [
            "SlowMist",
            "Cross Send V1.0.1",
            "Type: Authority Control Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Price manipulation issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Send V1.0.1_en-us.pdf",
        "body": "The IOUPrice is calculated using totalFarmingTokenBalance. Attackers can control totalFarmingTokenBalance to manipulate IOUPrice. The current code does not nd the location where IOUPrice is used. Referencehttps://slowmist.medium.com/cream-hacked-analysis-us-130-million-hacked-95c9410320ca cross-yield/contracts/core/CrossYield.sol#L95-L101 function IOUPrice() public view returns (uint256) { uint256 IOUSupply = totalSupply(); return IOUSupply == 0 ? 1e18 : (totalFarmingTokenBalance() * 1e18) / IOUSupply; } 18 cross-yield/contracts/core/CrossYield.sol#L65-L67 function totalFarmingTokenBalance() public view returns (uint256) { return farmingToken().balanceOf(address(this)) + strategy.balanceOf(); }",
        "labels": [
            "SlowMist",
            "Cross Send V1.0.1",
            "Type: Others",
            "Severity: Medium"
        ]
    },
    {
        "title": "Sandwich attacks issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Send V1.0.1_en-us.pdf",
        "body": "There is no slippage check during swap, and there is a risk of sandwich attack. IPancakeRouter02(pcsRouter).swapExactTokensForTokens(cakeBalance, 0,cakeToBaseRoute, address(this), block.timestamp); IPancakeRouter02(pcsRouter) .swapExactTokensForTokens(toSwap, 0, route, address(this), block.timestamp); Reference https://medium.com/coinmonks/demystify-the-dark-forest-on-ethereum-sandwich-attacks-5a3aec9fa33e cross-yield/contracts/libs/OptimalSwap.sol#L14-L63 function prepareLiquidity( address cake, address[2] memory lpTokens, 19 address wbnb, address busd, address farmingToken, address pcsRouter, uint256 fee ) external { uint256 cakeBalance = IERC20(cake).balanceOf(address(this)); bool isCakeInLp = lpTokens[0] == cake || lpTokens[1] == cake; bool isWbnbBased = lpTokens[0] == wbnb || lpTokens[1] == wbnb; address baseToken = isWbnbBased ? wbnb : busd; // if cake is not part of the lp token, swap all cake for the base token if (!isCakeInLp) { address[] memory cakeToBaseRoute = new address[](2); cakeToBaseRoute[0] = cake; cakeToBaseRoute[1] = baseToken; IPancakeRouter02(pcsRouter) .swapExactTokensForTokens(cakeBalance, 0, cakeToBaseRoute, address(this), block.timestamp); } (uint256 reserve0, uint256 reserve1,) = IPancakePair(farmingToken).getReserves(); address[] memory route = new address[](2); uint256 lp0Bal = IERC20(lpTokens[0]).balanceOf(address(this)); uint256 lp1Bal = IERC20(lpTokens[1]).balanceOf(address(this)); uint256 toSwap; // The possible cases here are: // - Cake was not part of the LP token, so we swap for baseToken which could either be lpToken0 or lpToken // - Cake was part of the LP token, so it can either be lpTokens[0] or lpTokens[1] // So, depending on which token we have the highest balance for, we swap for the other one. if (lp0Bal > lp1Bal) { toSwap = SwapAmount.getSwapAmount(lp0Bal, reserve0, fee); route[0] = lpTokens[0]; route[1] = lpTokens[1]; } else { toSwap = SwapAmount.getSwapAmount(lp1Bal, reserve1, fee); route[0] = lpTokens[1]; route[1] = lpTokens[0]; 20 } // Perform the swap IPancakeRouter02(pcsRouter) .swapExactTokensForTokens(toSwap, 0, route, address(this), block.timestamp); } IPancakeRouter02(pcsRouter).swapExactTokensForTokens(toWbnb, 0, cakeToWbnbRoute, address(this), block.timestamp); cross-yield/contracts/strategies/StrategyCake.sol#L131 function collectFees() internal { // a percentant of the cake we get from the masterchef will be used to buy BNB and transfer to this address // this is the total fees that will be shared amongst the protocol, stategy dev and the harvester uint256 toWbnb = feeManager.calculateTotalFee(IERC20(farmingToken).balanceOf(address(this))); IPancakeRouter02(pcsRouter).swapExactTokensForTokens(toWbnb, 0, cakeToWbnbRoute, address(this), block.timestamp); uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this)); // distribute hervester fee uint256 harvesterFeeAmount = feeManager.calculateHarvestFee(wbnbBal); // collectFees is called indirectly from the CrossYield contract via the beforeDeposit hook. // This means that _msgSender() is the CrossYield contract and not the actuall EOA account // that send the transaction IERC20(wbnb).safeTransfer(tx.origin, harvesterFeeAmount); // distribute protocol fee uint256 protocolFeeAmount = feeManager.calculateProtocolFee(wbnbBal); // IERC20(wbnb).safeTransfer(protocolFeeRecipient, protocolFeeAmount); feeProcessor.process(protocolFeeAmount); // distribute strategy dev fee uint256 strategyDevFeeAmount = feeManager.calculateStrategyDevFee(wbnbBal); IERC20(wbnb).safeTransfer(feeManager.strategyDev(), strategyDevFeeAmount); emit FeeCollected( toWbnb, 21 harvesterFeeAmount, protocolFeeAmount, strategyDevFeeAmount, _msgSender() ); } cross-yield/contracts/strategies/StrategyCakeLP.sol#L174 function collectFees() internal { // a percentant of the cake we get from the masterchef will be used to buy BNB and transfer to this address // this is the total fees that will be shared amongst the protocol, stategy dev and the harvester uint256 toWbnb = feeManager.calculateTotalFee(IERC20(cake).balanceOf(address(this))); IPancakeRouter02(pcsRouter).swapExactTokensForTokens(toWbnb, 0, cakeToWbnbRoute, address(this), block.timestamp); uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this)); // distribute hervester fee uint256 harvesterFeeAmount = feeManager.calculateHarvestFee(wbnbBal); IERC20(wbnb).safeTransfer(_msgSender(), harvesterFeeAmount); // distribute protocol fee uint256 protocolFeeAmount = feeManager.calculateProtocolFee(wbnbBal); feeProcessor.process(protocolFeeAmount); // distribute strategy dev fee uint256 strategyDevFeeAmount = feeManager.calculateStrategyDevFee(wbnbBal); IERC20(wbnb).safeTransfer(feeManager.strategyDev(), strategyDevFeeAmount); emit FeeCollected( toWbnb, harvesterFeeAmount, protocolFeeAmount, strategyDevFeeAmount, _msgSender() ); } cross-yield/contracts/strategies/StrategyCake.sol 22 function harvest() public override whenNotPaused { // claim rewards IMasterChef(masterchef).leaveStaking(0); // because harvest can automatically be called after each user deposit // we might end up having multiple deposits in the same block and only one // would return rewards from masterchef so the rest will have 0 cake so // we don't need to waste gas to collect fees and call deposit uint256 farmingTokenBalance = balanceOfFarmingToken(); if(farmingTokenBalance > 0) { collectFees(); deposit(); emit HarvestTriggered(_msgSender(), farmingTokenBalance); } } cross-yield/contracts/strategies/StrategyCakeLP.sol#l137-L148 function harvest() external override whenNotPaused { // claim rewards IMasterChef(masterchef).deposit(poolId, 0); uint256 harvestedAmount = IERC20(cake).balanceOf(address(this)); collectFees(); addLiquidity(); deposit(); emit HarvestTriggered(_msgSender(), harvestedAmount); }",
        "labels": [
            "SlowMist",
            "Cross Send V1.0.1",
            "Type: Reordering Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Missing slippage check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Send V1.0.1_en-us.pdf",
        "body": "The addLiquidity function without slippage check, it doesn't have an impermanent loss check. cross-yield/contracts/strategies/StrategyCakeLP.sol#L218 function addLiquidity() internal { OptimalSwap.prepareLiquidity( cake, [lpToken0, lpToken1], wbnb, busd, farmingToken, pcsRouter, swapFee ); // add liquidity to AMM on PCS uint256 lp0Bal = IERC20(lpToken0).balanceOf(address(this)); uint256 lp1Bal = IERC20(lpToken1).balanceOf(address(this)); IPancakeRouter02(pcsRouter) .addLiquidity(lpToken0, lpToken1, lp0Bal, lp1Bal, 0, 0, address(this), block.timestamp); emit LiquidityAdded(lpToken0, lpToken1, lp0Bal, lp1Bal, _msgSender()); }",
        "labels": [
            "SlowMist",
            "Cross Send V1.0.1",
            "Type: Reordering Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Permission check Missing",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Send V1.0.1_en-us.pdf",
        "body": "There is no permission check for deposit function. The function is called by the CrossYieid contract. cross-yield/contracts/strategies/StrategyCakeLP.sol#L225-L231 function deposit() public override whenNotPaused { uint256 farmingTokenBalance = balanceOfFarmingToken(); if (farmingTokenBalance > 0) { IMasterChef(masterchef).deposit(poolId, farmingTokenBalance); } } cross-yield/contracts/strategies/StrategyCake.sol#L169-L175 function deposit() public override whenNotPaused { uint256 farmingTokenBalance = balanceOfFarmingToken(); if (farmingTokenBalance > 0) { IMasterChef(masterchef).enterStaking(farmingTokenBalance); } }",
        "labels": [
            "SlowMist",
            "Cross Send V1.0.1",
            "Type: Authority Control Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Excessive authority issue 25",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Send V1.0.1_en-us.pdf",
        "body": "Owner can modify the address of the strategy. The new strategy may have security risks if it is not audited, which will aect the user's funds. If the private key is leaked, it will aect the user's funds. cross-yield/contracts/core/CrossYield.sol#L224-L236 function upgradeStrategy() public onlyOwner { require(stratCandidate.strategy != address(0), \"No proposal exists\"); require(block.number > stratCandidate.proposedBlock + stratUpgradableAfter, \"Strategy cannot be replaced yet\"); emit NewStrategy(stratCandidate.strategy); strategy.retireStrategy(); strategy = IStrategy(stratCandidate.strategy); stratCandidate.strategy = address(0); stratCandidate.proposedBlock = 0; putFundsToWork(); } cross-yield/contracts/core/CrossYield.sol#L211-L220 function proposeStrategy(address _strategy) public onlyOwner { require(address(this) == IStrategy(_strategy).vault(), \"Invalid new strategy\"); stratCandidate = StrategyCandidate({ strategy: _strategy, proposedBlock: block.number }); emit NewStratCandidate(_strategy); }",
        "labels": [
            "SlowMist",
            "Cross Send V1.0.1",
            "Type: Authority Control Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Repeatable claims issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Send V1.0.1_en-us.pdf",
        "body": "After the claim, lottery.status is not set as claimed, and it is also necessary to check whether lotteryId has been claimed when the claim is executed. hotdrop/contracts/HotDrop.sol#L261-L274 function claim(uint256 lotteryId) external nonReentrant { Lottery storage lottery = lotteries[lotteryId]; require(lottery.status == Status.WinnerDrawn, \"winner not drawn\"); // if there is no winner transfer the total amount to the treasury if(tickets[lotteryId][lottery.winningNumber] == address(0)) { lottery.purchaseToken.safeTransfer(treasury, lottery.purchaseToken.balanceOf(address(this))); } else if(tickets[lotteryId][lottery.winningNumber] == _msgSender()) { // if the ticket is the winning ticket and belongs to the user then split the pot uint256 treasuryAmount = (lottery.totalRaised * lottery.treasuryFee) / FEE_BASE; lottery.purchaseToken.safeTransfer(treasury, treasuryAmount); lottery.purchaseToken.safeTransfer(_msgSender(), lottery.totalRaised - treasuryAmount); } }",
        "labels": [
            "SlowMist",
            "Cross Send V1.0.1",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Round plan security reminder",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Send V1.0.1_en-us.pdf",
        "body": "And the new round of lottery can only be opened when the last round of lottery is in WinnerDrawn, otherwise randomGenerator.latestLotteryId will be updated, which will cause the old lottery round to fail to execute drawWinner function due to this check. require(lotteryId == randomGenerator.latestLotteryId(), \"numbers not drawn\"); hotdrop/contracts/HotDrop.sol#L44-L256 function drawWinner(uint256 lotteryId) external nonReentrant { Lottery storage lottery = lotteries[lotteryId]; require(lottery.status == Status.Close, \"lottery still active\"); require(lotteryId == randomGenerator.latestLotteryId(), \"numbers not drawn\"); // get the winning number based on the randomResult generated by ChainLink's fallback uint256 winningNumber = randomGenerator.randomResult(); lottery.winningNumber = winningNumber; lottery.status = Status.WinnerDrawn; emit LotteryNumberDrawn(lotteryId, winningNumber); }",
        "labels": [
            "SlowMist",
            "Cross Send V1.0.1",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Business logic error Payable Payable Can Modify State - Can Modify State Can Modify State Can Modify State - - - - - - - 13",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ioTube_en-us.pdf",
        "body": "When originalAssetByID gets the data of originalAssets, the _assetID passed in should be reduced by 1, and then readout. activateAsset, deactivateAsset function directly passes in _assetID, and then read originalAssets[_assetID], The judgment is _assetID <= originalAssets.length . There are two issues here: 1. When _assetID == originalAssets.length, originalAssets[_assetID] cannot read data. 2. The originalAssets data obtained here is not obtained using the originalAssetByID function, and the business logic needs to be conrmed. contracts/AssetRegistry.sol#L101-L133 function activateAsset(uint256 _assetID, uint256 _tubeID) public onlyOperator { require(_assetID > 0 && _assetID <= originalAssets.length, \"invalid asset id\"); Asset storage oa = originalAssets[_assetID]; if (_tubeID == 0 || oa.tubeID == _tubeID) { if (oa.active == false) { oa.active = true; emit AssetActivated(_assetID, oa.tubeID); } } else { Asset storage sa = shadowAssets[_assetID][_tubeID]; if (sa.asset != address(0) && sa.active == false) { sa.active = true; emit AssetActivated(_assetID, _tubeID); } } } function deactivateAsset(uint256 _assetID, uint256 _tubeID) public onlyOperator { require(_assetID > 0 && _assetID <= originalAssets.length, \"invalid asset id\"); Asset storage oa = originalAssets[_assetID]; if (_tubeID == 0 || oa.tubeID == _tubeID) { if (oa.active == true) { oa.active = false; 14 emit AssetDeactivated(_assetID, oa.tubeID); } } else { Asset storage sa = shadowAssets[_assetID][_tubeID]; if (sa.asset != address(0) && sa.active == true) { sa.active = false; emit AssetDeactivated(_assetID, _tubeID); } } } originalAssetIDs[_tubeID][_asset] = id; The record is originalAssets.length;, so to take the value of originalAssets, the index should be originalAssetIDs[_tubeID][_asset]-1, combined with the processing logic here, you need to conrm the issues with the developer. contracts/AssetRegistry.sol#L74-L84 function addOriginalAsset(uint256 _tubeID, address _asset) public onlyOperator returns (uint256) { require(_tubeID > 0 && _asset != address(0), \"invalid parameter\"); uint256 id = assetID(_tubeID, _asset); if (id == 0) { originalAssets.push(Asset(_tubeID, _asset, true)); id = originalAssets.length; originalAssetIDs[_tubeID][_asset] = id; emit NewOriginalAsset(_tubeID, _asset, id); } return id; }",
        "labels": [
            "SlowMist",
            "ioTube",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Authority transfer enhancement",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ioTube_en-us.pdf",
        "body": "There is no pending and accept mechanism for authority transfer to avoid loss of authority contracts/CrosschainERC20.sol#L34-L37 function transferMintership(address _newMinter) public onlyMinter { minter = _newMinter; 16 emit MinterSet(_newMinter); } contracts/CrosschainERC721.sol#L29-L32 function transferMintership(address _newMinter) public onlyMinter { minter = _newMinter; emit MinterSet(_newMinter); }",
        "labels": [
            "SlowMist",
            "ioTube",
            "Type: Authority Control Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "unsafe external call risk",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ioTube_en-us.pdf",
        "body": "The withdraw function in the contract code does not check the whitelist of _recipient and _data. There is an unsafe external call (success,) = _recipient.call(_data); . The attacker can use _recipient.call(_data); to call any function of the lord contract, or transfer the token approved by the user to the Tube contract. contracts/Tube.sol#L179-L207 function withdraw( uint256 _srcTubeID, uint256 _txIdx, address _token, address _recipient, uint256 _amount, bytes memory _data, bytes memory _signatures ) public whenNotPaused { require(_amount != 0, \"amount is 0\"); 17 require(_recipient != address(0), \"invalid recipient\"); require(_signatures.length % 65 == 0, \"invalid signature length\"); bytes32 key = genKey(_srcTubeID, _txIdx, _token, _recipient, _amount, _data); ledger.record(key); (bool isValid, address[] memory signers) = verifier.verify(key, _signatures); require(isValid, \"insufficient validators\"); bool success = true; if (_data.length > 0) { lord.mint(_token, address(this), _amount); IERC20(_token).safeApprove(_recipient, _amount); (success, ) = _recipient.call(_data); if (!success) { IERC20(_token).safeDecreaseAllowance(_recipient, _amount); } } else { lord.mint(_token, _recipient, _amount); } emit Settled(key, signers, success); }",
        "labels": [
            "SlowMist",
            "ioTube",
            "Type: Unsafe External Call Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Excessive authority issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ioTube_en-us.pdf",
        "body": "The Owner of the Tube contract has too much authority. The owner of the Lord contract can be changed, and the owner of the Lord contract can execute mint and burn arbitrarily. This will aect the users assets. contracts/Tube.sol#L71-L78 function upgrade(address _newTube) public onlyOwner { if (ledger.owner() == address(this)) { ledger.transferOwnership(_newTube); } 18 if (lord.owner() == address(this)) { lord.transferOwnership(_newTube); } } contracts/Lord.sol#L94-L131 function burn( address _token, address _sender, uint256 _amount ) public onlyOwner { if (address(standardTokenList) != address(0) && standardTokenList.isAllowed(_token)) { // transfer token to standardTokenList _callOptionalReturn( _token, abi.encodeWithSelector(IToken(_token).transferFrom.selector, _sender, tokenSafe, _amount) ); return; } if (address(proxyTokenList) != address(0) && proxyTokenList.isAllowed(_token)) { _callOptionalReturn( _token, abi.encodeWithSelector(IToken(_token).transferFrom.selector, _sender, address(this), _amount) ); _callOptionalReturn(_token, abi.encodeWithSelector(IToken(_token).burn.selector, _amount)); return; } _callOptionalReturn(_token, abi.encodeWithSelector(IToken(_token).burnFrom.selector, _sender, _amount)); } function mint( address _token, address _recipient, uint256 _amount ) public onlyOwner { if (address(standardTokenList) != address(0) && 19 standardTokenList.isAllowed(_token)) { require(tokenSafe.mint(_token, _recipient, _amount), \"token safe mint failed\"); return; } if (address(proxyTokenList) != address(0) && proxyTokenList.isAllowed(_token)) { require(minterPool.mint(_token, _recipient, _amount), \"proxy token mint failed\"); } _callOptionalReturn(_token, abi.encodeWithSelector(IToken(_token).mint.selector, _recipient, _amount)); } function mintNFT( address _token, uint256 _tokenID, address _recipient, bytes memory _data ) public onlyOwner { IERC721Mintable(_token).safeMint(_recipient, _tokenID, _data); } function upgrade(address _newLord) public onlyOwner { if (minterPool.owner() == address(this)) { _callOptionalReturn( address(tokenSafe), abi.encodeWithSelector(minterPool.transferOwnership.selector, _newLord) ); } if (tokenSafe.owner() == address(this)) { _callOptionalReturn( address(tokenSafe), abi.encodeWithSelector(tokenSafe.transferOwnership.selector, _newLord) ); } }",
        "labels": [
            "SlowMist",
            "ioTube",
            "Type: Authority Control Vulnerability",
            "Severity: High"
        ]
    },
    {
        "title": "Business logic aws",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ioTube_en-us.pdf",
        "body": "The swapCoinForCrosschainCoin function will call cerc20.depositTo. contracts/CrosschainCoinRouter.sol#L37-L40 function swapCoinForCrosschainCoin(uint256 _amount) public payable { wrappedCoin.deposit{value: _amount}(); cerc20.depositTo(msg.sender, _amount); } cerc20.depositTo will call safeTransferFrom, where msg.sender is the CrosschainCoinRouter contract, but CrosschainCoinRouter has authorized CrosschainERC20 contract operation assets. contracts/CrosschainERC20.sol#L43-L47 function depositTo(address _to, uint256 _amount) public { require(address(coToken) != address(0), \"no co-token\"); coToken.safeTransferFrom(msg.sender, address(this), _amount); _mint(_to, _amount); } Although the allowance is set to -1, under extreme conditions, the continuous consumption quota will still be reduced to no quota. At this time, the contract cannot be used without re-approve. contracts/CrosschainCoinRouter.sol#L20-L25 constructor(CrosschainERC20 _cerc20) public { ERC20 ct = _cerc20.coToken(); cerc20 = _cerc20; ct.safeApprove(address(cerc20), uint256(-1)); 21 wrappedCoin = WrappedCoin(address(ct)); }",
        "labels": [
            "SlowMist",
            "ioTube",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Excessive authority issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ioTube_en-us.pdf",
        "body": "Owner can set the relayfee arbitrarily, and there is no limit on the value range. When the relayfee is set to a large value, most of the user's funds will be used to pay the relayFees. contracts/TubeRouter.sol#L49-L55 function setRelayFee(uint256 _tubeID, uint256 _fee) public onlyOwner { if (_fee == 0) { relayFees[_tubeID].exists = false; } else { relayFees[_tubeID] = RelayFee(_fee, true); } }",
        "labels": [
            "SlowMist",
            "ioTube",
            "Type: Authority Control Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Coding optimization",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ioTube_en-us.pdf",
        "body": "22 Owner can withdraw ETH and token in the contract. There are relayFees in the TubeRouter contract, and the Owner can withdraw the relayFees through the withdrawToken function, However, withdrawCoin and withdrawToken are used to extract the assets that were unexpectedly credited into the contract. contracts/TubeRouter.sol#L97-L106 function withdrawCoin(address payable _to) external onlyOwner { _to.transfer(address(this).balance); } function withdrawToken(address _to, IERC20 _token) external onlyOwner { uint256 balance = _token.balanceOf(address(this)); if (balance > 0) { _token.safeTransfer(_to, balance); } } contracts/Tube.sol#L229-L238 function withdrawCoin(address payable _to) external onlyOwner { _to.transfer(address(this).balance); } function withdrawToken(address _to, IERC20 _token) external onlyOwner { uint256 balance = _token.balanceOf(address(this)); if (balance > 0) { _token.safeTransfer(_to, balance); } }",
        "labels": [
            "SlowMist",
            "ioTube",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Other safety reminders",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ioTube_en-us.pdf",
        "body": "Note that when signing, make sure that the K value is not the same in the signature implementation. In the elliptic curve signature algorithm, if the random number is not safe enough and the same K value random number is used, there will be two transactions with the same R value. , So that the private key can be calculated, please pay attention to investigate similar cryptographic implementations. Reference: https://panzhibiao.com/2019/03/13/important-random-k-and-fake-signatures/ To capture events in the cross-chain bridge, the implementation of subscribing to the events of the specied contract should be adopted to avoid the attacks of fake contract events",
        "labels": [
            "SlowMist",
            "ioTube",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Synclub_en-us.pdf",
        "body": "1.In the SnBnb contract, the DEFAULT_ADMIN_ROLE can set the stakeManager contract as the StakeManager role and the StakeManager role can call the mint and burn functions to mint tokens arbitrarily and burn any users tokens. ",
        "labels": [
            "SlowMist",
            "Synclub",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "The mint amount can be 0 in the deposit function",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Synclub_en-us.pdf",
        "body": "In the SnStakeManager contract, users deposit their BNB into this contract and obtain the SnBNB as the staking certicate. And the calculation of the snBnbToMint is dependent on the convertBnbToSnBnb function, the totalSupply of the SnBNB, and the totalPooledBnb in this contract. If the deposit amount of the BNB is small enough or the totalPooledBnb is big enough, the calculation of the snBnbToMint can be 0. But the amount of the BNB can still add to the amountToDelegate to cause the increment of the totalPooledBnb. ",
        "labels": [
            "SlowMist",
            "Synclub",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "The BNB can be remained in the contract",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Synclub_en-us.pdf",
        "body": "In the SnStakeManager contract when users claim to withdraw their BNB tokens in the claimWithdraw in the same uuid, the calculation of the amount = (totalBnbToWithdraw_ * amountInSnBnb) / totalSnBnbToBurn_; has the rounding to obtain one of the users withdrawal amount. It will cause the rounded amount of the BNB to remain in this contract and can not be withdrawn. ",
        "labels": [
            "SlowMist",
            "Synclub",
            "Type: Arithmetic Accuracy Deviation Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "The business logic is unclear",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Synclub_en-us.pdf",
        "body": "In the SnStakeManager contract, the claimUndelegated function calculates the claimUndelegated withdrawal value in one uuid and assigns it to two temporary variables. The two temporary variables are just for recording and have no other usage. ",
        "labels": [
            "SlowMist",
            "Synclub",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing the validator check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Synclub_en-us.pdf",
        "body": "In the SnStakeManager contract, the Manager role can change the Validator through the redelegate function, and this check is done by the NATIVE_STAKING contract, and if the call of the redelegate function failed, it will consume the gas of this call. ",
        "labels": [
            "SlowMist",
            "Synclub",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing the event records",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Synclub_en-us.pdf",
        "body": "There are no event logs of the claimUndelegated and claimFailedDelegation in this SnStakeManager contract. ",
        "labels": [
            "SlowMist",
            "Synclub",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Preemptive initialization",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Synclub_en-us.pdf",
        "body": "By calling the initialize function to initialize the contracts, there is a potential issue that malicious attackers preemptively call the initialize function to initialize. ",
        "labels": [
            "SlowMist",
            "Synclub",
            "Type: Race Conditions Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Dev address setting enhancement suggestions",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Synclub_en-us.pdf",
        "body": "In the SnStakeManager contract, the GOVERNANCE_ROLE role can set the revenuePool address to receive the fee. If the address is an EOA address, in a scenario where the private keys are leaked, the teams revenue will be stolen. ",
        "labels": [
            "SlowMist",
            "Synclub",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Excessive authority issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ROTL_en-us.pdf",
        "body": "In the ROTL contract, the DEFAULT_ADMIN_ROLE can set the minter role, the minter role can mint ERC721A tokens arbitrarily and the minter role is entitled to free mint without going through each rounds. 11 ",
        "labels": [
            "SlowMist",
            "ROTL",
            "Type: Authority Control Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Pausable is not implemented",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ROTL_en-us.pdf",
        "body": "In the ROLTMint contract, it heritates the Pausable contract, but there is no pause and unpause function implemented. That means the value ot the _paused is false and can not be changed. Which will impact the __isEnable function and whenNotPaused modier. ",
        "labels": [
            "SlowMist",
            "ROTL",
            "Type: Others",
            "Severity: Low"
        ]
    },
    {
        "title": "Missing event record",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ROTL_en-us.pdf",
        "body": "1.In the ROTLMint contract, the owner role can set the _nft, _merkleRoot, _currentRound, price, maxCount, onceMaxCount, addressMaxCount, and startBlock values through the setAddress, setMerkleRoot, setRound, and setRoundInfo functions. But there are no no events logging performed. ",
        "labels": [
            "SlowMist",
            "ROTL",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Dev address setting enhancement suggestion 14",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ROTL_en-us.pdf",
        "body": "In the ROTLMint contract, the owner role can withdraw the native token through the withdraw function. If the owner is an EOA address, in a scenario where the private key is leaked, the teams revenue will be stolen. ",
        "labels": [
            "SlowMist",
            "ROTL",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Variable not used",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ROTL_en-us.pdf",
        "body": "In the ROLT contract, the contract dened the _mintContractAddress and _revealIndex value. But these two values are not assigned and can not be set. ",
        "labels": [
            "SlowMist",
            "ROTL",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - LightDAO_en-us.pdf",
        "body": "1.In the HOPESalesAgent contract, the owner can add currency that can buy HOPE tokendelete the currency and change the currency exhange rate. If the owners privileges are lost, it could lead to a contract being maliciously added with a worthless currency and used it to unintentionally buy large amounts of hope tokens. ",
        "labels": [
            "SlowMist",
            "LightDAO",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "The DoS issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - LightDAO_en-us.pdf",
        "body": "The user can pass in the gombocAddressList array through the mintMany function to mint the LT. If the length of gombocAddressList is large, it will cause DoS because of the number of for loops. ",
        "labels": [
            "SlowMist",
            "LightDAO",
            "Type: Denial of Service Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Missing event records",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - LightDAO_en-us.pdf",
        "body": "1.In the Minter contract, the caller can toggle the approval status for mintingUser, but there are no event logs. ",
        "labels": [
            "SlowMist",
            "LightDAO",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing zero address check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - LightDAO_en-us.pdf",
        "body": "When modifying important addresses in the contract, it is not checked whether the incoming address is a zero address. ",
        "labels": [
            "SlowMist",
            "LightDAO",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing return value check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - LightDAO_en-us.pdf",
        "body": "When transferring ERC20 tokens, the return value after the transfer is not checked. If return false, the logical should be reverted. ",
        "labels": [
            "SlowMist",
            "LightDAO",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "4.3.1.1 Risk of repeated contract initialization",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SmoothyV1_en-us.pdf",
        "body": "In the SmoothyMasterV1 contract, the owner can initialize the contract through the initialize function to set the address of key parameters such as SMTYToken, startTime, and communityAddr. However, there is no restriction on the initialize function to prevent repeated initialization calls, which will cause the owner role to repeatedly initialize the contract through the initialize function. The same goes for VotingEscrow and SmoothyV1 contracts. Fix suggestion: It is suggested to restrict the initialization function that does not allow repeated calls. ",
        "labels": [
            "SlowMist",
            "SmoothyV1",
            "Severity: High"
        ]
    },
    {
        "title": "4.3.2.1 Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SmoothyV1_en-us.pdf",
        "body": "In the SMTYToken contract, the minter role can mint tokens arbitrarily through the mint function. The owner role can arbitrarily modify the minter role address through the changeMinter function, which 10 will lead to the risk of excessive owner authority. Fix suggestion: It is suggested to transfer the owner authority to community governance. ",
        "labels": [
            "SlowMist",
            "SmoothyV1",
            "Severity: Medium"
        ]
    },
    {
        "title": "4.3.2.2 Denial of Service Risk",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SmoothyV1_en-us.pdf",
        "body": "In the SmoothyMasterV1 contract, the user can update all pools through the massUpdatePools function, but it uses the for loop to update cyclically. If the number of pools exceeds too much, it will cause a DoS risk. Fix suggestion: It is suggested to limit the number of pools to avoid this problem. function massUpdatePools() public { uint256 length = poolInfo.length; for (uint256 pid = 0; pid < length; ++pid) { updatePool(pid); } } Fix status: No Fixed. 11",
        "labels": [
            "SlowMist",
            "SmoothyV1",
            "Severity: Medium"
        ]
    },
    {
        "title": "4.3.3.1 The lockDuration does not match the lockEnd",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SmoothyV1_en-us.pdf",
        "body": "In the SmoothyMasterV1 contract, the user can extend the mortgage lock period through the extendLock function. When reconfirming the lockDuration, take the new lock duration and the smaller value of MAX_TIME, but in the end, when determining the lockEnd, the _end parameter is still directly passed in. Assigned to lockEnd, if the new lock duration is greater than MAX_TIME, this will cause the lockDuration to not match the lockEnd. Fix suggestion: It is suggested to recalculate lockEnd based on lockDuration. ",
        "labels": [
            "SlowMist",
            "SmoothyV1",
            "Severity: Low"
        ]
    },
    {
        "title": "4.3.3.1 Inaccurate calculation of LP amount",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SmoothyV1_en-us.pdf",
        "body": "In the SmoothyV1 contract, in order to save gas in mint, redeem, and swap operations, the 12 calculation using getMintAmount uses cached data for calculation, which will cause the final calculation result to be inconsistent with expectations. Fix suggestion: Due to project design requirements, it is suggested that the project party manually invoke the update when the update is not performed to avoid this issue. ",
        "labels": [
            "SlowMist",
            "SmoothyV1",
            "Severity: Low"
        ]
    },
    {
        "title": "4.3.4.1 The change of LP pool weights affects users' income",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SmoothyV1_en-us.pdf",
        "body": "In the SmoothyMasterV1 contract, when the Owner calls the add function and the set function to add a new pool or reset the pool weight, all LP pool weights will change accordingly. The Owner can update all pools before adjusting the weight by passing in the _withUpdate parameter with a value of true to ensure that the user's income before the pool weight is changed will not be affected by the adjustment of the pool weight, but if the value of the _withUpdate parameter is false, then All pools will not be updated before the pool weight is adjusted, which will cause the user's income to be affected before the pool weight is changed. Fix suggestion: It is suggested to force all LP pools to be updated before the weights of LP pools are adjusted to avoid the impact of user income. ",
        "labels": [
            "SlowMist",
            "SmoothyV1",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.3.4.2 Loss of precision issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SmoothyV1_en-us.pdf",
        "body": "In the SmoothyMasterV1 contract, when using the _updateWorkingAmount function to calculate the number of workingAmount users participate in mining, divide first and then multiply, which will result in loss of accuracy. Fix suggestion: It is suggested to multiply and then divide to avoid this issue ",
        "labels": [
            "SlowMist",
            "SmoothyV1",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.3.4.3 Unrecoverable issue of pool imbalance",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SmoothyV1_en-us.pdf",
        "body": "In the SmoothyV1 contract, when the user performs operations such as recharge, redemption, and exchange, the penalty mechanism will be triggered when the weight of the coin exceeds the soft cap, but the contract does not have an incentive mechanism to perform exchange operations to reduce the proportion of the token pool. If the token pool is maliciously manipulated to exceed the soft cap, it may be difficult for the token pool to return to normal due to no incentive mechanism, which will affect normal business use. 17 Fix suggestion: It is suggested to add an incentive mechanism in an unbalanced state to avoid this problem. ",
        "labels": [
            "SlowMist",
            "SmoothyV1",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.3.4.4 Risk of Potential Token Transfer Failure",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SmoothyV1_en-us.pdf",
        "body": "In the SmoothyV1 contract, when the user deposits the token, the safeTransferFrom function is used to transfer the corresponding token, and the safeTransfer function is used to transfer the token when withdrawToken. The safeTransferFrom function and safeTransfer function will check the returned success and data , If the connected token defines the return value, but does not return according to the EIP20 specification, the user will not be able to pass the check here, resulting in the tokens being unable to be transferred in or out. Fix suggestion: It is suggested that when docking new tokens, the project party should check whether its writing complies with EIP20 specifications. ",
        "labels": [
            "SlowMist",
            "SmoothyV1",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.3.4.5 Token compatibility issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SmoothyV1_en-us.pdf",
        "body": "In the SmoothyV1 contract, under the condition that each pool is stable, the exchange operation will be performed in a 1:1 manner. However, if the project is connected to a stable rebase algorithm, the number of tokens in the pool will be changed when it undergoes deflation, resulting in an unexpected 18 number of users during the exchange. Fix suggestion: It is suggested to strictly evaluate the algorithm model of stablecoins to avoid this risk when accessing stablecoins. ",
        "labels": [
            "SlowMist",
            "SmoothyV1",
            "Severity: Informational"
        ]
    },
    {
        "title": "Transaction reordering issues",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - wault.finance(WUSD)_en-us.pdf",
        "body": "(1) In commit: 91c541c2f1c0ac781ddcfb2be6a62555a5e1e8d1, the swapExactTokensForTokensSupportingFeeOnTransferTokens in the stake function is not checked for slippage. https://github.com/WaultFinance/WUSD/blob/91c541c2f/WUSDMaster.sol#L716-L722 function stake(uint256 amount) external nonReentrant { require(amount > 0, 'amount cant be zero'); require(wusdClaimAmount[msg.sender] == 0, 'you have to claim first'); require(amount <= maxStakeAmount, 'amount too high'); usdt.safeTransferFrom(msg.sender, address(this), amount); if(feePermille > 0) { uint256 feeAmount = amount * feePermille / 1000; usdt.safeTransfer(treasury, feeAmount); amount = amount - feeAmount; } uint256 wexAmount = amount * wexPermille / 1000; usdt.approve(address(wswapRouter), wexAmount); wswapRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens( wexAmount, 0, swapPath, address(this), block.timestamp ); wusdClaimAmount[msg.sender] = amount; wusdClaimBlock[msg.sender] = block.number; emit Stake(msg.sender, amount); } 9 (2) In commit: de61d93cd7a35213484827cf32533919c34e732e amountOutMin is the parameter that limits the slippage, but it is entered by the user, the maxStakeAmount is added, but this limit can still be bypassed by sorting multiple transactions. https://github.com/WaultFinance/WUSD/blob/de61d93cd7a35213484827cf32533919c34e732e/WUSDMas ter.sol#L808-L834 function stake(uint256 amount, uint256 amountOutMin) external nonReentrant whenNotPaused { require(amount > 0, 'amount cant be zero'); require(wusdClaimAmount[msg.sender] == 0, 'you have to claim first'); require(amount <= maxStakeAmount, 'amount too high'); usdt.safeTransferFrom(msg.sender, address(this), amount); if(feePermille > 0) { uint256 feeAmount = amount * feePermille / 1000; usdt.safeTransfer(treasury, feeAmount); amount = amount - feeAmount; } wusd.mint(address(this), amount); uint256 wexAmount = amount * wexPermille / 1000; usdt.approve(address(wswapRouter), wexAmount); wswapRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens( wexAmount, amountOutMin, swapPath, address(this), block.timestamp ); wusdClaimAmount[msg.sender] = amount; wusdClaimBlock[msg.sender] = block.number; emit Stake(msg.sender, amount); } (3) In commit: 5f50a2c77828c70299e8a9217cfbb926b8c1, the maxStakePerBlock is added, but this limit can still be bypassed by sorting multiple transactions in multiple blocks. 10 https://github.com/WaultFinance/WUSD/blob/5f50a2c77828c70299e8a9217cfbb926b8c1/WUSDMaster. sol#L819-L851 function stake(uint256 amount, uint256 amountOutMin) external nonReentrant whenNotPaused { require(amount > 0, 'amount cant be zero'); require(wusdClaimAmount[msg.sender] == 0, 'you have to claim first'); require(amount <= maxStakeAmount, 'amount too high'); if(lastBlock != block.number) { lastBlockUsdtStaked = 0; lastBlock = block.number; } lastBlockUsdtStaked += amount; require(lastBlockUsdtStaked <= maxStakePerBlock, 'maximum stake per block exceeded'); usdt.safeTransferFrom(msg.sender, address(this), amount); if(feePermille > 0) { uint256 feeAmount = amount * feePermille / 1000; usdt.safeTransfer(treasury, feeAmount); amount = amount - feeAmount; } wusd.mint(address(this), amount); uint256 wexAmount = amount * wexPermille / 1000; usdt.approve(address(wswapRouter), wexAmount); wswapRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens( wexAmount, amountOutMin, swapPath, address(this), block.timestamp ); wusdClaimAmount[msg.sender] = amount; wusdClaimBlock[msg.sender] = block.number; emit Stake(msg.sender, amount); }",
        "labels": [
            "SlowMist",
            "wault.finance(WUSD)",
            "Type: Reordering Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "The deationary token docking issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - CakeVault_en-us.pdf",
        "body": "Users can transfer the cake token into the vault contract through the deposit function. Under normal circumstances, the number of staking tokens transferred by the user is the same as the _amount parameter passed in. But if the staking token is a deationary token, the number of tokens transferred by the user may be dierent from the number of tokens actually received in the contract. ",
        "labels": [
            "SlowMist",
            "CakeVault",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "CakeAtLastUserAction parameter record error issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - CakeVault_en-us.pdf",
        "body": "In the Vault contract, the user can withdraw the funds staked by the user through the withdraw function. If the user does not withdraw all funds (user.shares> 0), this function will recalculate the user's cakeAtLastUserAction value. In the calculation process, the number of cake tokens obtained by the balanceOf function is used to participate in the calculation. But at the end of this function, a certain amount of cake tokens will be transferred to the user through the safeTransfer function, so the number of cake tokens obtained by the balanceOf function used in the calculation of cakeAtLastUserAction is relatively large. ",
        "labels": [
            "SlowMist",
            "CakeVault",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing event records",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - CakeVault_en-us.pdf",
        "body": "In the contract, the owner role can set the addresses of the admin role and the treasure role through the setAdmin function and the setTreasury function, respectively, but no event recording is performed. In the contract, the admin role can change the sensitive parameters of the contract through the setPerformanceFee, setCallFee, setWithdrawFee, and setWithdrawFeePeriod functions, but no event recording is performed. ",
        "labels": [
            "SlowMist",
            "CakeVault",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Emergency withdrawal issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - CakeVault_en-us.pdf",
        "body": "In the Vault contract, the admin role can make emergency withdrawals of cake tokens from the MasterChef contract to the Vault contract via the emergencyWithdraw function. However, it should be noted that any user can obtain 0.25% of the cake token reward in the Vault contract through the harvest function, and re-stake the remaining cake tokens into the MasterChef contract. So if the emergencyWithdraw operation is performed while the contract is not suspended it may cause unintended results. 10 ",
        "labels": [
            "SlowMist",
            "CakeVault",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Index conict issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm_Phase6_en-us.pdf",
        "body": "In the MIM strategy of ENF_V3, the getPID function is used to obtain the pool id of the specied LP token in ConvexBooster. Returns the current index if the match is successful, otherwise returns the 0 index. However, there is a corresponding LP (Curve. cDAI/cUSDC) conguration for the 0 index in ConvexBooster, which will make it impossible for the caller to determine whether the return of the 0 index is due to a matching failure or LP tokens in the 0 pool of ConvexBooster. ",
        "labels": [
            "SlowMist",
            "Earning.Farm_Phase6",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Visibility issue with getPID function",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm_Phase6_en-us.pdf",
        "body": "There is a getPID function with public visibility in the MIM strategy of ENF_V3, but this function is not called by other functions in this contract, so using public visibility will consume more gas than external visibility. ",
        "labels": [
            "SlowMist",
            "Earning.Farm_Phase6",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Read-only reentrancy checks subject to rounding errors",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm_Phase6_en-us.pdf",
        "body": "In the StETH contract in ENF_ETH_Lowrisk, the remove_liquidity_one_coin function will be called during the deposit and withdraw operations to avoid virtual price manipulation. However, the remove_liquidity_one_coin operation does not always succeed due to rounding errors in the calculation of _get_y_D . ",
        "labels": [
            "SlowMist",
            "Earning.Farm_Phase6",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Slippage check issue when Vault gets totalAssets",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm_Phase6_en-us.pdf",
        "body": "In the Vault contract of ENF_ETH_Lowrisk, the totalAssets function is used to obtain the total assets held by the protocol, which will be counted by calling the totalAssets function of each SS contract. In the FrxETH strategy, in order to ensure that the amount of totalAssets obtained has not been manipulated, a slippage check will be performed according to the fetch ag. Fetch is passed as true in the Vault contract, which will ignore the slippage check. ",
        "labels": [
            "SlowMist",
            "Earning.Farm_Phase6",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Logic optimization",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm_Phase6_en-us.pdf",
        "body": "In the FrxETH contract of ENF_ETH_Lowrisk, there are some functions to convert between share and asset through the totalSupply and totalAssets values of sFrx. However, these interfaces have been provided in the sFrx contract, and the calculated decimal is more accurate. Here is some alternative logic: The frxBal calculation in _totalAssets function can be done by ISfrx(sFrx).convertToAssets(sFrxBal) The lastEarnPrice calculation in _deposit function can be done by ISfrx(sFrx).pricePerShare() The currentPrice calculation in harvest function can be done by ISfrx(sFrx).pricePerShare() ",
        "labels": [
            "SlowMist",
            "Earning.Farm_Phase6",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Swap optimization from ETH to FrxETH",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm_Phase6_en-us.pdf",
        "body": "In the FrxETH contract of ENF_ETH_Lowrisk, the _deposit function will select the optimal exchange path according to the price of CurvePool. When the amount exchanged by CurvePool is greater than or equal to _amount (curveExpect >= _amount), it will exchange tokens through CurvePool . If curveExpect == _amount , converting through CurvePool may consume more gas than minting through frxMinter. ",
        "labels": [
            "SlowMist",
            "Earning.Farm_Phase6",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap_v3_en-us.pdf",
        "body": "In the StableSwapRouter, the Owner role can set the stableSwapFactory to any address. If a fake stableSwapFactory address is passed in, the SmartRouterHelper will obtain a malicious transaction pair from the getStableInfo function, resulting in loss of funds. And this function is also missing the event log and 0 address check. ",
        "labels": [
            "SlowMist",
            "PancakeSwap_v3",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Token compatibility issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap_v3_en-us.pdf",
        "body": "1.In the StableSwapRouter, the exactOutputStableSwap and exactInputStableSwap functions will call swap to transfer by the pay function via the input data amountIn and the input data is recorded directly into it. In the swap function, although amountIn is re-recorded. However, the amountIn_ data is still recorded in the _swap function when the exchange is performed in the swapContract of the transferring third-party contract. If the third-party contract token balance is used to directly participate in the calculation, the contract cannot be compatible with the rebase token. ",
        "labels": [
            "SlowMist",
            "PancakeSwap_v3",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing event records",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap_v3_en-us.pdf",
        "body": "1.In the PancakeV3FactoryOwner contract, the owner role can set the lmPoolDeployer address, but there is no event log and 0 address check. ",
        "labels": [
            "SlowMist",
            "PancakeSwap_v3",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of initial operation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap_v3_en-us.pdf",
        "body": "In the PancakeV3Pool contract, by calling the initialize function to initialize the contracts, there is a potential issue that malicious attackers preemptively call the initialize function to initialize and there is no access control verication for the initialize functions ",
        "labels": [
            "SlowMist",
            "PancakeSwap_v3",
            "Type: Race Conditions Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of denial of service",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap_v3_en-us.pdf",
        "body": "In the UniswapV3Pool contract, the swap function can be disrupted by forcing the loop to go through too many operations, potentially trapping the swap due to a lack of gas. ",
        "labels": [
            "SlowMist",
            "PancakeSwap_v3",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of external manipulation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - LightDAO Phase2_en-us.pdf",
        "body": "In the UniswapV2Pair contract, anyone can call the claimLightReward function to claim and deposit the reward belonging to the pair. But the incoming address parameters (lightGomboc, minter, lightToken, gomboc) are externally manipulable, the attacker can construct a malicious external contract (the malicious gomboc contract) to steal the rewards that belong to the pair. ",
        "labels": [
            "SlowMist",
            "LightDAO Phase2",
            "Type: Unsafe External Call Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "The DoS issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - LightDAO Phase2_en-us.pdf",
        "body": "The length of the external array passed in by the user can be controlled. If the length is large, it will cause DoS because of the number of for loops. ",
        "labels": [
            "SlowMist",
            "LightDAO Phase2",
            "Type: Denial of Service Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Token compatibility issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - LightDAO Phase2_en-us.pdf",
        "body": "In the burn function of the LightSwapBurner contract, it will transfer the specied token into this contract through the transferFrom function. If the specied token is a deationary token, the actual number of the token received by the contract is less than the value of the amount parameter passed in by the user. This may cause the subsequent swap operation to fail. ",
        "labels": [
            "SlowMist",
            "LightDAO Phase2",
            "Type: Others",
            "Severity: Low"
        ]
    },
    {
        "title": "Missing slippage check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - LightDAO Phase2_en-us.pdf",
        "body": "In the LightSwapBurner and UnderlyingBurner contract, when performing the burn operation, the swapExactTokensForTokens function will be used to exchange tokens. However, the swapExactTokensForTokens function does not perform a slippage check, which will result in a high probability of being subjected to a sandwich attack by MEV Bot when performing the above operations. This will result in far fewer exchanges than expected, or even very few left. ",
        "labels": [
            "SlowMist",
            "LightDAO Phase2",
            "Type: Reordering Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - LightDAO Phase2_en-us.pdf",
        "body": "In the UniswapV2Factory contract, the feeToSetter role can set the feeRateNumerator through the setFeeRateNumerator function. However, there is no limit to the feeRateNumerator parameter that will be passed in, which can lead to high user fees if it is modied too much. ",
        "labels": [
            "SlowMist",
            "LightDAO Phase2",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Missing zero address check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - LightDAO Phase2_en-us.pdf",
        "body": "1.In the ApprovedTokenManager contract, the owner can add any tokens to the whitelist, but there is a lack of zero address check here, which may aect users' normal transactions if the owner accidentally approves a zero address. ",
        "labels": [
            "SlowMist",
            "LightDAO Phase2",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Redundant code",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - LightDAO Phase2_en-us.pdf",
        "body": "Redundant code for calling the _getPointBalanceOf function. ",
        "labels": [
            "SlowMist",
            "LightDAO Phase2",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing event records",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - LightDAO Phase2_en-us.pdf",
        "body": "1.In the factory contract, the feeToSetter role can set the feeTo, feeToSetter and approvedTokenManager addresses, but there are no event logs. ",
        "labels": [
            "SlowMist",
            "LightDAO Phase2",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Redundant Code Usage",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm_Phase5_en-us.pdf",
        "body": "In the Vault contract of ENFv3/ENF_lowrisk_farm/ENF_lowrisk_ETH_farm, the user will rst calculate the share when performing the withdraw operation. But it is calculated in the same way as the convertToShares function, so it is not necessary to use duplicate code for the calculation without using the convertToShares function. ",
        "labels": [
            "SlowMist",
            "Earning.Farm_Phase5",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Potential Precision Calculation Issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm_Phase5_en-us.pdf",
        "body": "In the Vault contract of ENFv3/ENF_lowrisk_farm/ENF_lowrisk_ETH_farm, users can burn shares through the redeem function to get back staked assets. It uses (shares * assetsPerShare()) / 1e24 to calculate the number of assets corresponding to the share, and the assetsPerShare function will multiply (assetDecimal * 1e18) when performing calculations. If assetDecimal is not equal to 6, dividing 1e24 when performing assets calculation will cause the decimal of the result to deviate. ",
        "labels": [
            "SlowMist",
            "Earning.Farm_Phase5",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Business logic aws in reward distribution",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm_Phase5_en-us.pdf",
        "body": "In the Vault contract of ENF_lowrisk_farm/ENF_lowrisk_ETH_farm, users can obtain shares through deposits, and receive harvest dividends according to the amount of shares held. The key to reward calculation is the accRewardPerTokens and prevBalace parameters. The owner role will increase the accRewardPerTokens parameter every time the harvest operation is performed, and prevBalace represents the user's share balance before reward settlement. But there will be a way to collect rewards by front-run deposits to improve the eciency of capital utilization: When the owner role performs the harvest operation, the user deposits at a higher gas fee. At this point the accRewardPerShares of the protocol has not been updated, and the user will get a portion of the shares. Then the owner performs the harvest operation, and the accRewardPerShares of the protocol will increase. Finally the user makes withdrawal and gets reward. Malicious users can use this method to obtain rewards in the blocks before and after the harvest operation, or even in the same block, without worrying about the problem of liquidity being locked in the protocol, which improves the utilization rate of funds. ",
        "labels": [
            "SlowMist",
            "Earning.Farm_Phase5",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Token Transfer Missing Rewards Update",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm_Phase5_en-us.pdf",
        "body": "In the Vault contract of ENF_lowrisk_farm/ENF_lowrisk_ETH_farm, the _updateUserData function is used to update the user's reward, but it is not updated when the user's share is transferred. This will result in accounting errors during share token transfers. Users can steal rewards by continuously transferring share tokens to new addresses. ",
        "labels": [
            "SlowMist",
            "Earning.Farm_Phase5",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Issue with checking on fromToken",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm_Phase5_en-us.pdf",
        "body": "In the vault contract of ENF_lowrisk_farm/ENF_lowrisk_ETH_farm, the _swap function is used to exchange reward tokens for the specied toToken. It will check whether fromToken is WETH, if the check is true, it will be exchanged through the swapExactETHInput function, if the check is false, it will be exchanged through swapExactTokenInput. However, when fromToken is address(0), the token exchange will also be performed through the swapExactTokenInput function, which may cause the _swap function to fail to perform as expected. ",
        "labels": [
            "SlowMist",
            "Earning.Farm_Phase5",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Incorrect reward receiving address",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm_Phase5_en-us.pdf",
        "body": "In the Vault contract of ENF_lowrisk_farm/ENF_lowrisk_ETH_farm, users can claim rewards through the claim function and specify the receiving address of the rewards. When toAsset is false, the protocol will issue the reward directly to the user, but the destination address of the reward is not the receiver address specied by the user but msg.sender. This is not as expected. ",
        "labels": [
            "SlowMist",
            "Earning.Farm_Phase5",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Direct distribution of rewards is not available",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm_Phase5_en-us.pdf",
        "body": "In the Vault contract of ENF_lowrisk_farm/ENF_lowrisk_ETH_farm, users can claim rewards through the claim function. When toAsset is false, the protocol will directly issue rewards to users. The safeTransferFrom function is used to transfer tokens when issuing rewards, but the contract has not been approved before. This will cause the contract to be unable to successfully execute the safeTransferFrom operation due to insucient allowances, and ultimately result in failure to issue rewards. ",
        "labels": [
            "SlowMist",
            "Earning.Farm_Phase5",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of price manipulation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm_Phase5_en-us.pdf",
        "body": "In the stETH contract of ENF_lowrisk_ETH_farm, the slippage check of SS depends on the virtual price (get_virtual_price) of Curve Pool, which will be aected by the reentrancy vulnerability of ETH/stETH Pool (please check to Ref[1][2]). Failure to check for slippage will result in malicious theft of funds from the strategy. Ref: [1] https://chainsecurity.com/curve-lp-oracle-manipulation-post-mortem/ [2] https://chainsecurity.com/heartbreaks-curve-lp-oracles/",
        "labels": [
            "SlowMist",
            "Earning.Farm_Phase5",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    }
]