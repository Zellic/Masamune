[
    {
        "title": "Missing zero address check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Kayak-UniswapV3-Contract.pdf",
        "body": "1.In the KayakSwapRouter contract, the constructor function lacks a zero address check for the _WETH parameter. contracts/swaprouter/KayakSwapRouter.sol#L67-L69 constructor(address _WETH) { weth = IWETH(_WETH); } 2.In the KayakSwapRouter contract, the swap function lacks a zero address check for the params.pool parameter. contracts/swaprouter/KayakSwapRouter.sol#L113-L141 function swap(SwapParams calldata params) public payable nonReentrant returns (uint256 returnAmount) { ``` if (params.flag) { _swapOnStableSwap(params.srcToken, params.dstToken, params.pool, receivedAmount); } else { _swapOnV3ExactIn(params.srcToken, params.dstToken, params.pool, receivedAmount); } ``` } 3.In the KayakSwapQuoter contract, the constructor function lacks a zero address check for the _WETH parameter. contracts/swaprouter/KayakSwapQuoter.sol#L34-L36 constructor(address _WETH) { weth = IWETH(_WETH); } 4.In the KayakSwapQuoter contract, the getReturnStableSwap function and getReturnUniswapV3 function lack a zero address check for the pool parameter. contracts/swaprouter/KayakSwapQuoter.sol#L87-L103, L105-L130 function getReturnStableSwap( address srcToken, address dstToken, address pool, uint256 amount ) public view returns (uint256 returnAmount) { ``` uint256 n_coins = IStableSwap(pool).N_COINS(); ``` } function getReturnUniswapV3( address srcToken, address dstToken, address pool, uint256 amount ) public returns (uint256 returnAmount) { ``` IUniswapV3Pool(pool).swap( ``` ) ``` }",
        "labels": [
            "SlowMist",
            "Kayak-UniswapV3-Contract",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "The identity of msg.sender is not veried",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Kayak-UniswapV3-Contract.pdf",
        "body": "In the KayakSwapRouter contract, the uniswapV3SwapCallback function does not verify whether msg.sender is a valid Uniswap V3 Pool. When there are assets in the contract, the attacker can construct malicious parameters and transfer any assets in the contract through the uniTransfer function called in the uniswapV3SwapCallback function. contracts/swaprouter/KayakSwapRouter.sol#L187-L197 function uniswapV3SwapCallback(int256 amount0Delta, int256 amount1Delta, bytes calldata _data) external { require(amount0Delta > 0 || amount1Delta > 0); // swaps entirely within 0- liquidity regions are not supported SwapCallbackData memory data = abi.decode(_data, (SwapCallbackData)); (address tokenIn, address tokenOut, , ) = data.path.decodeFirstPool(); (, uint256 amountToPay) = amount0Delta > 0 ? (tokenIn < tokenOut, uint256(amount0Delta)) : (tokenOut < tokenIn, uint256(amount1Delta)); IERC20(tokenIn).uniTransfer(msg.sender, amountToPay); }",
        "labels": [
            "SlowMist",
            "Kayak-UniswapV3-Contract",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Unchecked return value",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Kayak-UniswapV3-Contract.pdf",
        "body": "In the UniERC20 library, the uniApprove function did not check the return value when calling the approve function. contracts/swaprouter/libraries/UniERC20.sol#L68-L72 function uniApprove(IERC20 token, address to, uint256 amount) internal { if (isETH(token)) return; token.approve(to, amount); }",
        "labels": [
            "SlowMist",
            "Kayak-UniswapV3-Contract",
            "Type: Others",
            "Severity: Low"
        ]
    },
    {
        "title": "Redundant code",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Kayak-UniswapV3-Contract.pdf",
        "body": "In the KayakSwapQuoter contract, amountOutCached is not used. contracts/swaprouter/KayakSwapQuoter.sol#L22 uint256 private amountOutCached;",
        "labels": [
            "SlowMist",
            "Kayak-UniswapV3-Contract",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Insucient ETH balance causes the function to be unavailable",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Kayak-UniswapV3-Contract.pdf",
        "body": "In the KayakSwapQuoter contract, the purpose of the getReturnUniswapV3 function is to return the number of tokens that can be exchanged in the UniswapV3 pool, so there is no need to call the weth.deposit function to exchange WETH. Calling the weth.deposit function will fail because the contract does not have enough ETH balance and subsequent operations cannot be performed, which will make the function unusable. contracts/swaprouter/KayakSwapQuoter.sol function getReturnUniswapV3( address srcToken, address dstToken, address pool, uint256 amount ) public returns (uint256 returnAmount) { if (IERC20(srcToken).isETH()) { weth.deposit{ value: amount }(); } address srcTokenReal = IERC20(srcToken).isETH() ? address(weth) : srcToken; address dstTokenReal = IERC20(dstToken).isETH() ? address(weth) : dstToken; bool zeroForOne = srcTokenReal < dstTokenReal; try IUniswapV3Pool(pool).swap( address(this), // address(0) might cause issues with some tokens zeroForOne, amount.toInt256(), zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1, abi.encodePacked(srcTokenReal, dstTokenReal, pool, false) ) {} catch (bytes memory reason) { return parseRevertReason(reason); } }",
        "labels": [
            "SlowMist",
            "Kayak-UniswapV3-Contract",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "External dependency changes may cause logic failure",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Kayak-UniswapV3-Contract.pdf",
        "body": "In the KayakSwapQuoter contract, the parseRevertReason function can parse the error information returned by UniswapV3Pool. If the Uniswap V3 contract interface or error return format changes, it may cause errors in error message parsing. contracts/swaprouter/KayakSwapQuoter.sol#L133-L142 function parseRevertReason(bytes memory reason) private pure returns (uint256) { if (reason.length != 32) { if (reason.length < 68) revert(\"Unexpected error\"); assembly { reason := add(reason, 0x04) } revert(abi.decode(reason, (string))); } return abi.decode(reason, (uint256)); }",
        "labels": [
            "SlowMist",
            "Kayak-UniswapV3-Contract",
            "Type: Others",
            "Severity: Information"
        ]
    },
    {
        "title": "Returns incorrect swap result",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Kayak-UniswapV3-Contract.pdf",
        "body": "In the KayakSwapQuoter contract, the getReturnStableSwap function and getReturnUniswapV3 function do not verify whether the pool contract is the correct address. If the user passes in a malicious contract address, an incorrect exchange result may be returned. contracts/swaprouter/KayakSwapQuoter.sol#L87-L103, L105-L130 function getReturnStableSwap( address srcToken, address dstToken, address pool, uint256 amount ) public view returns (uint256 returnAmount) { address[] memory tokens = new address[](3); uint256 n_coins = IStableSwap(pool).N_COINS(); tokens[0] = IStableSwap(pool).coins(uint256(0)); tokens[1] = IStableSwap(pool).coins(uint256(1)); if (n_coins == 3) { tokens[2] = IStableSwap(pool).coins(uint256(2)); } uint256 i = (srcToken == tokens[0] ? 1 : 0) + (srcToken == tokens[1] ? 2 : 0) + (srcToken == tokens[2] ? 3 : 0); uint256 j = (dstToken == tokens[0] ? 1 : 0) + (dstToken == tokens[1] ? 2 : 0) + (dstToken == tokens[2] ? 3 : 0); return IStableSwap(pool).get_dy(i - 1, j - 1, amount); } function getReturnUniswapV3( address srcToken, address dstToken, address pool, uint256 amount ) public returns (uint256 returnAmount) { if (IERC20(srcToken).isETH()) { weth.deposit{ value: amount }(); } address srcTokenReal = IERC20(srcToken).isETH() ? address(weth) : srcToken; address dstTokenReal = IERC20(dstToken).isETH() ? address(weth) : dstToken; bool zeroForOne = srcTokenReal < dstTokenReal; try IUniswapV3Pool(pool).swap( address(this), // address(0) might cause issues with some tokens zeroForOne, amount.toInt256(), zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1, abi.encodePacked(srcTokenReal, dstTokenReal, pool, false) ) {} catch (bytes memory reason) { return parseRevertReason(reason); } }",
        "labels": [
            "SlowMist",
            "Kayak-UniswapV3-Contract",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Kayak-UniswapV3-Contract.pdf",
        "body": "In the UniswapV3Factory contract, the owner role can transfer owner permissions and set feeAmountTickSpacing mapping. contracts/core/UniswapV3Factory.sol#L54-L58, L61-L72 function setOwner function enableFeeAmount",
        "labels": [
            "SlowMist",
            "Kayak-UniswapV3-Contract",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Redundant authorization operations",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Kayak-UniswapV3-Contract.pdf",
        "body": "In the KayakSwapRouter contract, the _swapOnV3ExactIn function calls the uniApprove function to authorize the pool contract, but in the uniswapV3SwapCallback function, the uniTransfer function is called to pay the tokenIn token, and the uniTransferFrom function is not used, so the authorized amount will continue to exist and accumulate. If the pool contract is a malicious contract, this authorization operation may cause the assets in the KayakSwapRouter contract to be transferred away. contracts/swaprouter/KayakSwapRouter.sol#L162-L185, L187-L197 function _swapOnV3ExactIn(address srcToken, address dstToken, address pool, uint256 amount) internal { ``` IERC20(srcTokenReal).uniApprove(payable(pool), amount); ``` } function uniswapV3SwapCallback(int256 amount0Delta, int256 amount1Delta, bytes calldata _data) external { ``` IERC20(tokenIn).uniTransfer(msg.sender, amountToPay); }",
        "labels": [
            "SlowMist",
            "Kayak-UniswapV3-Contract",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Potential denial of service risk due to gulp operations",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase5_en-us.pdf",
        "body": "In the Actions contract, when the user performs the autoJoinSmartPool operation, the number of shares the user can obtain will be calculated through the _calculateShare function, and minPoolAmountOut will be checked at the end. The _calculateShare function obtains the number of tokens recorded in the pool through bPool's getBalance when calculating the share, but unfortunately any user can update this parameter through bPool's gulp function. Therefore, when an ordinary user performs an autoJoinSmartPool operation, a malicious user directly transfers funds to bPool and calls the gulp function to update the token balance recorded in the pool. At this time, ordinary users will not be able to successfully add liquidity due to the minPoolAmountOut check. If the minPoolAmountOut value passed in by an ordinary user is 0, it may cause an interest rate ination attack. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase5",
            "Type: Denial of Service Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Incorrect event logging",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase5_en-us.pdf",
        "body": "In the CRP contract, the createPool function adds the creator parameter as the real creator of the pool. However, the corresponding events were not modied accordingly. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase5",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Incorrect WETH address",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase5_en-us.pdf",
        "body": "The WETH address constant is hard-coded in the Actions contract, but this address is an EOA address on the Ethereum mainnet and is not the correct WETH address. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase5",
            "Type: Others",
            "Severity: High"
        ]
    },
    {
        "title": "Incorrect poolTokens check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase5_en-us.pdf",
        "body": "In the autoJoinSmartPool function of the Actions contract, it checks the tokens deposited by the user through poolTokens[i] == handleToken , but handleToken has been replaced by the issueToken parameter during the native token checking phase. Therefore, the poolTokens[i] == handleToken check is not accurate. If handleToken is WETH, it will cause an error in the _makeSwap operation. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase5",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Redundant STBT token check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase5_en-us.pdf",
        "body": "In the autoJoinSmartPool and _exit functions of the Actions contract, when making a token transfer, it will be checked whether the transferred token is an STBT token. But in fact, the protocol does not allow deposits of STBT tokens, and STBT tokens will also be converted into stablecoins after the ETF expires. Therefore, theoretically, there will be no STBT tokens in the contract, so the STBT token check is redundant. . ",
        "labels": [
            "SlowMist",
            "DeSyn Phase5",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Potential risk of slot conict",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase5_en-us.pdf",
        "body": "In this protocol iteration, both SmartPoolManager and Actions contracts have changed their storage structures. If these contracts use an upgradeable model, and upgrading the contract directly on the original basis may lead to contract storage slot conicts. In fact, the Actions contract is an upgradeable contract, so special attention should be paid to such risks.",
        "labels": [
            "SlowMist",
            "DeSyn Phase5",
            "Type: Variable Coverage Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of event forgery",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase5_en-us.pdf",
        "body": "In the CRP contract, the exitPool function adds a user parameter to record the real caller when the user exits through the Actions contract. However, users can also exit by calling the exitPool function of the CRP contract. They can pass in any user parameter to make the LogExit event record an incorrect value. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase5",
            "Type: Malicious Event Log Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Potential risk of denial of service due to large CRPFactory array",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase5_en-us.pdf",
        "body": "In the CRPFactory contract, when the Blabs role performs addCRPFactory and removeCRPFactory operations, it will use a for loop to traverse the entire CRPFactorys array. If the array length is too large, it will lead to DoS risks. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase5",
            "Type: Denial of Service Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Potential risk of endless loop",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase5_en-us.pdf",
        "body": "In the CRPFactory contract, the isCrp function is used to check whether the address passed by the user is a CRP contract. If not, the CRPFactorys array will be circulated and the isCrp function of other CRPFactory will be called to check. However, it should be noted that if the Blabs role adds this contract address to the CRPFactorys array, the user will fall into an innite loop error when querying a CRP address that is not recorded in this contract through the isCrp function. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase5",
            "Type: Denial of Service Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Debug functions buer oset stack overow",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ccToken.pdf",
        "body": "There is no check to see if oset exceeds the size of debug_buer. If data_len is too large, it may cause a stack overow. contracts/c/common.h static void debug_print_data_impl(const char *prefix, const uint8_t *data, uint32_t data_len) { int offset = 0; offset += sprintf_(debug_buffer, \"%s\", prefix); for (size_t i = 0; i < data_len; i++) { offset += sprintf_(debug_buffer + offset, \"%02x\", data[i]); } debug_buffer[offset] = '\\0'; ckb_debug(debug_buffer); } static void debug_print_int_impl(const char *prefix, int ret) { int offset = 0; offset += sprintf_(debug_buffer, \"%s(%d)\", prefix, ret); debug_buffer[offset] = '\\0'; ckb_debug(debug_buffer); } static void debug_print_string_impl(const char *prefix, const uint8_t *data, uint32_t data_len) { int offset = 0; offset += sprintf_(debug_buffer, \"%s\", prefix); for (size_t i = 0; i < data_len; i++) { offset += sprintf_(debug_buffer + offset, \"%c\", data[i]); } debug_buffer[offset] = '\\0'; ckb_debug(debug_buffer); }",
        "labels": [
            "SlowMist",
            "ccToken",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "char2hex Logic error",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ccToken.pdf",
        "body": "This function assumes that the input hexChar is a valid hexadecimal character, but does not check if the character is in the valid range. If the input hexChar is an illegal character, the result of the calculation will be wrong. For example, entering 'G' or 'H' will result in undesired output. Also, the function only handles hexadecimal characters with uppercase letters ('A' through 'F'), but hexadecimal characters also include lowercase letters ('a' through 'f'). contracts/c/utils.h char char2hex(char hexChar) { char tmp; if(hexChar<='9') { tmp = hexChar-'0'; } else if(hexChar<='F') { tmp = hexChar-'7'; } else { tmp = hexChar-'W'; } return tmp; }",
        "labels": [
            "SlowMist",
            "ccToken",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ccToken.pdf",
        "body": "Custodian has the following unlock permissions: update_merchants confirm_mint reject_mint confirm_burn reject_burn Merchant has the following unlock permissions: update_merchants Request mint Request burn",
        "labels": [
            "SlowMist",
            "ccToken",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "simple_udt should check the size of the input and output amounts",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ccToken.pdf",
        "body": "simple_udt should check the size of the input and output amounts. contracts/c/tx_parser.h int simple_udt(uint128_t *ia, uint128_t *oa) { //... *ia = input_amount; *oa = output_amount; return CKB_SUCCESS; }",
        "labels": [
            "SlowMist",
            "ccToken",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Missing array bounds checking",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ccToken.pdf",
        "body": "Accessing data[0] and data[1...] without boundary checking may result in an array out-of-bounds error. without boundary checking may result in an array out-of-bounds error. libs/core/src/data_parser/cong_cell.rs pub fn parse(data: Vec<u8>) -> Result<(u8, Vec<(ConfigKey, Vec<u8>)>), CoreError> { let version = data[0]; let mut configs = vec![]; match version { 0 => { let config_mol = BytesVec::from_compatible_slice(&data[1..]).map_err(|_| CoreError::ParseCellDataFailed { //... } The code does not check if the input args and data are of sucient length. Direct access to args[0] and data[0] may result in out-of-bounds access, which can trigger a crash. libs/core/src/data_parser/governance_member_cell.rs pub fn parse_type_args(args: Vec<u8>) -> Result<(GovernanceMemberRole, Vec<u8>), CoreError> { let role = GovernanceMemberRole::try_from(args[0]).map_err(|_| CoreError::ParseCellDataFailed { cell_name: String::from(\"GovernanceMemberCell\"), msg: format!(\"Unknown role value {}\", args[0]), })?; let cell_id = (&args[1..]).to_vec(); //... Ok((role, cell_id)) } pub fn parse_data(data: Vec<u8>) -> Result<(u8, GovernanceMembers), CoreError> { let version = data[0]; //... GovernanceMembers::from_compatible_slice(&data[1..]).map_err(|_| CoreError::ParseCellDataFailed { //... } libs/core/src/data_parser/tick_cell.rs pub fn parse_data(data: Vec<u8>) -> Result<(u8, Tick), CoreError> { let version = data[0]; //... tick = Tick::from_compatible_slice(&data[1..]).map_err(|_| CoreError::ParseCellDataFailed { //... Ok((version, tick)) } libs/core/src/veriers/permission.rs pub fn verify_input_has_deploy_lock(index: usize) -> Result<(), CoreError> { //... cc_assert!(cells[0] == index, CoreError::DeployLockIsRequired { index }); Ok(()) } pub fn verify_input_has_owner_lock(index: usize) -> Result<(), CoreError> { //... cc_assert!(cells[0] == index, CoreError::OwnerLockIsRequired { index }); Ok(()) }",
        "labels": [
            "SlowMist",
            "ccToken",
            "Type: Others",
            "Severity: Low"
        ]
    },
    {
        "title": "Avoid unnecessary memory copies",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ccToken.pdf",
        "body": "Function arguments can accept slice references (&[u8]) instead of ownership (Vec), which avoids unnecessary memory copies. libs/core/src/data_parser/cong_cell.rs pub fn parse(data: Vec<u8>) -> Result<(u8, Vec<(ConfigKey, Vec<u8>)>), CoreError> { //... } libs/core/src/data_parser/governance_member_cell.rs pub fn parse_type_args(args: Vec<u8>) -> Result<(GovernanceMemberRole, Vec<u8>), CoreError> { //... } pub fn parse_data(data: Vec<u8>) -> Result<(u8, GovernanceMembers), CoreError> { //... } libs/core/src/data_parser/tick_cell.rs pub fn parse_data(data: Vec<u8>) -> Result<(u8, Tick), CoreError> { //... } libs/core/src/util.rs pub fn get_tx_action() -> Result<Action, CoreError> { //... let version_byte = witness[0]; //... let action_bytes = &witness[1..]; //... }",
        "labels": [
            "SlowMist",
            "ccToken",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Ambiguous error handling",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ccToken.pdf",
        "body": "Use the warn! log to record potential parsing errors, which is not uncommon in smart contracts, without explicitly indicating whether the error should be interrupted or accepted. libs/core/src/data_parser/cong_cell.rs pub fn parse(data: Vec<u8>) -> Result<(u8, Vec<(ConfigKey, Vec<u8>)>), CoreError> { //... let key = match ConfigKey::try_from(u32::from_le_bytes(key_bytes)) { Ok(key) => key, Err(_) => { warn!( \"[{}] Parse [0..4]({}) to config key failed, the key is removed or not defined.\", i, hex_string(key_bytes.as_ref()) ); continue; } }; //... } Ok((version, configs)) }",
        "labels": [
            "SlowMist",
            "ccToken",
            "Type: Others",
            "Severity: Low"
        ]
    },
    {
        "title": "Missing system shutdown status check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ccToken.pdf",
        "body": "When the system is processing the shutdown state, all other features except conguration should be disabled, including disabling the following features: init_governance update_owner update_custodians update_merchants confirm_mint reject_mint confirm_burn reject_burn Currently only the request function request for token minting and destruction checks if the system is disabled.",
        "labels": [
            "SlowMist",
            "ccToken",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "It is recommended to use the encapsulated method",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ccToken.pdf",
        "body": "A wrapped lock validation function already exists, and reusing it improves the readability of the code. contracts/cong-cell-type/src/entry.rs fn verify_output_lock(index: usize) -> Result<(), Box<dyn AsI8>> { //... lock.as_slice() == owner_lock.as_slice(), //... Ok(()) }",
        "labels": [
            "SlowMist",
            "ccToken",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap_v3_en-us.pdf",
        "body": "In the StableSwapRouter, the Owner role can set the stableSwapFactory to any address. If a fake stableSwapFactory address is passed in, the SmartRouterHelper will obtain a malicious transaction pair from the getStableInfo function, resulting in loss of funds. And this function is also missing the event log and 0 address check. ",
        "labels": [
            "SlowMist",
            "PancakeSwap_v3",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Token compatibility issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap_v3_en-us.pdf",
        "body": "1.In the StableSwapRouter, the exactOutputStableSwap and exactInputStableSwap functions will call swap to transfer by the pay function via the input data amountIn and the input data is recorded directly into it. In the swap function, although amountIn is re-recorded. However, the amountIn_ data is still recorded in the _swap function when the exchange is performed in the swapContract of the transferring third-party contract. If the third-party contract token balance is used to directly participate in the calculation, the contract cannot be compatible with the rebase token. ",
        "labels": [
            "SlowMist",
            "PancakeSwap_v3",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing event records",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap_v3_en-us.pdf",
        "body": "1.In the PancakeV3FactoryOwner contract, the owner role can set the lmPoolDeployer address, but there is no event log and 0 address check. ",
        "labels": [
            "SlowMist",
            "PancakeSwap_v3",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of initial operation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap_v3_en-us.pdf",
        "body": "In the PancakeV3Pool contract, by calling the initialize function to initialize the contracts, there is a potential issue that malicious attackers preemptively call the initialize function to initialize and there is no access control verication for the initialize functions ",
        "labels": [
            "SlowMist",
            "PancakeSwap_v3",
            "Type: Race Conditions Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of denial of service",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap_v3_en-us.pdf",
        "body": "In the UniswapV3Pool contract, the swap function can be disrupted by forcing the loop to go through too many operations, potentially trapping the swap due to a lack of gas. ",
        "labels": [
            "SlowMist",
            "PancakeSwap_v3",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of replay attack",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Coordinape protocol_en-us.pdf",
        "body": "In the ApeToken contract, DOMAIN_SEPARATOR is dened when the contract is initialized, but it is not reimplemented when DOMAIN_SEPARATOR is used in the permit function. So the DOMAIN_SEPARATOR contains 15 the chainId and is dened at contract deployment instead of reconstructed for every signature, there is a risk of possible replay attacks between chains in the event of a future chain split. coordinape-protocol/contracts/ApeProtocol/token/ApeToken.sol#L18 constructor() { uint chainId = block.chainid; DOMAIN_SEPARATOR = keccak256( abi.encode( keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'), keccak256(bytes(\"coordinape.com\")), keccak256(bytes('1')), chainId, address(this) ) ); } coordinape-protocol/contracts/ApeProtocol/token/ApeToken.sol#L42 function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public { require(block.timestamp <= deadline, \"COToken: expired deadline\"); require(owner != address(0), \"COToken: owner can't be ZERO address \"); bytes32 digest = keccak256( abi.encode( DOMAIN_SEPARATOR, '\\x19\\x01', keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline)) ) ); address signer = ECDSA.recover(digest, v, r, s); require(signer == owner, \"COToken: invalid signature\"); 16 _approve(owner, spender, value); }",
        "labels": [
            "SlowMist",
            "Coordinape protocol",
            "Type: Replay Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing event records",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Coordinape protocol_en-us.pdf",
        "body": "Missing event records are not conducive to the review of community users. coordinape-protocol/contracts/ApeProtocol/token/TokenAccessControl.sol#L32-47 function disableAllowlist() external onlyOwner { require(!allowlistDisabled, \"AccessControl: Allowlist already disabled\"); } allowlistDisabled = true; function changePauseStatus(bool _status) external onlyOwner { require(!foreverUnpaused, \"AccessControl: Contract is unpaused forever\"); } paused = _status; function disablePausingForever() external onlyOwner { require(!foreverUnpaused, \"AccessControl: Contract is unpaused forever\"); } foreverUnpaused = true; paused = false; 17 coordinape-protocol/contracts/ApeProtocol/token/TokenAccessControl.sol#L81-84 function disableMintingForever() external onlyOwner { require(!mintingDisabled, \"AccessControl: Contract cannot mint anymore\"); } mintingDisabled = true; coordinape-protocol/contracts/ApeProtocol/wrapper/beacon/ApeBeacon.sol#L23-28 function transferProxyOwnership(address _newOwner) external { require(msg.sender == proxyOwner()); assembly { sstore(_OWNER_SLOT, _newOwner) } } coordinape-protocol/contracts/ApeProtocol/wrapper/beacon/ApeRegistryBeacon.sol#37-L40 function pushNewImplementation(address _newImplementation) public itself { require(Address.isContract(_newImplementation), \"ApeRegistryBeacon: implementaion is not a contract\"); deployments[++deploymentCount] = _newImplementation; } coordinape-protocol/contracts/ApeProtocol/ApeRegistry.sol#L17-L35 function setFeeRegistry(address _registry) external itself { feeRegistry = _registry; } function setRouter(address _router) external itself { router = _router; } function setDistributor(address _distributor) external itself { distributor = _distributor; } 18 function setFactory(address _factory) external itself { factory = _factory; } function setTreasury(address _treasury) external itself { treasury = _treasury; } coordinape-protocol/contracts/ApeProtocol/ApeRouter.sol#L87-L89 function setRegistry(address _registry) external itself { yearnRegistry = _registry; }",
        "labels": [
            "SlowMist",
            "Coordinape protocol",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Coding optimization",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Coordinape protocol_en-us.pdf",
        "body": "getVariableFee function does not modify contract data, but does not use view. coordinape-protocol/contracts/ApeProtocol/FeeRegistry.sol#L24 function getVariableFee(uint256 _yield, uint256 _tapTotal) external returns(uint256 variableFee) { if (!on) return 0; uint256 yieldRatio = _yield * 1000 / _tapTotal; uint256 baseFee = 100; if (yieldRatio >= 900) variableFee = baseFee; // 1% @ 90% yield ratio else if (yieldRatio >= 800) variableFee = baseFee + 25; // 1.25% @ 80% yield ratio 19 else if (yieldRatio >= 700) variableFee = baseFee + 50; // 1.50% @ 70% yield ratio else if (yieldRatio >= 600) variableFee = baseFee + 75; // 1.75% @ 60% yield ratio else if (yieldRatio >= 500) variableFee = baseFee + 100; // 2.00% @ 80% yield ratio else if (yieldRatio >= 400) variableFee = baseFee + 125; // 2.25% @ 80% yield ratio else if (yieldRatio >= 300) variableFee = baseFee + 150; // 2.50% @ 80% yield ratio else if (yieldRatio >= 200) variableFee = baseFee + 175; // 2.75% @ 80% yield ratio else if (yieldRatio >= 100) variableFee = baseFee + 200; // 3.00% @ 80% yield ratio else } variableFee = baseFee + 250; // 3.50% @ 0% yield ratio",
        "labels": [
            "SlowMist",
            "Coordinape protocol",
            "Type: Authority Control Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Business logic is not clear",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Coordinape protocol_en-us.pdf",
        "body": "The _issueInvite function will execute the mint logic, but the burn is annotated in _revokeInvite, the business logic is not clear. coordinape-protocol/contracts/circles_obsolete/CoordinapeCircle.sol#L158-L175 function _issueInvite(address recipient, uint8 role) internal { Counters.increment(_inviteIds); uint256 tokenId = Counters.current(_inviteIds); _mint(recipient, tokenId); _roles[tokenId] = role; 20 _invites[recipient] = tokenId; _vouches[recipient] = 0; emit InviteIssued(recipient, role); } function _revokeInvite(address recipient) internal { uint256 tokenId = _invites[recipient]; _inactiveMembers.increment(); //_burn(tokenId); _roles[tokenId] = 0; _invites[recipient] = 0; emit InviteRevoked(recipient, 0); } _epochEnds is never initialized, and used in _epochInProgress function. coordinape-protocol/contracts/circles_obsolete/CoordinapeCircle.sol#L155 function _epochInProgress() internal view returns (bool) { uint256 epochId = Counters.current(_epochIds); // return epochId > 0 && !CoordinapeEpoch(_epochs[epochId]).ended(); return epochId > 0 && block.number < _epochEnds[epochId]; } _epochState is never initialized. and it is used in state function. coordinape-protocol/contracts/circles_obsolete/CoordinapeCircle.sol#L105 function state(uint256 _epoch) external view returns (uint8) { return _epochState[_epoch]; } The address passed in by the _migrate function is address(this), which means migrating to the address(this) contract, the logic here is not clear. coordinape-protocol/contracts/ApeProtocol/wrapper/beacon/ApeVault.sol#L166-L169 21 function apeMigrate() external onlyOwner returns(uint256 migrated){ migrated = _migrate(address(this)); vault = VaultAPI(registry.latestVault(address(token))); } migrated = _deposit(address(this), account, withdrawn, false); account is address(this), the logic here is wrong coordinape-protocol/contracts/ApeProtocol/wrapper/beacon/BaseWrapperImplementation.sol#L387-L427 function _migrate(address account) internal returns (uint256) { return _migrate(account, MIGRATE_EVERYTHING); } function _migrate(address account, uint256 amount) internal returns (uint256) { // NOTE: In practice, it was discovered that <50 was the maximum we've see for this variance return _migrate(account, amount, 0); } function _migrate( address account, uint256 amount, uint256 maxMigrationLoss ) internal returns (uint256 migrated) { VaultAPI _bestVault = bestVault(); // NOTE: Only override if we aren't migrating everything uint256 _depositLimit = _bestVault.depositLimit(); uint256 _totalAssets = _bestVault.totalAssets(); if (_depositLimit <= _totalAssets) return 0; // Nothing to migrate (not a failure) uint256 _amount = amount; if (_depositLimit < UNCAPPED_DEPOSITS && _amount < WITHDRAW_EVERYTHING) { // Can only deposit up to this amount uint256 _depositLeft = _depositLimit.sub(_totalAssets); if (_amount > _depositLeft) _amount = _depositLeft; } 22 if (_amount > 0) { // NOTE: `false` = don't withdraw from `_bestVault` uint256 withdrawn = _withdraw(account, address(this), _amount, false); if (withdrawn == 0) return 0; // Nothing to migrate (not a failure) // NOTE: `false` = don't do `transferFrom` because it's already local migrated = _deposit(address(this), account, withdrawn, false); // NOTE: Due to the precision loss of certain calculations, there is a small inefficency // on how migrations are calculated, and this could lead to a DoS issue. Hence, this // value is made to be configurable to allow the user to specify how much is acceptable require(withdrawn.sub(migrated) <= maxMigrationLoss); } // else: nothing to migrate! (not a failure) } The return value of decimals is 0, and developers need to conrm the business logic here. coordinape-protocol/contracts/circles_obsolete/CoordinapeEpoch.sol#L143-L145 function decimals() public pure override returns (uint8) { return 0; }",
        "labels": [
            "SlowMist",
            "Coordinape protocol",
            "Type: Others",
            "Severity: High"
        ]
    },
    {
        "title": "Coding standards issues 23",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Coordinape protocol_en-us.pdf",
        "body": "Executed rst _call(id, _target, _data); and then executed timestamps[id] = _DONE_TIMESTAMP; , which does not meet the specication(Checks-Eects-Interactions). coordinape-protocol/contracts/ApeProtocol/TimeLock.sol#L72-L73 function execute(address _target, bytes calldata _data, bytes32 _predecessor, bytes32 _salt, uint256 _delay) external onlyOwner { bytes32 id = hashOperation(_target, _data, _predecessor, _salt); require(isReadyCall(id), \"TimeLock: Not ready for execution or executed\"); require(_predecessor == bytes32(0) || isDoneCall(_predecessor), \"TimeLock: Predecessor call not executed\"); _call(id, _target, _data); timestamps[id] = _DONE_TIMESTAMP; } function _call( bytes32 id, address target, bytes calldata data ) internal { (bool success, ) = target.call(data); require(success, \"Timelock: underlying transaction reverted\"); emit CallExecuted(id, target, data); }",
        "labels": [
            "SlowMist",
            "Coordinape protocol",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "The external call does not judge the return value 24",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Coordinape protocol_en-us.pdf",
        "body": "The external call in the _withdraw function does not evaluate the return value E.g vaults[id].transferFrom , vault.transfer , IERC20(_token).transfer If the transferFrom function and transfer of the externally called token contract return false, the code logic will be wrong. coordinape-protocol/contracts/ApeProtocol/wrapper/beacon/BaseWrapperImplementation.sol#L353-L362 function _withdraw( address sender, address receiver, uint256 amount, // if `MAX_UINT256`, just withdraw everything bool withdrawFromBest // If true, also withdraw from `_bestVault` ) internal returns (uint256 withdrawn) { VaultAPI _bestVault = bestVault(); VaultAPI[] memory vaults = allVaults(); _updateVaultCache(vaults); // NOTE: This loop will attempt to withdraw from each Vault in `allVaults` that `sender` // is deposited in, up to `amount` tokens. The withdraw action can be expensive, // so it if there is a denial of service issue in withdrawing, the downstream usage // of this wrapper contract must give an alternative method of withdrawing using // this function so that `amount` is less than the full amount requested to withdraw // (e.g. \"piece-wise withdrawals\"), leading to less loop iterations such that the // DoS issue is mitigated (at a tradeoff of requiring more txns from the end user). for (uint256 id = 0; id < vaults.length; id++) { if (!withdrawFromBest && vaults[id] == _bestVault) { continue; // Don't withdraw from the best } 25 // Start with the total shares that `sender` has uint256 availableShares = vaults[id].balanceOf(sender); // Restrict by the allowance that `sender` has to this contract // NOTE: No need for allowance check if `sender` is this contract if (sender != address(this)) { availableShares = Math.min(availableShares, vaults[id].allowance(sender, address(this))); } // Limit by maximum withdrawal size from each vault availableShares = Math.min(availableShares, vaults[id].maxAvailableShares()); if (availableShares > 0) { // Intermediate step to move shares to this contract before withdrawing // NOTE: No need for share transfer if this contract is `sender` // if (sender != address(this)) vaults[id].transferFrom(sender, address(this), availableShares); if (amount != WITHDRAW_EVERYTHING) { // Compute amount to withdraw fully to satisfy the request uint256 estimatedShares = amount .sub(withdrawn) // NOTE: Changes every iteration .mul(10**uint256(vaults[id].decimals())) .div(vaults[id].pricePerShare()); // NOTE: Every Vault is different // Limit amount to withdraw to the maximum made available to this contract // NOTE: Avoid corner case where `estimatedShares` isn't precise enough // NOTE: If `0 < estimatedShares < 1` but `availableShares > 1`, this will withdraw more than necessary if (estimatedShares > 0 && estimatedShares < availableShares) { if (sender != address(this)) vaults[id].transferFrom(sender, address(this), estimatedShares); withdrawn = withdrawn.add(vaults[id].withdraw(estimatedShares)); } else { if (sender != address(this)) vaults[id].transferFrom(sender, address(this), availableShares); 26 withdrawn = withdrawn.add(vaults[id].withdraw(availableShares)); } } else { if (sender != address(this)) vaults[id].transferFrom(sender, address(this), availableShares); withdrawn = withdrawn.add(vaults[id].withdraw()); } // Check if we have fully satisfied the request // NOTE: use `amount = WITHDRAW_EVERYTHING` for withdrawing everything if (amount <= withdrawn) break; // withdrawn as much as we needed } } // If we have extra, deposit back into `_bestVault` for `sender` // NOTE: Invariant is `withdrawn <= amount` if (withdrawn > amount && withdrawn.sub(amount) > _bestVault.pricePerShare().div(10**_bestVault.decimals())) { // Don't forget to approve the deposit if (token.allowance(address(this), address(_bestVault)) < withdrawn.sub(amount)) { token.safeApprove(address(_bestVault), UNLIMITED_APPROVAL); // Vaults are trusted } _bestVault.deposit(withdrawn.sub(amount), sender); withdrawn = amount; } // `receiver` now has `withdrawn` tokens as balance if (receiver != address(this)) token.safeTransfer(receiver, withdrawn); } coordinape-protocol/contracts/ApeProtocol/ApeDistributor.sol#L147 function tapEpochAndDistribute( address _vault, bytes32 _circle, address _token, address[] calldata _users, 27 uint256[] calldata _amounts, uint256 _amount, uint8 _tapType) external { require(_users.length == _amounts.length, \"ApeDistributor: Array lengths do not match\"); require(sum(_amounts) == _amount, \"ApeDistributor: Amount does not match sum of values\"); _tap(_vault, _circle, _token, _amount, _tapType, bytes32(type(uint256).max)); for (uint256 i = 0; i < _users.length; i++) IERC20(_token).transfer(_users[i], _amounts[i]); } coordinape-vesting-contracts/contracts/Vesting.sol#L77-L99 function fetchTokens(uint256 _amount) external onlyOwner { IERC20(co).transfer(msg.sender, _amount); } function claim(uint256 _index) external override { uint256 _now = block.timestamp; Vehicule storage vehicule = vehicules[msg.sender][_index]; uint256 upfront = _claimUpfront(vehicule); uint256 start = vehicule.start; if (start == 0) revert(\"Vesting: vehicule does not exist\"); require(_now > start, \"Vesting: cliff !started\"); uint256 end = vehicule.end; uint256 elapsed = min(end, _now) - start; uint256 maxDelta = end - start; // yield = amount * delta / vest_duration - claimed_amount uint256 yield = (vehicule.amount * elapsed / maxDelta) - vehicule.claimed; vehicule.claimed += yield; IERC20(co).transfer(msg.sender, yield + upfront); 28 emit YieldClaimed(msg.sender, yield); }",
        "labels": [
            "SlowMist",
            "Coordinape protocol",
            "Type: Unsafe External Call Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Excessive authority issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Coordinape protocol_en-us.pdf",
        "body": "Owner can transfer assets in the contract. coordinape-protocol/contracts/ApeProtocol/wrapper/beacon/ApeVault.sol#L129 function apeWithdrawSimpleToken(uint256 _amount) public onlyOwner { simpleToken.safeTransfer(msg.sender, _amount); } coordinape-protocol/contracts/ApeProtocol/wrapper/beacon/ApeVault.sol#L139 function apeWithdraw(uint256 _shareAmount, bool _underlying) external onlyOwner { uint256 underlyingAmount = shareValue(_shareAmount); require(underlyingAmount <= underlyingValue, \"underlying amount higher than vault value\"); address router = ApeRegistry(apeRegistry).router(); underlyingValue -= underlyingAmount; vault.safeTransfer(router, _shareAmount); ApeRouter(router).delegateWithdrawal(owner(), address(this), vault.token(), _shareAmount, _underlying); } 29 coordinape-protocol/contracts/ApeProtocol/wrapper/beacon/ApeVault.sol#L154 function exitVaultToken(bool _underlying) external onlyOwner { underlyingValue = 0; uint256 totalShares = vault.balanceOf(address(this)); address router = ApeRegistry(apeRegistry).router(); vault.safeTransfer(router, totalShares); ApeRouter(router).delegateWithdrawal(owner(), address(this), vault.token(), totalShares, _underlying); } Owner can transfer the tokens in the contract. coordinape-vesting-contracts/contracts/Vesting.sol#L77 function fetchTokens(uint256 _amount) external onlyOwner { IERC20(co).transfer(msg.sender, _amount); }",
        "labels": [
            "SlowMist",
            "Coordinape protocol",
            "Type: Authority Control Vulnerability",
            "Severity: High"
        ]
    },
    {
        "title": "Lack of permission checks 30",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Coordinape protocol_en-us.pdf",
        "body": "The createApeVault function does not perform permission checks. Anyone can create ApeVault. If the incoming parameters are malicious (malicious Token or incompatible Token), it will aect the funds in the project. coordinape-protocol/contracts/ApeProtocol/wrapper/beacon/ApeVaultFactory.sol#L22-L27 function createApeVault(address _token, address _simpleToken) external { bytes memory data = abi.encodeWithSignature(\"init(address,address,address,address,address)\", apeRegistry, _token, yearnRegistry, _simpleToken, msg.sender); ApeBeacon proxy = new ApeBeacon(beacon, msg.sender, data); vaultRegistry[address(proxy)] = true; emit VaultCreated(address(proxy)); }",
        "labels": [
            "SlowMist",
            "Coordinape protocol",
            "Type: Authority Control Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "4.3.1.1 Reordering attack risk",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - InsurAce_en-us.pdf",
        "body": "When the owner calls preparePaymentForPayout, it will go to uniswap to calculate the required amountIn, and then perform the swap operation according to the amountIn. There is a risk of rearrangement attacks that may cause losses in the InsurAce pool. It is recommended to check the slippage of swap. Reference https://www.odaily.com/post/5162888 https://medium.com/coinmonks/demystify-the-dark-forest-on-ethereum-sandwich-attacks-5a3ae c9fa33e  contracts/pool/StakersPool.sol function claimPayout( address _fromToken, address _paymentToken, uint256 _settleAmtPT, address _claimTo, uint256 _claimId ) external override allowedCaller { require(_fromToken == poolToken, \"CP:1\"); 23 if (_settleAmtPT == 0) { return; } uint256 temp = _getTokenforExactPaymentToken(_fromToken, _paymentToken, _settleAmtPT); uint256 amountInMax = Math.min(stakedAmount, temp.mul(11).div(10)); uint256 convertOut = _convertTokenforExactPaymentToken(_fromToken, _paymentToken, _settleAmtPT, amountInMax); stakedAmount = stakedAmount.sub(convertOut); claimPayouts.push(convertOut); claimPayoutsClaimId.push(_claimId); _transferTokenTo(_paymentToken, _settleAmtPT, _claimTo, _claimId); } function _convertTokenforExactPaymentToken( address _tokenFrom, address _tokenTo, uint256 _amountOut, uint256 _amountInMax ) private returns (uint256) { require(_tokenFrom != _tokenTo, \"CT2EPT:1\"); address[] memory path = new address[](2); uint256[] memory ret; if (_tokenFrom == Constant.ETHTOKENADDRESS) { path[0] = uniswapRouter.WETH(); path[1] = _tokenTo; ret = uniswapRouter.swapETHForExactTokens{value: _amountInMax}( _amountOut, path, address(this), block.timestamp + 120 //solhint-disable-linenot-rely-on-time ); return ret[0]; } if (_tokenTo == Constant.ETHTOKENADDRESS) { path[0] = _tokenFrom; path[1] = uniswapRouter.WETH(); IERC20Upgradeable(path[0]).approve(Constant.UNISWAPV2_ROUTER_ADDRESS, _amountInMax); ret = uniswapRouter.swapTokensForExactETH( _amountOut, _amountInMax, path, 24 address(this), block.timestamp + 120 //solhint-disable-linenot-rely-on-time ); return ret[0]; } path[0] = _tokenFrom; path[1] = _tokenTo; IERC20Upgradeable(path[0]).approve(Constant.UNISWAPV2_ROUTER_ADDRESS, _amountInMax); ret = uniswapRouter.swapTokensForExactTokens( _amountOut, _amountInMax, path, address(this), block.timestamp + 120 //solhint-disable-linenot-rely-on-time ); return ret[0]; }  contracts/pool/StakersPool.sol function _getTokenforExactPaymentToken( address _tokenFrom, address _tokenTo, uint256 _amount ) private view returns (uint256) { if (_tokenFrom == _tokenTo) { return _amount; } address[] memory path = new address[](2); if (_tokenFrom == Constant.ETHTOKENADDRESS) { path[0] = uniswapRouter.WETH(); } else { path[0] = _tokenFrom; } if (_tokenTo == Constant.ETHTOKENADDRESS) { path[1] = uniswapRouter.WETH(); } else { path[1] = _tokenTo; } 25 uint256[] memory ret = uniswapRouter.getAmountsIn(_amount, path); return ret[0]; } Fix Status: The issues has been fixed.",
        "labels": [
            "SlowMist",
            "InsurAce",
            "Severity: High"
        ]
    },
    {
        "title": "4.3.1.2 Missing permission check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - InsurAce_en-us.pdf",
        "body": "The addCoverOwner function does not perform permission checking, any user can call this function to add owner. It is recommended to add permission check code.  contracts/cover/CoverData.sol function addCoverOwner(address owner) public { require(owner != address(0), \"ACO: 1\"); require(!allCoverOwnerFlagMap[owner], \"ACO: 2\"); allCoverOwnerList.push(owner); allCoverOwnerFlagMap[owner] = true; } Fix Status: The issues has been fixed.",
        "labels": [
            "SlowMist",
            "InsurAce",
            "Severity: High"
        ]
    },
    {
        "title": "4.3.2.1 DoS issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - InsurAce_en-us.pdf",
        "body": "_getDelAccuRwAmtPS has 3 while loop nestings, which will be affected by the parameters of lastScheduleCounter, gRewardTokenRatePerStakedTokenArray, _unstakeLockArrayBlockPerStaker, and dos due to more users or more mining cycles added.  contracts/staking/ScheduledMiningProgram.sol function _getDelAccuRwAmtPS( uint256 _lastCalculatedBlockPerStaker, uint256 _stakedAmtPerStaker, uint256[] memory _unstakeLockArrayBlockPerStaker, uint256[] memory _unstakeLockArrayAmtPerStaker 26 ) private view returns (uint256) { console.log(\"getDeltaAccumulativeRewardAmtPerStaker++\"); console.log(_lastCalculatedBlockPerStaker); console.log(_stakedAmtPerStaker); console.log(_unstakeLockArrayBlockPerStaker.length); uint256 retV = 0; //gothruthelistofallschedules uint256 scheduleIndex = lastScheduleCounter; while (scheduleIndex >= 1) { if (_lastCalculatedBlockPerStaker >= endMiningBlockPerSchedule[scheduleIndex]) { break; } //narrowdownblockdelta uint256 minWall = Math.max(_lastCalculatedBlockPerStaker, startMiningBlockPerSchedule[scheduleIndex]); uint256 maxWall = Math.min(block.number, endMiningBlockPerSchedule[scheduleIndex]); console.log(\"minWall: \", minWall); console.log(\"maxWall: \", maxWall); if (minWall >= maxWall) { scheduleIndex = scheduleIndex.sub(1); continue; } uint256 rateChangeIndex = gRewardTokenRatePerStakedTokenArray.length; if (rateChangeIndex == 0) { break; } uint256 rewardAccumulatedBetweenWalls = 0; while (rateChangeIndex > 0) { uint256 blockNumber = gRewardTokenRatePerStakedTokenArray[rateChangeIndex - 1]; console.log(\"blockNumber: \", blockNumber); if (blockNumber >= maxWall) { rateChangeIndex = rateChangeIndex.sub(1); continue; } if (blockNumber >= minWall) { uint256 delta = _getDeltaAccumulativeRewardsWithFixRatePerStaker(blockNumber, maxWall, gRewardTokenRatePerStakedTokenMap[blockNumber], _stakedAmtPerStaker, _unstakeLockArrayBlockPerStaker, _unstakeLockArrayAmtPerStaker); rewardAccumulatedBetweenWalls = delta.add(rewardAccumulatedBetweenWalls); maxWall = blockNumber; rateChangeIndex = rateChangeIndex.sub(1); continue; 27 } if (blockNumber < minWall) { uint256 delta = _getDeltaAccumulativeRewardsWithFixRatePerStaker(minWall, maxWall, gRewardTokenRatePerStakedTokenMap[blockNumber], _stakedAmtPerStaker, _unstakeLockArrayBlockPerStaker, _unstakeLockArrayAmtPerStaker); rewardAccumulatedBetweenWalls = delta.add(rewardAccumulatedBetweenWalls); break; } } retV = rewardAccumulatedBetweenWalls.add(retV); scheduleIndex = scheduleIndex.sub(1); } return retV; } Fix Status: This issue has been fixed",
        "labels": [
            "SlowMist",
            "InsurAce",
            "Severity: Medium"
        ]
    },
    {
        "title": "4.3.3.1 Excessive authority issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - InsurAce_en-us.pdf",
        "body": "Admin has permission to add sender, There is a issues of excessive authority. It is recommended to set Owner to Timelock contract or governance contract.  contracts/token/INSURToken.sol function addSender(address _from) external onlyAdmin { if (1 == transferFromAllowedList[_from]) { return; } membersFrom.push(_from); transferFromAllowedList[_from] = 1; } The admin can remove the sender arbitrarily, and there is a risk of denial of service. When the admin adds too many senders, the data in the memberFrom array will be very large, so when the removeSender is removed, the depth of the for loop call will be too large, resulting in The call fails. It 28 is recommended to change memberFrom to storage in the way of mapping, and use address as the key to avoid dos caused by this type of looping to obtain data.  contracts/token/INSURToken.sol function removeSender(address _from) external onlyAdmin { uint256 arrayLength = membersFrom.length; uint256 indexToBeDeleted; bool toDelete = false; for (uint256 i = 0; i < arrayLength; i++) { if (membersFrom[i] == _from) { indexToBeDeleted = i; toDelete = true; break; } } if (!toDelete) { return; } //ifindextobedeletedisnotthelastindex,swapposition. if (indexToBeDeleted < arrayLength - 1) { membersFrom[indexToBeDeleted] = membersFrom[arrayLength - 1]; } //wecannowreducethearraylengthby1 membersFrom.pop(); delete transferFromAllowedList[_from]; } MINTER can call mint arbitrarily, and there is no upper limit for minting.  contracts/token/INSURToken.sol function mint(address to, uint256 amount) public virtual { require(hasRole(MINTER_ROLE, _msgSender()), \"ERC20PresetMinterPauser: must have minter role to mint\"); _mint(to, amount); } Fix Status: This issue has been confirmed  after communication and feedback, the minting and Owner permissions may be transferred to address(0) in the future. 29 Owner can set lpTokenMinter and lpTokenBurner. The roles of lpTokenMinter and lpTokenBurner can mint and burn the user's LP. There is a issues of excessive authority. It is recommended to set Owner to Timelock contract or governance contract. And make sure the lpTokenMinter and lpTokenBurner cannot be EOA account.  contracts/token/LPToken.sol function setup(address _lpTokenMinter, address _lpTokenBurner) external onlyOwner { require(_lpTokenMinter != address(0), \"S:1\"); lpTokenMinter = _lpTokenMinter; require(_lpTokenBurner != address(0), \"S:2\"); lpTokenBurner = _lpTokenBurner; } Fix Status: This issue has been communicated back to the project team. The project team is aware of this and will adopt governance mechanism to secure the permission when the governance module goes live.",
        "labels": [
            "SlowMist",
            "InsurAce",
            "Severity: Low"
        ]
    },
    {
        "title": "4.3.3.2 DoS issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - InsurAce_en-us.pdf",
        "body": "The incoming _callers will add data to allowedCallersArray[_callee]. If too many _callers are added at one time, it will cause Out of Gas. When there are too many data in allowedCallersArray[_callee], the setAllowdCallersPerCallee function will DoS. It is recommended to set the data Use the mapping method to store instead, avoid using the for loop to find the value.  contracts/secmatrix/SecurityMatrix.sol function addAllowdCallersPerCallee(address _callee, address[] memory _callers) external onlyOwner { require(_callers.length != 0, \"AACPC:1\"); require(allowedCallersArray[_callee].length != 0, \"AACPC:2\"); for (uint256 index = 0; index < _callers.length; index++) { console.log(\"_callers index: \", _callers[index], index); allowedCallersArray[_callee].push(_callers[index]); 30 allowedCallersMap[_callee][_callers[index]] = 1; } }  contracts/secmatrix/SecurityMatrix.sol function setAllowdCallersPerCallee(address _callee, address[] memory _callers) external onlyOwner { console.log(\"_callee: \", _callee); console.log(\"_callers.length: \", _callers.length); require(_callers.length != 0, \"SACPC:1\"); //checkifcalleeexist if (allowedCallersArray[_callee].length == 0) { //notexist,soaddcallee allowedCallees.push(_callee); } else { //ifcalleeexist,thenpurgedata for (uint256 i = 0; i < allowedCallersArray[_callee].length; i++) { delete allowedCallersMap[_callee][allowedCallersArray[_callee][i]]; } delete allowedCallersArray[_callee]; } //andoverwrite for (uint256 index = 0; index < _callers.length; index++) { console.log(\"_callers index: \", _callers[index], index); allowedCallersArray[_callee].push(_callers[index]); allowedCallersMap[_callee][_callers[index]] = 1; } } Fix Status: This issue has been communicated back to project team. The project team is aware of this issue and the method will only be used by admin when setting up security matrix. The setAllowdCallersPerCallee method will be used to create security matrix entries, and the addAllowdCallersPerCallee method will be used to add delta matrix if needed.",
        "labels": [
            "SlowMist",
            "InsurAce",
            "Severity: Low"
        ]
    },
    {
        "title": "4.3.3.3 Repeatable call risk",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - InsurAce_en-us.pdf",
        "body": "If Owner call setupVestors function multiple times, there will be duplicate vestors in the vestor 31 array.When the setupVestors is called multiple times, if the vestor calls withdrawRewardPV intentionally or unintentionally during the calling process, initRewardPV and insurVestingTotalPV may get unexpected values. If setupVestors can be called multiple times, then when the owner is called, the vestor also calls withdrawRewardPV. In this case, the gas price of calling withdrawRewardPV is higher than that of calling setupVestors. Will execute withdrawRewardPV first, and then execute setupVestors, the data will appear unexpected. Competitive conditions similar to approve.  contracts/fixedvesting/FixedVesting.sol function setupVestors( address[] memory _vestors, uint256[] memory _vestingRewardPV, uint256[] memory _initRewardPV ) external onlyOwner { require(_vestors.length == _vestingRewardPV.length, \"AV:1\"); require(_initRewardPV.length == _vestingRewardPV.length, \"AV:2\"); for (uint256 i = 0; i < _vestors.length; i++) { address vestor = _vestors[i]; vestors.push(vestor); initRewardPV[vestor] = _initRewardPV[i]; insurVestingTotalPV[vestor] = _vestingRewardPV[i]; } } Fix Status: This issue has been fixed.",
        "labels": [
            "SlowMist",
            "InsurAce",
            "Severity: Low"
        ]
    },
    {
        "title": "4.3.3.4 Overflow risk",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - InsurAce_en-us.pdf",
        "body": "safemath should be used to calculate the length of the array to avoid overflow issues: if Currency is not added, the removal may cause overflow issues.  contracts/cover/CoverConfig.sol 32 function removeCurrency(address currency) external allowedCaller { require(currency != address(0), \"RC: 1\"); uint256 arrayLength = currencyValidAddressArray.length; uint256 indexToBeDeleted; bool toDelete = false; for (uint256 i = 0; i < arrayLength; i++) { if (currencyValidAddressArray[i] == currency) { indexToBeDeleted = i; toDelete = true; break; } } if (!toDelete) { require(toDelete, \"RC: 1\"); } //ifindextobedeletedisnotthelastindex,swapposition. if (indexToBeDeleted < arrayLength - 1) { currencyValidAddressArray[indexToBeDeleted] = currencyValidAddressArray[arrayLength - 1]; } //wecannowreducethearraylengthby1 currencyValidAddressArray.pop(); delete currencyValidAddressMap[currency]; } Fix Status: This issue has been fixed.",
        "labels": [
            "SlowMist",
            "InsurAce",
            "Severity: Low"
        ]
    },
    {
        "title": "4.3.3.5 FlashLoan attack risk",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - InsurAce_en-us.pdf",
        "body": "Unstake is judged by >= when there are already voting tasks. If claimsAssessorMinUnstakeTime is 0, then there will be a issue of using flashloan to vote.  contracts/claim/Claim.sol function unstake(address insurTokenAddress, uint256 insurAmount) external payable whenNotPaused nonReentrant { require(insurTokenAddress != address(0), \"USTK: 1\"); address payable assessor = _msgSender(); ClaimReward(crw).recalculateAssessor(assessor); bool canUnstake = false; 33 uint256 latestVoteTimestamp = ClaimAssessor(asr).getLatestVoteTimestamp(assessor); if (latestVoteTimestamp == 0) { canUnstake = true; } else { if ( block.timestamp >= ClaimAssessor(asr).getVoteStakePeriodEndTime(assessor) //solhint-disable-line not-rely-on-time canUnstake = true; ) { } } require(canUnstake, \"USTK: 2\"); require(insurAmount <= ClaimAssessor(asr).getNumOfVotes(assessor), \"USTK: 3\"); require(IERC20Upgradeable(insurTokenAddress).balanceOf(address(this)) >= insurAmount, \"USTK: 4\"); ClaimAssessor(asr).decreaseVotes(assessor, insurAmount); IERC20Upgradeable(insurTokenAddress).safeTransfer(assessor, insurAmount); } Fix Status: This issue has been fixed.",
        "labels": [
            "SlowMist",
            "InsurAce",
            "Severity: Low"
        ]
    },
    {
        "title": "4.3.4.1 Token compatibility risk",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - InsurAce_en-us.pdf",
        "body": "IERC20Upgradeable(stakedToken).safeTransferFrom(_msgSender(), address(this), _amount); The transfer operation of an external token is adopted. It is recommended to pay attention to the compatibility of the project and the token when adding a new token, such as: token return Value issues, fake token recharge issues, compatibility issues with deflationary tokens, etc.  contracts/staking/StakeOps.sol function stakeTokens(uint256 _amount, address _token) external payable whenNotPaused nonReentrant { require(IMiningProgram(iMiningProgram).canStake(_amount), \"ST:1\"); address stakedToken = StakersData(stakerDataAddr).stakedToken(); require(_token == stakedToken, \"ST:2\"); 34 if (stakedToken == Constant.ETHTOKENADDRESS) { require(_amount <= msg.value, \"ST:3\"); } else { require(IERC20Upgradeable(stakedToken).balanceOf(_msgSender()) >= _amount, \"ST:4\"); uint256 allowanceAmt = IERC20Upgradeable(stakedToken).allowance(_msgSender(), address(this)); require(allowanceAmt >= _amount, \"ST:5\"); } _reCalcPerStaker(); if (stakedToken != Constant.ETHTOKENADDRESS) { IERC20Upgradeable(stakedToken).safeTransferFrom(_msgSender(), address(this), _amount); } //dispatchtokentopool if (stakedToken == Constant.ETHTOKENADDRESS) { IStakersPool(iStakersPool).addStkAmount{value: _amount}(stakedToken, _amount); } else { IERC20Upgradeable(stakedToken).safeTransfer(iStakersPool, _amount); Fix Status: This issue has been communicated back to project team. The project team is aware of this and has already performed compatibility checks on the staking tokens, such as ETH, WETH, USDC, USDT, DAI, and INSUR, which are all compatible with the relevant standards.",
        "labels": [
            "SlowMist",
            "InsurAce",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.3.4.2 Event log is missing",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - InsurAce_en-us.pdf",
        "body": "It is recommended to add an event to record securityMatrix changes, applicable to all set functions. function setup(address _securityMatrix) external onlyOwner { require(_securityMatrix != address(0), \"S:1\"); securityMatrix = _securityMatrix; } Fix Status: This issue has been communicated back to project team. The project team will add more event logs in their development, including not limited to \"setup\".",
        "labels": [
            "SlowMist",
            "InsurAce",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.3.4.3 Redundant code",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - InsurAce_en-us.pdf",
        "body": "The `if (!toDelete) {require(toDelete, \"RC: 1\"); }` code can be simplified to `require(toDelete, \"RC: 1\");`. 35  contracts/cover/CoverConfig.sol function removeCurrency(address currency) external allowedCaller { require(currency != address(0), \"RC: 1\"); uint256 arrayLength = currencyValidAddressArray.length; uint256 indexToBeDeleted; bool toDelete = false; for (uint256 i = 0; i < arrayLength; i++) { if (currencyValidAddressArray[i] == currency) { indexToBeDeleted = i; toDelete = true; break; } } if (!toDelete) { require(toDelete, \"RC: 1\"); } //ifindextobedeletedisnotthelastindex,swapposition. if (indexToBeDeleted < arrayLength - 1) { currencyValidAddressArray[indexToBeDeleted] = currencyValidAddressArray[arrayLength - 1]; } //wecannowreducethearraylengthby1 currencyValidAddressArray.pop(); delete currencyValidAddressMap[currency]; } Fix Status: This issue has been fixed.",
        "labels": [
            "SlowMist",
            "InsurAce",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.3.4.4 Hard coded issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - InsurAce_en-us.pdf",
        "body": "The external contract address is hard-coded and cannot be modified. It is recommended that the external contract adopts a changeable method to avoid the problem that the project cannot operate normally due to the upgrade of the external contract.  common/Constant.sol address public constant UNISWAPV2_ROUTER_ADDRESS = address(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D); 36 Fix Status: This issue has been communicated back to project team. The project team is aware of this issue, and made design changes, such as adding exchange library lately, which will include token to token exchange queries from 1inch and Uniswap. In the case of address change, the ABI of the address may change accordingly, as such the project team will need to double check, and/or extend exchange library in tandem. 5.",
        "labels": [
            "SlowMist",
            "InsurAce",
            "Severity: Informational"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - LightDAO_en-us.pdf",
        "body": "1.In the HOPESalesAgent contract, the owner can add currency that can buy HOPE tokendelete the currency and change the currency exhange rate. If the owners privileges are lost, it could lead to a contract being maliciously added with a worthless currency and used it to unintentionally buy large amounts of hope tokens. ",
        "labels": [
            "SlowMist",
            "LightDAO",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "The DoS issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - LightDAO_en-us.pdf",
        "body": "The user can pass in the gombocAddressList array through the mintMany function to mint the LT. If the length of gombocAddressList is large, it will cause DoS because of the number of for loops. ",
        "labels": [
            "SlowMist",
            "LightDAO",
            "Type: Denial of Service Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Missing event records",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - LightDAO_en-us.pdf",
        "body": "1.In the Minter contract, the caller can toggle the approval status for mintingUser, but there are no event logs. ",
        "labels": [
            "SlowMist",
            "LightDAO",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing zero address check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - LightDAO_en-us.pdf",
        "body": "When modifying important addresses in the contract, it is not checked whether the incoming address is a zero address. ",
        "labels": [
            "SlowMist",
            "LightDAO",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing return value check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - LightDAO_en-us.pdf",
        "body": "When transferring ERC20 tokens, the return value after the transfer is not checked. If return false, the logical should be reverted. ",
        "labels": [
            "SlowMist",
            "LightDAO",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "No value is assigned to the fee parameter",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap Lottery_en-us.pdf",
        "body": "The fee parameter is dened in the RandomNumberGenerator contract and is used in the getRandomNumber function, but the contract is initialized without assigning a value to the fee parameter. ",
        "labels": [
            "SlowMist",
            "PancakeSwap Lottery",
            "Type: Others",
            "Severity: Low"
        ]
    },
    {
        "title": "Issue with reusable joinNFT",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Open Social Core_en-us.pdf",
        "body": "In the RelationLogic contract, users can join a specied community by calling the join or batchJoin function. A joinNFT is minted for the users, and the processJoin function in the community-specic JoinCondition contract is executed to enforce the corresponding join conditions. However, the joinNFT transfers are not restricted in any way, which leads to the following scenario: If a user joins a community that requires a fee, and pays a specied fee to obtain a joinNFT for the community, he can then transfer that NFT to other users, and since the transfer of the joinNFT is not subject to any checking, multiple users can view or manipulate the community's resources or information using a single NFT (paying for it only once). Code Location: contracts/core/logic/RelationLogic.sol function _executeJoin( uint256 communityId, bytes calldata joinConditionData, uint256 value ) internal returns (uint256 tokenId) { OspDataTypes.CommunityStruct memory community = _getCommunityStorage()._communityById[ communityId ]; if (community.joinNFT == address(0)) revert OspErrors.InvalidCommunityId(); tokenId = IJoinNFT(community.joinNFT).mint(msg.sender); if (community.joinCondition != address(0)) { IJoinCondition(community.joinCondition).processJoin{value: value}( msg.sender, communityId, joinConditionData ); } }",
        "labels": [
            "SlowMist",
            "Open Social Core",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Lack of the repeatability check for creating OpenReactions",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Open Social Core_en-us.pdf",
        "body": "In the",
        "labels": [
            "SlowMist",
            "Open Social Core",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Missing inviter check when creating a prole",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Open Social Core_en-us.pdf",
        "body": "In the ProleLogic contract, the user can create a prole by calling the createProle function, but here the inviter parameter is not checked. If the inviter passed in is equal to msg.sender, it does not follow the normal logic. Code Location: contracts/core/logic/ProleLogic.sol#L274 function _createProfile( OspDataTypes.CreateProfileData calldata vars ) internal returns (uint256) { ... if (vars.inviter != 0) { if (_getProfileStorage()._profileById[vars.inviter].owner == address(0)) { revert OspErrors.ProfileDoesNotExist(); } profileStruct.inviter = vars.inviter; } ... }",
        "labels": [
            "SlowMist",
            "Open Social Core",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Lack of check when following other users",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Open Social Core_en-us.pdf",
        "body": "In the RelationLogic contract, anyone can follow other users by calling the follow or batchFollow function. But here it doesn't check if the object to follow is equal to msg.sender, which doesn't follow the normal logic if you can follow yourself. Code Location: contracts/core/logic/RelationLogic.sol#L186-211 function _executeFollow( uint256 profileId, bytes calldata followConditionData, uint256 value ) internal returns (uint256 tokenId) { if (_getProfileStorage()._profileById[profileId].owner == address(0)) revert OspErrors.TokenDoesNotExist(); address followCondition = _getProfileStorage()._profileById[profileId].followCondition; address followSBT = _getProfileStorage()._profileById[profileId].followSBT; if (followSBT == address(0)) { followSBT = _deployFollowSBT(profileId); _getProfileStorage()._profileById[profileId].followSBT = followSBT; } ... }",
        "labels": [
            "SlowMist",
            "Open Social Core",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Lack of check whether a community has been joined",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Open Social Core_en-us.pdf",
        "body": "In the RelationLogic contract, anyone can join a specied community by calling the join or batchJoin function. However, there is no check to see if the user has already joined the community. If the condition of joining the community is that the number of tokens held reaches a set value, then the user can join the community several times to mint joinNFT, and then transfer the NFT to other users (even if the other users' token balances don't meet the requirements). Code Location: contracts/core/logic/RelationLogic.sol#L318-335 function _executeJoin( uint256 communityId, bytes calldata joinConditionData, uint256 value ) internal returns (uint256 tokenId) { OspDataTypes.CommunityStruct memory community = _getCommunityStorage()._communityById[ communityId ]; if (community.joinNFT == address(0)) revert OspErrors.InvalidCommunityId(); tokenId = IJoinNFT(community.joinNFT).mint(msg.sender); ... }",
        "labels": [
            "SlowMist",
            "Open Social Core",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Missing event record",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Open Social Core_en-us.pdf",
        "body": "The following functions in several contracts are for event logging of key parameter settings. Code Location: contracts/core/conditions/community/SlotNFTCommunityCond.sol#L34-36 function whitelistCommunitySlot(address slot, bool whitelist) external onlyOperation { _slotNFTWhitelisted[slot] = whitelist; } contracts/core/conditions/community/WhitelistAddressCommunityCond.sol#L37-39 function setMaxCreationNumber(address to, uint256 _maxCreationNumber) external onlyOperation { maxCreationNumber[to] = _maxCreationNumber; } Code Location: contracts/core/logic/GovernanceLogic.sol#L108-112 function setERC6551AccountImpl( address accountImpl ) external override onlyRole(Constants.GOVERNANCE) { _getGovernanceStorage()._erc6551AccountImpl = accountImpl; }",
        "labels": [
            "SlowMist",
            "Open Social Core",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "call() should be used instead of transfer() and send()",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Open Social Core_en-us.pdf",
        "body": "The transfer() and send() functions forward a xed amount of 2300 gas. Historically, it has often been recommended to use these functions for value transfers to guard against reentrancy attacks. However, the gas cost of EVM instructions may change signicantly during hard forks which may break already deployed contract systems that make xed assumptions about gas costs. For example. EIP 1884 broke several existing smart contracts due to a cost increase of the SLOAD instruction. ",
        "labels": [
            "SlowMist",
            "Open Social Core",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Open Social Core_en-us.pdf",
        "body": "In the OspUniversalProxy contract, the gov role can directly upgrade the implementation contract and call the functions of the new contract. If the privilege is lost or misused, This could lead to malicious tampering with the contract's functionality. ",
        "labels": [
            "SlowMist",
            "Open Social Core",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Authority transfer enhancement",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Open Social Core_en-us.pdf",
        "body": "In the Account contract, the admin role does not adopt the pending and access processes. If the admin is incorrectly set, the permission will be lost. Code Location: contracts/upgradeability/OspRouterImmutable.sol function changeAdmin(address _admin) public onlyAdmin { _changeAdmin(_admin); } ... function _changeAdmin(address admin_) internal { Data storage data = routerStorage(); emit AdminChanged(data.admin, admin_); data.admin = admin_; }",
        "labels": [
            "SlowMist",
            "Open Social Core",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Ination attack in StoneVault",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - StakeStone_en-us.pdf",
        "body": "In the StoneVault contract, users can can deposit assets and obtain the corresponding share of the vault by calling the deposit function, But there is a risk of interest rate ination attacks here: Consider this example: bob nds out that alice is making a deposit (e.g. via mempool). Pre-condition: no one deposit before( latestRoundID == 0 ) Assume raito = 1e18. Now, alice wants to deposit 1 (1 * 1e18 wei) WETH and the tx is spied on by the attacker(bob). Here is the breakdown: original state (after) Step 1 (after) Step 2 (after) Step 3 totalStone AssetsVault.getBalance() 0 1 1 1 0 1 1e18 + 1 2 * 1e18 + 1 1.bob front-runs alice and deposits 1 wei WETH and gets 1 share: since totalStone is 0, shares = amount = 1. 2.bob also transfers 1 * 1e18 wei WETH, making the WETH balance of the AssetsVault (AssetsVault.getBalance()) become 1e18 + 1 wei. And then directly call the rollToNextRoundId function to update the latestRoundId and price. (Since rebaseTime starts at 0, it can be called successfully directly). 3.alice deposits 1e18 wei WETH. However, alice gets 0 shares: 1e18 * 1 (totalStone) / (1e18 + 1) = 1e18 / (1e18 + 1) = 0. Since alice gets 0 shares, totalStone remains at 1. 4.bob still has the 1 only share ever minted, thus after waiting for the next rollToNextWETH function call for updating the price and the withdrawal of that 1 share takes away everything in the AssetsVault, including the alices 1e18 wei WETH.(Directly by calling the instantWithdraw function and passing in _amount parameter with a value of 0, _shares parameter with a value of 1). Code Location: contracts/StoneVault.sol#L150-173 function _depositFor( uint256 _amount, address _user ) internal returns (uint256 mintAmount) { require(_amount != 0, \"too small\"); uint256 sharePrice; uint256 currSharePrice = currentSharePrice(); if (latestRoundID == 0) { sharePrice = MULTIPLIER; } else { uint256 latestSharePrice = roundPricePerShare[latestRoundID - 1]; sharePrice = latestSharePrice > currSharePrice ? latestSharePrice : currSharePrice; } mintAmount = (_amount * MULTIPLIER) / sharePrice; AssetsVault(assetsVault).deposit{value: address(this).balance}(); Minter(minter).mint(_user, mintAmount); emit Deposit(_user, _amount, mintAmount, latestRoundID); } contracts/StoneVault.sol#L436-453 function currentSharePrice() public returns (uint256 price) { Stone stoneToken = Stone(stone); uint256 totalStone = stoneToken.totalSupply(); if ( latestRoundID == 0 || totalStone == 0 || totalStone == withdrawingSharesInPast ) { return MULTIPLIER; } uint256 etherAmount = AssetsVault(assetsVault).getBalance() + StrategyController(strategyController).getAllStrategiesValue() - withdrawableAmountInPast; uint256 activeShare = totalStone - withdrawingSharesInPast; return (etherAmount * MULTIPLIER) / activeShare; }",
        "labels": [
            "SlowMist",
            "StakeStone",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Missing setting rebaseTime when initializing",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - StakeStone_en-us.pdf",
        "body": "In the StoneVault contract, rebaseTime defaults to 0 and is not set in the constructor function. This could result in any user can call the function directly after the vault is created, potentially combining with other issues to have a signicant impact.(Refer to the N1 issue) Code Location: contracts/StoneVault.sol#L347 function rollToNextRound() external { require( block.timestamp > rebaseTime + rebaseTimeInterval, \"already rebased\" ); ... }",
        "labels": [
            "SlowMist",
            "StakeStone",
            "Type: Others",
            "Severity: Low"
        ]
    },
    {
        "title": "Risks of incorrect withdrawableAmountInPast updates",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - StakeStone_en-us.pdf",
        "body": "In the StoneVault contract, the rollToNextRound function moves the contract to the next round and updates the current round, including withdrawableAmountInPast. However, the price used in the withdrawableAmountInPast update is newSharePrice instead of the current round price (undPricePerShare [latestRoundID]). This results in newSharePrice being larger than the current round price (roundPricePerShare [latestRoundID]) if newSharePrice > previewSharePrice. In the withdrawal operation (instantWithdraw), the number of user withdrawals is actually calculated using roundPricePerShare, so if newSharePrice is larger than roundPricePerShare in the round of commit withdrawals, it may cause the withdrawal withdrawableAmountInPast is actually larger than the total remaining withdrawals. Then there may be the following situation: hypothesis After most withdrawals, totalStone has very little left (such as 1wei), and withdrawableAmountInPast the result of the price bias in statistics mentioned above is actually larger than expected. Then when calculating the current price (currentSharePrice), the calculation of etherAmount may be 0 or even an error due to overow. Code Location: contracts/StoneVault.sol#L387 function rollToNextRound() external { ... uint256 newSharePrice = currentSharePrice(); roundPricePerShare[latestRoundID] = previewSharePrice < newSharePrice ? previewSharePrice : newSharePrice; ... withdrawableAmountInPast = withdrawableAmountInPast + VaultMath.sharesToAsset(withdrawingSharesInRound, newSharePrice); withdrawingSharesInRound = 0; rebaseTime = block.timestamp; emit RollToNextRound(latestRoundID, vaultIn, vaultOut, newSharePrice); }",
        "labels": [
            "SlowMist",
            "StakeStone",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Missing check when migrating the vault",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - StakeStone_en-us.pdf",
        "body": "In the StoneVault contract, the migrateVault function is used to update the stoneVault address in the minter, assetsVault, and strategyController to achieve the eect of migration contracts. However, the migration does not check whether there are pending withdrawal requests in the current stoneVault contract. If the withdrawal request pending in the old stoneVault contract has not been nished during the migration process, then the data has been reset in the new stoneVault contract after the migration, which will cause the shares (stone tokens) transferred to the old stoneVault contract when the user committed the withdrawal request before to be locked and cannot be retrieved. Code Location: contracts/StoneVault.sol#L430-434 function migrateVault(address _vault) external onlyProposal { Minter(minter).setNewVault(_vault); AssetsVault(assetsVault).setNewVault(_vault); StrategyController(strategyController).setNewVault(_vault); }",
        "labels": [
            "SlowMist",
            "StakeStone",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Incorrect return value if the balance is sucient",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - StakeStone_en-us.pdf",
        "body": "When executing a withdrawal, if the eth balance in the AssetsVault contract is insucient, the forceWithdraw function of the controller contract will be called to make up the remaining eth by forcing a withdrawal. In the StrategyController contract, if the eth balance of this contract is sucient, the return value of actualAmount should normally be just what is needed (i.e. the passed ethAmount). But here all eth balances in the contract are returned, which may cause the user to withdraw more tokens than expected. Code Location: contracts/strategies/StrategyController.sol#L63 function forceWithdraw( uint256 _amount ) external onlyVault returns (uint256 actualAmount) { uint256 balanceBeforeRepay = address(this).balance; if (balanceBeforeRepay >= _amount) { _repayToVault(); actualAmount = balanceBeforeRepay; } else { actualAmount = _forceWithdraw(_amount - balanceBeforeRepay) + balanceBeforeRepay; } }",
        "labels": [
            "SlowMist",
            "StakeStone",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Incorrect withdrawal quantity calculation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - StakeStone_en-us.pdf",
        "body": "If the ETH balance in the contract is insucient during forced withdrawals, the instantWithdraw function in each strategy will be called in a loop to make up the dierence. The number of withdrawals for each strategy is calculated as _amount * ratios [strategy])/ONE_HUNDRED_PERCENT. Then there is a situation where if the sum of all ratios is less than ONE_HUNDRED_PERCENT, then the total number of forced withdrawals will be less than expected. (This is possible because the ratio of each strategy is set to only require the sum of all ratios to be less than or equal to ONE_HUNDRED_PERCENT, or a strategy is cleared). Code Location: contracts/strategies/StrategyController.sol#L187 function _forceWithdraw( uint256 _amount ) internal returns (uint256 actualAmount) { uint256 length = strategies.length(); for (uint i; i < length; i++) { address strategy = strategies.at(i); uint256 withAmount = (_amount * ratios[strategy]) / ONE_HUNDRED_PERCENT; if (withAmount != 0) { actualAmount = Strategy(strategy).instantWithdraw(withAmount) + actualAmount; } } _repayToVault(); }",
        "labels": [
            "SlowMist",
            "StakeStone",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Redundant code",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - StakeStone_en-us.pdf",
        "body": "There are useless codes in the le and codes that are not used in actual business. Code Location: contracts/strategies/StrategyController.sol#L51-53 function onlyRebaseStrategies() external { _rebase(0, 0); }",
        "labels": [
            "SlowMist",
            "StakeStone",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Incorrect PendingValue calculations in the STETHHoldingStrategy",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - StakeStone_en-us.pdf",
        "body": "In the STETHHoldingStrategy contract, the getPendingValue function is used to calculate the value of eth in the withdrawal process. However, only the amount of eth that has not passed the request during the withdrawal process is calculated here, and the part that has passed the request but has not been claimed is not calculated. This may cause the rollToNextRound function in the TokenVault contract to call the getAllStrategyPendingValue function to obtain all pending eth values less than expected. Code Location: contracts/strategies/STETHHoldingStrategy.sol#L155-157 function getPendingValue() public override returns (uint256 value) { (, , value) = checkPendingAssets(); } function checkPendingAssets() public returns ( uint256[] memory ids, uint256 totalClaimable, uint256 totalPending ) { ... for (uint256 i; i < length; i++) { ILidoWithdrawalQueue.WithdrawalRequestStatus memory status = statuses[i]; if (status.isClaimed) { continue; } if (status.isFinalized) { ids[j++] = allIds[i]; totalClaimable = totalClaimable + status.amountOfStETH; } else { totalPending = totalPending + status.amountOfStETH; } } ... }",
        "labels": [
            "SlowMist",
            "StakeStone",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Lack of event records",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - StakeStone_en-us.pdf",
        "body": "There is no corresponding event logged when a sensitive parameter in the contract is modied. Code Location: contracts/token/Minter.sol#L30-32 function setNewVault(address _vault) external onlyVault { vault = payable(_vault); } contracts/token/StoneCross.sol#L64-110 function _nonblockingLzReceive( uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload ) internal virtual override { ... if (packetType == PT_SEND) { _sendAck(_srcChainId, _srcAddress, _nonce, _payload); } else if (packetType == PT_FEED) { ... tokenPrice = price; updatedTime = time; } else if (packetType == PT_SET_ENABLE) { ... enable = flag; } else if (packetType == PT_SET_CAP) { ... cap = _cap; } else { revert(\"unknown packet type\"); } } contracts/AssetsVault.sol#L35-37 function setNewVault(address _vault) external onlyPermit { stoneVault = _vault; } contracts/strategies/RETHHoldingStrategy.sol#L158-164 function setRouter( bool _buyOnDex, bool _sellOnDex ) external onlyGovernance { buyOnDex = _buyOnDex; sellOnDex = _sellOnDex; } contracts/strategies/SFraxETHHoldingStrategy.sol#L151-157 function setRouter( bool _buyOnDex, bool _sellOnDex ) external onlyGovernance { buyOnDex = _buyOnDex; sellOnDex = _sellOnDex; } contracts/strategies/STETHHoldingStrategy.sol#L253-259 function setRouter( bool _buyOnDex, bool _sellOnDex ) external onlyGovernance { buyOnDex = _buyOnDex; sellOnDex = _sellOnDex; } contracts/strategies/Strategy.sol#L89-91 function setBufferTime(uint256 _time) external onlyGovernance { bufferTime = _time; } contracts/strategies/StrategyController.sol#L322-324 function setNewVault(address _vault) external onlyVault { stoneVault = _vault; } contracts/strategies/SwappingAggregator.sol#L396-420 function setUniRouter( address _token, address _uniPool, uint256 _slippage, uint24 _fee ) external onlyGovernance { require(_token != address(0), \"ZERO ADDRESS\"); uniV3Pools[_token] = _uniPool; slippage[_token] = _slippage; fees[_token] = _fee; } function setCurveRouter( address _token, address _curvePool, uint8 _curvePoolType, uint256 _slippage ) external onlyGovernance { require(_token != address(0), \"ZERO ADDRESS\"); curvePools[_token] = _curvePool; curvePoolType[_curvePool] = _curvePoolType; slippage[_token] = _slippage; }",
        "labels": [
            "SlowMist",
            "StakeStone",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Authority transfer enhancement",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - StakeStone_en-us.pdf",
        "body": "The permission transfer method for the core roles(like proposer and governance) does not adopt the pending and access processes. If set incorrectly, the permission of the core roles will be lost. Code Location: contracts/strategies/Strategy.sol#L84-87 function setGovernance(address governance_) external onlyGovernance { emit TransferGovernance(governance, governance_); governance = governance_; } contracts/strategies/SwappingAggregator.sol#L422-426 function setGovernance(address governance_) external onlyGovernance { emit TransferGovernance(governance, governance_); governance = governance_; } contracts/governance/Proposal.sol#L138-142 function setProposer(address _proposer) external onlyProposer { emit SetProposer(proposer, _proposer); proposer = _proposer; }",
        "labels": [
            "SlowMist",
            "StakeStone",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Lack of CrossChain fee checking in the bridgeTo function",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - StakeStone_en-us.pdf",
        "body": "In the DepositBridge contract, there is no check in the bridgeTo function to see if the incoming _gasPaidForCrossChain parameter is greater than or equal to the handling fee required to send across the chain. If passed in too small it may cause the cross-chain operation to fail. Code Location: contracts/mining/DepositBridge.sol#L30-41 function bridgeTo( uint256 _amount, bytes calldata _dstAddress, uint256 _gasPaidForCrossChain ) public payable returns (uint256 stoneMinted) { stoneMinted = bridge( msg.sender, _amount, _dstAddress, _gasPaidForCrossChain ); }",
        "labels": [
            "SlowMist",
            "StakeStone",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Missing check for dstChainId on initialisation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - StakeStone_en-us.pdf",
        "body": "In the DepositBridge contract, the dstChainId is set on initialisation, but there is no check to see if the value set is not equal to the chainId of the current chain, which would cause the sendFrom function in the stone tokens to revert and the cross-chain operation to fail. Code Location: contracts/mining/DepositBridge.sol#L27 constructor(address _stone, address payable _vault, uint16 _dstChainId) { ... dstChainId = _dstChainId; }",
        "labels": [
            "SlowMist",
            "StakeStone",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Lack of scope check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - StakeStone_en-us.pdf",
        "body": "1.In Strategy contracts, the setBuerTime function can be used to set the delay time for strategy operations. However, there is no check on the range of the _time parameter passed in, and if it is too large, the normal operation of the strategy contract will be aected. Code Location: contracts/strategies/Strategy.sol#L89-91 function setBufferTime(uint256 _time) external onlyGovernance { bufferTime = _time; } 2.In SwappingAggregator contracts, the Governance role can set the slips corresponding to dierent tokens and the fees charged by calling the setSlippage function, the setUniRouter function, and the setCurveRouter function. However, there is no range checking of incoming new slippage and fees at the time of setup, which could result in arbitrage or unintended depletion of the user's funds if set too high. Code Location: contracts/strategies/SwappingAggregator.sol#L387-420 function setSlippage( address _token, uint256 _slippage ) external onlyGovernance { emit SetSlippage(_token, slippage[_token], _slippage); slippage[_token] = _slippage; } function setUniRouter( address _token, address _uniPool, uint256 _slippage, uint24 _fee ) external onlyGovernance { require(_token != address(0), \"ZERO ADDRESS\"); uniV3Pools[_token] = _uniPool; slippage[_token] = _slippage; fees[_token] = _fee; } function setCurveRouter( address _token, address _curvePool, uint8 _curvePoolType, uint256 _slippage ) external onlyGovernance { require(_token != address(0), \"ZERO ADDRESS\"); curvePools[_token] = _curvePool; curvePoolType[_curvePool] = _curvePoolType; slippage[_token] = _slippage; }",
        "labels": [
            "SlowMist",
            "StakeStone",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Potential governance attacks",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - StakeStone_en-us.pdf",
        "body": "In a Proposal contract, users can call the voteFor function to transfer their holdings of stone tokens into that contract and vote on a specied proposal. However, if the Proposer role is evil (e.g. in the case of lost permissions), it is possible to call the instantWithdraw function or requestWithdraw function in the Stone Vault contract by submitting a proposal and transferring a large number of stone tokens towards the end of the vote to ensure that the proposal passes. After the proposal is executed, it will consume other users' stone tokens and make additional prot (enough to cover the cost of the attack). Code Location: contracts/governance/Proposal.sol#L76-96 function voteFor(address _proposal, uint256 _poll, bool _flag) external { require(canVote(_proposal), \"cannot vote\"); TransferHelper.safeTransferFrom( stoneToken, msg.sender, address(this), _poll ); ... }",
        "labels": [
            "SlowMist",
            "StakeStone",
            "Type: Design Logic Audit",
            "Severity: Information"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - StakeStone_en-us.pdf",
        "body": "1.In SwappingAggregator contracts, the Governance role can set the slips, the exchange router and the fee corresponding to dierent tokens by calling the setSlippage function, the setUniRouter function, and the setCurveRouter function. If the privilege is lost or misused, this may have an impact on the user's assets. Code Location: contracts/strategies/SwappingAggregator.sol#L387-420 function setSlippage( address _token, uint256 _slippage ) external onlyGovernance { emit SetSlippage(_token, slippage[_token], _slippage); slippage[_token] = _slippage; } function setUniRouter( address _token, address _uniPool, uint256 _slippage, uint24 _fee ) external onlyGovernance { require(_token != address(0), \"ZERO ADDRESS\"); uniV3Pools[_token] = _uniPool; slippage[_token] = _slippage; fees[_token] = _fee; } function setCurveRouter( address _token, address _curvePool, uint8 _curvePoolType, uint256 _slippage ) external onlyGovernance { require(_token != address(0), \"ZERO ADDRESS\"); curvePools[_token] = _curvePool; curvePoolType[_curvePool] = _curvePoolType; slippage[_token] = _slippage; } 2.In Proposal contracts, the Proposer role can initiate a proposal by calling the propose function. If the privilege is lost or misused, the Proposer role may launch a malicious proposal causing the user to suer a loss of funds. Code Location: contracts/governance/Proposal.sol#L57-74 function propose(bytes calldata _data) external onlyProposer { ... }",
        "labels": [
            "SlowMist",
            "StakeStone",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Missing return value check when adding strategies",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - StakeStone_en-us.pdf",
        "body": "In StrategyController contracts, the type of data structure used for strategy storage is the EnumerableSet library from openzeppelin. When using the .add() function, it will return false if the added data already exists and will not add the data repeatedly. However, the StrategyController contract does not check the return value of the .add() function when adding or setting a strategy, which may result in strategies not being added but ratios being changed. Code Location: contracts/strategies/StrategyController.sol function _initStrategies( address[] memory _strategies, uint256[] memory _ratios ) internal { ... for (uint i; i < length; i++) { strategies.add(_strategies[i]); ratios[_strategies[i]] = _ratios[i]; totalRatio = totalRatio + _ratios[i]; } require(totalRatio <= ONE_HUNDRED_PERCENT, \"exceed 100%\"); } function _setStrategies( address[] memory _strategies, uint256[] memory _ratios ) internal { ... for (uint i; i < length; i++) { ... strategies.add(_strategies[i]); ratios[_strategies[i]] = _ratios[i]; totalRatio = totalRatio + _ratios[i]; } require(totalRatio <= ONE_HUNDRED_PERCENT, \"exceed 100%\"); }",
        "labels": [
            "SlowMist",
            "StakeStone",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Synclub_en-us.pdf",
        "body": "1.In the SnBnb contract, the DEFAULT_ADMIN_ROLE can set the stakeManager contract as the StakeManager role and the StakeManager role can call the mint and burn functions to mint tokens arbitrarily and burn any users tokens. ",
        "labels": [
            "SlowMist",
            "Synclub",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "The mint amount can be 0 in the deposit function",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Synclub_en-us.pdf",
        "body": "In the SnStakeManager contract, users deposit their BNB into this contract and obtain the SnBNB as the staking certicate. And the calculation of the snBnbToMint is dependent on the convertBnbToSnBnb function, the totalSupply of the SnBNB, and the totalPooledBnb in this contract. If the deposit amount of the BNB is small enough or the totalPooledBnb is big enough, the calculation of the snBnbToMint can be 0. But the amount of the BNB can still add to the amountToDelegate to cause the increment of the totalPooledBnb. ",
        "labels": [
            "SlowMist",
            "Synclub",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "The BNB can be remained in the contract",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Synclub_en-us.pdf",
        "body": "In the SnStakeManager contract when users claim to withdraw their BNB tokens in the claimWithdraw in the same uuid, the calculation of the amount = (totalBnbToWithdraw_ * amountInSnBnb) / totalSnBnbToBurn_; has the rounding to obtain one of the users withdrawal amount. It will cause the rounded amount of the BNB to remain in this contract and can not be withdrawn. ",
        "labels": [
            "SlowMist",
            "Synclub",
            "Type: Arithmetic Accuracy Deviation Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "The business logic is unclear",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Synclub_en-us.pdf",
        "body": "In the SnStakeManager contract, the claimUndelegated function calculates the claimUndelegated withdrawal value in one uuid and assigns it to two temporary variables. The two temporary variables are just for recording and have no other usage. ",
        "labels": [
            "SlowMist",
            "Synclub",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing the validator check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Synclub_en-us.pdf",
        "body": "In the SnStakeManager contract, the Manager role can change the Validator through the redelegate function, and this check is done by the NATIVE_STAKING contract, and if the call of the redelegate function failed, it will consume the gas of this call. ",
        "labels": [
            "SlowMist",
            "Synclub",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing the event records",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Synclub_en-us.pdf",
        "body": "There are no event logs of the claimUndelegated and claimFailedDelegation in this SnStakeManager contract. ",
        "labels": [
            "SlowMist",
            "Synclub",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Preemptive initialization",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Synclub_en-us.pdf",
        "body": "By calling the initialize function to initialize the contracts, there is a potential issue that malicious attackers preemptively call the initialize function to initialize. ",
        "labels": [
            "SlowMist",
            "Synclub",
            "Type: Race Conditions Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Dev address setting enhancement suggestions",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Synclub_en-us.pdf",
        "body": "In the SnStakeManager contract, the GOVERNANCE_ROLE role can set the revenuePool address to receive the fee. If the address is an EOA address, in a scenario where the private keys are leaked, the teams revenue will be stolen. ",
        "labels": [
            "SlowMist",
            "Synclub",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Business logic error Payable Payable Can Modify State - Can Modify State Can Modify State Can Modify State - - - - - - - 13",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ioTube_en-us.pdf",
        "body": "When originalAssetByID gets the data of originalAssets, the _assetID passed in should be reduced by 1, and then readout. activateAsset, deactivateAsset function directly passes in _assetID, and then read originalAssets[_assetID], The judgment is _assetID <= originalAssets.length . There are two issues here: 1. When _assetID == originalAssets.length, originalAssets[_assetID] cannot read data. 2. The originalAssets data obtained here is not obtained using the originalAssetByID function, and the business logic needs to be conrmed. contracts/AssetRegistry.sol#L101-L133 function activateAsset(uint256 _assetID, uint256 _tubeID) public onlyOperator { require(_assetID > 0 && _assetID <= originalAssets.length, \"invalid asset id\"); Asset storage oa = originalAssets[_assetID]; if (_tubeID == 0 || oa.tubeID == _tubeID) { if (oa.active == false) { oa.active = true; emit AssetActivated(_assetID, oa.tubeID); } } else { Asset storage sa = shadowAssets[_assetID][_tubeID]; if (sa.asset != address(0) && sa.active == false) { sa.active = true; emit AssetActivated(_assetID, _tubeID); } } } function deactivateAsset(uint256 _assetID, uint256 _tubeID) public onlyOperator { require(_assetID > 0 && _assetID <= originalAssets.length, \"invalid asset id\"); Asset storage oa = originalAssets[_assetID]; if (_tubeID == 0 || oa.tubeID == _tubeID) { if (oa.active == true) { oa.active = false; 14 emit AssetDeactivated(_assetID, oa.tubeID); } } else { Asset storage sa = shadowAssets[_assetID][_tubeID]; if (sa.asset != address(0) && sa.active == true) { sa.active = false; emit AssetDeactivated(_assetID, _tubeID); } } } originalAssetIDs[_tubeID][_asset] = id; The record is originalAssets.length;, so to take the value of originalAssets, the index should be originalAssetIDs[_tubeID][_asset]-1, combined with the processing logic here, you need to conrm the issues with the developer. contracts/AssetRegistry.sol#L74-L84 function addOriginalAsset(uint256 _tubeID, address _asset) public onlyOperator returns (uint256) { require(_tubeID > 0 && _asset != address(0), \"invalid parameter\"); uint256 id = assetID(_tubeID, _asset); if (id == 0) { originalAssets.push(Asset(_tubeID, _asset, true)); id = originalAssets.length; originalAssetIDs[_tubeID][_asset] = id; emit NewOriginalAsset(_tubeID, _asset, id); } return id; }",
        "labels": [
            "SlowMist",
            "ioTube",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Authority transfer enhancement",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ioTube_en-us.pdf",
        "body": "There is no pending and accept mechanism for authority transfer to avoid loss of authority contracts/CrosschainERC20.sol#L34-L37 function transferMintership(address _newMinter) public onlyMinter { minter = _newMinter; 16 emit MinterSet(_newMinter); } contracts/CrosschainERC721.sol#L29-L32 function transferMintership(address _newMinter) public onlyMinter { minter = _newMinter; emit MinterSet(_newMinter); }",
        "labels": [
            "SlowMist",
            "ioTube",
            "Type: Authority Control Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "unsafe external call risk",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ioTube_en-us.pdf",
        "body": "The withdraw function in the contract code does not check the whitelist of _recipient and _data. There is an unsafe external call (success,) = _recipient.call(_data); . The attacker can use _recipient.call(_data); to call any function of the lord contract, or transfer the token approved by the user to the Tube contract. contracts/Tube.sol#L179-L207 function withdraw( uint256 _srcTubeID, uint256 _txIdx, address _token, address _recipient, uint256 _amount, bytes memory _data, bytes memory _signatures ) public whenNotPaused { require(_amount != 0, \"amount is 0\"); 17 require(_recipient != address(0), \"invalid recipient\"); require(_signatures.length % 65 == 0, \"invalid signature length\"); bytes32 key = genKey(_srcTubeID, _txIdx, _token, _recipient, _amount, _data); ledger.record(key); (bool isValid, address[] memory signers) = verifier.verify(key, _signatures); require(isValid, \"insufficient validators\"); bool success = true; if (_data.length > 0) { lord.mint(_token, address(this), _amount); IERC20(_token).safeApprove(_recipient, _amount); (success, ) = _recipient.call(_data); if (!success) { IERC20(_token).safeDecreaseAllowance(_recipient, _amount); } } else { lord.mint(_token, _recipient, _amount); } emit Settled(key, signers, success); }",
        "labels": [
            "SlowMist",
            "ioTube",
            "Type: Unsafe External Call Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Excessive authority issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ioTube_en-us.pdf",
        "body": "The Owner of the Tube contract has too much authority. The owner of the Lord contract can be changed, and the owner of the Lord contract can execute mint and burn arbitrarily. This will aect the users assets. contracts/Tube.sol#L71-L78 function upgrade(address _newTube) public onlyOwner { if (ledger.owner() == address(this)) { ledger.transferOwnership(_newTube); } 18 if (lord.owner() == address(this)) { lord.transferOwnership(_newTube); } } contracts/Lord.sol#L94-L131 function burn( address _token, address _sender, uint256 _amount ) public onlyOwner { if (address(standardTokenList) != address(0) && standardTokenList.isAllowed(_token)) { // transfer token to standardTokenList _callOptionalReturn( _token, abi.encodeWithSelector(IToken(_token).transferFrom.selector, _sender, tokenSafe, _amount) ); return; } if (address(proxyTokenList) != address(0) && proxyTokenList.isAllowed(_token)) { _callOptionalReturn( _token, abi.encodeWithSelector(IToken(_token).transferFrom.selector, _sender, address(this), _amount) ); _callOptionalReturn(_token, abi.encodeWithSelector(IToken(_token).burn.selector, _amount)); return; } _callOptionalReturn(_token, abi.encodeWithSelector(IToken(_token).burnFrom.selector, _sender, _amount)); } function mint( address _token, address _recipient, uint256 _amount ) public onlyOwner { if (address(standardTokenList) != address(0) && 19 standardTokenList.isAllowed(_token)) { require(tokenSafe.mint(_token, _recipient, _amount), \"token safe mint failed\"); return; } if (address(proxyTokenList) != address(0) && proxyTokenList.isAllowed(_token)) { require(minterPool.mint(_token, _recipient, _amount), \"proxy token mint failed\"); } _callOptionalReturn(_token, abi.encodeWithSelector(IToken(_token).mint.selector, _recipient, _amount)); } function mintNFT( address _token, uint256 _tokenID, address _recipient, bytes memory _data ) public onlyOwner { IERC721Mintable(_token).safeMint(_recipient, _tokenID, _data); } function upgrade(address _newLord) public onlyOwner { if (minterPool.owner() == address(this)) { _callOptionalReturn( address(tokenSafe), abi.encodeWithSelector(minterPool.transferOwnership.selector, _newLord) ); } if (tokenSafe.owner() == address(this)) { _callOptionalReturn( address(tokenSafe), abi.encodeWithSelector(tokenSafe.transferOwnership.selector, _newLord) ); } }",
        "labels": [
            "SlowMist",
            "ioTube",
            "Type: Authority Control Vulnerability",
            "Severity: High"
        ]
    },
    {
        "title": "Business logic aws",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ioTube_en-us.pdf",
        "body": "The swapCoinForCrosschainCoin function will call cerc20.depositTo. contracts/CrosschainCoinRouter.sol#L37-L40 function swapCoinForCrosschainCoin(uint256 _amount) public payable { wrappedCoin.deposit{value: _amount}(); cerc20.depositTo(msg.sender, _amount); } cerc20.depositTo will call safeTransferFrom, where msg.sender is the CrosschainCoinRouter contract, but CrosschainCoinRouter has authorized CrosschainERC20 contract operation assets. contracts/CrosschainERC20.sol#L43-L47 function depositTo(address _to, uint256 _amount) public { require(address(coToken) != address(0), \"no co-token\"); coToken.safeTransferFrom(msg.sender, address(this), _amount); _mint(_to, _amount); } Although the allowance is set to -1, under extreme conditions, the continuous consumption quota will still be reduced to no quota. At this time, the contract cannot be used without re-approve. contracts/CrosschainCoinRouter.sol#L20-L25 constructor(CrosschainERC20 _cerc20) public { ERC20 ct = _cerc20.coToken(); cerc20 = _cerc20; ct.safeApprove(address(cerc20), uint256(-1)); 21 wrappedCoin = WrappedCoin(address(ct)); }",
        "labels": [
            "SlowMist",
            "ioTube",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Excessive authority issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ioTube_en-us.pdf",
        "body": "Owner can set the relayfee arbitrarily, and there is no limit on the value range. When the relayfee is set to a large value, most of the user's funds will be used to pay the relayFees. contracts/TubeRouter.sol#L49-L55 function setRelayFee(uint256 _tubeID, uint256 _fee) public onlyOwner { if (_fee == 0) { relayFees[_tubeID].exists = false; } else { relayFees[_tubeID] = RelayFee(_fee, true); } }",
        "labels": [
            "SlowMist",
            "ioTube",
            "Type: Authority Control Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Coding optimization",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ioTube_en-us.pdf",
        "body": "22 Owner can withdraw ETH and token in the contract. There are relayFees in the TubeRouter contract, and the Owner can withdraw the relayFees through the withdrawToken function, However, withdrawCoin and withdrawToken are used to extract the assets that were unexpectedly credited into the contract. contracts/TubeRouter.sol#L97-L106 function withdrawCoin(address payable _to) external onlyOwner { _to.transfer(address(this).balance); } function withdrawToken(address _to, IERC20 _token) external onlyOwner { uint256 balance = _token.balanceOf(address(this)); if (balance > 0) { _token.safeTransfer(_to, balance); } } contracts/Tube.sol#L229-L238 function withdrawCoin(address payable _to) external onlyOwner { _to.transfer(address(this).balance); } function withdrawToken(address _to, IERC20 _token) external onlyOwner { uint256 balance = _token.balanceOf(address(this)); if (balance > 0) { _token.safeTransfer(_to, balance); } }",
        "labels": [
            "SlowMist",
            "ioTube",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Other safety reminders",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ioTube_en-us.pdf",
        "body": "Note that when signing, make sure that the K value is not the same in the signature implementation. In the elliptic curve signature algorithm, if the random number is not safe enough and the same K value random number is used, there will be two transactions with the same R value. , So that the private key can be calculated, please pay attention to investigate similar cryptographic implementations. Reference: https://panzhibiao.com/2019/03/13/important-random-k-and-fake-signatures/ To capture events in the cross-chain bridge, the implementation of subscribing to the events of the specied contract should be adopted to avoid the attacks of fake contract events",
        "labels": [
            "SlowMist",
            "ioTube",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Pancakeswap-CakePool_en-us.pdf",
        "body": "In the cakePool contract, the owner role can set the DURATION_FACTOR and DURATION_FACTOR_OVERDUE by 7 calling the setDurationFactor and setDurationFactorOverdue. If these values are set too large or too small, this may aect the calculation of user.shares when calling the deposit and withdraw function. ",
        "labels": [
            "SlowMist",
            "Pancakeswap-CakePool",
            "Type: Authority Control Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Missing event records",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Pancakeswap-CakePool_en-us.pdf",
        "body": "In the cakePool contract, the owner role can set admin, treasury, operator, boostContract, freeFeeUsers, performanceFee, performanceFeeContract, withdrawFee, withdrawFeeContract, withdrawFeePeriod, MAX_LOCK_DURATION, DURATION_FACTOR, DURATION_FACTOR_OVERDUE, UNLOCK_FREE_DURATION and 8 BOOST_WEIGHT by calling the setAdmin, setTreasury, setOperator, setBoostContract, setFreeFeeUser, setPerformanceFee, setPerformanceFeeContract, setWithdrawFee, setWithdrawFeeContract, setWithdrawFeePeriod, setMaxLockDuration, setDurationFactor, setDurationFactorOverdue, setUnlockFreeDuration and setBoostWeight. but there no event logging is preformed. ",
        "labels": [
            "SlowMist",
            "Pancakeswap-CakePool",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Index conict issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm_Phase6_en-us.pdf",
        "body": "In the MIM strategy of ENF_V3, the getPID function is used to obtain the pool id of the specied LP token in ConvexBooster. Returns the current index if the match is successful, otherwise returns the 0 index. However, there is a corresponding LP (Curve. cDAI/cUSDC) conguration for the 0 index in ConvexBooster, which will make it impossible for the caller to determine whether the return of the 0 index is due to a matching failure or LP tokens in the 0 pool of ConvexBooster. ",
        "labels": [
            "SlowMist",
            "Earning.Farm_Phase6",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Visibility issue with getPID function",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm_Phase6_en-us.pdf",
        "body": "There is a getPID function with public visibility in the MIM strategy of ENF_V3, but this function is not called by other functions in this contract, so using public visibility will consume more gas than external visibility. ",
        "labels": [
            "SlowMist",
            "Earning.Farm_Phase6",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Read-only reentrancy checks subject to rounding errors",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm_Phase6_en-us.pdf",
        "body": "In the StETH contract in ENF_ETH_Lowrisk, the remove_liquidity_one_coin function will be called during the deposit and withdraw operations to avoid virtual price manipulation. However, the remove_liquidity_one_coin operation does not always succeed due to rounding errors in the calculation of _get_y_D . ",
        "labels": [
            "SlowMist",
            "Earning.Farm_Phase6",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Slippage check issue when Vault gets totalAssets",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm_Phase6_en-us.pdf",
        "body": "In the Vault contract of ENF_ETH_Lowrisk, the totalAssets function is used to obtain the total assets held by the protocol, which will be counted by calling the totalAssets function of each SS contract. In the FrxETH strategy, in order to ensure that the amount of totalAssets obtained has not been manipulated, a slippage check will be performed according to the fetch ag. Fetch is passed as true in the Vault contract, which will ignore the slippage check. ",
        "labels": [
            "SlowMist",
            "Earning.Farm_Phase6",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Logic optimization",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm_Phase6_en-us.pdf",
        "body": "In the FrxETH contract of ENF_ETH_Lowrisk, there are some functions to convert between share and asset through the totalSupply and totalAssets values of sFrx. However, these interfaces have been provided in the sFrx contract, and the calculated decimal is more accurate. Here is some alternative logic: The frxBal calculation in _totalAssets function can be done by ISfrx(sFrx).convertToAssets(sFrxBal) The lastEarnPrice calculation in _deposit function can be done by ISfrx(sFrx).pricePerShare() The currentPrice calculation in harvest function can be done by ISfrx(sFrx).pricePerShare() ",
        "labels": [
            "SlowMist",
            "Earning.Farm_Phase6",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Swap optimization from ETH to FrxETH",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm_Phase6_en-us.pdf",
        "body": "In the FrxETH contract of ENF_ETH_Lowrisk, the _deposit function will select the optimal exchange path according to the price of CurvePool. When the amount exchanged by CurvePool is greater than or equal to _amount (curveExpect >= _amount), it will exchange tokens through CurvePool . If curveExpect == _amount , converting through CurvePool may consume more gas than minting through frxMinter. ",
        "labels": [
            "SlowMist",
            "Earning.Farm_Phase6",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Redundant code",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Yield V1.0.0_en-us.pdf",
        "body": "Ether is not accepted by default, which is a redundant code. cross-send/contracts/CrossSend.sol#L41-L47 initial-hotcross-oering/contracts/BaseIHO.sol#L67-L73 fallback () external payable { revert(\"cannot directly accept currency transfers\"); } receive () external payable { revert(\"cannot directly receive currency transfers\"); 15 }",
        "labels": [
            "SlowMist",
            "Cross Yield V1.0.0",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Gas optimization",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Yield V1.0.0_en-us.pdf",
        "body": "If one of the batch transfers fails, the transaction that was previously transferred normally will be reverted, but Gas has been consumed. It is a gas optimization issue here. cross-send/contracts/CrossSend.sol#L175-L210 function sendToken( IERC20 token, address[] memory recipients, uint256[] memory amounts ) private returns(uint256) { uint256 total = 0; for (uint256 i = 0; i < recipients.length ; i++) { require(_msgSender() != recipients[i], \"sender != recipient\"); token.safeTransferFrom(_msgSender(), recipients[i], amounts[i]); total += amounts[i]; } return total; } function sendNative( address[] memory recipients, uint256[] memory amounts ) private returns(uint256) { uint256 total = 0; 16 for (uint256 i = 0; i < recipients.length ; i++) { total += amounts[i]; (bool success, ) = payable(recipients[i]).call{value: amounts[i]}(\"\"); require(success, \"native transfer failed\"); } return total; }",
        "labels": [
            "SlowMist",
            "Cross Yield V1.0.0",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of allowance amount abuse",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Yield V1.0.0_en-us.pdf",
        "body": "There have an allowance amount in the contract, but the distributeTokenFee function does not limit the caller, and there is an issue of being called arbitrarily, but it can only transfer the balance of the sender to the feeCollector. cross-send/contracts/fee-managers/RecipientCountFee.sol#L65-L83 function distributeTokenFee( uint256 txRecipientCount, uint256, uint256, uint256, uint256, address sender ) public override { uint256 payableFee = txRecipientCount * tokenFeePerRecipient; 17 if(payableFee < minTokenFee) { payableFee = minTokenFee; } else if (payableFee > maxTokenFee) { payableFee = maxTokenFee; } token.safeTransferFrom(sender, feeCollector, payableFee); }",
        "labels": [
            "SlowMist",
            "Cross Yield V1.0.0",
            "Type: Authority Control Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Price manipulation issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Yield V1.0.0_en-us.pdf",
        "body": "The IOUPrice is calculated using totalFarmingTokenBalance. Attackers can control totalFarmingTokenBalance to manipulate IOUPrice. The current code does not nd the location where IOUPrice is used. Referencehttps://slowmist.medium.com/cream-hacked-analysis-us-130-million-hacked-95c9410320ca cross-yield/contracts/core/CrossYield.sol#L95-L101 function IOUPrice() public view returns (uint256) { uint256 IOUSupply = totalSupply(); return IOUSupply == 0 ? 1e18 : (totalFarmingTokenBalance() * 1e18) / IOUSupply; } 18 cross-yield/contracts/core/CrossYield.sol#L65-L67 function totalFarmingTokenBalance() public view returns (uint256) { return farmingToken().balanceOf(address(this)) + strategy.balanceOf(); }",
        "labels": [
            "SlowMist",
            "Cross Yield V1.0.0",
            "Type: Others",
            "Severity: Medium"
        ]
    },
    {
        "title": "Sandwich attacks issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Yield V1.0.0_en-us.pdf",
        "body": "There is no slippage check during swap, and there is a risk of sandwich attack. IPancakeRouter02(pcsRouter).swapExactTokensForTokens(cakeBalance, 0,cakeToBaseRoute, address(this), block.timestamp); IPancakeRouter02(pcsRouter) .swapExactTokensForTokens(toSwap, 0, route, address(this), block.timestamp); Reference https://medium.com/coinmonks/demystify-the-dark-forest-on-ethereum-sandwich-attacks-5a3aec9fa33e cross-yield/contracts/libs/OptimalSwap.sol#L14-L63 function prepareLiquidity( address cake, address[2] memory lpTokens, 19 address wbnb, address busd, address farmingToken, address pcsRouter, uint256 fee ) external { uint256 cakeBalance = IERC20(cake).balanceOf(address(this)); bool isCakeInLp = lpTokens[0] == cake || lpTokens[1] == cake; bool isWbnbBased = lpTokens[0] == wbnb || lpTokens[1] == wbnb; address baseToken = isWbnbBased ? wbnb : busd; // if cake is not part of the lp token, swap all cake for the base token if (!isCakeInLp) { address[] memory cakeToBaseRoute = new address[](2); cakeToBaseRoute[0] = cake; cakeToBaseRoute[1] = baseToken; IPancakeRouter02(pcsRouter) .swapExactTokensForTokens(cakeBalance, 0, cakeToBaseRoute, address(this), block.timestamp); } (uint256 reserve0, uint256 reserve1,) = IPancakePair(farmingToken).getReserves(); address[] memory route = new address[](2); uint256 lp0Bal = IERC20(lpTokens[0]).balanceOf(address(this)); uint256 lp1Bal = IERC20(lpTokens[1]).balanceOf(address(this)); uint256 toSwap; // The possible cases here are: // - Cake was not part of the LP token, so we swap for baseToken which could either be lpToken0 or lpToken // - Cake was part of the LP token, so it can either be lpTokens[0] or lpTokens[1] // So, depending on which token we have the highest balance for, we swap for the other one. if (lp0Bal > lp1Bal) { toSwap = SwapAmount.getSwapAmount(lp0Bal, reserve0, fee); route[0] = lpTokens[0]; route[1] = lpTokens[1]; } else { toSwap = SwapAmount.getSwapAmount(lp1Bal, reserve1, fee); route[0] = lpTokens[1]; route[1] = lpTokens[0]; 20 } // Perform the swap IPancakeRouter02(pcsRouter) .swapExactTokensForTokens(toSwap, 0, route, address(this), block.timestamp); } IPancakeRouter02(pcsRouter).swapExactTokensForTokens(toWbnb, 0, cakeToWbnbRoute, address(this), block.timestamp); cross-yield/contracts/strategies/StrategyCake.sol#L131 function collectFees() internal { // a percentant of the cake we get from the masterchef will be used to buy BNB and transfer to this address // this is the total fees that will be shared amongst the protocol, stategy dev and the harvester uint256 toWbnb = feeManager.calculateTotalFee(IERC20(farmingToken).balanceOf(address(this))); IPancakeRouter02(pcsRouter).swapExactTokensForTokens(toWbnb, 0, cakeToWbnbRoute, address(this), block.timestamp); uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this)); // distribute hervester fee uint256 harvesterFeeAmount = feeManager.calculateHarvestFee(wbnbBal); // collectFees is called indirectly from the CrossYield contract via the beforeDeposit hook. // This means that _msgSender() is the CrossYield contract and not the actuall EOA account // that send the transaction IERC20(wbnb).safeTransfer(tx.origin, harvesterFeeAmount); // distribute protocol fee uint256 protocolFeeAmount = feeManager.calculateProtocolFee(wbnbBal); // IERC20(wbnb).safeTransfer(protocolFeeRecipient, protocolFeeAmount); feeProcessor.process(protocolFeeAmount); // distribute strategy dev fee uint256 strategyDevFeeAmount = feeManager.calculateStrategyDevFee(wbnbBal); IERC20(wbnb).safeTransfer(feeManager.strategyDev(), strategyDevFeeAmount); emit FeeCollected( toWbnb, 21 harvesterFeeAmount, protocolFeeAmount, strategyDevFeeAmount, _msgSender() ); } cross-yield/contracts/strategies/StrategyCakeLP.sol#L174 function collectFees() internal { // a percentant of the cake we get from the masterchef will be used to buy BNB and transfer to this address // this is the total fees that will be shared amongst the protocol, stategy dev and the harvester uint256 toWbnb = feeManager.calculateTotalFee(IERC20(cake).balanceOf(address(this))); IPancakeRouter02(pcsRouter).swapExactTokensForTokens(toWbnb, 0, cakeToWbnbRoute, address(this), block.timestamp); uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this)); // distribute hervester fee uint256 harvesterFeeAmount = feeManager.calculateHarvestFee(wbnbBal); IERC20(wbnb).safeTransfer(_msgSender(), harvesterFeeAmount); // distribute protocol fee uint256 protocolFeeAmount = feeManager.calculateProtocolFee(wbnbBal); feeProcessor.process(protocolFeeAmount); // distribute strategy dev fee uint256 strategyDevFeeAmount = feeManager.calculateStrategyDevFee(wbnbBal); IERC20(wbnb).safeTransfer(feeManager.strategyDev(), strategyDevFeeAmount); emit FeeCollected( toWbnb, harvesterFeeAmount, protocolFeeAmount, strategyDevFeeAmount, _msgSender() ); } cross-yield/contracts/strategies/StrategyCake.sol 22 function harvest() public override whenNotPaused { // claim rewards IMasterChef(masterchef).leaveStaking(0); // because harvest can automatically be called after each user deposit // we might end up having multiple deposits in the same block and only one // would return rewards from masterchef so the rest will have 0 cake so // we don't need to waste gas to collect fees and call deposit uint256 farmingTokenBalance = balanceOfFarmingToken(); if(farmingTokenBalance > 0) { collectFees(); deposit(); emit HarvestTriggered(_msgSender(), farmingTokenBalance); } } cross-yield/contracts/strategies/StrategyCakeLP.sol#l137-L148 function harvest() external override whenNotPaused { // claim rewards IMasterChef(masterchef).deposit(poolId, 0); uint256 harvestedAmount = IERC20(cake).balanceOf(address(this)); collectFees(); addLiquidity(); deposit(); emit HarvestTriggered(_msgSender(), harvestedAmount); }",
        "labels": [
            "SlowMist",
            "Cross Yield V1.0.0",
            "Type: Reordering Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Missing slippage check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Yield V1.0.0_en-us.pdf",
        "body": "The addLiquidity function without slippage check, it doesn't have an impermanent loss check. cross-yield/contracts/strategies/StrategyCakeLP.sol#L218 function addLiquidity() internal { OptimalSwap.prepareLiquidity( cake, [lpToken0, lpToken1], wbnb, busd, farmingToken, pcsRouter, swapFee ); // add liquidity to AMM on PCS uint256 lp0Bal = IERC20(lpToken0).balanceOf(address(this)); uint256 lp1Bal = IERC20(lpToken1).balanceOf(address(this)); IPancakeRouter02(pcsRouter) .addLiquidity(lpToken0, lpToken1, lp0Bal, lp1Bal, 0, 0, address(this), block.timestamp); emit LiquidityAdded(lpToken0, lpToken1, lp0Bal, lp1Bal, _msgSender()); }",
        "labels": [
            "SlowMist",
            "Cross Yield V1.0.0",
            "Type: Reordering Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Permission check Missing",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Yield V1.0.0_en-us.pdf",
        "body": "There is no permission check for deposit function. The function is called by the CrossYieid contract. cross-yield/contracts/strategies/StrategyCakeLP.sol#L225-L231 function deposit() public override whenNotPaused { uint256 farmingTokenBalance = balanceOfFarmingToken(); if (farmingTokenBalance > 0) { IMasterChef(masterchef).deposit(poolId, farmingTokenBalance); } } cross-yield/contracts/strategies/StrategyCake.sol#L169-L175 function deposit() public override whenNotPaused { uint256 farmingTokenBalance = balanceOfFarmingToken(); if (farmingTokenBalance > 0) { IMasterChef(masterchef).enterStaking(farmingTokenBalance); } }",
        "labels": [
            "SlowMist",
            "Cross Yield V1.0.0",
            "Type: Authority Control Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Excessive authority issue 25",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Yield V1.0.0_en-us.pdf",
        "body": "Owner can modify the address of the strategy. The new strategy may have security risks if it is not audited, which will aect the user's funds. If the private key is leaked, it will aect the user's funds. cross-yield/contracts/core/CrossYield.sol#L224-L236 function upgradeStrategy() public onlyOwner { require(stratCandidate.strategy != address(0), \"No proposal exists\"); require(block.number > stratCandidate.proposedBlock + stratUpgradableAfter, \"Strategy cannot be replaced yet\"); emit NewStrategy(stratCandidate.strategy); strategy.retireStrategy(); strategy = IStrategy(stratCandidate.strategy); stratCandidate.strategy = address(0); stratCandidate.proposedBlock = 0; putFundsToWork(); } cross-yield/contracts/core/CrossYield.sol#L211-L220 function proposeStrategy(address _strategy) public onlyOwner { require(address(this) == IStrategy(_strategy).vault(), \"Invalid new strategy\"); stratCandidate = StrategyCandidate({ strategy: _strategy, proposedBlock: block.number }); emit NewStratCandidate(_strategy); }",
        "labels": [
            "SlowMist",
            "Cross Yield V1.0.0",
            "Type: Authority Control Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Repeatable claims issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Yield V1.0.0_en-us.pdf",
        "body": "After the claim, lottery.status is not set as claimed, and it is also necessary to check whether lotteryId has been claimed when the claim is executed. hotdrop/contracts/HotDrop.sol#L261-L274 function claim(uint256 lotteryId) external nonReentrant { Lottery storage lottery = lotteries[lotteryId]; require(lottery.status == Status.WinnerDrawn, \"winner not drawn\"); // if there is no winner transfer the total amount to the treasury if(tickets[lotteryId][lottery.winningNumber] == address(0)) { lottery.purchaseToken.safeTransfer(treasury, lottery.purchaseToken.balanceOf(address(this))); } else if(tickets[lotteryId][lottery.winningNumber] == _msgSender()) { // if the ticket is the winning ticket and belongs to the user then split the pot uint256 treasuryAmount = (lottery.totalRaised * lottery.treasuryFee) / FEE_BASE; lottery.purchaseToken.safeTransfer(treasury, treasuryAmount); lottery.purchaseToken.safeTransfer(_msgSender(), lottery.totalRaised - treasuryAmount); } }",
        "labels": [
            "SlowMist",
            "Cross Yield V1.0.0",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Round plan security reminder",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Yield V1.0.0_en-us.pdf",
        "body": "And the new round of lottery can only be opened when the last round of lottery is in WinnerDrawn, otherwise randomGenerator.latestLotteryId will be updated, which will cause the old lottery round to fail to execute drawWinner function due to this check. require(lotteryId == randomGenerator.latestLotteryId(), \"numbers not drawn\"); hotdrop/contracts/HotDrop.sol#L44-L256 function drawWinner(uint256 lotteryId) external nonReentrant { Lottery storage lottery = lotteries[lotteryId]; require(lottery.status == Status.Close, \"lottery still active\"); require(lotteryId == randomGenerator.latestLotteryId(), \"numbers not drawn\"); // get the winning number based on the randomResult generated by ChainLink's fallback uint256 winningNumber = randomGenerator.randomResult(); lottery.winningNumber = winningNumber; lottery.status = Status.WinnerDrawn; emit LotteryNumberDrawn(lotteryId, winningNumber); }",
        "labels": [
            "SlowMist",
            "Cross Yield V1.0.0",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Re-initialize issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cook Distribution and Reward_en-us.pdf",
        "body": "In RewardVesting contract, the Governance role can re-initialize the the contract through initialize function Location function initialize(IERC20 _cookReward) external onlyGovernance { cookReward = _cookReward; }",
        "labels": [
            "SlowMist",
            "Cook Distribution and Reward",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing authority check 7",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cook Distribution and Reward_en-us.pdf",
        "body": "The addEarning function exists in the RewardVesting contract. When the claim operation is performed in the StakingPool contract, if the corresponding reward needs to be time locked, the addEarning function of the RewardVesting contract will be called to perform the locking operation. However, the visibility of this function is external, which will cause any user to perform the addEarning operation.  function addEarning(address user, uint256 amount, uint256 durationInSecs) external { _addPendingEarning(user, amount, durationInSecs); cookReward.safeTransferFrom(msg.sender, address(this), amount); }",
        "labels": [
            "SlowMist",
            "Cook Distribution and Reward",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "4.3.1.1 Risk of repeated contract initialization",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SmoothyV1_en-us.pdf",
        "body": "In the SmoothyMasterV1 contract, the owner can initialize the contract through the initialize function to set the address of key parameters such as SMTYToken, startTime, and communityAddr. However, there is no restriction on the initialize function to prevent repeated initialization calls, which will cause the owner role to repeatedly initialize the contract through the initialize function. The same goes for VotingEscrow and SmoothyV1 contracts. Fix suggestion: It is suggested to restrict the initialization function that does not allow repeated calls. ",
        "labels": [
            "SlowMist",
            "SmoothyV1",
            "Severity: High"
        ]
    },
    {
        "title": "4.3.2.1 Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SmoothyV1_en-us.pdf",
        "body": "In the SMTYToken contract, the minter role can mint tokens arbitrarily through the mint function. The owner role can arbitrarily modify the minter role address through the changeMinter function, which 10 will lead to the risk of excessive owner authority. Fix suggestion: It is suggested to transfer the owner authority to community governance. ",
        "labels": [
            "SlowMist",
            "SmoothyV1",
            "Severity: Medium"
        ]
    },
    {
        "title": "4.3.2.2 Denial of Service Risk",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SmoothyV1_en-us.pdf",
        "body": "In the SmoothyMasterV1 contract, the user can update all pools through the massUpdatePools function, but it uses the for loop to update cyclically. If the number of pools exceeds too much, it will cause a DoS risk. Fix suggestion: It is suggested to limit the number of pools to avoid this problem. function massUpdatePools() public { uint256 length = poolInfo.length; for (uint256 pid = 0; pid < length; ++pid) { updatePool(pid); } } Fix status: No Fixed. 11",
        "labels": [
            "SlowMist",
            "SmoothyV1",
            "Severity: Medium"
        ]
    },
    {
        "title": "4.3.3.1 The lockDuration does not match the lockEnd",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SmoothyV1_en-us.pdf",
        "body": "In the SmoothyMasterV1 contract, the user can extend the mortgage lock period through the extendLock function. When reconfirming the lockDuration, take the new lock duration and the smaller value of MAX_TIME, but in the end, when determining the lockEnd, the _end parameter is still directly passed in. Assigned to lockEnd, if the new lock duration is greater than MAX_TIME, this will cause the lockDuration to not match the lockEnd. Fix suggestion: It is suggested to recalculate lockEnd based on lockDuration. ",
        "labels": [
            "SlowMist",
            "SmoothyV1",
            "Severity: Low"
        ]
    },
    {
        "title": "4.3.3.1 Inaccurate calculation of LP amount",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SmoothyV1_en-us.pdf",
        "body": "In the SmoothyV1 contract, in order to save gas in mint, redeem, and swap operations, the 12 calculation using getMintAmount uses cached data for calculation, which will cause the final calculation result to be inconsistent with expectations. Fix suggestion: Due to project design requirements, it is suggested that the project party manually invoke the update when the update is not performed to avoid this issue. ",
        "labels": [
            "SlowMist",
            "SmoothyV1",
            "Severity: Low"
        ]
    },
    {
        "title": "4.3.4.1 The change of LP pool weights affects users' income",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SmoothyV1_en-us.pdf",
        "body": "In the SmoothyMasterV1 contract, when the Owner calls the add function and the set function to add a new pool or reset the pool weight, all LP pool weights will change accordingly. The Owner can update all pools before adjusting the weight by passing in the _withUpdate parameter with a value of true to ensure that the user's income before the pool weight is changed will not be affected by the adjustment of the pool weight, but if the value of the _withUpdate parameter is false, then All pools will not be updated before the pool weight is adjusted, which will cause the user's income to be affected before the pool weight is changed. Fix suggestion: It is suggested to force all LP pools to be updated before the weights of LP pools are adjusted to avoid the impact of user income. ",
        "labels": [
            "SlowMist",
            "SmoothyV1",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.3.4.2 Loss of precision issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SmoothyV1_en-us.pdf",
        "body": "In the SmoothyMasterV1 contract, when using the _updateWorkingAmount function to calculate the number of workingAmount users participate in mining, divide first and then multiply, which will result in loss of accuracy. Fix suggestion: It is suggested to multiply and then divide to avoid this issue ",
        "labels": [
            "SlowMist",
            "SmoothyV1",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.3.4.3 Unrecoverable issue of pool imbalance",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SmoothyV1_en-us.pdf",
        "body": "In the SmoothyV1 contract, when the user performs operations such as recharge, redemption, and exchange, the penalty mechanism will be triggered when the weight of the coin exceeds the soft cap, but the contract does not have an incentive mechanism to perform exchange operations to reduce the proportion of the token pool. If the token pool is maliciously manipulated to exceed the soft cap, it may be difficult for the token pool to return to normal due to no incentive mechanism, which will affect normal business use. 17 Fix suggestion: It is suggested to add an incentive mechanism in an unbalanced state to avoid this problem. ",
        "labels": [
            "SlowMist",
            "SmoothyV1",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.3.4.4 Risk of Potential Token Transfer Failure",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SmoothyV1_en-us.pdf",
        "body": "In the SmoothyV1 contract, when the user deposits the token, the safeTransferFrom function is used to transfer the corresponding token, and the safeTransfer function is used to transfer the token when withdrawToken. The safeTransferFrom function and safeTransfer function will check the returned success and data , If the connected token defines the return value, but does not return according to the EIP20 specification, the user will not be able to pass the check here, resulting in the tokens being unable to be transferred in or out. Fix suggestion: It is suggested that when docking new tokens, the project party should check whether its writing complies with EIP20 specifications. ",
        "labels": [
            "SlowMist",
            "SmoothyV1",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.3.4.5 Token compatibility issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SmoothyV1_en-us.pdf",
        "body": "In the SmoothyV1 contract, under the condition that each pool is stable, the exchange operation will be performed in a 1:1 manner. However, if the project is connected to a stable rebase algorithm, the number of tokens in the pool will be changed when it undergoes deflation, resulting in an unexpected 18 number of users during the exchange. Fix suggestion: It is suggested to strictly evaluate the algorithm model of stablecoins to avoid this risk when accessing stablecoins. ",
        "labels": [
            "SlowMist",
            "SmoothyV1",
            "Severity: Informational"
        ]
    },
    {
        "title": "Excessive authority issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ROTL_en-us.pdf",
        "body": "In the ROTL contract, the DEFAULT_ADMIN_ROLE can set the minter role, the minter role can mint ERC721A tokens arbitrarily and the minter role is entitled to free mint without going through each rounds. 11 ",
        "labels": [
            "SlowMist",
            "ROTL",
            "Type: Authority Control Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Pausable is not implemented",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ROTL_en-us.pdf",
        "body": "In the ROLTMint contract, it heritates the Pausable contract, but there is no pause and unpause function implemented. That means the value ot the _paused is false and can not be changed. Which will impact the __isEnable function and whenNotPaused modier. ",
        "labels": [
            "SlowMist",
            "ROTL",
            "Type: Others",
            "Severity: Low"
        ]
    },
    {
        "title": "Missing event record",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ROTL_en-us.pdf",
        "body": "1.In the ROTLMint contract, the owner role can set the _nft, _merkleRoot, _currentRound, price, maxCount, onceMaxCount, addressMaxCount, and startBlock values through the setAddress, setMerkleRoot, setRound, and setRoundInfo functions. But there are no no events logging performed. ",
        "labels": [
            "SlowMist",
            "ROTL",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Dev address setting enhancement suggestion 14",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ROTL_en-us.pdf",
        "body": "In the ROTLMint contract, the owner role can withdraw the native token through the withdraw function. If the owner is an EOA address, in a scenario where the private key is leaked, the teams revenue will be stolen. ",
        "labels": [
            "SlowMist",
            "ROTL",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Variable not used",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ROTL_en-us.pdf",
        "body": "In the ROLT contract, the contract dened the _mintContractAddress and _revealIndex value. But these two values are not assigned and can not be set. ",
        "labels": [
            "SlowMist",
            "ROTL",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Wrong slippage check issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cook Index_en-us.pdf",
        "body": "In the IssuanceModule contract, the _createTradeInfo function is used to create a structure containing trade data. Among them, it will obtain the thresholdAmounts parameter oset by slippage through the getMinAmountsOut function and the getMaxAmountsIn function. After the trade data is created, the trade operation will be executed 8 through the _executeTrade function, which will use the thresholdAmounts parameter as the minimum amounts to receive for trading on uniswap. However, since slippage check and trade execution are carried out in the same transaction, the thresholdAmounts parameter will still be aected by the last swap transaction of uniswap. Therefore, the slippage check cannot play a protective role. ",
        "labels": [
            "SlowMist",
            "Cook Index",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Logical redundancy issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cook Index_en-us.pdf",
        "body": "In the VesperWrapAdapter contract, getSpenderAddress is used to obtain the source token address of the wrap token, but the actual function logic directly returns the passed _wrappedToken parameter. This seems to be dierent from what the function comments indicate. ",
        "labels": [
            "SlowMist",
            "Cook Index",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of external calls 11",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cook Index_en-us.pdf",
        "body": "There are a large number of external calls in the IssuanceModule contract, but the external call part is not within the scope of this audit. It is necessary to pay attention to the unknown risks of external calls.",
        "labels": [
            "SlowMist",
            "Cook Index",
            "Type: Unsafe External Call Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Random can be predicted issue 15",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DODO-MiningV3 and NFT_en-us.pdf",
        "body": "The random number is uncertain when buying a ticket. However, there is no separate operation of using the redeeming tickets and determining the random number when redeeming tickets, and there is an issue that the random number can be predicted. https://github.com/DODOEX/contractV2/blob/453e323af6/contracts/DODODrops/DODODropsV2/DODODro ps.sol#L114 function buyTickets(address ticketTo, uint256 ticketAmount) payable external preventReentrant { (uint256 curPrice, uint256 sellAmount, uint256 index) = getSellingInfo(); require(curPrice > 0 && sellAmount > 0, \"CAN_NOT_BUY\"); require(ticketAmount <= sellAmount, \"TICKETS_NOT_ENOUGH\"); (uint256 payAmount, uint256 feeAmount) = IDropsFeeModel(_FEE_MODEL_).getPayAmount(address(this), ticketTo, curPrice, ticketAmount); require(payAmount > 0, \"UnQualified\"); uint256 baseBalance = IERC20(_BUY_TOKEN_).universalBalanceOf(address(this)); uint256 buyInput = baseBalance.sub(_BUY_TOKEN_RESERVE_); require(payAmount <= buyInput, \"PAY_AMOUNT_NOT_ENOUGH\"); _SELLING_AMOUNT_SET_[index] = sellAmount.sub(ticketAmount); _BUY_TOKEN_RESERVE_ = baseBalance.sub(feeAmount); IERC20(_BUY_TOKEN_).universalTransfer(_MAINTAINER_,feeAmount); _mint(ticketTo, ticketAmount); emit BuyTicket(ticketTo, payAmount, feeAmount, ticketAmount); } The owner determines the value of _REVEAL_RN_ by calling the setRevealRn function. The value of _REVEAL_RN_ will affect the result of the random number. https://github.com/DODOEX/contractV2/blob/453e323af6/contracts/DODODrops/DODODropsV2/DODODro ps.sol#L229 function setRevealRn() external onlyOwner { require(_REVEAL_RN_ == 0, \"ALREADY_SET\"); 16 _REVEAL_RN_ = uint256(keccak256(abi.encodePacked(blockhash(block.number - 1)))); emit SetReveal(); } The value of random is related to _REVEAL_RN_ , msg.sender , balanceOf(msg.sender) and curNo in REVEAL_MODE mode when users use wallets for transactions. Attackers can generate addresses and balances values to control the random number. In non-REVEAL_MODE mode, the value of random is related to _RNG_ , block.number , and gasleft . The attackers can sort transactions through pre-execution or in cooperation with miners. In this way, they can manipulate block.number and gasleft to control random numbers. https://github.com/DODOEX/contractV2/blob/453e323af6/contracts/DODODrops/DODODropsV2/DODODro ps.sol#L154-L159 function _redeemSinglePrize(address to, uint256 curNo, address referer) internal { require(block.timestamp >= _REDEEM_ALLOWED_TIME_ && _REDEEM_ALLOWED_TIME_ != 0, \"REDEEM_CLOSE\"); uint256 range; if(_IS_PROB_MODE_) { range = _PROB_INTERVAL_[_PROB_INTERVAL_.length - 1]; }else { range = _TOKEN_ID_LIST_.length; } uint256 random; if(_IS_REVEAL_MODE_) { require(_REVEAL_RN_ != 0, \"REVEAL_NOT_SET\"); random = uint256(keccak256(abi.encodePacked(_REVEAL_RN_, msg.sender, balanceOf(msg.sender).add(curNo + 1)))) % range; }else { random = IRandomGenerator(_RNG_).random(gasleft() + block.number) % range; } uint256 tokenId; if(_IS_PROB_MODE_) { uint256 i; for (i = 0; i < _PROB_INTERVAL_.length; i++) { if (random <= _PROB_INTERVAL_[i]) { break; } } require(_TOKEN_ID_MAP_[i].length > 0, \"EMPTY_TOKEN_ID_MAP\"); 17 tokenId = _TOKEN_ID_MAP_[i][random % _TOKEN_ID_MAP_[i].length]; IDropsNft(_NFT_TOKEN_).mint(to, tokenId, 1, \"\"); } else { tokenId = _TOKEN_ID_LIST_[random]; if(random != range - 1) { _TOKEN_ID_LIST_[random] = _TOKEN_ID_LIST_[range - 1]; } _TOKEN_ID_LIST_.pop(); IDropsNft(_NFT_TOKEN_).mint(to, tokenId); } emit RedeemPrize(to, tokenId, referer); }",
        "labels": [
            "SlowMist",
            "DODO-MiningV3 and NFT",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "isContract can be bypassed",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DODO-MiningV3 and NFT_en-us.pdf",
        "body": "When redeeming tickets isContract is used to determine whether the caller msg.sender is a contract. The contract is not allowed to be called, but the implementation of this check has flaws and can be bypassed. https://github.com/DODOEX/contractV2/blob/453e323af6/contracts/DODODrops/DODODropsV2/DODODro ps.sol#L135 18 function redeemTicket(uint256 ticketNum, address referer) external { require(!address(msg.sender).isContract(), \"ONLY_ALLOW_EOA\"); require(ticketNum >= 1 && ticketNum <= balanceOf(msg.sender), \"TICKET_NUM_INVALID\"); _burn(msg.sender,ticketNum); for (uint256 i = 0; i < ticketNum; i++) { _redeemSinglePrize(msg.sender, i, referer); } } https://github.com/DODOEX/contractV2/blob/453e323af6/contracts/external/utils/Address.sol#L27 function isContract(address account) internal view returns (bool) { // This method relies on extcodesize, which returns 0 for contracts in // construction, since the code is only stored at the end of the // constructor execution. uint256 size; // solhint-disable-next-line no-inline-assembly assembly { size := extcodesize(account) } return size > 0; }",
        "labels": [
            "SlowMist",
            "DODO-MiningV3 and NFT",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Excessive authority issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DODO-MiningV3 and NFT_en-us.pdf",
        "body": "The owner can control the source of the seed of the random number. The seed of the random number will affect the value of the random number and affect the probability of redeeming the ticket. 19 https://github.com/DODOEX/contractV2/blob/453e323af6/contracts/DODODrops/DODODropsV2/DODODro ps.sol#L227 function setRevealRn() external onlyOwner { require(_REVEAL_RN_ == 0, \"ALREADY_SET\"); _REVEAL_RN_ = uint256(keccak256(abi.encodePacked(blockhash(block.number - 1)))); emit SetReveal(); } The owner can change the value of _RNG_ , which will affect the random number of the redemption ticket if it is not REVEAL_MODE. https://github.com/DODOEX/contractV2/blob/453e323af6/contracts/DODODrops/DODODropsV2/DODODro ps.sol#L259 function updateRNG(address newRNG) external onlyOwner { require(newRNG != address(0)); _RNG_ = newRNG; emit ChangeRNG(newRNG); } The owner can transfer _REWARD_TOKEN_ to any address. The current design framework Owner address will be sent to the address of the Mine contract. https://github.com/DODOEX/contractV2/blob/c7202eeae7/contracts/DODOToken/DODOMineV3/RewardVau lt.sol#L38-L49 function reward(address to, uint256 amount) external onlyOwner { require(_REWARD_RESERVE_ >= amount, \"VAULT_NOT_ENOUGH\"); _REWARD_RESERVE_ = _REWARD_RESERVE_.sub(amount); IERC20(_REWARD_TOKEN_).safeTransfer(to, amount); } function withdrawLeftOver(address to,uint256 amount) external onlyOwner { require(_REWARD_RESERVE_ >= amount, \"VAULT_NOT_ENOUGH\"); 20 _REWARD_RESERVE_ = _REWARD_RESERVE_.sub(amount); IERC20(_REWARD_TOKEN_).safeTransfer(to, amount); } The owner can mint tokens for any user and burn any user's tokens. https://github.com/DODOEX/contractV2/blob/c7202eeae7/contracts/external/ERC20/CustomERC20.sol#L12 3-L138 function mint(address user, uint256 value) external onlyOwner { require(isMintable, \"NOT_MINTABEL_TOKEN\"); balances[user] = balances[user].add(value); totalSupply = totalSupply.add(value); emit Mint(user, value); emit Transfer(address(0), user, value); } function burn(address user, uint256 value) external onlyOwner { require(isMintable, \"NOT_MINTABEL_TOKEN\"); balances[user] = balances[user].sub(value); totalSupply = totalSupply.sub(value); emit Burn(user, value); emit Transfer(user, address(0), value); } The owner can update the template contract. If an unaudited template contract is updated, this will affect the assets of the new user in the newly created contract. https://github.com/DODOEX/contractV2/blob/c7202eeae7/contracts/SmartRoute/proxies/DODOMineV3Prox y.sol#L128 function updateMineV2Template(address _newMineV3Template) external onlyOwner { _MINEV3_TEMPLATE_ = _newMineV3Template; } https://github.com/DODOEX/contractV2/blob/7e629d0e58/contracts/Factory/ERC20V2Factory.sol 21 function updateStdTemplate(address newStdTemplate) external onlyOwner { _ERC20_TEMPLATE_ = newStdTemplate; emit ChangeStdTemplate(newStdTemplate); } function updateCustomTemplate(address newCustomTemplate) external onlyOwner { _CUSTOM_ERC20_TEMPLATE_ = newCustomTemplate; emit ChangeCustomTemplate(newCustomTemplate); }",
        "labels": [
            "SlowMist",
            "DODO-MiningV3 and NFT",
            "Type: Authority Control Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "The DoS risk",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DODO-MiningV3 and NFT_en-us.pdf",
        "body": "Use a for loop to traverse the array. If the number of loops is large, it will cause an out of gas. After communication and feedback, the project team will ensure that the number of rewardTokenInfos will not be too much. 22 https://github.com/DODOEX/contractV2/blob/c7202eeae7/contracts/DODOToken/DODOMineV3/BaseMine.s ol#L258 function _updateAllReward(address user) internal { uint256 len = rewardTokenInfos.length; for (uint256 i = 0; i < len; i++) { _updateReward(user, i); } }",
        "labels": [
            "SlowMist",
            "DODO-MiningV3 and NFT",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Event log missing",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DODO-MiningV3 and NFT_en-us.pdf",
        "body": "The owner can arbitrarily set an external contract address as a template contract. When a user creates a new contract, it will be created based on the template contract. After creation, the asset needs to be recharged to the new contract. There is no event record, which is unfavorable for review by community users. https://github.com/DODOEX/contractV2/blob/c7202eeae7/contracts/SmartRoute/proxies/DODOMineV3Prox y.sol#L128 function updateMineV2Template(address _newMineV3Template) external onlyOwner { _MINEV3_TEMPLATE_ = _newMineV3Template; } The owner can modify the configuration of the contract, but there is no event record, which is unfavorable for review by community users. 23 https://github.com/DODOEX/contractV2/blob/c7202eeae7/contracts/Factory/Registries/DODOMineV3Registr y.sol#L87-L101 function addAdminList (address contractAddr) external onlyOwner { isAdminListed[contractAddr] = true; } function removeAdminList (address contractAddr) external onlyOwner { isAdminListed[contractAddr] = false; } function addSingleTokenList(address token) external onlyOwner { singleTokenList[token] = true; } function removeSingleTokenList(address token) external onlyOwner { singleTokenList[token] = false; }",
        "labels": [
            "SlowMist",
            "DODO-MiningV3 and NFT",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Check enhancement of isLpToken",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DODO-MiningV3 and NFT_en-us.pdf",
        "body": "Admin can add non-LPtoken assets but isLpToken is True, or belong to LPtoken assets but isLpToken is False Pool, which will affect the actual business logic. This part of the inspection is not implemented in the contract. https://github.com/DODOEX/contractV2/blob/c7202eeae7/contracts/Factory/Registries/DODOMineV3Registr y.sol#L44 function addMineV3( address mine, 24 bool isLpToken, address stakeToken ) override external { require(isAdminListed[msg.sender], \"ACCESS_DENIED\"); _MINE_REGISTRY_[mine] = stakeToken; if(isLpToken) { _LP_REGISTRY_[stakeToken] = mine; }else { require(_SINGLE_REGISTRY_[stakeToken].length == 0 || singleTokenList[stakeToken], \"ALREADY_EXSIT_POOL\"); _SINGLE_REGISTRY_[stakeToken].push(mine); } emit NewMineV3(mine, stakeToken, isLpToken); }",
        "labels": [
            "SlowMist",
            "DODO-MiningV3 and NFT",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Security reminder on architecture design",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DODO-MiningV3 and NFT_en-us.pdf",
        "body": "createStdERC20 and createMintableERC20 are open-ended calls. The user creates a contract using the createStdERC20 function to record the created information in _USER_STD_REGISTRY_ , and then can get the information through getTokenByUser. Because it is an open call, it is not recommended to use the data obtained by getTokenByUser. As input for other businesses, after communication and feedback, the project party will not rely on the data obtained by getTokenByUser in the business logic of the project. https://github.com/DODOEX/contractV2/blob/c7202eeae7/contracts/Factory/ERC20V2Factory.sol#L72-L123 function createStdERC20( uint256 totalSupply, string memory name, 25 string memory symbol, uint256 decimals ) external returns (address newERC20) { newERC20 = ICloneFactory(_CLONE_FACTORY_).clone(_ERC20_TEMPLATE_); IStdERC20(newERC20).init(msg.sender, totalSupply, name, symbol, decimals); _USER_STD_REGISTRY_[msg.sender].push(newERC20); emit NewERC20(newERC20, msg.sender, 0); } function createCustomERC20( uint256 initSupply, string memory name, string memory symbol, uint256 decimals, uint256 tradeBurnRatio, uint256 tradeFeeRatio, address teamAccount, bool isMintable ) external returns (address newCustomERC20) { newCustomERC20 = ICloneFactory(_CLONE_FACTORY_).clone(_CUSTOM_ERC20_TEMPLATE_); ICustomERC20(newCustomERC20).init( msg.sender, initSupply, name, symbol, decimals, tradeBurnRatio, tradeFeeRatio, teamAccount, isMintable ); _USER_CUSTOM_REGISTRY_[msg.sender].push(newCustomERC20); if(isMintable) emit NewERC20(newCustomERC20, msg.sender, 2); else emit NewERC20(newCustomERC20, msg.sender, 1); } // ============ View ============ function getTokenByUser(address user) external 26 view returns (address[] memory stds,address[] memory customs) { return (_USER_STD_REGISTRY_[user], _USER_CUSTOM_REGISTRY_[user]); }",
        "labels": [
            "SlowMist",
            "DODO-MiningV3 and NFT",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Pages calculation issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SubDao_en-us.pdf",
        "body": "In the DaoFactory contract, calculatePages is used to calculate the start index and end index of a page. The size, start index and end index are checked in the function size <= 0 || start >= total || start < end , but in fact, size should not be less than 0, and start should not be greater than total. ",
        "labels": [
            "SlowMist",
            "SubDao",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Missing event records",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SubDao_en-us.pdf",
        "body": "In the DaoTemplate contract, the user can modify the actionCong parameter through the setActionCong function, but no event recording is performed. The same is true for the setActionCong function in the VentureTemplate contract. The same is true for the setCanFreeAddMember, transferOwner and updateOwnership functions in the OrgManager contract. ",
        "labels": [
            "SlowMist",
            "SubDao",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Owner update issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SubDao_en-us.pdf",
        "body": "In the DaoTemplate contract, the owner can update the owner of all components through the updateOwnership function. But it calls the updateOwnership interface of the templateCong contract by mistake. The same is true for the updateOwnership function in the VentureTemplate contract. ",
        "labels": [
            "SlowMist",
            "SubDao",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "State Coverage Risk",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SubDao_en-us.pdf",
        "body": "In the GrantMethodManager contract, DaoTemplate can operate the applyOp and setUserOpByOwner functions through the action contract. Since the parameters it receives are all passed in from the outside, if the incoming data is repeated, the encoded key will be repeated, which will cause the existing data to be overwritten. ",
        "labels": [
            "SlowMist",
            "SubDao",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "TODO label issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SubDao_en-us.pdf",
        "body": "There is still a TODO label in the spendTokenInLimit function of the GrantMethodManager contract. Is there still a function not perfect? The same is true for the _unsafeCancelVote function in the VoteManager contract. ",
        "labels": [
            "SlowMist",
            "SubDao",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Length check issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SubDao_en-us.pdf",
        "body": "The initialize function exists in the VenturesStockManager , VenturesManager and GovTokenManager contracts to initialize the contract according to the incoming parameters. It checks the byte length of the incoming parameter, but because some parameters are variable-length data, forcing an equals check will lead to unsuccessful initialization. ",
        "labels": [
            "SlowMist",
            "SubDao",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Vote check issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SubDao_en-us.pdf",
        "body": "In the VoteManager contract, the _canExecute function is used to check whether the proposal can be executed, but it does not check whether the number of yes votes is greater than the number of negative votes. ",
        "labels": [
            "SlowMist",
            "SubDao",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Cancel voting issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SubDao_en-us.pdf",
        "body": "29 In the VoteManager contract, the _canCancel function user checks whether the current vote can be cancelled. If the voting period for a proposal has passed, but the execution conditions are still not met, the proposal cannot be executed or cancelled. ",
        "labels": [
            "SlowMist",
            "SubDao",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Risk of Governance Attacks",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SubDao_en-us.pdf",
        "body": "DAO members can create new proposals through ActionVoteNew , ActionGrantMethodRegister , ActionVoteTransferPeriodRegister and other contracts. However, the proposal does not contain the data that needs to be executed. After the proposal is passed, the community members will pass in the specic execution data for execution. If malicious data is passed in, there is a risk that the protocol will be maliciously broken during proposal execution.",
        "labels": [
            "SlowMist",
            "SubDao",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Potential Fund Theft Risk",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SubDao_en-us.pdf",
        "body": "As mentioned in N12, when a DAO member creates an Operation through ActionGrantMethodRegister, the user's specic execution data is not recorded in the newVote operation. Although registerOp records the extra data passed in by the user, it is not used op_.extra in actual execution. Therefore, the user can pass in valid execution data when performing the registerOp operation. And malicious data is passed in during the ActionVaultUniswapV2Router02Swap operation. This will result in funds managed by the DAO being approved for malicious router contracts, or swapping through extremely illiquid pools, allowing malicious users to easily arbitrage. This would create huge risks for DAOs. The same is true in the ActionVaultUniswapV2SwapToken contract. ",
        "labels": [
            "SlowMist",
            "SubDao",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Lack of access control",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SubDao_en-us.pdf",
        "body": "In the VenturesManager contract, the gpRaiseMoney and lpRaiseMoney functions are not restricted to be called by the owner. ",
        "labels": [
            "SlowMist",
            "SubDao",
            "Type: Authority Control Vulnerability",
            "Severity: High"
        ]
    },
    {
        "title": "Period transfer issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SubDao_en-us.pdf",
        "body": "In the ActionVoteTransferPeriodApply contract, when performing a period transfer, the period will be obtained through the transferPeriodStates function of the VoteExecutionManager contract, and then the period will be transferred through the transferVenturePeriod function of the VenturesManager contract. But in the current action, period is directly transferred to SettlementPeriod. ",
        "labels": [
            "SlowMist",
            "SubDao",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - X2Y2 - NFT Lending_en-us.pdf",
        "body": "1.In the Cong contract, the owner role can add manager role and can update the adminShare, and the manager role can set or remove the ERC20 and ERC721 tokens through the setERC20Permits and setERC721Permits functions. If the ERC20 and ERC721 on the loan list, the manager sets these permit as false may cause the risk of excessive authority. ",
        "labels": [
            "SlowMist",
            "X2Y2 - NFT Lending",
            "Type: Authority Control Vulnerability",
            "Severity: High"
        ]
    },
    {
        "title": "Token compatibility issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - X2Y2 - NFT Lending_en-us.pdf",
        "body": "In the XY3 contract, the lender will transfer the ERC20 token to the borrower in the borrow function also to the lender and adminFeeReceiver in the repay function. And this transfer is used the SafeER20 safeTransferFrom function and transfer the exact amount of the borrowAmount, payoAmount and adminFee. If the borrowAsset ERC20 tokens are the deationary tokens (or other tokens that require a transfer fee) which will cause the call failed. ",
        "labels": [
            "SlowMist",
            "X2Y2 - NFT Lending",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Dev address setting enhancement suggestions",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - X2Y2 - NFT Lending_en-us.pdf",
        "body": "In the Cong contract, the manager role can update the adminFeeReceiver in the updateAdminFeeReceiver function to receive the adminFee. If the adminFeeReceiver address is an EOA address, in a scenario where the private key is leaked, the teams revenue will be stolen. ",
        "labels": [
            "SlowMist",
            "X2Y2 - NFT Lending",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "The deationary token docking issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - CakeVault_en-us.pdf",
        "body": "Users can transfer the cake token into the vault contract through the deposit function. Under normal circumstances, the number of staking tokens transferred by the user is the same as the _amount parameter passed in. But if the staking token is a deationary token, the number of tokens transferred by the user may be dierent from the number of tokens actually received in the contract. ",
        "labels": [
            "SlowMist",
            "CakeVault",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "CakeAtLastUserAction parameter record error issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - CakeVault_en-us.pdf",
        "body": "In the Vault contract, the user can withdraw the funds staked by the user through the withdraw function. If the user does not withdraw all funds (user.shares> 0), this function will recalculate the user's cakeAtLastUserAction value. In the calculation process, the number of cake tokens obtained by the balanceOf function is used to participate in the calculation. But at the end of this function, a certain amount of cake tokens will be transferred to the user through the safeTransfer function, so the number of cake tokens obtained by the balanceOf function used in the calculation of cakeAtLastUserAction is relatively large. ",
        "labels": [
            "SlowMist",
            "CakeVault",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing event records",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - CakeVault_en-us.pdf",
        "body": "In the contract, the owner role can set the addresses of the admin role and the treasure role through the setAdmin function and the setTreasury function, respectively, but no event recording is performed. In the contract, the admin role can change the sensitive parameters of the contract through the setPerformanceFee, setCallFee, setWithdrawFee, and setWithdrawFeePeriod functions, but no event recording is performed. ",
        "labels": [
            "SlowMist",
            "CakeVault",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Emergency withdrawal issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - CakeVault_en-us.pdf",
        "body": "In the Vault contract, the admin role can make emergency withdrawals of cake tokens from the MasterChef contract to the Vault contract via the emergencyWithdraw function. However, it should be noted that any user can obtain 0.25% of the cake token reward in the Vault contract through the harvest function, and re-stake the remaining cake tokens into the MasterChef contract. So if the emergencyWithdraw operation is performed while the contract is not suspended it may cause unintended results. 10 ",
        "labels": [
            "SlowMist",
            "CakeVault",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Partial logic not implemented",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Das Contract Reverse_en-us.pdf",
        "body": "In the setReverseName function of the ReverseLogic contract, after the previous check, the specic check logic when the owner is still 0 address is not implemented. ",
        "labels": [
            "SlowMist",
            "Das Contract Reverse",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Potential risk of arbitrarily setting reverse name",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Das Contract Reverse_en-us.pdf",
        "body": "In the ReverseLogic contract, the user can set the reverse name through the setReverseName function, which allows the contract to set itself. However, some contracts have the feature of arbitrary external calls, which will allow any user to set the reverse name of the contract. ",
        "labels": [
            "SlowMist",
            "Das Contract Reverse",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "4.2.1.1 The settleHolderInterest is not used to update user interest before Withdraw",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - dFuture_en-us.pdf",
        "body": "The code uses payOffInterest to process the user's interest when processing the user's withdraw, but it did not use settleHolderInterest to update the user's interest situation before, resulting in a deviation in the interest payment. ",
        "labels": [
            "SlowMist",
            "dFuture",
            "Severity: Low"
        ]
    },
    {
        "title": "4.2.1.2 The global status is not updated when using the getMarginRatioOf function",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - dFuture_en-us.pdf",
        "body": "to calculate the user's position When using the getMarginRationOf function to calculate the user's position, the global state is not updated with updateGlobalInterestRate first, which may cause calculation errors. ",
        "labels": [
            "SlowMist",
            "dFuture",
            "Severity: Low"
        ]
    },
    {
        "title": "4.2.1.3 When calculating the user's position,",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - dFuture_en-us.pdf",
        "body": "the user's intereset <0 is not considered When using the getMarginRationOf function to calculate the user's position, the case of rate <0 is not 22 processed. ",
        "labels": [
            "SlowMist",
            "dFuture",
            "Severity: Low"
        ]
    },
    {
        "title": "4.2.2.1 did not consider the issue of system compensation, and did not limit the",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - dFuture_en-us.pdf",
        "body": "maximum benefits of users The system code does not consider whether the system can pay for this when processing the user's position closing. When this happens, it will cause an unknown error. ",
        "labels": [
            "SlowMist",
            "dFuture",
            "Severity: Low"
        ]
    },
    {
        "title": "Missing Checking",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap_en-us.pdf",
        "body": "In PancakeSwapRouter contract, the removeLiquidity / removeLiquidityETH / removeLiquidityWithPermit function does not check whether a pair is exist, which will leads to gas wasting when a pair does not exist. eg. removeLiquidity function function removeLiquidity( address tokenA, address tokenB, uint liquidity, uint amountAMin, uint amountBMin, address to, uint deadline ) public virtual override ensure(deadline) returns (uint amountA, uint amountB) { 13 address pair = PancakeLibrary.pairFor(factory, tokenA, tokenB); IPancakePair(pair).transferFrom(msg.sender, pair, liquidity); // send liquidity to pair (uint amount0, uint amount1) = IPancakePair(pair).burn(to); (address token0,) = PancakeLibrary.sortTokens(tokenA, tokenB); (amountA, amountB) = tokenA == token0 ? (amount0, amount1) : (amount1, amount0); require(amountA >= amountAMin, 'PancakeRouter: INSUFFICIENT_A_AMOUNT'); require(amountB >= amountBMin, 'PancakeRouter: INSUFFICIENT_B_AMOUNT'); }",
        "labels": [
            "SlowMist",
            "PancakeSwap",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Open Social - Abstract Account_en-us.pdf",
        "body": "1.In the VerifyingSingletonPaymaster contract, the DEFAULT_ADMIN_ROLE can arbitrarily set the unaccountedEPGasOverhead parameters. If this parameter is set too high, paymasterIdBalances may be consumed maliciously. ",
        "labels": [
            "SlowMist",
            "Open Social - Abstract Account",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Ordinary users with permitCalls may use the owner privilege through arbitrary contract calls",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Open Social - Abstract Account_en-us.pdf",
        "body": "The execute and executeBatch functions allow ordinary users to call the contracts which in the permitCalls with arbitrary calldata, can control their native token or ERC20 token assets by these functions. However, this functionality can be abused and users calling the contract itself (OspAccount) through the EntryPoint contract will then be able to call functions like setOwner, setRecoveryAddress, setPermitCall, and revokeSessionKey functions, thus overstepping their authority. ",
        "labels": [
            "SlowMist",
            "Open Social - Abstract Account",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing the event records",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Open Social - Abstract Account_en-us.pdf",
        "body": "In the WhitelistOperationVerifyingPaymaster and the OspAccountFactory contracts, the ADMIN and DEFAULT_ADMIN_ROLE can arbitrarily modify OperationInPut , enableWhitelistOperation , and accountImplementation parameters, but there are no event logs in these functions. ",
        "labels": [
            "SlowMist",
            "Open Social - Abstract Account",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing zero address validation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Open Social - Abstract Account_en-us.pdf",
        "body": "In the OspAccount and the OspAccountFactory contracts, it lacks a zero-check when setting addresses. ",
        "labels": [
            "SlowMist",
            "Open Social - Abstract Account",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "ERC777 reentrancy risk reminder",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Open Social - Abstract Account_en-us.pdf",
        "body": "ERC777 tokens are vulnerable to reentrancy attacks due to a design aw. In the TokenCallbackHandler contract, the deprecated ERC777 standard tokensReceived has been introduced into the contract. If there is any need to deal with ERC77 tokens in the project, strict attention needs to be paid to whether there is reentrancy risk. ",
        "labels": [
            "SlowMist",
            "Open Social - Abstract Account",
            "Type: Unsafe External Call Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing event log",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Arowana_en-us.pdf",
        "body": "The owner role can call the addToken and removeToken functions to add and remove the specied token address into the _addresses and _indexes . If there is no event record, it is not conducive to the review of community users. ",
        "labels": [
            "SlowMist",
            "Arowana",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing event log",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Arowana_en-us.pdf",
        "body": "7 The owner role can call the setValut function to set the source of reward token distribution. If there is no event record, it is not conducive to the review of community users. ",
        "labels": [
            "SlowMist",
            "Arowana",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing balance change",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Arowana_en-us.pdf",
        "body": "When the user calls the withdraw function for withdrawal ( block.timestap >= pool.end ), the balance of pool is not changed here. ",
        "labels": [
            "SlowMist",
            "Arowana",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Missing balance check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Arowana_en-us.pdf",
        "body": "When the user calls the withdraw function for withdrawal ( block.timestap >= pool.end ), there is a lack of judgment on the balance of valut. If the token balance of valut is not enough to pay the user's reward, the transaction will be rolled back and the user's principal and reward cannot be withdrawn. ",
        "labels": [
            "SlowMist",
            "Arowana",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Lack of access control issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning Farm - ETH Leverage_en-us.pdf",
        "body": "In the BalancerReceiver contract, the SS contract can initiate WETH ash loans through the ashLoan function, but the ashLoan function allows any user to call. Although the loanFallback function of the SS contract checks curState, it is undoubtedly more expected that the ashLoan function can only be called by the SS contract. 10 ",
        "labels": [
            "SlowMist",
            "Earning Farm - ETH Leverage",
            "Type: Authority Control Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Gas optimization",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning Farm - ETH Leverage_en-us.pdf",
        "body": "In the ETHLeverage contract, the _harvest function is used to collect fees, which will only be charged when lastEarnBlock and block.number are used. But the function does not check whether the dierence between lastEarnBlock and block.number is 0. If multiple users in the same block trigger the _harvest function, it will cause unnecessary gas consumption. ",
        "labels": [
            "SlowMist",
            "Earning Farm - ETH Leverage",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Redundant logic issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning Farm - ETH Leverage_en-us.pdf",
        "body": "In the Controller contract, the owner can set the exchange and harvestFee parameters respectively through the setExchange and setHarvestFee functions. But in this contract the exchange and harvestFee parameters are not used. ",
        "labels": [
            "SlowMist",
            "Earning Farm - ETH Leverage",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "The problem of checking the number of swaps",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning Farm - ETH Leverage_en-us.pdf",
        "body": "In the ETHLeverExchange contract, the swapExactETH function is used to exchange stETH to ETH during emergency withdrawal. It will get the amount of ETH that can be exchanged through the get_dy function and check if the swap amount is larger than the expected required amount. But in theory it is acceptable for the number of swaps to be equal to what is expected to be required. ",
        "labels": [
            "SlowMist",
            "Earning Farm - ETH Leverage",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning Farm - ETH Leverage_en-us.pdf",
        "body": "In the protocol, the owner role has many permissions, such as: the owner can set sensitive parameters, can suspend the contract, can make emergency withdrawals, can migrate the funds of the SS contract, etc. It is obviously inappropriate to give all the permissions of the protocol to the owner, which will greatly increase the single point of 13 risk.",
        "labels": [
            "SlowMist",
            "Earning Farm - ETH Leverage",
            "Type: Authority Control Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Risk of exchange slippage",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning Farm - ETH Leverage_en-us.pdf",
        "body": "When users make withdrawals in the protocol, they need to exchange stETH tokens for ETH tokens through CurvePool. However, the exchange slippage is not limited in the ETHLeverExchange contract, which will make users vulnerable to sandwich attacks when withdrawing. ",
        "labels": [
            "SlowMist",
            "Earning Farm - ETH Leverage",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Medium Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Ultiverse - Chips Contract_en-us.pdf",
        "body": "1.In the GoldChip contract, the owner role can modify key sensitive parameters such as the burnable status, the _baseTokenURI , and granting or revoking roles, which will lead to the risk of over-privilege of the owner role. ",
        "labels": [
            "SlowMist",
            "Ultiverse - Chips Contract",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Low-level call reminder",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Ultiverse - Chips Contract_en-us.pdf",
        "body": "In the ChipStakingPool contract, the contract uses low-level calls and does not limit the amount of gas used to transfer native tokens to users. ",
        "labels": [
            "SlowMist",
            "Ultiverse - Chips Contract",
            "Type: Others",
            "Severity: Information"
        ]
    },
    {
        "title": "Potential overow risks caused by type conversion",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Ultiverse - Chips Contract_en-us.pdf",
        "body": "In the ChipStakingPool contract, users can deposit the native tokens to gain the Lots. The deposit function uses a type conversion to convert the uint256 type values such as quantity, availableGoldLots, and availableSilverLots to the uint64 type. If the user passes in a quantity greater than uint64, this will cause the overow when converting the data to uint256. ",
        "labels": [
            "SlowMist",
            "Ultiverse - Chips Contract",
            "Type: Arithmetic Accuracy Deviation Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Refund lock reminder",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Ultiverse - Chips Contract_en-us.pdf",
        "body": "In the ChipStakingPool contract, users can deposit native tokens to get Lots and claim refunds to get the native back. When calling these two functions, these two functions will check the MerkleProof signed by the central. The claimRefund function will also check whether the user claimed before by checking the userRefundCount[_msgSender()] is larger than 0. If the signed MerkleProof quantity is not the same as the users deposit. There will be a situation where the user will not be able to call the claimRefund function again to withdraw native tokens after claiming refunds once. ",
        "labels": [
            "SlowMist",
            "Ultiverse - Chips Contract",
            "Type: Design Logic Audit",
            "Severity: Information"
        ]
    },
    {
        "title": "Transaction reordering issues",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - wault.finance(WUSD)_en-us.pdf",
        "body": "(1) In commit: 91c541c2f1c0ac781ddcfb2be6a62555a5e1e8d1, the swapExactTokensForTokensSupportingFeeOnTransferTokens in the stake function is not checked for slippage. https://github.com/WaultFinance/WUSD/blob/91c541c2f/WUSDMaster.sol#L716-L722 function stake(uint256 amount) external nonReentrant { require(amount > 0, 'amount cant be zero'); require(wusdClaimAmount[msg.sender] == 0, 'you have to claim first'); require(amount <= maxStakeAmount, 'amount too high'); usdt.safeTransferFrom(msg.sender, address(this), amount); if(feePermille > 0) { uint256 feeAmount = amount * feePermille / 1000; usdt.safeTransfer(treasury, feeAmount); amount = amount - feeAmount; } uint256 wexAmount = amount * wexPermille / 1000; usdt.approve(address(wswapRouter), wexAmount); wswapRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens( wexAmount, 0, swapPath, address(this), block.timestamp ); wusdClaimAmount[msg.sender] = amount; wusdClaimBlock[msg.sender] = block.number; emit Stake(msg.sender, amount); } 9 (2) In commit: de61d93cd7a35213484827cf32533919c34e732e amountOutMin is the parameter that limits the slippage, but it is entered by the user, the maxStakeAmount is added, but this limit can still be bypassed by sorting multiple transactions. https://github.com/WaultFinance/WUSD/blob/de61d93cd7a35213484827cf32533919c34e732e/WUSDMas ter.sol#L808-L834 function stake(uint256 amount, uint256 amountOutMin) external nonReentrant whenNotPaused { require(amount > 0, 'amount cant be zero'); require(wusdClaimAmount[msg.sender] == 0, 'you have to claim first'); require(amount <= maxStakeAmount, 'amount too high'); usdt.safeTransferFrom(msg.sender, address(this), amount); if(feePermille > 0) { uint256 feeAmount = amount * feePermille / 1000; usdt.safeTransfer(treasury, feeAmount); amount = amount - feeAmount; } wusd.mint(address(this), amount); uint256 wexAmount = amount * wexPermille / 1000; usdt.approve(address(wswapRouter), wexAmount); wswapRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens( wexAmount, amountOutMin, swapPath, address(this), block.timestamp ); wusdClaimAmount[msg.sender] = amount; wusdClaimBlock[msg.sender] = block.number; emit Stake(msg.sender, amount); } (3) In commit: 5f50a2c77828c70299e8a9217cfbb926b8c1, the maxStakePerBlock is added, but this limit can still be bypassed by sorting multiple transactions in multiple blocks. 10 https://github.com/WaultFinance/WUSD/blob/5f50a2c77828c70299e8a9217cfbb926b8c1/WUSDMaster. sol#L819-L851 function stake(uint256 amount, uint256 amountOutMin) external nonReentrant whenNotPaused { require(amount > 0, 'amount cant be zero'); require(wusdClaimAmount[msg.sender] == 0, 'you have to claim first'); require(amount <= maxStakeAmount, 'amount too high'); if(lastBlock != block.number) { lastBlockUsdtStaked = 0; lastBlock = block.number; } lastBlockUsdtStaked += amount; require(lastBlockUsdtStaked <= maxStakePerBlock, 'maximum stake per block exceeded'); usdt.safeTransferFrom(msg.sender, address(this), amount); if(feePermille > 0) { uint256 feeAmount = amount * feePermille / 1000; usdt.safeTransfer(treasury, feeAmount); amount = amount - feeAmount; } wusd.mint(address(this), amount); uint256 wexAmount = amount * wexPermille / 1000; usdt.approve(address(wswapRouter), wexAmount); wswapRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens( wexAmount, amountOutMin, swapPath, address(this), block.timestamp ); wusdClaimAmount[msg.sender] = amount; wusdClaimBlock[msg.sender] = block.number; emit Stake(msg.sender, amount); }",
        "labels": [
            "SlowMist",
            "wault.finance(WUSD)",
            "Type: Reordering Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Helio Money_en-us.pdf",
        "body": "Owner or special administrator accounts can operate the key functions. - auth auth auth auth auth auth auth auth - - auth auth auth - auth auth CeToken burn CeToken mint CeToken changeVault hBNB hBNB hBNB burn mint changeMinter HelioProvider liquidation HelioProvider daoBurn HelioProvider daoMint HelioProvider changeDao HelioProvider changeCeToken HelioProvider changeProxy HelioProvider changeCollateralToken HelioProvider changeOperator CerosRouter changeVault CerosRouter changeDex CerosRouter changePool CerosRouter changeProvider OwnableUpgradeable renounceOwnership OwnableUpgradeable transferOwnership CeVaultV2 updateStorage MasterVault _updateCerosStrategyDebt MasterVault depositAllToStrategy MasterVault depositToStrategy MasterVault withdrawFromStrategy MasterVault withdrawAllFromStrategy MasterVault setStrategy MasterVault retireStrat MasterVault migrateStrategy MasterVault withdrawFee MasterVault setDepositFee MasterVault setWithdrawalFee MasterVault addManager MasterVault removeManager MasterVault changeProvider MasterVault changeFeeReceiver MasterVault changeStrategyAllocation WaitingPool addToQueue WaitingPool tryRemove WaitingPool setCapLimit SlidingWindowOracle _authorizeUpgrade UUPSUpgradeable upgradeTo UUPSUpgradeable upgradeToAndCall PriceOracleTestnet _authorizeUpgrade PriceOracle _authorizeUpgrade BaseStrategy setStrategist BaseStrategy setRewards BnbxYieldConverterStrategy changeStakeManager CerosYieldConverterStrategy changeBinancePool CerosYieldConverterStrategy changeCeRouter EmergencyShutdown setMultiSig Ownable renounceOwnership Ownable transferOwnership Interaction addToWhitelist Interaction removeFromWhitelist Jar Jar Jar replenish setSpread setExitDelay",
        "labels": [
            "SlowMist",
            "Helio Money",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Sandwich attacks can aect slippage scope",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Helio Money_en-us.pdf",
        "body": "contracts/ceros/CerosRouter.sol function deposit() external payable override nonReentrant returns (uint256 value) { //...snip code...// uint256[] memory outAmounts = _dex.getAmountsOut(amount, path); //...snip code...// uint256[] memory amounts = _dex.swapExactETHForTokens{ value: amount }(dexABNBcAmount, path, address(this), block.timestamp + 300); realAmount = amounts[1]; //...snip code...// } function withdrawWithSlippage( address recipient, uint256 amount, uint256 outAmount ) external override nonReentrant returns (uint256 realAmount) { //...snip code...// uint256[] memory amounts = _dex.swapExactTokensForETH( realAmount, outAmount, path, recipient, block.timestamp + 300 ); //...snip code...// } Sandwich attacks, also known as MEV attacks, refer to attackers using the transaction order and execution results on the blockchain to gain additional value. This type of attack is usually carried out by miners or transaction order executors, who can gain additional value by reordering transactions or selectively including or excluding them.",
        "labels": [
            "SlowMist",
            "Helio Money",
            "Type: Reordering Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Ratio arbitrage attack vulnerability",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Helio Money_en-us.pdf",
        "body": "contracts/ceros/CeVault.sol contracts/ceros/upgrades/CeVaultV2.sol function _deposit(address account, uint256 amount) private returns (uint256) { uint256 ratio = _aBNBc.ratio(); _aBNBc.transferFrom(msg.sender, address(this), amount); uint256 toMint = (amount * 1e18) / ratio; //SlowMist// _depositors[account] += amount; // aBNBc _ceTokenBalances[account] += toMint; // mint ceToken to recipient ICertToken(_ceToken).mint(account, toMint); emit Deposited(msg.sender, account, toMint); return toMint; } function _withdraw( address owner, address recipient, uint256 amount ) private returns (uint256) { uint256 ratio = _aBNBc.ratio(); uint256 realAmount = (amount * ratio) / 1e18;//SlowMist// require( _aBNBc.balanceOf(address(this)) >= realAmount, \"not such amount in the vault\" ); uint256 balance = _ceTokenBalances[owner]; require(balance >= amount, \"insufficient balance\"); _ceTokenBalances[owner] -= amount; // BNB // burn ceToken from owner ICertToken(_ceToken).burn(owner, amount); _depositors[owner] -= realAmount; // aBNBc _aBNBc.transfer(recipient, realAmount); emit Withdrawn(owner, recipient, realAmount); return realAmount; } Here we can see that the amount of deposit and withdraw is related to the ratio. We can query the implementation of the ratio from the call chain: _aBNBc: function ratio() public view returns (uint256) { return IBondToken(_bondToken).ratio(); } _bondToken: function ratio() public view override returns (uint256) { return _ratio; } function repairRatio(uint256 newRatio) external onlyOwner { _ratio = newRatio; emit RatioUpdated(_ratio); } function updateRatio(uint256 totalRewards) external onlyOperator { uint256 totalShares = totalSharesSupply(); uint256 denominator = _totalStaked + totalRewards - _totalUnbondedBonds; _ratio = multiplyAndDivideFloor(totalShares, 1e18, denominator); // (totalShares * 1e18) / denominator; if (historicalRatios.length == 0) { historicalRatios = new uint256[](8); } if (block.timestamp - _lastUpdate > 1 days - 1 minutes) { uint256 _latestOffset = latestOffset; historicalRatios[((_latestOffset + 1) % 8)] = _ratio; latestOffset = _latestOffset + 1; _lastUpdate = block.timestamp; } emit RatioUpdated(_ratio); } The value of the ratio can be modied by Owner or through other mechanisms. We may trust the operations of the Owner, but changes in the ratio can cause serious arbitrage attacks that can be implemented without the Owner's permission. The main idea is to use MEV attacks by monitoring the transaction memory pool on the blockchain. When a transaction that increases the ratio is found, one transaction deposits the CeVault contract, and another transaction calls the withdraw function of CeVault. By adjusting the form of the transaction fees, these two transactions are placed before and after the ratio change transaction, allowing direct get aBNBc in CeVault. Asset changes like this: Tx1: deposit: 100 aBNBc Tx2: repairRatio: 1-->1.2 Tx3: withdraw: 120 aBNBc",
        "labels": [
            "SlowMist",
            "Helio Money",
            "Type: Unsafe External Call Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Missing check return value",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Helio Money_en-us.pdf",
        "body": "Code location: _aBNBc.transferFrom(msg.sender,address(this),amount) (CeVault.sol#70) _aBNBc.transfer(recipient,availableYields) (CeVault.sol#105) _aBNBc.transfer(recipient,realAmount) (CeVault.sol#143) _certToken.transferFrom(owner,address(this),amount) (CerosRouter.sol#125) _certToken.transfer(recipient,profit) (CerosRouter.sol#165) IERC20(wBnbToken).approve(dexAddress,type()(uint256).max) (CerosRouter.sol#59) IERC20(certToken).approve(dexAddress,type()(uint256).max) (CerosRouter.sol#60) IERC20(certToken).approve(bondToken,type()(uint256).max) (CerosRouter.sol#61) IERC20(certToken).approve(pool,type()(uint256).max) (CerosRouter.sol#62) IERC20(certToken).approve(vault,type()(uint256).max) (CerosRouter.sol#63) _certToken.approve(address(_vault),0) (CerosRouter.sol#250) _certToken.approve(address(_vault),type()(uint256).max) (CerosRouter.sol#252) IERC20(_wBnbAddress).approve(address(_dex),0) (CerosRouter.sol#256) _certToken.approve(address(_dex),0) (CerosRouter.sol#257) IERC20(_wBnbAddress).approve(address(_dex),type()(uint256).max) (CerosRouter.sol#260) _certToken.approve(address(_dex),type()(uint256).max) (CerosRouter.sol#261) _certToken.approve(address(_pool),0) (CerosRouter.sol#266) _certToken.approve(address(_pool),type()(uint256).max) (CerosRouter.sol#268) IERC20(_ceToken).approve(daoAddress,type()(uint256).max) (HelioProvider.sol#67) _ceRouter.withdrawABNBc(recipient,amount) (HelioProvider.sol#155) _dao.deposit(account,address(_ceToken),amount) (HelioProvider.sol#174) _dao.withdraw(account,address(_ceToken),amount) (HelioProvider.sol#178) IERC20(_ceToken).approve(address(_dao),0) (HelioProvider.sol#194) IERC20(_ceToken).approve(address(_dao),type()(uint256).max) (HelioProvider.sol#196) IERC20(_ceToken).approve(address(_dao),0) (HelioProvider.sol#200) IERC20(_ceToken).approve(address(_dao),type()(uint256).max) (HelioProvider.sol#202) IERC20Upgradeable(_rewardsToken).approve(address(target),reward) (mediator/ElipsisMediator.sol#59) _bnbxToken.approve(destination,type()(uint256).max) (strategy/BnbxYieldConverterStrategy.sol#58) _bnbxToken.approve(address(_stakeManager),0) (strategy/BnbxYieldConverterStrategy.sol#313) _bnbxToken.approve(address(_stakeManager),type()(uint256).max) (strategy/BnbxYieldConverterStrategy.sol#315) _certToken.approve(binancePool,type()(uint256).max) (strategy/CerosYieldConverterStrategy.sol#40) _certToken.approve(address(_binancePool),0) (strategy/CerosYieldConverterStrategy.sol#146) _certToken.approve(address(_binancePool),type()(uint256).max) (strategy/CerosYieldConverterStrategy.sol#148) _snBnbToken.approve(destination,type()(uint256).max) (strategy/SnBnbYieldConverterStrategy.sol#57) _snBnbToken.approve(address(_stakeManager),0) (strategy/SnBnbYieldConverterStrategy.sol#309) _snBnbToken.approve(address(_stakeManager),type()(uint256).max) (strategy/SnBnbYieldConverterStrategy.sol#311) hay.transferFrom(address(receiver), address(this), total)(contracts/flash.sol#110) hay.transfer(keeper,hayBal) (libraries/AuctionProxy.sol#39) hay.transfer(keeper,hayBal) (libraries/AuctionProxy.sol#62) hay.transferFrom(msg.sender,address(this),hayMaxAmount) (libraries/AuctionProxy.sol#83) hay.transfer(receiverAddress,hayBal) (libraries/AuctionProxy.sol#99) hay.approve(hayJoin_,type()(uint256).max) (Interaction.sol#103) hay.approve(address(hayJoin),0) (Interaction.sol#109) hay.approve(hayJoin_,type()(uint256).max) (Interaction.sol#118) hay.approve(address(hayJoin),type()(uint256).max) (Interaction.sol#122) IERC20Upgradeable(hay).transferFrom(msg.sender,address(this),wad) (vow.sol#99) Not verifying the return value may lead to logical errors.",
        "labels": [
            "SlowMist",
            "Helio Money",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Missing zero address validation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Helio Money_en-us.pdf",
        "body": "Code locations: CeToken.changeVault(address).vault (CeToken.sol#47) CeVault.changeRouter(address).router (CeVault.sol#194) CerosRouter.changeProvider(address).provider (CerosRouter.sol#271) hBNB.changeMinter(address).minter (hBNB.sol#42) HelioProvider.initialize(address,address,address,address,address,address).certToken (HelioProvider.sol#51) HelioProvider.initialize(address,address,address,address,address,address).ceToken (HelioProvider.sol#52) HelioProvider.changeCeToken(address).ceToken (HelioProvider.sol#199) HelioProvider.changeProxy(address).auctionProxy (HelioProvider.sol#205) HelioProvider.changeOperator(address).operator (HelioProvider.sol#213) MasterVault.initialize(uint256,uint256,uint8,address,address).ceToken (masterVault/MasterVault.sol#86) MasterVault.withdrawETH(address,uint256).account (masterVault/MasterVault.sol#126) PriceOracle.initialize(address,IMovingWindowOracle,bool,address,address)._tokenIn (oracle/PriceOracle.sol#22) PriceOracle.initialize(address,IMovingWindowOracle,bool,address,address)._wbnb (oracle/PriceOracle.sol#25) PriceOracle.initialize(address,IMovingWindowOracle,bool,address,address)._usd (oracle/PriceOracle.sol#26) PriceOracleTestnet.initialize(address,IMovingWindowOracle,bool)._tokenIn (oracle/PriceOracleTestnet.sol#31) SlidingWindowOracle.initialize(address,uint256,uint8).factory_ (oracle/SlidingWindowOracle.sol#46) BnbxYieldConverterStrategy.distributeManual(address).recipient (strategy/BnbxYieldConverterStrategy.sol#253) SnBnbYieldConverterStrategy.distributeManual(address).recipient (strategy/SnBnbYieldConverterStrategy.sol#253) StkBnbStrategy.distributeManual(address).recipient (strategy/StkBnbStrategy.sol#280) Interaction.setWhitelistOperator(address).usr (Interaction.sol#59) Interaction.initialize(address,address,address,address,address,address,address).dog_ (Interaction.sol#86) Jar.initialize(string,string,address,uint256,uint256,uint256)._hayToken (jar.sol#88) Clipper.file(bytes32,address).data (clip.sol#166) Dog.file(bytes32,address).data (dog.sol#133) EmergencyShutdown.constructor(address,address)._vat (es.sol#19) EmergencyShutdown.constructor(address,address)._multisig (es.sol#19) EmergencyShutdown.setMultiSig(address)._multisig (es.sol#28) Vow.initialize(address,address,address)._hayJoin (vow.sol#59) Vow.initialize(address,address,address).multisig_ (vow.sol#59) Vow.file(bytes32,address).data (vow.sol#78)",
        "labels": [
            "SlowMist",
            "Helio Money",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Performs a multiplication on the result of a division",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Helio Money_en-us.pdf",
        "body": "- price = oneTokenOut / amountOut * 10 ** 18 (oracle/PriceOracleTestnet.sol#55) - d /= pow2 (oracle/libraries/FullMath.sol#23) - r *= 2 - d * r (oracle/libraries/FullMath.sol#27) - d /= pow2 (oracle/libraries/FullMath.sol#23) - r *= 2 - d * r (oracle/libraries/FullMath.sol#28) - d /= pow2 (oracle/libraries/FullMath.sol#23) - r *= 2 - d * r (oracle/libraries/FullMath.sol#29) - d /= pow2 (oracle/libraries/FullMath.sol#23) - r *= 2 - d * r (oracle/libraries/FullMath.sol#30) - d /= pow2 (oracle/libraries/FullMath.sol#23) - r *= 2 - d * r (oracle/libraries/FullMath.sol#31) - d /= pow2 (oracle/libraries/FullMath.sol#23) - r *= 2 - d * r (oracle/libraries/FullMath.sol#32) - d /= pow2 (oracle/libraries/FullMath.sol#23) - r *= 2 - d * r (oracle/libraries/FullMath.sol#33) - d /= pow2 (oracle/libraries/FullMath.sol#23) - r *= 2 - d * r (oracle/libraries/FullMath.sol#34) - l /= pow2 (oracle/libraries/FullMath.sol#24) - l * r (oracle/libraries/FullMath.sol#35) - poolTokens = (poolTokensToBurn * 1e11) / (1e11 - stakePool.config().fee.withdraw) (strategy/StkBnbStrategy.sol#188) - poolTokensFee = (poolTokens * stakePool.config().fee.withdraw) / 1e11 (strategy/StkBnbStrategy.sol#198) - x = xxRound_rpow_asm_0 / b (hMath.sol#19) - zx_rpow_asm_0 = z * x (hMath.sol#21) - d /= pow2 (oracle/libraries/FullMath.sol#23) - r *= 2 - d * r (oracle/libraries/FullMath.sol#27) - d /= pow2 (oracle/libraries/FullMath.sol#23) - r *= 2 - d * r (oracle/libraries/FullMath.sol#28) - d /= pow2 (oracle/libraries/FullMath.sol#23) - r *= 2 - d * r (oracle/libraries/FullMath.sol#29) - d /= pow2 (oracle/libraries/FullMath.sol#23) - r *= 2 - d * r (oracle/libraries/FullMath.sol#30) - d /= pow2 (oracle/libraries/FullMath.sol#23) - r *= 2 - d * r (oracle/libraries/FullMath.sol#31) - d /= pow2 (oracle/libraries/FullMath.sol#23) - r *= 2 - d * r (oracle/libraries/FullMath.sol#32) - d /= pow2 (oracle/libraries/FullMath.sol#23) - r *= 2 - d * r (oracle/libraries/FullMath.sol#33) - d /= pow2 (oracle/libraries/FullMath.sol#23) - r *= 2 - d * r (oracle/libraries/FullMath.sol#34) - l /= pow2 (oracle/libraries/FullMath.sol#24) - l * r (oracle/libraries/FullMath.sol#35) - x = xxRound_rpow_asm_0 / b (abaci.sol#159) - zx_rpow_asm_0 = z * x (abaci.sol#161) - x = xxRound_rpow_asm_0 / b (abaci.sol#249) - zx_rpow_asm_0 = z * x (abaci.sol#251) - rate = wad / timeline (jar.sol#141) - leftover = remaining * rate (jar.sol#144) - x = xxRound_rpow_asm_0 / b (hMath.sol#19) - zx_rpow_asm_0 = z * x (hMath.sol#21) Solidity's integer division truncates. Thus, performing division before multiplication can lead to precision loss.",
        "labels": [
            "SlowMist",
            "Helio Money",
            "Type: Arithmetic Accuracy Deviation Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Anyone can call initialize on the logic contract",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Helio Money_en-us.pdf",
        "body": "contracts/ceros/upgrades/CeVaultV2.sol 33,5: function initialize( contracts/ceros/upgrades/HelioProviderV2.sol 43,5: function initialize( contracts/ceros/CerosRouter.sol 41,5: function initialize( contracts/ceros/CeToken.sol 31,5: function initialize(string calldata _name, string calldata _symbol) contracts/ceros/CeVault.sol 33,5: function initialize( contracts/ceros/hBNB.sol 29,5: function initialize() external initializer { contracts/ceros/HelioProvider.sol 49,5: function initialize( contracts/masterVault/MasterVault.sol 82,5: function initialize( contracts/masterVault/WaitingPool.sol 28,5: function initialize(address _masterVault, uint256 _capLimit) external initializer { contracts/mediator/ElipsisMediator.sol 43,5: function initialize(address targetContract) public initializer { contracts/oracle/interfaces/IUniswapV2Pair.sol 96,3: function initialize(address, address) external; contracts/oracle/BnbOracle.sol 11,5: function initialize(address aggregatorAddress) external initializer { contracts/oracle/BusdOracle.sol 11,5: function initialize(address aggregatorAddress) external initializer { contracts/oracle/HelioOracle.sol 17,5: function initialize(uint256 initialPrice) public initializer { contracts/oracle/PriceOracle.sol 21,3: function initialize( contracts/oracle/PriceOracleTestnet.sol 30,3: function initialize( contracts/oracle/SlidingWindowOracle.sol 45,3: function initialize( contracts/strategy/BnbxYieldConverterStrategy.sol 46,5: function initialize( contracts/strategy/CerosYieldConverterStrategy.sol 27,5: function initialize( contracts/strategy/SnBnbYieldConverterStrategy.sol 45,5: function initialize( contracts/strategy/StkBnbStrategy.sol 58,5: function initialize( contracts/abaci.sol 52,5: function initialize() external initializer { 123,5: function initialize() external initializer { 214,5: function initialize() external initializer { contracts/clip.sol 127,5: function initialize(address vat_, address spotter_, address dog_, bytes32 ilk_) external initializer { contracts/dog.sol 103,5: function initialize(address vat_) external initializer { contracts/flash.sol 58,5: function initialize(address _vat, address _hay, address _hayJoin, address _vow) external initializer { contracts/hay.sol 59,5: function initialize(uint256 chainId_, string memory symbol_, uint256 supplyCap_) external initializer { contracts/HelioRewards.sol 65,5: function initialize(address vat_, uint256 poolLimit_ ) public initializer { contracts/HelioToken.sol 28,5: function initialize(uint256 rewardsSupply_, address rewards_) public initializer { contracts/Interaction.sol 80,5: function initialize( contracts/jar.sol 88,5: function initialize(string memory _name, string memory _symbol, address _hayToken, uint _spread, uint _exitDelay, uint _flashLoanDelay) external initializer { contracts/join.sol 89,5: function initialize(address vat_, bytes32 ilk_, address gem_) external initializer { 149,5: function initialize(address vat_, address hay_) external initializer { contracts/jug.sol 54,5: function initialize(address vat_) external initializer { contracts/lock.sol 64,5: function initialize() external initializer { contracts/spot.sol 56,5: function initialize(address vat_) external initializer { contracts/vat.sol 74,5: function initialize() public initializer { contracts/vow.sol 59,5: function initialize(address vat_, address _hayJoin, address multisig_) external initializer { Anyone can call initialize on the logic contract.",
        "labels": [
            "SlowMist",
            "Helio Money",
            "Type: Race Conditions Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "vaultToken burned may exceed the actual number needed",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Helio Money_en-us.pdf",
        "body": "contracts/masterVault/MasterVault.sol function withdrawETH(address account, uint256 amount) external override nonReentrant whenNotPaused onlyProvider returns (uint256 shares) { address src = msg.sender; ICertToken(vaultToken).burn(src, amount); uint256 ethBalance = totalAssetInVault(); shares = _assessFee(amount, withdrawalFee); if(ethBalance < shares) { payable(account).transfer(ethBalance); uint256 withdrawn = withdrawFromActiveStrategies(account, shares - ethBalance); shares = ethBalance + withdrawn; } else { payable(account).transfer(shares); } emit Withdraw(src, src, src, amount, shares); return amount; } When Strategy balance is not enough, the actual withdrawn amount return by withdrawFromActiveStrategies will lower than shares - ethBalance passed, it means the provider burn amount but do not get enough native token.",
        "labels": [
            "SlowMist",
            "Helio Money",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Missing check BnbOracle status",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Helio Money_en-us.pdf",
        "body": "contracts/oracle/BnbOracle.sol function peek() public view returns (bytes32, bool) { ( /*uint80 roundID*/, int price, /*uint startedAt*/, /*uint timeStamp*/, /*uint80 answeredInRound*/ ) = priceFeed.latestRoundData(); if (price < 0) { return (0, false); } return (bytes32(uint(price) * (10**10)), true); } In order to get a correct price, we need to check key values returned by priceFeed.",
        "labels": [
            "SlowMist",
            "Helio Money",
            "Type: Unsafe External Call Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Upgrading contracts may introduce new risks",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Helio Money_en-us.pdf",
        "body": "contracts/oracle/HelioOracle.sol contracts/oracle/PriceOracle.sol contracts/oracle/SlidingWindowOracle.sol The Proxy can upgrade the contract by calling upgradeTo/upgradeToAndCall , and upgrading the contract may introduce new risks.",
        "labels": [
            "SlowMist",
            "Helio Money",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "HelioOracle owner is never initialized",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Helio Money_en-us.pdf",
        "body": "contracts/oracle/HelioOracle.sol function changePriceToken(uint256 price_) external { require(msg.sender == _owner, \"HelioOracle/forbidden\"); price = price_; emit PriceChanged(price); } _owner is never initialized, changePriceToken call will fail in any condition.",
        "labels": [
            "SlowMist",
            "Helio Money",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "HelioOracle price oracle is not rigorous",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Helio Money_en-us.pdf",
        "body": "contracts/oracle/HelioOracle.sol function changePriceToken(uint256 price_) external { require(msg.sender == _owner, \"HelioOracle/forbidden\"); price = price_; emit PriceChanged(price); } This oracle price is too simple, there is not parameters for determining the validity of prices, such as timestamp.",
        "labels": [
            "SlowMist",
            "Helio Money",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Oracle price should not return 0",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Helio Money_en-us.pdf",
        "body": "contracts/HelioRewards.sol function helioPrice() public view returns(uint256) { // 1 HAY is helioPrice() helios (bytes32 price, bool has) = oracle.peek(); if (has) { return uint256(price); } else { return 0; } } contracts/Interaction.sol function collateralPrice(address token) public view returns (uint256) { CollateralType memory collateralType = collaterals[token]; _checkIsLive(collateralType.live); (PipLike pip,) = spotter.ilks(collateralType.ilk); (bytes32 price, bool has) = pip.peek(); if (has) { return uint256(price); } else { return 0; } } Price oracle should break the operation when peek an error, instead of return 0.",
        "labels": [
            "SlowMist",
            "Helio Money",
            "Type: Unsafe External Call Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "ERC777 reentrancy risks",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Helio Money_en-us.pdf",
        "body": "contracts/strategy/StkBnbStrategy.sol function _withdraw(address recipient, uint256 amount) internal returns (uint256) { //... stkBNB.send(address(stakePool), poolTokens, \"\"); // save it so that we can later dispatch the amount to the recipient on claim withdrawReqs[_endIndex++] = WithdrawRequest(recipient, value); // keep track of _netDeposits in StakePool _bnbDepositsInStakePool -= value; return value + ethBalance; } stkBNB is a ERC777 token , ERC777 tokens are vulnerable to reentrancy attacks due to a design aw.",
        "labels": [
            "SlowMist",
            "Helio Money",
            "Type: Reentrancy Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Missing events access control",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Helio Money_en-us.pdf",
        "body": "MasterVault._updateCerosStrategyDebt() MasterVault.withdrawFee() BnbxYieldConverterStrategy._deposit() BnbxYieldConverterStrategy._withdraw() BnbxYieldConverterStrategy._distributeFund() BnbxYieldConverterStrategy._harvestTo() CerosYieldConverterStrategy._deposit() CerosYieldConverterStrategy._withdraw() CerosYieldConverterStrategy._harvestTo() SnBnbYieldConverterStrategy._deposit() SnBnbYieldConverterStrategy.withdrawInToken() SnBnbYieldConverterStrategy._withdraw() SnBnbYieldConverterStrategy._distributeFund() SnBnbYieldConverterStrategy._harvestTo() StkBnbStrategy._deposit() StkBnbStrategy.withdrawInToken() StkBnbStrategy._withdraw() StkBnbStrategy.harvest()",
        "labels": [
            "SlowMist",
            "Helio Money",
            "Type: Malicious Event Log Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Reentry prevention best practices",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Helio Money_en-us.pdf",
        "body": "contracts/HelioRewards.sol function claim(uint256 amount) external { //... } contracts/Interaction.sol function deposit( address participant, address token, uint256 dink ) external whitelisted(participant) returns (uint256) { } function borrow(address token, uint256 hayAmount) external returns (uint256) { //... } function payback(address token, uint256 hayAmount) external returns (int256) { //... } Not apply check-eects-interactions pattern when making external calls in these functions.",
        "labels": [
            "SlowMist",
            "Helio Money",
            "Type: Reentrancy Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing check return value",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Helio Money_en-us.pdf",
        "body": "Code location: jug.drip(collateralType.ilk) (Interaction.sol#145) jug.drip(collateralType.ilk) (Interaction.sol#309) _deactivateStrategy(strategy)(contracts/masterVault/MasterVault.sol#315) _depositToStrategy(strategies[i], depositAmount) (contracts/masterVault/MasterVault.sol#342) Not verifying the return value may lead to logical errors.",
        "labels": [
            "SlowMist",
            "Helio Money",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - wBETH_en-us.pdf",
        "body": "1.In the UnwrapTokenV1 contract, the owner role can set the operatorAddress, the rechargeAddress, the ethBackAddress, the ethStaked address, and the lockTime. Wrong conguration and sudden modication will aect the user's normal withdrawal request and claim. ",
        "labels": [
            "SlowMist",
            "wBETH",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "call() should be used instead of transfer()",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - wBETH_en-us.pdf",
        "body": "The transfer() and send() functions forward a xed amount of 2300 gas. Historically, it has often been recommended to use these functions for value transfers to guard against reentrancy attacks. However, the gas cost of EVM instructions may change signicantly during hard forks which may break already deployed contract systems that make xed assumptions about gas costs. For example. EIP 1884 broke several existing smart contracts due to a cost increase in the SLOAD instruction. ",
        "labels": [
            "SlowMist",
            "wBETH",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Preemptive Initialization",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - wBETH_en-us.pdf",
        "body": "By calling the initialize and deploy functions to initialize the contracts, there is a potential issue that malicious attackers preemptively call the initialize function to initialize. ",
        "labels": [
            "SlowMist",
            "wBETH",
            "Type: Race Conditions Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Possible calculation truncation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - wBETH_en-us.pdf",
        "body": "In the RateLimit contract, the amountToReplenish is calculated by the division (secondsSinceAllowanceSet * maxAllowances[caller]) / intervals[caller]; . If the value of the numerator is less than intervals[caller], this division can truncate towards 0. Since the result of the division is returned by the _getReplenishAmount function and is used in the _replenishAllowance function to update the callers allowance, this truncation can lead to a failure in updating the callers allowance. ",
        "labels": [
            "SlowMist",
            "wBETH",
            "Type: Arithmetic Accuracy Deviation Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Multiple Solidity versions in use",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - wBETH_en-us.pdf",
        "body": "Throughout the code base there are dierent versions of Solidity being used. Token contracts are specically using version 0.6.12 while other contracts allow compiling with version 0.8.6.",
        "labels": [
            "SlowMist",
            "wBETH",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Dev address setting enhancement suggestions",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - wBETH_en-us.pdf",
        "body": "In the can set the StakedTokenV1 and StakedTokenV2 contracts, the owner role can set the ethReceiver address to move the eth. If the address is an EOA address, in a scenario where the private keys are leaked, the teams revenue will be stolen. ",
        "labels": [
            "SlowMist",
            "wBETH",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Inability to claim due to insucient availableAllocateAmount",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - wBETH_en-us.pdf",
        "body": "In the WrapTokenV2ETH and WrapTokenV2BSC contract, users can call the requestWithdrawEth function to burn their wbeth to withdraw their unwrap_ETH tokens. In this function, the withdraw operation is executed by the UnwrapTokenV1 requestWithdraw function. And in the requestWithdraw function, the _currentIndex value will be increased by the nextIndex++ self-increment. Once the availableAllocateAmount is less than the _ethAmount or the startAllocatedEthIndex is not equal to the currentIndex , the if judgment will pass to execute the else part only, and the startAllocatedEthIndex will not self-increment. This can lead to the allocation failing that users can not call the claimWithdraw function to withdraw their eth. Only in the UnwrapTokenV1 contract, the operator role can call the allocate function to allocate availableAllocateAmount of ethAmount to make the startAllocatedEthIndex++ self-increment to match the if judgment and the claimWithdraws allocated value will be set to true. ",
        "labels": [
            "SlowMist",
            "wBETH",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Potential error in the calculation of the withdrawal amount",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist_Audit_Report_StakeStone_NativeLendingETHStrategy&Symbi_en-us.pdf",
        "body": "In the NativeLendingETHStrategy contract, the owner role can call the withdrawFromNativeByAmount function and the withdrawFromNativeByShare function to redeem the AquaLpToken for ETH. The nal calculated withdrawal amount is simply the dierence between the current ETH balance of the contract and the ETH balance before the redemption operation. However, the redemption operation rst converts the AquaLpToken back to WETH tokens, and then uses the WETH tokens to obtain ETH. If there are surplus WETH tokens in the contract before the redemption (for example, if other users have mistakenly transferred them in), then this excess WETH amount will also be included in the calculated withdrawal amount. Code Location: contracts/strategies/NativeLendingETHStrategy.sol#L44-66 function withdrawFromNativeByAmount( uint256 _amount ) external onlyOwner returns (uint256 withdrawAmount) { uint256 beforeBalance = address(this).balance; IAquaLpToken(LPTOKEN).redeemUnderlying(_amount); WETH.withdraw(WETH.balanceOf(address(this))); withdrawAmount = address(this).balance - beforeBalance; } function withdrawFromNativeByShare( uint256 _share ) external onlyOwner returns (uint256 withdrawAmount) { uint256 beforeBalance = address(this).balance; IAquaLpToken(LPTOKEN).redeem(_share); WETH.withdraw(WETH.balanceOf(address(this))); withdrawAmount = address(this).balance - beforeBalance; }",
        "labels": [
            "SlowMist",
            "SlowMist_Audit_Report_StakeStone_NativeLendingETHStrategy&Symbi",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Missing event records",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist_Audit_Report_StakeStone_NativeLendingETHStrategy&Symbi_en-us.pdf",
        "body": "In the NativeLendingETHStrategy contract, the owner role can use the ETH in the contract to mint AquaLpToken, and then use the AquaLpToken to redeem for ETH, but there is no event record. Code Location: contracts/strategies/NativeLendingETHStrategy.sol#L28-66 function depositIntoNative( uint256 _amount ) external onlyOwner returns (uint256 mintAmount) { ... } function withdrawFromNativeByAmount( uint256 _amount ) external onlyOwner returns (uint256 withdrawAmount) { ... } function withdrawFromNativeByShare( uint256 _share ) external onlyOwner returns (uint256 withdrawAmount) { ... }",
        "labels": [
            "SlowMist",
            "SlowMist_Audit_Report_StakeStone_NativeLendingETHStrategy&Symbi",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing zero value check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist_Audit_Report_StakeStone_NativeLendingETHStrategy&Symbi_en-us.pdf",
        "body": "In the NativeLendingETHStrategy contract, The owner role does not check whether the input amount for minting and redeeming AquaLpToken tokens is 0 or not. If the input value is 0, the operation can still be executed successfully, but it will consume gas. Code Location: contracts/strategies/NativeLendingETHStrategy.sol#L28-66 function depositIntoNative( uint256 _amount ) external onlyOwner returns (uint256 mintAmount) { ... } function withdrawFromNativeByAmount( uint256 _amount ) external onlyOwner returns (uint256 withdrawAmount) { ... } function withdrawFromNativeByShare( uint256 _share ) external onlyOwner returns (uint256 withdrawAmount) { ... }",
        "labels": [
            "SlowMist",
            "SlowMist_Audit_Report_StakeStone_NativeLendingETHStrategy&Symbi",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Lack of external interest rate ination vulnerability check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist_Audit_Report_StakeStone_NativeLendingETHStrategy&Symbi_en-us.pdf",
        "body": "In the NativeLendingETHStrategy and SymbioticDepositWstETHStrategy contracts, the owner role can separately call the depositIntoNative function and the depositIntoSymbiotic function to deposit the funds in the strategy contract into a third-party protocol, and mint the corresponding deposit certicates. However, the functions do not check whether the minted deposit shares are zero in quantity. Since the code of the third-party protocol is not within the scope of this audit, if there is an interest rate ination vulnerability in the code of the third-party protocol, the funds in the contract may be damaged due to malicious users front-running. For details on the interest rate ination vulnerability, please refer to the following link: https://blog.openzeppelin.com/a-novel-defense-against-erc4626-ination-attacks Code Location: contracts/strategies/NativeLendingETHStrategy.sol#L28-42 function depositIntoNative( uint256 _amount ) external onlyOwner returns (uint256 mintAmount) { ... IAquaLpToken(LPTOKEN).mint(_amount); mintAmount = IAquaLpToken(LPTOKEN).balanceOf(address(this)) - beforeLPBalance; } contracts/strategies/SymbioticDepositWstETHStrategy.sol#L151-169 function depositIntoSymbiotic( uint256 _wstETHAmount ) external onlyOwner returns (uint256 shares) { ... shares = ICollateral(collateralAddr).deposit( address(this), _wstETHAmount ); emit DepositIntoSymbiotic( collateralAddr, address(this), _wstETHAmount, shares ); }",
        "labels": [
            "SlowMist",
            "SlowMist_Audit_Report_StakeStone_NativeLendingETHStrategy&Symbi",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Potentially unclaimed rewards",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the SingleTokenStaking contract, the calculation of staking rewards mainly depends on the rewardSpeed variable. The contract calculates the global reward accumulation accuedReward based on rewardSpeed and the block interval. When a user settles rewards, the dierence between the current global accuedReward and the user's last settled accuedReward is multiplied by the user's deposit amount to determine the user's claimable rewards. It is important to note that the contract does not limit users' minimum deposit amount. This means that when a user deposits an extremely small amount and rewardSpeed is set relatively low (for example, if the user deposits 1 wei and rewardSpeed is less than 1e18), the user's small rewards may be truncated due to decimal rounding during the reward settlement process. This may result in the user's rewards being left unclaimed in the contract. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Arithmetic Accuracy Deviation Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Optimizable refreshGlobalState",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the SingleTokenStaking contract, the refreshGlobalState function is used to update the global reward state accuedReward and update the accumulated rewards and the current block to the corresponding global variables. It is important to note that there may be a large number of users performing operations such as depositing, withdrawing, and claiming rewards within the same block, which will result in frequent calls to the refreshGlobalState function. This means that although accuedReward will not be accumulated within the same block, users still need to pay some gas to update gDeposits.accuedReward and gDeposits.accuedBlock , which is unnecessary within the same block. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Compatibility issues with deationary tokens",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the SingleTokenStaking contract, users can deposit supported tokens into the contract using the deposit function, and the addDeposit function directly records the amount of deposit tokens passed in by the user. If the token supported by the contract is deationary, the contract will actually receive fewer tokens than the deposit amount passed in by the user. This will cause the contract to record a higher user deposit than the actual amount of tokens received. When the user withdraws, it will result in a bad debt for the protocol. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Optimizable RFG token distribution method",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the RFGToken contract, the token distribution rules are hardcoded. 30% of the token supply will be allocated to liquidity, 10% will be allocated to airdrops, and the remaining tokens will be minted by the minter role. The contract uses three separate functions to mint tokens for these three dierent allocation purposes. However, it should be noted that in the claimAirdrop and claimLiquidity functions, although the tokens are minted for airdrop and liquidity purposes, the receiving addresses are not specied. The owner role can mint these tokens to any address. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Admin who has not set the Boss role",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "During the initialization of the Auction contract, the specied boss address is granted the BossRole. However, it should be noted that the BossRole is not assigned the AdminRole. This means that if the boss address experiences issues such as private key leakage, the protocol will not be able to handle the boss address through revokeRole/grantRole . ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Not checking the reasonableness of time when updating auctions",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the Auction contract, the admin role can update existing auction congurations through the updateAuction function. When updating, it checks whether the new startPrice is greater than 0, but it does not check whether the new endTime is greater than startTime. It should be noted that the admin can update an auction that has already ended to reopen it. This means that users who have already placed bids or claimed items can participate in the auction again. However, this will cause the restarted auction to conict with the previous claim/refund data. For example, if a user who successfully claimed an NFT in the previous auction wins the auction again, they will not be able to claim the new NFT successfully a second time. This does not align with the expected design. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Smart contracts cannot participate in the auction",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the Auction contract, users can participate in the auction through the bidAuction function. However, the function checks whether msg.sender is equal to tx.origin , which prevents smart contracts (including EIP4337 wallets) from participating in the auction. It should be noted that in the future, if the EIP3074 standard is approved, it may break this check. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Design Logic Audit",
            "Severity: Information"
        ]
    },
    {
        "title": "Time check when closing auction is awed",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the Auction contract, the operator can end the auction through the nishAuction function after the endTime. When performing the nishAuction operation, the endTime is checked using block.timestamp >= auction.endTime , while when performing the bidAuction operation, the endTime is checked using block.timestamp <= auction.endTime . This means that when the operator performs the nishAuction operation to set result.price exactly at the endTime, users can still perform the bidAuction operation to participate in the auction. This may not align with the intended design. It may also cause confusion for users, as they can place a bid higher than result.price at the endTime but are not included in the nal Merkle tree. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Not checking if the user's bid is as expected",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the Auction contract, users who successfully win the auction can obtain the NFT through the claimNft function. The operator sets the Merkle proof to verify the validity of the claiming user. When the user's bid price is higher than auctionResult.price , the contract processes a refund for them. However, the contract does not check whether the user's bid price is necessarily greater than or equal to auctionResult.price . If the Merkle tree erroneously includes users with bid prices lower than auctionResult.price , it may result in insucient funds in the contract for the boss role to withdraw. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Not checking if the user's bid is refundable",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the Auction contract, users who meet the refund conditions can use the operator's signature to request a refund. Theoretically, if a user is eligible to claim the NFT, the operator will not sign for them to avoid giving up their eligibility for a refund. However, the refund function does not strictly check whether the bid prices of all refunding users are less than auctionResult.price . If the operator erroneously signs a refund for a user who is eligible to claim the NFT, it will prevent the boss from withdrawing the remaining auction proceeds. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Risk of pseudo-randomness",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the Auction contract, when a user claims an NFT, the fakeRandomToken function is used to calculate the tokenId for the user. The fakeRandomToken function uses block.prevrandao , block.number , and the user-provided seed for calculation. Unfortunately, these parameters can be controlled or are already known. This allows malicious users to ensure that the tokenIds of the NFTs they obtain at specic blocks are all of high value. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Block data Dependence Vulnerability",
            "Severity: Critical"
        ]
    },
    {
        "title": "Redundant return value of adjustRandomtoken function",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the Auction contract, the adjustRandomtoken function is used to select a matching id for the user based on the current tokenId inventory. When all the inventory has been claimed, the function directly throws an error using require(false) . This makes the nal return 0 redundant because the function will never execute this return statement. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "The tokenId obtained by the user is related to the NFT inventory",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the Auction contract, the adjustRandomtoken function is used to adjust the nal tokenId based on the inventory of each tokenId's NFTs. If a user obtains the highest-value NFT but there is no inventory for this NFT, they may be assigned the lowest-value NFT instead, and vice versa. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Design Logic Audit",
            "Severity: Information"
        ]
    },
    {
        "title": "Unchecked boost bound parameters during initialization",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the initialize function of the RFGDeposit contract, when the proxy contract is initialized, parameters such as lowerBound and upperBound are passed in. However, the function does not check whether the passed-in lowerBound is less than upperBound. Incorrectly passing the corresponding values may cause the protocol to be unusable. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Rewards not settled as expected",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the RFGDeposit contract, users can make xed-term deposits through the xedDeposit function. When a user's autoRedeposit status is false, even if the user's deposit time is several times longer than the duration, only one cycle of rewards will be settled for the user. Unfortunately, the xedDeposit function does not handle the case where autoRedeposit is false. This allows users with autoRedeposit set to false to make a small deposit to the same xId after a long deposit period and still receive the full rewards, not just for one duration. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Incorrect whitelist pool check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the Pool contract, the assertCallerIsPool function is used to check whether the passed-in sender is a pool created in the stakingManager. The assertCallerIsPool function receives the msg.sender from SinglePool and CouplePool as a possible pool address, calls the poolID interface of msg.sender to obtain the pool id, and nally checks whether this pool id is valid in the stakingManager. Unfortunately, this check method is not eective. Malicious contracts can also implement the poolID interface and return a valid pool id (1~7) when called. Since the assertCallerIsPool function only checks whether the id is valid through the stakingManager contract, malicious contracts can easily bypass this check to perform malicious custodial staking and eventually exhaust the protocol's assets. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Unsafe External Call Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Unexpected rewards when staking in pairs",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the CouplePool contract, the stakingManager can stake a user's NFT through the socialStake function. When the staking has not been paired yet, CouplePool will custody the user's NFT to SinglePool to obtain SinglePool staking rewards. Once the pairing is complete, it will withdraw from SinglePool and stake in CouplePool. Theoretically, during the process of pairing, users should only receive rewards from SinglePool and not from CouplePool. Unfortunately, when SinglePool custody is performed, the user's ssInfo.stakeInfo.amount value in the CouplePool contract will be updated to the staked amount. This allows users to claim CouplePool staking rewards through the claimSocialReward function of the stakingManager contract even before the pairing is completed. Worse still, the user's ssInfo.stakeInfo.claimedToAccued has not been set at this point, so when settling rewards, calculateStakeReward will distribute large unexpected rewards to the user. Malicious users can exploit this issue to exhaust all reward tokens. Similarly, this issue also exists in the GroupPool contract. Users can still claim large rewards from GroupPool even before the three-party pairing is completed. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Manipulate boost to inuence the token id obtained in the auction",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the Auction contract, when a user claims the auctioned NFT, the token id of the NFT depends not only on the random number seed but also on the amount of the user's deposit in the RFGDeposit contract. The larger the user's deposit amount, the greater the user's boost, and the higher the probability of obtaining a high-value NFT. Unfortunately, the calculation of the boost only depends on the user's deposit amount. Users can increase their RFG deposit before claiming the NFT to improve the probability. When multiple addresses of a user have obtained NFTs, they only need to withdraw the staked RFG tokens from other addresses and transfer them to the address that needs to claim the NFT for staking before claiming the NFT, in order to increase the probability. In other words, users only need a high amount of staking and can continuously stake/unstake/transfer RFG tokens to increase the probability of obtaining high-value NFTs at a lower cost. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Redundant PoolMax enum",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the NftID library, PoolID lists an enumeration of all the pools supported by the protocol, but PoolMax is not used anywhere in the protocol, which is redundant. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Reward calculation for two stakers in GroupPool being the same user",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the GroupPool contract, when a user performs a socialUnstake/forceSocialUnstake operation, a portion of the bailed rewards of the initiator of the unstaking operation will be deducted and distributed to other users in the same group. However, it should be noted that one of the users in the same group may also be the initiator because the protocol allows the same user to provide two dierent NFTs for GroupPool staking. This means that a portion of the initiator's penalized rewards still belong to the initiator themselves. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Design Logic Audit",
            "Severity: Information"
        ]
    },
    {
        "title": "Potentially incorrect social staking reward information in GroupPool",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "As previously mentioned, GroupPool allows the same user to provide two NFTs for staking. However, during reward settlement, stakerShareReward and bailed are calculated based on three dierent staking users. Therefore, in the viewSocialStakeRewardInfo function, when obtaining the user's pendingRewards, it only considers the scenario where the three stakers are dierent users, while overlooking the possibility that two of the stakers might be the same user. This may cause the reward amount returned by the viewSocialStakeRewardInfo function to be lower than expected. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Potential Denial of Service Risk",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In Pool, users can freely choose dierent pools for staking. Theoretically, users can stake their owned NFTs in pools of dierent types or in dierent matchCodes within the same pool. The pool uses OpenZeppelin's EnumerableSet library to record the pools or matchCodes that users have joined, and retrieves all the pools or matchCodes joined by users through the values interface of EnumerableSet when claiming rewards. It is important to note that the values operation copies the entire storage space to memory. If the user participates in a large number of pools or matchCodes, the values operation will generate signicant gas costs, potentially exceeding the block's gasLimit and ultimately leading to DoS risks. Despite this, if a DoS issue arises, users can still avoid their rewards being locked by claiming rewards individually. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Denial of Service Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "The validity of the pid was not checked when creating the pool",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the StakingManager contract, operators can create pools using the createPool function, but the validity of the passed-in pid value is not checked. Theoretically, the pid of a pool should only be between 1 and 7. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "When creating a matchCode, it does not check whether the pool has been created.",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the StakingManager contract, users can create matchCodes for social staking using the createMatch2Code and createMatch3Code functions. However, when creating a matchCode, there is no check to verify if the pool corresponding to the pid has already been created. If the pool has not been created, users will be unable to successfully create a matchCode, and no error message will be thrown, which may cause confusion for users. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "There is an upper limit on the matchCodes available in the pool",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the StakingManager contract, when a user creates a matchCode for social staking, the protocol assigns a matchCode to this staking. The matchCode is obtained through the nextMatchCode function of the pool, which is calculated using poolID * 10 ** 8 + matchCodeNonce . It is important to note that if the value of matchCodeNonce exceeds 1e8, it will aect the matchCode of the next pool. In reality, it is highly unlikely for a pool to have 1e8 matchCodes, but the project team should still remain attentive to this matter. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Checks-Eects-Interactions are not followed when transferring out NFT",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the StakingManager contract, the returnNftsBackAndClaimReward function is used to transfer users' staked NFTs from the contract back to the users and claim social staking rewards for users through the claimSocialReward function. The practice of transferring assets before modifying the contract state does not comply with the Checks- Eects-Interactions pattern. Although it does not lead to reentrancy risks in the current business scenario, it cannot be guaranteed that new exploitable business scenarios will not be introduced in the future. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Optimizable reward information update",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the updateRewardInfo function of the GroupPool contract, the currently claimable social staking rewards are calculated through the calculateStakeReward function, and the rewards are distributed to the stakers. It is important to note that when users exit staking through the StakingManager contract, multiple calls to the updateRewardInfo function may be involved in a single transaction. The pendingReward for reward settlement is only greater than 0 during the rst call, and when pendingReward is 0, the updateRewardInfo function still performs reward distribution operations, which will consume a lot of unnecessary gas. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risks of excessive privilege",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the StakingManager contract, the admin role can upgrade any pool through the upgradePool function. Moreover, in the protocol, except for the InviteReward, Airdrop, RFGToken, and NftCard contracts, all other contracts use an upgradable model, where the admin of the proxy contract can arbitrarily upgrade these contracts. This leads to the risk of excessive privileges. In the Auction contract, after the auction is completed, the project team will calculate o-chain the users who can obtain NFTs and the nal auction price, and establish a Merkle proof for users to claim. This also increases the centralization risk to a certain extent. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Protocol Missing Emergency Operations Role",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "The protocol has planned for multiple roles to manage dierent contracts, but it is important to note that the protocol lacks an emergency pause functionality and a role to manage this function. When an emergency occurs in the protocol, the emergency operation role can close the protocol through the pause function to minimize losses as much as possible.",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing event records",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the NftCard contract, the owner can modify the URI of the NFT through the setUri function, but no event is recorded. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "4.2.1.1 Sandwich attacks issues",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - autofarm_en-us.pdf",
        "body": "The earn(), buyBack(), convertDustToEarned(), _convertMDXToEarned functions no limit slippage, there is a sandwich attacks issues. It is recommended to add a slippage limit, and the slippage parameter can only be modified by the Owner.  AutofarmV2_CrossChain/StratVLEV2.sol function earn() external whenNotPaused { if (onlyGov) { require(msg.sender == govAddress, \"!gov\"); } 6 IVenusDistribution(venusDistributionAddress).claimVenus(address(this)); uint256 earnedAmt = IERC20(venusAddress).balanceOf(address(this)); earnedAmt = distributeFees(earnedAmt); earnedAmt = buyBack(earnedAmt); if (venusAddress != wantAddress) { IPancakeRouter02(uniRouterAddress).swapExactTokensForTokens( earnedAmt, 0, venusToWantPath, address(this), now.add(600) ); } lastEarnBlock = block.number; _farm(false); //SupplywantTokenwithoutleverage,tocaterfornet-veinterestrates. }  AutofarmV2_CrossChain/StratVLEV2.sol function buyBack(uint256 _earnedAmt) internal returns (uint256) { if (buyBackRate <= 0) { return _earnedAmt; } uint256 buyBackAmt = _earnedAmt.mul(buyBackRate).div(buyBackRateMax); IPancakeRouter02(uniRouterAddress).swapExactTokensForTokens( buyBackAmt, 0, earnedToAUTOPath, buyBackAddress, now + 600 ); return _earnedAmt.sub(buyBackAmt); 7 }  AutofarmV2_CrossChain/StratX2_MDEX.sol function convertDustToEarned() public whenNotPaused { require(isAutoComp, \"!isAutoComp\"); require(!isCAKEStaking, \"isCAKEStaking\"); //Convertsdusttokensintoearnedtokens,whichwillbereinvestedonthenextearn(). //Convertstoken0dust(ifany)toearnedtokens uint256 token0Amt = IERC20(token0Address).balanceOf(address(this)); if (token0Address != earnedAddress && token0Amt > 0) { IERC20(token0Address).safeIncreaseAllowance( uniRouterAddress, token0Amt ); //Swapalldusttokenstoearnedtokens IPancakeRouter02(uniRouterAddress) .swapExactTokensForTokensSupportingFeeOnTransferTokens( token0Amt, 0, token0ToEarnedPath, address(this), now + 600 ); } //Convertstoken1dust(ifany)toearnedtokens uint256 token1Amt = IERC20(token1Address).balanceOf(address(this)); if (token1Address != earnedAddress && token1Amt > 0) { IERC20(token1Address).safeIncreaseAllowance( uniRouterAddress, token1Amt ); //Swapalldusttokenstoearnedtokens IPancakeRouter02(uniRouterAddress) .swapExactTokensForTokensSupportingFeeOnTransferTokens( 8 token1Amt, 0, token1ToEarnedPath, address(this), now + 600 ); } }  AutofarmV2_CrossChain/StratX2_MDEX.sol function _convertMDXToEarned() internal { //ConvertsMDX(ifany)toearnedtokens uint256 MDXAmt = IERC20(MDXAddress).balanceOf(address(this)); if (MDXAddress != earnedAddress && MDXAmt > 0) { IERC20(MDXAddress).safeIncreaseAllowance(uniRouterAddress, MDXAmt); //Swapalldusttokenstoearnedtokens IPancakeRouter02(uniRouterAddress) .swapExactTokensForTokensSupportingFeeOnTransferTokens( MDXAmt, 0, MDXToEarnedPath, address(this), now + 60 ); } }  AutofarmV2_CrossChain/StratX2_MDEX.sol function buyBack(uint256 _earnedAmt) internal returns (uint256) { if (buyBackRate <= 0) { return _earnedAmt; } uint256 buyBackAmt = _earnedAmt.mul(buyBackRate).div(buyBackRateMax); if (earnedAddress == AUTOAddress) { IERC20(earnedAddress).safeTransfer(buyBackAddress, buyBackAmt); } else { IERC20(earnedAddress).safeIncreaseAllowance( uniRouterAddress, 9 buyBackAmt ); IPancakeRouter02(uniRouterAddress) .swapExactTokensForTokensSupportingFeeOnTransferTokens( buyBackAmt, 0, earnedToAUTOPath, buyBackAddress, now + 600 ); } return _earnedAmt.sub(buyBackAmt); }  AutofarmV2_CrossChain/StratVLEV2.sol function earn() external whenNotPaused { if (onlyGov) { require(msg.sender == govAddress, \"!gov\"); } IVenusDistribution(venusDistributionAddress).claimVenus(address(this)); uint256 earnedAmt = IERC20(venusAddress).balanceOf(address(this)); earnedAmt = distributeFees(earnedAmt); earnedAmt = buyBack(earnedAmt); if (venusAddress != wantAddress) { IPancakeRouter02(uniRouterAddress).swapExactTokensForTokens( earnedAmt, 0, venusToWantPath, address(this), now.add(600) ); } lastEarnBlock = block.number; 10 _farm(false); //SupplywantTokenwithoutleverage,tocaterfornet-veinterestrates. } Fix Status: The issue has been fixed in this commit: b27f2cafcf51667726bd70220420707c89b75975",
        "labels": [
            "SlowMist",
            "autofarm",
            "Severity: High"
        ]
    },
    {
        "title": "4.2.2.1 Excessive authority issues",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - autofarm_en-us.pdf",
        "body": "The add function has excessive authority issues, Owner can add mining pool arbitrarily, there is a risk of stealing mining by himself, and _strat is the destination address of the final sending of funds, the owner can set this address arbitrarily, pay attention to compatibility issues with external contracts, it is recommended to set the ownership to the timelock contract, and add events to record in the add function.  AutofarmV2_CrossChain/AutoFarmV2_CrossChain.sol function add( uint256 _allocPoint, IERC20 _want, bool _withUpdate, address _strat ) public onlyOwner { if (_withUpdate) { massUpdatePools(); } totalAllocPoint = totalAllocPoint.add(_allocPoint); poolInfo.push( PoolInfo({ want: _want, allocPoint: _allocPoint, lastRewardBlock: 0, accAUTOPerShare: 0, 11 strat: _strat }) ); } Fix Status: The ownership has been transfer to timelock contract. Reference https://hecoinfo.com/tx/0xbe90b5dba8315b30a010ea957e9631154857b93d84cdb344c11b339b 5f3e5421 The authority of the Gov role is large, and the address of the external contract can be set arbitrarily. Malicious and wrong external contracts will cause the user's funds to be lost, and there is a issues of excessive authorityit is recommended to set the gov to the timelock contract.  AutofarmV2_CrossChain/StratX2.sol function setEntranceFeeFactor(uint256 _entranceFeeFactor) public { require(msg.sender == govAddress, \"!gov\"); require(_entranceFeeFactor >= entranceFeeFactorLL, \"!safe - too low\"); require(_entranceFeeFactor <= entranceFeeFactorMax, \"!safe - too high\"); entranceFeeFactor = _entranceFeeFactor; } function setWithdrawFeeFactor(uint256 _withdrawFeeFactor) public { require(msg.sender == govAddress, \"!gov\"); require(_withdrawFeeFactor >= withdrawFeeFactorLL, \"!safe - too low\"); require(_withdrawFeeFactor <= withdrawFeeFactorMax, \"!safe - too high\"); withdrawFeeFactor = _withdrawFeeFactor; } function setControllerFee(uint256 _controllerFee) public { require(msg.sender == govAddress, \"!gov\"); require(_controllerFee <= controllerFeeUL, \"too high\"); controllerFee = _controllerFee; } function setbuyBackRate(uint256 _buyBackRate) public { require(msg.sender == govAddress, \"!gov\"); 12 require(buyBackRate <= buyBackRateUL, \"too high\"); buyBackRate = _buyBackRate; } function setGov(address _govAddress) public { require(msg.sender == govAddress, \"!gov\"); govAddress = _govAddress; } function setOnlyGov(bool _onlyGov) public { require(msg.sender == govAddress, \"!gov\"); onlyGov = _onlyGov; } function setUniRouterAddress(address _uniRouterAddress) public { require(msg.sender == govAddress, \"!gov\"); uniRouterAddress = _uniRouterAddress; } function setBuyBackAddress(address _buyBackAddress) public { require(msg.sender == govAddress, \"!gov\"); buyBackAddress = _buyBackAddress; } function setRewardsAddress(address _rewardsAddress) public { require(msg.sender == govAddress, \"!gov\"); rewardsAddress = _rewardsAddress; } Fix Status: The Gov has been transfer to timelock contract. Reference https://hecoinfo.com/tx/0xfdf183915b5659473f9e8e3438c295cb859e022faa073a0a8f12c38e0a 4c257d",
        "labels": [
            "SlowMist",
            "autofarm",
            "Severity: Medium"
        ]
    },
    {
        "title": "4.2.2.2 DoS issues",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - autofarm_en-us.pdf",
        "body": "In the massUpdatePools function, if the length of poolInfo is too large, there is a risk of DoS. It is 13 recommended to limit poolInfo.length to avoid DoS caused by too large length.  AutofarmV2_CrossChain/AutoFarmV2_CrossChain.sol function massUpdatePools() public { uint256 length = poolInfo.length; for (uint256 pid = 0; pid < length; ++pid) { updatePool(pid); } } Fix Status: The issue has been fixed in this commit: b27f2cafcf51667726bd70220420707c89b75975",
        "labels": [
            "SlowMist",
            "autofarm",
            "Severity: Medium"
        ]
    },
    {
        "title": "4.2.3.1 Missing event log",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - autofarm_en-us.pdf",
        "body": "\"setEntranceFeeFactor\" function, \"setWithdrawFeeFactor\" function, \"setControllerFee\" function, \"setbuyBackRate\" function, \"setGov\" function, \"setOnlyGov\" function, \"setUniRouterAddress\" function, \"setBuyBackAddress\" function, \"setRewardsAddress\" function, no events are added to record. It is recommended to add events for recording.  AutofarmV2_CrossChain/StratX2_MDEX.sol  AutofarmV2_CrossChain/StratVLEV2.sol function setEntranceFeeFactor(uint256 _entranceFeeFactor) public { require(msg.sender == govAddress, \"!gov\"); require(_entranceFeeFactor >= entranceFeeFactorLL, \"!safe - too low\"); require(_entranceFeeFactor <= entranceFeeFactorMax, \"!safe - too high\"); entranceFeeFactor = _entranceFeeFactor; } function setWithdrawFeeFactor(uint256 _withdrawFeeFactor) public { require(msg.sender == govAddress, \"!gov\"); require(_withdrawFeeFactor >= withdrawFeeFactorLL, \"!safe - too low\"); 14 require(_withdrawFeeFactor <= withdrawFeeFactorMax, \"!safe - too high\"); withdrawFeeFactor = _withdrawFeeFactor; } function setControllerFee(uint256 _controllerFee) public { require(msg.sender == govAddress, \"!gov\"); require(_controllerFee <= controllerFeeUL, \"too high\"); controllerFee = _controllerFee; } function setbuyBackRate(uint256 _buyBackRate) public { require(msg.sender == govAddress, \"!gov\"); require(buyBackRate <= buyBackRateUL, \"too high\"); buyBackRate = _buyBackRate; } function setGov(address _govAddress) public { require(msg.sender == govAddress, \"!gov\"); govAddress = _govAddress; } function setOnlyGov(bool _onlyGov) public { require(msg.sender == govAddress, \"!gov\"); onlyGov = _onlyGov; } function setUniRouterAddress(address _uniRouterAddress) public { require(msg.sender == govAddress, \"!gov\"); uniRouterAddress = _uniRouterAddress; } function setBuyBackAddress(address _buyBackAddress) public { require(msg.sender == govAddress, \"!gov\"); buyBackAddress = _buyBackAddress; } function setRewardsAddress(address _rewardsAddress) public { require(msg.sender == govAddress, \"!gov\"); rewardsAddress = _rewardsAddress; } Fix Status: 15 The issue has been fixed in this commit: b27f2cafcf51667726bd70220420707c89b75975",
        "labels": [
            "SlowMist",
            "autofarm",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.2.3.2 Missing nonReentrant modifier",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - autofarm_en-us.pdf",
        "body": "The deposit function missing the nonReentrant modifier, it is recommended to add the nonReentrant modifier.  AutofarmV2_CrossChain/StratX2_MDEX.sol function deposit(address _userAddress, uint256 _wantAmt) public onlyOwner whenNotPaused returns (uint256) IERC20(wantAddress).safeTransferFrom( address(msg.sender), address(this), _wantAmt ); uint256 sharesAdded = _wantAmt; if (wantLockedTotal > 0 && sharesTotal > 0) { sharesAdded = _wantAmt .mul(sharesTotal) .mul(entranceFeeFactor) .div(wantLockedTotal) .div(entranceFeeFactorMax); } sharesTotal = sharesTotal.add(sharesAdded); if (isAutoComp) { _farm(); } else { wantLockedTotal = wantLockedTotal.add(_wantAmt); } return sharesAdded; 16 { } Fix Status: The issue has been fixed in this commit: b27f2cafcf51667726bd70220420707c89b75975 5.",
        "labels": [
            "SlowMist",
            "autofarm",
            "Severity: Informational"
        ]
    },
    {
        "title": "Overow issues",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - WombatExchange_en-us.pdf",
        "body": "The data type of priceStruct.expo is int32, and the return result is negative, so uint256(int256(priceStruct.expo)) will get a large value, and 10 ** uint256(int256(priceStruct.expo) will overflow. Because the compiler version used is pragma solidity ^0.8.5;`. ",
        "labels": [
            "SlowMist",
            "WombatExchange",
            "Type: Integer Overow and Underow Vulnerability",
            "Severity: Critical"
        ]
    },
    {
        "title": "Missing event record",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - WombatExchange_en-us.pdf",
        "body": "The owner has the ability to modify the values of the maxPriceAge, shouldCapEquilCovRatio, startCovRatio, endCovRatio parameters, etc. which are global variables, but any modications made to them are not recorded with events. ",
        "labels": [
            "SlowMist",
            "WombatExchange",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Excessive authority issues",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - WombatExchange_en-us.pdf",
        "body": "The Owner can modify priceIDs[_token], priceFeed, fallbackPriceFeed. This will aect the price at which the project gets oracle. The wrong price will lead to a fatal vulnerability in the project. ",
        "labels": [
            "SlowMist",
            "WombatExchange",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Redundant judgment",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - WombatExchange_en-us.pdf",
        "body": "If fromAmount is 0, the code will revert, so if (fromAmount >= 0) should be changed to if (fromAmount > 0). ",
        "labels": [
            "SlowMist",
            "WombatExchange",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "fee management suggestions",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - WombatExchange_en-us.pdf",
        "body": "If the receiving address of fee is an EOA address, there will be a single point risk of private key management. ",
        "labels": [
            "SlowMist",
            "WombatExchange",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "conditional competition issues",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - WombatExchange_en-us.pdf",
        "body": "The llPool function and the transferTipBucket function are controlled by the two roles of dev and owner respectively. When the opinions of the dev and owner are inconsistent, there will be conditional competition issues. ",
        "labels": [
            "SlowMist",
            "WombatExchange",
            "Type: Race Conditions Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Suggestions for variable type conversion",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - WombatExchange_en-us.pdf",
        "body": "The following functions when using uint256 to convert int256, it is not judged whether the variable to be converted is less than type(int256).max, and when using int256 to convert uint256, it is not judged whether the variable is greater than 0. CoreV3.quoteDepositLiquidity CoreV3.quoteWithdrawAmount CoreV3.quoteWithdrawAmountFromOtherAsset CoreV3.quoteSwap CoreV3.quoteSwapTokensForCredit CoreV3.quoteSwapCreditForTokens PoolV3._globalInvariantFunc PoolV3.globalEquilCovRatioWithCredit DynamicPoolV3._globalInvariantFunc PythPriceFeed.getLatestPrice",
        "labels": [
            "SlowMist",
            "WombatExchange",
            "Type: Others",
            "Severity: Low"
        ]
    },
    {
        "title": "Business logic is unclear",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - WombatExchange_en-us.pdf",
        "body": "The _quoteFactor function returns a xed value of 1e18, but the function receives parameters, and the parameters do not need to be used. ",
        "labels": [
            "SlowMist",
            "WombatExchange",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Token compatibility issues",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - WombatExchange_en-us.pdf",
        "body": "When the project is transferred to the token, it does not judge the balance change before and after the transfer of the target address receiving the token, so it is incompatible with reective tokens (deation/ination type tokens), which will cause the balance of the transfer to be inconsistent with the balance actually received, which will lead to calculation errors. ",
        "labels": [
            "SlowMist",
            "WombatExchange",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Redundant type conversion code",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - WombatExchange_en-us.pdf",
        "body": "The _quoteFrom function is using uint256 nalToAssetCovRatio = (toAssetCash + uint256(actualToAmount)).wdiv(toAssetLiability); to convert uint256(actualToAmount), But actualToAmount is of the type uint256, it is no need to convert. ",
        "labels": [
            "SlowMist",
            "WombatExchange",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Authorization limit issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - TransitSwap v4 Core_en-us.pdf",
        "body": "There are two roles Owner and Executor in the contract, and the permissions of the two roles are not clearly divided.",
        "labels": [
            "SlowMist",
            "TransitSwap v4 Core",
            "Type: Authority Control Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Security suggestion",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - TransitSwap v4 Core_en-us.pdf",
        "body": "Since the TransitSwapRouter contract will retain the user's authorization limit, it is recommended to allow the user to allocate on demand during the front-end authorization, and do not authorize the maximum value at one time to prevent the user's funds from being stolen. 11",
        "labels": [
            "SlowMist",
            "TransitSwap v4 Core",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing zero address check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - TransitSwap v4 Core_en-us.pdf",
        "body": "When modifying important addresses in the contract, it is not checked whether the incoming address is a zero address. ",
        "labels": [
            "SlowMist",
            "TransitSwap v4 Core",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - TransitSwap v4 Core_en-us.pdf",
        "body": "The Owner has the risk of over-authorization, and this role can withdraw the tokens in the contract to any address. ",
        "labels": [
            "SlowMist",
            "TransitSwap v4 Core",
            "Type: Authority Control Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Authority control issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - TransitSwap v4 Core_en-us.pdf",
        "body": "The contract adopts a completely open calling logic. There is an operation to authorize the approveAddress address in the _beforeSwap function. The calling path of this function is TransitSwapRouter.swap() -> TransitSwap.swap() -> TransitSwap._beforeSwap(). The calldata parameter is also passed in when calling the top-level function TransitSwapRouter.swap(). The code does not check whether the approveAddress is legal. If a malicious approveAddress is passed in, the contract will be incorrectly authorized and the tokens in the contract will be lost. ",
        "labels": [
            "SlowMist",
            "TransitSwap v4 Core",
            "Type: Authority Control Vulnerability",
            "Severity: High"
        ]
    },
    {
        "title": "Uninitialized parameter",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - TransitSwap v4 Core_en-us.pdf",
        "body": "The swapAmount parameter is declared in the contract but not initialized. ",
        "labels": [
            "SlowMist",
            "TransitSwap v4 Core",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Unsafe external call",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - TransitSwap v4 Core_en-us.pdf",
        "body": "The path and pair parameters in the supportingFeeOn function are controllable. If an attacker passes in malicious path and pair parameters, it may cause unexpected errors. ",
        "labels": [
            "SlowMist",
            "TransitSwap v4 Core",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing Approve amount reset",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - TransitSwap v4 Core_en-us.pdf",
        "body": "The _beforeSwap function in the TransitSwap contract will set the authorization limit to the maximum value when accessing the token for the rst time, but the function to remake the authorization is not found in the contract. When the authorization limit is used up, it will not be able to remake and the token cannot be used.",
        "labels": [
            "SlowMist",
            "TransitSwap v4 Core",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "4.2.1.1 __Guard_init function was not call when initialize",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Hot Cross BSC Bridge V1.0.0_en-us.pdf",
        "body": "ForeignProcessor contract and HomeRequest contract are inherit the Guard contract but dost not call the __Gurad_init function function __ForeignProcessor_init( IERC20 token, ValidatorRegistry validatorRegistry_ ) internal initializer { //SlowMist// Missing call of __Guard_init function require( address(token) != address(0) && Misc.isContract(address(token)), \"ForeignProcessor:Invalid erc20 address provided\" 10 ); require( address(validatorRegistry_) != address(0) && Misc.isContract(address(validatorRegistry_)), \"ForeignProcessor:Invalid validator registry address\" ); erc20 = token; validatorRegistry = validatorRegistry_; } function __HomeRequest_init( BEP20 token, ValidatorRegistry validatorRegistry_ ) internal initializer { //SlowMist// Missing call of __Guard_init function require( address(token) != address(0) && Misc.isContract(address(token)), \"HomeRequest:Invalid BEP20 address\" ); require( address(validatorRegistry_) != address(0) && Misc.isContract(address(validatorRegistry_)), \"HomeRequest:Invalid validator registry address\" ); bep20 = token; validatorRegistry = validatorRegistry_; } Fix status: fixed. 11 5.",
        "labels": [
            "SlowMist",
            "Hot Cross BSC Bridge V1.0.0",
            "Severity: Informational"
        ]
    },
    {
        "title": "Tokens Obtained from Emergency Withdrawal Partly Locked",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist_Audit_Report_StakeStone_MellowDepositWstETHStrategy_en-us.pdf",
        "body": "In the MellowDepositWstETHStrategy contract, the owner role can execute an emergency withdrawal operation from the mellowVault contract by calling the emergencyWithdrawFromMellow function. In the mellowVault contract, during an emergency withdrawal operation, the specied amount of LP tokens from previous withdrawal requests are burned, and two types of tokens, wstETH and DC_wstETH, are transferred to the address indicated in the withdrawal request. The amounts transferred are calculated based on the burned LP tokens and the current balance of these two tokens in the pool. However, in the MellowDepositWstETHStrategy contract, there is no implementation for redeeming DC_wstETH tokens back into wstETH, which results in these DC_wstETH tokens being locked within the contract. Furthermore, when calculating the total invested value of the contract using the getInvestedValue function, it fails to account for the value of the held DC_wstETH tokens. Code Location: contracts/strategies/MellowDepositWstETHStrategy.sol function getInvestedValue() public override returns (uint256 value) { uint256 etherValue = address(this).balance; uint256 stETHValue = IERC20(stETHAddr).balanceOf(address(this)); (, uint256 claimableValue, uint256 pendingValue) = checkPendingAssets(); uint256 mellowPending = getPendingValueFromMellow(); value = etherValue + stETHValue + claimableValue + pendingValue + getWstETHValue() + getDepositedValue() + mellowPending; } ... function emergencyWithdrawFromMellow( uint256[] memory _minAmounts, uint256 _deadline ) external onlyOwner returns (uint256 wstETHAmount) { IMellowVault(mellowVaultAddr).emergencyWithdraw(_minAmounts, _deadline); }",
        "labels": [
            "SlowMist",
            "SlowMist_Audit_Report_StakeStone_MellowDepositWstETHStrategy",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "The Potential Risk of Fixed Array Lengths",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist_Audit_Report_StakeStone_MellowDepositWstETHStrategy_en-us.pdf",
        "body": "In the MellowDepositWstETHStrategy contract, the owner role can call the depositIntoMellow function to deposit wstETH tokens from the contract into the MellowVault, where the length of the passed amounts array is xed at 1. Within the deposit function of the MellowVault contract, a check is performed to ensure that the lengths of the contract's _underlyingTokens array and the passed amounts array are equal. Currently, as the _underlyingTokens array in the MellowVault contract also contains only 1 element, this check passes successfully. However, the MellowVault contract features a function (addToken) that allows for adding new token data to the _underlyingTokens array. If, in the future, the _underlyingTokens array expands due to the addition of new tokens, the depositIntoMellow function may fail this length check and consequently be unable to execute properly. The same issues also apply when making a withdrawal request. Code Location: contracts/strategies/MellowDepositWstETHStrategy.sol#L177&L200 function depositIntoMellow( uint256 _wstETHAmount, uint256 _minLpAmount ) external onlyOwner returns (uint256 lpAmount) { require(_wstETHAmount != 0, \"zero\"); TransferHelper.safeApprove(wstETHAddr, mellowVaultAddr, _wstETHAmount); uint256[] memory amounts = new uint256[](1); amounts[0] = _wstETHAmount; (, lpAmount) = IMellowVault(mellowVaultAddr).deposit( address(this), amounts, _minLpAmount, block.timestamp ); emit DepositIntoMellow( mellowVaultAddr, address(this), _wstETHAmount, lpAmount ); } function requestWithdrawFromMellow( uint256 _share, uint256 _minAmount ) external onlyOwner { require(_share != 0, \"zero\"); uint256[] memory amounts = new uint256[](1); amounts[0] = _minAmount; IMellowVault(mellowVaultAddr).registerWithdrawal( address(this), _share, amounts, block.timestamp, type(uint256).max, true ); emit WithdrawFromMellow(mellowVaultAddr, address(this), _share); }",
        "labels": [
            "SlowMist",
            "SlowMist_Audit_Report_StakeStone_MellowDepositWstETHStrategy",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Conict in withdrawal requests",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist_Audit_Report_StakeStone_MellowDepositWstETHStrategy_en-us.pdf",
        "body": "In the MellowDepositWstETHStrategy contract, The owner role can initiate a withdrawal request for wstETH by calling the requestWithdrawFromMellow function, with the closePrevious parameter set to true by default. This implies that if a previous withdrawal request has been submitted and is still pending, it will rst be canceled before replacing it with the newly submitted withdrawal request. Code Location: contracts/strategies/MellowDepositWstETHStrategy.sol#L208 function requestWithdrawFromMellow( uint256 _share, uint256 _minAmount ) external onlyOwner { require(_share != 0, \"zero\"); uint256[] memory amounts = new uint256[](1); amounts[0] = _minAmount; IMellowVault(mellowVaultAddr).registerWithdrawal( address(this), _share, amounts, block.timestamp, type(uint256).max, true ); emit WithdrawFromMellow(mellowVaultAddr, address(this), _share); }",
        "labels": [
            "SlowMist",
            "SlowMist_Audit_Report_StakeStone_MellowDepositWstETHStrategy",
            "Type: Design Logic Audit",
            "Severity: Information"
        ]
    },
    {
        "title": "Redundant code",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Owlto Depositor_en-us.pdf",
        "body": "There are useless codes in the le and codes that are not used in actual business. Code Location: Depositor.sol#L225-227 contract Depositor { ... error NotOwnerError(); error LengthError(); error ZeroAddressError(); ... }",
        "labels": [
            "SlowMist",
            "Owlto Depositor",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Spelling mistake",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Owlto Depositor_en-us.pdf",
        "body": "Spelling mistake was identied within the code. Code Location: Depositor.sol function isContractt(address account) internal view returns (bool) { // This method relies on extcodesize, which returns 0 for contracts in // construction, since the code is only stored at the end of the // constructor execution. uint256 size; // solhint-disable-next-line no-inline-assembly assembly { size := extcodesize(account) } return size > 0; } ... function callOptionalReturn(IERC20 token, bytes memory data) private { ... require(address(token).isContractt(), \"SafeERC20: call to non-contract\"); ... }",
        "labels": [
            "SlowMist",
            "Owlto Depositor",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "4.2.1.1 Excessive auditing authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - MoonSwap_en-us.pdf",
        "body": "The owner in MasterStar contract can add a new lpToken through the add function, but if there is a black swan event, such as the addition of a malicious lpToken, there will be useless lpToken to recharge to get rewards. It is suggested that the owner can be handed over to the governance contract or time lock contract for management. function add(uint256 _allocPoint, IERC20 _lpToken, bool _withUpdate) public onlyOwner { if (_withUpdate) { massUpdatePools(); } require(poolIndexs[address(_lpToken)] < 1, \"LpToken exists\"); uint256 lastRewardBlock = block.number > startBlock ? block.number : startBlock; totalAllocPoint = totalAllocPoint.add(_allocPoint); poolInfo.push(PoolInfo({ lpToken: _lpToken, allocPoint: _allocPoint, lastRewardBlock: lastRewardBlock, tokenPerBlock: currentTokenPerBlock, accTokenPerShare: 0, finishMigrate: false, lockCrosschainAmount:0, crosschain_enable: false })); poolIndexs[address(_lpToken)] = poolInfo.length; } Owner can set migrator , It is suggested that the owner can be handed over to the governance contract or time lock contract for management. function setMigrator(IMigratorStar _migrator) public onlyOwner { migrator = _migrator; 7 } //Migratelptokentoanotherlpcontract.Canbecalledbyanyone.Wetrustthatmigratorcontractisgood. function migrate(uint256 _pid) public { require(address(migrator) != address(0), \"migrate: no migrator\"); PoolInfo storage pool = poolInfo[_pid]; IERC20 lpToken = pool.lpToken; uint256 bal = lpToken.balanceOf(address(this)); lpToken.safeApprove(address(migrator), bal); IERC20 newLpToken = migrator.migrate(lpToken); require(bal == newLpToken.balanceOf(address(this)), \"migrate: bad\"); pool.lpToken = newLpToken; pool.finishMigrate = true; } Fixed: The owner authority has been transferred to the timelock contract. Reference: https://etherscan.io/tx/0x3e8be2489c824906c7fe1abe376ccea198e3cd28cb225dee91d4f9c3e9 62a889",
        "labels": [
            "SlowMist",
            "MoonSwap",
            "Severity: Low"
        ]
    },
    {
        "title": "4.2.2.1 Compiler version is inconsistent",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - MoonSwap_en-us.pdf",
        "body": "The compiler version used by the imported contract is inconsistent. It is recommended to use a unified fixed compiler version when deploying. pragma solidity ^0.6.0; pragma solidity ^0.6.2; pragma solidity 0.6.12;",
        "labels": [
            "SlowMist",
            "MoonSwap",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.2.2.2 Better handling of ownership transfers",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - MoonSwap_en-us.pdf",
        "body": "When using the transferOwnership function to change the owner, it is recommended to add a 8 confirmation method that newOwner accepts the owner. The real authority transfer is performed after the new address is signed and confirmed to avoid the loss of authority. function transferOwnership(address newOwner) public virtual onlyOwner { require(newOwner != address(0), \"Ownable: new owner is the zero address\"); emit OwnershipTransferred(_owner, newOwner); _owner = newOwner; }",
        "labels": [
            "SlowMist",
            "MoonSwap",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.2.2.3 Enhancement point of delegateBySig function",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - MoonSwap_en-us.pdf",
        "body": "The nonce in the delegateBySig function is input by the user. When the user input a larger nonce, the current transaction cannot be success but the relevant signature data will still remain on the chain, causing this signature to be available for some time in the future. It is recommended to fix it according to EIP-2612. Reference: https://github.com/ethereum/EIPs/blob/master/EIPS/eip-2612.md#implementation. function delegateBySig( address delegatee, uint nonce, uint expiry, uint8 v, bytes32 r, bytes32 s external ) { bytes32 domainSeparator = keccak256( abi.encode( DOMAIN_TYPEHASH, keccak256(bytes(name())), getChainId(), address(this) ) ); 9 bytes32 structHash = keccak256( abi.encode( DELEGATION_TYPEHASH, delegatee, nonce, expiry ) ); bytes32 digest = keccak256( abi.encodePacked( \"\\x19\\x01\", domainSeparator, structHash ) ); address signatory = ecrecover(digest, v, r, s); require(signatory != address(0), \"MOON::delegateBySig: invalid signature\"); require(nonce == nonces[signatory]++, \"MOON::delegateBySig: invalid nonce\"); require(now <= expiry, \"MOON::delegateBySig: signature expired\"); return _delegate(signatory, delegatee); }",
        "labels": [
            "SlowMist",
            "MoonSwap",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.2.2.4 Mint issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - MoonSwap_en-us.pdf",
        "body": "The owner can mint tokens unlimitedly through mint function, but the owner's authority of the token contract is changed to MasterStar contract for the first time. function mint(address _to, uint256 _amount) public onlyOwner { _mint(_to, _amount); _moveDelegates(address(0), _delegates[_to], _amount); } Fixed: The owner authority has actually been transferred to the MasterStar contract. Reference: 10 https://etherscan.io/tx/0x0303672ee5045cd01102fdb50787541d11bddc3e1bfc446d4f6b46db85 e65bff",
        "labels": [
            "SlowMist",
            "MoonSwap",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.2.2.5 Using now globally available variables that will be deprecated",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - MoonSwap_en-us.pdf",
        "body": "The now globally available variables is used, which has been deprecated in compiler solidity 0.7.0. require(signatory != address(0), \"MOON::delegateBySig: invalid signature\"); require(nonce == nonces[signatory]++, \"MOON::delegateBySig: invalid nonce\"); require(now <= expiry, \"MOON::delegateBySig: signature expired\");",
        "labels": [
            "SlowMist",
            "MoonSwap",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.2.2.6 0 value is not checked",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - MoonSwap_en-us.pdf",
        "body": "The withdraw function suggests adding a check of _amount> 0, which can optimize the gas consumption when _amount is 0. function withdraw(uint256 _pid, uint256 _amount) public { PoolInfo storage pool = poolInfo[_pid]; require(!pool.finishMigrate, \"migrate not withdraw\"); UserInfo storage user = userInfo[_pid][msg.sender]; require(user.amount >= _amount, \"withdraw: not good\"); updatePool(_pid); uint256 pending = user.amount.mul(pool.accTokenPerShare).div(1e12).sub(user.rewardDebt); safeTokenTransfer(msg.sender, pending); user.amount = user.amount.sub(_amount); user.rewardDebt = user.amount.mul(pool.accTokenPerShare).div(1e12); pool.lpToken.safeTransfer(address(msg.sender), _amount); emit Withdraw(msg.sender, _pid, _amount); }",
        "labels": [
            "SlowMist",
            "MoonSwap",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.2.2.7 Prompt Error",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - MoonSwap_en-us.pdf",
        "body": "The prompt of setCrosschain function require has an error \"migrate not deposit\", it is recommended to modify the prompt to \"migrate not setCrosschain\". 11 function setCrosschain(uint256 _pid, bool isOk, address cmoonAddr) public onlyOwner { PoolInfo storage pool = poolInfo[_pid]; require(pool.finishMigrate, \"migrate not deposit\"); pool.crosschain_enable = isOk; require(cmoonAddr != address(0), \"address invalid\"); migratePoolAddrs[_pid] = cmoonAddr; } Fixed: The issue has been fixed by this commit: ef19afe4b6bfd624dd79903c36ea335be6a7b283.",
        "labels": [
            "SlowMist",
            "MoonSwap",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.2.2.8 Better handling of devaddr transfers",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - MoonSwap_en-us.pdf",
        "body": "When changing devaddr in the dev function, it is recommended to add newDevaddr to accept the replacement confirmation method. After the new address is signed and confirmed, the real change to devaddr can be made to avoid setting errors and the income cannot be normally obtained. function dev(address _devaddr) public { require(msg.sender == devaddr, \"dev: wut?\"); devaddr = _devaddr; }",
        "labels": [
            "SlowMist",
            "MoonSwap",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.2.2.9 Coding Standards",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - MoonSwap_en-us.pdf",
        "body": "The coding style of emergencyWithdraw function is to make an external call first, and then change the value of the contract variable. This way of writing, because lpToken is considered safe, there is no reentrancy problem, but it is recommended to use the correct coding standard: The variable is changed, and then an external call is made. A lock modifier for reentrancy prevention can also be added. function emergencyWithdraw(uint256 _pid) public { PoolInfo storage pool = poolInfo[_pid]; require(!pool.finishMigrate, \"migrate not withdraw\"); UserInfo storage user = userInfo[_pid][msg.sender]; pool.lpToken.safeTransfer(address(msg.sender), user.amount); 12 emit EmergencyWithdraw(msg.sender, _pid, user.amount); user.amount = 0; user.rewardDebt = 0; } Fixed: The issue has been fixed by this commit: ef19afe4b6bfd624dd79903c36ea335be6a7b283 5.",
        "labels": [
            "SlowMist",
            "MoonSwap",
            "Severity: Informational"
        ]
    },
    {
        "title": "Lack of previous pool status check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Stake Mask_en-us.pdf",
        "body": "In the StakeManager contract, the user can deposit funds into the contract by calling the depositAndLock function and withdraw funds by calling the withdraw function. However, when a new pool is added and currentPoolId is updated to the id of the new pool, the user calls depositAndLock function again to make a deposit without checking the unlocked state of the pool that the user deposited in before. So the poolId in the user's information will be directly overwritten with the new currentPoolId, even if the pool state at the time of the previous deposit was a locked state. If the state of the new pool is unlocked, the withdraw function can be called directly to withdraw all of the user's deposits, even if the pool where the rst deposit was made was in a locked state. Code Location: src/StakeManager.sol function depositAndLock(uint256 _amount) public nonReentrant { Pool storage pool = pools[currentPoolId]; require(pool.stakingEnabled, \"Staking is disabled for this pool\"); require(maskToken.transferFrom(msg.sender, address(this), _amount), \"Transfer failed\"); userInfos[msg.sender].stakedAmount += _amount; // depositAndLock will always stake to currentPoolId // it will init userInfos[msg.sender].poolId for the first time // it will change userInfos[msg.sender].poolId to currntPoolId(which means new pool) when // user deposit after prev pool unlocked userInfos[msg.sender].poolId = currentPoolId; emit Staked(msg.sender, currentPoolId, _amount); } function withdraw(uint256 _amount) public nonReentrant { Pool storage pool = pools[userInfos[msg.sender].poolId]; require(pool.unlocked, \"Pool is locked\"); require(userInfos[msg.sender].stakedAmount >= _amount, \"Insufficient balance\"); userInfos[msg.sender].stakedAmount -= _amount; require(maskToken.transfer(msg.sender, _amount), \"Transfer failed\"); emit unstaked(msg.sender, userInfos[msg.sender].poolId, _amount); }",
        "labels": [
            "SlowMist",
            "Stake Mask",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Dierence check when changing pools",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Stake Mask_en-us.pdf",
        "body": "In the StakeManager contract, the user can update the poolId in the user information to the latest currentPoolId by calling the changePool function. However, there is no check to see if the currentPoolId matches the poolId in the user information. Code Location: src/StakeManager.sol function changePool() public nonReentrant { uint8 fromPoolId = userInfos[msg.sender].poolId; Pool storage fromPool = pools[userInfos[msg.sender].poolId]; Pool storage toPool = pools[currentPoolId]; require(toPool.stakingEnabled, \"Staking is disabled for this pool\"); require(fromPool.unlocked, \"From pool is locked\"); require(userInfos[msg.sender].stakedAmount > 0, \"No staked amount\"); userInfos[msg.sender].poolId = currentPoolId; emit StakeChanged(msg.sender, fromPoolId, currentPoolId); }",
        "labels": [
            "SlowMist",
            "Stake Mask",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing return value check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Stake Mask_en-us.pdf",
        "body": "In the Reward contract, the owner can call the emergencyWithdraw function to transfer any tokens in the contract. But it does not check the return value. If external tokens do not adopt the EIP20 standard, it may lead to false top-up issues. ",
        "labels": [
            "SlowMist",
            "Stake Mask",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Stake Mask_en-us.pdf",
        "body": "In the Reward contract, the owner can call the emergencyWithdraw function to transfer any tokens in the contract. If the privilege is lost or misused, there may be an impact on the user's funds. ",
        "labels": [
            "SlowMist",
            "Stake Mask",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "4.3.1.2 Risk of loss of user funds",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DODOV2_en-us.pdf",
        "body": "In the LockTokenVault contract, when transferring the user's locked token, it did not check whether the _to address is msg.sender itself, which caused the user to abuse the transfer and cause a loss of funds. function transferLockedToken(address to) external { originBalances[to] = originBalances[to].add(originBalances[msg.sender]); claimedBalances[to] = claimedBalances[to].add(claimedBalances[msg.sender]); originBalances[msg.sender] = 0; claimedBalances[msg.sender] = 0; } Fix status: fixed, repair commit: main-08a06609604779c31db493bc0d755efa1c3f0a61.",
        "labels": [
            "SlowMist",
            "DODOV2",
            "Severity: Low"
        ]
    },
    {
        "title": "4.2.2.1 Missing events",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DODOV2_en-us.pdf",
        "body": "Contract  DODOApproveProxy  Function list  init / unlockAddProxy / addDODOProxy / LockAddProxy / removeDODOProxy ContractDODOApproveFunction listinit / unlockSetProxy / setDODOProxy / LockSetProxy ContractDODV2Proxy02Function listaddWhiteList / removeWhiteList / updateGasReturn ContractDVMFactorFunction listupdateDvmTemplate ContractDPPAdvanceFunction listtunePrice ContractDPPAdvance Function listsetOperator / setFreezeTimestamp ContractDPPVaultFunction listratioSync / retrieve 6 ContractDVMVault Function list_setReserve_sync The above functions does not have an event declaration, it is recommended to add the corresponding event declaration Fix status: After communicating with the project party, it is confirmed that the above event statement is not currently used in business and will be fixed in subsequent iterations.",
        "labels": [
            "SlowMist",
            "DODOV2",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.2.2.2 The contract balance was not verified when the reward was distributed",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DODOV2_en-us.pdf",
        "body": "In the RewardVault contract, the contract balance is not verified when the reward is distributed, which may cause the contract balance to fail to be distributed function reward(address to, uint256 amount) external onlyOwner { //SlowMist// Not verify if contract balance is larger than the transfer amount IERC20(dodoToken).safeTransfer(to, amount); } Fix situation: After confirming with the project party, they ignore this problem.",
        "labels": [
            "SlowMist",
            "DODOV2",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.2.2.3 Unchecked array length",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DODOV2_en-us.pdf",
        "body": "a. The getPendingReward function in the BaseMine contract did not verify whether the value of i passed in was less than the length of the array when obtaining the reward of the pool, which resulted in the failure to obtain the reward. function getPendingReward(address user, uint256 i) public view returns (uint256) { //SlowMist// Not verify the array length RewardTokenInfo storage rt = rewardTokenInfos[i]; uint256 accRewardPerShare = rt.accRewardPerShare; if (rt.lastRewardBlock != block.number) { accRewardPerShare = _getAccRewardPerShare(i); } return 7 DecimalMath.mulFloor( balanceOf(user), accRewardPerShare.sub(rt.userRewardPerSharePaid[user]) ).add(rt.userRewards[user]); } Fix status: fixed, repair commit: feature/mineV2AndDSP- 5917c95439cac06241f108038043d2 2348c863e6. b. The claimReward function in the BaseMine contract does not verify whether the value of i passed in is less than the length of the array, resulting in failure to obtain rewards function claimReward(uint256 i) public { require(i<rewardTokenInfos.length, \"DODOMineV2: REWARD_ID_NOT_FOUND\"); _updateReward(msg.sender, i); RewardTokenInfo storage rt = rewardTokenInfos[i]; uint256 reward = rt.userRewards[msg.sender]; if (reward > 0) { rt.userRewards[msg.sender] = 0; IRewardVault(rt.rewardVault).reward(msg.sender, reward); emit Claim(i, msg.sender, reward); } } Fix status: fixed, repair commit: feature/mineV2AndDSP- 5917c95439cac06241f108038043d2 2348c863e6.",
        "labels": [
            "SlowMist",
            "DODOV2",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.2.2.4 Compatibility risk of rebasing tokens",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DODOV2_en-us.pdf",
        "body": "The deposit function of the ERC20Mine contract does not verify the incoming amount. When it is compatible with rebasing tokens, it will cause an error to obtain the transfer amount. function claimReward(uint256 i) public { require(i<rewardTokenInfos.length, \"DODOMineV2: REWARD_ID_NOT_FOUND\"); _updateReward(msg.sender, i); 8 RewardTokenInfo storage rt = rewardTokenInfos[i]; uint256 reward = rt.userRewards[msg.sender]; if (reward > 0) { rt.userRewards[msg.sender] = 0; IRewardVault(rt.rewardVault).reward(msg.sender, reward); emit Claim(i, msg.sender, reward); } } Fix status: fixed, fix commit: main-d26b21bd814d4bfcc702521d52f6cb3af4f86e5c. 5.",
        "labels": [
            "SlowMist",
            "DODOV2",
            "Severity: Informational"
        ]
    },
    {
        "title": "Unchecked asset type in inputEth function allows potential asset mismatch",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Doubler Lite.pdf",
        "body": "The input function lacks a crucial check to verify if the _asset parameter corresponds to an ETH pool. This oversight creates a potential vulnerability. In a scenario where both ETH and BTC pools exist, a user could potentially input ETH but have it processed as BTC. This mismatch between the intended and actual asset type could lead to unexpected behavior and potential exploitation of the system. contracts/Doubler.sol function inputEth( address _asset, uint256 _qAmount, address _to ) external payable nonReentrant onlyOncePerBlock onlyAsset(_asset) { if (msg.value != _qAmount) revert E_Balance(); _input(_asset, _qAmount, _to, true); }",
        "labels": [
            "SlowMist",
            "Doubler Lite",
            "Type: Others",
            "Severity: Low"
        ]
    },
    {
        "title": "Issue with fee allocation in the _limitMint function",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Doubler Lite.pdf",
        "body": "In the _limitMint function, the distribution of minting fees should be based on the length of _srvFeeAddr . Currently, the number of _srvFeeAddr entries called from the Doubler contract is only 2. However, if other contracts call this function with a dierent length of _srvFeeAddr in the future, it will result in allocating more fees than intended. contracts/RBToken.sol function _limitMint( address _recipient, uint256 _tokenAmount, uint256 _poolTotalLimit, address[] memory _srvFeeAddr, uint16 _srvFeeRatio ) internal returns (uint256 recipientTokenAmount) { ... _totalShare = _totalShare + newShares; uint256 recipientNewShare = newShares; recipientTokenAmount = _tokenAmount; if (_srvFeeRatio > 0) { uint256 srvFee = (newShares * _srvFeeRatio) / _perMil; recipientTokenAmount = recipientTokenAmount - (_tokenAmount * _srvFeeRatio) / _perMil; for (uint8 i = 0; i < _srvFeeAddr.length; i++) { _shares[_srvFeeAddr[i]] = _shares[_srvFeeAddr[i]] + srvFee / 2; recipientNewShare = recipientNewShare - srvFee / 2; _emitTransferEvents(address(0x0), _recipient, (_tokenAmount * _srvFeeRatio) / _perMil, srvFee); } } _shares[_recipient] = _shares[_recipient] + recipientNewShare; _emitTransferEvents(address(0x0), _recipient, recipientTokenAmount, recipientNewShare); }",
        "labels": [
            "SlowMist",
            "Doubler Lite",
            "Type: Others",
            "Severity: Low"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Doubler Lite.pdf",
        "body": "The owner can modify the fees and fee recipients in the pool, which can cause damage to the project's funds if the private key is compromised. contracts/Doubler.sol owner can initializeDoubler owner can updateLowerOfInputMaximum owner can newPool owner can updatePool ADMIN can set the upper and lower price limits of the prediction machine, which will aect the functionality of the contract if ADMIN's private key is compromised. contracts/FastPriceFeed.sol ADMIN can setAssetPriceLimit ADMIN can setPriceFeedTimeLimit ADMIN can newAsset ADMIN can switchPriceFeed The owner can set the address where the fee will be charged, and if the private key is leaked, it will result in the loss of the project's funds. contracts/DoublerFactory.sol contracts/DoublerFactory.sol owner can updateEcoAddr owner can newPool",
        "labels": [
            "SlowMist",
            "Doubler Lite",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Potential bypass Issue with onlyOncePerBlock",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Doubler Lite.pdf",
        "body": "In the design logic of doubler lite, atoken, btoken, and ctoken are all transferable. The onlyOncePerBlock mechanism is intended to restrict a user to a single function operation within one block. However, this restriction only applies to msg.sender, allowing users to bypass the limitation by making calls through multiple contracts. contracts/Doubler.sol modifier onlyOncePerBlock() { if (_lastBlockCalled[msg.sender] >= block.number) revert E_BlockOnce(); _; _lastBlockCalled[msg.sender] = block.number; }",
        "labels": [
            "SlowMist",
            "Doubler Lite",
            "Type: Others",
            "Severity: Medium"
        ]
    },
    {
        "title": "Abnormal implementation logic in getPooledByShares",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Doubler Lite.pdf",
        "body": "In the getPooledByShares function, it should retrieve the corresponding token amount based on sharesAmount. However, the actual interface called retrieves sharesAmount based on the token amount. contracts/RBToken.sol function getPooledByShares(uint256 _sharesAmount) public view returns (uint256) { return _getSharesByPooledToken(_sharesAmount); }",
        "labels": [
            "SlowMist",
            "Doubler Lite",
            "Type: Others",
            "Severity: Low"
        ]
    },
    {
        "title": "Potential risk due to the unique nature of 10xBToken",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Doubler Lite.pdf",
        "body": "Since 10xBToken is a special type of token where users hold shares instead of actual quantities, there may be an extreme risk when users add liquidity providers. In an extreme scenario, subsequent investors can obtain a large number of shares, causing the price of BToken in the pool to rise sharply (because the actual token quantity obtainable by the pools shares decreases). This could result in liquidity providers incurring losses as a small amount of tokens might be used to exchange for a large amount of corresponding assets. Status Acknowledged",
        "labels": [
            "SlowMist",
            "Doubler Lite",
            "Type: Others",
            "Severity: Information"
        ]
    },
    {
        "title": "Impact of inationary or deationary tokens on the doubler lite economic model",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Doubler Lite.pdf",
        "body": "In the economic model of Doubler Lite, the use of inationary (e.g., stETH) or deationary tokens does not aect the overall economic model. This is because all calculations are based on shares, and the ination or deation impacts only the temporary average price of the tokens, which aligns with the design expectations. Status Acknowledged",
        "labels": [
            "SlowMist",
            "Doubler Lite",
            "Type: Others",
            "Severity: Information"
        ]
    },
    {
        "title": "Recommendations for parameter checking",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Doubler Lite.pdf",
        "body": "contracts/Doubler.sol Suggest checking startTime, endTime to make sure startTime is less than endTime, and checking creator to make sure creator is not address(0). function _checkPoolParam(Pool memory _pl) internal pure { if (_pl.inputFee > 20) revert E_FeeLimit(); if (_pl.withdrawFee > 20) revert E_FeeLimit(); }",
        "labels": [
            "SlowMist",
            "Doubler Lite",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Redundant code",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Send V1.0.1_en-us.pdf",
        "body": "Ether is not accepted by default, which is a redundant code. cross-send/contracts/CrossSend.sol#L41-L47 initial-hotcross-oering/contracts/BaseIHO.sol#L67-L73 fallback () external payable { revert(\"cannot directly accept currency transfers\"); } receive () external payable { revert(\"cannot directly receive currency transfers\"); 15 }",
        "labels": [
            "SlowMist",
            "Cross Send V1.0.1",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Gas optimization",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Send V1.0.1_en-us.pdf",
        "body": "If one of the batch transfers fails, the transaction that was previously transferred normally will be reverted, but Gas has been consumed. It is a gas optimization issue here. cross-send/contracts/CrossSend.sol#L175-L210 function sendToken( IERC20 token, address[] memory recipients, uint256[] memory amounts ) private returns(uint256) { uint256 total = 0; for (uint256 i = 0; i < recipients.length ; i++) { require(_msgSender() != recipients[i], \"sender != recipient\"); token.safeTransferFrom(_msgSender(), recipients[i], amounts[i]); total += amounts[i]; } return total; } function sendNative( address[] memory recipients, uint256[] memory amounts ) private returns(uint256) { uint256 total = 0; 16 for (uint256 i = 0; i < recipients.length ; i++) { total += amounts[i]; (bool success, ) = payable(recipients[i]).call{value: amounts[i]}(\"\"); require(success, \"native transfer failed\"); } return total; }",
        "labels": [
            "SlowMist",
            "Cross Send V1.0.1",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of allowance amount abuse",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Send V1.0.1_en-us.pdf",
        "body": "There have an allowance amount in the contract, but the distributeTokenFee function does not limit the caller, and there is an issue of being called arbitrarily, but it can only transfer the balance of the sender to the feeCollector. cross-send/contracts/fee-managers/RecipientCountFee.sol#L65-L83 function distributeTokenFee( uint256 txRecipientCount, uint256, uint256, uint256, uint256, address sender ) public override { uint256 payableFee = txRecipientCount * tokenFeePerRecipient; 17 if(payableFee < minTokenFee) { payableFee = minTokenFee; } else if (payableFee > maxTokenFee) { payableFee = maxTokenFee; } token.safeTransferFrom(sender, feeCollector, payableFee); }",
        "labels": [
            "SlowMist",
            "Cross Send V1.0.1",
            "Type: Authority Control Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Price manipulation issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Send V1.0.1_en-us.pdf",
        "body": "The IOUPrice is calculated using totalFarmingTokenBalance. Attackers can control totalFarmingTokenBalance to manipulate IOUPrice. The current code does not nd the location where IOUPrice is used. Referencehttps://slowmist.medium.com/cream-hacked-analysis-us-130-million-hacked-95c9410320ca cross-yield/contracts/core/CrossYield.sol#L95-L101 function IOUPrice() public view returns (uint256) { uint256 IOUSupply = totalSupply(); return IOUSupply == 0 ? 1e18 : (totalFarmingTokenBalance() * 1e18) / IOUSupply; } 18 cross-yield/contracts/core/CrossYield.sol#L65-L67 function totalFarmingTokenBalance() public view returns (uint256) { return farmingToken().balanceOf(address(this)) + strategy.balanceOf(); }",
        "labels": [
            "SlowMist",
            "Cross Send V1.0.1",
            "Type: Others",
            "Severity: Medium"
        ]
    },
    {
        "title": "Sandwich attacks issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Send V1.0.1_en-us.pdf",
        "body": "There is no slippage check during swap, and there is a risk of sandwich attack. IPancakeRouter02(pcsRouter).swapExactTokensForTokens(cakeBalance, 0,cakeToBaseRoute, address(this), block.timestamp); IPancakeRouter02(pcsRouter) .swapExactTokensForTokens(toSwap, 0, route, address(this), block.timestamp); Reference https://medium.com/coinmonks/demystify-the-dark-forest-on-ethereum-sandwich-attacks-5a3aec9fa33e cross-yield/contracts/libs/OptimalSwap.sol#L14-L63 function prepareLiquidity( address cake, address[2] memory lpTokens, 19 address wbnb, address busd, address farmingToken, address pcsRouter, uint256 fee ) external { uint256 cakeBalance = IERC20(cake).balanceOf(address(this)); bool isCakeInLp = lpTokens[0] == cake || lpTokens[1] == cake; bool isWbnbBased = lpTokens[0] == wbnb || lpTokens[1] == wbnb; address baseToken = isWbnbBased ? wbnb : busd; // if cake is not part of the lp token, swap all cake for the base token if (!isCakeInLp) { address[] memory cakeToBaseRoute = new address[](2); cakeToBaseRoute[0] = cake; cakeToBaseRoute[1] = baseToken; IPancakeRouter02(pcsRouter) .swapExactTokensForTokens(cakeBalance, 0, cakeToBaseRoute, address(this), block.timestamp); } (uint256 reserve0, uint256 reserve1,) = IPancakePair(farmingToken).getReserves(); address[] memory route = new address[](2); uint256 lp0Bal = IERC20(lpTokens[0]).balanceOf(address(this)); uint256 lp1Bal = IERC20(lpTokens[1]).balanceOf(address(this)); uint256 toSwap; // The possible cases here are: // - Cake was not part of the LP token, so we swap for baseToken which could either be lpToken0 or lpToken // - Cake was part of the LP token, so it can either be lpTokens[0] or lpTokens[1] // So, depending on which token we have the highest balance for, we swap for the other one. if (lp0Bal > lp1Bal) { toSwap = SwapAmount.getSwapAmount(lp0Bal, reserve0, fee); route[0] = lpTokens[0]; route[1] = lpTokens[1]; } else { toSwap = SwapAmount.getSwapAmount(lp1Bal, reserve1, fee); route[0] = lpTokens[1]; route[1] = lpTokens[0]; 20 } // Perform the swap IPancakeRouter02(pcsRouter) .swapExactTokensForTokens(toSwap, 0, route, address(this), block.timestamp); } IPancakeRouter02(pcsRouter).swapExactTokensForTokens(toWbnb, 0, cakeToWbnbRoute, address(this), block.timestamp); cross-yield/contracts/strategies/StrategyCake.sol#L131 function collectFees() internal { // a percentant of the cake we get from the masterchef will be used to buy BNB and transfer to this address // this is the total fees that will be shared amongst the protocol, stategy dev and the harvester uint256 toWbnb = feeManager.calculateTotalFee(IERC20(farmingToken).balanceOf(address(this))); IPancakeRouter02(pcsRouter).swapExactTokensForTokens(toWbnb, 0, cakeToWbnbRoute, address(this), block.timestamp); uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this)); // distribute hervester fee uint256 harvesterFeeAmount = feeManager.calculateHarvestFee(wbnbBal); // collectFees is called indirectly from the CrossYield contract via the beforeDeposit hook. // This means that _msgSender() is the CrossYield contract and not the actuall EOA account // that send the transaction IERC20(wbnb).safeTransfer(tx.origin, harvesterFeeAmount); // distribute protocol fee uint256 protocolFeeAmount = feeManager.calculateProtocolFee(wbnbBal); // IERC20(wbnb).safeTransfer(protocolFeeRecipient, protocolFeeAmount); feeProcessor.process(protocolFeeAmount); // distribute strategy dev fee uint256 strategyDevFeeAmount = feeManager.calculateStrategyDevFee(wbnbBal); IERC20(wbnb).safeTransfer(feeManager.strategyDev(), strategyDevFeeAmount); emit FeeCollected( toWbnb, 21 harvesterFeeAmount, protocolFeeAmount, strategyDevFeeAmount, _msgSender() ); } cross-yield/contracts/strategies/StrategyCakeLP.sol#L174 function collectFees() internal { // a percentant of the cake we get from the masterchef will be used to buy BNB and transfer to this address // this is the total fees that will be shared amongst the protocol, stategy dev and the harvester uint256 toWbnb = feeManager.calculateTotalFee(IERC20(cake).balanceOf(address(this))); IPancakeRouter02(pcsRouter).swapExactTokensForTokens(toWbnb, 0, cakeToWbnbRoute, address(this), block.timestamp); uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this)); // distribute hervester fee uint256 harvesterFeeAmount = feeManager.calculateHarvestFee(wbnbBal); IERC20(wbnb).safeTransfer(_msgSender(), harvesterFeeAmount); // distribute protocol fee uint256 protocolFeeAmount = feeManager.calculateProtocolFee(wbnbBal); feeProcessor.process(protocolFeeAmount); // distribute strategy dev fee uint256 strategyDevFeeAmount = feeManager.calculateStrategyDevFee(wbnbBal); IERC20(wbnb).safeTransfer(feeManager.strategyDev(), strategyDevFeeAmount); emit FeeCollected( toWbnb, harvesterFeeAmount, protocolFeeAmount, strategyDevFeeAmount, _msgSender() ); } cross-yield/contracts/strategies/StrategyCake.sol 22 function harvest() public override whenNotPaused { // claim rewards IMasterChef(masterchef).leaveStaking(0); // because harvest can automatically be called after each user deposit // we might end up having multiple deposits in the same block and only one // would return rewards from masterchef so the rest will have 0 cake so // we don't need to waste gas to collect fees and call deposit uint256 farmingTokenBalance = balanceOfFarmingToken(); if(farmingTokenBalance > 0) { collectFees(); deposit(); emit HarvestTriggered(_msgSender(), farmingTokenBalance); } } cross-yield/contracts/strategies/StrategyCakeLP.sol#l137-L148 function harvest() external override whenNotPaused { // claim rewards IMasterChef(masterchef).deposit(poolId, 0); uint256 harvestedAmount = IERC20(cake).balanceOf(address(this)); collectFees(); addLiquidity(); deposit(); emit HarvestTriggered(_msgSender(), harvestedAmount); }",
        "labels": [
            "SlowMist",
            "Cross Send V1.0.1",
            "Type: Reordering Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Missing slippage check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Send V1.0.1_en-us.pdf",
        "body": "The addLiquidity function without slippage check, it doesn't have an impermanent loss check. cross-yield/contracts/strategies/StrategyCakeLP.sol#L218 function addLiquidity() internal { OptimalSwap.prepareLiquidity( cake, [lpToken0, lpToken1], wbnb, busd, farmingToken, pcsRouter, swapFee ); // add liquidity to AMM on PCS uint256 lp0Bal = IERC20(lpToken0).balanceOf(address(this)); uint256 lp1Bal = IERC20(lpToken1).balanceOf(address(this)); IPancakeRouter02(pcsRouter) .addLiquidity(lpToken0, lpToken1, lp0Bal, lp1Bal, 0, 0, address(this), block.timestamp); emit LiquidityAdded(lpToken0, lpToken1, lp0Bal, lp1Bal, _msgSender()); }",
        "labels": [
            "SlowMist",
            "Cross Send V1.0.1",
            "Type: Reordering Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Permission check Missing",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Send V1.0.1_en-us.pdf",
        "body": "There is no permission check for deposit function. The function is called by the CrossYieid contract. cross-yield/contracts/strategies/StrategyCakeLP.sol#L225-L231 function deposit() public override whenNotPaused { uint256 farmingTokenBalance = balanceOfFarmingToken(); if (farmingTokenBalance > 0) { IMasterChef(masterchef).deposit(poolId, farmingTokenBalance); } } cross-yield/contracts/strategies/StrategyCake.sol#L169-L175 function deposit() public override whenNotPaused { uint256 farmingTokenBalance = balanceOfFarmingToken(); if (farmingTokenBalance > 0) { IMasterChef(masterchef).enterStaking(farmingTokenBalance); } }",
        "labels": [
            "SlowMist",
            "Cross Send V1.0.1",
            "Type: Authority Control Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Excessive authority issue 25",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Send V1.0.1_en-us.pdf",
        "body": "Owner can modify the address of the strategy. The new strategy may have security risks if it is not audited, which will aect the user's funds. If the private key is leaked, it will aect the user's funds. cross-yield/contracts/core/CrossYield.sol#L224-L236 function upgradeStrategy() public onlyOwner { require(stratCandidate.strategy != address(0), \"No proposal exists\"); require(block.number > stratCandidate.proposedBlock + stratUpgradableAfter, \"Strategy cannot be replaced yet\"); emit NewStrategy(stratCandidate.strategy); strategy.retireStrategy(); strategy = IStrategy(stratCandidate.strategy); stratCandidate.strategy = address(0); stratCandidate.proposedBlock = 0; putFundsToWork(); } cross-yield/contracts/core/CrossYield.sol#L211-L220 function proposeStrategy(address _strategy) public onlyOwner { require(address(this) == IStrategy(_strategy).vault(), \"Invalid new strategy\"); stratCandidate = StrategyCandidate({ strategy: _strategy, proposedBlock: block.number }); emit NewStratCandidate(_strategy); }",
        "labels": [
            "SlowMist",
            "Cross Send V1.0.1",
            "Type: Authority Control Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Repeatable claims issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Send V1.0.1_en-us.pdf",
        "body": "After the claim, lottery.status is not set as claimed, and it is also necessary to check whether lotteryId has been claimed when the claim is executed. hotdrop/contracts/HotDrop.sol#L261-L274 function claim(uint256 lotteryId) external nonReentrant { Lottery storage lottery = lotteries[lotteryId]; require(lottery.status == Status.WinnerDrawn, \"winner not drawn\"); // if there is no winner transfer the total amount to the treasury if(tickets[lotteryId][lottery.winningNumber] == address(0)) { lottery.purchaseToken.safeTransfer(treasury, lottery.purchaseToken.balanceOf(address(this))); } else if(tickets[lotteryId][lottery.winningNumber] == _msgSender()) { // if the ticket is the winning ticket and belongs to the user then split the pot uint256 treasuryAmount = (lottery.totalRaised * lottery.treasuryFee) / FEE_BASE; lottery.purchaseToken.safeTransfer(treasury, treasuryAmount); lottery.purchaseToken.safeTransfer(_msgSender(), lottery.totalRaised - treasuryAmount); } }",
        "labels": [
            "SlowMist",
            "Cross Send V1.0.1",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Round plan security reminder",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Send V1.0.1_en-us.pdf",
        "body": "And the new round of lottery can only be opened when the last round of lottery is in WinnerDrawn, otherwise randomGenerator.latestLotteryId will be updated, which will cause the old lottery round to fail to execute drawWinner function due to this check. require(lotteryId == randomGenerator.latestLotteryId(), \"numbers not drawn\"); hotdrop/contracts/HotDrop.sol#L44-L256 function drawWinner(uint256 lotteryId) external nonReentrant { Lottery storage lottery = lotteries[lotteryId]; require(lottery.status == Status.Close, \"lottery still active\"); require(lotteryId == randomGenerator.latestLotteryId(), \"numbers not drawn\"); // get the winning number based on the randomResult generated by ChainLink's fallback uint256 winningNumber = randomGenerator.randomResult(); lottery.winningNumber = winningNumber; lottery.status = Status.WinnerDrawn; emit LotteryNumberDrawn(lotteryId, winningNumber); }",
        "labels": [
            "SlowMist",
            "Cross Send V1.0.1",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Trustin_en_us.pdf",
        "body": "In the Comptroller, CToken, SimplePriceOracle, and Unitroller contracts, the admin role can modify key sensitive parameters such as the manager roles, the rate model, the market, the pause status, the whitelist, the price of the underlying asset, and the admin role, which will lead to the risk of over-privilege of the admin role. ",
        "labels": [
            "SlowMist",
            "Trustin_en_us",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Decimal loss with an empty marke",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Trustin_en_us.pdf",
        "body": "If there are two markets, one of which was used by the UI, one of which was empty. Someone can mint collateral tokens in an empty market and redeem most minted tokens, then donate redeemed asset tokens to inate the exchange rate through the getAccountSnapshot function. Next, borrow a dierent asset with the manipulated exchange rate, and redeem collateral to recover donation. However, the redeemUnderlying function may wrongly be rounded down on the tokens to remove from a malicious caller, which causes the redemption of many tokens only to require little underlying assets. The last, liquidation borrower contract position with borrowed funds and redeem collateral tokens to reset the empty market. Reference: https://www.comp.xyz/t/hundred-nance-exploit-and-compound-v2/4266 ",
        "labels": [
            "SlowMist",
            "Trustin_en_us",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Receive can lock users native tokens",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Trustin_en_us.pdf",
        "body": "There is a receive function in the CErc20Delegator, Timelock, and Unitroller contracts so that the contracts can receive native tokens. However, the receive function can lock users native tokens when users transfer the native token in these contracts by mistake and there is no token processing logic. ",
        "labels": [
            "SlowMist",
            "Trustin_en_us",
            "Type: Others",
            "Severity: Low"
        ]
    },
    {
        "title": "Missing the event record",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Trustin_en_us.pdf",
        "body": "The admin role can modify the compAddress parameter, but there are no event logs in these functions. ",
        "labels": [
            "SlowMist",
            "Trustin_en_us",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "External call reminder",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Trustin_en_us.pdf",
        "body": "In the Comptroller contract, users can call the claimZnt to claim the comp in markets, but the implementation address is seting by the admin and the import Zenith is not in the audit scope. ",
        "labels": [
            "SlowMist",
            "Trustin_en_us",
            "Type: Unsafe External Call Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing event record",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cell Core_en-us.pdf",
        "body": "The following functions do not log events. contracts/Cell.sol updateStageRecordMaxCount updateStageRecordCostPoint updateStageRecordIncPoint updateStageRecordValid addSigner removeSigner setProxyer contracts/Nucleus.sol setOracleAddress contracts/Oracle.sol addOracleAddress removeOracleAddress setTokenNameAddress setRates setRatePeriod setFixedPrice revokeFixedPrice contracts/Proxy.sol setOracleAddress setCellAddress setMintPrice",
        "labels": [
            "SlowMist",
            "Cell Core",
            "Type: Malicious Event Log Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Safe transfer issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cell Core_en-us.pdf",
        "body": "contracts/Nucleus.sol Use transferFrom in the claim function to transfer the token. If the token in the operation does not meet the eip20 standard, the transaction may fail. contracts/Proxy.sol Use transferFrom in the mint function to transfer the token. If the token in the operation does not meet the eip20 standard, the transaction may fail.",
        "labels": [
            "SlowMist",
            "Cell Core",
            "Type: Others",
            "Severity: Low"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cell Core_en-us.pdf",
        "body": "contracts/Cell.sol The owner has too much authority, and if the owner's private key is leaked, the attacker can control the casting of NFT. contracts/Oracle.sol The owner has too much authority. If the owner's private key is leaked, the attacker can manipulate the price by setting setRates and setFixedPrice . contracts/Proxy.sol The owner's authority is too large. If the owner's private key is leaked, the attacker can withdraw the revenue in the contract. You can also set a malicious Oracle contract through setOracleAddress to control the price. contracts/Nucleus.sol The owner has too much authority. If the owner's private key is leaked, the attacker can set a malicious Oracle contract through setOracleAddress to control the price.",
        "labels": [
            "SlowMist",
            "Cell Core",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Excessive Authority Issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - wault.finance(WEXPolyMaster)_en-us.pdf",
        "body": "The owner can set the value of wexPerBlock arbitrarily, which will affect the profit of wexReward, and there is no limit on the value range of wexPerBlock, and there is a issue of excessive authority. https://polygonscan.com/address/0xC8Bd86E5a132Ac0bf10134e270De06A8Ba317BFe#code function setWexPerBlock(uint256 _wexPerBlock) public onlyOwner { require(_wexPerBlock > 0, \"!wexPerBlock-0\"); wexPerBlock = _wexPerBlock; } Owner can add pool, can set the allocPoint of pool, there is a issue of selfish mining. function add( uint256 _allocPoint, IERC20 _lpToken, bool _withUpdate ) public onlyOwner { if (_withUpdate) { massUpdatePools(); } uint256 lastRewardBlock = block.number > startBlock ? block.number : startBlock; totalAllocPoint = totalAllocPoint.add(_allocPoint); poolInfo.push( 6 PoolInfo({ lpToken: _lpToken, allocPoint: _allocPoint, lastRewardBlock: lastRewardBlock, accWexPerShare: 0 }) ); function set( uint256 _pid, uint256 _allocPoint, bool _withUpdate ) public onlyOwner { if (_withUpdate) { massUpdatePools(); } totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add( _allocPoint ); poolInfo[_pid].allocPoint = _allocPoint; }",
        "labels": [
            "SlowMist",
            "wault.finance(WEXPolyMaster)",
            "Type: Others",
            "Severity: Low"
        ]
    },
    {
        "title": "Event log missing",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - earning.farm_en-us.pdf",
        "body": "12 contracts/core/EFLeverVault.sol Modifying important variables in the contract requires corresponding event records. function initAddresses(address[7] memory addr) public onlyOwner{ aave = addr[0]; balancer = addr[1]; balancer_fee = addr[2]; lido = addr[3]; asteth = addr[4]; curve_pool = addr[5]; weth = addr[6]; } contracts/core/EFCRVVault.sol Modifying important variables in the contract requires corresponding event records. function initAddresses(address[11] memory addr) public onlyOwner{ crv = addr[0]; usdc = addr[1]; eth_usdc_router = addr[2]; weth = addr[3]; cvxcrv = addr[4]; eth_crv_router = addr[5]; crv_cvxcrv_router = addr[6]; eth_usdt_router = addr[7]; usdt = addr[8]; oracle = addr[9]; staker = addr[10]; }",
        "labels": [
            "SlowMist",
            "earning.farm",
            "Type: Malicious Event Log Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - earning.farm_en-us.pdf",
        "body": "contracts/core/EFLeverVault.sol The owner's authority is too large. If the private key is lost, the attacker can use the pause function to transfer the funds in the contract through callWithData ,or directly transfer astheth. function callWithData(address payable to, bytes memory data, uint256 amount)public payable onlyOwner{ (bool status, ) = to.call.value(amount)(data); require(status, \"call failed\"); } function delegateCallWithData(address payable to, bytes memory data)public payable onlyOwner{ (bool status, ) = to.delegatecall(data); require(status, \"call failed\"); }",
        "labels": [
            "SlowMist",
            "earning.farm",
            "Type: Authority Control Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Potential Sandwich Attack Risk",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - earning.farm_en-us.pdf",
        "body": "contracts/core/EFCRVVault.sol 14 it will perform the token swap operation through the swapExactTokensForTokens function. But the incoming minAmountOut is 0 , which will not do slippage checking,There is a risk of being attacked by sandwiches. function depositStable(uint256 _amount) public payable nonReentrant{ require(!is_paused, \"paused\"); require(IERC20(usdc).allowance(msg.sender, address(this)) >= _amount, \"CFVault: not enough allowance\"); IERC20(usdc).safeTransferFrom(msg.sender, address(this), _amount); if (IERC20(usdc).allowance(address(this), eth_usdc_router) != 0){ IERC20(usdc).approve(eth_usdc_router, 0); } IERC20(usdc).approve(eth_usdc_router, _amount); uint256 weth_before = IERC20(weth).balanceOf(address(this)); address[] memory t = new address[](2); t[0] = usdc; t[1] = weth; UniswapV3Interface(eth_usdc_router).swapExactTokensForTokens(_amount, 0, t, address(this)); uint256 weth_amount = IERC20(weth).balanceOf(address(this)).safeSub(weth_before); if (IERC20(weth).allowance(address(this), eth_crv_router) != 0){ IERC20(weth).approve(eth_crv_router, 0); } IERC20(weth).approve(eth_crv_router, weth_amount); uint256 tt_before = IERC20(crv).balanceOf(address(this)); CurveInterface256(eth_crv_router).exchange(0, 1, weth_amount, 0); uint256 tt_amount = IERC20(crv).balanceOf(address(this)).safeSub(tt_before); _deposit(_amount, tt_amount); }",
        "labels": [
            "SlowMist",
            "earning.farm",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Potential Sandwich Attack Risk",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - earning.farm_en-us.pdf",
        "body": "contracts/core/EFCRVVault.sol it will perform the token swap operation through the swapExactTokensForTokens function. But the incoming minAmountOut is 0 , which will not do slippage checking,There is a risk of being attacked by sandwiches. function withdraw(uint256 _amount, bool _use_stable) public nonReentrant{ require(!is_paused, \"paused\"); { uint256 total_balance = IERC20(ef_token).balanceOf(msg.sender); require(total_balance >= _amount, \"not enough LP tokens\"); } uint256 target_amount; { //if (IERC20(ef_token).totalSupply() == 0) require(false, \"000\"); uint256 lp_amount = _amount.safeMul(lp_balance).safeDiv(IERC20(ef_token).totalSupply()); uint256 target_before = IERC20(crv).balanceOf(address(this)); _withdraw(lp_amount); target_amount = IERC20(crv).balanceOf(address(this)).safeSub(target_before); } uint256 f = 0; if(withdraw_fee_ratio != 0 && fee_pool != address(0x0)){ f = target_amount.safeMul(withdraw_fee_ratio).safeDiv(ratio_base); target_amount = target_amount.safeSub(f); IERC20(crv).transfer(fee_pool, f); TokenInterfaceERC20(ef_token).destroyTokens(msg.sender, _amount); }else{ TokenInterfaceERC20(ef_token).destroyTokens(msg.sender, _amount); } if (!_use_stable){ IERC20(crv).transfer(msg.sender, target_amount); emit CFFWithdraw(msg.sender, target_amount, target_amount.safeMul(uint256(ChainlinkInterface(oracle).latestAnswer())).safeDiv(1e2 16 0), _amount, f, getVirtualPrice()); } else{ if (IERC20(crv).allowance(address(this), eth_crv_router) != 0){ IERC20(crv).approve(eth_crv_router, 0); } IERC20(crv).approve(eth_crv_router, target_amount); uint256 weth_amount; { uint256 weth_before = IERC20(weth).balanceOf(address(this)); CurveInterface256(eth_crv_router).exchange(1, 0, target_amount, 0); weth_amount = IERC20(weth).balanceOf(address(this)).safeSub(weth_before); } if (IERC20(weth).allowance(address(this), eth_usdc_router) != 0){ IERC20(weth).approve(eth_usdc_router, 0); } IERC20(weth).approve(eth_usdc_router, weth_amount); uint256 usdc_amount; { address[] memory t = new address[](2); t[0] = weth; t[1] = usdc; uint256 usdc_before = IERC20(usdc).balanceOf(address(this)); UniswapV3Interface(eth_usdc_router).swapExactTokensForTokens(weth_amount, 0, t, address(this)); usdc_amount = IERC20(usdc).balanceOf(address(this)).safeSub(usdc_before); } IERC20(usdc).transfer(msg.sender, usdc_amount); emit CFFWithdraw(msg.sender, target_amount, usdc_amount, _amount, f, getVirtualPrice()); } }",
        "labels": [
            "SlowMist",
            "earning.farm",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Redundant code",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - earning.farm_en-us.pdf",
        "body": "contracts/erc20/ERC20Impl.sol onTransferDone function not being called function onTransferDone(address _from, address _to, uint256 _amount) internal { for(uint i = 0; i < transferListeners.length; i++){ TransferEventCallBack t = TransferEventCallBack(transferListeners[i]); t.onTransfer(_from, _to, _amount); } }",
        "labels": [
            "SlowMist",
            "earning.farm",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Redundant code",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - earning.farm_en-us.pdf",
        "body": "contracts/core/EFLeverVault.sol IERC20(weth).balanceOf(address(this)) return result unused. function raiseActualLTV(uint256 lt) public onlyOwner{//take lt = 7500 uint256 e = getDebt(); uint256 st = getCollecteral(); require(e.safeMul(10000) < st.safeMul(mlr), \"no need to raise\"); uint256 x = st.safeMul(mlr).safeSub(e.safeMul(10000)).safeDiv(uint256(10000).safeSub(mlr));//x = 18 (mST-E)/(1-m) uint256 y = st.safeMul(lt).safeDiv(10000).safeSub(e).safeSub(1); if (x > y) {x = y;} IAAVE(aave).borrow(weth, x, 2, 0, address(this)); IWETH(weth).withdraw(IERC20(weth).balanceOf(address(this))); ILido(lido).submit.value(address(this).balance)(address(this)); IERC20(weth).balanceOf(address(this));//SlowMist//return result unused if (IERC20(lido).allowance(address(this), aave) != 0) {IERC20(lido).safeApprove(aave, 0);} IERC20(lido).safeApprove(aave, IERC20(lido).balanceOf(address(this))); IAAVE(aave).deposit(lido, IERC20(lido).balanceOf(address(this)), address(this), 0); emit ActualLTVChanged(e, st, getDebt(), getCollecteral()); }",
        "labels": [
            "SlowMist",
            "earning.farm",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - earning.farm_en-us.pdf",
        "body": "contracts/core/EFLeverVault.sol If the owner permission is lost, the attacker can achieve free recharge by changing the address of the token, thereby taking away the funds in the contract. function initAddresses(address[7] memory addr) public onlyOwner{ aave = addr[0]; balancer = addr[1]; balancer_fee = addr[2]; lido = addr[3]; 19 asteth = addr[4]; curve_pool = addr[5]; weth = addr[6]; emit CFFNewAddress(addr); } contracts/core/EFCRVVault.sol function initAddresses(address[11] memory addr) public onlyOwner{ crv = addr[0]; usdc = addr[1]; eth_usdc_router = addr[2]; weth = addr[3]; cvxcrv = addr[4]; eth_crv_router = addr[5]; crv_cvxcrv_router = addr[6]; eth_usdt_router = addr[7]; usdt = addr[8]; oracle = addr[9]; staker = addr[10]; emit CFFNewAddress(addr); }",
        "labels": [
            "SlowMist",
            "earning.farm",
            "Type: Authority Control Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - earning.farm_en-us.pdf",
        "body": "contracts/core/EFCRVVault.sol 20 delegateCallWithData is an arbitrary external call, if the private key is lost the attacker can unstake and transfer the funds And for users who have previously authorized the current contract, the attacker can transfer funds that are not operated by the user himself by constructing a malicious contract. function delegateCallWithData(address payable to, bytes memory data)public payable onlyOwner{ (bool status, ) = to.delegatecall(data); require(status, \"call failed\"); }",
        "labels": [
            "SlowMist",
            "earning.farm",
            "Type: Authority Control Vulnerability",
            "Severity: Critical"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Bitlayer Bridge.pdf",
        "body": "1.The BitlayerBridge contracts are implemented using the OpenZeppelin upgradeable model, allowing the AdminRole role to perform contract upgrades. However, this design introduces an excessive privilege risk. 2.In the BitlayerBridge contract, the UnlockRole role can call the unlock function to unlock the ETH locked in the contract; the LiquidityRole role can call the removeLiquidityTo function to remove the liquidity of any address. BitlayerBridge.sol#L125-L134,L148-L163 function removeLiquidityTo(address to, uint256 amount) external onlyRole(LiquidityRole) whenNotPaused { ``` } function unlock(string memory _txHash, address to, uint256 amount) external onlyRole(UnlockRole) whenNotPaused { ``` } } 3.In the BitlayerBridge contract, AdminRole role can set important parameters of the contract. BitlayerBridge.sol function setFeeAddress function setLockFee function setMinLockAmount function setMaxLockAmount",
        "labels": [
            "SlowMist",
            "Bitlayer Bridge",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Missing zero address check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Bitlayer Bridge.pdf",
        "body": "In the BitlayerBridge contract, the zero address check is missing in the initialize function and unlock function. BitlayerBridge.sol#L36-L75,L148-L163 function initialize(  ) public initializer {  feeAddress = _feeAddress;  } function unlock(string memory _txHash, address to, uint256 amount) external onlyRole(UnlockRole) whenNotPaused {  (bool success, bytes memory returndata) = payable(to).call{value: amount} (\"\");  }",
        "labels": [
            "SlowMist",
            "Bitlayer Bridge",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Return value not checked",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Bitlayer Bridge.pdf",
        "body": "In the BitlayerBridge contract, the return value is not checked when the initialize function calls the _grantRole function. BitlayerBridge.sol#L36-L75 function initialize( ``` ) public initializer { _grantRole(AdminRole, admin); ``` }",
        "labels": [
            "SlowMist",
            "Bitlayer Bridge",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Parameter Validation Missing in unlock Function",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Bitlayer Bridge.pdf",
        "body": "In the BitlayerBridge contract, the unlock function does not verify the validity of the parameters passed in. The UnlockRole role can enter any _txHash (not recorded by txUnlocked mapping) and amount to unlock the ETH in the contract and transfer it to the specied address. BitlayerBridge.sol#L148-L163 function unlock(string memory _txHash, address to, uint256 amount) external onlyRole(UnlockRole) whenNotPaused { bytes32 txHash = keccak256(abi.encode(_txHash)); require(!txUnlocked[txHash], \"txHash already unlocked\"); txUnlocked[txHash] = true; (bool success, bytes memory returndata) = payable(to).call{value: amount} (\"\"); require(success, string(returndata)); totalUnlocked += amount; emit NativeUnlocked(_txHash, to, amount); }",
        "labels": [
            "SlowMist",
            "Bitlayer Bridge",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Min lock amount not checked against max",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Bitlayer Bridge.pdf",
        "body": "In the BitlayerBridge contract, whether the variable minLockAmount is less than the variable maxLockAmount is not checked in the initialize function, setMinLockAmount function, and setMaxLockAmount function. If the variable minLockAmount is greater than the variable maxLockAmount , the lock function cannot be used. BitlayerBridge.sol#L41-L85,L113-L118,L120-L125 function initialize( ``` ) public initializer { ``` minLockAmount = _minLockAmount; maxLockAmount = _maxLockAmount; } function setMinLockAmount(uint256 min) external onlyRole(AdminRole) { uint256 oldMin = minLockAmount; minLockAmount = min; emit MinLockAmountSet(oldMin, min); } function setMaxLockAmount(uint256 max) external onlyRole(AdminRole) { uint256 oldMax = maxLockAmount; maxLockAmount = max; emit MaxLockAmountSet(oldMax, max); }",
        "labels": [
            "SlowMist",
            "Bitlayer Bridge",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Reentrancy risks",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DappOS Contracts Core.pdf",
        "body": "In the PayDB contract, the executeDstOrderETH , executeDstOrderETH , tryExecuteDstOrderETH , cancelOrderETH , _executeIsolateOrder , and _createSrcOrder functions do not add anti-reentrancy locks, and there is a risk of reentrancy attacks when calling the safeTransferETH function. contracts/core/PayDB.sol#L75-L153,L162-L249,L287-L335,L337-L383,L385-L475 function executeDstOrderETH( address orderOwner, address receiver, address wallet, ExePayOrderParam[] calldata eparams, IVWManager.VWExecuteParam calldata vwExeParam ) external payable override{ ```` if (eparams[i].tokenOut == address(0)) { TransferHelper.safeTransferETH( _realReceiver, eparams[i].amountOut ); totalETH += eparams[i].amountOut; } else { TransferHelper.safeTransferFrom( eparams[i].tokenOut, msg.sender, _realReceiver, eparams[i].amountOut ); } ```` } function tryExecuteDstOrderETH( address orderOwner, address receiver, address wallet, ExePayOrderParam[] calldata eparams, IVWManager.VWExecuteParam calldata vwExeParam ) external payable override { ```` if (eparams[i].tokenOut == address(0)) { TransferHelper.safeTransferETH( _realReceiver, eparams[i].amountOut ); totalETH += eparams[i].amountOut; } else { TransferHelper.safeTransferFrom( eparams[i].tokenOut, msg.sender, _realReceiver, eparams[i].amountOut ); } ```` } function cancelOrderETH( address sender, address receiver, CreatePayOrderParam[] calldata cparams, bytes32[] calldata workFlowHashs ) external payable override { ```` require(msg.value == totalETH,\"E18\"); if(totalETH > 0){ TransferHelper.safeTransferETH(sender, msg.value); } ```` } function _executeIsolateOrder( address receiver, address wallet, ExePayOrderParam[] calldata eparams, IVWManager.VWExecuteParam calldata vwExeParam ) internal { ```` if (eparams[i].tokenOut == address(0)) { TransferHelper.safeTransferETH( receiver, eparams[i].amountOut ); totalETH += eparams[i].amountOut; } else { TransferHelper.safeTransferFrom( eparams[i].tokenOut, msg.sender, receiver, eparams[i].amountOut ); } ```` } function _createSrcOrder( address _orderOwner, address wallet, address receiver, CreatePayOrderParam[] calldata cparams, VwOrderDetail calldata vwDetail, CallParam calldata callParam ) internal { ```` if (cparams[i].tokenIn == address(0)) { // Transfer ETH to node TransferHelper.safeTransferETH( cparams[i].node, cparams[i].amountIn ); totalEth += cparams[i].amountIn; } else { // Transfer ERC20 to node TransferHelper.safeTransferFrom( cparams[i].tokenIn, msg.sender, cparams[i].node, cparams[i].amountIn ); } ```` }",
        "labels": [
            "SlowMist",
            "DappOS Contracts Core",
            "Type: Reentrancy Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Unauthorized information status modication",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DappOS Contracts Core.pdf",
        "body": "In the storeInfo function of the VWManager contract, we found the following issues 1. Any user can set the willDelete parameter of information stored by other users to false, thereby deleting infoSender[infoHash] so that it cannot be deleted. 2. Key Parameter Settings Unrecorded Events. 3. The function may be subject to MEV attacks, causing the user to store infoSender[infoHash] = msg.sender as the attacker's address when storing information. contracts/core/vwmanager/VWManager.sol#L295-L311 function storeInfo( bytes calldata info, bool willDelete ) external { if(info.length > 0){ bytes32 infoHash = keccak256(info); if(eip1271Info[infoHash].length == 0){ eip1271Info[infoHash] = info; emit InfoStored(infoHash, info); if(willDelete){ infoSender[infoHash] = msg.sender; } } else if(!willDelete) { delete infoSender[infoHash]; } } }",
        "labels": [
            "SlowMist",
            "DappOS Contracts Core",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Unveried feeReceiver parameter",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DappOS Contracts Core.pdf",
        "body": "The cancelTx , changeOwner , approveResetter , and resetOwner functions of the VWManagerService contract, the feeReceiver parameter is not veried. It may be subject to MEV attack risk. The attacker replaces the feeReceiver parameters, causing losses. contracts/core/vwmanager/VWManagerService.sol#L53-L92,L123-L161,L177-L217,L227-L256 function cancelTx( uint256 code, address wallet, uint256 codeToCancel, FeeParam calldata fParam, bytes calldata signature ) external {  bytes32 dataHash = keccak256( abi.encode( CANCEL_TYPEHASH, code, codeToCancel, fParam.gasToken, fParam.gasTokenPrice, fParam.priorityFee, fParam.gasLimit ) ); result[walletOwner[wallet]][codeToCancel] = uint256(CodeStatus.CANCELED); result[walletOwner[wallet]][code] = uint256(CodeStatus.SUCCEED); emit TxCanceled(codeToCancel); verifyOperation( walletOwner[wallet], domainSeparator[srcChain], dataHash, signature, CANCEL_TYPEHASH ); _walletPayFee(wallet, preGas, fParam); } function changeOwner( uint256 code, address wallet, address newOwner, FeeParam calldata fParam, bytes calldata signature ) external {  bytes32 dataHash = keccak256( abi.encode( CHANGE_OWNER_TX_TYPEHASH, code, newOwner, fParam.gasToken, fParam.gasTokenPrice, fParam.priorityFee, fParam.gasLimit ) ); address previousOwner = _resetOwner(wallet, newOwner); result[walletOwner[wallet]][code] = uint256(CodeStatus.SUCCEED); verifyOperation( previousOwner, domainSeparator[srcChain], dataHash, signature, CHANGE_OWNER_TX_TYPEHASH ); _walletPayFee(wallet, preGas, fParam); } function approveResetter( uint256 code, address wallet, address resetter, bool approved, FeeParam calldata fParam, bytes calldata signature ) external returns (bytes32 dataHash) {  dataHash = keccak256( abi.encode( RESETTER_APPROVE_TYPEHASH, code, resetter, approved, fParam.gasToken, fParam.gasTokenPrice, fParam.priorityFee, fParam.gasLimit ) ); approvedResetter[wallet] = approved ? resetter : address(0); emit ResetterChanged(approvedResetter[wallet]); result[walletOwner[wallet]][code] = uint256(CodeStatus.SUCCEED); verifyOperation( walletOwner[wallet], domainSeparator[srcChain], dataHash, signature, RESETTER_APPROVE_TYPEHASH ); _walletPayFee(wallet, preGas, fParam); } function resetOwner( uint256 code, address wallet, address newOwner, FeeParam calldata fParam, bytes calldata data ) external nonReentrant{  require ( IVWResetter(approvedResetter[wallet]).verify( wallet, newOwner, data, fParam.gasToken, fParam.gasTokenPrice, fParam.priorityFee, fParam.gasLimit ), \"E5\"); _resetOwner(wallet, newOwner); result[walletOwner[wallet]][code] = uint256(CodeStatus.SUCCEED); _walletPayFee(wallet, preGas, fParam); }",
        "labels": [
            "SlowMist",
            "DappOS Contracts Core",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Reentrancy risks",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DappOS Contracts Core.pdf",
        "body": "In the PayLock contract, the deposit function does not add an anti-reentrancy lock, and there is a risk of reentrancy attacks when calling the safeTransferFrom function. contracts/core/PayLock.sol#L73-L78 function deposit(address token, uint amount, address node) external { uint256 beforeTransfer = IERC20(token).balanceOf(address(this)); TransferHelper.safeTransferFrom(token, msg.sender, address(this), amount); uint256 afterTransfer = IERC20(token).balanceOf(address(this)); _deposit(token, afterTransfer - beforeTransfer, node); }",
        "labels": [
            "SlowMist",
            "DappOS Contracts Core",
            "Type: Reentrancy Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DappOS Contracts Core.pdf",
        "body": "Owner accounts can operate the key functions. PayLock punish PayLock configToken PayLock configWithdrawPendingTime VWManager configFee VWManager VWManager requestConfigSrcChain configSrcChain",
        "labels": [
            "SlowMist",
            "DappOS Contracts Core",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Unveried manager and feeReceiver parameter",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DappOS Contracts Core.pdf",
        "body": "In the verifyProof function of the VWManager contract, only the 8 parameters in vweParam were veried, and the manager and feeReceiver parameters were not veried. contracts/core/vwmanager/VWManager.sol#L113-L145 function verifyProof(uint resCode, address wallet, VWExecuteParam calldata vweParam) internal { address vwOwner = walletOwner[wallet]; result[vwOwner][vweParam.code] = resCode; (uint256 dstChainId, uint256 srcChain, uint256 expTime) = VWCode.chainidsAndExpTime(vweParam.code); require(dstChainId == block.chainid, 'E3'); require(block.timestamp <= expTime, 'E6'); require(domainSeparator[srcChain] != bytes32(0), 'E31'); bytes32 rootHash = keccak256( abi.encode( APPROVE_SERVICE_TX_TYPEHASH, vweParam.code, keccak256(vweParam.data), vweParam.service, vweParam.gasToken, vweParam.gasTokenPrice, vweParam.priorityFee, vweParam.gasLimit, vweParam.isGateway ) ); if (vweParam.proof.length > 0) { rootHash = MerkleProof.processProof(vweParam.proof, rootHash); rootHash = keccak256(abi.encode(APPROVE_SERVICE_PROOF_TX_TYPEHASH, rootHash)); } // srcChain is the chain where user sign the rootHash if (Address.isContract(vwOwner)) { require(IWalletOwner(vwOwner).verifyVWParam(rootHash, domainSeparator[srcChain], vweParam), 'E1'); } else { SignLibrary.verify(vwOwner, domainSeparator[srcChain], rootHash, vweParam.serviceSignature); } emit TxExecuted(wallet, vwOwner, vweParam.code, rootHash, resCode); }",
        "labels": [
            "SlowMist",
            "DappOS Contracts Core",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Redundant code",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DappOS Contracts Core.pdf",
        "body": "The functions implemented in library OrderId are the same as those in library VWCode. contracts/libraries/OrderId.sol#L7-L17 function genCode( uint128 nonce, uint32 time, uint32 srcChainId, uint32 dstChainId, uint16 oType, uint16 flag ) internal pure returns (uint code){ code = (uint(nonce) << 128) + (uint(time) << 96) + (uint(srcChainId) << 64) + (uint(dstChainId) << 32) + (uint(oType) << 16) + uint(flag); } function chainidsAndExpTime(uint code) internal pure returns (uint dstChainId, uint srcChainId, uint time){ dstChainId = (code >> 32) & ((1 << 32) - 1); srcChainId = (code >> 64) & ((1 << 32) - 1); time = (code >> 96) & ((1 << 32) - 1); }",
        "labels": [
            "SlowMist",
            "DappOS Contracts Core",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Reentrancy risks",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DappOS Contracts Core.pdf",
        "body": "In the PayLock contract punish function, the punishes mapping is not used correctly, resulting in the risk of reentrancy. contracts/governance/PayLock.sol#L131-L159 function punish( uint orderId, address node, address to, address[] calldata tokens, uint[] calldata amounts ) external onlyOwner { require(tokens.length > 0 && tokens.length == amounts.length, \"Invalid length\"); for (uint i = 0; i < tokens.length; i++) { require(validTokens[tokens[i]], \"INVALID_TOKEN\"); TokenBalance storage bal = nodeTokenBalance[node][tokens[i]]; uint256 realAmount = amounts[i]; if (amounts[i] > bal.numOnWithdraw) { if (bal.numTotal <= amounts[i].sub(uint(bal.numOnWithdraw))) { realAmount = uint(bal.numTotal + bal.numOnWithdraw); (bal.numTotal, bal.numOnWithdraw) = (0, 0); } else { bal.numTotal -= (amounts[i] - uint(bal.numOnWithdraw)).toUint128(); bal.numOnWithdraw = 0; } } else { bal.numOnWithdraw = (uint(bal.numOnWithdraw).sub(amounts[i])).toUint128(); } TransferHelper.safeTransfer2(tokens[i], to, realAmount); } punishes[node]++; emit NodePunished(orderId, amounts, tokens, node, to); }",
        "labels": [
            "SlowMist",
            "DappOS Contracts Core",
            "Type: Reentrancy Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Insucient WithdrawPendingTime error",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DappOS Contracts Core.pdf",
        "body": "In the PayLock contract congWithdrawPendingTime function, the withdrawPendingTime parameter should be set to greater than or equal to 7 days. Since congWithdrawPendingTime is associated with the order's term, congWithdrawPendingTime should be greater than the order's term. contracts/governance/PayLock.sol#L168-L172 function configWithdrawPendingTime(uint period) external onlyOwner { require(period <= 7 days, \"E27\"); withdrawPendingTime = period; emit WithdrawPendingTime(period); }",
        "labels": [
            "SlowMist",
            "DappOS Contracts Core",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Unveried Node Mortgage Requirement",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DappOS Contracts Core.pdf",
        "body": "In the PayDB contract, when the user creates an order through the createSrcOrder function or createSrcOrderETH function, it is not veried whether the node's mortgage assets meet the mortgage requirements required for the created order.",
        "labels": [
            "SlowMist",
            "DappOS Contracts Core",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Service nodes are at risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DappOS Contracts Core.pdf",
        "body": "In the PayDB contract, when the user creates an order through the createSrcOrder function or createSrcOrderETH function, he transfer assets to the cparams[i].node , and these nodes are at risk of rug-pull ,or private key leak.",
        "labels": [
            "SlowMist",
            "DappOS Contracts Core",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Redundant collectEndTime check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase3_en-us.pdf",
        "body": "In the CongurableRightsPool contract, users can redeem underlying assets through the exitPool function. When the pool is a closed ETF, it will check isCompletedCollect and collectEndTime to decide whether to perform _claimManagerFee operation. But when isCompletedCollect is true, the collectEndTime check will be performed in snapshotEndAssets, and when isCompletedCollect is false, the collectEndTime check will be performed in exitPoolHandleB. Hence the collectEndTime check before the _claimManagerFee operation is redundant. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase3",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Redundant closureEndTime check on exitPool",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase3_en-us.pdf",
        "body": "In the CongurableRightsPool contract, users can redeem underlying assets through the exitPool function. When the pool is a closed ETF and isCloseEtfCollectEndWithFailure is false, it will check that the current time must be greater than closureEndTime + 5 minutes before allowing the user to exit. However, it should be noted that the snapshotEndAssets operation will be performed before this. The snapshotEndAssets function will also check whether the current time is greater than closureEndTime + 5 minutes . Only the admin and owner can execute snapshotEndAssets within 5 minutes after the closure period ends. Otherwise, the transaction will be reverted. Therefore, the closureEndTime check in the exitPool function is redundant. When snapshotEndAssets cannot be performed, the entire transaction will be reverted, and subsequent closureEndTime checks will not be performed. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase3",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Redundant performance fee calculation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase3_en-us.pdf",
        "body": "In the exitPool function of the CongurableRightsPool contract, redeemAndPerformanceFeeReceived, nalAmountOut and redeemFeeReceived are calculated through exitPoolHandleA. However, since the performance fee will be calculated uniformly in the snapshotEndAssets operation, there is no need to process the performance fee in the exitPool function. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase3",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "The time allowed for snapshots is too short",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase3_en-us.pdf",
        "body": "In the CongurableRightsPool contract when the closed ETF completes collect and the collection period has ended, the current total value of the ETF can be recorded through the snapshotBeginAssets function. However, users can only call the snapshotBeginAssets function within 15 minutes after the end of the collection period. If there is congestion on the chain, it may not be possible to call the snapshot in time within 15 minutes. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase3",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Duplicate decimal processing issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase3_en-us.pdf",
        "body": "In the DesynChainlinkOracle contract, the getPrice function is used to obtain the corresponding token price from prices, getChainlinkPrice, and getUniswapPrice, and perform decimal processing. However, decimal has been processed in getChainlinkPrice and getUniswapPrice, and theoretically, the returned decimal will be 1e18. Therefore, processing decimals through decimalDelta will cause decimals to be enlarged. Note that the amountIn passed in for the consult in the getUniswapPrice function is 1e18, which needs to be ensured that the token decimal in twapOracle matches it in practice ",
        "labels": [
            "SlowMist",
            "DeSyn Phase3",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Decimal processing issue in AllPrice calculation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase3_en-us.pdf",
        "body": "In the DesynChainlinkOracle contract, the getAllPrice function is used to calculate the total value of the specied amount of tokens. It is calculated by badd(fundAll, bmul(getPrice(t), tokenAmountOut)) , theoretically the decimal returned by getPrice is 1e18, and the decimal of tokenAmountOut is consistent with the decimal of the token itself. Therefore, multiplying these two values will result in a very large decimal in the nal result. The getNormalizedWeight function is also aected by this, but this is not harmful to normal business. Note: ",
        "labels": [
            "SlowMist",
            "DeSyn Phase3",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Redundant code issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase3_en-us.pdf",
        "body": "In the SmartPoolManager library, the exitPoolHandle function has been deprecated since closed ETF prots are calculated in snapshotEndAssets. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase3",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Token list conict in recordTokenInfo",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase3_en-us.pdf",
        "body": "When the user performs createPool and joinPool, if the Pool is a closed ETF and the current time is within the collection period, the KOL invitation amount will be recorded through UserVault's recordTokenInfo interface. But unfortunately, the tokens in the Pool can be Bind/unBind at any time, which will cause the list of tokens supported by the Pool to change. If the recordTokenInfo operation is performed when the Pool token list changes, the amount recorded by variables such as poolInviteTotal, kolTotalAmountList, and kolUserInfo may be disturbed. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase3",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "couldManagerClaim not checked when managerClaim",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase3_en-us.pdf",
        "body": "In the UserVault contract, the Manager role can claim management fees through the managerClaim function, but it does not check whether the couldManagerClaim parameter is true. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase3",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Some redundant invoke functions",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase3_en-us.pdf",
        "body": "In the Invoke library, the strictInvokeTransfer, invokeUnwrapWETH, invokeWrapWETH, and invokeMint functions are not used. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase3",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of ETF falsication",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase3_en-us.pdf",
        "body": "In the RebalanceAdapter contract, the Manager role can adjust the position of the pool through the rebalance function. But the address of the ETF is obtained from the rebalanceInfo passed in by the user. If a malicious user passes in a fake ETF, the check in the onlyManager decorator will be bypassed, and the _verifyWhiteToken check of token1 and the isCompletedCollect and collectEndTime checks will be useless. Malicious users can steal bPool funds through _makeSwap and bind malicious tokens. The approve function also has this risk, but it doesn't break the protocol too much ",
        "labels": [
            "SlowMist",
            "DeSyn Phase3",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Risk of the Manager role potentially disrupting the protocol",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase3_en-us.pdf",
        "body": "In the RebalanceAdapter contract, the Manager role can adjust the position of the ETF through the rebalance function. It will use the _makeSwap function to call Uniswap, 1inch and other DEXs for token swaps to adjust token positions. But unfortunately, the swap path of the token is not checked during the token swap process, which will cause the Manager role to pass in a carefully constructed malicious swap path to steal the middle token0 of the ETF. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase3",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Double slippage check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase3_en-us.pdf",
        "body": "In the RebalanceAdapter contract, the Manager role can adjust the position of the ETF through the rebalance function. It will use the _makeSwap function to call Uniswap, 1inch and other DEXs for token swaps to adjust token positions. During the swap process, the slippage will be checked by passing minReturn to the external DEXs, but the implementation of the slippage check of the external DEXs is uncontrollable. If the slippage protection of the external DEXs fails, it will aect the funds of users in the protocol. (1inch users encountered invalid slippage check before) ",
        "labels": [
            "SlowMist",
            "DeSyn Phase3",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Does not follow the Checks-Eects-Interactions specication",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase3_en-us.pdf",
        "body": "In the RebalanceAdapter contract, the _makeSwap function is used for token swap. When the swap type is not UNISWAPV3 and UNISWAPV2, the parameters passed in by the user will be checked through _validateData . However, the execute operation is performed rst, and the _validateData operation is performed after the token exchange is completed. This is not in line with the follow the Checks-Effects-Interactions principle. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase3",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Perform strict parameter checking",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase3_en-us.pdf",
        "body": "In the RebalanceAdapter contract, the _validateData function is used to check the exchange parameters, but it only parses the recipient and amountIn for checking, but does not check whether other key parameters such as srcToken, dstToken, clipperExchange, makerAsset, takerAsset are in line with expectations. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase3",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Redundant aggregator parameter",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase3_en-us.pdf",
        "body": "In the RebalanceAdapter contract, the _validateData function is used to check the conversion parameters, but the aggregator parameter it receives is not used. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase3",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Incorrect approval operation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase3_en-us.pdf",
        "body": "In the RebalanceAdapter contract, the Manager role can adjust the position of the ETF through the rebalance function. If token1 has not been bound in bPool, it will be approved rst. However, the subsidy of this contract was wrongly approved to bPool, which will cause bPool to be unable to transfer tokens from CRP in the future. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase3",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase3_en-us.pdf",
        "body": "There is an execute function in the CRP and bPool contracts so that the Manager can manage the ETF. In bFactory, the Blabs role can arbitrarily register modules to gain control over CRP. The registered modules can use the execute function in CRP to call the execute function in bPool to perform any operations. This would pose a huge risk to users' funds. And the Manager can approve the tokens in the bPool through the approve function of the RebalanceAdapter contract, which will also bring huge risks to the user's funds. The above problems lead to the risk of excessive permissions of the Blabs role and the Manager role. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase3",
            "Type: Authority Control Vulnerability Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Enforce strict permission controls",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase3_en-us.pdf",
        "body": "In the LiquidityPool contract, any user can call the joinPool, exitPool, and gulp functions to add/remove liquidity/record token balances, which will make it impossible to charge various fees to users in CRP. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase3",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Function visibility issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Alpaca Finance Oracle_en-us.pdf",
        "body": "In the OracleMedianizer contract, the user can get the price of the pair token through the getPrice function. The getPrice function will call the _getPrice function to get the price, but the visibility of the _getPrice function is public. ",
        "labels": [
            "SlowMist",
            "Alpaca Finance Oracle",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "The Token Pair Check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Alpaca Finance Oracle_en-us.pdf",
        "body": "There is a _setPriceFeed function in the ChainLinkPriceOracle contract, which is used to set the source of the token pair. In the function, check whether priceFeeds[token1][token0] already exists, but then set the source for priceFeeds[token0][token1] . ",
        "labels": [
            "SlowMist",
            "Alpaca Finance Oracle",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Redundant parameter issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ENF_WBTC_Borrow_ETH_en-us.pdf",
        "body": "In the PriceOracle contract, the getAssetPrice function is used to obtain the relative price of WBTC and ETH. But the _asset parameter it receives is not used. ",
        "labels": [
            "SlowMist",
            "ENF_WBTC_Borrow_ETH",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Token swap defect when withdrawing",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ENF_WBTC_Borrow_ETH_en-us.pdf",
        "body": "In the WBTCBorrowETH contract, the withdraw function is used to withdraw WBTC tokens. When the repayable amount of the contract is less than the required loan amount (ethWithdrawn < ethDebt), the contract will withdraw wbtcToSwap amount of WBTC from AAVE to swap it into WETH, and use the wbtcAmt value as the amountInMaximum in the Swap exchange. However, since the wbtcAmt value is indirectly calculated through the ChainLink price, there may be a deviation from the price in Uniswap v3, so using the wbtcAmt value as the amountInMaximum parameter may not be successfully swapped due to the price deviation. ",
        "labels": [
            "SlowMist",
            "ENF_WBTC_Borrow_ETH",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Swap balance has not been processed",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ENF_WBTC_Borrow_ETH_en-us.pdf",
        "body": "In the _withdraw function of the WBTCBorrowETH contract, when ethWithdrawn < ethDebt , the contract will withdraw WBTC tokens from AAVE and swap them into ETH to repay the loan. If the amount of ETH is greater than the amount of debt required to be repaid (ethBal > ethDebt), the contract will swap the excess part into WBTC, but these excess WBTC tokens have not been sent to the user, nor have they been re-staked into AAVE. It was left in the SS contract. When the next user deposit, it will be billed as part of the user's deposit. And when ethWithdrawn >= ethDebt , the contract will convert the excess ETH to WBTC, but the contract has not yet processed these WBTC. ",
        "labels": [
            "SlowMist",
            "ENF_WBTC_Borrow_ETH",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Defects in LTV operation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ENF_WBTC_Borrow_ETH_en-us.pdf",
        "body": "In the reduceLTV operation, the contract will rst extract x amount of WBTC from AAVE and exchange it into WETH 12 for repayment. In this operation, although the liabilities of the contract are reduced, the amount of collateral of the contract is also reduced. At the same time, due to the impact of the slippage of the swap operation, the reduceLTV operation may not be able to eectively control the risk as expected. ",
        "labels": [
            "SlowMist",
            "ENF_WBTC_Borrow_ETH",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Reduced availability for LTV operations 13",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ENF_WBTC_Borrow_ETH_en-us.pdf",
        "body": "In the protocol, the raiseLTV and reduceLTV functions are important means to improve capital utilization and prevent bad debts, but in these two functions, the token exchange is performed through the _swapExactInput function. The _swapExactInput function does not check for slippage, which will reduce the availability of raiseLTV and reduceLTV for the protocol. ",
        "labels": [
            "SlowMist",
            "ENF_WBTC_Borrow_ETH",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "The withdraw function will not work when the market is extreme",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ENF_WBTC_Borrow_ETH_en-us.pdf",
        "body": "In the protocol, when extreme market conditions occur (such as a sharp unilateral drop of BTC) and the owner has no time to adjust the protocol LTV through the reduceLTV function, the protocols WBTC position will be liquidated. If 14 the protocol's liabilities are fully liquidated (getDebt will become 0), ethDebt will be 0. This will cause the _withdraw function to fail to perform the repay operation, and the emergencyWithdraw operation will also not work. Users' funds will be locked in the protocol. In the repay operation of AAVE, if the repayment amount is 0, it will fail the validateRepay check.",
        "labels": [
            "SlowMist",
            "ENF_WBTC_Borrow_ETH",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Risk of multiple leverages in unilateral market conditions",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ENF_WBTC_Borrow_ETH_en-us.pdf",
        "body": "The protocol deposits WBTC tokens deposited by users into AAVE and lends ETH, and then deposits the loaned ETH into the ENF_ETH_Leverage protocol. The ENF_ETH_Leverage protocol also creates positions in AAVE via ETH/stETH. This makes the ENF_WBTC_Borrow_ETH protocol have multiple leverages, which means it is extremely sensitive to market stability. Once the agreement does not manage LTV properly, it will lead to risks such as bad debts of the agreement. ",
        "labels": [
            "SlowMist",
            "ENF_WBTC_Borrow_ETH",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of excessive authority 16",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ENF_WBTC_Borrow_ETH_en-us.pdf",
        "body": "In the protocol, the owner role has many permissions, such as the owner can set sensitive parameters, can suspend the contract, can make emergency withdrawals, etc. It is obviously inappropriate to give all the permissions of the protocol to the owner, which will greatly increase the single point of risk.",
        "labels": [
            "SlowMist",
            "ENF_WBTC_Borrow_ETH",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Swap Path Issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Oddz Finance_en-us.pdf",
        "body": "In the PancakeSwapForUnderlyingAsset contract, the owner can swap fromToken to toToken through the 11 swapTokensForUA function. The path set is [fromToken, toToken] . If fromToken and toToken in PancakeSwap do not have a directly related token pair, then using this path will not be able to successfully swap. contracts/Integrations/Dex/PancakeSwap/PancakeSwapForUnderlyingAsset.sol#L29-L44 function swapTokensForUA( address _fromToken, address _toToken, address _account, uint256 _amountIn, uint256 _amountOutMin, uint256 _deadline ) public override onlyOwner returns (uint256[] memory result) { address[] memory path = new address[](2); path[0] = _fromToken; path[1] = _toToken; ERC20(_fromToken).safeApprove(address(pancakeSwap), _amountIn); result = pancakeSwap.swapExactTokensForTokens(_amountIn, _amountOutMin, path, address(this), _deadline); // converting address to address payable ERC20(address(uint160(_toToken))).safeTransfer(_account, result[1]); }",
        "labels": [
            "SlowMist",
            "Oddz Finance",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Missing event records",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Oddz Finance_en-us.pdf",
        "body": "12 In the ChainlinkIVOracle contract, the owner can set allowedPeriods, minVolatilityBound, maxVolatilityBound and other parameters at will, but no event recording is performed. contracts/Integrations/VolatilityOracle/Chainlink/ChainlinkIVOracle.sol function addAllowedPeriods(uint8 _ivAgg) public onlyOwner(msg.sender) { allowedPeriods[_ivAgg] = true; } function setMinVolatilityBound(uint256 _minVolatility) public onlyOwner(msg.sender) { minVolatilityBound = _minVolatility; } function setMaxVolatilityBound(uint256 _maxVolatility) public onlyOwner(msg.sender) { maxVolatilityBound = _maxVolatility; } function setDelay(uint256 _delay) public onlyOwner(msg.sender) { delayInSeconds = _delay; } function setVolatilityPrecision(uint8 _precision) public onlyOwner(msg.sender) { volatilityPrecision = _precision; }",
        "labels": [
            "SlowMist",
            "Oddz Finance",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "The deationary token docking issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Oddz Finance_en-us.pdf",
        "body": "13 Users can transfer the staking token into the staking contract through the deposit function. Under normal circumstances, the number of staking tokens transferred by the user is the same as the _amount parameter passed in. But if the staking token is a deationary token, the number of tokens transferred by the user may be dierent from the number of tokens actually received in the contract. contracts/Staking/OddzStakingManager.sol, OddzTokenStaking.sol, OUsdTokenStaking function stake(IERC20 _token, uint256 _amount) external override validToken(_token) { require(_amount > 0, \"Staking: invalid amount\"); tokens[_token]._stakingContract.stake(msg.sender, _amount); emit Stake(msg.sender, address(_token), _amount); } function stake(address _staker, uint256 _amount) external override onlyOwner { _stake(_staker, _amount); _mint(_staker, _amount); IERC20(token).safeTransferFrom(_staker, address(this), _amount); }",
        "labels": [
            "SlowMist",
            "Oddz Finance",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Token active status change issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Oddz Finance_en-us.pdf",
        "body": "In the OddzStakingManager contract, the owner can set the active state of the token to true through the activateToken function, and the timelock contract can set the active state to false through the deactivateToken 14 function. But after the state change, the txnFeeReward, settlementFeeReward, and allotedReward parameters of each valid token did not change accordingly, so the totalTxnFee, totalSettlementFee, and totalAllotedFee parameters are not equal to 100. contracts/Staking/OddzStakingManager.sol function deactivateToken(IERC20 _token) external onlyTimeLocker(msg.sender) validToken(_token) { tokens[_token]._active = false; emit TokenDeactivate(address(_token)); } function activateToken(IERC20 _token) external onlyOwner(msg.sender) inactiveToken(_token) { tokens[_token]._active = true; emit TokenActivate(address(_token)); }",
        "labels": [
            "SlowMist",
            "Oddz Finance",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Redundant code",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Oddz Finance_en-us.pdf",
        "body": "There is _transferRewards function in the OddzStakingManager contract, which checks whether the staker's collateral time is greater than rewardsLockupDuration, while the actual _transferRewards function is only called by the withdraw function and the claimRewards function. But in both withdraw and claimRewards functions, there is a check to see if the staker's collateral time is greater than 15 rewardsLockupDuration. So the _transferRewards function does not need to check again if the staker's collateral time is greater than the rewardsLockupDuration. contracts/Staking/OddzStakingManager.sol function _transferRewards( address _staker, IERC20 _token, uint256 _date ) private returns (uint256 reward) { if (_date - tokens[_token]._stakingContract.getLastStakedAt(_staker) >= tokens[_token]._rewardsLockupDuration) { reward = tokens[_token]._stakingContract.withdrawRewards(_staker); oddzToken.safeTransfer(_staker, reward); emit TransferReward(_staker, address(_token), reward); } }",
        "labels": [
            "SlowMist",
            "Oddz Finance",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Unsafe External Call",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Oddz Finance_en-us.pdf",
        "body": "_pool is entered by the user. When the user enters a malicious contract address and returns the malicious premium through the malicious contract, the tokens in the OddzLiquidityPoolManager contract can be transferred to a malicious address. 16 contracts/Pool/OddzLiquidityPoolManager.sol#L300 function withdrawProfits(IOddzLiquidityPool _pool) external { uint256 premium = _pool.collectPremium(msg.sender, premiumLockupDuration); require(premium > 0, \"LP Error: No premium allocated\"); token.safeTransfer(msg.sender, premium); } The getSortedEligiblePools function does not check the input _liquidityParams and does not ensure that allPools is in the whitelist. When other functions depend on the data of getSortedEligiblePools, the same issues may occur. contracts/Pool/OddzLiquidityPoolManager.sol#L341 function getSortedEligiblePools(LiquidityParams memory _liquidityParams) public view returns (address[] memory pools, uint256[] memory poolBalance) { // if _expiration is 86401 i.e. 1 day 1 second, then max 1 day expiration pool will not be eligible IOddzLiquidityPool[] memory allPools = poolMapper[ keccak256( abi.encode( _liquidityParams._pair, _liquidityParams._type, _liquidityParams._model, periodMapper[getActiveDayTimestamp(_liquidityParams._expiration) / 1 days] ) ) ]; uint256 count = 0; for (uint8 i = 0; i < allPools.length; i++) { if (allPools[i].availableBalance() > 0) { count++; } } poolBalance = new uint256[](count); pools = new address[](count); uint256 j = 0; 17 uint256 balance = 0; for (uint256 i = 0; i < allPools.length; i++) { if (allPools[i].availableBalance() > 0) { pools[j] = address(allPools[i]); poolBalance[j] = allPools[i].availableBalance(); balance += poolBalance[j]; j++; } } (poolBalance, pools) = _sort(poolBalance, pools); require(balance > _liquidityParams._amount, \"LP Error: Amount is too large\"); }",
        "labels": [
            "SlowMist",
            "Oddz Finance",
            "Type: Unsafe External Call Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Race conditions issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Oddz Finance_en-us.pdf",
        "body": "The enableOptionTransfer function can be called repeatedly, When the attacker calls enableOptionTransfer to set a small value of _minAmount.The user does not need to enter minAmount to check when calling the optionTransfer function.Therefore, the attacker can call enableOptionTransfer again with a higher gas price to set a new minAmount, so that if the allowance is greater than the minAmount + transferFee , the user can normally execute optionTransfer calls and trade with a larger amount, and the attacker can prot. contracts/Option/OddzOptionManager.sol function enableOptionTransfer(uint256 _optionId, uint256 _minAmount) external { Option storage option = options[_optionId]; require( option.expiration > (block.timestamp + 18 assetManager.getMinPeriod(option.pair)), \"Option not eligble for transfer\" ); require(option.holder == msg.sender, \"Invalid Caller\"); require(option.state == State.Active, \"Invalid state\"); require(_minAmount >= minimumPremium, \"amount is lower than minimum premium\"); optionTransferMap[_optionId] = _minAmount; emit OptionTransferEnabled(_optionId, _minAmount); } function optionTransfer(uint256 _optionId) external { Option storage option = options[_optionId]; require( option.expiration > (block.timestamp + assetManager.getMinPeriod(option.pair)), \"Option not eligble for transfer\" ); uint256 minAmount = optionTransferMap[_optionId]; require(minAmount > 0, \"Option not enabled for transfer\"); require(option.state == State.Active, \"Invalid state\"); require(option.holder != msg.sender, \"Self option transfer is not allowed\"); // once transfer initiated update option tranfer map delete optionTransferMap[_optionId]; uint256 transferFee = _getTransactionFee(minAmount, msg.sender); txnFeeAggregate += transferFee; _validateOptionAmount(token.allowance(msg.sender, address(this)), minAmount + transferFee); token.safeTransferFrom(msg.sender, option.holder, minAmount); token.safeTransferFrom(msg.sender, address(this), transferFee); address oldHolder = option.holder; option.holder = msg.sender; emit OptionTransfer(_optionId, oldHolder, msg.sender, minAmount, transferFee); } 19",
        "labels": [
            "SlowMist",
            "Oddz Finance",
            "Type: Reordering Vulnerability",
            "Severity: Critical"
        ]
    },
    {
        "title": "Excessive authority issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Oddz Finance_en-us.pdf",
        "body": "(1) The owner of the OddzIVOracleManager and OddzPriceOracleManager contracts can change the conguration of the contract and does not use timelock for management, there is a risk of excessive authority. The oracle aects the price of the asset. When the oracle contract is maliciously manipulated, it will cause the user's asset to be damaged. (2) After the contracts are deployed, it is necessary to check whether TimeLocker is set correctly.",
        "labels": [
            "SlowMist",
            "Oddz Finance",
            "Type: Authority Control Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - EarningFarm v3 Iterative_en-us.pdf",
        "body": "In the Exchange contract, the owner role can set swapCaller and router through the setSwapCaller and listRouter functions. If it is set to a malicious address, funds will be lost. In the CDai contract, the owner role can set sensitive parameters through the setSwapPath function. This will lead to the risk of excessive owner permissions. ",
        "labels": [
            "SlowMist",
            "EarningFarm v3 Iterative",
            "Type: Authority Control Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Variable storage issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - EarningFarm v3 Iterative_en-us.pdf",
        "body": "In the Curve3Pool contract, the swap function is used for token exchange. When fetching pools[_index], it uses storage to store the curve variable, but in this function there is no need to modify pools[_index], so this will consume more gas. ",
        "labels": [
            "SlowMist",
            "EarningFarm v3 Iterative",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Slippage issue 9",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - EarningFarm v3 Iterative_en-us.pdf",
        "body": "In the Curve3Pool contract, the swap function is used to exchange tokens in 3pool, but the _min_received passed in during the exchange is 0, which will cause the exchange process to be subject to a sandwich attack. ",
        "labels": [
            "SlowMist",
            "EarningFarm v3 Iterative",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "get_dy index issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - EarningFarm v3 Iterative_en-us.pdf",
        "body": "In the CDai contract, the _totalAssets function converts DAI to USDC as total assets via CurvePool's get_dy. But Calculate withdraw amout of usdc - from Dai (j) to USDC(i) is stated in the comments, while according to the get_dy function description (https://curve.readthedocs.io/factory-pools.html#StableSwap.get_dy ), the i index should be DAI, and the j index should be USDC. ",
        "labels": [
            "SlowMist",
            "EarningFarm v3 Iterative",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of breaching contract integrity",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - EarningFarm v3 Iterative_en-us.pdf",
        "body": "When the user makes a withdrawal, the protocol will withdraw from the SS contract through the controller contract, and then burn the user's share. 11 In the withdraw function of the SS contract, it will rst calculate the number of LPs that the user can withdraw (lpAmt), then extract the LP tokens from the convex, and then use balanceOf(address(this)) to obtain the LP balance of this contract as lpWithdrawn. TotalLP will then subtract lpWithdrawn and remove liquidity from CurvePool. The amount to remove liquidity is also lpWithdrawn. Then transfer all USDC tokens in the SS contract to the controller. Finally, the controller contract transfers the USDC token to the user. In the withdraw function of the vault contract, after the controller completes the withdrawal, the number of burned shares is calculated based on the assets passed in by the user. This will lead to the destruction of the totalLP value if a malicious user transfers a large amount of LP tokens to the SS contract and withdraws them after depositing. ",
        "labels": [
            "SlowMist",
            "EarningFarm v3 Iterative",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Risk of slippage checks being bypassed",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - EarningFarm v3 Iterative_en-us.pdf",
        "body": "In the CDai contract, the totalAssets function calculates the total collateral amount of the SS contract in the strategy through the get_dy function of CurvePool. When the user withdraws, the contract will participate in the calculation of 12 the nDAI value to be withdrawn through totalAssets. Unfortunately, a malicious user can manipulate the CurvePool with large sums of money so that the value obtained by the get_dy function is much smaller than expected, which will cause the nDAI value to be much larger than expected when withdrawing. Malicious users can deplete the liquidity in CDai by stealing collateral that does not belong to them. ",
        "labels": [
            "SlowMist",
            "EarningFarm v3 Iterative",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Arbitrary permission initialization of lend/oracle contract",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Larix Obsolete_en-us.pdf",
        "body": "Anyone can initialize the lend/oracle contract, which may lead to the illegal use of the contract, and malicious users may use the ocially deployed Program to conduct fraudulent activities.",
        "labels": [
            "SlowMist",
            "Larix Obsolete",
            "Type: Authority Control Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Flash loan repayment detection bypass",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Larix Obsolete_en-us.pdf",
        "body": "After the attacker calls process_flash_loan to borrow, he uses the borrowed funds to recharge to the contract. In this way, the ash loan will detect that the funds have been returned during the repayment check, which leads to the success of the ash loan, but the funds are not actually returned. Instead, the attacker get a deposit position is established, and the attacker can withdraw this fund at any time, thereby stealing all the funds in the fund pool.",
        "labels": [
            "SlowMist",
            "Larix Obsolete",
            "Type: Reentrancy Vulnerability",
            "Severity: Critical"
        ]
    },
    {
        "title": "Process_ash_loan forged account risk 7",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Larix Obsolete_en-us.pdf",
        "body": "Code location: larix-lending/src/processor.rs fn process_flash_loan( program_id: &Pubkey, liquidity_amount: u64, accounts: &[AccountInfo], ) If the owner or key of the reserve_info account is not veried, the attacker may attack the contract by maliciously constructing the data stored in the account.",
        "labels": [
            "SlowMist",
            "Larix Obsolete",
            "Type: Forged account attack",
            "Severity: Critical"
        ]
    },
    {
        "title": "Process_reserve forged account risk",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Larix Obsolete_en-us.pdf",
        "body": "Code location: larix-lending/src/cong/cong_process.rs fn process_reserve(program_id: & Pubkey, accounts: & [AccountInfo],reserve_type:ConfigReserveType) If the owner or key of the reserve_info account is not veried, the attacker may attack the contract by maliciously constructing the data stored in the account.",
        "labels": [
            "SlowMist",
            "Larix Obsolete",
            "Type: Forged account attack",
            "Severity: Critical"
        ]
    },
    {
        "title": "process_borrow_obligation_liquidity host_fee transfer target is not veried",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Larix Obsolete_en-us.pdf",
        "body": "Code location: larix-lending/src/processor.rs if let Ok(host_fee_receiver_info) = next_account_info(account_info_iter) { if host_fee > 0 { owner_fee = owner_fee .checked_sub(host_fee) .ok_or(LendingError::MathOverflow)?; spl_token_transfer(TokenTransferParams { source: source_liquidity_info.clone(), destination: host_fee_receiver_info.clone(), amount: host_fee, authority: lending_market_authority_info.clone(), authority_signer_seeds, token_program: token_program_id.clone(), })?; } } The owner or key of the host_fee_receiver_info account is not veried, and the user can steal host_fee by specifying host_fee_receiver_info .",
        "labels": [
            "SlowMist",
            "Larix Obsolete",
            "Type: Forged account attack",
            "Severity: Critical"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap_v3_Phase2_en-us.pdf",
        "body": "1.The owner role can change the external part contract FARM_BOOSTER through the updateFarmBoostContract function and the external part contract can aect the boostMultiplier . ",
        "labels": [
            "SlowMist",
            "PancakeSwap_v3_Phase2",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "LP token locking issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap_v3_Phase2_en-us.pdf",
        "body": "In the MasterChefV3 contract, users will transfer their ERC721 LP tokens for staking to get the CAKE as reward. Users can only call the safeTransferFrom function to transfer their ERC721 LP token in the MasterChefV3 contract to trigger the _checkOnERC721Received hook to let the NonfungiblePositionManager contract call back the onERC721Received function. After this, the positionInfo can be recorded and make the staking eective. If users miss transferring the LP token by using the transferFrom function, the LP tokens will be locked in this contract. ",
        "labels": [
            "SlowMist",
            "PancakeSwap_v3_Phase2",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Cast truncation issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap_v3_Phase2_en-us.pdf",
        "body": "In the PancakeV3LmPool contract, the Pool or MasterChef will calculate the reward through the accumulateReward function. The uint256 endTime is assigned by getLatestPeriodInfo in the MasterChef contract and the endTime is assigned by an uint256 value latestPeriodEndTime , then the endTime will cast to an uint32 to endTimestamp . If the latestPeriodEndTime is larger than type(uin32).max , there will be a cast truncation issue. And PancakeV3LmPool contract imports the SafeCast contract but doesnt use it for the uin32 cast. ",
        "labels": [
            "SlowMist",
            "PancakeSwap_v3_Phase2",
            "Type: Arithmetic Accuracy Deviation Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Redundant logic issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - MasterChef v2_en-us.pdf",
        "body": "In the add function, the owner can add new pools. It will rst check whether the number of newly added lpTokens in the contract is greater than or equal to 0. But in fact, the number of lpTokens in the contract will be greater than or equal to 0 in any case, so this check is redundant. ",
        "labels": [
            "SlowMist",
            "MasterChef v2",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Permission control issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - MasterChef v2_en-us.pdf",
        "body": "If any user holds the dummy token, the user can stake the dummy token to the MasterChef v1 contract through the init function, which will cause the lastBurnedBlock parameter to be updated unexpectedly, and nally lead to an error in the calculation of the number of CAKE tokens waiting to be burned. ",
        "labels": [
            "SlowMist",
            "MasterChef v2",
            "Type: Authority Control Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "The number of pendingCakeToBurn is not checked",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - MasterChef v2_en-us.pdf",
        "body": "In the burnCake function, if the number of CAKE tokens in the contract is less than pendingCakeToBurn, it will harvest CAKE tokens from MasterChef v1 via the harvestFromMasterChef function. But it does not check if the balance of CAKE tokens in the contract after harvesting is greater than or equal to pendingCakeToBurn. ",
        "labels": [
            "SlowMist",
            "MasterChef v2",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Repeatable initialization issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap_MOVE_en-us.pdf",
        "body": "In the swap module RESOURCE_ACCOUNT can initialize SwapInfo through the init_storage function, but the function does not check for repeated initialization. ",
        "labels": [
            "SlowMist",
            "PancakeSwap_MOVE",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Gas optimization",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap_MOVE_en-us.pdf",
        "body": "In the swap module, the add_liquidity function is used to add liquidity and return the remaining tokens to the user. But without checking whether the token value to be returned is greater than 0, the coin::deposit function is called. If the returned token value is 0, this will cause unnecessary gas consumption. ",
        "labels": [
            "SlowMist",
            "PancakeSwap_MOVE",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Architecture optimization",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap_MOVE_en-us.pdf",
        "body": "The storage of LP tokens is realized through storage.move in the protocol. But the creation of Pair is realized through the create_pair of the swap module and the resource storage is carried out by TokenPairMetadata and TokenPairReserve. So LPToken can be implemented directly in swap module without having to implement it in storage.move separately. ",
        "labels": [
            "SlowMist",
            "PancakeSwap_MOVE",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Assertion aw issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap_MOVE_en-us.pdf",
        "body": "In the swap module, the mint function is used to mint LP tokens when liquidity is added. When adding liquidity for the rst time, the liquidity amount needs to meet MINIMUM_LIQUIDITY. If the MINIMUM_LIQUIDITY is not met, the 12 transaction will be revet. In this case the protocol will throw an overow error instead of ERROR_INSUFFICIENT_LIQUIDITY_MINTED. ",
        "labels": [
            "SlowMist",
            "PancakeSwap_MOVE",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Not checked if pair has been created",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap_MOVE_en-us.pdf",
        "body": "In the router module contract, users can remove liquidity and exchange tokens through the functions remove_liquidity, swap_exact_input, swap_exact_output, swap_exact_input_doublehop, 13 swap_exact_output_doublehop, swap_exact_input_triplehop and swap_exact_output_triplehop respectively, but do not check whether a pair is created rst. ",
        "labels": [
            "SlowMist",
            "PancakeSwap_MOVE",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Redundant code",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap_MOVE_en-us.pdf",
        "body": "In the Swap module, the quote_x_to_y_after_fees, quote_y_to_x_after_fees, transfer_x and transfer_y functions are all internal functions, but no other public functions call them. ",
        "labels": [
            "SlowMist",
            "PancakeSwap_MOVE",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "k value check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap_MOVE_en-us.pdf",
        "body": "During the swap process, it is necessary to check whether the multiplication of the token balance of the pair after the swap is strictly greater than or equal to the k value. However, due to the fee charged during the swap process, in theory, the multiplication of the token balance of the pair after swap must be strictly greater than the k value. While using u256 avoids close rounding errors it is still not necessary to check if it is equal to the k value. ",
        "labels": [
            "SlowMist",
            "PancakeSwap_MOVE",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap_MOVE_en-us.pdf",
        "body": "In the swap module contract, the admin role can call the upgrade_swap function to upgrade the entire contract. If administrator privileges are stolen, it may have an impact on the normal operation of the contract. ",
        "labels": [
            "SlowMist",
            "PancakeSwap_MOVE",
            "Type: Excessive Authority Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "The validity of the token contract address is not checked",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Bitlayer Bridge Phase 2.pdf",
        "body": "In the BitlayerBridgeV2 contract, the crossoutBurn function does not check the validity of the token address. An attacker can pass in the token contract address created by himself, and then transfer and burn the tokens created by the attacker through the crossoutBurn function to trigger the CrossoutBurned event. contracts/BitlayerBridgeV2.sol#L278-L307 function crossoutBurn( address token, uint256 value, string memory btcReceiver ) external payable { require(token != address(0), \"invalid token address\"); require(value != 0, \"invalid value\"); require(bytes(btcReceiver).length != 0, \"invalid btcReceiver\"); uint256 crossoutFeeAmount = tokenConfigs[token].crossoutFee; require(crossoutFeeAmount == 0 || msg.value >= crossoutFeeAmount, \"not enough fee paied\"); SafeERC20.safeTransferFrom(IERC20(token), msg.sender, address(this), value); IPegToken(token).burn(address(this), value); if (crossoutFeeAmount > 0) { (bool success, bytes memory returndata) = feeAddress.call{value: crossoutFeeAmount}(\"\"); require(success, string(returndata)); } uint256 unusedFee = msg.value - crossoutFeeAmount; if (unusedFee > 0) { (bool success, bytes memory returndata) = msg.sender.call{value: unusedFee}(\"\"); require(success, string(returndata)); } emit CrossoutBurned(msg.sender, btcReceiver, token, value); }",
        "labels": [
            "SlowMist",
            "Bitlayer Bridge Phase 2",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Unlimited huge amount minting",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Bitlayer Bridge Phase 2.pdf",
        "body": "In the BitlayerBridgeV2 contract, when huge amounts are minted through the proposeMint function and executeMint function, the minted amount is not limited by periodLimit , nor is it recorded in periodMinted , and the period will not be updated. contracts/BitlayerBridgeV2.sol#L235-L255,L258-L275 function proposeMint( MintInfo memory mInfo ) external onlyRole(ProposerRole) { bytes32 blExecHash = keccak256(abi.encodePacked(mInfo.btcTxHash)); require(!executedBtcHash[blExecHash], \"already executed\"); require(mInfo.receiver != address(0), \"receiver is null\"); require(proposedMint[blExecHash].receiver == address(0), \"already proposed\"); require(mInfo.value >= tokenConfigs[mInfo.token].mintSplitLine, \"mint value is less than configed\"); require( !IPegToken(mInfo.token).isBlacklist(mInfo.receiver), \"receiver is blacklisted\" ); proposedMint[blExecHash] = mInfo; emit MintProposed(mInfo.btcTxHash, blExecHash, mInfo.receiver, mInfo.token, mInfo.value); } function executeMint( bytes32 blExecHash ) external onlyRole(ExecutorRole) { MintInfo memory mInfo = proposedMint[blExecHash]; require(!executedBtcHash[blExecHash], \"already executed\"); require(mInfo.receiver != address(0), \"not proposed\"); executedBtcHash[blExecHash] = true; delete proposedMint[blExecHash]; IPegToken(mInfo.token).mint(mInfo.receiver, mInfo.value); emit MintExecuted(mInfo.btcTxHash, blExecHash, mInfo.receiver, mInfo.token, mInfo.value); }",
        "labels": [
            "SlowMist",
            "Bitlayer Bridge Phase 2",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "The returned leftQuota value is inaccurate",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Bitlayer Bridge Phase 2.pdf",
        "body": "In the BitlayerBridgeV2 contract, the getPeriodInfo function is inaccurate when returning the leftQuota of the specied token. If block.number has reached the next period and tokenConfigs[token] has not been updated, the value of leftQuota should be config.periodLimit . contracts/BitlayerBridgeV2.sol#L309-L319 function getPeriodInfo(address token) external view returns(uint256 periodLimit, uint256 leftQuota, uint256 leftBlocksToNextPeriod) { TokenConfig memory config = tokenConfigs[token]; periodLimit = config.periodLimit; leftQuota = config.periodLimit - config.periodMinted; leftBlocksToNextPeriod = config.periodInterval - (block.number - config.lastBlockNumber) % config.periodInterval; }",
        "labels": [
            "SlowMist",
            "Bitlayer Bridge Phase 2",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Missing zero address check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Bitlayer Bridge Phase 2.pdf",
        "body": "1.In the BitlayerBridgeV2 contract, the initToken function does not perform a zero address check on the token address. contracts/BitlayerBridgeV2.sol#L99-L119 function initToken( address token, ``` ) external onlyRole(AdminRole) { TokenConfig storage config = tokenConfigs[token]; ``` } 2.In the BitlayerBridgeV2 contract, the directMint function does not perform a zero address check on the mInfo.token address. contracts/BitlayerBridgeV2.sol#L198-L233 function directMint( MintInfo memory mInfo ) external onlyRole(MinterRole) { ``` IPegToken(mInfo.token).mint(mInfo.receiver, mInfo.value); ``` } 3.In the BitlayerBridgeV2 contract, the proposeMint function does not perform a zero address check on the mInfo.token address. BitlayerBridgeV2.sol#L235-L255 function proposeMint( MintInfo memory mInfo ) external onlyRole(ProposerRole) { ``` require( !IPegToken(mInfo.token).isBlacklist(mInfo.receiver), \"receiver is blacklisted\" ); ``` }",
        "labels": [
            "SlowMist",
            "Bitlayer Bridge Phase 2",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Unchecked parameter value is not 0",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Bitlayer Bridge Phase 2.pdf",
        "body": "1.In the BitlayerBridgeV2 contract, the initToken function does not check whether the values of periodInterval and mintSplitLine are not 0. contracts/BitlayerBridgeV2.sol#L99-L119 function initToken( address token, uint256 periodLimit, uint256 periodInterval, uint256 mintSplitLine, uint256 crossoutFee ) external onlyRole(AdminRole) { TokenConfig storage config = tokenConfigs[token]; require(config.lastBlockNumber == 0, \"already inited\"); config.lastBlockNumber = block.number; config.periodLimit = periodLimit; config.periodInterval = periodInterval; config.mintSplitLine = mintSplitLine; config.crossoutFee = crossoutFee; emit TokenInited(token, periodLimit, periodInterval, mintSplitLine, crossoutFee); } 2.In the BitlayerBridgeV2 contract, the setMintSplitLine function does not check whether the value of limit is not 0. contracts/BitlayerBridgeV2.sol#L137-L149 function setMintSplitLine( address token, uint256 limit ) public onlyRole(AdminRole) { require(token != address(0), \"invalid token address\"); tokenConfigs[token].mintSplitLine = limit; emit MintSplitLineSet(token, limit); } 3.In the BitlayerBridgeV2 contract, the directMint function does not check whether the value of mInfo.value is not 0. BitlayerBridgeV2.sol#L198-L233 function directMint( MintInfo memory mInfo ) external onlyRole(MinterRole) { ``` require( mInfo.value < config.mintSplitLine, \"mint value is greater than configed\" ); ``` }",
        "labels": [
            "SlowMist",
            "Bitlayer Bridge Phase 2",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Redundant code",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Bitlayer Bridge Phase 2.pdf",
        "body": "In the BitlayerBridgeV2 contract, the directMint function repeatedly performs a zero address check on the mInfo.receiver address because the zero address check has already been performed on this address in the mint function of the token contract. contracts/BitlayerBridgeV2.sol#L198-L233 function directMint( MintInfo memory mInfo ) external onlyRole(MinterRole) { ``` require(mInfo.receiver != address(0), \"receiver is null\"); ``` }",
        "labels": [
            "SlowMist",
            "Bitlayer Bridge Phase 2",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Bitlayer Bridge Phase 2.pdf",
        "body": "1.In the BitlayerBridgeV2 contract, the AdminRole role can set important parameters in the contract through the following functions. contracts/BitlayerBridgeV2.sol function setRoles function initToken function setPeriodMintLimit function setMintSplitLine function setCrossoutFee function setPeriodInterval function startNewPeriod 2.The BitlayerBridge contracts are implemented using the OpenZeppelin upgradeable model, allowing the AdminRole role to perform contract upgrades.Since the BitlayerBridgeV2 contract inherits the BitlayerBridge contract, it is also an upgradeable contract. However, this design introduces an excessive privilege risk. contracts/BitlayerBridge.sol#L4 import \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\"; 3.In the BitlayerBridge contract, AdminRole role can set important parameters of the contract.And the BitlayerBridgeV2 contract also inherits these privileged functions. contracts/BitlayerBridge.sol function setFeeAddress function setLockFee function setMinLockAmount function setMaxLockAmount 4.In the BitlayerBridge contract, the LiquidityRole role can call the removeLiquidityTo function to remove the liquidity of any address.And the BitlayerBridgeV2 contract also inherits this privileged functions. contracts/BitlayerBridge.sol#L159-L162 function removeLiquidity(uint256 amount) external whenNotPaused { require(amount > 0, \"invalid amount\"); doRemoveLiquidity(msg.sender, amount); } 5.In the BitlayerBridge contract, UnlockRole can pass in any _txHash through the unlock function to unlock any amount of native tokens. In the BitlayerBridgeV2 contract, MinterRole , ProposerRole and ExecutorRole can mint any amount of PegToken by passing in any btcTxHash parameter through their respective functions ( directMint , proposeMint and executeMint ). These vulnerabilities stem from the contract's inability to verify Bitcoin networks transaction hash at the EVM level, instead leaving verication to a centralized validator. contracts/BitlayerBridge.sol function unlock contracts/BitlayerBridgeV2.sol function directMint function proposeMint function executeMint",
        "labels": [
            "SlowMist",
            "Bitlayer Bridge Phase 2",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Missing event record",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap_Pottery_en-us.pdf",
        "body": "When the sensitive parameters of the contract are modied, the corresponding events are not recorded, which is not conducive to the supervision of the community and users. ",
        "labels": [
            "SlowMist",
            "PancakeSwap_Pottery",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Business logic problem",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap_Pottery_en-us.pdf",
        "body": "The contract does not check whether the incoming address and ID exist. If the wrong data is passed in in the actual operation, it will lead to waste of resources. ",
        "labels": [
            "SlowMist",
            "PancakeSwap_Pottery",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap_Pottery_en-us.pdf",
        "body": "The Owner has the right to modify the address of the contract to any address. ",
        "labels": [
            "SlowMist",
            "PancakeSwap_Pottery",
            "Type: Authority Control Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Defects in the defaultDepositSS check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ENF_ETH_Lowrisk_en-us.pdf",
        "body": "In the harvest function of the Controller contract, before re-depositing the protocol income into the strategy, it will check whether the default SS exists through subStrategies.length > defaultDepositSS . But actually, defaultDepositSS will be 0 when the default SS does not exist, so the subStrategies.length > defaultDepositSS check will always pass. Eventually the protocol will fail to re-deposit. ",
        "labels": [
            "SlowMist",
            "ENF_ETH_Lowrisk",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "ownerDeposit remaining deposit issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ENF_ETH_Lowrisk_en-us.pdf",
        "body": "In the ownerDeposit function of the StETH contract, the owner role will directly deposit ETH into the strategy. It checks that msg.value must be greater than or equal to the amount to be deposited through _amount <= msg.value . But when the owner's msg.value is greater than _amount , the ownerDeposit function does not implement the refund of excess ETH. This will result in funds being locked. The same is true for the ownerDeposit function of the CEth contract. ",
        "labels": [
            "SlowMist",
            "ENF_ETH_Lowrisk",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Redundant variable",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ENF_ETH_Lowrisk_en-us.pdf",
        "body": "There is a weth global variable in the CEth contract, but this variable is not used in the contract. ",
        "labels": [
            "SlowMist",
            "ENF_ETH_Lowrisk",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ENF_ETH_Lowrisk_en-us.pdf",
        "body": "10 In the protocol, the owner role has many permissions, such as: the owner can set sensitive parameters, can suspend the contract, can make emergency withdrawals, can migrate the funds of the SS contract, etc. It is obviously inappropriate to give all the permissions of the protocol to the owner, which will greatly increase the single point of risk.",
        "labels": [
            "SlowMist",
            "ENF_ETH_Lowrisk",
            "Type: Authority Control Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Compound interest slippage check issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ENF_ETH_Lowrisk_en-us.pdf",
        "body": "In the router contract, no slippage check is performed during the swap operation. If there are more funds with compound interest, there will be a risk of being attacked by sandwiches. ",
        "labels": [
            "SlowMist",
            "ENF_ETH_Lowrisk",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Business logic issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Unemeta_en-us.pdf",
        "body": "1.In the UnemetaMarket contract, the matchSellerOrdersWETH and matchSellerOrders use the strategy to match orders, but the canExecuteTakerBid function is not in the StrategyFixedPrice contract. ",
        "labels": [
            "SlowMist",
            "Unemeta",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Unemeta_en-us.pdf",
        "body": "The owner role of the RoyaltyFeeRegistry and RoyaltyFeeSetter contract can update the royaltyFeeLimit and the FeeInfo of the NFT collection. ",
        "labels": [
            "SlowMist",
            "Unemeta",
            "Type: Authority Control Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Risk of replay attack",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Unemeta_en-us.pdf",
        "body": "13 The chainid is dened when the contract is initialized, but it is not reimplemented when DOMAIN(domainSeparator) is used in the verify function. So the domainSeparator contains the chainId and is dened at contract deployment instead of reconstructed for every signature, there is a risk of possible replay attacks between chains in the event of a future chain split. ",
        "labels": [
            "SlowMist",
            "Unemeta",
            "Type: Replay Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing event records",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap Stable Swap_en-us.pdf",
        "body": "In the PancakeStableSwap contract, the owner can set the is_killed, balances and admin_actions_deadline parameters respectively through the kill_me, unkill_me, donate_admin_fees and revert_new_parameters functions, but no event recording is performed. ",
        "labels": [
            "SlowMist",
            "PancakeSwap Stable Swap",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Ring Protocol_en-us.pdf",
        "body": "1.In the FewWrappedToken contract, the burner role can burn any users Wrapped tokens through the burnFrom function without users approval. All role settings are completed in the core contract, which is not within the scope of this audit. ",
        "labels": [
            "SlowMist",
            "Ring Protocol",
            "Type: Authority Control Vulnerability Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Token compatibility reminder",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Ring Protocol_en-us.pdf",
        "body": "In the FixedStakingRewards contract, users can stake, stakeWithPermit, and withdraw the stakeingTokens by safetransferFrom and safetransfer functions to the staking contract and the amount will be directly recorded in the totalSupply. If the stakingTokens are deationary tokens, the actual amount of tokens received by the FixedStakingRewards contract will be less than the amount recorded by the amount parameter. ",
        "labels": [
            "SlowMist",
            "Ring Protocol",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Potential token decimal compatibility reminder",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Ring Protocol_en-us.pdf",
        "body": "In the FixedStakingRewards contract, users can stake the tokens through the stake and stakeWithPermit functions. It will update each totalSupply and balances parameters according to the amount of user deposits. These parameters will not distinguish dierent stakingTokens, if the stakingTokens deposit with dierent decimals will may lead to errors in the calculation of rewards in the protocol.",
        "labels": [
            "SlowMist",
            "Ring Protocol",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing the event records",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Ring Protocol_en-us.pdf",
        "body": "In the FixedStakingRewards contract, the rewardSetter can arbitrarily modify every rewardPerTokenPerSecond , periodFinish , and rewardSetter parameters in each StakingInfo, but there are no event logs. ",
        "labels": [
            "SlowMist",
            "Ring Protocol",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing the 0 address check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Ring Protocol_en-us.pdf",
        "body": "In the FixedStakingRewards and CoreRef contract, the Governor role can modify the _core address and the rewardSetter can modify the rewardSetter address, but there are no 0 address checks. ",
        "labels": [
            "SlowMist",
            "Ring Protocol",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Malleable attack risk",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Ring Protocol_en-us.pdf",
        "body": "In the permit function of the FewWrappedToken contract, it restores the address of the signer through the ecrecover function, but does not check the value of v and s. Since EIP2 still allows the malleability for ecrecover, this will lead to the risk of transaction malleability attacks. ",
        "labels": [
            "SlowMist",
            "Ring Protocol",
            "Type: Replay Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of replay attack",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Ring Protocol_en-us.pdf",
        "body": "DOMAIN_SEPARATOR is dened when the contract is initialized, but it is not reimplemented when DOMAIN_SEPARATOR is used in the permit function. So the DOMAIN_SEPARATOR contains the chainId and is dened at contract deployment instead of reconstructed for every signature, there is a risk of possible replay attacks between chains in the event of a future chain split. ",
        "labels": [
            "SlowMist",
            "Ring Protocol",
            "Type: Replay Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Preemptive Initialization",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Ring Protocol_en-us.pdf",
        "body": "By calling the initialize and deploy functions to initialize the contracts, there is a potential issue that malicious attackers preemptively call the initialize function to initialize. ",
        "labels": [
            "SlowMist",
            "Ring Protocol",
            "Type: Race Conditions Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - getBTC.pdf",
        "body": "1.In the TokenExchange contract, the owner role can set vaults mapping through the setVaults function. TokenExchange.sol#L74-L77 function setVaults(address valut, bool status) external onlyOwner { vaults[valut] = status; emit SetVaults(valut, status); } 2.In the TokenExchange contract, the owner role can set the Operator role address through the setOperator function; the owner's ownership can be transferred through the transferOwnership function. TokenExchange.sol#L90-L94,L95-L99 function transferOwnership(address newOwner) external onlyOwner { require(newOwner != address(0),\"Owner_Should_Not_Zero_Address\"); owner = newOwner; emit TransferOwnership(newOwner); } function setOperator(address newOp) external onlyOwner { operator = newOp; emit SetOperator(newOp); } 3.In the TokenExchange contract, the owner role can withdraw the ERC20 token in the contract through the withdrawERC20 function; the Native token in the contract can be withdrawn through the withdrawBTC function. TokenExchange.sol#L78-L82,L82-L88 function withdrawERC20(address tokenAddress, address receiver, uint256 amount) external onlyOwner { require(amount <= IERC20(tokenAddress).balanceOf(address(this)),\"Token_Not_Enough\"); SafeERC20.safeTransfer(IERC20(tokenAddress), receiver, amount); emit Withdrawn(tokenAddress, receiver, amount); } function withdrawBTC(address payable receiver, uint256 amount) external onlyOwner { require(amount <= address(this).balance,\"BTC_Not_Enough\"); (bool success, bytes memory returnData) = receiver.call{value: amount}(\"\"); require(success, string(returnData)); emit Withdrawn(address(0), receiver, amount); }",
        "labels": [
            "SlowMist",
            "getBTC",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Missing zero address check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - getBTC.pdf",
        "body": "In the TokenExchange contract, the withdrawBTC function and setOperator function lack zero address check. TokenExchange.sol#L83-L88,L95-L98 function withdrawBTC(address payable receiver, uint256 amount) external onlyOwner { require(amount <= address(this).balance,\"BTC_Not_Enough\"); (bool success, bytes memory returnData) = receiver.call{value: amount}(\"\"); require(success, string(returnData)); emit Withdrawn(address(0), receiver, amount); } function setOperator(address newOp) external onlyOwner { operator = newOp; emit SetOperator(newOp); }",
        "labels": [
            "SlowMist",
            "getBTC",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Variable names are the same",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - getBTC.pdf",
        "body": "The private string variable _name dened in the TokenExchange contract has the same name as the private immutable string _name inherited from the EIP712 contract. TokenExchange.sol#L19 string private _name; EIP712.sol#L49 ShortString private immutable _name;",
        "labels": [
            "SlowMist",
            "getBTC",
            "Type: Others",
            "Severity: Information"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - peg-Token.pdf",
        "body": "1.The PegToken contracts and the TokenManager contract are implemented using the OpenZeppelin upgradeable model, allowing the AdminRole role to perform contract upgrades. In the TokenManager contract, the Operator role can upgrade the specied PegToken contract through the upgradeToken function.However, this design introduces an excessive privilege risk. TokenManager.sol#L123-L131 function upgradeToken(string memory symbol, address newImpl, bytes memory callData) external onlyRole(Operator) { require(newImpl != address(0), \"invalid new impl\"); PegToken peg = getDeployedTokenOrRevert(symbol); peg.upgradeToAndCall(newImpl, callData); } 2.In the TokenManager contract, the Operator role can call the setBlacklist function of the specied PegToken contract through the setBlackList function to add a blacklist address. TokenManager.sol#L79-L87 function setBlackList(string memory symbol, address account, bool toBlacklist) external onlyRole(Operator) { require(account != address(0), \"invalid account\"); PegToken peg = getDeployedTokenOrRevert(symbol); peg.setBlacklist(account, toBlacklist); } PegToken.sol#L86-L92 function setBlacklist(address account, bool toBlacklist) external onlyManager { isBlacklist[account] = toBlacklist; emit BlacklistAdded(account, toBlacklist); } 3.In the TokenManager contract, the Operator role can add the Minter role by calling the setMinter function of the specied PegToken contract through the setMinter function. TokenManager.sol#L89-L97 function setMinter(string memory symbol, address account, bool asMinter) external onlyRole(Operator) { require(account != address(0), \"invalid account\"); PegToken peg = getDeployedTokenOrRevert(symbol); peg.setMinter(account, asMinter); } PegToken.sol#L94-L100 function setMinter(address account, bool asMinter) external onlyManager { minters[account] = asMinter; emit MinterSet(account, asMinter); } 4.In the PegToken contract, the Minter role can mint any number of tokens by calling the mint function through the mint function. PegToken.sol#L112-L118 function mint(address to, uint256 amount) external onlyMinter notBlacklisted(to) { _mint(to, amount); } 5.In the TokenManager contract, the FreezeRole role can perform transfer operations by calling the recall function of the specied PegToken contract through the recall function. TokenManager.sol#L159-L165 function recall(string memory symbol, address from, address to, uint256 value) external onlyRole(FreezeRole) { PegToken peg = getDeployedTokenOrRevert(symbol); peg.recall(from, to, value); } PegToken.sol#L120-L126 function recall(address from, address to, uint256 value) external onlyManager { _transfer(from, to, value); emit TokenRecalled(from, to, value); } 6.In the TokenManager contract, the FreezeRole role can freeze the specied token at the specied address by calling the freeze function of the specied PegToken contract through the freezeToken function. TokenManager.sol#L143-L149 function freezeToken(string memory symbol, address account, uint256 value) external onlyRole(FreezeRole) { PegToken peg = getDeployedTokenOrRevert(symbol); peg.freeze(account, value); } PegToken.sol#L128-L136 function freeze(address account, uint256 value) external onlyManager { _transfer(account, address(this), value); freezedToken[account] += value; emit TokenFreezed(account, value); }",
        "labels": [
            "SlowMist",
            "peg-Token",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "DoS issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Flurry Bridge_en-us.pdf",
        "body": "The getVoteCount function uses a for loop to count members votes. When the number of members is large, it will cause DoS due to the increased number of for loops. bridge/contracts/contracts/Federation.sol#L242-L249 function getVoteCount(bytes32 processId) public view override returns(uint) { uint count = 0; for (uint i = 0; i < members.length; i++) { if (votes[processId][members[i]]) count += 1; } return count; }",
        "labels": [
            "SlowMist",
            "Flurry Bridge",
            "Type: Denial of Service Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Safety Reminders",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Flurry Bridge_en-us.pdf",
        "body": "To capture events in the cross-chain bridge, the implementation of subscribing to the events of the specied contract should be adopted to avoid the attacks of fake contract events.",
        "labels": [
            "SlowMist",
            "Flurry Bridge",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Limit of value range",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Flurry Bridge_en-us.pdf",
        "body": "Owner can set fee arbitrarily, and there is no restriction on the value range. and the fee variable is not used in the contract code. bridge/contracts/contracts/Registry.sol#L87-L91 function setFee(address localaddr_, uint256 fee_) external override onlyOwner { require(fee_ > 0, \"Registry: Fee Should be> 0\"); fee[localaddr_] = fee_; emit FeeChanged(localaddr_, fee_); } 8",
        "labels": [
            "SlowMist",
            "Flurry Bridge",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Useless code",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Flurry Bridge_en-us.pdf",
        "body": "There are a lot of comment codes in the contract. It is necessary to conrm whether the comment codes are redundant codes. bridge/contracts/contracts/Registry.sol#L43-L85 // function registerCall( // uint256 alienChainId_, // address alienChainContractAddr_, // address localChainContractAddr_, // bytes4 callSig_ // ) external onlyOwner { // bytes32 callRegistryID = Utils.getCallRegistryId( // alienChainId_, // alienChainContractAddr_, // localChainContractAddr_, // callSig_ // ); // require(!callRegistry[callRegistryID], \"Registry: Call already exists in callRegistry\"); // callRegistry[callRegistryID] = true; // emit CallRegistered( // alienChainId_, // alienChainContractAddr_, // localChainContractAddr_, // callSig_ // ); // } // function unregisterCall( 9 // uint256 alienChainId_, // address alienChainContractAddr_, // address localChainContractAddr_, // bytes4 callSig_ // ) external onlyOwner { // bytes32 callRegistryID = Utils.getCallRegistryId( // alienChainId_, // alienChainContractAddr_, // localChainContractAddr_, // callSig_ // ); // require(callRegistry[callRegistryID], \"Registry: Call not registered\"); // delete callRegistry[callRegistryID]; // emit CallUnregistered( // alienChainId_, // alienChainContractAddr_, // localChainContractAddr_, // callSig_ // ); // } bridge/contracts/contracts/Federation.sol#L159-L240 // function voteCall( // uint256 srcChainID_, // address srcChainContractAddress_, // address dstChainContractAddress_, // bytes32 transactionHash_, // uint32 logIndex_, // bytes calldata payload // ) external override onlyMember { // if (bridge.isCallProcessed( // srcChainID_, // srcChainContractAddress_, // dstChainContractAddress_, // transactionHash_, // logIndex_, // payload // )) { // return; // } // bytes32 callId = Utils.getCallId( 10 // srcChainID_, // srcChainContractAddress_, // dstChainContractAddress_, // transactionHash_, // logIndex_, // payload // ); // if (votes[callId][_msgSender()]) // return; // votes[callId][_msgSender()] = true; // emit VotedCall( // srcChainID_, // srcChainContractAddress_, // dstChainContractAddress_, // transactionHash_, // logIndex_, // _msgSender(), // callId, // payload // ); // uint voteCount = getVoteCount(callId); // if ((voteCount >= required) && (voteCount >= members.length / 2 + 1)) { // bridge.acceptCall( // srcChainID_, // srcChainContractAddress_, // dstChainContractAddress_, // transactionHash_, // logIndex_, // payload // ); // emit ExecutedCall(callId); // } // } // function hasVotedCall( // uint256 srcChainID_, // address srcChainContractAddress_, // address dstChainContractAddress_, // bytes32 transactionHash_, // uint32 logIndex_, // bytes calldata payload // ) external view override returns(bool) { // bytes32 callId = Utils.getCallId( 11 // srcChainID_, // srcChainContractAddress_, // dstChainContractAddress_, // transactionHash_, // logIndex_, // payload // ); // return votes[callId][_msgSender()]; // } // function isCallProcessed( // uint256 srcChainID_, // address srcChainContractAddress_, // address dstChainContractAddress_, // bytes32 transactionHash_, // uint32 logIndex_, // bytes calldata payload // ) external view override returns(bool) { // return bridge.isCallProcessed(srcChainID_, srcChainContractAddress_, dstChainContractAddress_, transactionHash_, logIndex_, payload); // } bridge/contracts/contracts/Bridge.sol#L114-L154 // function acceptCall( // uint256 srcChainID_, // address srcChainTokenAddress_, // address dstChainTokenAddress_, // bytes32 transactionHash_, // uint32 logIndex_, // bytes calldata payload // ) external override onlyFederation nonReentrant { // require(dstChainTokenAddress_ != address(0), \"Bridge: destination chain token address is null\"); // require(srcChainTokenAddress_ != address(0), \"Bridge: src chain token address is null\"); // require(transactionHash_ != bytes32(0), \"Bridge: Transaction is null\"); // require(srcChainTokenAddress_ != address(0), \"src token address is null\"); // bytes4 sig = // payload[0] | // (bytes4(payload[1]) >> 8) | // (bytes4(payload[2]) >> 16) | // (bytes4(payload[3]) >> 24); 12 // bytes32 callRegistryID = Utils.getCallRegistryId( // srcChainID_, // srcChainTokenAddress_, // dstChainTokenAddress_, // sig // ); // require(tokenRegistry.callRegistry(callRegistryID), \"Call Not Registered\"); // bytes32 callId = Utils.getCallId( // srcChainID_, // srcChainTokenAddress_, // dstChainTokenAddress_, // transactionHash_, // logIndex_, // payload // ); // require(processed[callId] == 0, \"Bridge: Already processed\"); // processed[callId] = block.number; // // call the function // (bool success, ) = dstChainTokenAddress_.call(payload); // require(success, \"call fail\"); // } bridge/contracts/libraries/Utils.sol#L6-L18 // function getCallRegistryId( // uint256 alienChainId_, // address alienChainContractAddr_, // address localChainContractAddr_, // bytes4 callSig_ // ) internal pure returns(bytes32) { // return keccak256(abi.encodePacked( // alienChainId_, // alienChainContractAddr_, // localChainContractAddr_, // callSig_ // )); // } 13 bridge/contracts/libraries/Utils.sol#L50-L67 // function getCallId( // uint256 srcChainID_, // address srcChainTokenAddress_, // address dstChainTokenAddress_, // bytes32 transactionHash_, // uint32 logIndex_, // bytes calldata payload // ) internal pure returns (bytes32) { // return keccak256(abi.encodePacked( // \"Call\", // srcChainID_, // srcChainTokenAddress_, // dstChainTokenAddress_, // transactionHash_, // logIndex_, // payload // )); // }",
        "labels": [
            "SlowMist",
            "Flurry Bridge",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Redundant Code Usage",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm_Phase5_en-us.pdf",
        "body": "In the Vault contract of ENFv3/ENF_lowrisk_farm/ENF_lowrisk_ETH_farm, the user will rst calculate the share when performing the withdraw operation. But it is calculated in the same way as the convertToShares function, so it is not necessary to use duplicate code for the calculation without using the convertToShares function. ",
        "labels": [
            "SlowMist",
            "Earning.Farm_Phase5",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Potential Precision Calculation Issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm_Phase5_en-us.pdf",
        "body": "In the Vault contract of ENFv3/ENF_lowrisk_farm/ENF_lowrisk_ETH_farm, users can burn shares through the redeem function to get back staked assets. It uses (shares * assetsPerShare()) / 1e24 to calculate the number of assets corresponding to the share, and the assetsPerShare function will multiply (assetDecimal * 1e18) when performing calculations. If assetDecimal is not equal to 6, dividing 1e24 when performing assets calculation will cause the decimal of the result to deviate. ",
        "labels": [
            "SlowMist",
            "Earning.Farm_Phase5",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Business logic aws in reward distribution",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm_Phase5_en-us.pdf",
        "body": "In the Vault contract of ENF_lowrisk_farm/ENF_lowrisk_ETH_farm, users can obtain shares through deposits, and receive harvest dividends according to the amount of shares held. The key to reward calculation is the accRewardPerTokens and prevBalace parameters. The owner role will increase the accRewardPerTokens parameter every time the harvest operation is performed, and prevBalace represents the user's share balance before reward settlement. But there will be a way to collect rewards by front-run deposits to improve the eciency of capital utilization: When the owner role performs the harvest operation, the user deposits at a higher gas fee. At this point the accRewardPerShares of the protocol has not been updated, and the user will get a portion of the shares. Then the owner performs the harvest operation, and the accRewardPerShares of the protocol will increase. Finally the user makes withdrawal and gets reward. Malicious users can use this method to obtain rewards in the blocks before and after the harvest operation, or even in the same block, without worrying about the problem of liquidity being locked in the protocol, which improves the utilization rate of funds. ",
        "labels": [
            "SlowMist",
            "Earning.Farm_Phase5",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Token Transfer Missing Rewards Update",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm_Phase5_en-us.pdf",
        "body": "In the Vault contract of ENF_lowrisk_farm/ENF_lowrisk_ETH_farm, the _updateUserData function is used to update the user's reward, but it is not updated when the user's share is transferred. This will result in accounting errors during share token transfers. Users can steal rewards by continuously transferring share tokens to new addresses. ",
        "labels": [
            "SlowMist",
            "Earning.Farm_Phase5",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Issue with checking on fromToken",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm_Phase5_en-us.pdf",
        "body": "In the vault contract of ENF_lowrisk_farm/ENF_lowrisk_ETH_farm, the _swap function is used to exchange reward tokens for the specied toToken. It will check whether fromToken is WETH, if the check is true, it will be exchanged through the swapExactETHInput function, if the check is false, it will be exchanged through swapExactTokenInput. However, when fromToken is address(0), the token exchange will also be performed through the swapExactTokenInput function, which may cause the _swap function to fail to perform as expected. ",
        "labels": [
            "SlowMist",
            "Earning.Farm_Phase5",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Incorrect reward receiving address",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm_Phase5_en-us.pdf",
        "body": "In the Vault contract of ENF_lowrisk_farm/ENF_lowrisk_ETH_farm, users can claim rewards through the claim function and specify the receiving address of the rewards. When toAsset is false, the protocol will issue the reward directly to the user, but the destination address of the reward is not the receiver address specied by the user but msg.sender. This is not as expected. ",
        "labels": [
            "SlowMist",
            "Earning.Farm_Phase5",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Direct distribution of rewards is not available",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm_Phase5_en-us.pdf",
        "body": "In the Vault contract of ENF_lowrisk_farm/ENF_lowrisk_ETH_farm, users can claim rewards through the claim function. When toAsset is false, the protocol will directly issue rewards to users. The safeTransferFrom function is used to transfer tokens when issuing rewards, but the contract has not been approved before. This will cause the contract to be unable to successfully execute the safeTransferFrom operation due to insucient allowances, and ultimately result in failure to issue rewards. ",
        "labels": [
            "SlowMist",
            "Earning.Farm_Phase5",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of price manipulation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm_Phase5_en-us.pdf",
        "body": "In the stETH contract of ENF_lowrisk_ETH_farm, the slippage check of SS depends on the virtual price (get_virtual_price) of Curve Pool, which will be aected by the reentrancy vulnerability of ETH/stETH Pool (please check to Ref[1][2]). Failure to check for slippage will result in malicious theft of funds from the strategy. Ref: [1] https://chainsecurity.com/curve-lp-oracle-manipulation-post-mortem/ [2] https://chainsecurity.com/heartbreaks-curve-lp-oracles/",
        "labels": [
            "SlowMist",
            "Earning.Farm_Phase5",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "4.2.1.1 __Guard_init function was not call when initialize",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Hot Cross BSC Bridge V1.0.1_en-us.pdf",
        "body": "ForeignProcessor contract and HomeRequest contract are inherit the Guard contract but dost not call the __Gurad_init function function __ForeignProcessor_init( IERC20 token, ValidatorRegistry validatorRegistry_ ) internal initializer { //SlowMist// Missing call of __Guard_init function require( address(token) != address(0) && Misc.isContract(address(token)), \"ForeignProcessor:Invalid erc20 address provided\" 10 ); require( address(validatorRegistry_) != address(0) && Misc.isContract(address(validatorRegistry_)), \"ForeignProcessor:Invalid validator registry address\" ); erc20 = token; validatorRegistry = validatorRegistry_; } function __HomeRequest_init( BEP20 token, ValidatorRegistry validatorRegistry_ ) internal initializer { //SlowMist// Missing call of __Guard_init function require( address(token) != address(0) && Misc.isContract(address(token)), \"HomeRequest:Invalid BEP20 address\" ); require( address(validatorRegistry_) != address(0) && Misc.isContract(address(validatorRegistry_)), \"HomeRequest:Invalid validator registry address\" ); bep20 = token; validatorRegistry = validatorRegistry_; } Fix status: fixed. 11 5.",
        "labels": [
            "SlowMist",
            "Hot Cross BSC Bridge V1.0.1",
            "Severity: Informational"
        ]
    },
    {
        "title": "Access control issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - CheersUp_alpha8_en-us.pdf",
        "body": "The Owner role has the right to call the giveaway function to airdrop any number of blind boxes to any address at any time. function giveaway(address address_, uint64 numberOfTokens_) external onlyOwner nonReentrant { require(address_ != address(0), \"zero address\"); require(numberOfTokens_ > 0, \"invalid number of tokens\"); require(totalMinted() + numberOfTokens_ <= MAX_TOKEN, \"max supply exceeded\"); _safeMint(address_, numberOfTokens_); } The Owner role has the right to modify the cucpContractAddress contract address through the setCUCPContractAddress function, and unauthorized modication will result in the user's blind box being unable to be opened or arbitrarily modifying the blind box. function setCUCPContractAddress(address address_) public onlyOwner { cucpContractAddress = address_; } The Owner role has the right to modify the price of the blind box purchased by the user through the setWhitelistSaleCong function and the setPublicSaleCong function at any time. If the price of the blind box is modied after the sale starts, the user's transaction will fail. function setWhitelistSaleConfig(WhitelistSaleConfig calldata config_) external onlyOwner { require(config_.price > 0, \"sale price must greater than zero\"); whitelistSaleConfig = config_; } 9 function setPublicSaleConfig(PublicSaleConfig calldata config_) external onlyOwner { require(config_.price > 0, \"sale price must greater than zero\"); publicSaleConfig = config_; } The Owner has the right to modify the revealCong parameter through the setRevealCong function, which includes the address of the contract that opens the blind box, and the time and closing time of the blind box sale. function setRevealConfig(RevealConfig calldata config_) external onlyOwner { revealConfig = config_; }",
        "labels": [
            "SlowMist",
            "CheersUp_alpha8",
            "Type: Authority Control Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Random number problem",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - CheersUp_alpha8_en-us.pdf",
        "body": "The tokenId in the contract is related to the properties of the NFT. The tokenId is randomly generated through the random number on the chain, which will cause the random number to be predicted. function mint(address address_, uint256 cucpTokenId_) public returns(uint256) { require(_msgSender() == cucpContractAddress, \"not authorized\"); 10 require(_numberMinted + 1 <= MAX_TOKEN, \"mint would exceed max supply\"); uint256 tokenId = randomToken(address_); _safeMint(address_, tokenId); unchecked { _numberMinted += 1; } emit CheersUpRevealed(cucpTokenId_, tokenId); return tokenId; } function getRandomTokenId() internal returns (uint256) { unchecked { uint256 remain = MAX_TOKEN - _numberMinted; uint256 pos = unsafeRandom() % remain; uint256 val = _randIndices[pos] == 0 ? pos : _randIndices[pos]; _randIndices[pos] = _randIndices[remain - 1] == 0 ? remain - 1 : _randIndices[remain - 1]; return val; } } /** * @notice unsafeRandom is used to generate a random number by on-chain randomness. * Please note that on-chain random is potentially manipulated by miners, and most scenarios suggest using VRF. * @return randomly generated number. */ function unsafeRandom() internal view returns (uint256) { unchecked { return uint256(keccak256(abi.encodePacked( blockhash(block.number-1), block.difficulty, block.timestamp, _numberMinted, tx.origin ))); } }",
        "labels": [
            "SlowMist",
            "CheersUp_alpha8",
            "Type: Others",
            "Severity: Low"
        ]
    },
    {
        "title": "4.3.1.1 Risk of Oracle Manipulation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Shield_en-us.pdf",
        "body": "In DDSContracts, the price is obtained from Uniswap's getAmountsIn through the getPriceByWBTCDAI function, but this interface obtains the real-time price of the WBTC/DAI pool, and there is a risk of malicious manipulation. 6 Fix suggestion: It is recommended to use Uniswap's delayed price feed oracle for acquisition. ",
        "labels": [
            "SlowMist",
            "Shield",
            "Severity: Critical"
        ]
    },
    {
        "title": "4.3.1.2 Price acquisition issue when opening and closing positions",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Shield_en-us.pdf",
        "body": "In the DDSContracts contract, the price used when opening and closing a position is passed in from the outside, which will cause the user to pass in any price when opening and closing a position. After communicating with the project party, this is the test code, and the oracle will be used to feed the price during the formal deployment. Fix suggestion: It is recommended to use Uniswap's delayed price feed oracle for acquisition. ",
        "labels": [
            "SlowMist",
            "Shield",
            "Severity: Critical"
        ]
    },
    {
        "title": "4.3.2.1 The available funds were not processed when the riskControl",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Shield_en-us.pdf",
        "body": "closed the position In the Pool contract, when riskClose is triggered when the risk control liquidation is triggered, if the margin is insufficient and the pool order transfer fails, risk funds will be used to make up for the insufficient part, and all available funds of the user will be deducted. However, the user's available funds are not actually set to 0. Fix suggestion: It is recommended that the available funds should be emptied after the transfer of insurance funds. ",
        "labels": [
            "SlowMist",
            "Shield",
            "Severity: High"
        ]
    },
    {
        "title": "4.3.3.1 Insecure random number",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Shield_en-us.pdf",
        "body": "In the Pool contract, the getMatchLp2Object function uses block difficulty and block time now as the random number seed to participate in the calculation of random numbers. But block difficulty and time can be predicted or manipulated. Fix suggestion: It is recommended to use the random number provided by chainlink that cannot be manipulated. ",
        "labels": [
            "SlowMist",
            "Shield",
            "Severity: Low"
        ]
    },
    {
        "title": "4.3.4.1 Event missing",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Shield_en-us.pdf",
        "body": "In the DDSContracts contract, the owner can set the key parameters of the contract through the setExchageAddress, setPoolTokenAddr, setPrivatePool, setPublicPool, setFormular, and setrepayFudAddr functions, but no event recording is performed. Fix suggestion: In order to facilitate follow-up records and community viewing, it is recommended to record events for sensitive parameter modifications. ",
        "labels": [
            "SlowMist",
            "Shield",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.3.4.2 Does not follow the `Checks-effects-interactions` model",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Shield_en-us.pdf",
        "body": "In Contracts and Pool2 contracts, when deposit and provide functions are used to recharge, the state is changed first, and then the corresponding tokens are transferred to the contract. Fix suggestion: It is recommended to follow the Checks-effects-interactions model, first transfer the corresponding tokens and then change the state. 10 ",
        "labels": [
            "SlowMist",
            "Shield",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.3.4.3 Redundant code",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Shield_en-us.pdf",
        "body": "Provide price feed interfaces such as updateImpliedVolrate and updatePriceByOwner in the DDSFormular contract to update the price. However, these interfaces are not used by the Contracts contract, and these price-feeding interfaces have no permission control and can be called by any user. 11 Fix suggestion: If this interface is a test interface, it is recommended to remove it during formal deployment. If it will use the suggestions in subsequent iterations for permission control. ",
        "labels": [
            "SlowMist",
            "Shield",
            "Severity: Informational"
        ]
    },
    {
        "title": "Low-level call issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - CFFv2_en-us.pdf",
        "body": "In the CRVExchangeV2 contract, the handleExtraToken function is used to perform the token transfer operation after the token swap. Low-level calls are used when transferring native tokens, but the amount of gas usage is not limited, which may lead to unknown security risks. ",
        "labels": [
            "SlowMist",
            "CFFv2",
            "Type: Others",
            "Severity: Low"
        ]
    },
    {
        "title": "Contract variable usage issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - CFFv2_en-us.pdf",
        "body": "In the IWbtcPoolBase contract, when the Controller role calls the deposit function, the deposit_wbtc_amount parameter will increase, but when the Controller role calls the withdraw function, the deposit_wbtc_amount parameter does not decrease accordingly. And the withdraw_wbtc_amount parameter in the contract is not used. 16 The deposit_eth_amount and withdraw_eth_amount parameters in the IETHPoolBase contract are the same. The deposit_usdc_amount and withdraw_usdc_amount parameters in the IUSDCPoolBase contract are the same. ",
        "labels": [
            "SlowMist",
            "CFFv2",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing event record",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - CFFv2_en-us.pdf",
        "body": "In the IWbtcPoolBase contract, the owner can modify the controller and vault addresses through the setController function, but no event recording is performed. ",
        "labels": [
            "SlowMist",
            "CFFv2",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Logical redundancy issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - CFFv2_en-us.pdf",
        "body": "In the AavePool contract, the withdraw_from_curve function will rst authorize the lp_token_addr token to the pool_deposit contract and then call the remove_liquidity_one_coin function of the pool_deposit contract to remove liquidity. However, since the minter role of the lp_token_addr contract is the pool_deposit contract, there is no need to perform an approve operation. ",
        "labels": [
            "SlowMist",
            "CFFv2",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Reentrancy risk 20",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - CFFv2_en-us.pdf",
        "body": "In the CFVaultV2 contract, the user can withdraw assets through the withdraw function, but in the withdraw function, it will rst transfer the assets to the user and then destroy the user's credentials through the destroyTokens function. If the transfer is native tokens, this will lead to a risk of reentrancy. ",
        "labels": [
            "SlowMist",
            "CFFv2",
            "Type: Reentrancy Vulnerability",
            "Severity: Critical"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - CFFv2_en-us.pdf",
        "body": "In the IWbtcPoolBase, IETHPoolBase and IUSDCPoolBase contracts, the owner can call any data through the callWithData function. Since these strategies contracts indirectly keep the user's assets, any data call will cause the risk of excessive owner authority. ",
        "labels": [
            "SlowMist",
            "CFFv2",
            "Type: Authority Control Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - TaprootChain - BTCLayer2Bridge_en-us.pdf",
        "body": "1.In the BTCLayer2Bridge contract, the superAdmin role is initialized in the initialize function and can be modied in the setSuperAdminAddress function. The superAdmin can also set the normalAdmin role through the setNormalAdminAddress function. ",
        "labels": [
            "SlowMist",
            "TaprootChain - BTCLayer2Bridge",
            "Type: Authority Control Vulnerability Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Receive can lock users native tokens",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - TaprootChain - BTCLayer2Bridge_en-us.pdf",
        "body": "There is a receive function in the BTCLayer2Bridge contract so that the contracts can receive native tokens. However, the receive function can lock users native tokens when users transfer the native token in these contracts by mistake. And the payable modier can help these functions which need to call with the native tokens. ",
        "labels": [
            "SlowMist",
            "TaprootChain - BTCLayer2Bridge",
            "Type: Others",
            "Severity: Low"
        ]
    },
    {
        "title": "Parameter _symbol is not case checked",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - TaprootChain - BTCLayer2Bridge_en-us.pdf",
        "body": "The _symbol eld of ERC20 tokens and ERC721 tokens on the Ethereum chain is case-sensitive, but for BRC20 Tick is not case-sensitive. In the BTCLayer2Bridge contract, the addERC20TokenWrapped function and the addERC721TokenWrapped function do not standardize the case format of the _symbol parameter passed in. ",
        "labels": [
            "SlowMist",
            "TaprootChain - BTCLayer2Bridge",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Delete the address without popping up the list",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - TaprootChain - BTCLayer2Bridge_en-us.pdf",
        "body": "In the addUnlockTokenAdminAddress function, the superAdmin and normalAdmin roles can add user address into the unlockTokenAdminAddressList and set the unlockTokenAdminAddressSupported to true. But in the delUnlockTokenAdminAddress function, the superAdmin and normalAdmin roles remove the unlockTokenAdminAddress just by setting the unlockTokenAdminAddressSupported to false without popping up from the unlockTokenAdminAddressList . Once called the delUnlockTokenAdminAddress function deletes the address, the superAdmin and normalAdmin roles can call the addUnlockTokenAdminAddress function to add the same address added before into the unlockTokenAdminAddressList and the length of the unlockTokenAdminAddressList will increase. ",
        "labels": [
            "SlowMist",
            "TaprootChain - BTCLayer2Bridge",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "SuperAdmin Transfer Recommendations",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - TaprootChain - BTCLayer2Bridge_en-us.pdf",
        "body": "In the BTCLayer2Bridge contract, superAdmin directly overwrites the previous address with the new address during transfer. If superAdmin calls the setSuperAdminAddress function with the wrong address when the operation is wrong, this will result in the loss of the superAdmin role permissions. ",
        "labels": [
            "SlowMist",
            "TaprootChain - BTCLayer2Bridge",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Low-level call reminder",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - TaprootChain - BTCLayer2Bridge_en-us.pdf",
        "body": "In the BTCLayer2Bridge contract, the burnERC20Token, batchBurnERC721Token, lockNativeToken, and unlockNativeToken use low-level calls to transfer native tokens to the feeAddress and to address from the unlockNativeToken function. But do not limit the amount of gas used to transfer native tokens to the user. ",
        "labels": [
            "SlowMist",
            "TaprootChain - BTCLayer2Bridge",
            "Type: Reentrancy Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Preemptive Initialization",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - TaprootChain - BTCLayer2Bridge_en-us.pdf",
        "body": "By calling the initialize and deploy functions to initialize the contracts, there is a potential issue that malicious attackers preemptively call the initialize function to initialize. ",
        "labels": [
            "SlowMist",
            "TaprootChain - BTCLayer2Bridge",
            "Type: Race Conditions Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Dev address setting enhancement suggestions",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - TaprootChain - BTCLayer2Bridge_en-us.pdf",
        "body": "In the contract, the superAdmin role can set the feeAddress to receive the fee. If the addfeeAddress is an EOA address, in a scenario where the private keys are leaked, the teams revenue will be stolen. ",
        "labels": [
            "SlowMist",
            "TaprootChain - BTCLayer2Bridge",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "External call reminder",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - TaprootChain - BTCLayer2Bridge_en-us.pdf",
        "body": "In the contract, the core functions mintERC20Token , burnERC20Token , batchMintERC721Token , batchBurnERC721Token , unlockNativeToken , and lockNativeToken , which are mainly used for fund interaction by unlockTokenAdminAddressSupported users, are all completed by external calls to bridgeERC20Address and bridgeERC721Address. The current contract also does complete verication of the incoming parameters txHash , _symbol , _baseURI , destBtcAddr , inscriptionNumbers , inscriptionIds , etc., and these verications may be completed by a centralized system or these external call contracts. This audit does not include centralized systems or external call contracts. Users need to pay attention to these external risks when calling these functions.",
        "labels": [
            "SlowMist",
            "TaprootChain - BTCLayer2Bridge",
            "Type: Unsafe External Call Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Excessive Authority Issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - wault.finance(WSwap)_en-us.pdf",
        "body": "The owner can set the value of wexPerBlock arbitrarily, which will affect the profit of wexReward, and there is no limit on the value range of wexPerBlock, and there is a issue of excessive authority. https://bscscan.com/address/0x22fB2663C7ca71Adc2cc99481C77Aaf21E152e2D function setWexPerBlock(uint256 _wexPerBlock) public onlyOwner { require(_wexPerBlock > 0, \"!wexPerBlock-0\"); wexPerBlock = _wexPerBlock; } Owner can add pool, can set the allocPoint of pool, there is a issue of selfish mining. function add( uint256 _allocPoint, IERC20 _lpToken, bool _withUpdate ) public onlyOwner { if (_withUpdate) { massUpdatePools(); } uint256 lastRewardBlock = block.number > startBlock ? block.number : startBlock; totalAllocPoint = totalAllocPoint.add(_allocPoint); poolInfo.push( PoolInfo({ lpToken: _lpToken, allocPoint: _allocPoint, lastRewardBlock: lastRewardBlock, accWexPerShare: 0 }) ); 12 function set( uint256 _pid, uint256 _allocPoint, bool _withUpdate ) public onlyOwner { if (_withUpdate) { massUpdatePools(); } totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add( _allocPoint ); poolInfo[_pid].allocPoint = _allocPoint; }",
        "labels": [
            "SlowMist",
            "wault.finance(WSwap)",
            "Type: Others",
            "Severity: Low"
        ]
    },
    {
        "title": "Ignoring the Return Value",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist_Audit_Report_StakeStone_SymbioticDepositWBETHStrategy_en-us.pdf",
        "body": "In the SymbioticDepositWBETHStrategy contract, the owner can extract the claimable ETH by calling the claimPendingAssets function. This function will call the claimWithdraw function of the UnwrapTokenV1ETH contract to claim the corresponding ETH by passing in a specic index. The claimWithDraw function returns a value (_ethAmount) after each call to represent the number of ETH claimed. Code Location: contracts/strategies/SymbioticDepositWBETHStrategy.sol#L176 function claimPendingAssets(uint256 _index) external onlyOwner { IUnwrapTokenV1ETH(unwrapTokenV1ETHAddr).claimWithdraw(_index); }",
        "labels": [
            "SlowMist",
            "SlowMist_Audit_Report_StakeStone_SymbioticDepositWBETHStrategy",
            "Type: Others",
            "Severity: Information"
        ]
    },
    {
        "title": "Risk of unintended claim operations",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - pufETH_en-us.pdf",
        "body": "In the PuerVault contract, Users can collect ETH tokens to be claimed in the lido withdrawal process by calling the claimWithdrawalsFromLido function. The normal expectation of this function is that the incoming requestIds parameter should be created by the initiateETHWithdrawalsFromLido function, and only then the lidoLockedETH variable will be deducted correctly. However, a malicious user can directly call requestWithdrawals function in lido to generate requestIds, and then call claimWithdrawalsFromLido function, lidoLockedETH will be deducted additionally, resulting in a normal claim operation failing due to insucient lidoLockedETH. The following scenarios can be used as a reference: 1. The contract has a total of 10 ETH total deposited in Lido, at which point a normal user calls the initiateETHWithdrawalsFromLido function to submit a request to withdraw 10 ETH($.lidoLockedETH = 10). 2. A malicious user calls requestWithdrawals function directly on Lido to generate a withdrawal request to withdraw 1 ETH(need to specify WithdrawalRequest._owner as puerVault). 3. The malicious user calls the claimWithdrawalsFromLido function and passes in the requestIds generated in step 2, the value of $.lidoLockedETH is equal to 9. 4. A normal user calls the claimWithdrawalsFromLido function and passes in the requestIds generated in the rst step, at which point the amount of ETH to be fetched is 10, while the value of $.lidoLockedETH is 9, which causes $.lidoLockedETH -= msg.value to overow and the entire transaction fails. 5. So the nal result is that 10 ETH cannot be successfully withdrawn through the puerVault contract. And this security risk also exists when withdrawing ETH from EigenLayer(Specify withdrawer as the puerVault address to achieve the same eect). ",
        "labels": [
            "SlowMist",
            "pufETH",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Authority transfer enhancement",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - pufETH_en-us.pdf",
        "body": "The pauserMultisig role does not adopt the pending and access processes. If the pauserMultisig is incorrectly set, the owner permission will be lost. ",
        "labels": [
            "SlowMist",
            "pufETH",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Gas optimization",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Laqira NFT marketplace_en-us.pdf",
        "body": "Using assert will consume the remaining gas when the transaction fails to execute. ",
        "labels": [
            "SlowMist",
            "Laqira NFT marketplace",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Unused return",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Laqira NFT marketplace_en-us.pdf",
        "body": "There is a return value in the setRoyalties function in the RoyaltiesProvider contract, and the function is called here without checking its return value. Laqira-Collectibles-and-NFT-Marketplace/contracts/LaqiraNFT.sol #L58-L76 function mint(string memory _tokenURI, address[] memory royaltyOwners, uint96[] memory values) public virtual payable { uint256 transferredAmount = msg.value; require(transferredAmount >= mintingFee, 'Insufficient paid amount'); (bool success, ) = feeAddress.call{value: transferredAmount}(new bytes(0)); 14 require(success, 'Transfer failed'); _tokenIds.increment(); uint256 newTokenId = _tokenIds.current(); pendingRequests.push(newTokenId); _pendingIds[newTokenId].owner = _msgSender(); _pendingIds[newTokenId].tokenURI = _tokenURI; _userPendingIds[_msgSender()].push(newTokenId); IRoyaltiesProvider(royaltiesProviderAddress).setRoyalties(newTokenId, royaltyOwners, values); }",
        "labels": [
            "SlowMist",
            "Laqira NFT marketplace",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing event record",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Laqira NFT marketplace_en-us.pdf",
        "body": "Modifying sensitive parameters in the contract does not log an event. Laqira-Collectibles-and-NFT-Marketplace/contracts/LaqiraNFT.sol #L123-L133 function setMintingFeeAmount(uint256 _amount) public virtual onlyOwner { mintingFee = _amount; } function setAsOperator(address _operator) public virtual onlyOwner { operators[_operator] = true; } function removeOperator(address _operator) public virtual onlyOwner { operators[_operator] = false; } 15 ",
        "labels": [
            "SlowMist",
            "Laqira NFT marketplace",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing zero address validation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Laqira NFT marketplace_en-us.pdf",
        "body": "Missing zero address validation when setting the address in the function. ",
        "labels": [
            "SlowMist",
            "Laqira NFT marketplace",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Redundant code",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - IHO V1.0.0_en-us.pdf",
        "body": "Ether is not accepted by default, which is a redundant code. cross-send/contracts/CrossSend.sol#L41-L47 initial-hotcross-oering/contracts/BaseIHO.sol#L67-L73 fallback () external payable { revert(\"cannot directly accept currency transfers\"); } receive () external payable { revert(\"cannot directly receive currency transfers\"); 15 }",
        "labels": [
            "SlowMist",
            "IHO V1.0.0",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Gas optimization",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - IHO V1.0.0_en-us.pdf",
        "body": "If one of the batch transfers fails, the transaction that was previously transferred normally will be reverted, but Gas has been consumed. It is a gas optimization issue here. cross-send/contracts/CrossSend.sol#L175-L210 function sendToken( IERC20 token, address[] memory recipients, uint256[] memory amounts ) private returns(uint256) { uint256 total = 0; for (uint256 i = 0; i < recipients.length ; i++) { require(_msgSender() != recipients[i], \"sender != recipient\"); token.safeTransferFrom(_msgSender(), recipients[i], amounts[i]); total += amounts[i]; } return total; } function sendNative( address[] memory recipients, uint256[] memory amounts ) private returns(uint256) { uint256 total = 0; 16 for (uint256 i = 0; i < recipients.length ; i++) { total += amounts[i]; (bool success, ) = payable(recipients[i]).call{value: amounts[i]}(\"\"); require(success, \"native transfer failed\"); } return total; }",
        "labels": [
            "SlowMist",
            "IHO V1.0.0",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of allowance amount abuse",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - IHO V1.0.0_en-us.pdf",
        "body": "There have an allowance amount in the contract, but the distributeTokenFee function does not limit the caller, and there is an issue of being called arbitrarily, but it can only transfer the balance of the sender to the feeCollector. cross-send/contracts/fee-managers/RecipientCountFee.sol#L65-L83 function distributeTokenFee( uint256 txRecipientCount, uint256, uint256, uint256, uint256, address sender ) public override { uint256 payableFee = txRecipientCount * tokenFeePerRecipient; 17 if(payableFee < minTokenFee) { payableFee = minTokenFee; } else if (payableFee > maxTokenFee) { payableFee = maxTokenFee; } token.safeTransferFrom(sender, feeCollector, payableFee); }",
        "labels": [
            "SlowMist",
            "IHO V1.0.0",
            "Type: Authority Control Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Price manipulation issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - IHO V1.0.0_en-us.pdf",
        "body": "The IOUPrice is calculated using totalFarmingTokenBalance. Attackers can control totalFarmingTokenBalance to manipulate IOUPrice. The current code does not nd the location where IOUPrice is used. Referencehttps://slowmist.medium.com/cream-hacked-analysis-us-130-million-hacked-95c9410320ca cross-yield/contracts/core/CrossYield.sol#L95-L101 function IOUPrice() public view returns (uint256) { uint256 IOUSupply = totalSupply(); return IOUSupply == 0 ? 1e18 : (totalFarmingTokenBalance() * 1e18) / IOUSupply; } 18 cross-yield/contracts/core/CrossYield.sol#L65-L67 function totalFarmingTokenBalance() public view returns (uint256) { return farmingToken().balanceOf(address(this)) + strategy.balanceOf(); }",
        "labels": [
            "SlowMist",
            "IHO V1.0.0",
            "Type: Others",
            "Severity: Medium"
        ]
    },
    {
        "title": "Sandwich attacks issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - IHO V1.0.0_en-us.pdf",
        "body": "There is no slippage check during swap, and there is a risk of sandwich attack. IPancakeRouter02(pcsRouter).swapExactTokensForTokens(cakeBalance, 0,cakeToBaseRoute, address(this), block.timestamp); IPancakeRouter02(pcsRouter) .swapExactTokensForTokens(toSwap, 0, route, address(this), block.timestamp); Reference https://medium.com/coinmonks/demystify-the-dark-forest-on-ethereum-sandwich-attacks-5a3aec9fa33e cross-yield/contracts/libs/OptimalSwap.sol#L14-L63 function prepareLiquidity( address cake, address[2] memory lpTokens, 19 address wbnb, address busd, address farmingToken, address pcsRouter, uint256 fee ) external { uint256 cakeBalance = IERC20(cake).balanceOf(address(this)); bool isCakeInLp = lpTokens[0] == cake || lpTokens[1] == cake; bool isWbnbBased = lpTokens[0] == wbnb || lpTokens[1] == wbnb; address baseToken = isWbnbBased ? wbnb : busd; // if cake is not part of the lp token, swap all cake for the base token if (!isCakeInLp) { address[] memory cakeToBaseRoute = new address[](2); cakeToBaseRoute[0] = cake; cakeToBaseRoute[1] = baseToken; IPancakeRouter02(pcsRouter) .swapExactTokensForTokens(cakeBalance, 0, cakeToBaseRoute, address(this), block.timestamp); } (uint256 reserve0, uint256 reserve1,) = IPancakePair(farmingToken).getReserves(); address[] memory route = new address[](2); uint256 lp0Bal = IERC20(lpTokens[0]).balanceOf(address(this)); uint256 lp1Bal = IERC20(lpTokens[1]).balanceOf(address(this)); uint256 toSwap; // The possible cases here are: // - Cake was not part of the LP token, so we swap for baseToken which could either be lpToken0 or lpToken // - Cake was part of the LP token, so it can either be lpTokens[0] or lpTokens[1] // So, depending on which token we have the highest balance for, we swap for the other one. if (lp0Bal > lp1Bal) { toSwap = SwapAmount.getSwapAmount(lp0Bal, reserve0, fee); route[0] = lpTokens[0]; route[1] = lpTokens[1]; } else { toSwap = SwapAmount.getSwapAmount(lp1Bal, reserve1, fee); route[0] = lpTokens[1]; route[1] = lpTokens[0]; 20 } // Perform the swap IPancakeRouter02(pcsRouter) .swapExactTokensForTokens(toSwap, 0, route, address(this), block.timestamp); } IPancakeRouter02(pcsRouter).swapExactTokensForTokens(toWbnb, 0, cakeToWbnbRoute, address(this), block.timestamp); cross-yield/contracts/strategies/StrategyCake.sol#L131 function collectFees() internal { // a percentant of the cake we get from the masterchef will be used to buy BNB and transfer to this address // this is the total fees that will be shared amongst the protocol, stategy dev and the harvester uint256 toWbnb = feeManager.calculateTotalFee(IERC20(farmingToken).balanceOf(address(this))); IPancakeRouter02(pcsRouter).swapExactTokensForTokens(toWbnb, 0, cakeToWbnbRoute, address(this), block.timestamp); uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this)); // distribute hervester fee uint256 harvesterFeeAmount = feeManager.calculateHarvestFee(wbnbBal); // collectFees is called indirectly from the CrossYield contract via the beforeDeposit hook. // This means that _msgSender() is the CrossYield contract and not the actuall EOA account // that send the transaction IERC20(wbnb).safeTransfer(tx.origin, harvesterFeeAmount); // distribute protocol fee uint256 protocolFeeAmount = feeManager.calculateProtocolFee(wbnbBal); // IERC20(wbnb).safeTransfer(protocolFeeRecipient, protocolFeeAmount); feeProcessor.process(protocolFeeAmount); // distribute strategy dev fee uint256 strategyDevFeeAmount = feeManager.calculateStrategyDevFee(wbnbBal); IERC20(wbnb).safeTransfer(feeManager.strategyDev(), strategyDevFeeAmount); emit FeeCollected( toWbnb, 21 harvesterFeeAmount, protocolFeeAmount, strategyDevFeeAmount, _msgSender() ); } cross-yield/contracts/strategies/StrategyCakeLP.sol#L174 function collectFees() internal { // a percentant of the cake we get from the masterchef will be used to buy BNB and transfer to this address // this is the total fees that will be shared amongst the protocol, stategy dev and the harvester uint256 toWbnb = feeManager.calculateTotalFee(IERC20(cake).balanceOf(address(this))); IPancakeRouter02(pcsRouter).swapExactTokensForTokens(toWbnb, 0, cakeToWbnbRoute, address(this), block.timestamp); uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this)); // distribute hervester fee uint256 harvesterFeeAmount = feeManager.calculateHarvestFee(wbnbBal); IERC20(wbnb).safeTransfer(_msgSender(), harvesterFeeAmount); // distribute protocol fee uint256 protocolFeeAmount = feeManager.calculateProtocolFee(wbnbBal); feeProcessor.process(protocolFeeAmount); // distribute strategy dev fee uint256 strategyDevFeeAmount = feeManager.calculateStrategyDevFee(wbnbBal); IERC20(wbnb).safeTransfer(feeManager.strategyDev(), strategyDevFeeAmount); emit FeeCollected( toWbnb, harvesterFeeAmount, protocolFeeAmount, strategyDevFeeAmount, _msgSender() ); } cross-yield/contracts/strategies/StrategyCake.sol 22 function harvest() public override whenNotPaused { // claim rewards IMasterChef(masterchef).leaveStaking(0); // because harvest can automatically be called after each user deposit // we might end up having multiple deposits in the same block and only one // would return rewards from masterchef so the rest will have 0 cake so // we don't need to waste gas to collect fees and call deposit uint256 farmingTokenBalance = balanceOfFarmingToken(); if(farmingTokenBalance > 0) { collectFees(); deposit(); emit HarvestTriggered(_msgSender(), farmingTokenBalance); } } cross-yield/contracts/strategies/StrategyCakeLP.sol#l137-L148 function harvest() external override whenNotPaused { // claim rewards IMasterChef(masterchef).deposit(poolId, 0); uint256 harvestedAmount = IERC20(cake).balanceOf(address(this)); collectFees(); addLiquidity(); deposit(); emit HarvestTriggered(_msgSender(), harvestedAmount); }",
        "labels": [
            "SlowMist",
            "IHO V1.0.0",
            "Type: Reordering Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Missing slippage check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - IHO V1.0.0_en-us.pdf",
        "body": "The addLiquidity function without slippage check, it doesn't have an impermanent loss check. cross-yield/contracts/strategies/StrategyCakeLP.sol#L218 function addLiquidity() internal { OptimalSwap.prepareLiquidity( cake, [lpToken0, lpToken1], wbnb, busd, farmingToken, pcsRouter, swapFee ); // add liquidity to AMM on PCS uint256 lp0Bal = IERC20(lpToken0).balanceOf(address(this)); uint256 lp1Bal = IERC20(lpToken1).balanceOf(address(this)); IPancakeRouter02(pcsRouter) .addLiquidity(lpToken0, lpToken1, lp0Bal, lp1Bal, 0, 0, address(this), block.timestamp); emit LiquidityAdded(lpToken0, lpToken1, lp0Bal, lp1Bal, _msgSender()); }",
        "labels": [
            "SlowMist",
            "IHO V1.0.0",
            "Type: Reordering Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Permission check Missing",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - IHO V1.0.0_en-us.pdf",
        "body": "There is no permission check for deposit function. The function is called by the CrossYieid contract. cross-yield/contracts/strategies/StrategyCakeLP.sol#L225-L231 function deposit() public override whenNotPaused { uint256 farmingTokenBalance = balanceOfFarmingToken(); if (farmingTokenBalance > 0) { IMasterChef(masterchef).deposit(poolId, farmingTokenBalance); } } cross-yield/contracts/strategies/StrategyCake.sol#L169-L175 function deposit() public override whenNotPaused { uint256 farmingTokenBalance = balanceOfFarmingToken(); if (farmingTokenBalance > 0) { IMasterChef(masterchef).enterStaking(farmingTokenBalance); } }",
        "labels": [
            "SlowMist",
            "IHO V1.0.0",
            "Type: Authority Control Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Excessive authority issue 25",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - IHO V1.0.0_en-us.pdf",
        "body": "Owner can modify the address of the strategy. The new strategy may have security risks if it is not audited, which will aect the user's funds. If the private key is leaked, it will aect the user's funds. cross-yield/contracts/core/CrossYield.sol#L224-L236 function upgradeStrategy() public onlyOwner { require(stratCandidate.strategy != address(0), \"No proposal exists\"); require(block.number > stratCandidate.proposedBlock + stratUpgradableAfter, \"Strategy cannot be replaced yet\"); emit NewStrategy(stratCandidate.strategy); strategy.retireStrategy(); strategy = IStrategy(stratCandidate.strategy); stratCandidate.strategy = address(0); stratCandidate.proposedBlock = 0; putFundsToWork(); } cross-yield/contracts/core/CrossYield.sol#L211-L220 function proposeStrategy(address _strategy) public onlyOwner { require(address(this) == IStrategy(_strategy).vault(), \"Invalid new strategy\"); stratCandidate = StrategyCandidate({ strategy: _strategy, proposedBlock: block.number }); emit NewStratCandidate(_strategy); }",
        "labels": [
            "SlowMist",
            "IHO V1.0.0",
            "Type: Authority Control Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Repeatable claims issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - IHO V1.0.0_en-us.pdf",
        "body": "After the claim, lottery.status is not set as claimed, and it is also necessary to check whether lotteryId has been claimed when the claim is executed. hotdrop/contracts/HotDrop.sol#L261-L274 function claim(uint256 lotteryId) external nonReentrant { Lottery storage lottery = lotteries[lotteryId]; require(lottery.status == Status.WinnerDrawn, \"winner not drawn\"); // if there is no winner transfer the total amount to the treasury if(tickets[lotteryId][lottery.winningNumber] == address(0)) { lottery.purchaseToken.safeTransfer(treasury, lottery.purchaseToken.balanceOf(address(this))); } else if(tickets[lotteryId][lottery.winningNumber] == _msgSender()) { // if the ticket is the winning ticket and belongs to the user then split the pot uint256 treasuryAmount = (lottery.totalRaised * lottery.treasuryFee) / FEE_BASE; lottery.purchaseToken.safeTransfer(treasury, treasuryAmount); lottery.purchaseToken.safeTransfer(_msgSender(), lottery.totalRaised - treasuryAmount); } }",
        "labels": [
            "SlowMist",
            "IHO V1.0.0",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Round plan security reminder",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - IHO V1.0.0_en-us.pdf",
        "body": "And the new round of lottery can only be opened when the last round of lottery is in WinnerDrawn, otherwise randomGenerator.latestLotteryId will be updated, which will cause the old lottery round to fail to execute drawWinner function due to this check. require(lotteryId == randomGenerator.latestLotteryId(), \"numbers not drawn\"); hotdrop/contracts/HotDrop.sol#L44-L256 function drawWinner(uint256 lotteryId) external nonReentrant { Lottery storage lottery = lotteries[lotteryId]; require(lottery.status == Status.Close, \"lottery still active\"); require(lotteryId == randomGenerator.latestLotteryId(), \"numbers not drawn\"); // get the winning number based on the randomResult generated by ChainLink's fallback uint256 winningNumber = randomGenerator.randomResult(); lottery.winningNumber = winningNumber; lottery.status = Status.WinnerDrawn; emit LotteryNumberDrawn(lotteryId, winningNumber); }",
        "labels": [
            "SlowMist",
            "IHO V1.0.0",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Deposit defect issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "In the EFVault contract, it is not restricted to call the deposit function only by the DepositApprover contract. If the user transfers funds to the EFVault contract by mistake, any user can call the deposit function to deposit for himself. 19 ",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Incorrect withdrawal amount check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "In the vault contract, users can withdraw funds through the withdraw function. It will check if the funds withdrawn by the user is less than the user's total deposit, but this will prevent the user from withdrawing all of their total deposit. ",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Risk of overburning shares",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "In the vault contract, users can burn their shares to withdraw funds through the withdraw function. However, when calculating the required burning share, it incorrectly divides the user's total deposit. This will cause the number of shares to be burned to be much larger than expected. ",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Small deposit issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "When a user makes a deposit, the vault contract will deposit the user's funds into the strategy pool and then mint the 21 corresponding share to the user. If the total deposit of the contract is very large at this time, when the user deposits a small amount of funds, the nal result of the division operation will be 0 when the amount is too small when withdrawing. Causes the problem that small assets cannot be withdrawn.",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "The deationary token issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "In the DepositApprover contract, the amount of the deposit is the amount passed in by the user. If the tokens supported by the protocol become deationary tokens in the future (for example, USDT enables the transfer fee function), this will cause the actual number of tokens received by the protocol to be inconsistent with the number of dedicated incoming tokens. The same is true for Controller and SS contracts. ",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of share manipulation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "When the user deposits in the agreement, the contract will mint the corresponding share to the user, and when the user withdraws, the corresponding share will be burned. The totalAssets function is used to participate in the calculation when calculating the share, and in the SS contract of the convex, the totalAssets are obtained through the calc_withdraw_one_coin function of the Curve Pool. However, the calc_withdraw_one_coin function is vulnerable to the balance in the Curve Pool, so malicious users can manipulate the calc_withdraw_one_coin function to aect the number of shares minted by the contract. ",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Missing event records 23",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "In the vault contract, the owner can modify the maxDeposit, maxWithdraw, controller and depositApprover parameters through the setMaxDeposit, setMaxWithdraw, setController and setDepositApprover functions respectively. But event logging is not used. In the Controller contract, the owner can modify the vault, apySort, treasury, exchange, withdrawFee, defaultDepositSS and isDefault parameters through the setVault, setAPYSort, setTreasury, setExchange, setWithdrawFee, setDefaultDepositSS and setDefaultOption functions. But event logging is not used. In the contracts under the exchanges folder, the owner can set the exchange contract address through the setExchange function. But event logging is not used. In the contracts under the subStrategies/convex folder, the owner can modify the controller, depositSlippage, pId, lpToken, curvePool, harvestGap, maxDeposit, rewardTokens parameters through the setController, setDepositSlippage, setWithdrawSlippage, setPoolId, setLPToken, setCurvePool, setHarvestGap, setMaxDeposit, addRewardToken and removeRewardToken functions. But event logging is not used. In the cusdc contract, the owner can modify the controller, depositSlippage, withdrawSlippage, harvestGap and maxDeposit parameters through the setController, setDepositSlippage, setWithdrawSlippage, setHarvestGap and setMaxDeposit functions. But event logging is not used. ",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "AllocPoint deposit issue 28",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "In the Controller contract, deposits are made according to the allocPoint of each SS, which calculates the number of tokens transferred to each SS through the following algorithm amountForSS = (_amount * subStrategies[i].allocPoint) / totalAllocPoint; However, due to the loss of precision in the division calculation, a small amount of funds cannot be transferred into SS. ",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "check withdrawal amount issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "After the Controller contract withdraws from SS, it will check whether withdrawAmt is greater than 0. But since the protocol will havest periodically, theoretically withdrawAmt should be greater than or equal to the _amount parameter passed in by the user. ",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Risks of fake routers",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "In the Controller contract, the owner role can compound interest through the harvest function. However, it is not checked whether the router list passed in by owner is as expected. If an unexpected router is passed in, it may lead to failure to harvest normally or loss of funds. ",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Loss of computational precision",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "In the vault contract, the convertToAssets function is used to convert shares to corresponding asset amounts. 31 However, it performs the calculation by performing the division operation rst and then the multiplication operation, which will result in loss of calculation accuracy. ",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Risks of strict equality checks",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "In Convex's SS contract, when the user makes a withdrawal, it is checked whether the LP balance of the current contract is strictly equal to the LP amount required by the user. If a malicious user intentionally transfers any amount of LP tokens to the current contract, this will cause the SS contract to become unusable. ",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Negative number check issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "In the Cusdc contract, the _totalAssets function is used to obtain the total collateralized assets. It is calculated by multiplying the number of nTokens held by the protocol by the price of nTokens and dividing the total supply of nTokens. The price of nToken is obtained through the getPresentValueUnderlyingDenominated function, but the return value of the getPresentValueUnderlyingDenominated function is int256, while the return value of the INusdc interface is dened as uint256. If it returns a negative number, it will overow. ",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "In the Controller contract, the owner can set allocation point of a sub strategy, register the substrategies to the controller contract and withdraw the assets from one SS and deposit to other SS. This will have an impact on the user's deposit and withdrawal operations. ",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Authority Control Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Code redundancy issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "In the vault contract, the convertToShares function is dened, but it is not actually used in the contract. ",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Invalid minimum output calculation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "In the SS contract, the calc_token_amount function will be used to calculate the minimum amount of LP tokens received during the deposit operation; the minimum amount of staking tokens received will be calculated through the calc_withdraw_one_coin function during the withdrawal operation. However, the calc_token_amount function and the calc_withdraw_one_coin function are easily aected by the last transaction of CurvePool, so they cannot play the role of slippage protection. Lusd and Tri contracts also have slippage issue, but the slippage check is annotated in the deposit function. ",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Risk of pid acquisition",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "In the Alusd contract, the getPID function user obtains the corresponding LP pool address in the ConvexBooster contract. It will return 0 if LpToken does not exist, but pid0 has a value in the ConvexBooster contract. So when getPID returns 0, it will be hard to tell if pid exists. 37 ",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Redundant approval issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "In the swapExactTokenInput function of the Exchange contract, it will rst transfer the tokens that need to be swapped from the controller contract to the router contract. But the swapExactTokenInput function approves the router contract again, which is unnecessary. ",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Incorrect storage of temporary variables",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "In the router contract, the removePath function is used to remove the swap path recorded in the contract. It will rst store the balancerBatchAssets variable through storage, then delete it, and then use this variable for event recording after deletion. ",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Compound interest slippage check issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "In the router contract, no slippage check is performed during the swap operation. If there are more funds with compound interest, there will be a risk of being attacked by sandwiches. ",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Lack of access control",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "The swap function in the UniswapV3 contract is not subject to permission control, which will allow any user to call it. ",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Authority Control Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Analyzing inaccuracies in reward calculation due to time span misalignment",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Lumiterra Community Contracts_en-us.pdf",
        "body": "contracts/UtilityStake.sol In the _calcClaimableAmount function, if di (the time elapsed since the last reward claim) exceeds timeoutClaimPeriod , then the result of the modulo operation diff % timeoutClaimPeriod , which yields claimD , will be less than the actual time span that should be considered. This leads to an inaccurate calculation of the reward amount. function _calcClaimableAmount( address staker ) internal view returns (uint256) { StakeInfo memory stakeInfo = stakeInfoByStaker[staker]; if (stakeInfo.stakedAmount == 0) { return 0; } if (stakeInfo.latestClaimedAt == 0) { return 0; } if (stakeInfo.latestClaimedAt > block.timestamp) { return 0; } if (totalStakeAmount == 0) { return 0; } if (rate == 0) { return 0; } uint256 diff = block.timestamp - stakeInfo.latestClaimedAt; uint256 claimD = diff % timeoutClaimPeriod; // Avoid delayed on-chain submissions resulting in zero rewards 0 if (diff == timeoutClaimPeriod) { claimD = timeoutClaimPeriod; } uint256 claimableAmount = Math.mulDiv( stakeInfo.stakedAmount * claimD, rate, totalStakeAmount, Math.Rounding.Zero ); return claimableAmount; }",
        "labels": [
            "SlowMist",
            "Lumiterra Community Contracts",
            "Type: Others",
            "Severity: Medium"
        ]
    },
    {
        "title": "Handling reward calculation issues and function restrictions in reward cycles",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Lumiterra Community Contracts_en-us.pdf",
        "body": "contracts/UtilityStake.sol Users will still be able to use the old rate to calculate rewards and collect them when the next cycle has not yet been set up. This also causes a problem. When there are not enough reward tokens in the pool, users can't use the unstake and stake functions. function _calcClaimableAmount( address staker ) internal view returns (uint256) { StakeInfo memory stakeInfo = stakeInfoByStaker[staker]; if (stakeInfo.stakedAmount == 0) { return 0; } if (stakeInfo.latestClaimedAt == 0) { return 0; } if (stakeInfo.latestClaimedAt > block.timestamp) { return 0; } if (totalStakeAmount == 0) { return 0; } if (rate == 0) { return 0; } uint256 diff = block.timestamp - stakeInfo.latestClaimedAt; uint256 claimD = diff % timeoutClaimPeriod; // Avoid delayed on-chain submissions resulting in zero rewards 0 if (diff == timeoutClaimPeriod) { claimD = timeoutClaimPeriod; } uint256 claimableAmount = Math.mulDiv( stakeInfo.stakedAmount * claimD, rate, totalStakeAmount, Math.Rounding.Zero ); return claimableAmount; }",
        "labels": [
            "SlowMist",
            "Lumiterra Community Contracts",
            "Type: Others",
            "Severity: High"
        ]
    },
    {
        "title": "Addressing overpayment risk in reward distribution due to rate update delays",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Lumiterra Community Contracts_en-us.pdf",
        "body": "contracts/UtilityStake.sol In the current reward mechanism, a signicant issue arises if users claim their rewards after an update to the reward rate. Specically, if a user claims rewards accrued before the rate update, the calculation will be based on the new, potentially higher rate, leading to an overestimation of their rightful reward. This overpayment can deplete the reward pool more rapidly than anticipated, potentially leaving insucient funds for later users. Consequently, this could impede the normal operation of unstake and stake functions, as the reward pool might not sustain the demands. function depositRewardToken(address token, uint256 amount) external { IUtilityToken rewardToken = config.getPRToken(); require(token == address(rewardToken), \"UtilityStake: invalid token\"); rewardToken.transferFrom(msg.sender, address(this), amount); if (block.timestamp >= periodFinish) { rate = amount / periodDuration; } else { uint256 remaining = periodFinish - block.timestamp; uint256 leftover = remaining * rate; rate = (amount + leftover) / periodDuration; } periodFinish = block.timestamp + periodDuration; emit DepositRewardToken(amount); }",
        "labels": [
            "SlowMist",
            "Lumiterra Community Contracts",
            "Type: Others",
            "Severity: Critical"
        ]
    },
    {
        "title": "Inaccuracies in reward calculation due to misuse of total supply in liquidity pool",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Lumiterra Community Contracts_en-us.pdf",
        "body": "contracts/LiquidityStake.sol In the _checkpoint function, the use of _sc2crvPool().totalSupply() for calculating rewards may lead to inaccuracies. This is because it utilizes the total supply of the entire liquidity pool, rather than the quantity of LP tokens controlled by the contract itself. Indeed, this approach can result in the calculation of rewards being less than what is rightfully due, consequently leading to users receiving fewer rewards than they are actually entitled to. function _checkpoint(address staker) internal { _metaGauge().claim_rewards(); StakeInfo memory stakeInfo = stakeInfoByStaker[staker]; uint256 totalSupplay = _sc2crvPool().totalSupply(); if (totalSupplay == 0) { return; } for (uint256 i = 0; i < MAX_REWARDS; i++) { address tokenAddress = _metaGauge().reward_tokens(i); if (tokenAddress == address(0)) { break; } uint256 dI = 0; uint256 tokenBalance = IERC20Metadata(tokenAddress).balanceOf( address(this) ); dI = (10 ** 18 * (tokenBalance - rewardBalances[tokenAddress])) / totalSupplay; rewardBalances[tokenAddress] = tokenBalance; // integral: uint256 = self.reward_integral[token] + dI uint256 integral = rewardIntegral[tokenAddress] + dI; if (dI != 0) { rewardIntegral[tokenAddress] = integral; } uint256 integralFor = rewardIntegralFor[tokenAddress][staker]; uint256 newClaimable = 0; if (integralFor < integral) { rewardIntegralFor[tokenAddress][staker] = integral; (stakeInfo.totalSC2CRVLP * ((integral - integralFor))) / PRICE_PRECISION; } uint256 claimData = claimDataByStaker[staker][tokenAddress]; uint256 totalClaimable = (claimData >> 128) + newClaimable; if (totalClaimable > 0) { uint256 totalClaimed = claimData % 2 ** 128; claimDataByStaker[staker][tokenAddress] = totalClaimed + (totalClaimable << 128); } } } }",
        "labels": [
            "SlowMist",
            "Lumiterra Community Contracts",
            "Type: Others",
            "Severity: Critical"
        ]
    },
    {
        "title": "Redundant logic in _setFloorPrice function of smart contract",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Lumiterra Community Contracts_en-us.pdf",
        "body": "contracts/PriceField.sol The else if (_floorPrice == 0) conditional branch in this function will not actually be executed. This is because _floorPrice is set to the new floorPrice_ before any conditional judgment is entered, and floorPrice_ cannot be zero, as veried at the beginning of the function. function _setFloorPrice(uint256 floorPrice_) internal { require(floorPrice_ >= PRICE_PRECISION / 2, \"floor price too low\"); require(floorPrice_ > _floorPrice, \"floor price too low\"); uint256 previousFloorPrice = _floorPrice; uint256 x3 = _config.getUtilityToken().totalSupply(); _floorPrice = floorPrice_; if (x3 > c()) { uint256 maxFloorPrice = (Math.mulDiv( x3 - c(), _slope, PRECENT_DENOMINATOR, Math.Rounding.Zero ) + PRICE_PRECISION) / 2; if (maxFloorPrice > floorPrice_) { _floorPrice = floorPrice_; } } else if (_floorPrice == 0) { //SLOWMIST//will not be implemented _floorPrice = floorPrice_; } else if (x3 > x1(floorPrice_) + _exerciseAmount) { _floorPrice = floorPrice_; } else if (x3 == 0) { _floorPrice = floorPrice_; } require(_floorPrice > previousFloorPrice, \"floor price too low\"); emit UpdateFloorPrice(_floorPrice); }",
        "labels": [
            "SlowMist",
            "Lumiterra Community Contracts",
            "Type: Others",
            "Severity: Low"
        ]
    },
    {
        "title": "Potential reentrancy risk in VAMM's _mintByPRToken function",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Lumiterra Community Contracts_en-us.pdf",
        "body": "contracts/VAMM.sol The payToken can be passed in arbitrarily from the outside, and if the payToken is a token that implements a callback function, then this call may trigger malicious code.An attacker can exploit this by calling the _mintByPRToken function again during the callback. Since the _mintByPRToken function calls payToken.transferFrom before updating _floorPrice and minting new tokens, a reentry attack could allow an attacker to mint tokens multiple times at the old, more favorable price, rather than at the updated price. This could lead to improper minting of assets. function _mintByPRToken( address payTokenAddress, uint256 mintAmount, uint256 maxPayAmount, address recipient ) internal { IERC20Metadata payToken = IERC20Metadata(payTokenAddress); IUtilityToken _utilityToken = _config.getUtilityToken(); IUtilityToken _prToken = _config.getPRToken(); require(_prToken.balanceOf(msg.sender) >= mintAmount, \"VAMM:mp0\"); require( _prToken.allowance(msg.sender, address(this)) >= mintAmount, \"VAMM:mp1\" ); (uint256 toLiquidityPrice, uint256 fees) = _priceField.getUseFPBuyPrice( mintAmount ); require(toLiquidityPrice + fees <= maxPayAmount, \"VAMM:mp2\"); // Include slippage as fee income fees = maxPayAmount - toLiquidityPrice; //SLOWMIST// uint256 maxPayAmountInPayToken = _convertPrice( maxPayAmount, payToken, true ); _priceField.increaseSupplyWithNoPriceImpact(mintAmount); require( payToken.transferFrom( msg.sender, address(this), maxPayAmountInPayToken ), \"VAMM:mp3\" );//The paytoken is an arbitrary token, so any worthless token can be used as the key to transfer money to the contract. // burn pr token _prToken.burnFrom(msg.sender, mintAmount); _collectFees(fees); /// mint token _totalLiquidity += toLiquidityPrice; _utilityToken.mint(recipient, mintAmount); _deposit(payTokenAddress); _autoUpFP(); emit Mint(recipient, mintAmount, toLiquidityPrice, fees); }",
        "labels": [
            "SlowMist",
            "Lumiterra Community Contracts",
            "Type: Others",
            "Severity: High"
        ]
    },
    {
        "title": "Exploitation risk with arbitrary payToken in VAMM's _mintByPRToken function",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Lumiterra Community Contracts_en-us.pdf",
        "body": "contracts/VAMM.sol The payToken can be any token, so it can be used to construct a malicious token to make a payment. function _mintByPRToken( address payTokenAddress, uint256 mintAmount, uint256 maxPayAmount, address recipient ) internal { IERC20Metadata payToken = IERC20Metadata(payTokenAddress); IUtilityToken _utilityToken = _config.getUtilityToken(); IUtilityToken _prToken = _config.getPRToken(); require(_prToken.balanceOf(msg.sender) >= mintAmount, \"VAMM:mp0\"); require( _prToken.allowance(msg.sender, address(this)) >= mintAmount, \"VAMM:mp1\" ); (uint256 toLiquidityPrice, uint256 fees) = _priceField.getUseFPBuyPrice( mintAmount ); require(toLiquidityPrice + fees <= maxPayAmount, \"VAMM:mp2\"); // Include slippage as fee income fees = maxPayAmount - toLiquidityPrice; //SLOWMIST// uint256 maxPayAmountInPayToken = _convertPrice( maxPayAmount, payToken, true ); _priceField.increaseSupplyWithNoPriceImpact(mintAmount); require( payToken.transferFrom( msg.sender, address(this), maxPayAmountInPayToken ), \"VAMM:mp3\" );//The paytoken is an arbitrary token, so any worthless token can be used as the key to transfer money to the contract. // burn pr token _prToken.burnFrom(msg.sender, mintAmount); _collectFees(fees); /// mint token _totalLiquidity += toLiquidityPrice; _utilityToken.mint(recipient, mintAmount); _deposit(payTokenAddress); _autoUpFP(); emit Mint(recipient, mintAmount, toLiquidityPrice, fees); }",
        "labels": [
            "SlowMist",
            "Lumiterra Community Contracts",
            "Type: Others",
            "Severity: High"
        ]
    },
    {
        "title": "Preemptive Initialization",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Lumiterra Community Contracts_en-us.pdf",
        "body": "contracts/LiquidityStake.sol function initialize(IConfig config_) public initializer { __Ownable_init(); __UUPSUpgradeable_init(); _transferOwnership(tx.origin); config = config_; } contracts/UtilityStake.sol function initialize(IConfig config_) public initializer { __Ownable_init(); __UUPSUpgradeable_init(); _transferOwnership(tx.origin); config = config_; unstakeFee = 300000000; periodDuration = 1 weeks; timeoutClaimPeriod = 2 days; } contracts/VAMM.sol function initialize( IConfig config_, PriceField priceField_, uint256 t_, uint256 x_, uint256 c_ ) public initializer { __Ownable_init(); __UUPSUpgradeable_init(); _transferOwnership(tx.origin); _config = config_; _priceField = priceField_; tForMFR = t_; maxTForMFR = 5000000000; minTForMFR = t_; cForMFR = c_; // ethereum block time 13s reduceTBlocks = 6600; xForMFR = x_; }",
        "labels": [
            "SlowMist",
            "Lumiterra Community Contracts",
            "Type: Race Conditions Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Lacking event logging in critical contract functions alters state without transparency issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Lumiterra Community Contracts_en-us.pdf",
        "body": "contracts/LiquidityStake.sol function setHook(LiquidityStakeHook hook_) external onlyOwner { hook = hook_; } contracts/UtilityStake.sol function setHook(UtilityStakeHook hook_) external onlyOwner { hook = hook_; } contracts/PriceField.sol function increaseSupplyWithNoPriceImpact(uint256 amount) external onlyVamm { _exerciseAmount += amount; } contracts/VAMM.sol function setPriceField(PriceField priceField_) external onlyOwner { _priceField = priceField_; }",
        "labels": [
            "SlowMist",
            "Lumiterra Community Contracts",
            "Type: Malicious Event Log Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Redundant functions",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Lumiterra Community Contracts_en-us.pdf",
        "body": "contracts/VAMM.sol Redundant function code, which can be deleted if it is not useful. function liquidityTesting() external { }",
        "labels": [
            "SlowMist",
            "Lumiterra Community Contracts",
            "Type: Others",
            "Severity: Information"
        ]
    },
    {
        "title": "Missing check return value",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Lumiterra Community Contracts_en-us.pdf",
        "body": "It is recommended to check the return value of transferFrom, as there may be problems if a non-ERC20 standard token is subsequently used. contracts/UtilityStake.sol line 142: utilityToken.transferFrom(staker, address(this), amount); line 196: stablecoin.transferFrom(staker, address(this), fees); line 287: rewardToken.transferFrom(msg.sender, address(this), amount); contracts/LiquidityStake.sol line 154: stablecoin.transferFrom(staker, address(this), _amount); contracts/VAMM.sol line 504: token.transferFrom(msg.sender, address(this), _repayAmount);",
        "labels": [
            "SlowMist",
            "Lumiterra Community Contracts",
            "Type: Others",
            "Severity: Low"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Lumiterra Community Contracts_en-us.pdf",
        "body": "contracts/VAMM.sol The owner can set the key parameters, if the private key is lost, the price will be out of control. owner can setPriceField operator can updateMFR contracts/UtilityToken.sol The owner can mint the token, if the private key is lost it will cause the token to be incremented. owner can mint owner can transferOwnership Other contracts have key roles and key parameters that are mostly controlled by external config contracts.",
        "labels": [
            "SlowMist",
            "Lumiterra Community Contracts",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Recommendation to Implement reentrancy",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Lumiterra Community Contracts_en-us.pdf",
        "body": "contracts/VAMM.sol In _mint , _burn , there is no utilization scenario at the moment, but it is recommended to add reentrant locks.",
        "labels": [
            "SlowMist",
            "Lumiterra Community Contracts",
            "Type: Reentrancy Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Lack of authority control",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DTX Protocol_en-us.pdf",
        "body": "1.In the PositionManager contract, the increasePosition and decreasePosition functions are used to open and decrease positions respectively. However, both of these functions lack permission validation, resulting in any external user being able to pass in custom order information parameters to open or close a position. For the createPosition function, the user can call it directly and pass in the valid order information parameter to open a position without transferring margin. For decreasePosition positions, the user can directly close any position that exists in the market by calling and passing in a valid order information parameter. Code Location: contracts/PositionManager.sol function increasePosition( Order.IncreaseOrder memory order ) external returns (bool, Order.CancelType, uint256, uint256) { ... } ... function decreasePosition( Order.DecreaseOrder memory decreaseOrder ) external returns (bool, Order.CancelType, uint256, uint256, bool, uint256) { ... } 2.In the MarketVault and Treasury contract, anyone can transfer tokens out of a contract without restriction by calling the transferOut and transferOutNative functions. Code Location: contracts/vault/MarketVault.sol function transferOut( address token, address receiver, uint256 amount ) external { if (amount == 0) return; IERC20(token).safeTransfer(receiver, amount); } function transferOutNative( address payable receiver, uint256 amount ) external { if (amount == 0) return; receiver.transfer(amount); } contracts/vault/Treasury.sol function transferOut( address token, address receiver, uint256 amount ) external { IERC20(token).safeTransfer(receiver, amount); } function transferOutNative( address payable receiver, uint256 amount ) external { receiver.transfer(amount); } 3.In the Oracle contract, anyone can set oracle machine price congurations such as price source, adjustmentBasisPoints, spreadThresholdBasisPoints and token attributes without restriction by calling the setAdjustment, setFastPriceEnabled, setFastPriceFeed, setChainPriceFeed, setSpreadBasisPoints, setSpreadThresholdBasisPoints, setMaxStrictPriceDeviation and setStableTokens functions. Code Location: contracts/oracle/Oracle.sol#L40-107 function setAdjustment( address _token, bool _isAdditive, uint256 _adjustmentBps ) external /*onlyInitOr(MANAGER_ROLE)*/ { ... } function setFastPriceEnabled( bool _isEnabled ) external /* onlyInitOr(MANAGER_ROLE) */ { ... } function setFastPriceFeed( address _feed ) external /*onlyInitOr(MANAGER_ROLE)*/ { ... } function setChainPriceFeed( address _feed ) external /*onlyInitOr(MANAGER_ROLE)*/ { ... } function setSpreadBasisPoints( address _token, uint256 _spreadBasisPoints ) external /*onlyInitOr(MANAGER_ROLE)*/ { ... } function setSpreadThresholdBasisPoints( uint256 _spreadThresholdBasisPoints ) external /*onlyInitOr(MANAGER_ROLE) */ { ... } function setMaxStrictPriceDeviation( uint256 _maxStrictPriceDeviation ) external /*onlyInitOr(MANAGER_ROLE)*/ { ... } function setStableTokens( address _token, bool _stable ) external /*onlyInitOr(MANAGER_ROLE)*/ { ... } 4.In the ChainPriceFeed contract, anyone can set the price feed congurations such as the sampleSpace, the priceFeeds and the priceDecimals without restriction by calling the setSampleSpace and setPriceFeed functions. Code Location: contracts/oracle/ChainPriceFeed.sol#15-27 function setSampleSpace(uint256 _times) external /*onlyAdmin*/ { ... } function setPriceFeed( address _token, address _feed, uint256 _decimal ) external /*onlyInitOr(MANAGER_ROLE)*/ { ... } 5.In the FastPriceFeed contract, anyone can set the price feed congurations such as the chainPriceFeed, the maxTimeDeviation, the priceDuration, the maxPriceUpdateDelay, the spreadBasisPointsIfInactive, the spreadBasisPointsIfChainError, the minBlockInterval, the isSpreadEnablede, the lastUpdatedAt, the maxDeviationBasisPoints, the maxCumulativeDeltaDis, the priceDataInterval, the tokens and the tokens price without restriction by calling the setPriceFeed, the setMaxTimeDeviation, the setPriceDuration, the setMaxPriceUpdateDelay, the setSpreadBasisPointsIfInactive, the setSpreadBasisPointsIfChainError, the setMinBlockInterval, the setIsSpreadEnabled, the setLastUpdatedAt, the setMaxDeviationBasisPoints, the setMaxCumulativeDeltaDis, the setPriceDataInterval, the setTokens, the setPrices, the setCompactedPrices, the setPricesWithBits functions. Code Location: contracts/oracle/FastPriceFeed.sol#103-247 function setPriceFeed(address _feed) external /*onlyInitOr(MANAGER_ROLE)*/ { ... } function setMaxTimeDeviation( uint256 _deviation ) external /*onlyInitOr(MANAGER_ROLE)*/ { ... } function setPriceDuration( uint256 _duration ) external /*onlyInitOr(MANAGER_ROLE)*/ { ... } function setMaxPriceUpdateDelay( uint256 _delay ) external /*onlyInitOr(MANAGER_ROLE)*/ { ... } function setSpreadBasisPointsIfInactive( uint256 _point ) external /*onlyInitOr(MANAGER_ROLE)*/ { ... } function setSpreadBasisPointsIfChainError( uint256 _point ) external /*onlyInitOr(MANAGER_ROLE)*/ { ... } function setMinBlockInterval( uint256 _interval ) external /* onlyInitOr(MANAGER_ROLE)*/ { ... } function setIsSpreadEnabled( bool _enabled ) external /*onlyInitOr(MANAGER_ROLE)*/ { ... } function setLastUpdatedAt( uint256 _lastUpdatedAt ) external /*onlyInitOr(MANAGER_ROLE)*/ { ... } function setMaxDeviationBasisPoints( uint256 _maxDeviationBasisPoints ) external /*onlyInitOr(MANAGER_ROLE)*/ { ... } function setMaxCumulativeDeltaDiffs( address[] memory _tokens, uint256[] memory _maxCumulativeDeltaDiffs ) external /*onlyInitOr(MANAGER_ROLE)*/ { ... } function setPriceDataInterval( uint256 _priceDataInterval ) external /*onlyInitOr(MANAGER_ROLE)*/ { ... } function setTokens( address[] memory _tokens, uint256[] memory _tokenPrecisions ) external /*onlyInitOr(MANAGER_ROLE)*/ { ... } function setPrices( address[] memory _tokens, uint256[] memory _prices, uint256 _timestamp ) external /*onlyUpdater*/ { ... } function setCompactedPrices( uint256[] memory _priceBitArray, uint256 _timestamp ) external /*onlyUpdater*/ { ... } function setPricesWithBits( uint256 _priceBits, uint256 _timestamp ) external /*onlyUpdater*/ { ... }",
        "labels": [
            "SlowMist",
            "DTX Protocol",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Liquidity incorrectly updated upon liquidation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DTX Protocol_en-us.pdf",
        "body": "In the PositionManager contract, the Liquidator role can liquidate a specied position by calling the liquidatePosition function. The actual liquidation logic is done by calling the liquidatePosition function in the PositionHandler contract. In the liquididatePosition function of the PositionHandler contract, the updateOccupiedLiquidity function is called to update the liquidity occupancy after passing the check. However, in the liquididatePosition function of the PositionManager contract, the liquidity occupancy is updated again after the liquidation operation is completed. Repeated update operation is not designed to be expected and may result in liquidity deductions beyond what is expected. Code Location: contracts/PositionManager.sol#L553-557 function liquidatePosition( Keys.PositionKeyInfo memory keyInfo ) external onlyLiquidator returns (bool isSuccess, string memory res) { ... (isSuccess, res, _realisedPnL) = market .positionHandler .liquidatePosition(_position); if (!isSuccess) { return (isSuccess, \"liquidate error\"); } market.updateOccupiedLiquidity( _position.collateral, _position.isLong, false ); ... }",
        "labels": [
            "SlowMist",
            "DTX Protocol",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Redundant code",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DTX Protocol_en-us.pdf",
        "body": "There are useless codes in the le and codes that are not used in actual business. Code Location: contracts/PositionManager.sol#L365-525 function previewIncreasePosition( Order.IncreaseOrder memory increaseOrder, Market.Price memory collateralTokenPrice, Market.Price memory indexTokenPrice ) external view returns ( Position.Props memory position, Position.FundDelta memory fundDelta, bool canExecute, string memory reason ) { ... } ... function previewDecreasePosition( Order.DecreaseOrder memory decreaseOrder, Market.Price memory collateralTokenPrice, Market.Price memory indexTokenPrice ) external view returns ( Position.Props memory position, Position.FundDelta memory fundDelta, bool canExecute, string memory reason ) { ... } contracts/data/MarketData.sol mapping(address => EnumerableSet.AddressSet) private vaultIndexTokens; ... function getIndexTokensByVault( address collateralTokenVault ) external view returns (address[] memory) { return vaultIndexTokens[collateralTokenVault].values(); } contracts/MarketRouter.sol function getIndexTokensByVault( IVault collateralTokenVault ) external view returns (address[] memory) { return this.marketData().getIndexTokensByVault(collateralTokenVault); }",
        "labels": [
            "SlowMist",
            "DTX Protocol",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Lack of checks in the direction of price triggers",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DTX Protocol_en-us.pdf",
        "body": "In the OrderBook contract, the contract does not check isTriggerAbove and keyInfo.isLong in the incoming order information parameters when the user creates and modies an order. Suppose there is a situation where the user creates a limit order to open a long position and the incoming isTriggerAbove parameter is set to true by mistake, which would result in the order being executed immediately even if the price is not at the trigger price at the time the order is executed. Code Location: contracts/OrderBook.sol function createIncreaseOrder( Order.IncreaseOrder memory request ) external payable { ... } function createDecreaseOrders( Order.DecreaseOrder[] memory orders ) external payable { ... } function createDecreaseOrder( Order.DecreaseOrder memory request ) external payable { ... } ... function updateOrder(Order.UpdateOrder calldata request) external { ... }",
        "labels": [
            "SlowMist",
            "DTX Protocol",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Lack of cost checks for the execution of orders",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DTX Protocol_en-us.pdf",
        "body": "In the OrderBook contract, users can create decrease orders in bulk by calling the createDecreaseOrders function. However, there is no check in the function to see if the sum of the incoming executionFee parameter is equal to msg.value. if the sum of the incoming executionFee is much greater than the value of msg.value, then this will result in unintended consumption of funds in the vault. Code Location: contracts/OrderBook.sol#L125-156 function createDecreaseOrders( Order.DecreaseOrder[] memory orders ) external payable { uint256 _execFee; uint256 orderLen = orders.length; for (uint256 i; i < orderLen; i++) { _execFee += orders[i].executionFee; } uint256 _need; for (uint256 i = 0; i < orderLen; i++) { uint256 executionFeeRequired = orders[i] .keyInfo .collateralTokenVault .getVaultOrderConfig() .executionFee; _need += executionFeeRequired; } require(msg.value >= _need, \"invalid execution fee\"); _transferExecFee(msg.value); ... }",
        "labels": [
            "SlowMist",
            "DTX Protocol",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "call() should be used instead of transfer() and send()",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DTX Protocol_en-us.pdf",
        "body": "The transfer() and send() functions forward a xed amount of 2300 gas. Historically, it has often been recommended to use these functions for value transfers to guard against reentrancy attacks. However, the gas cost of EVM instructions may change signicantly during hard forks which may break already deployed contract systems that make xed assumptions about gas costs. For example. EIP 1884 broke several existing smart contracts due to a cost increase of the SLOAD instruction. ",
        "labels": [
            "SlowMist",
            "DTX Protocol",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Potential issues with using chainlink to get prices",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DTX Protocol_en-us.pdf",
        "body": "In the ChainPriceFeed contract, the getLatestPrice function and the getPrice function will obtain the price from chainlinks price feed contract through the latestAnswer interface. But the latestAnswer interface only returns the price parameter, without any other parameters to check whether the price is valid. For this reason, chainlink has deprecated this interface in v3. In addition, the getRoundData function is used in the getPrice function to get the price, but there is no check if the return value indicates stale data(updateAt refers to the timestamp of the round. This value isnt checked to make sure it is recent). Reference: https://docs.chain.link/data-feeds/api-reference/#latestanswer https://docs.chain.link/data-feeds/#check-the-timestamp-of-the-latest-answer Code Location: contracts/oracle/ChainPriceFeed.sol function getLatestPrice(address _token) public view returns (uint256) { ... int256 _price = _priceFeed.latestAnswer(); require(_price > 0, \"PriceFeed: invalid price\"); return uint256(_price); } function getPrice( address _token, bool _maximise ) public view returns (uint256) { ... uint80 _id = _priceFeed.latestRound(); for (uint80 i = 0; i < sampleSpace; i++) { if (_id <= i) { break; } uint256 p; if (i == 0) { int256 _p = _priceFeed.latestAnswer(); require(_p > 0, \"PriceFeed: invalid price\"); p = uint256(_p); } else { (, int256 _p, , , ) = _priceFeed.getRoundData(_id - i); require(_p > 0, \"PriceFeed: invalid price\"); p = uint256(_p); } ... } ... } }",
        "labels": [
            "SlowMist",
            "DTX Protocol",
            "Type: Others",
            "Severity: Low"
        ]
    },
    {
        "title": "Rounding issues when transferring the fee",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DTX Protocol_en-us.pdf",
        "body": "In the PositionManager contract, after the execution of opening and decreasing positions, the contract will call the transferIncreaseFee function in the market library to transfer the fee to be charged. In the transferIncreaseFee function of the market contract, The cost of transferring to the vault is rst calculated, after which a portion of the cost that needs to be transferred to the treasury address is deducted from it. However, when calculating the number of tokens to be transferred to treasury, the Precision library's applyFactor function is used, which divides an extra FLOAT_PRECISION parameter(i.e., 10 ** 30). This will eventually result in the number of tokens transferred being incorrectly calculated as 0 due to rounding issues. Code Location: contracts/PositionManager.sol function increasePosition( Order.IncreaseOrder memory order ) external returns (bool, Order.CancelType, uint256, uint256) { ... market.transferIncreaseFee( _fees, marketRouter, market.getFeeConfig().treasuryFactor, collateralTokenPrice ); ... } ... function decreasePosition( Order.DecreaseOrder memory decreaseOrder ) external returns (bool, Order.CancelType, uint256, uint256, bool, uint256) { ... market.transferIncreaseFee( _fees, marketRouter, market.getFeeConfig().treasuryFactor, collateralTokenPrice ); ... } contracts/libs/Market.sol#L387-388 function transferIncreaseFee( Props memory market, Fee.FeeDelta memory feeDelta, IMarketRouter marketRouter, uint256 treasuryFactor, Market.Price memory collateralTokenPrice ) external { ... uint256 _amount = Precision.applyFactor(_treasuryFee, 10 ** _decimals) / collateralTokenPrice.max; marketRouter.marketVault().transferOut( _token, address(marketRouter.treasury()), _amount ); }",
        "labels": [
            "SlowMist",
            "DTX Protocol",
            "Type: Arithmetic Accuracy Deviation Vulnerability",
            "Severity: High"
        ]
    },
    {
        "title": "Lack of deduction of fees receivable in liquidation check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DTX Protocol_en-us.pdf",
        "body": "In the positionHandler contract, an external call to the validateLiquidation function allows you to check whether an incoming position can be liquidated. A position can be liquidated if the amount of the loss of the position plus the total cost of the position is greater than the margin. However, the fee is calculated without deducting the funding fee that the position should receive, so there is a situation where the position does not need to pay the funding fee at the moment but receives it from the counterparty, and if this is not deducted it may result in the position being incorrectly calculated as liquidatable. Code Location: contracts/positionHandler.sol function validateLiquidation( Position.Props memory position, Market.Price memory collateralTokenPrice, uint256 markPrice, uint256 cumulativeBorrowingRate ) public view returns ( Position.PositionStatus status, Position.FundDelta memory fundDelta ) { ... fundDelta.totalFee = fees.totalFee(); // get position config in market Market.PositionConfig memory _config = _router .configData() .positionConfigs(_marketKey); // Collateral - Funding Fee - Borrow Fee - Liquidation Fee - PnL <= Collateral * 1000bps if (!hasProfit) { uint256 _limit = position.collateral - Precision.mulDiv( position.collateral, _config.mmr, Precision.BASIS_POINTS ); uint256 _loss = fundDelta.totalFee + unrealisedPnL; if (_limit <= _loss) { return (Position.PositionStatus.LIQUIDATION, fundDelta); } } else { ... } return (Position.PositionStatus.OPEN, fundDelta); } contracts/libs/Fee.sol function totalFee(FeeDelta memory fees) external pure returns (uint256) { return fees.marginFee + fees.execFee + fees.liquidationFee + fees.borrowingFee + fees.fundingFeeUSD; }",
        "labels": [
            "SlowMist",
            "DTX Protocol",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Lack of deducting the fund fee to take-prot checks",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DTX Protocol_en-us.pdf",
        "body": "In the positionHandler contract, an external call to the validateLiquidation function allows you to check whether an incoming position triggers Take Prot. However, it only checks whether the prot of the position exceeds the maximum threshold, and does not deduct the fees that need to be charged from the prot, such as fund fees and position opening fees. This may result in positions being incorrectly taken out early. Code Location: contracts/positionHandler.sol function validateLiquidation( Position.Props memory position, Market.Price memory collateralTokenPrice, uint256 markPrice, uint256 cumulativeBorrowingRate ) public view returns ( Position.PositionStatus status, Position.FundDelta memory fundDelta ) { ... if (!hasProfit) { ... } else { uint256 _maxPnL = Precision.mulDiv( position.collateral, _config.maxPnLBps, Precision.BASIS_POINTS ); if (unrealisedPnL >= _maxPnL) { return (Position.PositionStatus.TP, fundDelta); } } return (Position.PositionStatus.OPEN, fundDelta); }",
        "labels": [
            "SlowMist",
            "DTX Protocol",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DTX Protocol_en-us.pdf",
        "body": "1.In the Keeper contract, the Keeper role can arbitrarily set the price of tokens when executing orders. If the privilege is lost or misused, this may have an impact on the user's assets. Code Location: contracts/Keeper.sol function setPricesAndExecOrder( address[] memory _tokens, uint256[] memory _prices, uint256[] memory orderIds, uint256 _timestamp, address payable receiver ) external onlyKeeper returns (bool[] memory isSuccess, string[] memory res) { address _fastFeed = marketRouter.oracle().fastPriceFeed(); IFastPriceFeed(_fastFeed).setPrices(_tokens, _prices, _timestamp); ... } function execVaultOrders( address[] memory vaults, uint256[] memory vaultPrices, uint256[] memory orderIds, address payable receiver ) external onlyKeeper returns (bool[] memory isSuccess, string[] memory res) { require(vaults.length == vaultPrices.length, \"invalid params\"); for (uint256 i = 0; i < vaults.length; i++) { _setVaultPrice(vaults[i], vaultPrices[i]); } ... } ... function setPricesAndLiquidatePosition( address[] memory _tokens, uint256[] memory _prices, Keys.PositionKeyInfo[] memory keyInfo, uint256 _timestamp ) external onlyKeeper returns (bool[] memory isSuccess, string[] memory res) { address _fastFeed = IOracle(marketRouter.oracle()).fastPriceFeed(); IFastPriceFeed(_fastFeed).setPrices(_tokens, _prices, _timestamp); ... } 2.In the MarketRouter contract, the admin role can set the addresses of the system contracts and various congurations of the market (e.g. order congurations, position congurations, etc.) by calling the setSysAddresses function and the setMarketCongsByVault function. If the privilege is lost or misused, this may have an impact on the user's assets. Code Location: contracts/MarketRouter.sol function setSysAddresses(SysAddresses memory addresses) external onlyAdmin { sysAddresses = addresses; emit UpdateSystemAddress(addresses); } function setMarketConfigsByVault( address vault, address[] memory indexTokens, MarketConfigs[] memory marketConfigs ) external onlyAdmin { ... }",
        "labels": [
            "SlowMist",
            "DTX Protocol",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Lack of long/short position spread judgement",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DTX Protocol_en-us.pdf",
        "body": "In the FeeHandler contract, the getNextFundingRate function is used to calculate the latest funding charge, where the funding rate is increased if the positive or negative value of the previous funding rate is in the same direction as the current position pays the charge. However, there is a missing check here: for example, when the last funding rate was positive and the current long position position is still larger than the short position; but the dierence between long minus short has decreased from the previous time (i.e., the short position has increased more than the long position), this should be a decrease in the funding rate rather than an increase. Code Location: contracts/FeeHandler.sol function getNextFundingRate( Market.FeeConfig memory config, bytes32 market, uint256 openInterestLong, uint256 openInterestShort, uint256 duration ) public view returns (uint256, bool, int256) { ... bool _isSameDirection = (_fundingRate > 0 && openInterestLong > openInterestShort) || (_fundingRate < 0 && openInterestShort > openInterestLong); if (_isSameDirection) { // (open interest imbalance) ^ (funding exponent factor) / (total open interest) if (_diffToOpenInterestFactor > config.thresholdForStableFunding) { _changeType = FundingRateChangeType.Increase; } else if ( _diffToOpenInterestFactor < config.thresholdForDecreaseFunding ) { _changeType = FundingRateChangeType.Decrease; } } else { // if the skew has changed, then the funding should increase in the opposite direction _changeType = FundingRateChangeType.Increase; } if (_changeType == FundingRateChangeType.Increase) { // increase funding rate // longShortImbalance * fundingIncreaseFactorPerSecond int256 _increaseValue = Precision .applyFactor( _diffToOpenInterestFactor, config.fundingIncreaseFactor ) .toInt256() * duration.toInt256(); // if there are more longs than shorts, then the savedFundingFactorPerSecond should increase // otherwise the savedFundingFactorPerSecond should increase in the opposite direction / decrease if (openInterestLong < openInterestShort) { _increaseValue = -_increaseValue; } _nextFundingRate = _fundingRate + _increaseValue; } ... }",
        "labels": [
            "SlowMist",
            "DTX Protocol",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Missing event record",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DTX Protocol_en-us.pdf",
        "body": "The following functions in several contracts are for event logging of key parameter settings. Code Location: contracts/oracle/Oracle.sol#L40-107 function setAdjustment function setFastPriceEnabled function setFastPriceFeed function setChainPriceFeed function setSpreadBasisPoints function setSpreadThresholdBasisPoints function setMaxStrictPriceDeviation function setStableTokens contracts/oracle/ChainPriceFeed.sol#15-27 function setSampleSpace function setPriceFeed contracts/oracle/FastPriceFeed.sol#103-247 function setPriceFeed function setMaxTimeDeviation function setPriceDuration function setMaxPriceUpdateDelay function setSpreadBasisPointsIfInactive function setSpreadBasisPointsIfChainError function setMinBlockInterval function setIsSpreadEnabled function setLastUpdatedAt function setMaxDeviationBasisPoints function setMaxCumulativeDeltaDiffs function setPriceDataInterval function setTokens function setPrices function setCompactedPrices function setPricesWithBits contracts/Vault.sol function setOrderConfig",
        "labels": [
            "SlowMist",
            "DTX Protocol",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Lack of liquidity checking mechanism in case of position reduction",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DTX Protocol_en-us.pdf",
        "body": "In the PositionManager contract, the user decreases a position by calling the decreasePosition function, which calls the validateDecreaseOrder function in the orderHandler contract to check if the decrease can be done. However, there is no liquidity check in this function, so if the user takes a large prot and there is not enough liquidity in the vault to cover the user's prot amount, the decrease may fail due to lack of liquidity. Code Location: contracts/PositionManager.sol function decreasePosition( Order.DecreaseOrder memory decreaseOrder ) external returns (bool, Order.CancelType, uint256, uint256, bool, uint256) { ... (bool valid, Order.CancelType cancelType) = market .positionHandler .validatePosition( _position, collateralTokenPrice, markPrice, _rate ); if (!valid) return (false, cancelType, 0, 0, false, 0); ... }",
        "labels": [
            "SlowMist",
            "DTX Protocol",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Code redundancy issue 9",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Mint V1.0.1_en-us.pdf",
        "body": "The _beforeTokenTransfer function exists in the CrossMint1155 contract, but this function does not implement any logic and belongs to redundant code. In the CrossMint1155BaseURI contract, there is a _clearTokenURI function to clear tokenId . The visibility of this function is internal, but no other function calls this internal visibility function. Code loction: function _beforeTokenTransfer( address operator, address from, address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data ) internal virtual override { // noop } function _clearTokenURI(uint256 tokenId) internal { if (bytes(_tokenURIs[tokenId]).length != 0) { delete _tokenURIs[tokenId]; } }",
        "labels": [
            "SlowMist",
            "Cross Mint V1.0.1",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing event records 10",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Mint V1.0.1_en-us.pdf",
        "body": "In the CrossMint1155BaseURI contract, the _setBaseURI function is used to set the baseURI , but no event recording is performed. In the CrossMint contract, the owner can set baseURI and feeManager through the setBaseURI function and setFeeManager function respectively, but no event recording is performed. ",
        "labels": [
            "SlowMist",
            "Cross Mint V1.0.1",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Permission control issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Mint V1.0.1_en-us.pdf",
        "body": "In the CrossMint721Factory library, any user can create a new CrossMint721 contract through the deployCrossMint721 function; in the CrossMint1155Factory library, any user can create a new deployCrossMint1155 contract through the deployCrossMint721 function; ",
        "labels": [
            "SlowMist",
            "Cross Mint V1.0.1",
            "Type: Authority Control Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Return value checking issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Mint V1.0.1_en-us.pdf",
        "body": "There are the withMintFee modier and withCollectionFee modier in the CrossMint contract, which respectively call the distributeMintFee function and the distributeCollectionFee function to distribute fees, and check the results of their execution. However, the distributeMintFee function and the distributeCollectionFee function both have return values, so it may be better to check the return value while checking the execution result. ",
        "labels": [
            "SlowMist",
            "Cross Mint V1.0.1",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of external call",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cook Finance_en-us.pdf",
        "body": "BasicIssuanceModule has many external call, it suggested to be aware of the risk of external call e.g. initialize function function initialize( ICKToken _ckToken, IManagerIssuanceHook _preIssueHook ) external onlyCKManager(_ckToken, msg.sender) onlyValidAndPendingCK(_ckToken) 10 { managerIssuanceHook[_ckToken] = _preIssueHook; //SlowMist// Please be aware of the risk of external call _ckToken.initializeModule(); }",
        "labels": [
            "SlowMist",
            "Cook Finance",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of sandwich attack",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cook Finance_en-us.pdf",
        "body": "In SingleIndexModule, the trade function does not set a slippage protection when trade, which may results in sandwich attack. function trade(address _component) external nonReentrant onlyAllowedTrader(msg.sender) onlyEOA() virtual { _validateTradeParameters(_component); //@audit not check assetInfo[component] before trade. ( bool isBuy, uint256 tradeAmount //SlowMist// There is no slippage protection inside _calculateTradeSizeAndDirection ) = _calculateTradeSizeAndDirection(_component); if (isBuy) { //@audit no check if tradeAmount is larger than component _buyUnderweight(_component, tradeAmount); } else { _sellOverweight(_component, tradeAmount); } assetInfo[_component].lastTradeTimestamp = block.timestamp; } 11",
        "labels": [
            "SlowMist",
            "Cook Finance",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Risk of re-initialization",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cook Finance_en-us.pdf",
        "body": "The initialize function of SingleIndexModule, TradeModule and WarpModule were not restricted to can only be called once. //SlowMist// No restriction on initialization function initialize(ICKToken _index) external onlyCKManager(_index, msg.sender) onlyValidAndPendingCK(_index) { require(address(index) == address(0), \"Module already in use\"); ICKToken.Position[] memory positions = _index.getPositions(); for (uint256 i = 0; i < positions.length; i++) { ICKToken.Position memory position = positions[i]; assetInfo[position.component].targetUnit = position.unit.toUint256(); assetInfo[position.component].lastTradeTimestamp = 0; } index = _index; _index.initializeModule(); }",
        "labels": [
            "SlowMist",
            "Cook Finance",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "No check the _receiveToken address",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cook Finance_en-us.pdf",
        "body": "The trade function of TradeModule does not check if _receiveToken is allowed to trade. function trade( ICKToken _ckToken, string memory _exchangeName, address _sendToken, uint256 _sendQuantity, address _receiveToken, uint256 _minReceiveQuantity, bytes memory _data ) external nonReentrant onlyManagerAndValidCK(_ckToken) { TradeInfo memory tradeInfo = _createTradeInfo( _ckToken, _exchangeName, _sendToken, _receiveToken, _sendQuantity, _minReceiveQuantity ); _validatePreTradeData(tradeInfo, _sendQuantity); _executeTrade(tradeInfo, _data); uint256 exchangedQuantity = _validatePostTrade(tradeInfo); uint256 protocolFee = _accrueProtocolFee(tradeInfo, exchangedQuantity); ( 13 uint256 netSendAmount, uint256 netReceiveAmount ) = _updateCKTokenPositions(tradeInfo); emit ComponentExchanged( _ckToken, _sendToken, _receiveToken, tradeInfo.exchangeAdapter, netSendAmount, netReceiveAmount, protocolFee ); }",
        "labels": [
            "SlowMist",
            "Cook Finance",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Lack of update on the value of withdrawingNodeAmount and activeNodeAmount",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - StakeStone - Restaking_en-us.pdf",
        "body": "In the EigenNativeRestakingStrategy contract, the unstakeFromEigenPod function is used to submit a request for the cancellation of the stake, however the values of withdrawingNodeAmount and activeNodeAmount are not automatically updated after submitting the request and the _nodeAmount parameter passed in is not used. The normal logic would be that the activeNodeAmount should decrease and the withdrawingNodeAmount should increase after the request is submitted. Code Location: contracts/strategies/eigen/EigenNativeRestakingStrategy.sol#L156-169 function unstakeFromEigenPod( uint256 _nodeAmount, address _eigenPod ) external onlyGovernance { address podOwner = eigenPodOwners[_eigenPod]; require(podOwner != address(0), \"EigenPod not exist\"); Account account = Account(payable(podOwner)); account.invoke( _eigenPod, 0, abi.encodeWithSelector(IEigenPod.withdrawBeforeRestaking.selector) ); }",
        "labels": [
            "SlowMist",
            "StakeStone - Restaking",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Incorrect function call target",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - StakeStone - Restaking_en-us.pdf",
        "body": "In the EigenNativeRestakingStrategy contract, the nalizeWithdrawingNode function is used to complete the nal withdrawal request and transfer the ETH from the podOwner contract back into this contract. In this case, getting the ETH for the cancellation of the stake is done by calling the claimDelayedWithdrawals function to claim the ETH back to podOwner However, in eigenlayer's protocol, claimDelayedWithdrawals are present in the DelayedWithdrawalRouter contract and not in the eigenPod contract. In the nalizeWithdrawingNode function, the eigenPod contract is called instead, and this incorrect call will cause the nal claim operation to fail. Code Location: contracts/strategies/eigen/EigenNativeRestakingStrategy.sol#L171-190 function finalizeWithdrawingNode( uint256 _nodeAmount, address _eigenPod ) external onlyGovernance { address podOwner = eigenPodOwners[_eigenPod]; require(podOwner != address(0), \"EigenPod not exist\"); Account account = Account(payable(podOwner)); account.invoke( _eigenPod, 0, abi.encodeWithSelector( IEigenPod.claimDelayedWithdrawals.selector, type(uint256).max ) ); account.invoke(address(this), podOwner.balance, \"\"); withdrawingNodeAmount -= _nodeAmount; } contracts/interfaces/IEigenPod.sol function claimDelayedWithdrawals( uint256 maxNumberOfDelayedWithdrawalsToClaim ) external;",
        "labels": [
            "SlowMist",
            "StakeStone - Restaking",
            "Type: Others",
            "Severity: High"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - StakeStone - Restaking_en-us.pdf",
        "body": "In the EigenNativeRestakingStrategy contract, the Governance role can set the address of the new eigenPodManager by calling the setNewEigenPodManager function and can directly modify the values of the pendingNodeAmount, activeNodeAmount, and withdrawingNodeAmount by calling the nalizePendingNode and unstakeFromNodeOperators functions. If the privilege is lost or misused, this may have an impact on the user's assets. Code Location: contracts/strategies/eigen/EigenNativeRestakingStrategy.sol function finalizePendingNode(uint256 _nodeAmount) external onlyGovernance { pendingNodeAmount -= _nodeAmount; activeNodeAmount += _nodeAmount; } function unstakeFromNodeOperators( uint256 _nodeAmount ) external onlyGovernance { activeNodeAmount -= _nodeAmount; withdrawingNodeAmount += _nodeAmount; } ... function setNewEigenPodManager( address _eigenPodManager ) external onlyGovernance { emit SetNewEigenPodManager(eigenPodManager, _eigenPodManager); eigenPodManager = _eigenPodManager; }",
        "labels": [
            "SlowMist",
            "StakeStone - Restaking",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Authority transfer enhancement",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - StakeStone - Restaking_en-us.pdf",
        "body": "In the Account contract, the admin role does not adopt the pending and access processes. If the admin is incorrectly set, the permission will be lost. Code Location: contracts/strategies/eigen/Account.sol#L26-29 function transferAdmin(address _admin) public { require(msg.sender == admin, \"not admin\"); admin = _admin; }",
        "labels": [
            "SlowMist",
            "StakeStone - Restaking",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing event record",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - StakeStone - Restaking_en-us.pdf",
        "body": "The following functions in several contracts are for event logging of key parameter settings. Code Location: contracts/strategies/eigen/Account.sol#L26-29 function transferAdmin(address _admin) public { ... } contracts/strategies/eigen/EigenNativeRestakingStrategy.sol function finalizePendingNode(uint256 _nodeAmount) external onlyGovernance { ... } function unstakeFromNodeOperators( uint256 _nodeAmount ) external onlyGovernance { ... }",
        "labels": [
            "SlowMist",
            "StakeStone - Restaking",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Incorrect whitelist check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap - CrossChain_en-us.pdf",
        "body": "In the CrossFarmingVault contract, the owner can add a new pool through the add function and check if it is in the whitelist. However, the non-whitelisted pool is allowed to enter by mistake, but the whitelisted pool cannot be successfully added. ",
        "labels": [
            "SlowMist",
            "PancakeSwap - CrossChain",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Redundant balance checks",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap - CrossChain_en-us.pdf",
        "body": "In the CrossFarmingVault contract, the owner can add a new pool through the add function and check whether the balance of the LP tokens added in the current contract is greater than or equal to 0. In theory, the balance of each account will be greater than or equal to 0, so this check is redundant. ",
        "labels": [
            "SlowMist",
            "PancakeSwap - CrossChain",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Gas optimization",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap - CrossChain_en-us.pdf",
        "body": "In the CrossFarmingVault contract, the deposit, withdraw and emergencyWithdraw functions use low-level calls to make external function calls, which will consume more gas than using the interface method. The same is true for the executeMessage function in the CrossFarmingReceiver contract. 11 ",
        "labels": [
            "SlowMist",
            "PancakeSwap - CrossChain",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Potential fake mining risk",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap - CrossChain_en-us.pdf",
        "body": "In the protocol, if the user's deposit in the src chain is successful, but the deposit in the dest chain fails, the operator role can return the LP tokens to the user through the fallbackDeposit function. However, if the user successfully deposits in the dest chain, but the operator role still triggers the fallbackDeposit function to refund, this will cause the user to still receive CAKE token rewards in the dest chain. 13 ",
        "labels": [
            "SlowMist",
            "PancakeSwap - CrossChain",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Incorrect function state",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap - CrossChain_en-us.pdf",
        "body": "In the CrossFarmingVault, the calcFee function is used to calculate the fee required for the message cross-chain, and the encodeMessage function is used to encode the message. Both can use the view function. ",
        "labels": [
            "SlowMist",
            "PancakeSwap - CrossChain",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Inappropriate exchange rate decimal",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap - CrossChain_en-us.pdf",
        "body": "In the CrossFarmingSender contract, the exchange rate is obtained by multiplying the BNB price by EXCHANGE_RATE_PRECISION and dividing the ETH price. In the future, if the price of ETH is greater than 1e5 times the price of BNB, the result of this algorithm will be 0. ",
        "labels": [
            "SlowMist",
            "PancakeSwap - CrossChain",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Redundant payable label",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap - CrossChain_en-us.pdf",
        "body": "In the CrossFarmingSender and CrossFarmingReceiver contract, the claimFee function user transfers the native tokens in the contract, so this function does not need the payable label. ",
        "labels": [
            "SlowMist",
            "PancakeSwap - CrossChain",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Potential duplicate deposit and withdrawal issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap - CrossChain_en-us.pdf",
        "body": "In the protocol, the deposit function of CrossFarmingProxy is indirectly triggered by SGN's MessageBus to make deposits for users. If SGN repeatedly executes the message due to failure, the message of the same nonce will be executed multiple times.",
        "labels": [
            "SlowMist",
            "PancakeSwap - CrossChain",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Allowance depletion issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap - CrossChain_en-us.pdf",
        "body": "In the CrossFarmingProxy contract, the deposit function is used to deposit LP tokens into the MASTER_CHEF_V2 contract. MASTER_CHEF_V2 will be approved before depositing, and approved[lpToken] will be set to true after approval, and will never be approved again in the future. Although the approved amount is uint256, the allowance may still be exhausted in the future, and after the allowance is exhausted, it will no longer be possible to approve. This will make the proxy contract unavailable. ",
        "labels": [
            "SlowMist",
            "PancakeSwap - CrossChain",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Incorrect interface call",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap - CrossChain_en-us.pdf",
        "body": "In the executeMessage function of the CrossFarmingReceiver contract, when the msgType is Withdraw and EmergencyWithdraw, the sender contract that is not deployed in the BSC chain is called by mistake. ",
        "labels": [
            "SlowMist",
            "PancakeSwap - CrossChain",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Gas optimization",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Starcrazy_en-us.pdf",
        "body": "Using assert in the contract will consume all the Gas. ",
        "labels": [
            "SlowMist",
            "Starcrazy",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Overow reminder",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Starcrazy_en-us.pdf",
        "body": "There are many places in the contract that do not use safe-math for operations, which may cause overow.",
        "labels": [
            "SlowMist",
            "Starcrazy",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Hardcoded reminders",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Starcrazy_en-us.pdf",
        "body": "The address in the contract is hardcoded and cannot be modied. ",
        "labels": [
            "SlowMist",
            "Starcrazy",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Return value not checked",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Starcrazy_en-us.pdf",
        "body": "The _depositFrom function calls the insert function to insert data. There is a return value in the insert function but the return value is not checked when it is called. ",
        "labels": [
            "SlowMist",
            "Starcrazy",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Authority control issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Starcrazy_en-us.pdf",
        "body": "The CEO has the right to modify the address of the genScience contract. If the modied genScience contract is an unaudited contract, there may be security risks. ",
        "labels": [
            "SlowMist",
            "Starcrazy",
            "Type: Authority Control Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "lack of authorization",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Starcrazy_en-us.pdf",
        "body": "49 In the AlianaMinting contract, the CEO has the right to call the withdrawsByCEO function (this function will calculate the reward) and emergencyWithdrawByCEO function (this function will not calculate the reward) to withdraw the tokens for the user without the user's authorization, and the withdrawn tokens will be in the same way returned to the user. ",
        "labels": [
            "SlowMist",
            "Starcrazy",
            "Type: Authority Control Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Business logic issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Starcrazy_en-us.pdf",
        "body": "The receiveApproval function exists in multiple contracts. The function is public and can be called by anyone. Anyone can use these functions to manipulate other users' assets, as long as the user has an authorization limit to the contract. However, this authorization limit is not set by the user. The authorization limit for each transaction of the user is calculated o-chain by the project team. The code here is not within the scope of this audit, so we will not be able to guarantee the security here. If there is an error in the calculation of the authorization limit.Anyone can call the receiveApproval function to deposit any user's tokens without authorization. ",
        "labels": [
            "SlowMist",
            "Starcrazy",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Redundant code",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Starcrazy_en-us.pdf",
        "body": "The require check for the action parameter in the following function is redundant. The location of redundant code will be marked with (//Slowmist// Redundant code here). ",
        "labels": [
            "SlowMist",
            "Starcrazy",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Parameter modication issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Starcrazy_en-us.pdf",
        "body": "The NFT in the project can be auctioned, and the CEO has the right to modify some sensitive parameters in the auction information, which will aect the results of the auction. ",
        "labels": [
            "SlowMist",
            "Starcrazy",
            "Type: Authority Control Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Missing event record",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Starcrazy_en-us.pdf",
        "body": "Events are not logged when sensitive parameters are modied in several places in the contract. ",
        "labels": [
            "SlowMist",
            "Starcrazy",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing event record",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - CheersUp_en-us.pdf",
        "body": "Modifying sensitive parameters in contracts lacks corresponding event records. function setProvenance(string memory provenance_) external onlyOwner { provenance = provenance_; } function setCUCPContractAddress(address address_) public onlyOwner { cucpContractAddress = address_; } function setWhitelistSaleConfig(WhitelistSaleConfig calldata config_) external onlyOwner { require(config_.price > 0, \"sale price must greater than zero\"); whitelistSaleConfig = config_; } function setPublicSaleConfig(PublicSaleConfig calldata config_) external onlyOwner { require(config_.price > 0, \"sale price must greater than zero\"); publicSaleConfig = config_; } function setRevealConfig(RevealConfig calldata config_) external onlyOwner { revealConfig = config_; }",
        "labels": [
            "SlowMist",
            "CheersUp",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Access control issue 9",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - CheersUp_en-us.pdf",
        "body": "The Owner role has the right to call the giveaway function to airdrop any number of blind boxes to any address at any time. function giveaway(address address_, uint64 numberOfTokens_) external onlyOwner nonReentrant { require(address_ != address(0), \"zero address\"); require(numberOfTokens_ > 0, \"invalid number of tokens\"); require(totalMinted() + numberOfTokens_ <= MAX_TOKEN, \"max supply exceeded\"); _safeMint(address_, numberOfTokens_); } The Owner role has the right to modify the cucpContractAddress contract address through the setCUCPContractAddress function, and unauthorized modication will result in the user's blind box being unable to be opened or arbitrarily modifying the blind box. function setCUCPContractAddress(address address_) public onlyOwner { cucpContractAddress = address_; } The Owner role has the right to modify the price of the blind box purchased by the user through the setWhitelistSaleCong function and the setPublicSaleCong function at any time. If the price of the blind box is modied after the sale starts, the user's transaction will fail. function setWhitelistSaleConfig(WhitelistSaleConfig calldata config_) external onlyOwner { require(config_.price > 0, \"sale price must greater than zero\"); whitelistSaleConfig = config_; } function setPublicSaleConfig(PublicSaleConfig calldata config_) external onlyOwner { require(config_.price > 0, \"sale price must greater than zero\"); publicSaleConfig = config_; } 10 The Owner has the right to modify the revealCong parameter through the setRevealCong function, which includes the address of the contract that opens the blind box, and the time and closing time of the blind box sale. function setRevealConfig(RevealConfig calldata config_) external onlyOwner { revealConfig = config_; }",
        "labels": [
            "SlowMist",
            "CheersUp",
            "Type: Authority Control Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Random number problem",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - CheersUp_en-us.pdf",
        "body": "The tokenId in the contract is related to the properties of the NFT. The tokenId is randomly generated through the random number on the chain, which will cause the random number to be predicted. function mint(address address_, uint256 cucpTokenId_) public returns(uint256) { require(_msgSender() == cucpContractAddress, \"not authorized\"); require(_numberMinted + 1 <= MAX_TOKEN, \"mint would exceed max supply\"); uint256 tokenId = randomToken(address_); _safeMint(address_, tokenId); unchecked { _numberMinted += 1; 11 } emit CheersUpRevealed(cucpTokenId_, tokenId); return tokenId; } function randomToken(address address_) internal returns (uint256) { unchecked { uint totalSize = MAX_TOKEN - _numberMinted; uint index = uint(keccak256(abi.encodePacked(_numberMinted, address_, block.difficulty, block.timestamp))) % totalSize; uint value = 0; if (randIndices[index] != 0) { value = randIndices[index]; } else { value = index; } if (randIndices[totalSize - 1] == 0) { randIndices[index] = totalSize - 1; } else { randIndices[index] = randIndices[totalSize - 1]; } return value; } }",
        "labels": [
            "SlowMist",
            "CheersUp",
            "Type: Others",
            "Severity: Low"
        ]
    },
    {
        "title": "Incorrect variable used in Staked event emission",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - IoTeX - SystemStaking_en-us.pdf",
        "body": "In the emit statement of the Staked event, it is observed that the msgValue variable is used to emit the amount of the stake, which is not correct. The correct variable to use is _amount. function stake( uint256 _amount, uint256 _duration, bytes12 _delegate, uint256 _count ) external payable whenNotPaused returns (uint256 firstTokenId_) { uint256 msgValue = msg.value; require(_count > 0 && _amount * _count == msgValue, \"invalid parameters\"); uint256 index = _bucketTypeIndex(_amount, _duration); _assertOnlyActiveBucketType(index); unchecked { firstTokenId_ = __currTokenId + 1; } for (uint256 i = 0; i < _count; i = unsafeInc(i)) { _stake(index, _delegate); emit Staked(firstTokenId_ + i, _delegate, msgValue, _duration); //SlowMist// msgValue should be _amount } return firstTokenId_; }",
        "labels": [
            "SlowMist",
            "IoTeX - SystemStaking",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Using the transfer function to transfer ETH may cause assets to be locked.",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - IoTeX - SystemStaking_en-us.pdf",
        "body": "transfer use a xed gas limit (2300). Plus, User can not transfer there bucket token once they unstake. If the recipient is a contract and implement a fallback function which used more than 2300 gas, then user can suer from lock of fund. src/SystemStaking.sol 93: _recipient.transfer(_amount); 593: _recipient.transfer(amount - fee_); User can not transfer there bucket token once they unstake. function _beforeTokenTransfer( address _from, address _to, uint256 _firstTokenId, uint256 _batchSize ) internal override { require(_batchSize == 1, \"batch transfer is not supported\"); require( _to == address(0) || !_isTriggered(__buckets[_firstTokenId].unstakedAt), \"cannot transfer unstaked token\" ); super._beforeTokenTransfer(_from, _to, _firstTokenId, _batchSize); }",
        "labels": [
            "SlowMist",
            "IoTeX - SystemStaking",
            "Type: Unsafe External Call Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - IoTeX - SystemStaking_en-us.pdf",
        "body": "Owner can perform critical functions such as pause , withdrawFee , setEmergencyWithdrawPenaltyRate . This lead to the risk of excessive permissions of the owner role in this two scenario. 1. owner can perform pause , and user can suer from lock of fund 2. owner can frontrun user's emergencyWithdraw and setEmergencyWithdrawPenaltyRate to 100 which can drain out user's fund. ",
        "labels": [
            "SlowMist",
            "IoTeX - SystemStaking",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Default penalty rate can be dangerous",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - IoTeX - SystemStaking_en-us.pdf",
        "body": "We set penalty rate to 100% in constructor . This can conscate all funds of the user as a penalty. constructor() ERC721(\"BucketNFT\", \"BKT\") { _setEmergencyWithdrawPenaltyRate(100); }",
        "labels": [
            "SlowMist",
            "IoTeX - SystemStaking",
            "Type: Others",
            "Severity: Low"
        ]
    },
    {
        "title": "Note on implementation of _isActiveBucketType",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - IoTeX - SystemStaking_en-us.pdf",
        "body": "When passing a non-exist index of bucket type to _isActiveBucketType , the return value will be true . Note that the current implementation _isActiveBucketType is not a problem due to _isActiveBucketType always get index from _bucketTypeIndex which can not return invalid index (index of non-exist bucket type). By xing it we can: 1. Avoid potential problem in future development. 2. Convey the clearer logic required by the specication. function _isActiveBucketType(uint256 _index) internal view returns (bool) { return __bucketTypes[_index].activatedAt <= block.number; }",
        "labels": [
            "SlowMist",
            "IoTeX - SystemStaking",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Particle Vault Contract_en_us.pdf",
        "body": "1.In the Vault contract, the Guardian Or the Governor roles can modify the yieldManager address, the rateMapping , and the positionFeeRate parameters. These parameters can aect the calculation of the yield rate and the recording of principal and yield. ",
        "labels": [
            "SlowMist",
            "Particle Vault Contract_en_us",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "mintFixedRate may fail on the rst call and the yield will be 0",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Particle Vault Contract_en_us.pdf",
        "body": "In the Vault contract, the user can choose between a xed rate strategy and a variable rate strategy for yield by selecting two dierent mint functions. However, the rst time a deposit call is made to mintFixedRate in a Vault contract, the contract is called and updated through a series of eldManager contract deposits before any other principal and yield support is available. At this point, since the rst _updateIdleYield update operation is performed and the getIdleYield function is called to update the controlledIdleYield as well as the principal. but the actual value of these two parameters is 0. This is followed by an update to the prevTimestamp parameter which is the current block.timestamp . In the call path of the mintFixedRate function, the lockedYield is obtained by calling the getYieldToLock function, which in turn calls the getIdleYield function of the yieldManager contract. The lockedYield obtained will then have a lockedYield of 0 due to the previously updated prevTimestamp value, and if the rst user sets the minLockedYield value to greater than 0 on the rst call, then the call will fail. ",
        "labels": [
            "SlowMist",
            "Particle Vault Contract_en_us",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "First opposite strategy mint can gain all yield and fee",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Particle Vault Contract_en_us.pdf",
        "body": "There are two strategies in the project, one is VariableRate and the other is FixedRate, which is a xed rate to get the returns. When the mint is initially done through the FixedRate strategy, the earnings are updated through the _updateIdleYield function and the getIdleYield function. At this point, when a user makes a deposit via VariableRate, there is no record of the update of the variableRatePrincipal.principalTimespan and variableRatePrincipal.principal parameters. The user can then call burnVariableRate immediately after making a deposit to get the yield and principal. At this time, the amountTimespan and the variableRateTotalPrincipalTimespan calculated by the _getVariableRatePortion function are the same, and the yield is the getIdle parameter of getIdlePortion . This means the yield is the total amount calculated by getIdleYield and the total fee is obtained by IERC20(TOKEN).balanceOf(address(this)). Similarly, the reverse situation is also similar, when all the deposits are made by VariableRate in the previous period, the rst time the mint deposit is made by FixedRate, getFixedRate is used. The rst time a mint deposit is made via FixedRate, the xed rate value obtained by getFixedRate will be equal to BASIS , and yieldToLock will be the result of the deposited principal * MATURITY . However, mintFixedRate has a yield limitation, require(lockedYield <= IYieldManager(yieldManager).getIdleYield(), \"Vault: overspend\"); , and if there is insucient existing yield to calculate the resulting lockedYield then the deposit is not supported. Vault.sol#215-263, 275-293 function burnVariableRate( uint256 amount, uint256 minYield ) external override nonReentrant returns (uint256 yield, uint256 fee) { ... require(amount <= principal, \"Vault: overspend\"); variableRatePrincipal.principalTimespan += variableRatePrincipal.principal * // update principal timespan until now first (block.timestamp - variableRatePrincipal.checkpointTimestamp); variableRatePrincipal.checkpointTimestamp = block.timestamp; uint256 amountTimespan; (amountTimespan, yield, fee) = _getVariableRatePortion(msg.sender, amount); ... variableRatePrincipal.principalTimespan -= amountTimespan; variableRatePrincipal.principal -= amount; ... IYieldManager(yieldManager).mintYield(msg.sender, yield); IERC20(TOKEN).safeTransfer(msg.sender, fee); emit BurnVariableRate(msg.sender, amount, yield, fee); } function _getVariableRatePortion(address owner, uint256 amount) internal view returns (uint256 amountTimespan, uint256 yield, uint256 fee) { amountTimespan = amount * (block.timestamp - variableRateTerms[owner].mintTimestamp); uint256 idleYield = IYieldManager(yieldManager).getIdleYield(); uint256 variableRateTotalPrincipalTimespan = variableRatePrincipal.principalTimespan; if (variableRateTotalPrincipalTimespan > 0) { yield = (idleYield * amountTimespan) / variableRateTotalPrincipalTimespan; fee = (IERC20(TOKEN).balanceOf(address(this)) * amountTimespan) / variableRateTotalPrincipalTimespan; } }",
        "labels": [
            "SlowMist",
            "Particle Vault Contract_en_us",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Missing the burn logic in the FixedRateNFT",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Particle Vault Contract_en_us.pdf",
        "body": "In the FixedRateNFT contract, users can call the mint function to deposit to the Vault. It can get an ERC721 NFT and traded on the secondary market. However, the contract has no NFT burn operation in the burn and withdraw functions. That means if the user to withdraw all his principal and yields through the burn and withdraw function, the user can still trade the NFT. And the buyer cannot get the principal and yield from the NFT anymore. ",
        "labels": [
            "SlowMist",
            "Particle Vault Contract_en_us",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Receive can lock users native tokens",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Particle Vault Contract_en_us.pdf",
        "body": "There is a receive function in the WrapMint contract so that the contracts can receive native tokens from the WETH contract. However, the receive function can lock users native tokens when users transfer the native token in these contracts by mistake. ",
        "labels": [
            "SlowMist",
            "Particle Vault Contract_en_us",
            "Type: Others",
            "Severity: Low"
        ]
    },
    {
        "title": "Withdraw can aect the rate and yield",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Particle Vault Contract_en_us.pdf",
        "body": "Throughout the project, the principal is recorded and calculated in 3 parts: VariableRate and FixedRate contracts record the principal deposited by a single user, which is input and output by the Vault contract, and calculate the transformation of the deposits and withdrawals. The Vault contract records and calculates the accumulated deposits and withdrawals of all users in the YieldManager contract. When the Vault contract makes mint and burn rates calls, it updates and recalculates the principal and yield totals stored in the contract. The owner of the VariableRate and FixedRate contracts, i.e., the individual user who made the deposit, can then withdraw the principal directly through the withdraw function in the Emergency situation, and the individual's principal data will not be transferred to the YieldManager contract for updating and calculation through the vault contract. contract for update calculation. The total amount of principal in the program changes after withdrawal, but the total amount of principal recorded in the YieldManager contract remains unchanged, and the calculation of earnings is still based on the total amount of principal withdrawn. Then, in the subsequent accesses by the user, the calculation of the rates and the calculation of the earnings are based on the amount before the withdrawal. Thus, even after the user withdraws the principal, the calculation of the return is still based on the previous total, and the principal in the contract is still the same as before. This is inconsistent with the expected total return and the calculation of rates. ",
        "labels": [
            "SlowMist",
            "Particle Vault Contract_en_us",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing the approve when calling the burnFrom function",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Particle Vault Contract_en_us.pdf",
        "body": "When calling the burnFixedRate function to withdraw the principal and yield of the users. At last, it will call the burnUnmaturedYield function of the yieldManager contract to burn the yieldToBurn yield tokens. It uses the burnFrom function, but there is no approval from the FixedRate contract to the YieldManager contract. ",
        "labels": [
            "SlowMist",
            "Particle Vault Contract_en_us",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Redundant code",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Particle Vault Contract_en_us.pdf",
        "body": "1.In the Vault, deposit users can call the burnFixedRate function to get their principal and yield by their FixdRate contract. In the burnFixedRate function, the input data amount is already checked in the upper-level contract to check if it is less than the user's principal. Therefore, the input amount is always less than or equal to the user's principal. and yieldToUnlock is calculated from (fixedRateTerm.yield * amount)/fixedRateTerm.principal . This means that yieldToUnlock will always be less than or equal to fixedRateTerm.yield . and the value of FixedRate(msg.sender).yield() is initially based on FixedRateTerm.yield , so this means that yieldToBurn will be constant less than the value of yieldToUnlock . this makes require(yieldToBurn <= FixedRate(msg.sender).yield(), \"Vault: overburn yield\"); judgment redundant. ",
        "labels": [
            "SlowMist",
            "Particle Vault Contract_en_us",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing the 0 address/value check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Particle Vault Contract_en_us.pdf",
        "body": "All the addresses and parameters are missing the 0 address and 0 value check in the constructor, and these parameters can not be modied after the parameters' initialization. ",
        "labels": [
            "SlowMist",
            "Particle Vault Contract_en_us",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing the event records",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Particle Vault Contract_en_us.pdf",
        "body": "Guardian, governor, and owner roles can arbitrarily modify EMERGENCY , vault , yieldRate , fixedRateNft , and whitelistedExchanges parameters, but there are no event logs in these functions. ",
        "labels": [
            "SlowMist",
            "Particle Vault Contract_en_us",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Preemptive Initialization",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Particle Vault Contract_en_us.pdf",
        "body": "By calling the initialize and deploy functions to initialize the contracts, there is a potential issue that malicious attackers preemptively call the initialize function to initialize. ",
        "labels": [
            "SlowMist",
            "Particle Vault Contract_en_us",
            "Type: Race Conditions Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "External call reminder",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Particle Vault Contract_en_us.pdf",
        "body": "In the WrapMint contract, there is an external call to the low-level call of the token swap, and the calldata for the call in it is constructed and passed in by an arbitrary user without any checking. Although the target contract of the call, exchange, requires the owner to be the owner of the whitelisted exchanges to be added and removed, there is still a need to pay attention to the security of the external call and the external contract. ",
        "labels": [
            "SlowMist",
            "Particle Vault Contract_en_us",
            "Type: Unsafe External Call Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Successive mint and burn calls to get the yield and fee",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Particle Vault Contract_en_us.pdf",
        "body": "In the VariableRate strategy, users can add or remove principal and rewards at any time via mintVariableRate and burnVariableRate. The VariableRate earnings calculation is to take the user's principal * deposit time than on the VariableRate strategy accumulated principalTimespan integrated ratio multiplied by the total getIdleYield and fee. That means as long as the user's funds in and out of the rewards can be obtained, there is no charge for any fees. ",
        "labels": [
            "SlowMist",
            "Particle Vault Contract_en_us",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of external manipulation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - LightDAO Phase2_en-us.pdf",
        "body": "In the UniswapV2Pair contract, anyone can call the claimLightReward function to claim and deposit the reward belonging to the pair. But the incoming address parameters (lightGomboc, minter, lightToken, gomboc) are externally manipulable, the attacker can construct a malicious external contract (the malicious gomboc contract) to steal the rewards that belong to the pair. ",
        "labels": [
            "SlowMist",
            "LightDAO Phase2",
            "Type: Unsafe External Call Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "The DoS issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - LightDAO Phase2_en-us.pdf",
        "body": "The length of the external array passed in by the user can be controlled. If the length is large, it will cause DoS because of the number of for loops. ",
        "labels": [
            "SlowMist",
            "LightDAO Phase2",
            "Type: Denial of Service Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Token compatibility issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - LightDAO Phase2_en-us.pdf",
        "body": "In the burn function of the LightSwapBurner contract, it will transfer the specied token into this contract through the transferFrom function. If the specied token is a deationary token, the actual number of the token received by the contract is less than the value of the amount parameter passed in by the user. This may cause the subsequent swap operation to fail. ",
        "labels": [
            "SlowMist",
            "LightDAO Phase2",
            "Type: Others",
            "Severity: Low"
        ]
    },
    {
        "title": "Missing slippage check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - LightDAO Phase2_en-us.pdf",
        "body": "In the LightSwapBurner and UnderlyingBurner contract, when performing the burn operation, the swapExactTokensForTokens function will be used to exchange tokens. However, the swapExactTokensForTokens function does not perform a slippage check, which will result in a high probability of being subjected to a sandwich attack by MEV Bot when performing the above operations. This will result in far fewer exchanges than expected, or even very few left. ",
        "labels": [
            "SlowMist",
            "LightDAO Phase2",
            "Type: Reordering Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - LightDAO Phase2_en-us.pdf",
        "body": "In the UniswapV2Factory contract, the feeToSetter role can set the feeRateNumerator through the setFeeRateNumerator function. However, there is no limit to the feeRateNumerator parameter that will be passed in, which can lead to high user fees if it is modied too much. ",
        "labels": [
            "SlowMist",
            "LightDAO Phase2",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Missing zero address check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - LightDAO Phase2_en-us.pdf",
        "body": "1.In the ApprovedTokenManager contract, the owner can add any tokens to the whitelist, but there is a lack of zero address check here, which may aect users' normal transactions if the owner accidentally approves a zero address. ",
        "labels": [
            "SlowMist",
            "LightDAO Phase2",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Redundant code",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - LightDAO Phase2_en-us.pdf",
        "body": "Redundant code for calling the _getPointBalanceOf function. ",
        "labels": [
            "SlowMist",
            "LightDAO Phase2",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing event records",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - LightDAO Phase2_en-us.pdf",
        "body": "1.In the factory contract, the feeToSetter role can set the feeTo, feeToSetter and approvedTokenManager addresses, but there are no event logs. ",
        "labels": [
            "SlowMist",
            "LightDAO Phase2",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Deation token compatibility issues",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - eden-network_en-us.pdf",
        "body": "If the number of deationary token records is smaller than the actual number of receipts, if malicious users continue to deposit and withdraw , the pool of deationary tokens will be exhausted. contracts/RewardsManager.sol function _deposit( uint256 pid, uint256 amount, PoolInfo storage pool, UserInfo storage user ) internal { updatePool(pid); uint256 sushiPid = sushiPools[address(pool.token)]; uint256 pendingSushiTokens = 0; 17 if (user.amount > 0) { uint256 pendingRewards = user.amount * pool.accRewardsPerShare / 1e12 - user.rewardTokenDebt; if (pendingRewards > 0) { _distributeRewards(msg.sender, pendingRewards, pool.vestingPercent, pool.vestingPeriod, pool.vestingCliff, pool.vpForVesting); } if (sushiPid != uint256(0)) { masterChef.updatePool(sushiPid); pendingSushiTokens = user.amount * masterChef.poolInfo(sushiPid).accSushiPerShare / 1e12 - user.sushiRewardDebt; } } pool.token.safeTransferFrom(msg.sender, address(this), amount); pool.totalStaked = pool.totalStaked + amount; user.amount = user.amount + amount; //SlowMist Incompatible with deflationary currencies user.rewardTokenDebt = user.amount * pool.accRewardsPerShare / 1e12; if (sushiPid != uint256(0)) { masterChef.updatePool(sushiPid); user.sushiRewardDebt = user.amount * masterChef.poolInfo(sushiPid).accSushiPerShare / 1e12; masterChef.deposit(sushiPid, amount); } if (amount > 0 && pool.vpForDeposit) { lockManager.grantVotingPower(msg.sender, address(pool.token), amount); } if (pendingSushiTokens > 0) { _safeSushiTransfer(msg.sender, pendingSushiTokens); } emit Deposit(msg.sender, pid, amount); }",
        "labels": [
            "SlowMist",
            "eden-network",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - eden-network_en-us.pdf",
        "body": "These functions may cause the project party to take away the tokens pledged by the user in the pool. contracts/RewardsManager.sol function setMasterChef(address newAddress) external onlyOwner { emit ChangedAddress(\"MASTER_CHEF\", address(masterChef), newAddress); masterChef = IMasterChef(newAddress); } function setVault(address newAddress) external onlyOwner { emit ChangedAddress(\"VAULT\", address(vault), newAddress); vault = IVault(newAddress); } function setLockManager(address newAddress) external onlyOwner { emit ChangedAddress(\"LOCK_MANAGER\", address(lockManager), newAddress); lockManager = ILockManager(newAddress); } function rescueTokens( address[] calldata tokens, uint256[] calldata amounts, address receiver ) external onlyOwner { require(tokens.length == amounts.length, \"RM::rescueTokens: not same length\"); for (uint i = 0; i < tokens.length; i++) { IERC20Extended token = IERC20Extended(tokens[i]); uint256 withdrawalAmount; uint256 tokenBalance = token.balanceOf(address(this)); uint256 tokenAllowance = token.allowance(address(this), receiver); if (amounts[i] == 0) { if (tokenBalance > tokenAllowance) { withdrawalAmount = tokenAllowance; 19 } else { withdrawalAmount = tokenBalance; } } else { require(tokenBalance >= amounts[i], \"RM::rescueTokens: contract balance too low\"); require(tokenAllowance >= amounts[i], \"RM::rescueTokens: increase token allowance\"); withdrawalAmount = amounts[i]; } token.safeTransferFrom(address(this), receiver, withdrawalAmount); } }",
        "labels": [
            "SlowMist",
            "eden-network",
            "Type: Authority Control Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Payments Contract Deation token compatibility issues",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - eden-network_en-us.pdf",
        "body": "If it is a deationary currency, the actual number of tokens received at this time is less than the incoming amount. contracts/Payments.sol function _createPayment( address token, address payer, address receiver, uint48 startTime, uint256 amount, uint256 paymentDurationInSecs, uint16 cliffDurationInDays ) internal { // Transfer the tokens under the control of the payment contract IERC20(token).safeTransferFrom(payer, address(this), amount); uint48 paymentStartTime = startTime == 0 ? uint48(block.timestamp) : startTime; // Create payment Payment memory payment = Payment({ token: token, receiver: receiver, payer: payer, startTime: paymentStartTime, stopTime: 0, paymentDurationInSecs: paymentDurationInSecs, cliffDurationInDays: cliffDurationInDays, amount: amount,// SlowMist Incompatible with deflationary currencies amountClaimed: 0 }); tokenPayments[numPayments] = payment;//SlowMist Incompatible with deflationary currencies paymentIds[receiver].push(numPayments); emit PaymentCreated(token, payer, receiver, numPayments, amount, paymentStartTime, paymentDurationInSecs, cliffDurationInDays); 21 // Increment payment id numPayments++; }",
        "labels": [
            "SlowMist",
            "eden-network",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "User voting rights are lost",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - eden-network_en-us.pdf",
        "body": "This is an externally called function. There may be a risk of LOCKER_ROLE removing the voting rights of locked users in batches. contracts/Vault.sol function claimAllUnlockedTokens(uint256[] memory locks) external { for (uint i = 0; i < locks.length; i++) { uint256 claimableAmount = claimableBalance(locks[i]); require(claimableAmount > 0, \"Vault::claimAllUnlockedTokens: claimableAmount is 0\"); _claimTokens(locks[i], claimableAmount); } } function _claimTokens(uint256 lockId, uint256 claimAmount) internal { Lock storage lock = tokenLocks[lockId]; uint256 votingPowerRemoved; // Remove voting power, if exists if (lock.votingPower > 0) { votingPowerRemoved = lockManager.removeVotingPower(lock.receiver, lock.token, claimAmount); lock.votingPower = lock.votingPower - votingPowerRemoved; 22 } // Update claimed amount lock.amountClaimed = lock.amountClaimed + claimAmount; // Release tokens IERC20Permit(lock.token).safeTransfer(lock.receiver, claimAmount); emit UnlockedTokensClaimed(lock.receiver, lock.token, lockId, claimAmount, votingPowerRemoved); }",
        "labels": [
            "SlowMist",
            "eden-network",
            "Type: Others",
            "Severity: Medium"
        ]
    },
    {
        "title": "Out of gas in the loop",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - eden-network_en-us.pdf",
        "body": "The delegate is an external function. If too many producers are added by malicious calls, it will cause the execution of delegateBatch and cause out of gas in the loop. contracts/DistributorGovernance.sol /// @notice Only addresses with delegator role or block producer modifier onlyDelegatorOrProducer(address producer) { require(hasRole(DELEGATOR_ROLE, msg.sender) || msg.sender == producer, \"must be producer or delegator\"); _;//SlowMist If msg.sender = producer is satisfied, the judgment can be passed } function delegate(address producer, address collector) external onlyDelegatorOrProducer(producer) { rewardCollector[producer] = collector; emit BlockProducerRewardCollectorChanged(producer, collector); 23 } function delegateBatch(address[] memory producers, address[] memory collectors) external onlyDelegator { require(producers.length == collectors.length, \"length mismatch\"); for(uint i; i< producers.length; i++) { rewardCollector[producers[i]] = collectors[i]; emit BlockProducerRewardCollectorChanged(producers[i], collectors[i]); } }",
        "labels": [
            "SlowMist",
            "eden-network",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "The new variable is not assigned",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - eden-network_en-us.pdf",
        "body": "newCliffDuration This variable was not stored at the end. contracts/LockManager.sol function extendLock(uint256 lockId, uint16 vestingDaysToAdd, uint16 cliffDaysToAdd) external { Lock storage lock = tokenLocks[lockId]; require(msg.sender == lock.receiver, \"Vault::extendLock: msg.sender must be receiver\"); uint16 oldVestingDuration = lock.vestingDurationInDays; uint16 newVestingDuration = _add16(oldVestingDuration, vestingDaysToAdd, \"Vault::extendLock: vesting max days exceeded\"); uint16 oldCliffDuration = lock.cliffDurationInDays; uint16 newCliffDuration = _add16(oldCliffDuration, cliffDaysToAdd, \"Vault::extendLock: cliff max days exceeded\");//SlowMist newCliffDuration This variable was not stored at the end require(newCliffDuration <= 10*365, \"Vault::extendLock: cliff more than 10 years\"); require(newVestingDuration <= 25*365, \"Vault::extendLock: vesting duration 24 more than 25 years\"); require(newVestingDuration >= newCliffDuration, \"Vault::extendLock: duration < cliff\"); lock.vestingDurationInDays = newVestingDuration; emit LockExtended(lockId, oldVestingDuration, newVestingDuration, oldCliffDuration, newCliffDuration, lock.startTime); }",
        "labels": [
            "SlowMist",
            "eden-network",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Restrictions can be bypassed",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - eden-network_en-us.pdf",
        "body": "When existingBidAmount and existingSlotBalance are 0 . bid >= MIN_BID This condition can be bypassed. contracts/EdenNetwork.sol function _claimSlot(uint8 slot, uint128 bid, address delegate) internal { require(delegate != address(0), \"cannot delegate to 0 address\"); Bid storage currentBid = slotBid[slot]; uint128 existingBidAmount = currentBid.bidAmount; uint128 existingSlotBalance = slotBalance(slot); uint128 taxedBalance = existingBidAmount - existingSlotBalance; require((existingSlotBalance == 0 && bid >= MIN_BID) || bid >= existingBidAmount * 110 / 100, \"bid too small\");//slowmist uint128 bidderLockedBalance = lockedBalance[msg.sender]; uint128 bidIncrement = currentBid.bidder == msg.sender ? bid - existingSlotBalance : bid; if (bidderLockedBalance > 0) { if (bidderLockedBalance >= bidIncrement) { lockedBalance[msg.sender] -= bidIncrement; } else { lockedBalance[msg.sender] = 0; token.transferFrom(msg.sender, address(this), bidIncrement - 25 bidderLockedBalance); } } else { token.transferFrom(msg.sender, address(this), bidIncrement); } if (currentBid.bidder != msg.sender) { lockedBalance[currentBid.bidder] += existingSlotBalance; } if (taxedBalance > 0) { token.burn(taxedBalance); } _slotOwner[slot] = msg.sender; _slotDelegate[slot] = delegate; currentBid.bidder = msg.sender; currentBid.periodStart = uint64(block.timestamp); currentBid.bidAmount = bid; currentBid.taxNumerator = taxNumerator; currentBid.taxDenominator = taxDenominator; slotExpiration[slot] = uint64(block.timestamp + uint256(taxDenominator) * 86400 / uint256(taxNumerator)); emit SlotClaimed(slot, msg.sender, delegate, bid, existingBidAmount, taxNumerator, taxDenominator); }",
        "labels": [
            "SlowMist",
            "eden-network",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - eden-network_en-us.pdf",
        "body": "26 Since most of the contract settings only need to be modied by the admin, they can take eect immediately. If the admin address is hacked, it will cause some serious consequences. For example: contracts/VotingPowerPrism.sol The admin has the authority to modify the pointed logical contract immediately. It may cause abnormal voting rights after the admin address is stolen. contracts/EdenNetworkProxy.sol The admin has the authority to modify the pointed logical contract immediately. It may cause the loss of the token of the contract address after the admin address is stolen. contracts/TokenRegistry.sol If the admin address is hacked, you can also modify the TokenFormula immediately. This will cause abnormal voting rights.",
        "labels": [
            "SlowMist",
            "eden-network",
            "Type: Authority Control Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Did not check whether the pair exists",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - O3 swap_en-us.pdf",
        "body": "The _swapSupportingFeeOnTransferTokens function of the O3swapBSCPancakeBridge / O3swapETHUniswapBridge / O3swapHecoMdexBridge contract did not verify the existence of the pair, which caused the exchange to fail function _swapSupportingFeeOnTransferTokens(address[] memory path, address _to) internal virtual { for (uint i; i < path.length - 1; i++) { (address input, address output) = (path[i], path[i + 1]); (address token0,) = PancakeLibrary.sortTokens(input, output); //SlowMist// There is no check to see if the pair exists, which causes the exchange to fail 18 IPancakePair pair = IPancakePair(PancakeLibrary.pairFor(pancakeFactory, input, output)); uint amountInput; uint amountOutput; { // scope to avoid stack too deep errors (uint reserve0, uint reserve1,) = pair.getReserves(); (uint reserveInput, uint reserveOutput) = input == token0 ? (reserve0, reserve1) : (reserve1, reserve0); amountInput = IBEP20(input).balanceOf(address(pair)).sub(reserveInput); amountOutput = PancakeLibrary.getAmountOut(amountInput, reserveInput, reserveOutput); } (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0)); address to = i < path.length - 2 ? PancakeLibrary.pairFor(pancakeFactory, output, path[i + 2]) : _to; pair.swap(amount0Out, amount1Out, to, new bytes(0)); } }",
        "labels": [
            "SlowMist",
            "O3 swap",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Excessive permissions",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - O3 swap_en-us.pdf",
        "body": "The collect function of the O3 staking contract can transfer any tokens in the contract, including the users assets. There is a problem of excessive authority. It is recommended to limit the token != stakingToken function collect(address token, address to) external nonReentrant onlyOwner _logs_ { //SlowMist// Excessive authority issues, should be restricted token != staking Token uint balance = IERC20(token).balanceOf(address(this)); _pushToken(token, to, balance); }",
        "labels": [
            "SlowMist",
            "O3 swap",
            "Type: Authority Control Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Preemptive Initialization",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Doubler - 20240117.pdf",
        "body": "contracts/FRNFT.sol This function has the problem of being preempted. function initialize(address doublerPool) external { require(_initialized == false, \"initialized err\"); _initialized = true; _doublerPool = doublerPool; _grantRole(DOUBLER_ROLE, doublerPool); } contracts/Doubler.sol This function has the problem of being preempted. function initialize( address _initTeam, address _initEco, address _initFastPriceFeed, address _initDoublerNFT, address _initDbrTokenAddress, address _initMultiSigWallet, uint16 _initProtectBlock ) external { if (_initialized == true) revert E_Initialized(); _initialized = true; _team = _initTeam; _eco = _initEco; _fastPriceFeed = _initFastPriceFeed; _FRNFT = _initDoublerNFT; _ecoFeeRatio = 2000; // 20% * 100 _feeRatio = 20; // 0.2% * 100 _protectBlock = _initProtectBlock; _grantRole(DEFAULT_ADMIN_ROLE, _initMultiSigWallet); emit Initialize(_initTeam, _initFastPriceFeed, _initDoublerNFT, _initDbrTokenAddress, _initMultiSigWallet); }",
        "labels": [
            "SlowMist",
            "Doubler - 20240117",
            "Type: Race Conditions Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Doubler - 20240117.pdf",
        "body": "contracts/FastPriceFeed.sol The admin role can be set to price related, if the private key leakage will cause the price anomaly caused by the pool function is impaired. admin can newAsset admin can updatePriceAggregator admin can upgradePlan admin can setTwapInterval",
        "labels": [
            "SlowMist",
            "Doubler - 20240117",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Pool depth and TWAP interval in uniswap V3 price queries",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Doubler - 20240117.pdf",
        "body": "contracts/FastPriceFeed.sol When getting the price of the token, you should pay attention to the depth of the corresponding pool, if the depth of the pool is too shallow and the price range is set too low, there is still a possibility of price manipulation. function getPriceFromDex(address _asset) internal view returns (uint256 price) { require(_isSupported[_asset], 'UniV3: oracle in mainnet not initialized yet!'); address uniswapV3Pool = _assetFeedMap[_asset]; uint32 twapInterval = _twapIntervals[_asset]; IUniswapV3Pool pool = IUniswapV3Pool(uniswapV3Pool); IUniswapV3Pool.Slot0 memory slot0; IUniswapV3Pool.Observation memory obs; slot0 = pool.slot0(); obs = pool.observations((slot0.observationIndex + 1) % slot0.observationCardinality); require(obs.initialized, \"UNIV3: Pair did't initialized\"); uint32 delta = uint32(block.timestamp) - obs.blockTimestamp; require(delta >= twapInterval, 'UniV3: token pool does not have enough transaction history in mainnet'); uint32[] memory secondsAgos = new uint32[](2); secondsAgos[0] = twapInterval; secondsAgos[1] = 0; (int56[] memory tickCumulatives, ) = pool.observe(secondsAgos); uint160 sqrtPriceX96 = TickMath.getSqrtRatioAtTick( int24((tickCumulatives[1] - tickCumulatives[0]) / int56(uint56(twapInterval))) ); (uint256 price0, uint256 price1) = mockDexPrice(pool, sqrtPriceX96); return pool.token0() == _asset ? price0 : price1; }",
        "labels": [
            "SlowMist",
            "Doubler - 20240117",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Recommendations on the conditions of winner",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Doubler - 20240117.pdf",
        "body": "contracts/Doubler.sol In some extreme cases, it may be possible to control the nal winner.",
        "labels": [
            "SlowMist",
            "Doubler - 20240117",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Suggestions for setTwapInterval",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Doubler - 20240117.pdf",
        "body": "contracts/FastPriceFeed.sol It should be a supported token to set the interval. function setTwapInterval(address _asset, uint32 _twapInterval) external onlyRole(DEFAULT_ADMIN_ROLE) { require(!_isSupported[_asset], 'Oracle: do not support this token'); require(_plans[_asset] == Plan.DEX, \"setTwapInterval: Only dex _asset\"); require( MAX_INTERVA >= _twapIntervals[_asset] && _twapIntervals[_asset] >= MIN_INTERVA, 'setTwapInterval: Invalid twapInterval' ); emit SetTwapInterval(_asset, _twapIntervals[_asset], _twapInterval); _twapIntervals[_asset] = _twapInterval; }",
        "labels": [
            "SlowMist",
            "Doubler - 20240117",
            "Type: Others",
            "Severity: Low"
        ]
    },
    {
        "title": "Redundant code",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Doubler - 20240117.pdf",
        "body": "contracts/Doubler.sol The hot in the structure is not used. struct Pool { address asset; address creator; address terminator; uint16 fallRatio; uint16 profitRatio; uint16 rewardRatio; uint16 winnerRatio; uint32 double; uint32 lastLayer; uint256 tokenId; uint256 unitSize; uint256 maxRewardUnits; uint256 winnerOffset; uint256 endPrice; uint256 hot; //SLOWMIST// unused uint256 lastOpenPrice; uint256 tvl; uint256 amount; uint256 margin; uint256 joins; uint256 lastInputBlockNo; uint256 kTotal; }",
        "labels": [
            "SlowMist",
            "Doubler - 20240117",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Function permission control issues",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Doubler - 20240117.pdf",
        "body": "contracts/FRNFT.sol The roles used by these functions are not set and cannot be executed subsequently. setTokenRoyalty resetTokenRoyalty setDefaultRoyaltyInfo deleteDefaultRoyalty",
        "labels": [
            "SlowMist",
            "Doubler - 20240117",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Overlooking purchase price relative to target prot in pool ending logic",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Doubler - 20240117.pdf",
        "body": "contracts/Doubler.sol The scenario where the purchase price is less than or equal to the target prot price has not been considered. When the price at the time of purchase is less than or equal to the target prot price, the purchase should not be allowed. Otherwise, users can manipulate the ending of the pool after purchasing to position themselves as the winner. function _input(AddInput memory _addInput, uint8 _decimals) internal returns (uint256 tokenId) { Pool memory pool = _poolMap[_addInput.poolId]; if (_addInput.margin == 0 || _addInput.margin > _addInput.amount || _addInput.margin.mod(pool.unitSize) != 0) revert E_Margin(); if (IERC20(pool.asset).allowance(_msgSender(), address(this)) < _addInput.margin) revert E_Approve(); if (IERC20(pool.asset).balanceOf(_msgSender()) < _addInput.margin) revert E_Balance(); if (_addInput.multiple < 1 || _addInput.margin.mul(_addInput.multiple) != _addInput.amount) revert E_Multiple(); if (_addInput.multiple > 1 && _addInput.multiple > _getMaxMultiple(pool, _addInput.curPrice, _decimals)) revert E_MultipleLimit(); _addInput.layer = _getLastLayer(_addInput.poolId, _addInput.curPrice, _addInput.amount); LayerData memory layer = _layerDataMap[_addInput.poolId][_addInput.layer]; if (layer.amount >= layer.cap) revert E_LayerCap(); if (layer.cap.sub(layer.amount) < _addInput.margin) { _addInput.margin = _addInput.amount = layer.cap.sub(layer.amount); } else { _addInput.amount = layer.cap.sub(layer.amount) < _addInput.amount ? layer.cap.sub(layer.amount) : _addInput.amount; } IERC20(pool.asset).safeTransferFrom(_msgSender(), address(this), _addInput.margin); uint256 layerAmount = _addTvl(_addInput); uint256 layerRanking = layerAmount.div(pool.unitSize); tokenId = IFRNFT(_FRNFT).mint( _msgSender(), _addInput.poolId, _addInput.layer, _addInput.margin, _addInput.amount, _addInput.curPrice, layerRanking ); emit NewInput( tokenId, _addInput.poolId, _msgSender(), _addInput.layer, _addInput.margin, _addInput.amount, _addInput.curPrice ); }",
        "labels": [
            "SlowMist",
            "Doubler - 20240117",
            "Type: Others",
            "Severity: High"
        ]
    },
    {
        "title": "Potential Token Compatibility Issues",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/STONE BTC - SlowMist Audit Report_en-us.pdf",
        "body": "In the StoneBTCVault contract, users can deposit funds through the deposit/depositMultiple functions. The contract directly transfers the user-specied amount of wrapped BTC tokens using the safeTransferFrom function. It is important to note that the contract is not compatible with fee-on-transfer wrapped BTC tokens. Similarly, when users make deposits or withdrawals, the contract performs decimal conversion using 18- tokenDecimals[_token] . This renders the contract incompatible with any wrapped BTC tokens that have a decimal greater than 18. ",
        "labels": [
            "SlowMist",
            "STONE BTC - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Potential risk of not being able to collect fees",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/STONE BTC - SlowMist Audit Report_en-us.pdf",
        "body": "In the StoneBTCVault contract, users are charged a certain fee when making deposits or withdrawals. The fee amount is determined by amount * feeRate / FEE_BASE . Due to Solidity's division operation truncating the decimal part, if the user's deposit or withdrawal amount is relatively small, the calculated fee will be 0. This prevents the contract from collecting deposit/withdrawal fees. ",
        "labels": [
            "SlowMist",
            "STONE BTC - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Unnecessary unchecked",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/STONE BTC - SlowMist Audit Report_en-us.pdf",
        "body": "In the StoneBTCVault contract, all the for loop functionalities use unchecked for incrementing i to reduce gas consumption. However, the contract's Solidity compilation uses ^0.8.26 , and Solidity introduced the unchecked loop increments feature in version 0.8.22, making the use of unchecked unnecessary. ",
        "labels": [
            "SlowMist",
            "STONE BTC - SlowMist Audit Report",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of DoS when removing supported tokens",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/STONE BTC - SlowMist Audit Report_en-us.pdf",
        "body": "In the StoneBTCVault contract, privileged roles can add/remove supported wrapped BTC tokens through the addSupportedTokens/removeSupportedTokens functions. When performing the removeSupportedTokens operation, the contract checks that the balance of the token being removed must be zero. This can be easily exploited, as users can donate a small amount of tokens to prevent the removeSupportedTokens function from working properly. It is also important to note that when users withdraw, the contract converts the decimal to the decimal of the token being withdrawn. When the decimal of this token is smaller than the decimal of STONE BTC, there will always be a small amount of dust tokens left in the vault. This indirectly prevents the removeSupportedTokens function from working correctly. ",
        "labels": [
            "SlowMist",
            "STONE BTC - SlowMist Audit Report",
            "Type: Denial of Service Vulnerability",
            "Severity: High"
        ]
    },
    {
        "title": "The actual deposit amount may dier from the contract balance",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/STONE BTC - SlowMist Audit Report_en-us.pdf",
        "body": "In the StoneBTCVault contract, the _checkDepositAllowed function checks the depositCapacity based on the balance of wrapped BTC tokens in the contract. Similarly, the getDepositAmounts function retrieves token balances to determine the deposit amounts. These values may dier from the actual deposit amounts made by users. Users might accidentally transfer supported tokens into the vault, or some users might send small donations to the vault. Both scenarios will cause the above two functions to obtain amounts that are greater than the users' actual deposit amounts. ",
        "labels": [
            "SlowMist",
            "STONE BTC - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Not checking if withAmount is greater than 0 when retrieving all tokens",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/STONE BTC - SlowMist Audit Report_en-us.pdf",
        "body": "In the Proposal contract, users can retrieve all their STONE tokens used for voting through the retrieveAllToken function. It uses a temporary variable withAmount to record the amount of STONE tokens that can be withdrawn. However, it does not check if withAmount is greater than 0 before initiating the transfer, which may result in the contract sending a 0 transfer and wasting gas. ",
        "labels": [
            "SlowMist",
            "STONE BTC - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risks of excessive privilege",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/STONE BTC - SlowMist Audit Report_en-us.pdf",
        "body": "In the StoneBTC contract, the contract deployer is set as the DEFAULT_ADMIN_ROLE. The admin role can arbitrarily change the MINTER_ROLE/BURNER_ROLE roles, which are involved in minting and burning STONE BTC. This leads to the risk of excessive privileges. Similarly, in the StoneBTCVault and Proposal contracts, the initial DEFAULT_ADMIN_ROLE is also the deployer. Assigning sensitive permissions to an EOA address not only creates the risk of excessive privileges but also introduces a single point of failure. ",
        "labels": [
            "SlowMist",
            "STONE BTC - SlowMist Audit Report",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Code x situation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Penpie Contracts Exploit Fixes - SlowMist Audit Report_en-us.pdf",
        "body": "In the x, the project team used OpenZeppelin's ReentrancyGuard library to modify the harvestMarketReward and batchHarvestMarketRewards functions in the PendleStaking contract to address the issue of reentering depositMarket. Additionally, they restricted the registerPool function in the PendleStaking contract to be callable only by the owner role to ensure that newly registered pools are reviewed. ",
        "labels": [
            "SlowMist",
            "Penpie Contracts Exploit Fixes - SlowMist Audit Report",
            "Type: Others",
            "Severity: Information"
        ]
    },
    {
        "title": "Potential denial of service risk due to gulp operations",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase5 - SlowMist Audit Report_en-us.pdf",
        "body": "In the Actions contract, when the user performs the autoJoinSmartPool operation, the number of shares the user can obtain will be calculated through the _calculateShare function, and minPoolAmountOut will be checked at the end. The _calculateShare function obtains the number of tokens recorded in the pool through bPool's getBalance when calculating the share, but unfortunately any user can update this parameter through bPool's gulp function. Therefore, when an ordinary user performs an autoJoinSmartPool operation, a malicious user directly transfers funds to bPool and calls the gulp function to update the token balance recorded in the pool. At this time, ordinary users will not be able to successfully add liquidity due to the minPoolAmountOut check. If the minPoolAmountOut value passed in by an ordinary user is 0, it may cause an interest rate ination attack. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase5 - SlowMist Audit Report",
            "Type: Denial of Service Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Incorrect event logging",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase5 - SlowMist Audit Report_en-us.pdf",
        "body": "In the CRP contract, the createPool function adds the creator parameter as the real creator of the pool. However, the corresponding events were not modied accordingly. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase5 - SlowMist Audit Report",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Incorrect WETH address",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase5 - SlowMist Audit Report_en-us.pdf",
        "body": "The WETH address constant is hard-coded in the Actions contract, but this address is an EOA address on the Ethereum mainnet and is not the correct WETH address. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase5 - SlowMist Audit Report",
            "Type: Others",
            "Severity: High"
        ]
    },
    {
        "title": "Incorrect poolTokens check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase5 - SlowMist Audit Report_en-us.pdf",
        "body": "In the autoJoinSmartPool function of the Actions contract, it checks the tokens deposited by the user through poolTokens[i] == handleToken , but handleToken has been replaced by the issueToken parameter during the native token checking phase. Therefore, the poolTokens[i] == handleToken check is not accurate. If handleToken is WETH, it will cause an error in the _makeSwap operation. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase5 - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Redundant STBT token check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase5 - SlowMist Audit Report_en-us.pdf",
        "body": "In the autoJoinSmartPool and _exit functions of the Actions contract, when making a token transfer, it will be checked whether the transferred token is an STBT token. But in fact, the protocol does not allow deposits of STBT tokens, and STBT tokens will also be converted into stablecoins after the ETF expires. Therefore, theoretically, there will be no STBT tokens in the contract, so the STBT token check is redundant. . ",
        "labels": [
            "SlowMist",
            "DeSyn Phase5 - SlowMist Audit Report",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Potential risk of slot conict",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase5 - SlowMist Audit Report_en-us.pdf",
        "body": "In this protocol iteration, both SmartPoolManager and Actions contracts have changed their storage structures. If these contracts use an upgradeable model, and upgrading the contract directly on the original basis may lead to contract storage slot conicts. In fact, the Actions contract is an upgradeable contract, so special attention should be paid to such risks.",
        "labels": [
            "SlowMist",
            "DeSyn Phase5 - SlowMist Audit Report",
            "Type: Variable Coverage Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of event forgery",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase5 - SlowMist Audit Report_en-us.pdf",
        "body": "In the CRP contract, the exitPool function adds a user parameter to record the real caller when the user exits through the Actions contract. However, users can also exit by calling the exitPool function of the CRP contract. They can pass in any user parameter to make the LogExit event record an incorrect value. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase5 - SlowMist Audit Report",
            "Type: Malicious Event Log Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Potential risk of denial of service due to large CRPFactory array",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase5 - SlowMist Audit Report_en-us.pdf",
        "body": "In the CRPFactory contract, when the Blabs role performs addCRPFactory and removeCRPFactory operations, it will use a for loop to traverse the entire CRPFactorys array. If the array length is too large, it will lead to DoS risks. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase5 - SlowMist Audit Report",
            "Type: Denial of Service Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Potential risk of endless loop",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase5 - SlowMist Audit Report_en-us.pdf",
        "body": "In the CRPFactory contract, the isCrp function is used to check whether the address passed by the user is a CRP contract. If not, the CRPFactorys array will be circulated and the isCrp function of other CRPFactory will be called to check. However, it should be noted that if the Blabs role adds this contract address to the CRPFactorys array, the user will fall into an innite loop error when querying a CRP address that is not recorded in this contract through the isCrp function. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase5 - SlowMist Audit Report",
            "Type: Denial of Service Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Redundant collectEndTime check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report_en-us.pdf",
        "body": "In the CongurableRightsPool contract, users can redeem underlying assets through the exitPool function. When the pool is a closed ETF, it will check isCompletedCollect and collectEndTime to decide whether to perform _claimManagerFee operation. But when isCompletedCollect is true, the collectEndTime check will be performed in snapshotEndAssets, and when isCompletedCollect is false, the collectEndTime check will be performed in exitPoolHandleB. Hence the collectEndTime check before the _claimManagerFee operation is redundant. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Redundant closureEndTime check on exitPool",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report_en-us.pdf",
        "body": "In the CongurableRightsPool contract, users can redeem underlying assets through the exitPool function. When the pool is a closed ETF and isCloseEtfCollectEndWithFailure is false, it will check that the current time must be greater than closureEndTime + 5 minutes before allowing the user to exit. However, it should be noted that the snapshotEndAssets operation will be performed before this. The snapshotEndAssets function will also check whether the current time is greater than closureEndTime + 5 minutes . Only the admin and owner can execute snapshotEndAssets within 5 minutes after the closure period ends. Otherwise, the transaction will be reverted. Therefore, the closureEndTime check in the exitPool function is redundant. When snapshotEndAssets cannot be performed, the entire transaction will be reverted, and subsequent closureEndTime checks will not be performed. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Redundant performance fee calculation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report_en-us.pdf",
        "body": "In the exitPool function of the CongurableRightsPool contract, redeemAndPerformanceFeeReceived, nalAmountOut and redeemFeeReceived are calculated through exitPoolHandleA. However, since the performance fee will be calculated uniformly in the snapshotEndAssets operation, there is no need to process the performance fee in the exitPool function. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "The time allowed for snapshots is too short",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report_en-us.pdf",
        "body": "In the CongurableRightsPool contract when the closed ETF completes collect and the collection period has ended, the current total value of the ETF can be recorded through the snapshotBeginAssets function. However, users can only call the snapshotBeginAssets function within 15 minutes after the end of the collection period. If there is congestion on the chain, it may not be possible to call the snapshot in time within 15 minutes. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Duplicate decimal processing issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report_en-us.pdf",
        "body": "In the DesynChainlinkOracle contract, the getPrice function is used to obtain the corresponding token price from prices, getChainlinkPrice, and getUniswapPrice, and perform decimal processing. However, decimal has been processed in getChainlinkPrice and getUniswapPrice, and theoretically, the returned decimal will be 1e18. Therefore, processing decimals through decimalDelta will cause decimals to be enlarged. Note that the amountIn passed in for the consult in the getUniswapPrice function is 1e18, which needs to be ensured that the token decimal in twapOracle matches it in practice ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Decimal processing issue in AllPrice calculation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report_en-us.pdf",
        "body": "In the DesynChainlinkOracle contract, the getAllPrice function is used to calculate the total value of the specied amount of tokens. It is calculated by badd(fundAll, bmul(getPrice(t), tokenAmountOut)) , theoretically the decimal returned by getPrice is 1e18, and the decimal of tokenAmountOut is consistent with the decimal of the token itself. Therefore, multiplying these two values will result in a very large decimal in the nal result. The getNormalizedWeight function is also aected by this, but this is not harmful to normal business. Note: ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Redundant code issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report_en-us.pdf",
        "body": "In the SmartPoolManager library, the exitPoolHandle function has been deprecated since closed ETF prots are calculated in snapshotEndAssets. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Token list conict in recordTokenInfo",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report_en-us.pdf",
        "body": "When the user performs createPool and joinPool, if the Pool is a closed ETF and the current time is within the collection period, the KOL invitation amount will be recorded through UserVault's recordTokenInfo interface. But unfortunately, the tokens in the Pool can be Bind/unBind at any time, which will cause the list of tokens supported by the Pool to change. If the recordTokenInfo operation is performed when the Pool token list changes, the amount recorded by variables such as poolInviteTotal, kolTotalAmountList, and kolUserInfo may be disturbed. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "couldManagerClaim not checked when managerClaim",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report_en-us.pdf",
        "body": "In the UserVault contract, the Manager role can claim management fees through the managerClaim function, but it does not check whether the couldManagerClaim parameter is true. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Some redundant invoke functions",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report_en-us.pdf",
        "body": "In the Invoke library, the strictInvokeTransfer, invokeUnwrapWETH, invokeWrapWETH, and invokeMint functions are not used. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of ETF falsication",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report_en-us.pdf",
        "body": "In the RebalanceAdapter contract, the Manager role can adjust the position of the pool through the rebalance function. But the address of the ETF is obtained from the rebalanceInfo passed in by the user. If a malicious user passes in a fake ETF, the check in the onlyManager decorator will be bypassed, and the _verifyWhiteToken check of token1 and the isCompletedCollect and collectEndTime checks will be useless. Malicious users can steal bPool funds through _makeSwap and bind malicious tokens. The approve function also has this risk, but it doesn't break the protocol too much ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Risk of the Manager role potentially disrupting the protocol",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report_en-us.pdf",
        "body": "In the RebalanceAdapter contract, the Manager role can adjust the position of the ETF through the rebalance function. It will use the _makeSwap function to call Uniswap, 1inch and other DEXs for token swaps to adjust token positions. But unfortunately, the swap path of the token is not checked during the token swap process, which will cause the Manager role to pass in a carefully constructed malicious swap path to steal the middle token0 of the ETF. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Double slippage check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report_en-us.pdf",
        "body": "In the RebalanceAdapter contract, the Manager role can adjust the position of the ETF through the rebalance function. It will use the _makeSwap function to call Uniswap, 1inch and other DEXs for token swaps to adjust token positions. During the swap process, the slippage will be checked by passing minReturn to the external DEXs, but the implementation of the slippage check of the external DEXs is uncontrollable. If the slippage protection of the external DEXs fails, it will aect the funds of users in the protocol. (1inch users encountered invalid slippage check before) ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Does not follow the Checks-Eects-Interactions specication",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report_en-us.pdf",
        "body": "In the RebalanceAdapter contract, the _makeSwap function is used for token swap. When the swap type is not UNISWAPV3 and UNISWAPV2, the parameters passed in by the user will be checked through _validateData . However, the execute operation is performed rst, and the _validateData operation is performed after the token exchange is completed. This is not in line with the follow the Checks-Effects-Interactions principle. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Perform strict parameter checking",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report_en-us.pdf",
        "body": "In the RebalanceAdapter contract, the _validateData function is used to check the exchange parameters, but it only parses the recipient and amountIn for checking, but does not check whether other key parameters such as srcToken, dstToken, clipperExchange, makerAsset, takerAsset are in line with expectations. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Redundant aggregator parameter",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report_en-us.pdf",
        "body": "In the RebalanceAdapter contract, the _validateData function is used to check the conversion parameters, but the aggregator parameter it receives is not used. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Incorrect approval operation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report_en-us.pdf",
        "body": "In the RebalanceAdapter contract, the Manager role can adjust the position of the ETF through the rebalance function. If token1 has not been bound in bPool, it will be approved rst. However, the subsidy of this contract was wrongly approved to bPool, which will cause bPool to be unable to transfer tokens from CRP in the future. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report_en-us.pdf",
        "body": "There is an execute function in the CRP and bPool contracts so that the Manager can manage the ETF. In bFactory, the Blabs role can arbitrarily register modules to gain control over CRP. The registered modules can use the execute function in CRP to call the execute function in bPool to perform any operations. This would pose a huge risk to users' funds. And the Manager can approve the tokens in the bPool through the approve function of the RebalanceAdapter contract, which will also bring huge risks to the user's funds. The above problems lead to the risk of excessive permissions of the Blabs role and the Manager role. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Authority Control Vulnerability Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Enforce strict permission controls",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report_en-us.pdf",
        "body": "In the LiquidityPool contract, any user can call the joinPool, exitPool, and gulp functions to add/remove liquidity/record token balances, which will make it impossible to charge various fees to users in CRP. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Missing zero address check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Kayak-UniswapV3-Contract.pdf",
        "body": "1.In the KayakSwapRouter contract, the constructor function lacks a zero address check for the _WETH parameter. contracts/swaprouter/KayakSwapRouter.sol#L67-L69 constructor(address _WETH) { weth = IWETH(_WETH); } 2.In the KayakSwapRouter contract, the swap function lacks a zero address check for the params.pool parameter. contracts/swaprouter/KayakSwapRouter.sol#L113-L141 function swap(SwapParams calldata params) public payable nonReentrant returns (uint256 returnAmount) { ``` if (params.flag) { _swapOnStableSwap(params.srcToken, params.dstToken, params.pool, receivedAmount); } else { _swapOnV3ExactIn(params.srcToken, params.dstToken, params.pool, receivedAmount); } ``` } 3.In the KayakSwapQuoter contract, the constructor function lacks a zero address check for the _WETH parameter. contracts/swaprouter/KayakSwapQuoter.sol#L34-L36 constructor(address _WETH) { weth = IWETH(_WETH); } 4.In the KayakSwapQuoter contract, the getReturnStableSwap function and getReturnUniswapV3 function lack a zero address check for the pool parameter. contracts/swaprouter/KayakSwapQuoter.sol#L87-L103, L105-L130 function getReturnStableSwap( address srcToken, address dstToken, address pool, uint256 amount ) public view returns (uint256 returnAmount) { ``` uint256 n_coins = IStableSwap(pool).N_COINS(); ``` } function getReturnUniswapV3( address srcToken, address dstToken, address pool, uint256 amount ) public returns (uint256 returnAmount) { ``` IUniswapV3Pool(pool).swap( ``` ) ``` }",
        "labels": [
            "SlowMist",
            "Kayak-UniswapV3-Contract",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "The identity of msg.sender is not veried",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Kayak-UniswapV3-Contract.pdf",
        "body": "In the KayakSwapRouter contract, the uniswapV3SwapCallback function does not verify whether msg.sender is a valid Uniswap V3 Pool. When there are assets in the contract, the attacker can construct malicious parameters and transfer any assets in the contract through the uniTransfer function called in the uniswapV3SwapCallback function. contracts/swaprouter/KayakSwapRouter.sol#L187-L197 function uniswapV3SwapCallback(int256 amount0Delta, int256 amount1Delta, bytes calldata _data) external { require(amount0Delta > 0 || amount1Delta > 0); // swaps entirely within 0- liquidity regions are not supported SwapCallbackData memory data = abi.decode(_data, (SwapCallbackData)); (address tokenIn, address tokenOut, , ) = data.path.decodeFirstPool(); (, uint256 amountToPay) = amount0Delta > 0 ? (tokenIn < tokenOut, uint256(amount0Delta)) : (tokenOut < tokenIn, uint256(amount1Delta)); IERC20(tokenIn).uniTransfer(msg.sender, amountToPay); }",
        "labels": [
            "SlowMist",
            "Kayak-UniswapV3-Contract",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Unchecked return value",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Kayak-UniswapV3-Contract.pdf",
        "body": "In the UniERC20 library, the uniApprove function did not check the return value when calling the approve function. contracts/swaprouter/libraries/UniERC20.sol#L68-L72 function uniApprove(IERC20 token, address to, uint256 amount) internal { if (isETH(token)) return; token.approve(to, amount); }",
        "labels": [
            "SlowMist",
            "Kayak-UniswapV3-Contract",
            "Type: Others",
            "Severity: Low"
        ]
    },
    {
        "title": "Redundant code",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Kayak-UniswapV3-Contract.pdf",
        "body": "In the KayakSwapQuoter contract, amountOutCached is not used. contracts/swaprouter/KayakSwapQuoter.sol#L22 uint256 private amountOutCached;",
        "labels": [
            "SlowMist",
            "Kayak-UniswapV3-Contract",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Insucient ETH balance causes the function to be unavailable",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Kayak-UniswapV3-Contract.pdf",
        "body": "In the KayakSwapQuoter contract, the purpose of the getReturnUniswapV3 function is to return the number of tokens that can be exchanged in the UniswapV3 pool, so there is no need to call the weth.deposit function to exchange WETH. Calling the weth.deposit function will fail because the contract does not have enough ETH balance and subsequent operations cannot be performed, which will make the function unusable. contracts/swaprouter/KayakSwapQuoter.sol function getReturnUniswapV3( address srcToken, address dstToken, address pool, uint256 amount ) public returns (uint256 returnAmount) { if (IERC20(srcToken).isETH()) { weth.deposit{ value: amount }(); } address srcTokenReal = IERC20(srcToken).isETH() ? address(weth) : srcToken; address dstTokenReal = IERC20(dstToken).isETH() ? address(weth) : dstToken; bool zeroForOne = srcTokenReal < dstTokenReal; try IUniswapV3Pool(pool).swap( address(this), // address(0) might cause issues with some tokens zeroForOne, amount.toInt256(), zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1, abi.encodePacked(srcTokenReal, dstTokenReal, pool, false) ) {} catch (bytes memory reason) { return parseRevertReason(reason); } }",
        "labels": [
            "SlowMist",
            "Kayak-UniswapV3-Contract",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "External dependency changes may cause logic failure",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Kayak-UniswapV3-Contract.pdf",
        "body": "In the KayakSwapQuoter contract, the parseRevertReason function can parse the error information returned by UniswapV3Pool. If the Uniswap V3 contract interface or error return format changes, it may cause errors in error message parsing. contracts/swaprouter/KayakSwapQuoter.sol#L133-L142 function parseRevertReason(bytes memory reason) private pure returns (uint256) { if (reason.length != 32) { if (reason.length < 68) revert(\"Unexpected error\"); assembly { reason := add(reason, 0x04) } revert(abi.decode(reason, (string))); } return abi.decode(reason, (uint256)); }",
        "labels": [
            "SlowMist",
            "Kayak-UniswapV3-Contract",
            "Type: Others",
            "Severity: Information"
        ]
    },
    {
        "title": "Returns incorrect swap result",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Kayak-UniswapV3-Contract.pdf",
        "body": "In the KayakSwapQuoter contract, the getReturnStableSwap function and getReturnUniswapV3 function do not verify whether the pool contract is the correct address. If the user passes in a malicious contract address, an incorrect exchange result may be returned. contracts/swaprouter/KayakSwapQuoter.sol#L87-L103, L105-L130 function getReturnStableSwap( address srcToken, address dstToken, address pool, uint256 amount ) public view returns (uint256 returnAmount) { address[] memory tokens = new address[](3); uint256 n_coins = IStableSwap(pool).N_COINS(); tokens[0] = IStableSwap(pool).coins(uint256(0)); tokens[1] = IStableSwap(pool).coins(uint256(1)); if (n_coins == 3) { tokens[2] = IStableSwap(pool).coins(uint256(2)); } uint256 i = (srcToken == tokens[0] ? 1 : 0) + (srcToken == tokens[1] ? 2 : 0) + (srcToken == tokens[2] ? 3 : 0); uint256 j = (dstToken == tokens[0] ? 1 : 0) + (dstToken == tokens[1] ? 2 : 0) + (dstToken == tokens[2] ? 3 : 0); return IStableSwap(pool).get_dy(i - 1, j - 1, amount); } function getReturnUniswapV3( address srcToken, address dstToken, address pool, uint256 amount ) public returns (uint256 returnAmount) { if (IERC20(srcToken).isETH()) { weth.deposit{ value: amount }(); } address srcTokenReal = IERC20(srcToken).isETH() ? address(weth) : srcToken; address dstTokenReal = IERC20(dstToken).isETH() ? address(weth) : dstToken; bool zeroForOne = srcTokenReal < dstTokenReal; try IUniswapV3Pool(pool).swap( address(this), // address(0) might cause issues with some tokens zeroForOne, amount.toInt256(), zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1, abi.encodePacked(srcTokenReal, dstTokenReal, pool, false) ) {} catch (bytes memory reason) { return parseRevertReason(reason); } }",
        "labels": [
            "SlowMist",
            "Kayak-UniswapV3-Contract",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Kayak-UniswapV3-Contract.pdf",
        "body": "In the UniswapV3Factory contract, the owner role can transfer owner permissions and set feeAmountTickSpacing mapping. contracts/core/UniswapV3Factory.sol#L54-L58, L61-L72 function setOwner function enableFeeAmount",
        "labels": [
            "SlowMist",
            "Kayak-UniswapV3-Contract",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Redundant authorization operations",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Kayak-UniswapV3-Contract.pdf",
        "body": "In the KayakSwapRouter contract, the _swapOnV3ExactIn function calls the uniApprove function to authorize the pool contract, but in the uniswapV3SwapCallback function, the uniTransfer function is called to pay the tokenIn token, and the uniTransferFrom function is not used, so the authorized amount will continue to exist and accumulate. If the pool contract is a malicious contract, this authorization operation may cause the assets in the KayakSwapRouter contract to be transferred away. contracts/swaprouter/KayakSwapRouter.sol#L162-L185, L187-L197 function _swapOnV3ExactIn(address srcToken, address dstToken, address pool, uint256 amount) internal { ``` IERC20(srcTokenReal).uniApprove(payable(pool), amount); ``` } function uniswapV3SwapCallback(int256 amount0Delta, int256 amount1Delta, bytes calldata _data) external { ``` IERC20(tokenIn).uniTransfer(msg.sender, amountToPay); }",
        "labels": [
            "SlowMist",
            "Kayak-UniswapV3-Contract",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Potential denial of service risk due to gulp operations",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase5_en-us.pdf",
        "body": "In the Actions contract, when the user performs the autoJoinSmartPool operation, the number of shares the user can obtain will be calculated through the _calculateShare function, and minPoolAmountOut will be checked at the end. The _calculateShare function obtains the number of tokens recorded in the pool through bPool's getBalance when calculating the share, but unfortunately any user can update this parameter through bPool's gulp function. Therefore, when an ordinary user performs an autoJoinSmartPool operation, a malicious user directly transfers funds to bPool and calls the gulp function to update the token balance recorded in the pool. At this time, ordinary users will not be able to successfully add liquidity due to the minPoolAmountOut check. If the minPoolAmountOut value passed in by an ordinary user is 0, it may cause an interest rate ination attack. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase5",
            "Type: Denial of Service Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Incorrect event logging",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase5_en-us.pdf",
        "body": "In the CRP contract, the createPool function adds the creator parameter as the real creator of the pool. However, the corresponding events were not modied accordingly. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase5",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Incorrect WETH address",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase5_en-us.pdf",
        "body": "The WETH address constant is hard-coded in the Actions contract, but this address is an EOA address on the Ethereum mainnet and is not the correct WETH address. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase5",
            "Type: Others",
            "Severity: High"
        ]
    },
    {
        "title": "Incorrect poolTokens check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase5_en-us.pdf",
        "body": "In the autoJoinSmartPool function of the Actions contract, it checks the tokens deposited by the user through poolTokens[i] == handleToken , but handleToken has been replaced by the issueToken parameter during the native token checking phase. Therefore, the poolTokens[i] == handleToken check is not accurate. If handleToken is WETH, it will cause an error in the _makeSwap operation. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase5",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Redundant STBT token check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase5_en-us.pdf",
        "body": "In the autoJoinSmartPool and _exit functions of the Actions contract, when making a token transfer, it will be checked whether the transferred token is an STBT token. But in fact, the protocol does not allow deposits of STBT tokens, and STBT tokens will also be converted into stablecoins after the ETF expires. Therefore, theoretically, there will be no STBT tokens in the contract, so the STBT token check is redundant. . ",
        "labels": [
            "SlowMist",
            "DeSyn Phase5",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Potential risk of slot conict",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase5_en-us.pdf",
        "body": "In this protocol iteration, both SmartPoolManager and Actions contracts have changed their storage structures. If these contracts use an upgradeable model, and upgrading the contract directly on the original basis may lead to contract storage slot conicts. In fact, the Actions contract is an upgradeable contract, so special attention should be paid to such risks.",
        "labels": [
            "SlowMist",
            "DeSyn Phase5",
            "Type: Variable Coverage Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of event forgery",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase5_en-us.pdf",
        "body": "In the CRP contract, the exitPool function adds a user parameter to record the real caller when the user exits through the Actions contract. However, users can also exit by calling the exitPool function of the CRP contract. They can pass in any user parameter to make the LogExit event record an incorrect value. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase5",
            "Type: Malicious Event Log Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Potential risk of denial of service due to large CRPFactory array",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase5_en-us.pdf",
        "body": "In the CRPFactory contract, when the Blabs role performs addCRPFactory and removeCRPFactory operations, it will use a for loop to traverse the entire CRPFactorys array. If the array length is too large, it will lead to DoS risks. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase5",
            "Type: Denial of Service Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Potential risk of endless loop",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase5_en-us.pdf",
        "body": "In the CRPFactory contract, the isCrp function is used to check whether the address passed by the user is a CRP contract. If not, the CRPFactorys array will be circulated and the isCrp function of other CRPFactory will be called to check. However, it should be noted that if the Blabs role adds this contract address to the CRPFactorys array, the user will fall into an innite loop error when querying a CRP address that is not recorded in this contract through the isCrp function. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase5",
            "Type: Denial of Service Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Debug functions buer oset stack overow",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ccToken.pdf",
        "body": "There is no check to see if oset exceeds the size of debug_buer. If data_len is too large, it may cause a stack overow. contracts/c/common.h static void debug_print_data_impl(const char *prefix, const uint8_t *data, uint32_t data_len) { int offset = 0; offset += sprintf_(debug_buffer, \"%s\", prefix); for (size_t i = 0; i < data_len; i++) { offset += sprintf_(debug_buffer + offset, \"%02x\", data[i]); } debug_buffer[offset] = '\\0'; ckb_debug(debug_buffer); } static void debug_print_int_impl(const char *prefix, int ret) { int offset = 0; offset += sprintf_(debug_buffer, \"%s(%d)\", prefix, ret); debug_buffer[offset] = '\\0'; ckb_debug(debug_buffer); } static void debug_print_string_impl(const char *prefix, const uint8_t *data, uint32_t data_len) { int offset = 0; offset += sprintf_(debug_buffer, \"%s\", prefix); for (size_t i = 0; i < data_len; i++) { offset += sprintf_(debug_buffer + offset, \"%c\", data[i]); } debug_buffer[offset] = '\\0'; ckb_debug(debug_buffer); }",
        "labels": [
            "SlowMist",
            "ccToken",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "char2hex Logic error",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ccToken.pdf",
        "body": "This function assumes that the input hexChar is a valid hexadecimal character, but does not check if the character is in the valid range. If the input hexChar is an illegal character, the result of the calculation will be wrong. For example, entering 'G' or 'H' will result in undesired output. Also, the function only handles hexadecimal characters with uppercase letters ('A' through 'F'), but hexadecimal characters also include lowercase letters ('a' through 'f'). contracts/c/utils.h char char2hex(char hexChar) { char tmp; if(hexChar<='9') { tmp = hexChar-'0'; } else if(hexChar<='F') { tmp = hexChar-'7'; } else { tmp = hexChar-'W'; } return tmp; }",
        "labels": [
            "SlowMist",
            "ccToken",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ccToken.pdf",
        "body": "Custodian has the following unlock permissions: update_merchants confirm_mint reject_mint confirm_burn reject_burn Merchant has the following unlock permissions: update_merchants Request mint Request burn",
        "labels": [
            "SlowMist",
            "ccToken",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "simple_udt should check the size of the input and output amounts",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ccToken.pdf",
        "body": "simple_udt should check the size of the input and output amounts. contracts/c/tx_parser.h int simple_udt(uint128_t *ia, uint128_t *oa) { //... *ia = input_amount; *oa = output_amount; return CKB_SUCCESS; }",
        "labels": [
            "SlowMist",
            "ccToken",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Missing array bounds checking",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ccToken.pdf",
        "body": "Accessing data[0] and data[1...] without boundary checking may result in an array out-of-bounds error. without boundary checking may result in an array out-of-bounds error. libs/core/src/data_parser/cong_cell.rs pub fn parse(data: Vec<u8>) -> Result<(u8, Vec<(ConfigKey, Vec<u8>)>), CoreError> { let version = data[0]; let mut configs = vec![]; match version { 0 => { let config_mol = BytesVec::from_compatible_slice(&data[1..]).map_err(|_| CoreError::ParseCellDataFailed { //... } The code does not check if the input args and data are of sucient length. Direct access to args[0] and data[0] may result in out-of-bounds access, which can trigger a crash. libs/core/src/data_parser/governance_member_cell.rs pub fn parse_type_args(args: Vec<u8>) -> Result<(GovernanceMemberRole, Vec<u8>), CoreError> { let role = GovernanceMemberRole::try_from(args[0]).map_err(|_| CoreError::ParseCellDataFailed { cell_name: String::from(\"GovernanceMemberCell\"), msg: format!(\"Unknown role value {}\", args[0]), })?; let cell_id = (&args[1..]).to_vec(); //... Ok((role, cell_id)) } pub fn parse_data(data: Vec<u8>) -> Result<(u8, GovernanceMembers), CoreError> { let version = data[0]; //... GovernanceMembers::from_compatible_slice(&data[1..]).map_err(|_| CoreError::ParseCellDataFailed { //... } libs/core/src/data_parser/tick_cell.rs pub fn parse_data(data: Vec<u8>) -> Result<(u8, Tick), CoreError> { let version = data[0]; //... tick = Tick::from_compatible_slice(&data[1..]).map_err(|_| CoreError::ParseCellDataFailed { //... Ok((version, tick)) } libs/core/src/veriers/permission.rs pub fn verify_input_has_deploy_lock(index: usize) -> Result<(), CoreError> { //... cc_assert!(cells[0] == index, CoreError::DeployLockIsRequired { index }); Ok(()) } pub fn verify_input_has_owner_lock(index: usize) -> Result<(), CoreError> { //... cc_assert!(cells[0] == index, CoreError::OwnerLockIsRequired { index }); Ok(()) }",
        "labels": [
            "SlowMist",
            "ccToken",
            "Type: Others",
            "Severity: Low"
        ]
    },
    {
        "title": "Avoid unnecessary memory copies",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ccToken.pdf",
        "body": "Function arguments can accept slice references (&[u8]) instead of ownership (Vec), which avoids unnecessary memory copies. libs/core/src/data_parser/cong_cell.rs pub fn parse(data: Vec<u8>) -> Result<(u8, Vec<(ConfigKey, Vec<u8>)>), CoreError> { //... } libs/core/src/data_parser/governance_member_cell.rs pub fn parse_type_args(args: Vec<u8>) -> Result<(GovernanceMemberRole, Vec<u8>), CoreError> { //... } pub fn parse_data(data: Vec<u8>) -> Result<(u8, GovernanceMembers), CoreError> { //... } libs/core/src/data_parser/tick_cell.rs pub fn parse_data(data: Vec<u8>) -> Result<(u8, Tick), CoreError> { //... } libs/core/src/util.rs pub fn get_tx_action() -> Result<Action, CoreError> { //... let version_byte = witness[0]; //... let action_bytes = &witness[1..]; //... }",
        "labels": [
            "SlowMist",
            "ccToken",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Ambiguous error handling",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ccToken.pdf",
        "body": "Use the warn! log to record potential parsing errors, which is not uncommon in smart contracts, without explicitly indicating whether the error should be interrupted or accepted. libs/core/src/data_parser/cong_cell.rs pub fn parse(data: Vec<u8>) -> Result<(u8, Vec<(ConfigKey, Vec<u8>)>), CoreError> { //... let key = match ConfigKey::try_from(u32::from_le_bytes(key_bytes)) { Ok(key) => key, Err(_) => { warn!( \"[{}] Parse [0..4]({}) to config key failed, the key is removed or not defined.\", i, hex_string(key_bytes.as_ref()) ); continue; } }; //... } Ok((version, configs)) }",
        "labels": [
            "SlowMist",
            "ccToken",
            "Type: Others",
            "Severity: Low"
        ]
    },
    {
        "title": "Missing system shutdown status check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ccToken.pdf",
        "body": "When the system is processing the shutdown state, all other features except conguration should be disabled, including disabling the following features: init_governance update_owner update_custodians update_merchants confirm_mint reject_mint confirm_burn reject_burn Currently only the request function request for token minting and destruction checks if the system is disabled.",
        "labels": [
            "SlowMist",
            "ccToken",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "It is recommended to use the encapsulated method",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ccToken.pdf",
        "body": "A wrapped lock validation function already exists, and reusing it improves the readability of the code. contracts/cong-cell-type/src/entry.rs fn verify_output_lock(index: usize) -> Result<(), Box<dyn AsI8>> { //... lock.as_slice() == owner_lock.as_slice(), //... Ok(()) }",
        "labels": [
            "SlowMist",
            "ccToken",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap_v3_en-us.pdf",
        "body": "In the StableSwapRouter, the Owner role can set the stableSwapFactory to any address. If a fake stableSwapFactory address is passed in, the SmartRouterHelper will obtain a malicious transaction pair from the getStableInfo function, resulting in loss of funds. And this function is also missing the event log and 0 address check. ",
        "labels": [
            "SlowMist",
            "PancakeSwap_v3",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Token compatibility issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap_v3_en-us.pdf",
        "body": "1.In the StableSwapRouter, the exactOutputStableSwap and exactInputStableSwap functions will call swap to transfer by the pay function via the input data amountIn and the input data is recorded directly into it. In the swap function, although amountIn is re-recorded. However, the amountIn_ data is still recorded in the _swap function when the exchange is performed in the swapContract of the transferring third-party contract. If the third-party contract token balance is used to directly participate in the calculation, the contract cannot be compatible with the rebase token. ",
        "labels": [
            "SlowMist",
            "PancakeSwap_v3",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing event records",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap_v3_en-us.pdf",
        "body": "1.In the PancakeV3FactoryOwner contract, the owner role can set the lmPoolDeployer address, but there is no event log and 0 address check. ",
        "labels": [
            "SlowMist",
            "PancakeSwap_v3",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of initial operation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap_v3_en-us.pdf",
        "body": "In the PancakeV3Pool contract, by calling the initialize function to initialize the contracts, there is a potential issue that malicious attackers preemptively call the initialize function to initialize and there is no access control verication for the initialize functions ",
        "labels": [
            "SlowMist",
            "PancakeSwap_v3",
            "Type: Race Conditions Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of denial of service",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap_v3_en-us.pdf",
        "body": "In the UniswapV3Pool contract, the swap function can be disrupted by forcing the loop to go through too many operations, potentially trapping the swap due to a lack of gas. ",
        "labels": [
            "SlowMist",
            "PancakeSwap_v3",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of replay attack",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Coordinape protocol_en-us.pdf",
        "body": "In the ApeToken contract, DOMAIN_SEPARATOR is dened when the contract is initialized, but it is not reimplemented when DOMAIN_SEPARATOR is used in the permit function. So the DOMAIN_SEPARATOR contains 15 the chainId and is dened at contract deployment instead of reconstructed for every signature, there is a risk of possible replay attacks between chains in the event of a future chain split. coordinape-protocol/contracts/ApeProtocol/token/ApeToken.sol#L18 constructor() { uint chainId = block.chainid; DOMAIN_SEPARATOR = keccak256( abi.encode( keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'), keccak256(bytes(\"coordinape.com\")), keccak256(bytes('1')), chainId, address(this) ) ); } coordinape-protocol/contracts/ApeProtocol/token/ApeToken.sol#L42 function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public { require(block.timestamp <= deadline, \"COToken: expired deadline\"); require(owner != address(0), \"COToken: owner can't be ZERO address \"); bytes32 digest = keccak256( abi.encode( DOMAIN_SEPARATOR, '\\x19\\x01', keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline)) ) ); address signer = ECDSA.recover(digest, v, r, s); require(signer == owner, \"COToken: invalid signature\"); 16 _approve(owner, spender, value); }",
        "labels": [
            "SlowMist",
            "Coordinape protocol",
            "Type: Replay Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing event records",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Coordinape protocol_en-us.pdf",
        "body": "Missing event records are not conducive to the review of community users. coordinape-protocol/contracts/ApeProtocol/token/TokenAccessControl.sol#L32-47 function disableAllowlist() external onlyOwner { require(!allowlistDisabled, \"AccessControl: Allowlist already disabled\"); } allowlistDisabled = true; function changePauseStatus(bool _status) external onlyOwner { require(!foreverUnpaused, \"AccessControl: Contract is unpaused forever\"); } paused = _status; function disablePausingForever() external onlyOwner { require(!foreverUnpaused, \"AccessControl: Contract is unpaused forever\"); } foreverUnpaused = true; paused = false; 17 coordinape-protocol/contracts/ApeProtocol/token/TokenAccessControl.sol#L81-84 function disableMintingForever() external onlyOwner { require(!mintingDisabled, \"AccessControl: Contract cannot mint anymore\"); } mintingDisabled = true; coordinape-protocol/contracts/ApeProtocol/wrapper/beacon/ApeBeacon.sol#L23-28 function transferProxyOwnership(address _newOwner) external { require(msg.sender == proxyOwner()); assembly { sstore(_OWNER_SLOT, _newOwner) } } coordinape-protocol/contracts/ApeProtocol/wrapper/beacon/ApeRegistryBeacon.sol#37-L40 function pushNewImplementation(address _newImplementation) public itself { require(Address.isContract(_newImplementation), \"ApeRegistryBeacon: implementaion is not a contract\"); deployments[++deploymentCount] = _newImplementation; } coordinape-protocol/contracts/ApeProtocol/ApeRegistry.sol#L17-L35 function setFeeRegistry(address _registry) external itself { feeRegistry = _registry; } function setRouter(address _router) external itself { router = _router; } function setDistributor(address _distributor) external itself { distributor = _distributor; } 18 function setFactory(address _factory) external itself { factory = _factory; } function setTreasury(address _treasury) external itself { treasury = _treasury; } coordinape-protocol/contracts/ApeProtocol/ApeRouter.sol#L87-L89 function setRegistry(address _registry) external itself { yearnRegistry = _registry; }",
        "labels": [
            "SlowMist",
            "Coordinape protocol",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Coding optimization",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Coordinape protocol_en-us.pdf",
        "body": "getVariableFee function does not modify contract data, but does not use view. coordinape-protocol/contracts/ApeProtocol/FeeRegistry.sol#L24 function getVariableFee(uint256 _yield, uint256 _tapTotal) external returns(uint256 variableFee) { if (!on) return 0; uint256 yieldRatio = _yield * 1000 / _tapTotal; uint256 baseFee = 100; if (yieldRatio >= 900) variableFee = baseFee; // 1% @ 90% yield ratio else if (yieldRatio >= 800) variableFee = baseFee + 25; // 1.25% @ 80% yield ratio 19 else if (yieldRatio >= 700) variableFee = baseFee + 50; // 1.50% @ 70% yield ratio else if (yieldRatio >= 600) variableFee = baseFee + 75; // 1.75% @ 60% yield ratio else if (yieldRatio >= 500) variableFee = baseFee + 100; // 2.00% @ 80% yield ratio else if (yieldRatio >= 400) variableFee = baseFee + 125; // 2.25% @ 80% yield ratio else if (yieldRatio >= 300) variableFee = baseFee + 150; // 2.50% @ 80% yield ratio else if (yieldRatio >= 200) variableFee = baseFee + 175; // 2.75% @ 80% yield ratio else if (yieldRatio >= 100) variableFee = baseFee + 200; // 3.00% @ 80% yield ratio else } variableFee = baseFee + 250; // 3.50% @ 0% yield ratio",
        "labels": [
            "SlowMist",
            "Coordinape protocol",
            "Type: Authority Control Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Business logic is not clear",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Coordinape protocol_en-us.pdf",
        "body": "The _issueInvite function will execute the mint logic, but the burn is annotated in _revokeInvite, the business logic is not clear. coordinape-protocol/contracts/circles_obsolete/CoordinapeCircle.sol#L158-L175 function _issueInvite(address recipient, uint8 role) internal { Counters.increment(_inviteIds); uint256 tokenId = Counters.current(_inviteIds); _mint(recipient, tokenId); _roles[tokenId] = role; 20 _invites[recipient] = tokenId; _vouches[recipient] = 0; emit InviteIssued(recipient, role); } function _revokeInvite(address recipient) internal { uint256 tokenId = _invites[recipient]; _inactiveMembers.increment(); //_burn(tokenId); _roles[tokenId] = 0; _invites[recipient] = 0; emit InviteRevoked(recipient, 0); } _epochEnds is never initialized, and used in _epochInProgress function. coordinape-protocol/contracts/circles_obsolete/CoordinapeCircle.sol#L155 function _epochInProgress() internal view returns (bool) { uint256 epochId = Counters.current(_epochIds); // return epochId > 0 && !CoordinapeEpoch(_epochs[epochId]).ended(); return epochId > 0 && block.number < _epochEnds[epochId]; } _epochState is never initialized. and it is used in state function. coordinape-protocol/contracts/circles_obsolete/CoordinapeCircle.sol#L105 function state(uint256 _epoch) external view returns (uint8) { return _epochState[_epoch]; } The address passed in by the _migrate function is address(this), which means migrating to the address(this) contract, the logic here is not clear. coordinape-protocol/contracts/ApeProtocol/wrapper/beacon/ApeVault.sol#L166-L169 21 function apeMigrate() external onlyOwner returns(uint256 migrated){ migrated = _migrate(address(this)); vault = VaultAPI(registry.latestVault(address(token))); } migrated = _deposit(address(this), account, withdrawn, false); account is address(this), the logic here is wrong coordinape-protocol/contracts/ApeProtocol/wrapper/beacon/BaseWrapperImplementation.sol#L387-L427 function _migrate(address account) internal returns (uint256) { return _migrate(account, MIGRATE_EVERYTHING); } function _migrate(address account, uint256 amount) internal returns (uint256) { // NOTE: In practice, it was discovered that <50 was the maximum we've see for this variance return _migrate(account, amount, 0); } function _migrate( address account, uint256 amount, uint256 maxMigrationLoss ) internal returns (uint256 migrated) { VaultAPI _bestVault = bestVault(); // NOTE: Only override if we aren't migrating everything uint256 _depositLimit = _bestVault.depositLimit(); uint256 _totalAssets = _bestVault.totalAssets(); if (_depositLimit <= _totalAssets) return 0; // Nothing to migrate (not a failure) uint256 _amount = amount; if (_depositLimit < UNCAPPED_DEPOSITS && _amount < WITHDRAW_EVERYTHING) { // Can only deposit up to this amount uint256 _depositLeft = _depositLimit.sub(_totalAssets); if (_amount > _depositLeft) _amount = _depositLeft; } 22 if (_amount > 0) { // NOTE: `false` = don't withdraw from `_bestVault` uint256 withdrawn = _withdraw(account, address(this), _amount, false); if (withdrawn == 0) return 0; // Nothing to migrate (not a failure) // NOTE: `false` = don't do `transferFrom` because it's already local migrated = _deposit(address(this), account, withdrawn, false); // NOTE: Due to the precision loss of certain calculations, there is a small inefficency // on how migrations are calculated, and this could lead to a DoS issue. Hence, this // value is made to be configurable to allow the user to specify how much is acceptable require(withdrawn.sub(migrated) <= maxMigrationLoss); } // else: nothing to migrate! (not a failure) } The return value of decimals is 0, and developers need to conrm the business logic here. coordinape-protocol/contracts/circles_obsolete/CoordinapeEpoch.sol#L143-L145 function decimals() public pure override returns (uint8) { return 0; }",
        "labels": [
            "SlowMist",
            "Coordinape protocol",
            "Type: Others",
            "Severity: High"
        ]
    },
    {
        "title": "Coding standards issues 23",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Coordinape protocol_en-us.pdf",
        "body": "Executed rst _call(id, _target, _data); and then executed timestamps[id] = _DONE_TIMESTAMP; , which does not meet the specication(Checks-Eects-Interactions). coordinape-protocol/contracts/ApeProtocol/TimeLock.sol#L72-L73 function execute(address _target, bytes calldata _data, bytes32 _predecessor, bytes32 _salt, uint256 _delay) external onlyOwner { bytes32 id = hashOperation(_target, _data, _predecessor, _salt); require(isReadyCall(id), \"TimeLock: Not ready for execution or executed\"); require(_predecessor == bytes32(0) || isDoneCall(_predecessor), \"TimeLock: Predecessor call not executed\"); _call(id, _target, _data); timestamps[id] = _DONE_TIMESTAMP; } function _call( bytes32 id, address target, bytes calldata data ) internal { (bool success, ) = target.call(data); require(success, \"Timelock: underlying transaction reverted\"); emit CallExecuted(id, target, data); }",
        "labels": [
            "SlowMist",
            "Coordinape protocol",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "The external call does not judge the return value 24",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Coordinape protocol_en-us.pdf",
        "body": "The external call in the _withdraw function does not evaluate the return value E.g vaults[id].transferFrom , vault.transfer , IERC20(_token).transfer If the transferFrom function and transfer of the externally called token contract return false, the code logic will be wrong. coordinape-protocol/contracts/ApeProtocol/wrapper/beacon/BaseWrapperImplementation.sol#L353-L362 function _withdraw( address sender, address receiver, uint256 amount, // if `MAX_UINT256`, just withdraw everything bool withdrawFromBest // If true, also withdraw from `_bestVault` ) internal returns (uint256 withdrawn) { VaultAPI _bestVault = bestVault(); VaultAPI[] memory vaults = allVaults(); _updateVaultCache(vaults); // NOTE: This loop will attempt to withdraw from each Vault in `allVaults` that `sender` // is deposited in, up to `amount` tokens. The withdraw action can be expensive, // so it if there is a denial of service issue in withdrawing, the downstream usage // of this wrapper contract must give an alternative method of withdrawing using // this function so that `amount` is less than the full amount requested to withdraw // (e.g. \"piece-wise withdrawals\"), leading to less loop iterations such that the // DoS issue is mitigated (at a tradeoff of requiring more txns from the end user). for (uint256 id = 0; id < vaults.length; id++) { if (!withdrawFromBest && vaults[id] == _bestVault) { continue; // Don't withdraw from the best } 25 // Start with the total shares that `sender` has uint256 availableShares = vaults[id].balanceOf(sender); // Restrict by the allowance that `sender` has to this contract // NOTE: No need for allowance check if `sender` is this contract if (sender != address(this)) { availableShares = Math.min(availableShares, vaults[id].allowance(sender, address(this))); } // Limit by maximum withdrawal size from each vault availableShares = Math.min(availableShares, vaults[id].maxAvailableShares()); if (availableShares > 0) { // Intermediate step to move shares to this contract before withdrawing // NOTE: No need for share transfer if this contract is `sender` // if (sender != address(this)) vaults[id].transferFrom(sender, address(this), availableShares); if (amount != WITHDRAW_EVERYTHING) { // Compute amount to withdraw fully to satisfy the request uint256 estimatedShares = amount .sub(withdrawn) // NOTE: Changes every iteration .mul(10**uint256(vaults[id].decimals())) .div(vaults[id].pricePerShare()); // NOTE: Every Vault is different // Limit amount to withdraw to the maximum made available to this contract // NOTE: Avoid corner case where `estimatedShares` isn't precise enough // NOTE: If `0 < estimatedShares < 1` but `availableShares > 1`, this will withdraw more than necessary if (estimatedShares > 0 && estimatedShares < availableShares) { if (sender != address(this)) vaults[id].transferFrom(sender, address(this), estimatedShares); withdrawn = withdrawn.add(vaults[id].withdraw(estimatedShares)); } else { if (sender != address(this)) vaults[id].transferFrom(sender, address(this), availableShares); 26 withdrawn = withdrawn.add(vaults[id].withdraw(availableShares)); } } else { if (sender != address(this)) vaults[id].transferFrom(sender, address(this), availableShares); withdrawn = withdrawn.add(vaults[id].withdraw()); } // Check if we have fully satisfied the request // NOTE: use `amount = WITHDRAW_EVERYTHING` for withdrawing everything if (amount <= withdrawn) break; // withdrawn as much as we needed } } // If we have extra, deposit back into `_bestVault` for `sender` // NOTE: Invariant is `withdrawn <= amount` if (withdrawn > amount && withdrawn.sub(amount) > _bestVault.pricePerShare().div(10**_bestVault.decimals())) { // Don't forget to approve the deposit if (token.allowance(address(this), address(_bestVault)) < withdrawn.sub(amount)) { token.safeApprove(address(_bestVault), UNLIMITED_APPROVAL); // Vaults are trusted } _bestVault.deposit(withdrawn.sub(amount), sender); withdrawn = amount; } // `receiver` now has `withdrawn` tokens as balance if (receiver != address(this)) token.safeTransfer(receiver, withdrawn); } coordinape-protocol/contracts/ApeProtocol/ApeDistributor.sol#L147 function tapEpochAndDistribute( address _vault, bytes32 _circle, address _token, address[] calldata _users, 27 uint256[] calldata _amounts, uint256 _amount, uint8 _tapType) external { require(_users.length == _amounts.length, \"ApeDistributor: Array lengths do not match\"); require(sum(_amounts) == _amount, \"ApeDistributor: Amount does not match sum of values\"); _tap(_vault, _circle, _token, _amount, _tapType, bytes32(type(uint256).max)); for (uint256 i = 0; i < _users.length; i++) IERC20(_token).transfer(_users[i], _amounts[i]); } coordinape-vesting-contracts/contracts/Vesting.sol#L77-L99 function fetchTokens(uint256 _amount) external onlyOwner { IERC20(co).transfer(msg.sender, _amount); } function claim(uint256 _index) external override { uint256 _now = block.timestamp; Vehicule storage vehicule = vehicules[msg.sender][_index]; uint256 upfront = _claimUpfront(vehicule); uint256 start = vehicule.start; if (start == 0) revert(\"Vesting: vehicule does not exist\"); require(_now > start, \"Vesting: cliff !started\"); uint256 end = vehicule.end; uint256 elapsed = min(end, _now) - start; uint256 maxDelta = end - start; // yield = amount * delta / vest_duration - claimed_amount uint256 yield = (vehicule.amount * elapsed / maxDelta) - vehicule.claimed; vehicule.claimed += yield; IERC20(co).transfer(msg.sender, yield + upfront); 28 emit YieldClaimed(msg.sender, yield); }",
        "labels": [
            "SlowMist",
            "Coordinape protocol",
            "Type: Unsafe External Call Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Excessive authority issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Coordinape protocol_en-us.pdf",
        "body": "Owner can transfer assets in the contract. coordinape-protocol/contracts/ApeProtocol/wrapper/beacon/ApeVault.sol#L129 function apeWithdrawSimpleToken(uint256 _amount) public onlyOwner { simpleToken.safeTransfer(msg.sender, _amount); } coordinape-protocol/contracts/ApeProtocol/wrapper/beacon/ApeVault.sol#L139 function apeWithdraw(uint256 _shareAmount, bool _underlying) external onlyOwner { uint256 underlyingAmount = shareValue(_shareAmount); require(underlyingAmount <= underlyingValue, \"underlying amount higher than vault value\"); address router = ApeRegistry(apeRegistry).router(); underlyingValue -= underlyingAmount; vault.safeTransfer(router, _shareAmount); ApeRouter(router).delegateWithdrawal(owner(), address(this), vault.token(), _shareAmount, _underlying); } 29 coordinape-protocol/contracts/ApeProtocol/wrapper/beacon/ApeVault.sol#L154 function exitVaultToken(bool _underlying) external onlyOwner { underlyingValue = 0; uint256 totalShares = vault.balanceOf(address(this)); address router = ApeRegistry(apeRegistry).router(); vault.safeTransfer(router, totalShares); ApeRouter(router).delegateWithdrawal(owner(), address(this), vault.token(), totalShares, _underlying); } Owner can transfer the tokens in the contract. coordinape-vesting-contracts/contracts/Vesting.sol#L77 function fetchTokens(uint256 _amount) external onlyOwner { IERC20(co).transfer(msg.sender, _amount); }",
        "labels": [
            "SlowMist",
            "Coordinape protocol",
            "Type: Authority Control Vulnerability",
            "Severity: High"
        ]
    },
    {
        "title": "Lack of permission checks 30",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Coordinape protocol_en-us.pdf",
        "body": "The createApeVault function does not perform permission checks. Anyone can create ApeVault. If the incoming parameters are malicious (malicious Token or incompatible Token), it will aect the funds in the project. coordinape-protocol/contracts/ApeProtocol/wrapper/beacon/ApeVaultFactory.sol#L22-L27 function createApeVault(address _token, address _simpleToken) external { bytes memory data = abi.encodeWithSignature(\"init(address,address,address,address,address)\", apeRegistry, _token, yearnRegistry, _simpleToken, msg.sender); ApeBeacon proxy = new ApeBeacon(beacon, msg.sender, data); vaultRegistry[address(proxy)] = true; emit VaultCreated(address(proxy)); }",
        "labels": [
            "SlowMist",
            "Coordinape protocol",
            "Type: Authority Control Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "4.3.1.1 Reordering attack risk",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - InsurAce_en-us.pdf",
        "body": "When the owner calls preparePaymentForPayout, it will go to uniswap to calculate the required amountIn, and then perform the swap operation according to the amountIn. There is a risk of rearrangement attacks that may cause losses in the InsurAce pool. It is recommended to check the slippage of swap. Reference https://www.odaily.com/post/5162888 https://medium.com/coinmonks/demystify-the-dark-forest-on-ethereum-sandwich-attacks-5a3ae c9fa33e  contracts/pool/StakersPool.sol function claimPayout( address _fromToken, address _paymentToken, uint256 _settleAmtPT, address _claimTo, uint256 _claimId ) external override allowedCaller { require(_fromToken == poolToken, \"CP:1\"); 23 if (_settleAmtPT == 0) { return; } uint256 temp = _getTokenforExactPaymentToken(_fromToken, _paymentToken, _settleAmtPT); uint256 amountInMax = Math.min(stakedAmount, temp.mul(11).div(10)); uint256 convertOut = _convertTokenforExactPaymentToken(_fromToken, _paymentToken, _settleAmtPT, amountInMax); stakedAmount = stakedAmount.sub(convertOut); claimPayouts.push(convertOut); claimPayoutsClaimId.push(_claimId); _transferTokenTo(_paymentToken, _settleAmtPT, _claimTo, _claimId); } function _convertTokenforExactPaymentToken( address _tokenFrom, address _tokenTo, uint256 _amountOut, uint256 _amountInMax ) private returns (uint256) { require(_tokenFrom != _tokenTo, \"CT2EPT:1\"); address[] memory path = new address[](2); uint256[] memory ret; if (_tokenFrom == Constant.ETHTOKENADDRESS) { path[0] = uniswapRouter.WETH(); path[1] = _tokenTo; ret = uniswapRouter.swapETHForExactTokens{value: _amountInMax}( _amountOut, path, address(this), block.timestamp + 120 //solhint-disable-linenot-rely-on-time ); return ret[0]; } if (_tokenTo == Constant.ETHTOKENADDRESS) { path[0] = _tokenFrom; path[1] = uniswapRouter.WETH(); IERC20Upgradeable(path[0]).approve(Constant.UNISWAPV2_ROUTER_ADDRESS, _amountInMax); ret = uniswapRouter.swapTokensForExactETH( _amountOut, _amountInMax, path, 24 address(this), block.timestamp + 120 //solhint-disable-linenot-rely-on-time ); return ret[0]; } path[0] = _tokenFrom; path[1] = _tokenTo; IERC20Upgradeable(path[0]).approve(Constant.UNISWAPV2_ROUTER_ADDRESS, _amountInMax); ret = uniswapRouter.swapTokensForExactTokens( _amountOut, _amountInMax, path, address(this), block.timestamp + 120 //solhint-disable-linenot-rely-on-time ); return ret[0]; }  contracts/pool/StakersPool.sol function _getTokenforExactPaymentToken( address _tokenFrom, address _tokenTo, uint256 _amount ) private view returns (uint256) { if (_tokenFrom == _tokenTo) { return _amount; } address[] memory path = new address[](2); if (_tokenFrom == Constant.ETHTOKENADDRESS) { path[0] = uniswapRouter.WETH(); } else { path[0] = _tokenFrom; } if (_tokenTo == Constant.ETHTOKENADDRESS) { path[1] = uniswapRouter.WETH(); } else { path[1] = _tokenTo; } 25 uint256[] memory ret = uniswapRouter.getAmountsIn(_amount, path); return ret[0]; } Fix Status: The issues has been fixed.",
        "labels": [
            "SlowMist",
            "InsurAce",
            "Severity: High"
        ]
    },
    {
        "title": "4.3.1.2 Missing permission check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - InsurAce_en-us.pdf",
        "body": "The addCoverOwner function does not perform permission checking, any user can call this function to add owner. It is recommended to add permission check code.  contracts/cover/CoverData.sol function addCoverOwner(address owner) public { require(owner != address(0), \"ACO: 1\"); require(!allCoverOwnerFlagMap[owner], \"ACO: 2\"); allCoverOwnerList.push(owner); allCoverOwnerFlagMap[owner] = true; } Fix Status: The issues has been fixed.",
        "labels": [
            "SlowMist",
            "InsurAce",
            "Severity: High"
        ]
    },
    {
        "title": "4.3.2.1 DoS issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - InsurAce_en-us.pdf",
        "body": "_getDelAccuRwAmtPS has 3 while loop nestings, which will be affected by the parameters of lastScheduleCounter, gRewardTokenRatePerStakedTokenArray, _unstakeLockArrayBlockPerStaker, and dos due to more users or more mining cycles added.  contracts/staking/ScheduledMiningProgram.sol function _getDelAccuRwAmtPS( uint256 _lastCalculatedBlockPerStaker, uint256 _stakedAmtPerStaker, uint256[] memory _unstakeLockArrayBlockPerStaker, uint256[] memory _unstakeLockArrayAmtPerStaker 26 ) private view returns (uint256) { console.log(\"getDeltaAccumulativeRewardAmtPerStaker++\"); console.log(_lastCalculatedBlockPerStaker); console.log(_stakedAmtPerStaker); console.log(_unstakeLockArrayBlockPerStaker.length); uint256 retV = 0; //gothruthelistofallschedules uint256 scheduleIndex = lastScheduleCounter; while (scheduleIndex >= 1) { if (_lastCalculatedBlockPerStaker >= endMiningBlockPerSchedule[scheduleIndex]) { break; } //narrowdownblockdelta uint256 minWall = Math.max(_lastCalculatedBlockPerStaker, startMiningBlockPerSchedule[scheduleIndex]); uint256 maxWall = Math.min(block.number, endMiningBlockPerSchedule[scheduleIndex]); console.log(\"minWall: \", minWall); console.log(\"maxWall: \", maxWall); if (minWall >= maxWall) { scheduleIndex = scheduleIndex.sub(1); continue; } uint256 rateChangeIndex = gRewardTokenRatePerStakedTokenArray.length; if (rateChangeIndex == 0) { break; } uint256 rewardAccumulatedBetweenWalls = 0; while (rateChangeIndex > 0) { uint256 blockNumber = gRewardTokenRatePerStakedTokenArray[rateChangeIndex - 1]; console.log(\"blockNumber: \", blockNumber); if (blockNumber >= maxWall) { rateChangeIndex = rateChangeIndex.sub(1); continue; } if (blockNumber >= minWall) { uint256 delta = _getDeltaAccumulativeRewardsWithFixRatePerStaker(blockNumber, maxWall, gRewardTokenRatePerStakedTokenMap[blockNumber], _stakedAmtPerStaker, _unstakeLockArrayBlockPerStaker, _unstakeLockArrayAmtPerStaker); rewardAccumulatedBetweenWalls = delta.add(rewardAccumulatedBetweenWalls); maxWall = blockNumber; rateChangeIndex = rateChangeIndex.sub(1); continue; 27 } if (blockNumber < minWall) { uint256 delta = _getDeltaAccumulativeRewardsWithFixRatePerStaker(minWall, maxWall, gRewardTokenRatePerStakedTokenMap[blockNumber], _stakedAmtPerStaker, _unstakeLockArrayBlockPerStaker, _unstakeLockArrayAmtPerStaker); rewardAccumulatedBetweenWalls = delta.add(rewardAccumulatedBetweenWalls); break; } } retV = rewardAccumulatedBetweenWalls.add(retV); scheduleIndex = scheduleIndex.sub(1); } return retV; } Fix Status: This issue has been fixed",
        "labels": [
            "SlowMist",
            "InsurAce",
            "Severity: Medium"
        ]
    },
    {
        "title": "4.3.3.1 Excessive authority issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - InsurAce_en-us.pdf",
        "body": "Admin has permission to add sender, There is a issues of excessive authority. It is recommended to set Owner to Timelock contract or governance contract.  contracts/token/INSURToken.sol function addSender(address _from) external onlyAdmin { if (1 == transferFromAllowedList[_from]) { return; } membersFrom.push(_from); transferFromAllowedList[_from] = 1; } The admin can remove the sender arbitrarily, and there is a risk of denial of service. When the admin adds too many senders, the data in the memberFrom array will be very large, so when the removeSender is removed, the depth of the for loop call will be too large, resulting in The call fails. It 28 is recommended to change memberFrom to storage in the way of mapping, and use address as the key to avoid dos caused by this type of looping to obtain data.  contracts/token/INSURToken.sol function removeSender(address _from) external onlyAdmin { uint256 arrayLength = membersFrom.length; uint256 indexToBeDeleted; bool toDelete = false; for (uint256 i = 0; i < arrayLength; i++) { if (membersFrom[i] == _from) { indexToBeDeleted = i; toDelete = true; break; } } if (!toDelete) { return; } //ifindextobedeletedisnotthelastindex,swapposition. if (indexToBeDeleted < arrayLength - 1) { membersFrom[indexToBeDeleted] = membersFrom[arrayLength - 1]; } //wecannowreducethearraylengthby1 membersFrom.pop(); delete transferFromAllowedList[_from]; } MINTER can call mint arbitrarily, and there is no upper limit for minting.  contracts/token/INSURToken.sol function mint(address to, uint256 amount) public virtual { require(hasRole(MINTER_ROLE, _msgSender()), \"ERC20PresetMinterPauser: must have minter role to mint\"); _mint(to, amount); } Fix Status: This issue has been confirmed  after communication and feedback, the minting and Owner permissions may be transferred to address(0) in the future. 29 Owner can set lpTokenMinter and lpTokenBurner. The roles of lpTokenMinter and lpTokenBurner can mint and burn the user's LP. There is a issues of excessive authority. It is recommended to set Owner to Timelock contract or governance contract. And make sure the lpTokenMinter and lpTokenBurner cannot be EOA account.  contracts/token/LPToken.sol function setup(address _lpTokenMinter, address _lpTokenBurner) external onlyOwner { require(_lpTokenMinter != address(0), \"S:1\"); lpTokenMinter = _lpTokenMinter; require(_lpTokenBurner != address(0), \"S:2\"); lpTokenBurner = _lpTokenBurner; } Fix Status: This issue has been communicated back to the project team. The project team is aware of this and will adopt governance mechanism to secure the permission when the governance module goes live.",
        "labels": [
            "SlowMist",
            "InsurAce",
            "Severity: Low"
        ]
    },
    {
        "title": "4.3.3.2 DoS issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - InsurAce_en-us.pdf",
        "body": "The incoming _callers will add data to allowedCallersArray[_callee]. If too many _callers are added at one time, it will cause Out of Gas. When there are too many data in allowedCallersArray[_callee], the setAllowdCallersPerCallee function will DoS. It is recommended to set the data Use the mapping method to store instead, avoid using the for loop to find the value.  contracts/secmatrix/SecurityMatrix.sol function addAllowdCallersPerCallee(address _callee, address[] memory _callers) external onlyOwner { require(_callers.length != 0, \"AACPC:1\"); require(allowedCallersArray[_callee].length != 0, \"AACPC:2\"); for (uint256 index = 0; index < _callers.length; index++) { console.log(\"_callers index: \", _callers[index], index); allowedCallersArray[_callee].push(_callers[index]); 30 allowedCallersMap[_callee][_callers[index]] = 1; } }  contracts/secmatrix/SecurityMatrix.sol function setAllowdCallersPerCallee(address _callee, address[] memory _callers) external onlyOwner { console.log(\"_callee: \", _callee); console.log(\"_callers.length: \", _callers.length); require(_callers.length != 0, \"SACPC:1\"); //checkifcalleeexist if (allowedCallersArray[_callee].length == 0) { //notexist,soaddcallee allowedCallees.push(_callee); } else { //ifcalleeexist,thenpurgedata for (uint256 i = 0; i < allowedCallersArray[_callee].length; i++) { delete allowedCallersMap[_callee][allowedCallersArray[_callee][i]]; } delete allowedCallersArray[_callee]; } //andoverwrite for (uint256 index = 0; index < _callers.length; index++) { console.log(\"_callers index: \", _callers[index], index); allowedCallersArray[_callee].push(_callers[index]); allowedCallersMap[_callee][_callers[index]] = 1; } } Fix Status: This issue has been communicated back to project team. The project team is aware of this issue and the method will only be used by admin when setting up security matrix. The setAllowdCallersPerCallee method will be used to create security matrix entries, and the addAllowdCallersPerCallee method will be used to add delta matrix if needed.",
        "labels": [
            "SlowMist",
            "InsurAce",
            "Severity: Low"
        ]
    },
    {
        "title": "4.3.3.3 Repeatable call risk",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - InsurAce_en-us.pdf",
        "body": "If Owner call setupVestors function multiple times, there will be duplicate vestors in the vestor 31 array.When the setupVestors is called multiple times, if the vestor calls withdrawRewardPV intentionally or unintentionally during the calling process, initRewardPV and insurVestingTotalPV may get unexpected values. If setupVestors can be called multiple times, then when the owner is called, the vestor also calls withdrawRewardPV. In this case, the gas price of calling withdrawRewardPV is higher than that of calling setupVestors. Will execute withdrawRewardPV first, and then execute setupVestors, the data will appear unexpected. Competitive conditions similar to approve.  contracts/fixedvesting/FixedVesting.sol function setupVestors( address[] memory _vestors, uint256[] memory _vestingRewardPV, uint256[] memory _initRewardPV ) external onlyOwner { require(_vestors.length == _vestingRewardPV.length, \"AV:1\"); require(_initRewardPV.length == _vestingRewardPV.length, \"AV:2\"); for (uint256 i = 0; i < _vestors.length; i++) { address vestor = _vestors[i]; vestors.push(vestor); initRewardPV[vestor] = _initRewardPV[i]; insurVestingTotalPV[vestor] = _vestingRewardPV[i]; } } Fix Status: This issue has been fixed.",
        "labels": [
            "SlowMist",
            "InsurAce",
            "Severity: Low"
        ]
    },
    {
        "title": "4.3.3.4 Overflow risk",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - InsurAce_en-us.pdf",
        "body": "safemath should be used to calculate the length of the array to avoid overflow issues: if Currency is not added, the removal may cause overflow issues.  contracts/cover/CoverConfig.sol 32 function removeCurrency(address currency) external allowedCaller { require(currency != address(0), \"RC: 1\"); uint256 arrayLength = currencyValidAddressArray.length; uint256 indexToBeDeleted; bool toDelete = false; for (uint256 i = 0; i < arrayLength; i++) { if (currencyValidAddressArray[i] == currency) { indexToBeDeleted = i; toDelete = true; break; } } if (!toDelete) { require(toDelete, \"RC: 1\"); } //ifindextobedeletedisnotthelastindex,swapposition. if (indexToBeDeleted < arrayLength - 1) { currencyValidAddressArray[indexToBeDeleted] = currencyValidAddressArray[arrayLength - 1]; } //wecannowreducethearraylengthby1 currencyValidAddressArray.pop(); delete currencyValidAddressMap[currency]; } Fix Status: This issue has been fixed.",
        "labels": [
            "SlowMist",
            "InsurAce",
            "Severity: Low"
        ]
    },
    {
        "title": "4.3.3.5 FlashLoan attack risk",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - InsurAce_en-us.pdf",
        "body": "Unstake is judged by >= when there are already voting tasks. If claimsAssessorMinUnstakeTime is 0, then there will be a issue of using flashloan to vote.  contracts/claim/Claim.sol function unstake(address insurTokenAddress, uint256 insurAmount) external payable whenNotPaused nonReentrant { require(insurTokenAddress != address(0), \"USTK: 1\"); address payable assessor = _msgSender(); ClaimReward(crw).recalculateAssessor(assessor); bool canUnstake = false; 33 uint256 latestVoteTimestamp = ClaimAssessor(asr).getLatestVoteTimestamp(assessor); if (latestVoteTimestamp == 0) { canUnstake = true; } else { if ( block.timestamp >= ClaimAssessor(asr).getVoteStakePeriodEndTime(assessor) //solhint-disable-line not-rely-on-time canUnstake = true; ) { } } require(canUnstake, \"USTK: 2\"); require(insurAmount <= ClaimAssessor(asr).getNumOfVotes(assessor), \"USTK: 3\"); require(IERC20Upgradeable(insurTokenAddress).balanceOf(address(this)) >= insurAmount, \"USTK: 4\"); ClaimAssessor(asr).decreaseVotes(assessor, insurAmount); IERC20Upgradeable(insurTokenAddress).safeTransfer(assessor, insurAmount); } Fix Status: This issue has been fixed.",
        "labels": [
            "SlowMist",
            "InsurAce",
            "Severity: Low"
        ]
    },
    {
        "title": "4.3.4.1 Token compatibility risk",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - InsurAce_en-us.pdf",
        "body": "IERC20Upgradeable(stakedToken).safeTransferFrom(_msgSender(), address(this), _amount); The transfer operation of an external token is adopted. It is recommended to pay attention to the compatibility of the project and the token when adding a new token, such as: token return Value issues, fake token recharge issues, compatibility issues with deflationary tokens, etc.  contracts/staking/StakeOps.sol function stakeTokens(uint256 _amount, address _token) external payable whenNotPaused nonReentrant { require(IMiningProgram(iMiningProgram).canStake(_amount), \"ST:1\"); address stakedToken = StakersData(stakerDataAddr).stakedToken(); require(_token == stakedToken, \"ST:2\"); 34 if (stakedToken == Constant.ETHTOKENADDRESS) { require(_amount <= msg.value, \"ST:3\"); } else { require(IERC20Upgradeable(stakedToken).balanceOf(_msgSender()) >= _amount, \"ST:4\"); uint256 allowanceAmt = IERC20Upgradeable(stakedToken).allowance(_msgSender(), address(this)); require(allowanceAmt >= _amount, \"ST:5\"); } _reCalcPerStaker(); if (stakedToken != Constant.ETHTOKENADDRESS) { IERC20Upgradeable(stakedToken).safeTransferFrom(_msgSender(), address(this), _amount); } //dispatchtokentopool if (stakedToken == Constant.ETHTOKENADDRESS) { IStakersPool(iStakersPool).addStkAmount{value: _amount}(stakedToken, _amount); } else { IERC20Upgradeable(stakedToken).safeTransfer(iStakersPool, _amount); Fix Status: This issue has been communicated back to project team. The project team is aware of this and has already performed compatibility checks on the staking tokens, such as ETH, WETH, USDC, USDT, DAI, and INSUR, which are all compatible with the relevant standards.",
        "labels": [
            "SlowMist",
            "InsurAce",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.3.4.2 Event log is missing",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - InsurAce_en-us.pdf",
        "body": "It is recommended to add an event to record securityMatrix changes, applicable to all set functions. function setup(address _securityMatrix) external onlyOwner { require(_securityMatrix != address(0), \"S:1\"); securityMatrix = _securityMatrix; } Fix Status: This issue has been communicated back to project team. The project team will add more event logs in their development, including not limited to \"setup\".",
        "labels": [
            "SlowMist",
            "InsurAce",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.3.4.3 Redundant code",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - InsurAce_en-us.pdf",
        "body": "The `if (!toDelete) {require(toDelete, \"RC: 1\"); }` code can be simplified to `require(toDelete, \"RC: 1\");`. 35  contracts/cover/CoverConfig.sol function removeCurrency(address currency) external allowedCaller { require(currency != address(0), \"RC: 1\"); uint256 arrayLength = currencyValidAddressArray.length; uint256 indexToBeDeleted; bool toDelete = false; for (uint256 i = 0; i < arrayLength; i++) { if (currencyValidAddressArray[i] == currency) { indexToBeDeleted = i; toDelete = true; break; } } if (!toDelete) { require(toDelete, \"RC: 1\"); } //ifindextobedeletedisnotthelastindex,swapposition. if (indexToBeDeleted < arrayLength - 1) { currencyValidAddressArray[indexToBeDeleted] = currencyValidAddressArray[arrayLength - 1]; } //wecannowreducethearraylengthby1 currencyValidAddressArray.pop(); delete currencyValidAddressMap[currency]; } Fix Status: This issue has been fixed.",
        "labels": [
            "SlowMist",
            "InsurAce",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.3.4.4 Hard coded issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - InsurAce_en-us.pdf",
        "body": "The external contract address is hard-coded and cannot be modified. It is recommended that the external contract adopts a changeable method to avoid the problem that the project cannot operate normally due to the upgrade of the external contract.  common/Constant.sol address public constant UNISWAPV2_ROUTER_ADDRESS = address(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D); 36 Fix Status: This issue has been communicated back to project team. The project team is aware of this issue, and made design changes, such as adding exchange library lately, which will include token to token exchange queries from 1inch and Uniswap. In the case of address change, the ABI of the address may change accordingly, as such the project team will need to double check, and/or extend exchange library in tandem. 5.",
        "labels": [
            "SlowMist",
            "InsurAce",
            "Severity: Informational"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - LightDAO_en-us.pdf",
        "body": "1.In the HOPESalesAgent contract, the owner can add currency that can buy HOPE tokendelete the currency and change the currency exhange rate. If the owners privileges are lost, it could lead to a contract being maliciously added with a worthless currency and used it to unintentionally buy large amounts of hope tokens. ",
        "labels": [
            "SlowMist",
            "LightDAO",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "The DoS issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - LightDAO_en-us.pdf",
        "body": "The user can pass in the gombocAddressList array through the mintMany function to mint the LT. If the length of gombocAddressList is large, it will cause DoS because of the number of for loops. ",
        "labels": [
            "SlowMist",
            "LightDAO",
            "Type: Denial of Service Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Missing event records",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - LightDAO_en-us.pdf",
        "body": "1.In the Minter contract, the caller can toggle the approval status for mintingUser, but there are no event logs. ",
        "labels": [
            "SlowMist",
            "LightDAO",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing zero address check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - LightDAO_en-us.pdf",
        "body": "When modifying important addresses in the contract, it is not checked whether the incoming address is a zero address. ",
        "labels": [
            "SlowMist",
            "LightDAO",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing return value check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - LightDAO_en-us.pdf",
        "body": "When transferring ERC20 tokens, the return value after the transfer is not checked. If return false, the logical should be reverted. ",
        "labels": [
            "SlowMist",
            "LightDAO",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "No value is assigned to the fee parameter",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap Lottery_en-us.pdf",
        "body": "The fee parameter is dened in the RandomNumberGenerator contract and is used in the getRandomNumber function, but the contract is initialized without assigning a value to the fee parameter. ",
        "labels": [
            "SlowMist",
            "PancakeSwap Lottery",
            "Type: Others",
            "Severity: Low"
        ]
    },
    {
        "title": "Issue with reusable joinNFT",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Open Social Core_en-us.pdf",
        "body": "In the RelationLogic contract, users can join a specied community by calling the join or batchJoin function. A joinNFT is minted for the users, and the processJoin function in the community-specic JoinCondition contract is executed to enforce the corresponding join conditions. However, the joinNFT transfers are not restricted in any way, which leads to the following scenario: If a user joins a community that requires a fee, and pays a specied fee to obtain a joinNFT for the community, he can then transfer that NFT to other users, and since the transfer of the joinNFT is not subject to any checking, multiple users can view or manipulate the community's resources or information using a single NFT (paying for it only once). Code Location: contracts/core/logic/RelationLogic.sol function _executeJoin( uint256 communityId, bytes calldata joinConditionData, uint256 value ) internal returns (uint256 tokenId) { OspDataTypes.CommunityStruct memory community = _getCommunityStorage()._communityById[ communityId ]; if (community.joinNFT == address(0)) revert OspErrors.InvalidCommunityId(); tokenId = IJoinNFT(community.joinNFT).mint(msg.sender); if (community.joinCondition != address(0)) { IJoinCondition(community.joinCondition).processJoin{value: value}( msg.sender, communityId, joinConditionData ); } }",
        "labels": [
            "SlowMist",
            "Open Social Core",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Lack of the repeatability check for creating OpenReactions",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Open Social Core_en-us.pdf",
        "body": "In the",
        "labels": [
            "SlowMist",
            "Open Social Core",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Missing inviter check when creating a prole",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Open Social Core_en-us.pdf",
        "body": "In the ProleLogic contract, the user can create a prole by calling the createProle function, but here the inviter parameter is not checked. If the inviter passed in is equal to msg.sender, it does not follow the normal logic. Code Location: contracts/core/logic/ProleLogic.sol#L274 function _createProfile( OspDataTypes.CreateProfileData calldata vars ) internal returns (uint256) { ... if (vars.inviter != 0) { if (_getProfileStorage()._profileById[vars.inviter].owner == address(0)) { revert OspErrors.ProfileDoesNotExist(); } profileStruct.inviter = vars.inviter; } ... }",
        "labels": [
            "SlowMist",
            "Open Social Core",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Lack of check when following other users",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Open Social Core_en-us.pdf",
        "body": "In the RelationLogic contract, anyone can follow other users by calling the follow or batchFollow function. But here it doesn't check if the object to follow is equal to msg.sender, which doesn't follow the normal logic if you can follow yourself. Code Location: contracts/core/logic/RelationLogic.sol#L186-211 function _executeFollow( uint256 profileId, bytes calldata followConditionData, uint256 value ) internal returns (uint256 tokenId) { if (_getProfileStorage()._profileById[profileId].owner == address(0)) revert OspErrors.TokenDoesNotExist(); address followCondition = _getProfileStorage()._profileById[profileId].followCondition; address followSBT = _getProfileStorage()._profileById[profileId].followSBT; if (followSBT == address(0)) { followSBT = _deployFollowSBT(profileId); _getProfileStorage()._profileById[profileId].followSBT = followSBT; } ... }",
        "labels": [
            "SlowMist",
            "Open Social Core",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Lack of check whether a community has been joined",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Open Social Core_en-us.pdf",
        "body": "In the RelationLogic contract, anyone can join a specied community by calling the join or batchJoin function. However, there is no check to see if the user has already joined the community. If the condition of joining the community is that the number of tokens held reaches a set value, then the user can join the community several times to mint joinNFT, and then transfer the NFT to other users (even if the other users' token balances don't meet the requirements). Code Location: contracts/core/logic/RelationLogic.sol#L318-335 function _executeJoin( uint256 communityId, bytes calldata joinConditionData, uint256 value ) internal returns (uint256 tokenId) { OspDataTypes.CommunityStruct memory community = _getCommunityStorage()._communityById[ communityId ]; if (community.joinNFT == address(0)) revert OspErrors.InvalidCommunityId(); tokenId = IJoinNFT(community.joinNFT).mint(msg.sender); ... }",
        "labels": [
            "SlowMist",
            "Open Social Core",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Missing event record",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Open Social Core_en-us.pdf",
        "body": "The following functions in several contracts are for event logging of key parameter settings. Code Location: contracts/core/conditions/community/SlotNFTCommunityCond.sol#L34-36 function whitelistCommunitySlot(address slot, bool whitelist) external onlyOperation { _slotNFTWhitelisted[slot] = whitelist; } contracts/core/conditions/community/WhitelistAddressCommunityCond.sol#L37-39 function setMaxCreationNumber(address to, uint256 _maxCreationNumber) external onlyOperation { maxCreationNumber[to] = _maxCreationNumber; } Code Location: contracts/core/logic/GovernanceLogic.sol#L108-112 function setERC6551AccountImpl( address accountImpl ) external override onlyRole(Constants.GOVERNANCE) { _getGovernanceStorage()._erc6551AccountImpl = accountImpl; }",
        "labels": [
            "SlowMist",
            "Open Social Core",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "call() should be used instead of transfer() and send()",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Open Social Core_en-us.pdf",
        "body": "The transfer() and send() functions forward a xed amount of 2300 gas. Historically, it has often been recommended to use these functions for value transfers to guard against reentrancy attacks. However, the gas cost of EVM instructions may change signicantly during hard forks which may break already deployed contract systems that make xed assumptions about gas costs. For example. EIP 1884 broke several existing smart contracts due to a cost increase of the SLOAD instruction. ",
        "labels": [
            "SlowMist",
            "Open Social Core",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Open Social Core_en-us.pdf",
        "body": "In the OspUniversalProxy contract, the gov role can directly upgrade the implementation contract and call the functions of the new contract. If the privilege is lost or misused, This could lead to malicious tampering with the contract's functionality. ",
        "labels": [
            "SlowMist",
            "Open Social Core",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Authority transfer enhancement",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Open Social Core_en-us.pdf",
        "body": "In the Account contract, the admin role does not adopt the pending and access processes. If the admin is incorrectly set, the permission will be lost. Code Location: contracts/upgradeability/OspRouterImmutable.sol function changeAdmin(address _admin) public onlyAdmin { _changeAdmin(_admin); } ... function _changeAdmin(address admin_) internal { Data storage data = routerStorage(); emit AdminChanged(data.admin, admin_); data.admin = admin_; }",
        "labels": [
            "SlowMist",
            "Open Social Core",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Optimizable bytecode concatenation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase8 - SlowMist Audit Report.pdf",
        "body": "In the setByteCodes function of the Factory and CRPFactory contracts on the Scroll chain, due to the block gasLimit restriction, it is not possible to write the complete contract bytecode into bytecodes in a single transaction. Therefore, the bytecode is concatenated using the concatenate function. The concatenate function uses a for loop to copy and concatenate the bytecode, which consumes a large amount of gas compared to using calldatacopy. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase8 - SlowMist Audit Report",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Ination attack in StoneVault",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - StakeStone_en-us.pdf",
        "body": "In the StoneVault contract, users can can deposit assets and obtain the corresponding share of the vault by calling the deposit function, But there is a risk of interest rate ination attacks here: Consider this example: bob nds out that alice is making a deposit (e.g. via mempool). Pre-condition: no one deposit before( latestRoundID == 0 ) Assume raito = 1e18. Now, alice wants to deposit 1 (1 * 1e18 wei) WETH and the tx is spied on by the attacker(bob). Here is the breakdown: original state (after) Step 1 (after) Step 2 (after) Step 3 totalStone AssetsVault.getBalance() 0 1 1 1 0 1 1e18 + 1 2 * 1e18 + 1 1.bob front-runs alice and deposits 1 wei WETH and gets 1 share: since totalStone is 0, shares = amount = 1. 2.bob also transfers 1 * 1e18 wei WETH, making the WETH balance of the AssetsVault (AssetsVault.getBalance()) become 1e18 + 1 wei. And then directly call the rollToNextRoundId function to update the latestRoundId and price. (Since rebaseTime starts at 0, it can be called successfully directly). 3.alice deposits 1e18 wei WETH. However, alice gets 0 shares: 1e18 * 1 (totalStone) / (1e18 + 1) = 1e18 / (1e18 + 1) = 0. Since alice gets 0 shares, totalStone remains at 1. 4.bob still has the 1 only share ever minted, thus after waiting for the next rollToNextWETH function call for updating the price and the withdrawal of that 1 share takes away everything in the AssetsVault, including the alices 1e18 wei WETH.(Directly by calling the instantWithdraw function and passing in _amount parameter with a value of 0, _shares parameter with a value of 1). Code Location: contracts/StoneVault.sol#L150-173 function _depositFor( uint256 _amount, address _user ) internal returns (uint256 mintAmount) { require(_amount != 0, \"too small\"); uint256 sharePrice; uint256 currSharePrice = currentSharePrice(); if (latestRoundID == 0) { sharePrice = MULTIPLIER; } else { uint256 latestSharePrice = roundPricePerShare[latestRoundID - 1]; sharePrice = latestSharePrice > currSharePrice ? latestSharePrice : currSharePrice; } mintAmount = (_amount * MULTIPLIER) / sharePrice; AssetsVault(assetsVault).deposit{value: address(this).balance}(); Minter(minter).mint(_user, mintAmount); emit Deposit(_user, _amount, mintAmount, latestRoundID); } contracts/StoneVault.sol#L436-453 function currentSharePrice() public returns (uint256 price) { Stone stoneToken = Stone(stone); uint256 totalStone = stoneToken.totalSupply(); if ( latestRoundID == 0 || totalStone == 0 || totalStone == withdrawingSharesInPast ) { return MULTIPLIER; } uint256 etherAmount = AssetsVault(assetsVault).getBalance() + StrategyController(strategyController).getAllStrategiesValue() - withdrawableAmountInPast; uint256 activeShare = totalStone - withdrawingSharesInPast; return (etherAmount * MULTIPLIER) / activeShare; }",
        "labels": [
            "SlowMist",
            "StakeStone",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Missing setting rebaseTime when initializing",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - StakeStone_en-us.pdf",
        "body": "In the StoneVault contract, rebaseTime defaults to 0 and is not set in the constructor function. This could result in any user can call the function directly after the vault is created, potentially combining with other issues to have a signicant impact.(Refer to the N1 issue) Code Location: contracts/StoneVault.sol#L347 function rollToNextRound() external { require( block.timestamp > rebaseTime + rebaseTimeInterval, \"already rebased\" ); ... }",
        "labels": [
            "SlowMist",
            "StakeStone",
            "Type: Others",
            "Severity: Low"
        ]
    },
    {
        "title": "Risks of incorrect withdrawableAmountInPast updates",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - StakeStone_en-us.pdf",
        "body": "In the StoneVault contract, the rollToNextRound function moves the contract to the next round and updates the current round, including withdrawableAmountInPast. However, the price used in the withdrawableAmountInPast update is newSharePrice instead of the current round price (undPricePerShare [latestRoundID]). This results in newSharePrice being larger than the current round price (roundPricePerShare [latestRoundID]) if newSharePrice > previewSharePrice. In the withdrawal operation (instantWithdraw), the number of user withdrawals is actually calculated using roundPricePerShare, so if newSharePrice is larger than roundPricePerShare in the round of commit withdrawals, it may cause the withdrawal withdrawableAmountInPast is actually larger than the total remaining withdrawals. Then there may be the following situation: hypothesis After most withdrawals, totalStone has very little left (such as 1wei), and withdrawableAmountInPast the result of the price bias in statistics mentioned above is actually larger than expected. Then when calculating the current price (currentSharePrice), the calculation of etherAmount may be 0 or even an error due to overow. Code Location: contracts/StoneVault.sol#L387 function rollToNextRound() external { ... uint256 newSharePrice = currentSharePrice(); roundPricePerShare[latestRoundID] = previewSharePrice < newSharePrice ? previewSharePrice : newSharePrice; ... withdrawableAmountInPast = withdrawableAmountInPast + VaultMath.sharesToAsset(withdrawingSharesInRound, newSharePrice); withdrawingSharesInRound = 0; rebaseTime = block.timestamp; emit RollToNextRound(latestRoundID, vaultIn, vaultOut, newSharePrice); }",
        "labels": [
            "SlowMist",
            "StakeStone",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Missing check when migrating the vault",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - StakeStone_en-us.pdf",
        "body": "In the StoneVault contract, the migrateVault function is used to update the stoneVault address in the minter, assetsVault, and strategyController to achieve the eect of migration contracts. However, the migration does not check whether there are pending withdrawal requests in the current stoneVault contract. If the withdrawal request pending in the old stoneVault contract has not been nished during the migration process, then the data has been reset in the new stoneVault contract after the migration, which will cause the shares (stone tokens) transferred to the old stoneVault contract when the user committed the withdrawal request before to be locked and cannot be retrieved. Code Location: contracts/StoneVault.sol#L430-434 function migrateVault(address _vault) external onlyProposal { Minter(minter).setNewVault(_vault); AssetsVault(assetsVault).setNewVault(_vault); StrategyController(strategyController).setNewVault(_vault); }",
        "labels": [
            "SlowMist",
            "StakeStone",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Incorrect return value if the balance is sucient",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - StakeStone_en-us.pdf",
        "body": "When executing a withdrawal, if the eth balance in the AssetsVault contract is insucient, the forceWithdraw function of the controller contract will be called to make up the remaining eth by forcing a withdrawal. In the StrategyController contract, if the eth balance of this contract is sucient, the return value of actualAmount should normally be just what is needed (i.e. the passed ethAmount). But here all eth balances in the contract are returned, which may cause the user to withdraw more tokens than expected. Code Location: contracts/strategies/StrategyController.sol#L63 function forceWithdraw( uint256 _amount ) external onlyVault returns (uint256 actualAmount) { uint256 balanceBeforeRepay = address(this).balance; if (balanceBeforeRepay >= _amount) { _repayToVault(); actualAmount = balanceBeforeRepay; } else { actualAmount = _forceWithdraw(_amount - balanceBeforeRepay) + balanceBeforeRepay; } }",
        "labels": [
            "SlowMist",
            "StakeStone",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Incorrect withdrawal quantity calculation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - StakeStone_en-us.pdf",
        "body": "If the ETH balance in the contract is insucient during forced withdrawals, the instantWithdraw function in each strategy will be called in a loop to make up the dierence. The number of withdrawals for each strategy is calculated as _amount * ratios [strategy])/ONE_HUNDRED_PERCENT. Then there is a situation where if the sum of all ratios is less than ONE_HUNDRED_PERCENT, then the total number of forced withdrawals will be less than expected. (This is possible because the ratio of each strategy is set to only require the sum of all ratios to be less than or equal to ONE_HUNDRED_PERCENT, or a strategy is cleared). Code Location: contracts/strategies/StrategyController.sol#L187 function _forceWithdraw( uint256 _amount ) internal returns (uint256 actualAmount) { uint256 length = strategies.length(); for (uint i; i < length; i++) { address strategy = strategies.at(i); uint256 withAmount = (_amount * ratios[strategy]) / ONE_HUNDRED_PERCENT; if (withAmount != 0) { actualAmount = Strategy(strategy).instantWithdraw(withAmount) + actualAmount; } } _repayToVault(); }",
        "labels": [
            "SlowMist",
            "StakeStone",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Redundant code",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - StakeStone_en-us.pdf",
        "body": "There are useless codes in the le and codes that are not used in actual business. Code Location: contracts/strategies/StrategyController.sol#L51-53 function onlyRebaseStrategies() external { _rebase(0, 0); }",
        "labels": [
            "SlowMist",
            "StakeStone",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Incorrect PendingValue calculations in the STETHHoldingStrategy",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - StakeStone_en-us.pdf",
        "body": "In the STETHHoldingStrategy contract, the getPendingValue function is used to calculate the value of eth in the withdrawal process. However, only the amount of eth that has not passed the request during the withdrawal process is calculated here, and the part that has passed the request but has not been claimed is not calculated. This may cause the rollToNextRound function in the TokenVault contract to call the getAllStrategyPendingValue function to obtain all pending eth values less than expected. Code Location: contracts/strategies/STETHHoldingStrategy.sol#L155-157 function getPendingValue() public override returns (uint256 value) { (, , value) = checkPendingAssets(); } function checkPendingAssets() public returns ( uint256[] memory ids, uint256 totalClaimable, uint256 totalPending ) { ... for (uint256 i; i < length; i++) { ILidoWithdrawalQueue.WithdrawalRequestStatus memory status = statuses[i]; if (status.isClaimed) { continue; } if (status.isFinalized) { ids[j++] = allIds[i]; totalClaimable = totalClaimable + status.amountOfStETH; } else { totalPending = totalPending + status.amountOfStETH; } } ... }",
        "labels": [
            "SlowMist",
            "StakeStone",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Lack of event records",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - StakeStone_en-us.pdf",
        "body": "There is no corresponding event logged when a sensitive parameter in the contract is modied. Code Location: contracts/token/Minter.sol#L30-32 function setNewVault(address _vault) external onlyVault { vault = payable(_vault); } contracts/token/StoneCross.sol#L64-110 function _nonblockingLzReceive( uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload ) internal virtual override { ... if (packetType == PT_SEND) { _sendAck(_srcChainId, _srcAddress, _nonce, _payload); } else if (packetType == PT_FEED) { ... tokenPrice = price; updatedTime = time; } else if (packetType == PT_SET_ENABLE) { ... enable = flag; } else if (packetType == PT_SET_CAP) { ... cap = _cap; } else { revert(\"unknown packet type\"); } } contracts/AssetsVault.sol#L35-37 function setNewVault(address _vault) external onlyPermit { stoneVault = _vault; } contracts/strategies/RETHHoldingStrategy.sol#L158-164 function setRouter( bool _buyOnDex, bool _sellOnDex ) external onlyGovernance { buyOnDex = _buyOnDex; sellOnDex = _sellOnDex; } contracts/strategies/SFraxETHHoldingStrategy.sol#L151-157 function setRouter( bool _buyOnDex, bool _sellOnDex ) external onlyGovernance { buyOnDex = _buyOnDex; sellOnDex = _sellOnDex; } contracts/strategies/STETHHoldingStrategy.sol#L253-259 function setRouter( bool _buyOnDex, bool _sellOnDex ) external onlyGovernance { buyOnDex = _buyOnDex; sellOnDex = _sellOnDex; } contracts/strategies/Strategy.sol#L89-91 function setBufferTime(uint256 _time) external onlyGovernance { bufferTime = _time; } contracts/strategies/StrategyController.sol#L322-324 function setNewVault(address _vault) external onlyVault { stoneVault = _vault; } contracts/strategies/SwappingAggregator.sol#L396-420 function setUniRouter( address _token, address _uniPool, uint256 _slippage, uint24 _fee ) external onlyGovernance { require(_token != address(0), \"ZERO ADDRESS\"); uniV3Pools[_token] = _uniPool; slippage[_token] = _slippage; fees[_token] = _fee; } function setCurveRouter( address _token, address _curvePool, uint8 _curvePoolType, uint256 _slippage ) external onlyGovernance { require(_token != address(0), \"ZERO ADDRESS\"); curvePools[_token] = _curvePool; curvePoolType[_curvePool] = _curvePoolType; slippage[_token] = _slippage; }",
        "labels": [
            "SlowMist",
            "StakeStone",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Authority transfer enhancement",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - StakeStone_en-us.pdf",
        "body": "The permission transfer method for the core roles(like proposer and governance) does not adopt the pending and access processes. If set incorrectly, the permission of the core roles will be lost. Code Location: contracts/strategies/Strategy.sol#L84-87 function setGovernance(address governance_) external onlyGovernance { emit TransferGovernance(governance, governance_); governance = governance_; } contracts/strategies/SwappingAggregator.sol#L422-426 function setGovernance(address governance_) external onlyGovernance { emit TransferGovernance(governance, governance_); governance = governance_; } contracts/governance/Proposal.sol#L138-142 function setProposer(address _proposer) external onlyProposer { emit SetProposer(proposer, _proposer); proposer = _proposer; }",
        "labels": [
            "SlowMist",
            "StakeStone",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Lack of CrossChain fee checking in the bridgeTo function",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - StakeStone_en-us.pdf",
        "body": "In the DepositBridge contract, there is no check in the bridgeTo function to see if the incoming _gasPaidForCrossChain parameter is greater than or equal to the handling fee required to send across the chain. If passed in too small it may cause the cross-chain operation to fail. Code Location: contracts/mining/DepositBridge.sol#L30-41 function bridgeTo( uint256 _amount, bytes calldata _dstAddress, uint256 _gasPaidForCrossChain ) public payable returns (uint256 stoneMinted) { stoneMinted = bridge( msg.sender, _amount, _dstAddress, _gasPaidForCrossChain ); }",
        "labels": [
            "SlowMist",
            "StakeStone",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Missing check for dstChainId on initialisation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - StakeStone_en-us.pdf",
        "body": "In the DepositBridge contract, the dstChainId is set on initialisation, but there is no check to see if the value set is not equal to the chainId of the current chain, which would cause the sendFrom function in the stone tokens to revert and the cross-chain operation to fail. Code Location: contracts/mining/DepositBridge.sol#L27 constructor(address _stone, address payable _vault, uint16 _dstChainId) { ... dstChainId = _dstChainId; }",
        "labels": [
            "SlowMist",
            "StakeStone",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Lack of scope check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - StakeStone_en-us.pdf",
        "body": "1.In Strategy contracts, the setBuerTime function can be used to set the delay time for strategy operations. However, there is no check on the range of the _time parameter passed in, and if it is too large, the normal operation of the strategy contract will be aected. Code Location: contracts/strategies/Strategy.sol#L89-91 function setBufferTime(uint256 _time) external onlyGovernance { bufferTime = _time; } 2.In SwappingAggregator contracts, the Governance role can set the slips corresponding to dierent tokens and the fees charged by calling the setSlippage function, the setUniRouter function, and the setCurveRouter function. However, there is no range checking of incoming new slippage and fees at the time of setup, which could result in arbitrage or unintended depletion of the user's funds if set too high. Code Location: contracts/strategies/SwappingAggregator.sol#L387-420 function setSlippage( address _token, uint256 _slippage ) external onlyGovernance { emit SetSlippage(_token, slippage[_token], _slippage); slippage[_token] = _slippage; } function setUniRouter( address _token, address _uniPool, uint256 _slippage, uint24 _fee ) external onlyGovernance { require(_token != address(0), \"ZERO ADDRESS\"); uniV3Pools[_token] = _uniPool; slippage[_token] = _slippage; fees[_token] = _fee; } function setCurveRouter( address _token, address _curvePool, uint8 _curvePoolType, uint256 _slippage ) external onlyGovernance { require(_token != address(0), \"ZERO ADDRESS\"); curvePools[_token] = _curvePool; curvePoolType[_curvePool] = _curvePoolType; slippage[_token] = _slippage; }",
        "labels": [
            "SlowMist",
            "StakeStone",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Potential governance attacks",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - StakeStone_en-us.pdf",
        "body": "In a Proposal contract, users can call the voteFor function to transfer their holdings of stone tokens into that contract and vote on a specied proposal. However, if the Proposer role is evil (e.g. in the case of lost permissions), it is possible to call the instantWithdraw function or requestWithdraw function in the Stone Vault contract by submitting a proposal and transferring a large number of stone tokens towards the end of the vote to ensure that the proposal passes. After the proposal is executed, it will consume other users' stone tokens and make additional prot (enough to cover the cost of the attack). Code Location: contracts/governance/Proposal.sol#L76-96 function voteFor(address _proposal, uint256 _poll, bool _flag) external { require(canVote(_proposal), \"cannot vote\"); TransferHelper.safeTransferFrom( stoneToken, msg.sender, address(this), _poll ); ... }",
        "labels": [
            "SlowMist",
            "StakeStone",
            "Type: Design Logic Audit",
            "Severity: Information"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - StakeStone_en-us.pdf",
        "body": "1.In SwappingAggregator contracts, the Governance role can set the slips, the exchange router and the fee corresponding to dierent tokens by calling the setSlippage function, the setUniRouter function, and the setCurveRouter function. If the privilege is lost or misused, this may have an impact on the user's assets. Code Location: contracts/strategies/SwappingAggregator.sol#L387-420 function setSlippage( address _token, uint256 _slippage ) external onlyGovernance { emit SetSlippage(_token, slippage[_token], _slippage); slippage[_token] = _slippage; } function setUniRouter( address _token, address _uniPool, uint256 _slippage, uint24 _fee ) external onlyGovernance { require(_token != address(0), \"ZERO ADDRESS\"); uniV3Pools[_token] = _uniPool; slippage[_token] = _slippage; fees[_token] = _fee; } function setCurveRouter( address _token, address _curvePool, uint8 _curvePoolType, uint256 _slippage ) external onlyGovernance { require(_token != address(0), \"ZERO ADDRESS\"); curvePools[_token] = _curvePool; curvePoolType[_curvePool] = _curvePoolType; slippage[_token] = _slippage; } 2.In Proposal contracts, the Proposer role can initiate a proposal by calling the propose function. If the privilege is lost or misused, the Proposer role may launch a malicious proposal causing the user to suer a loss of funds. Code Location: contracts/governance/Proposal.sol#L57-74 function propose(bytes calldata _data) external onlyProposer { ... }",
        "labels": [
            "SlowMist",
            "StakeStone",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Missing return value check when adding strategies",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - StakeStone_en-us.pdf",
        "body": "In StrategyController contracts, the type of data structure used for strategy storage is the EnumerableSet library from openzeppelin. When using the .add() function, it will return false if the added data already exists and will not add the data repeatedly. However, the StrategyController contract does not check the return value of the .add() function when adding or setting a strategy, which may result in strategies not being added but ratios being changed. Code Location: contracts/strategies/StrategyController.sol function _initStrategies( address[] memory _strategies, uint256[] memory _ratios ) internal { ... for (uint i; i < length; i++) { strategies.add(_strategies[i]); ratios[_strategies[i]] = _ratios[i]; totalRatio = totalRatio + _ratios[i]; } require(totalRatio <= ONE_HUNDRED_PERCENT, \"exceed 100%\"); } function _setStrategies( address[] memory _strategies, uint256[] memory _ratios ) internal { ... for (uint i; i < length; i++) { ... strategies.add(_strategies[i]); ratios[_strategies[i]] = _ratios[i]; totalRatio = totalRatio + _ratios[i]; } require(totalRatio <= ONE_HUNDRED_PERCENT, \"exceed 100%\"); }",
        "labels": [
            "SlowMist",
            "StakeStone",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Synclub_en-us.pdf",
        "body": "1.In the SnBnb contract, the DEFAULT_ADMIN_ROLE can set the stakeManager contract as the StakeManager role and the StakeManager role can call the mint and burn functions to mint tokens arbitrarily and burn any users tokens. ",
        "labels": [
            "SlowMist",
            "Synclub",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "The mint amount can be 0 in the deposit function",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Synclub_en-us.pdf",
        "body": "In the SnStakeManager contract, users deposit their BNB into this contract and obtain the SnBNB as the staking certicate. And the calculation of the snBnbToMint is dependent on the convertBnbToSnBnb function, the totalSupply of the SnBNB, and the totalPooledBnb in this contract. If the deposit amount of the BNB is small enough or the totalPooledBnb is big enough, the calculation of the snBnbToMint can be 0. But the amount of the BNB can still add to the amountToDelegate to cause the increment of the totalPooledBnb. ",
        "labels": [
            "SlowMist",
            "Synclub",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "The BNB can be remained in the contract",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Synclub_en-us.pdf",
        "body": "In the SnStakeManager contract when users claim to withdraw their BNB tokens in the claimWithdraw in the same uuid, the calculation of the amount = (totalBnbToWithdraw_ * amountInSnBnb) / totalSnBnbToBurn_; has the rounding to obtain one of the users withdrawal amount. It will cause the rounded amount of the BNB to remain in this contract and can not be withdrawn. ",
        "labels": [
            "SlowMist",
            "Synclub",
            "Type: Arithmetic Accuracy Deviation Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "The business logic is unclear",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Synclub_en-us.pdf",
        "body": "In the SnStakeManager contract, the claimUndelegated function calculates the claimUndelegated withdrawal value in one uuid and assigns it to two temporary variables. The two temporary variables are just for recording and have no other usage. ",
        "labels": [
            "SlowMist",
            "Synclub",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing the validator check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Synclub_en-us.pdf",
        "body": "In the SnStakeManager contract, the Manager role can change the Validator through the redelegate function, and this check is done by the NATIVE_STAKING contract, and if the call of the redelegate function failed, it will consume the gas of this call. ",
        "labels": [
            "SlowMist",
            "Synclub",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing the event records",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Synclub_en-us.pdf",
        "body": "There are no event logs of the claimUndelegated and claimFailedDelegation in this SnStakeManager contract. ",
        "labels": [
            "SlowMist",
            "Synclub",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Preemptive initialization",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Synclub_en-us.pdf",
        "body": "By calling the initialize function to initialize the contracts, there is a potential issue that malicious attackers preemptively call the initialize function to initialize. ",
        "labels": [
            "SlowMist",
            "Synclub",
            "Type: Race Conditions Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Dev address setting enhancement suggestions",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Synclub_en-us.pdf",
        "body": "In the SnStakeManager contract, the GOVERNANCE_ROLE role can set the revenuePool address to receive the fee. If the address is an EOA address, in a scenario where the private keys are leaked, the teams revenue will be stolen. ",
        "labels": [
            "SlowMist",
            "Synclub",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Business logic error Payable Payable Can Modify State - Can Modify State Can Modify State Can Modify State - - - - - - - 13",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ioTube_en-us.pdf",
        "body": "When originalAssetByID gets the data of originalAssets, the _assetID passed in should be reduced by 1, and then readout. activateAsset, deactivateAsset function directly passes in _assetID, and then read originalAssets[_assetID], The judgment is _assetID <= originalAssets.length . There are two issues here: 1. When _assetID == originalAssets.length, originalAssets[_assetID] cannot read data. 2. The originalAssets data obtained here is not obtained using the originalAssetByID function, and the business logic needs to be conrmed. contracts/AssetRegistry.sol#L101-L133 function activateAsset(uint256 _assetID, uint256 _tubeID) public onlyOperator { require(_assetID > 0 && _assetID <= originalAssets.length, \"invalid asset id\"); Asset storage oa = originalAssets[_assetID]; if (_tubeID == 0 || oa.tubeID == _tubeID) { if (oa.active == false) { oa.active = true; emit AssetActivated(_assetID, oa.tubeID); } } else { Asset storage sa = shadowAssets[_assetID][_tubeID]; if (sa.asset != address(0) && sa.active == false) { sa.active = true; emit AssetActivated(_assetID, _tubeID); } } } function deactivateAsset(uint256 _assetID, uint256 _tubeID) public onlyOperator { require(_assetID > 0 && _assetID <= originalAssets.length, \"invalid asset id\"); Asset storage oa = originalAssets[_assetID]; if (_tubeID == 0 || oa.tubeID == _tubeID) { if (oa.active == true) { oa.active = false; 14 emit AssetDeactivated(_assetID, oa.tubeID); } } else { Asset storage sa = shadowAssets[_assetID][_tubeID]; if (sa.asset != address(0) && sa.active == true) { sa.active = false; emit AssetDeactivated(_assetID, _tubeID); } } } originalAssetIDs[_tubeID][_asset] = id; The record is originalAssets.length;, so to take the value of originalAssets, the index should be originalAssetIDs[_tubeID][_asset]-1, combined with the processing logic here, you need to conrm the issues with the developer. contracts/AssetRegistry.sol#L74-L84 function addOriginalAsset(uint256 _tubeID, address _asset) public onlyOperator returns (uint256) { require(_tubeID > 0 && _asset != address(0), \"invalid parameter\"); uint256 id = assetID(_tubeID, _asset); if (id == 0) { originalAssets.push(Asset(_tubeID, _asset, true)); id = originalAssets.length; originalAssetIDs[_tubeID][_asset] = id; emit NewOriginalAsset(_tubeID, _asset, id); } return id; }",
        "labels": [
            "SlowMist",
            "ioTube",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Authority transfer enhancement",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ioTube_en-us.pdf",
        "body": "There is no pending and accept mechanism for authority transfer to avoid loss of authority contracts/CrosschainERC20.sol#L34-L37 function transferMintership(address _newMinter) public onlyMinter { minter = _newMinter; 16 emit MinterSet(_newMinter); } contracts/CrosschainERC721.sol#L29-L32 function transferMintership(address _newMinter) public onlyMinter { minter = _newMinter; emit MinterSet(_newMinter); }",
        "labels": [
            "SlowMist",
            "ioTube",
            "Type: Authority Control Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "unsafe external call risk",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ioTube_en-us.pdf",
        "body": "The withdraw function in the contract code does not check the whitelist of _recipient and _data. There is an unsafe external call (success,) = _recipient.call(_data); . The attacker can use _recipient.call(_data); to call any function of the lord contract, or transfer the token approved by the user to the Tube contract. contracts/Tube.sol#L179-L207 function withdraw( uint256 _srcTubeID, uint256 _txIdx, address _token, address _recipient, uint256 _amount, bytes memory _data, bytes memory _signatures ) public whenNotPaused { require(_amount != 0, \"amount is 0\"); 17 require(_recipient != address(0), \"invalid recipient\"); require(_signatures.length % 65 == 0, \"invalid signature length\"); bytes32 key = genKey(_srcTubeID, _txIdx, _token, _recipient, _amount, _data); ledger.record(key); (bool isValid, address[] memory signers) = verifier.verify(key, _signatures); require(isValid, \"insufficient validators\"); bool success = true; if (_data.length > 0) { lord.mint(_token, address(this), _amount); IERC20(_token).safeApprove(_recipient, _amount); (success, ) = _recipient.call(_data); if (!success) { IERC20(_token).safeDecreaseAllowance(_recipient, _amount); } } else { lord.mint(_token, _recipient, _amount); } emit Settled(key, signers, success); }",
        "labels": [
            "SlowMist",
            "ioTube",
            "Type: Unsafe External Call Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Excessive authority issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ioTube_en-us.pdf",
        "body": "The Owner of the Tube contract has too much authority. The owner of the Lord contract can be changed, and the owner of the Lord contract can execute mint and burn arbitrarily. This will aect the users assets. contracts/Tube.sol#L71-L78 function upgrade(address _newTube) public onlyOwner { if (ledger.owner() == address(this)) { ledger.transferOwnership(_newTube); } 18 if (lord.owner() == address(this)) { lord.transferOwnership(_newTube); } } contracts/Lord.sol#L94-L131 function burn( address _token, address _sender, uint256 _amount ) public onlyOwner { if (address(standardTokenList) != address(0) && standardTokenList.isAllowed(_token)) { // transfer token to standardTokenList _callOptionalReturn( _token, abi.encodeWithSelector(IToken(_token).transferFrom.selector, _sender, tokenSafe, _amount) ); return; } if (address(proxyTokenList) != address(0) && proxyTokenList.isAllowed(_token)) { _callOptionalReturn( _token, abi.encodeWithSelector(IToken(_token).transferFrom.selector, _sender, address(this), _amount) ); _callOptionalReturn(_token, abi.encodeWithSelector(IToken(_token).burn.selector, _amount)); return; } _callOptionalReturn(_token, abi.encodeWithSelector(IToken(_token).burnFrom.selector, _sender, _amount)); } function mint( address _token, address _recipient, uint256 _amount ) public onlyOwner { if (address(standardTokenList) != address(0) && 19 standardTokenList.isAllowed(_token)) { require(tokenSafe.mint(_token, _recipient, _amount), \"token safe mint failed\"); return; } if (address(proxyTokenList) != address(0) && proxyTokenList.isAllowed(_token)) { require(minterPool.mint(_token, _recipient, _amount), \"proxy token mint failed\"); } _callOptionalReturn(_token, abi.encodeWithSelector(IToken(_token).mint.selector, _recipient, _amount)); } function mintNFT( address _token, uint256 _tokenID, address _recipient, bytes memory _data ) public onlyOwner { IERC721Mintable(_token).safeMint(_recipient, _tokenID, _data); } function upgrade(address _newLord) public onlyOwner { if (minterPool.owner() == address(this)) { _callOptionalReturn( address(tokenSafe), abi.encodeWithSelector(minterPool.transferOwnership.selector, _newLord) ); } if (tokenSafe.owner() == address(this)) { _callOptionalReturn( address(tokenSafe), abi.encodeWithSelector(tokenSafe.transferOwnership.selector, _newLord) ); } }",
        "labels": [
            "SlowMist",
            "ioTube",
            "Type: Authority Control Vulnerability",
            "Severity: High"
        ]
    },
    {
        "title": "Business logic aws",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ioTube_en-us.pdf",
        "body": "The swapCoinForCrosschainCoin function will call cerc20.depositTo. contracts/CrosschainCoinRouter.sol#L37-L40 function swapCoinForCrosschainCoin(uint256 _amount) public payable { wrappedCoin.deposit{value: _amount}(); cerc20.depositTo(msg.sender, _amount); } cerc20.depositTo will call safeTransferFrom, where msg.sender is the CrosschainCoinRouter contract, but CrosschainCoinRouter has authorized CrosschainERC20 contract operation assets. contracts/CrosschainERC20.sol#L43-L47 function depositTo(address _to, uint256 _amount) public { require(address(coToken) != address(0), \"no co-token\"); coToken.safeTransferFrom(msg.sender, address(this), _amount); _mint(_to, _amount); } Although the allowance is set to -1, under extreme conditions, the continuous consumption quota will still be reduced to no quota. At this time, the contract cannot be used without re-approve. contracts/CrosschainCoinRouter.sol#L20-L25 constructor(CrosschainERC20 _cerc20) public { ERC20 ct = _cerc20.coToken(); cerc20 = _cerc20; ct.safeApprove(address(cerc20), uint256(-1)); 21 wrappedCoin = WrappedCoin(address(ct)); }",
        "labels": [
            "SlowMist",
            "ioTube",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Excessive authority issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ioTube_en-us.pdf",
        "body": "Owner can set the relayfee arbitrarily, and there is no limit on the value range. When the relayfee is set to a large value, most of the user's funds will be used to pay the relayFees. contracts/TubeRouter.sol#L49-L55 function setRelayFee(uint256 _tubeID, uint256 _fee) public onlyOwner { if (_fee == 0) { relayFees[_tubeID].exists = false; } else { relayFees[_tubeID] = RelayFee(_fee, true); } }",
        "labels": [
            "SlowMist",
            "ioTube",
            "Type: Authority Control Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Coding optimization",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ioTube_en-us.pdf",
        "body": "22 Owner can withdraw ETH and token in the contract. There are relayFees in the TubeRouter contract, and the Owner can withdraw the relayFees through the withdrawToken function, However, withdrawCoin and withdrawToken are used to extract the assets that were unexpectedly credited into the contract. contracts/TubeRouter.sol#L97-L106 function withdrawCoin(address payable _to) external onlyOwner { _to.transfer(address(this).balance); } function withdrawToken(address _to, IERC20 _token) external onlyOwner { uint256 balance = _token.balanceOf(address(this)); if (balance > 0) { _token.safeTransfer(_to, balance); } } contracts/Tube.sol#L229-L238 function withdrawCoin(address payable _to) external onlyOwner { _to.transfer(address(this).balance); } function withdrawToken(address _to, IERC20 _token) external onlyOwner { uint256 balance = _token.balanceOf(address(this)); if (balance > 0) { _token.safeTransfer(_to, balance); } }",
        "labels": [
            "SlowMist",
            "ioTube",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Other safety reminders",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ioTube_en-us.pdf",
        "body": "Note that when signing, make sure that the K value is not the same in the signature implementation. In the elliptic curve signature algorithm, if the random number is not safe enough and the same K value random number is used, there will be two transactions with the same R value. , So that the private key can be calculated, please pay attention to investigate similar cryptographic implementations. Reference: https://panzhibiao.com/2019/03/13/important-random-k-and-fake-signatures/ To capture events in the cross-chain bridge, the implementation of subscribing to the events of the specied contract should be adopted to avoid the attacks of fake contract events",
        "labels": [
            "SlowMist",
            "ioTube",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Recommendations for Parameter Declarations - - - - - - - - - - - - - - - - - - -",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase4 - SlowMist Audit Report.pdf",
        "body": "In the DTBT contract, the _name and _symbol parameters are hardcoded with xed values, but they are not declared as constants, which will result in additional gas consumption. The same is true for stableCoinReceiver , sTBTReceiver , stbt , stableCoin parameters in the TBillSimple contract. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase4 - SlowMist Audit Report",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Invalid function return value",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase4 - SlowMist Audit Report.pdf",
        "body": "In the DTBT contract, the owner role can modify the decimals of the contract through the updateDecimals function. This function denes the return value, but it does not return any value. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase4 - SlowMist Audit Report",
            "Type: Others",
            "Severity: Low"
        ]
    },
    {
        "title": "The transfer return value that does not conform to the EIP20 interface standard",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase4 - SlowMist Audit Report.pdf",
        "body": "In the DTBT contract, users can transfer DTBT tokens through the transferFrom function. However, the implementation of this function does not comply with the return value standard specied in EIP20. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase4 - SlowMist Audit Report",
            "Type: Others",
            "Severity: Low"
        ]
    },
    {
        "title": "Redundant Period enum",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase4 - SlowMist Audit Report.pdf",
        "body": "The Period enum is dened in the TBillSimple contract, but it is not used in the contract. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase4 - SlowMist Audit Report",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing error message",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase4 - SlowMist Audit Report.pdf",
        "body": "In the DTBT contract, the add/sub function users add and subtract mathematically. It will perform overow checks through require , but no error message will be thrown when the check fails, which will prevent users from intuitively obtaining the cause of the error. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase4 - SlowMist Audit Report",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Hardcoded testnet address issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase4 - SlowMist Audit Report.pdf",
        "body": "In the TBillSimple contract, the parameters of stableCoinReceiver, sTBTReceiver, stbt, and stableCoin are all hardcoded with the address of the Goerli testnet. If the hard-coded address is not modied when the protocol is launched on the mainnet, the protocol will not work properly. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase4 - SlowMist Audit Report",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "collectEndTime is not checked",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase4 - SlowMist Audit Report.pdf",
        "body": "In the TBillSimple contract, managers can buy/sell STBT through the swap function. It checks whether the current time is less than the closing end time of the ETF, but does not check whether the current time is greater than the fundraising end time of the ETF. Although it will check whether the isCompletedCollect status of the ETF is true through _checkTx , users can still add liquidity to the ETF at this time. If the swap operation is performed at this time, the stableCoin will be unbound, and users will not be able to add liquidity during the fundraising period, which is inconsistent with the design expectation. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase4 - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Missing 0 balance check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase4 - SlowMist Audit Report.pdf",
        "body": "In the TBillSimple contract, managers can synchronize the stableCoin position data in bPool through the rebalance function. But it does not check whether the stableCoin balance in bPool is greater than 0, and if the balance is 0, the rebind operation is meaningless. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase4 - SlowMist Audit Report",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Decimal conversion causes data mismatch",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase4 - SlowMist Audit Report.pdf",
        "body": "In the TBillSimple contract, managers can buy/sell STBT through the swap function. It will adjust the ETF position through _sendStableCoin and _sendSTBT functions respectively, and use _decimalsHandle function to perform decimal conversion between stableCoin and stbt tokens. However, due to the fact that solidity will truncate decimals when performing division operations, there will be some precision loss when converting large decimals to small decimals. This will cause the calculation result of _decimalsHandle to be smaller than the actual amount of tokens received by the ETF, causing the Record data of the ETF to be inconsistent with the actual balance. In fact, the rebalance function in the TBillSimple contract can alleviate the problem of the mismatch between the stableCoin balance and Record data, but the contract does not implement the rebalance operation for STBT tokens. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase4 - SlowMist Audit Report",
            "Type: Arithmetic Accuracy Deviation Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Incorrect DTBT amount update",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase4 - SlowMist Audit Report.pdf",
        "body": "In the TBillSimple contract, it uses DTBT instead of STBT for timely accounting operations. When ETF sells STBT, it will burn the balance of DTBT tokens in bPool and unbond them, but it does update the DTBT with the same balance through _updateDtbtAmount function by mistake, which will make the amount of DTBT tokens in bPool not decrease , which is not as expected by design. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase4 - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Invalid execution result capture",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase4 - SlowMist Audit Report.pdf",
        "body": "In the TBillSimple contract, the _invokeUnbind function is used to unbind the specied token in the ETF. It captures the result of the operation through try-catch , but does not process the result of the operation in the catch. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase4 - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Typo issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase4 - SlowMist Audit Report.pdf",
        "body": "In the smart join/exit pool function of the Actions contract, it will receive the handleToken parameter to specify the source token or target token of the token swap. But it is wrong to write this parameter as handleToekn. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase4 - SlowMist Audit Report",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "The length of minAmountsOut is not checked",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase4 - SlowMist Audit Report.pdf",
        "body": "In the Actions contract, the autoExitSmartPool function user removes the user's liquidity and converts the obtained tokens into the specied tokens, and performs a slippage check through the minAmountsOut parameter passed in by the user. However, the function does not check whether the length of the minAmountsOut list is the same as the length of the tokens. If the length of the incoming list is shorter than the expected length, the transaction may fail and waste gas. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase4 - SlowMist Audit Report",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Redundant approval operation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase4 - SlowMist Audit Report.pdf",
        "body": "In the Actions contract, the autoExitSmartPool function user removes user liquidity and converts the obtained tokens into specied tokens. It will rst approve the pool tokens in this contract to the contract itself, and then perform _exit operation. But the self-approval operation is meaningless. If the contract needs to transfer tokens, it can be transferred directly through transfer without approval, which is a waste of gas. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase4 - SlowMist Audit Report",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "The validity of the aggregator is not checked",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase4 - SlowMist Audit Report.pdf",
        "body": "In the Actions contract, the smart join/exit pool mode will help users exchange tokens through the _makeSwap function. It performs token exchange operations by calling the aggregator address specied by the user. It stipulates that the aggregator is composed of UNISWAPV2, UNISWAPV3, and ONEINCH through the SwapType enumeration, but in fact, the contract does not check whether the aggregator called by the user is a real and valid address. If the user is phished or the wrong address is passed in, it will result in a loss of funds or use the Actions contract to perform sensitive operations on the ETF. For example: when performing the swap through ONEINCH, it will not check the address of the caller and can pass in any call data. This allows the attacker to perform operations such as setController, approveUnderlying, addTokenToWhitelist, etc. on the pool when the user is phished. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase4 - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Pancakeswap-CakePool_en-us.pdf",
        "body": "In the cakePool contract, the owner role can set the DURATION_FACTOR and DURATION_FACTOR_OVERDUE by 7 calling the setDurationFactor and setDurationFactorOverdue. If these values are set too large or too small, this may aect the calculation of user.shares when calling the deposit and withdraw function. ",
        "labels": [
            "SlowMist",
            "Pancakeswap-CakePool",
            "Type: Authority Control Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Missing event records",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Pancakeswap-CakePool_en-us.pdf",
        "body": "In the cakePool contract, the owner role can set admin, treasury, operator, boostContract, freeFeeUsers, performanceFee, performanceFeeContract, withdrawFee, withdrawFeeContract, withdrawFeePeriod, MAX_LOCK_DURATION, DURATION_FACTOR, DURATION_FACTOR_OVERDUE, UNLOCK_FREE_DURATION and 8 BOOST_WEIGHT by calling the setAdmin, setTreasury, setOperator, setBoostContract, setFreeFeeUser, setPerformanceFee, setPerformanceFeeContract, setWithdrawFee, setWithdrawFeeContract, setWithdrawFeePeriod, setMaxLockDuration, setDurationFactor, setDurationFactorOverdue, setUnlockFreeDuration and setBoostWeight. but there no event logging is preformed. ",
        "labels": [
            "SlowMist",
            "Pancakeswap-CakePool",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Redundant collectEndTime check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report.pdf",
        "body": "In the CongurableRightsPool contract, users can redeem underlying assets through the exitPool function. When the pool is a closed ETF, it will check isCompletedCollect and collectEndTime to decide whether to perform _claimManagerFee operation. But when isCompletedCollect is true, the collectEndTime check will be performed in snapshotEndAssets, and when isCompletedCollect is false, the collectEndTime check will be performed in exitPoolHandleB. Hence the collectEndTime check before the _claimManagerFee operation is redundant. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Redundant closureEndTime check on exitPool",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report.pdf",
        "body": "In the CongurableRightsPool contract, users can redeem underlying assets through the exitPool function. When the pool is a closed ETF and isCloseEtfCollectEndWithFailure is false, it will check that the current time must be greater than closureEndTime + 5 minutes before allowing the user to exit. However, it should be noted that the snapshotEndAssets operation will be performed before this. The snapshotEndAssets function will also check whether the current time is greater than closureEndTime + 5 minutes . Only the admin and owner can execute snapshotEndAssets within 5 minutes after the closure period ends. Otherwise, the transaction will be reverted. Therefore, the closureEndTime check in the exitPool function is redundant. When snapshotEndAssets cannot be performed, the entire transaction will be reverted, and subsequent closureEndTime checks will not be performed. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Redundant performance fee calculation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report.pdf",
        "body": "In the exitPool function of the CongurableRightsPool contract, redeemAndPerformanceFeeReceived, nalAmountOut and redeemFeeReceived are calculated through exitPoolHandleA. However, since the performance fee will be calculated uniformly in the snapshotEndAssets operation, there is no need to process the performance fee in the exitPool function. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "The time allowed for snapshots is too short",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report.pdf",
        "body": "In the CongurableRightsPool contract when the closed ETF completes collect and the collection period has ended, the current total value of the ETF can be recorded through the snapshotBeginAssets function. However, users can only call the snapshotBeginAssets function within 15 minutes after the end of the collection period. If there is congestion on the chain, it may not be possible to call the snapshot in time within 15 minutes. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Duplicate decimal processing issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report.pdf",
        "body": "In the DesynChainlinkOracle contract, the getPrice function is used to obtain the corresponding token price from prices, getChainlinkPrice, and getUniswapPrice, and perform decimal processing. However, decimal has been processed in getChainlinkPrice and getUniswapPrice, and theoretically, the returned decimal will be 1e18. Therefore, processing decimals through decimalDelta will cause decimals to be enlarged. Note that the amountIn passed in for the consult in the getUniswapPrice function is 1e18, which needs to be ensured that the token decimal in twapOracle matches it in practice ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Decimal processing issue in AllPrice calculation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report.pdf",
        "body": "In the DesynChainlinkOracle contract, the getAllPrice function is used to calculate the total value of the specied amount of tokens. It is calculated by badd(fundAll, bmul(getPrice(t), tokenAmountOut)) , theoretically the decimal returned by getPrice is 1e18, and the decimal of tokenAmountOut is consistent with the decimal of the token itself. Therefore, multiplying these two values will result in a very large decimal in the nal result. The getNormalizedWeight function is also aected by this, but this is not harmful to normal business. Note: ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Redundant code issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report.pdf",
        "body": "In the SmartPoolManager library, the exitPoolHandle function has been deprecated since closed ETF prots are calculated in snapshotEndAssets. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Token list conict in recordTokenInfo",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report.pdf",
        "body": "When the user performs createPool and joinPool, if the Pool is a closed ETF and the current time is within the collection period, the KOL invitation amount will be recorded through UserVault's recordTokenInfo interface. But unfortunately, the tokens in the Pool can be Bind/unBind at any time, which will cause the list of tokens supported by the Pool to change. If the recordTokenInfo operation is performed when the Pool token list changes, the amount recorded by variables such as poolInviteTotal, kolTotalAmountList, and kolUserInfo may be disturbed. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "couldManagerClaim not checked when managerClaim",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report.pdf",
        "body": "In the UserVault contract, the Manager role can claim management fees through the managerClaim function, but it does not check whether the couldManagerClaim parameter is true. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Some redundant invoke functions",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report.pdf",
        "body": "In the Invoke library, the strictInvokeTransfer, invokeUnwrapWETH, invokeWrapWETH, and invokeMint functions are not used. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of ETF falsication",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report.pdf",
        "body": "In the RebalanceAdapter contract, the Manager role can adjust the position of the pool through the rebalance function. But the address of the ETF is obtained from the rebalanceInfo passed in by the user. If a malicious user passes in a fake ETF, the check in the onlyManager decorator will be bypassed, and the _verifyWhiteToken check of token1 and the isCompletedCollect and collectEndTime checks will be useless. Malicious users can steal bPool funds through _makeSwap and bind malicious tokens. The approve function also has this risk, but it doesn't break the protocol too much ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Risk of the Manager role potentially disrupting the protocol",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report.pdf",
        "body": "In the RebalanceAdapter contract, the Manager role can adjust the position of the ETF through the rebalance function. It will use the _makeSwap function to call Uniswap, 1inch and other DEXs for token swaps to adjust token positions. But unfortunately, the swap path of the token is not checked during the token swap process, which will cause the Manager role to pass in a carefully constructed malicious swap path to steal the middle token0 of the ETF. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Double slippage check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report.pdf",
        "body": "In the RebalanceAdapter contract, the Manager role can adjust the position of the ETF through the rebalance function. It will use the _makeSwap function to call Uniswap, 1inch and other DEXs for token swaps to adjust token positions. During the swap process, the slippage will be checked by passing minReturn to the external DEXs, but the implementation of the slippage check of the external DEXs is uncontrollable. If the slippage protection of the external DEXs fails, it will aect the funds of users in the protocol. (1inch users encountered invalid slippage check before) ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Does not follow the Checks-Eects-Interactions specication",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report.pdf",
        "body": "In the RebalanceAdapter contract, the _makeSwap function is used for token swap. When the swap type is not UNISWAPV3 and UNISWAPV2, the parameters passed in by the user will be checked through _validateData . However, the execute operation is performed rst, and the _validateData operation is performed after the token exchange is completed. This is not in line with the follow the Checks-Effects-Interactions principle. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Perform strict parameter checking",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report.pdf",
        "body": "In the RebalanceAdapter contract, the _validateData function is used to check the exchange parameters, but it only parses the recipient and amountIn for checking, but does not check whether other key parameters such as srcToken, dstToken, clipperExchange, makerAsset, takerAsset are in line with expectations. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Redundant aggregator parameter",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report.pdf",
        "body": "In the RebalanceAdapter contract, the _validateData function is used to check the conversion parameters, but the aggregator parameter it receives is not used. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Incorrect approval operation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report.pdf",
        "body": "In the RebalanceAdapter contract, the Manager role can adjust the position of the ETF through the rebalance function. If token1 has not been bound in bPool, it will be approved rst. However, the subsidy of this contract was wrongly approved to bPool, which will cause bPool to be unable to transfer tokens from CRP in the future. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report.pdf",
        "body": "There is an execute function in the CRP and bPool contracts so that the Manager can manage the ETF. In bFactory, the Blabs role can arbitrarily register modules to gain control over CRP. The registered modules can use the execute function in CRP to call the execute function in bPool to perform any operations. This would pose a huge risk to users' funds. And the Manager can approve the tokens in the bPool through the approve function of the RebalanceAdapter contract, which will also bring huge risks to the user's funds. The above problems lead to the risk of excessive permissions of the Blabs role and the Manager role. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Authority Control Vulnerability Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Enforce strict permission controls",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report.pdf",
        "body": "In the LiquidityPool contract, any user can call the joinPool, exitPool, and gulp functions to add/remove liquidity/record token balances, which will make it impossible to charge various fees to users in CRP. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Index conict issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm_Phase6_en-us.pdf",
        "body": "In the MIM strategy of ENF_V3, the getPID function is used to obtain the pool id of the specied LP token in ConvexBooster. Returns the current index if the match is successful, otherwise returns the 0 index. However, there is a corresponding LP (Curve. cDAI/cUSDC) conguration for the 0 index in ConvexBooster, which will make it impossible for the caller to determine whether the return of the 0 index is due to a matching failure or LP tokens in the 0 pool of ConvexBooster. ",
        "labels": [
            "SlowMist",
            "Earning.Farm_Phase6",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Visibility issue with getPID function",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm_Phase6_en-us.pdf",
        "body": "There is a getPID function with public visibility in the MIM strategy of ENF_V3, but this function is not called by other functions in this contract, so using public visibility will consume more gas than external visibility. ",
        "labels": [
            "SlowMist",
            "Earning.Farm_Phase6",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Read-only reentrancy checks subject to rounding errors",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm_Phase6_en-us.pdf",
        "body": "In the StETH contract in ENF_ETH_Lowrisk, the remove_liquidity_one_coin function will be called during the deposit and withdraw operations to avoid virtual price manipulation. However, the remove_liquidity_one_coin operation does not always succeed due to rounding errors in the calculation of _get_y_D . ",
        "labels": [
            "SlowMist",
            "Earning.Farm_Phase6",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Slippage check issue when Vault gets totalAssets",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm_Phase6_en-us.pdf",
        "body": "In the Vault contract of ENF_ETH_Lowrisk, the totalAssets function is used to obtain the total assets held by the protocol, which will be counted by calling the totalAssets function of each SS contract. In the FrxETH strategy, in order to ensure that the amount of totalAssets obtained has not been manipulated, a slippage check will be performed according to the fetch ag. Fetch is passed as true in the Vault contract, which will ignore the slippage check. ",
        "labels": [
            "SlowMist",
            "Earning.Farm_Phase6",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Logic optimization",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm_Phase6_en-us.pdf",
        "body": "In the FrxETH contract of ENF_ETH_Lowrisk, there are some functions to convert between share and asset through the totalSupply and totalAssets values of sFrx. However, these interfaces have been provided in the sFrx contract, and the calculated decimal is more accurate. Here is some alternative logic: The frxBal calculation in _totalAssets function can be done by ISfrx(sFrx).convertToAssets(sFrxBal) The lastEarnPrice calculation in _deposit function can be done by ISfrx(sFrx).pricePerShare() The currentPrice calculation in harvest function can be done by ISfrx(sFrx).pricePerShare() ",
        "labels": [
            "SlowMist",
            "Earning.Farm_Phase6",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Swap optimization from ETH to FrxETH",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm_Phase6_en-us.pdf",
        "body": "In the FrxETH contract of ENF_ETH_Lowrisk, the _deposit function will select the optimal exchange path according to the price of CurvePool. When the amount exchanged by CurvePool is greater than or equal to _amount (curveExpect >= _amount), it will exchange tokens through CurvePool . If curveExpect == _amount , converting through CurvePool may consume more gas than minting through frxMinter. ",
        "labels": [
            "SlowMist",
            "Earning.Farm_Phase6",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Redundant code",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Yield V1.0.0_en-us.pdf",
        "body": "Ether is not accepted by default, which is a redundant code. cross-send/contracts/CrossSend.sol#L41-L47 initial-hotcross-oering/contracts/BaseIHO.sol#L67-L73 fallback () external payable { revert(\"cannot directly accept currency transfers\"); } receive () external payable { revert(\"cannot directly receive currency transfers\"); 15 }",
        "labels": [
            "SlowMist",
            "Cross Yield V1.0.0",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Gas optimization",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Yield V1.0.0_en-us.pdf",
        "body": "If one of the batch transfers fails, the transaction that was previously transferred normally will be reverted, but Gas has been consumed. It is a gas optimization issue here. cross-send/contracts/CrossSend.sol#L175-L210 function sendToken( IERC20 token, address[] memory recipients, uint256[] memory amounts ) private returns(uint256) { uint256 total = 0; for (uint256 i = 0; i < recipients.length ; i++) { require(_msgSender() != recipients[i], \"sender != recipient\"); token.safeTransferFrom(_msgSender(), recipients[i], amounts[i]); total += amounts[i]; } return total; } function sendNative( address[] memory recipients, uint256[] memory amounts ) private returns(uint256) { uint256 total = 0; 16 for (uint256 i = 0; i < recipients.length ; i++) { total += amounts[i]; (bool success, ) = payable(recipients[i]).call{value: amounts[i]}(\"\"); require(success, \"native transfer failed\"); } return total; }",
        "labels": [
            "SlowMist",
            "Cross Yield V1.0.0",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of allowance amount abuse",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Yield V1.0.0_en-us.pdf",
        "body": "There have an allowance amount in the contract, but the distributeTokenFee function does not limit the caller, and there is an issue of being called arbitrarily, but it can only transfer the balance of the sender to the feeCollector. cross-send/contracts/fee-managers/RecipientCountFee.sol#L65-L83 function distributeTokenFee( uint256 txRecipientCount, uint256, uint256, uint256, uint256, address sender ) public override { uint256 payableFee = txRecipientCount * tokenFeePerRecipient; 17 if(payableFee < minTokenFee) { payableFee = minTokenFee; } else if (payableFee > maxTokenFee) { payableFee = maxTokenFee; } token.safeTransferFrom(sender, feeCollector, payableFee); }",
        "labels": [
            "SlowMist",
            "Cross Yield V1.0.0",
            "Type: Authority Control Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Price manipulation issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Yield V1.0.0_en-us.pdf",
        "body": "The IOUPrice is calculated using totalFarmingTokenBalance. Attackers can control totalFarmingTokenBalance to manipulate IOUPrice. The current code does not nd the location where IOUPrice is used. Referencehttps://slowmist.medium.com/cream-hacked-analysis-us-130-million-hacked-95c9410320ca cross-yield/contracts/core/CrossYield.sol#L95-L101 function IOUPrice() public view returns (uint256) { uint256 IOUSupply = totalSupply(); return IOUSupply == 0 ? 1e18 : (totalFarmingTokenBalance() * 1e18) / IOUSupply; } 18 cross-yield/contracts/core/CrossYield.sol#L65-L67 function totalFarmingTokenBalance() public view returns (uint256) { return farmingToken().balanceOf(address(this)) + strategy.balanceOf(); }",
        "labels": [
            "SlowMist",
            "Cross Yield V1.0.0",
            "Type: Others",
            "Severity: Medium"
        ]
    },
    {
        "title": "Sandwich attacks issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Yield V1.0.0_en-us.pdf",
        "body": "There is no slippage check during swap, and there is a risk of sandwich attack. IPancakeRouter02(pcsRouter).swapExactTokensForTokens(cakeBalance, 0,cakeToBaseRoute, address(this), block.timestamp); IPancakeRouter02(pcsRouter) .swapExactTokensForTokens(toSwap, 0, route, address(this), block.timestamp); Reference https://medium.com/coinmonks/demystify-the-dark-forest-on-ethereum-sandwich-attacks-5a3aec9fa33e cross-yield/contracts/libs/OptimalSwap.sol#L14-L63 function prepareLiquidity( address cake, address[2] memory lpTokens, 19 address wbnb, address busd, address farmingToken, address pcsRouter, uint256 fee ) external { uint256 cakeBalance = IERC20(cake).balanceOf(address(this)); bool isCakeInLp = lpTokens[0] == cake || lpTokens[1] == cake; bool isWbnbBased = lpTokens[0] == wbnb || lpTokens[1] == wbnb; address baseToken = isWbnbBased ? wbnb : busd; // if cake is not part of the lp token, swap all cake for the base token if (!isCakeInLp) { address[] memory cakeToBaseRoute = new address[](2); cakeToBaseRoute[0] = cake; cakeToBaseRoute[1] = baseToken; IPancakeRouter02(pcsRouter) .swapExactTokensForTokens(cakeBalance, 0, cakeToBaseRoute, address(this), block.timestamp); } (uint256 reserve0, uint256 reserve1,) = IPancakePair(farmingToken).getReserves(); address[] memory route = new address[](2); uint256 lp0Bal = IERC20(lpTokens[0]).balanceOf(address(this)); uint256 lp1Bal = IERC20(lpTokens[1]).balanceOf(address(this)); uint256 toSwap; // The possible cases here are: // - Cake was not part of the LP token, so we swap for baseToken which could either be lpToken0 or lpToken // - Cake was part of the LP token, so it can either be lpTokens[0] or lpTokens[1] // So, depending on which token we have the highest balance for, we swap for the other one. if (lp0Bal > lp1Bal) { toSwap = SwapAmount.getSwapAmount(lp0Bal, reserve0, fee); route[0] = lpTokens[0]; route[1] = lpTokens[1]; } else { toSwap = SwapAmount.getSwapAmount(lp1Bal, reserve1, fee); route[0] = lpTokens[1]; route[1] = lpTokens[0]; 20 } // Perform the swap IPancakeRouter02(pcsRouter) .swapExactTokensForTokens(toSwap, 0, route, address(this), block.timestamp); } IPancakeRouter02(pcsRouter).swapExactTokensForTokens(toWbnb, 0, cakeToWbnbRoute, address(this), block.timestamp); cross-yield/contracts/strategies/StrategyCake.sol#L131 function collectFees() internal { // a percentant of the cake we get from the masterchef will be used to buy BNB and transfer to this address // this is the total fees that will be shared amongst the protocol, stategy dev and the harvester uint256 toWbnb = feeManager.calculateTotalFee(IERC20(farmingToken).balanceOf(address(this))); IPancakeRouter02(pcsRouter).swapExactTokensForTokens(toWbnb, 0, cakeToWbnbRoute, address(this), block.timestamp); uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this)); // distribute hervester fee uint256 harvesterFeeAmount = feeManager.calculateHarvestFee(wbnbBal); // collectFees is called indirectly from the CrossYield contract via the beforeDeposit hook. // This means that _msgSender() is the CrossYield contract and not the actuall EOA account // that send the transaction IERC20(wbnb).safeTransfer(tx.origin, harvesterFeeAmount); // distribute protocol fee uint256 protocolFeeAmount = feeManager.calculateProtocolFee(wbnbBal); // IERC20(wbnb).safeTransfer(protocolFeeRecipient, protocolFeeAmount); feeProcessor.process(protocolFeeAmount); // distribute strategy dev fee uint256 strategyDevFeeAmount = feeManager.calculateStrategyDevFee(wbnbBal); IERC20(wbnb).safeTransfer(feeManager.strategyDev(), strategyDevFeeAmount); emit FeeCollected( toWbnb, 21 harvesterFeeAmount, protocolFeeAmount, strategyDevFeeAmount, _msgSender() ); } cross-yield/contracts/strategies/StrategyCakeLP.sol#L174 function collectFees() internal { // a percentant of the cake we get from the masterchef will be used to buy BNB and transfer to this address // this is the total fees that will be shared amongst the protocol, stategy dev and the harvester uint256 toWbnb = feeManager.calculateTotalFee(IERC20(cake).balanceOf(address(this))); IPancakeRouter02(pcsRouter).swapExactTokensForTokens(toWbnb, 0, cakeToWbnbRoute, address(this), block.timestamp); uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this)); // distribute hervester fee uint256 harvesterFeeAmount = feeManager.calculateHarvestFee(wbnbBal); IERC20(wbnb).safeTransfer(_msgSender(), harvesterFeeAmount); // distribute protocol fee uint256 protocolFeeAmount = feeManager.calculateProtocolFee(wbnbBal); feeProcessor.process(protocolFeeAmount); // distribute strategy dev fee uint256 strategyDevFeeAmount = feeManager.calculateStrategyDevFee(wbnbBal); IERC20(wbnb).safeTransfer(feeManager.strategyDev(), strategyDevFeeAmount); emit FeeCollected( toWbnb, harvesterFeeAmount, protocolFeeAmount, strategyDevFeeAmount, _msgSender() ); } cross-yield/contracts/strategies/StrategyCake.sol 22 function harvest() public override whenNotPaused { // claim rewards IMasterChef(masterchef).leaveStaking(0); // because harvest can automatically be called after each user deposit // we might end up having multiple deposits in the same block and only one // would return rewards from masterchef so the rest will have 0 cake so // we don't need to waste gas to collect fees and call deposit uint256 farmingTokenBalance = balanceOfFarmingToken(); if(farmingTokenBalance > 0) { collectFees(); deposit(); emit HarvestTriggered(_msgSender(), farmingTokenBalance); } } cross-yield/contracts/strategies/StrategyCakeLP.sol#l137-L148 function harvest() external override whenNotPaused { // claim rewards IMasterChef(masterchef).deposit(poolId, 0); uint256 harvestedAmount = IERC20(cake).balanceOf(address(this)); collectFees(); addLiquidity(); deposit(); emit HarvestTriggered(_msgSender(), harvestedAmount); }",
        "labels": [
            "SlowMist",
            "Cross Yield V1.0.0",
            "Type: Reordering Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Missing slippage check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Yield V1.0.0_en-us.pdf",
        "body": "The addLiquidity function without slippage check, it doesn't have an impermanent loss check. cross-yield/contracts/strategies/StrategyCakeLP.sol#L218 function addLiquidity() internal { OptimalSwap.prepareLiquidity( cake, [lpToken0, lpToken1], wbnb, busd, farmingToken, pcsRouter, swapFee ); // add liquidity to AMM on PCS uint256 lp0Bal = IERC20(lpToken0).balanceOf(address(this)); uint256 lp1Bal = IERC20(lpToken1).balanceOf(address(this)); IPancakeRouter02(pcsRouter) .addLiquidity(lpToken0, lpToken1, lp0Bal, lp1Bal, 0, 0, address(this), block.timestamp); emit LiquidityAdded(lpToken0, lpToken1, lp0Bal, lp1Bal, _msgSender()); }",
        "labels": [
            "SlowMist",
            "Cross Yield V1.0.0",
            "Type: Reordering Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Permission check Missing",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Yield V1.0.0_en-us.pdf",
        "body": "There is no permission check for deposit function. The function is called by the CrossYieid contract. cross-yield/contracts/strategies/StrategyCakeLP.sol#L225-L231 function deposit() public override whenNotPaused { uint256 farmingTokenBalance = balanceOfFarmingToken(); if (farmingTokenBalance > 0) { IMasterChef(masterchef).deposit(poolId, farmingTokenBalance); } } cross-yield/contracts/strategies/StrategyCake.sol#L169-L175 function deposit() public override whenNotPaused { uint256 farmingTokenBalance = balanceOfFarmingToken(); if (farmingTokenBalance > 0) { IMasterChef(masterchef).enterStaking(farmingTokenBalance); } }",
        "labels": [
            "SlowMist",
            "Cross Yield V1.0.0",
            "Type: Authority Control Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Excessive authority issue 25",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Yield V1.0.0_en-us.pdf",
        "body": "Owner can modify the address of the strategy. The new strategy may have security risks if it is not audited, which will aect the user's funds. If the private key is leaked, it will aect the user's funds. cross-yield/contracts/core/CrossYield.sol#L224-L236 function upgradeStrategy() public onlyOwner { require(stratCandidate.strategy != address(0), \"No proposal exists\"); require(block.number > stratCandidate.proposedBlock + stratUpgradableAfter, \"Strategy cannot be replaced yet\"); emit NewStrategy(stratCandidate.strategy); strategy.retireStrategy(); strategy = IStrategy(stratCandidate.strategy); stratCandidate.strategy = address(0); stratCandidate.proposedBlock = 0; putFundsToWork(); } cross-yield/contracts/core/CrossYield.sol#L211-L220 function proposeStrategy(address _strategy) public onlyOwner { require(address(this) == IStrategy(_strategy).vault(), \"Invalid new strategy\"); stratCandidate = StrategyCandidate({ strategy: _strategy, proposedBlock: block.number }); emit NewStratCandidate(_strategy); }",
        "labels": [
            "SlowMist",
            "Cross Yield V1.0.0",
            "Type: Authority Control Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Repeatable claims issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Yield V1.0.0_en-us.pdf",
        "body": "After the claim, lottery.status is not set as claimed, and it is also necessary to check whether lotteryId has been claimed when the claim is executed. hotdrop/contracts/HotDrop.sol#L261-L274 function claim(uint256 lotteryId) external nonReentrant { Lottery storage lottery = lotteries[lotteryId]; require(lottery.status == Status.WinnerDrawn, \"winner not drawn\"); // if there is no winner transfer the total amount to the treasury if(tickets[lotteryId][lottery.winningNumber] == address(0)) { lottery.purchaseToken.safeTransfer(treasury, lottery.purchaseToken.balanceOf(address(this))); } else if(tickets[lotteryId][lottery.winningNumber] == _msgSender()) { // if the ticket is the winning ticket and belongs to the user then split the pot uint256 treasuryAmount = (lottery.totalRaised * lottery.treasuryFee) / FEE_BASE; lottery.purchaseToken.safeTransfer(treasury, treasuryAmount); lottery.purchaseToken.safeTransfer(_msgSender(), lottery.totalRaised - treasuryAmount); } }",
        "labels": [
            "SlowMist",
            "Cross Yield V1.0.0",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Round plan security reminder",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Yield V1.0.0_en-us.pdf",
        "body": "And the new round of lottery can only be opened when the last round of lottery is in WinnerDrawn, otherwise randomGenerator.latestLotteryId will be updated, which will cause the old lottery round to fail to execute drawWinner function due to this check. require(lotteryId == randomGenerator.latestLotteryId(), \"numbers not drawn\"); hotdrop/contracts/HotDrop.sol#L44-L256 function drawWinner(uint256 lotteryId) external nonReentrant { Lottery storage lottery = lotteries[lotteryId]; require(lottery.status == Status.Close, \"lottery still active\"); require(lotteryId == randomGenerator.latestLotteryId(), \"numbers not drawn\"); // get the winning number based on the randomResult generated by ChainLink's fallback uint256 winningNumber = randomGenerator.randomResult(); lottery.winningNumber = winningNumber; lottery.status = Status.WinnerDrawn; emit LotteryNumberDrawn(lotteryId, winningNumber); }",
        "labels": [
            "SlowMist",
            "Cross Yield V1.0.0",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Re-initialize issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cook Distribution and Reward_en-us.pdf",
        "body": "In RewardVesting contract, the Governance role can re-initialize the the contract through initialize function Location function initialize(IERC20 _cookReward) external onlyGovernance { cookReward = _cookReward; }",
        "labels": [
            "SlowMist",
            "Cook Distribution and Reward",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing authority check 7",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cook Distribution and Reward_en-us.pdf",
        "body": "The addEarning function exists in the RewardVesting contract. When the claim operation is performed in the StakingPool contract, if the corresponding reward needs to be time locked, the addEarning function of the RewardVesting contract will be called to perform the locking operation. However, the visibility of this function is external, which will cause any user to perform the addEarning operation.  function addEarning(address user, uint256 amount, uint256 durationInSecs) external { _addPendingEarning(user, amount, durationInSecs); cookReward.safeTransferFrom(msg.sender, address(this), amount); }",
        "labels": [
            "SlowMist",
            "Cook Distribution and Reward",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Code x situation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Penpie Contracts Exploit Fixes - SlowMist Audit Report_en-us.pdf",
        "body": "In the x, the project team used OpenZeppelin's ReentrancyGuard library to modify the harvestMarketReward and batchHarvestMarketRewards functions in the PendleStaking contract to address the issue of reentering depositMarket. Additionally, they restricted the registerPool function in the PendleStaking contract to be callable only by the owner role to ensure that newly registered pools are reviewed. ",
        "labels": [
            "SlowMist",
            "Penpie Contracts Exploit Fixes - SlowMist Audit Report",
            "Type: Others",
            "Severity: Information"
        ]
    },
    {
        "title": "4.3.1.1 Risk of repeated contract initialization",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SmoothyV1_en-us.pdf",
        "body": "In the SmoothyMasterV1 contract, the owner can initialize the contract through the initialize function to set the address of key parameters such as SMTYToken, startTime, and communityAddr. However, there is no restriction on the initialize function to prevent repeated initialization calls, which will cause the owner role to repeatedly initialize the contract through the initialize function. The same goes for VotingEscrow and SmoothyV1 contracts. Fix suggestion: It is suggested to restrict the initialization function that does not allow repeated calls. ",
        "labels": [
            "SlowMist",
            "SmoothyV1",
            "Severity: High"
        ]
    },
    {
        "title": "4.3.2.1 Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SmoothyV1_en-us.pdf",
        "body": "In the SMTYToken contract, the minter role can mint tokens arbitrarily through the mint function. The owner role can arbitrarily modify the minter role address through the changeMinter function, which 10 will lead to the risk of excessive owner authority. Fix suggestion: It is suggested to transfer the owner authority to community governance. ",
        "labels": [
            "SlowMist",
            "SmoothyV1",
            "Severity: Medium"
        ]
    },
    {
        "title": "4.3.2.2 Denial of Service Risk",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SmoothyV1_en-us.pdf",
        "body": "In the SmoothyMasterV1 contract, the user can update all pools through the massUpdatePools function, but it uses the for loop to update cyclically. If the number of pools exceeds too much, it will cause a DoS risk. Fix suggestion: It is suggested to limit the number of pools to avoid this problem. function massUpdatePools() public { uint256 length = poolInfo.length; for (uint256 pid = 0; pid < length; ++pid) { updatePool(pid); } } Fix status: No Fixed. 11",
        "labels": [
            "SlowMist",
            "SmoothyV1",
            "Severity: Medium"
        ]
    },
    {
        "title": "4.3.3.1 The lockDuration does not match the lockEnd",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SmoothyV1_en-us.pdf",
        "body": "In the SmoothyMasterV1 contract, the user can extend the mortgage lock period through the extendLock function. When reconfirming the lockDuration, take the new lock duration and the smaller value of MAX_TIME, but in the end, when determining the lockEnd, the _end parameter is still directly passed in. Assigned to lockEnd, if the new lock duration is greater than MAX_TIME, this will cause the lockDuration to not match the lockEnd. Fix suggestion: It is suggested to recalculate lockEnd based on lockDuration. ",
        "labels": [
            "SlowMist",
            "SmoothyV1",
            "Severity: Low"
        ]
    },
    {
        "title": "4.3.3.1 Inaccurate calculation of LP amount",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SmoothyV1_en-us.pdf",
        "body": "In the SmoothyV1 contract, in order to save gas in mint, redeem, and swap operations, the 12 calculation using getMintAmount uses cached data for calculation, which will cause the final calculation result to be inconsistent with expectations. Fix suggestion: Due to project design requirements, it is suggested that the project party manually invoke the update when the update is not performed to avoid this issue. ",
        "labels": [
            "SlowMist",
            "SmoothyV1",
            "Severity: Low"
        ]
    },
    {
        "title": "4.3.4.1 The change of LP pool weights affects users' income",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SmoothyV1_en-us.pdf",
        "body": "In the SmoothyMasterV1 contract, when the Owner calls the add function and the set function to add a new pool or reset the pool weight, all LP pool weights will change accordingly. The Owner can update all pools before adjusting the weight by passing in the _withUpdate parameter with a value of true to ensure that the user's income before the pool weight is changed will not be affected by the adjustment of the pool weight, but if the value of the _withUpdate parameter is false, then All pools will not be updated before the pool weight is adjusted, which will cause the user's income to be affected before the pool weight is changed. Fix suggestion: It is suggested to force all LP pools to be updated before the weights of LP pools are adjusted to avoid the impact of user income. ",
        "labels": [
            "SlowMist",
            "SmoothyV1",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.3.4.2 Loss of precision issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SmoothyV1_en-us.pdf",
        "body": "In the SmoothyMasterV1 contract, when using the _updateWorkingAmount function to calculate the number of workingAmount users participate in mining, divide first and then multiply, which will result in loss of accuracy. Fix suggestion: It is suggested to multiply and then divide to avoid this issue ",
        "labels": [
            "SlowMist",
            "SmoothyV1",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.3.4.3 Unrecoverable issue of pool imbalance",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SmoothyV1_en-us.pdf",
        "body": "In the SmoothyV1 contract, when the user performs operations such as recharge, redemption, and exchange, the penalty mechanism will be triggered when the weight of the coin exceeds the soft cap, but the contract does not have an incentive mechanism to perform exchange operations to reduce the proportion of the token pool. If the token pool is maliciously manipulated to exceed the soft cap, it may be difficult for the token pool to return to normal due to no incentive mechanism, which will affect normal business use. 17 Fix suggestion: It is suggested to add an incentive mechanism in an unbalanced state to avoid this problem. ",
        "labels": [
            "SlowMist",
            "SmoothyV1",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.3.4.4 Risk of Potential Token Transfer Failure",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SmoothyV1_en-us.pdf",
        "body": "In the SmoothyV1 contract, when the user deposits the token, the safeTransferFrom function is used to transfer the corresponding token, and the safeTransfer function is used to transfer the token when withdrawToken. The safeTransferFrom function and safeTransfer function will check the returned success and data , If the connected token defines the return value, but does not return according to the EIP20 specification, the user will not be able to pass the check here, resulting in the tokens being unable to be transferred in or out. Fix suggestion: It is suggested that when docking new tokens, the project party should check whether its writing complies with EIP20 specifications. ",
        "labels": [
            "SlowMist",
            "SmoothyV1",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.3.4.5 Token compatibility issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SmoothyV1_en-us.pdf",
        "body": "In the SmoothyV1 contract, under the condition that each pool is stable, the exchange operation will be performed in a 1:1 manner. However, if the project is connected to a stable rebase algorithm, the number of tokens in the pool will be changed when it undergoes deflation, resulting in an unexpected 18 number of users during the exchange. Fix suggestion: It is suggested to strictly evaluate the algorithm model of stablecoins to avoid this risk when accessing stablecoins. ",
        "labels": [
            "SlowMist",
            "SmoothyV1",
            "Severity: Informational"
        ]
    },
    {
        "title": "Excessive authority issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ROTL_en-us.pdf",
        "body": "In the ROTL contract, the DEFAULT_ADMIN_ROLE can set the minter role, the minter role can mint ERC721A tokens arbitrarily and the minter role is entitled to free mint without going through each rounds. 11 ",
        "labels": [
            "SlowMist",
            "ROTL",
            "Type: Authority Control Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Pausable is not implemented",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ROTL_en-us.pdf",
        "body": "In the ROLTMint contract, it heritates the Pausable contract, but there is no pause and unpause function implemented. That means the value ot the _paused is false and can not be changed. Which will impact the __isEnable function and whenNotPaused modier. ",
        "labels": [
            "SlowMist",
            "ROTL",
            "Type: Others",
            "Severity: Low"
        ]
    },
    {
        "title": "Missing event record",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ROTL_en-us.pdf",
        "body": "1.In the ROTLMint contract, the owner role can set the _nft, _merkleRoot, _currentRound, price, maxCount, onceMaxCount, addressMaxCount, and startBlock values through the setAddress, setMerkleRoot, setRound, and setRoundInfo functions. But there are no no events logging performed. ",
        "labels": [
            "SlowMist",
            "ROTL",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Dev address setting enhancement suggestion 14",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ROTL_en-us.pdf",
        "body": "In the ROTLMint contract, the owner role can withdraw the native token through the withdraw function. If the owner is an EOA address, in a scenario where the private key is leaked, the teams revenue will be stolen. ",
        "labels": [
            "SlowMist",
            "ROTL",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Variable not used",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ROTL_en-us.pdf",
        "body": "In the ROLT contract, the contract dened the _mintContractAddress and _revealIndex value. But these two values are not assigned and can not be set. ",
        "labels": [
            "SlowMist",
            "ROTL",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Potential risks of approving denial of service",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn - Restaking - SlowMist Audit Report.pdf",
        "body": "In the invest function, when the user passes in a rawToken that is neither NATIVE_TOKEN nor _WST_ETH token, the contract will call the user-provided depositor to execute custom user data. Prior to this, the contract approves the user's transferred funds to the depositor using the safeApprove function. It is important to note that the safeApprove function requires either the current approved amount to be 0 or the current allowance of the contract to the depositor to be 0 in order to safely approve; otherwise, it will revert. If a malicious user intentionally does not use up all the allowance during the depositor call, when the protocol attempts to execute safeApprove for this rawToken again, it will revert. This will cause a denial of service for some of the contract's functionality. ",
        "labels": [
            "SlowMist",
            "DeSyn - Restaking - SlowMist Audit Report",
            "Type: Denial of Service Vulnerability",
            "Severity: High"
        ]
    },
    {
        "title": "Accidentally transferred funds that can be stolen",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn - Restaking - SlowMist Audit Report.pdf",
        "body": "In the invest function, when the user-specied rawToken is neither NATIVE_TOKEN nor _WST_ETH, the contract directly calls the depositor contract to execute user-specied data. When other users accidentally transfer rawTokens into the Restaking contract and the Restaking contract still has a remaining allowance for the depositor, these other users can deposit the accidentally transferred tokens into the depositor as their own prot. It is obvious that the project team can also transfer out the erroneously transferred assets in the contract by approving a specic depositor. ",
        "labels": [
            "SlowMist",
            "DeSyn - Restaking - SlowMist Audit Report",
            "Type: Others",
            "Severity: Information"
        ]
    },
    {
        "title": "Risk of user assets being stolen due to arbitrary execution of data",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn - Restaking - SlowMist Audit Report.pdf",
        "body": "In the invest function, when the user-specied rawToken is neither NATIVE_TOKEN nor _WST_ETH, the contract directly calls the depositor contract to execute user-specied data. It is important to note that in some restaking protocols (such as stETH and pufETH), the deposit, borrowing, and token transfer interfaces are in the same contract. Taking pufETH as an example, users can call the pufETH contract to make deposits and obtain pufETH tokens, and they can also call the pufETH contract to transfer pufETH tokens. Therefore, although the legality of the depositor is checked in the invest function, the restakingParams.data passed in by the user is not checked. This allows users to call the transferFrom function of the LST/LRT contract via restakingParams.depositor.functionCallWithValue to transfer tokens of any user who has already approved this contract. ",
        "labels": [
            "SlowMist",
            "DeSyn - Restaking - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Decimal problems in share calculation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn - Restaking - SlowMist Audit Report.pdf",
        "body": "In the invest function, when a user completes a restaking operation, the contract deposits the restaking tokens into the user-specied ETF and transfers the ETF LP to the user. Prior to this, the contract calculates the amount of ETF LP the user can obtain when joining the pool through _calculateShare . It is important to note that if the user's deposit amount is relatively small, due to decimal errors during calculation, the amount of LP obtained during the joinPool operation may be 1 wei more than the amount calculated by _calculateShare . However, this does not aect the normal business logic of the protocol. ",
        "labels": [
            "SlowMist",
            "DeSyn - Restaking - SlowMist Audit Report",
            "Type: Arithmetic Accuracy Deviation Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Issues where issueFee maybe 0",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn - Restaking - SlowMist Audit Report.pdf",
        "body": "In the _calculateShare function, it calculates the amount of LP that can be obtained based on the amount of tokens that need to be deposited into the ETF. In this process, it considers the minting fee charged when depositing into the ETF. However, it is important to note that if the user-specied ETF is closed-ended and the current isCompletedCollect state is false, the ETF will waive the minting fee for the depositor. This will cause the share calculated by the _calculateShare function to be smaller than expected, ultimately resulting in some funds remaining in the Restaking contract and not being deposited into the ETF. ",
        "labels": [
            "SlowMist",
            "DeSyn - Restaking - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Wrong slippage check issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cook Index_en-us.pdf",
        "body": "In the IssuanceModule contract, the _createTradeInfo function is used to create a structure containing trade data. Among them, it will obtain the thresholdAmounts parameter oset by slippage through the getMinAmountsOut function and the getMaxAmountsIn function. After the trade data is created, the trade operation will be executed 8 through the _executeTrade function, which will use the thresholdAmounts parameter as the minimum amounts to receive for trading on uniswap. However, since slippage check and trade execution are carried out in the same transaction, the thresholdAmounts parameter will still be aected by the last swap transaction of uniswap. Therefore, the slippage check cannot play a protective role. ",
        "labels": [
            "SlowMist",
            "Cook Index",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Logical redundancy issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cook Index_en-us.pdf",
        "body": "In the VesperWrapAdapter contract, getSpenderAddress is used to obtain the source token address of the wrap token, but the actual function logic directly returns the passed _wrappedToken parameter. This seems to be dierent from what the function comments indicate. ",
        "labels": [
            "SlowMist",
            "Cook Index",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of external calls 11",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cook Index_en-us.pdf",
        "body": "There are a large number of external calls in the IssuanceModule contract, but the external call part is not within the scope of this audit. It is necessary to pay attention to the unknown risks of external calls.",
        "labels": [
            "SlowMist",
            "Cook Index",
            "Type: Unsafe External Call Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Random can be predicted issue 15",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DODO-MiningV3 and NFT_en-us.pdf",
        "body": "The random number is uncertain when buying a ticket. However, there is no separate operation of using the redeeming tickets and determining the random number when redeeming tickets, and there is an issue that the random number can be predicted. https://github.com/DODOEX/contractV2/blob/453e323af6/contracts/DODODrops/DODODropsV2/DODODro ps.sol#L114 function buyTickets(address ticketTo, uint256 ticketAmount) payable external preventReentrant { (uint256 curPrice, uint256 sellAmount, uint256 index) = getSellingInfo(); require(curPrice > 0 && sellAmount > 0, \"CAN_NOT_BUY\"); require(ticketAmount <= sellAmount, \"TICKETS_NOT_ENOUGH\"); (uint256 payAmount, uint256 feeAmount) = IDropsFeeModel(_FEE_MODEL_).getPayAmount(address(this), ticketTo, curPrice, ticketAmount); require(payAmount > 0, \"UnQualified\"); uint256 baseBalance = IERC20(_BUY_TOKEN_).universalBalanceOf(address(this)); uint256 buyInput = baseBalance.sub(_BUY_TOKEN_RESERVE_); require(payAmount <= buyInput, \"PAY_AMOUNT_NOT_ENOUGH\"); _SELLING_AMOUNT_SET_[index] = sellAmount.sub(ticketAmount); _BUY_TOKEN_RESERVE_ = baseBalance.sub(feeAmount); IERC20(_BUY_TOKEN_).universalTransfer(_MAINTAINER_,feeAmount); _mint(ticketTo, ticketAmount); emit BuyTicket(ticketTo, payAmount, feeAmount, ticketAmount); } The owner determines the value of _REVEAL_RN_ by calling the setRevealRn function. The value of _REVEAL_RN_ will affect the result of the random number. https://github.com/DODOEX/contractV2/blob/453e323af6/contracts/DODODrops/DODODropsV2/DODODro ps.sol#L229 function setRevealRn() external onlyOwner { require(_REVEAL_RN_ == 0, \"ALREADY_SET\"); 16 _REVEAL_RN_ = uint256(keccak256(abi.encodePacked(blockhash(block.number - 1)))); emit SetReveal(); } The value of random is related to _REVEAL_RN_ , msg.sender , balanceOf(msg.sender) and curNo in REVEAL_MODE mode when users use wallets for transactions. Attackers can generate addresses and balances values to control the random number. In non-REVEAL_MODE mode, the value of random is related to _RNG_ , block.number , and gasleft . The attackers can sort transactions through pre-execution or in cooperation with miners. In this way, they can manipulate block.number and gasleft to control random numbers. https://github.com/DODOEX/contractV2/blob/453e323af6/contracts/DODODrops/DODODropsV2/DODODro ps.sol#L154-L159 function _redeemSinglePrize(address to, uint256 curNo, address referer) internal { require(block.timestamp >= _REDEEM_ALLOWED_TIME_ && _REDEEM_ALLOWED_TIME_ != 0, \"REDEEM_CLOSE\"); uint256 range; if(_IS_PROB_MODE_) { range = _PROB_INTERVAL_[_PROB_INTERVAL_.length - 1]; }else { range = _TOKEN_ID_LIST_.length; } uint256 random; if(_IS_REVEAL_MODE_) { require(_REVEAL_RN_ != 0, \"REVEAL_NOT_SET\"); random = uint256(keccak256(abi.encodePacked(_REVEAL_RN_, msg.sender, balanceOf(msg.sender).add(curNo + 1)))) % range; }else { random = IRandomGenerator(_RNG_).random(gasleft() + block.number) % range; } uint256 tokenId; if(_IS_PROB_MODE_) { uint256 i; for (i = 0; i < _PROB_INTERVAL_.length; i++) { if (random <= _PROB_INTERVAL_[i]) { break; } } require(_TOKEN_ID_MAP_[i].length > 0, \"EMPTY_TOKEN_ID_MAP\"); 17 tokenId = _TOKEN_ID_MAP_[i][random % _TOKEN_ID_MAP_[i].length]; IDropsNft(_NFT_TOKEN_).mint(to, tokenId, 1, \"\"); } else { tokenId = _TOKEN_ID_LIST_[random]; if(random != range - 1) { _TOKEN_ID_LIST_[random] = _TOKEN_ID_LIST_[range - 1]; } _TOKEN_ID_LIST_.pop(); IDropsNft(_NFT_TOKEN_).mint(to, tokenId); } emit RedeemPrize(to, tokenId, referer); }",
        "labels": [
            "SlowMist",
            "DODO-MiningV3 and NFT",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "isContract can be bypassed",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DODO-MiningV3 and NFT_en-us.pdf",
        "body": "When redeeming tickets isContract is used to determine whether the caller msg.sender is a contract. The contract is not allowed to be called, but the implementation of this check has flaws and can be bypassed. https://github.com/DODOEX/contractV2/blob/453e323af6/contracts/DODODrops/DODODropsV2/DODODro ps.sol#L135 18 function redeemTicket(uint256 ticketNum, address referer) external { require(!address(msg.sender).isContract(), \"ONLY_ALLOW_EOA\"); require(ticketNum >= 1 && ticketNum <= balanceOf(msg.sender), \"TICKET_NUM_INVALID\"); _burn(msg.sender,ticketNum); for (uint256 i = 0; i < ticketNum; i++) { _redeemSinglePrize(msg.sender, i, referer); } } https://github.com/DODOEX/contractV2/blob/453e323af6/contracts/external/utils/Address.sol#L27 function isContract(address account) internal view returns (bool) { // This method relies on extcodesize, which returns 0 for contracts in // construction, since the code is only stored at the end of the // constructor execution. uint256 size; // solhint-disable-next-line no-inline-assembly assembly { size := extcodesize(account) } return size > 0; }",
        "labels": [
            "SlowMist",
            "DODO-MiningV3 and NFT",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Excessive authority issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DODO-MiningV3 and NFT_en-us.pdf",
        "body": "The owner can control the source of the seed of the random number. The seed of the random number will affect the value of the random number and affect the probability of redeeming the ticket. 19 https://github.com/DODOEX/contractV2/blob/453e323af6/contracts/DODODrops/DODODropsV2/DODODro ps.sol#L227 function setRevealRn() external onlyOwner { require(_REVEAL_RN_ == 0, \"ALREADY_SET\"); _REVEAL_RN_ = uint256(keccak256(abi.encodePacked(blockhash(block.number - 1)))); emit SetReveal(); } The owner can change the value of _RNG_ , which will affect the random number of the redemption ticket if it is not REVEAL_MODE. https://github.com/DODOEX/contractV2/blob/453e323af6/contracts/DODODrops/DODODropsV2/DODODro ps.sol#L259 function updateRNG(address newRNG) external onlyOwner { require(newRNG != address(0)); _RNG_ = newRNG; emit ChangeRNG(newRNG); } The owner can transfer _REWARD_TOKEN_ to any address. The current design framework Owner address will be sent to the address of the Mine contract. https://github.com/DODOEX/contractV2/blob/c7202eeae7/contracts/DODOToken/DODOMineV3/RewardVau lt.sol#L38-L49 function reward(address to, uint256 amount) external onlyOwner { require(_REWARD_RESERVE_ >= amount, \"VAULT_NOT_ENOUGH\"); _REWARD_RESERVE_ = _REWARD_RESERVE_.sub(amount); IERC20(_REWARD_TOKEN_).safeTransfer(to, amount); } function withdrawLeftOver(address to,uint256 amount) external onlyOwner { require(_REWARD_RESERVE_ >= amount, \"VAULT_NOT_ENOUGH\"); 20 _REWARD_RESERVE_ = _REWARD_RESERVE_.sub(amount); IERC20(_REWARD_TOKEN_).safeTransfer(to, amount); } The owner can mint tokens for any user and burn any user's tokens. https://github.com/DODOEX/contractV2/blob/c7202eeae7/contracts/external/ERC20/CustomERC20.sol#L12 3-L138 function mint(address user, uint256 value) external onlyOwner { require(isMintable, \"NOT_MINTABEL_TOKEN\"); balances[user] = balances[user].add(value); totalSupply = totalSupply.add(value); emit Mint(user, value); emit Transfer(address(0), user, value); } function burn(address user, uint256 value) external onlyOwner { require(isMintable, \"NOT_MINTABEL_TOKEN\"); balances[user] = balances[user].sub(value); totalSupply = totalSupply.sub(value); emit Burn(user, value); emit Transfer(user, address(0), value); } The owner can update the template contract. If an unaudited template contract is updated, this will affect the assets of the new user in the newly created contract. https://github.com/DODOEX/contractV2/blob/c7202eeae7/contracts/SmartRoute/proxies/DODOMineV3Prox y.sol#L128 function updateMineV2Template(address _newMineV3Template) external onlyOwner { _MINEV3_TEMPLATE_ = _newMineV3Template; } https://github.com/DODOEX/contractV2/blob/7e629d0e58/contracts/Factory/ERC20V2Factory.sol 21 function updateStdTemplate(address newStdTemplate) external onlyOwner { _ERC20_TEMPLATE_ = newStdTemplate; emit ChangeStdTemplate(newStdTemplate); } function updateCustomTemplate(address newCustomTemplate) external onlyOwner { _CUSTOM_ERC20_TEMPLATE_ = newCustomTemplate; emit ChangeCustomTemplate(newCustomTemplate); }",
        "labels": [
            "SlowMist",
            "DODO-MiningV3 and NFT",
            "Type: Authority Control Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "The DoS risk",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DODO-MiningV3 and NFT_en-us.pdf",
        "body": "Use a for loop to traverse the array. If the number of loops is large, it will cause an out of gas. After communication and feedback, the project team will ensure that the number of rewardTokenInfos will not be too much. 22 https://github.com/DODOEX/contractV2/blob/c7202eeae7/contracts/DODOToken/DODOMineV3/BaseMine.s ol#L258 function _updateAllReward(address user) internal { uint256 len = rewardTokenInfos.length; for (uint256 i = 0; i < len; i++) { _updateReward(user, i); } }",
        "labels": [
            "SlowMist",
            "DODO-MiningV3 and NFT",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Event log missing",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DODO-MiningV3 and NFT_en-us.pdf",
        "body": "The owner can arbitrarily set an external contract address as a template contract. When a user creates a new contract, it will be created based on the template contract. After creation, the asset needs to be recharged to the new contract. There is no event record, which is unfavorable for review by community users. https://github.com/DODOEX/contractV2/blob/c7202eeae7/contracts/SmartRoute/proxies/DODOMineV3Prox y.sol#L128 function updateMineV2Template(address _newMineV3Template) external onlyOwner { _MINEV3_TEMPLATE_ = _newMineV3Template; } The owner can modify the configuration of the contract, but there is no event record, which is unfavorable for review by community users. 23 https://github.com/DODOEX/contractV2/blob/c7202eeae7/contracts/Factory/Registries/DODOMineV3Registr y.sol#L87-L101 function addAdminList (address contractAddr) external onlyOwner { isAdminListed[contractAddr] = true; } function removeAdminList (address contractAddr) external onlyOwner { isAdminListed[contractAddr] = false; } function addSingleTokenList(address token) external onlyOwner { singleTokenList[token] = true; } function removeSingleTokenList(address token) external onlyOwner { singleTokenList[token] = false; }",
        "labels": [
            "SlowMist",
            "DODO-MiningV3 and NFT",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Check enhancement of isLpToken",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DODO-MiningV3 and NFT_en-us.pdf",
        "body": "Admin can add non-LPtoken assets but isLpToken is True, or belong to LPtoken assets but isLpToken is False Pool, which will affect the actual business logic. This part of the inspection is not implemented in the contract. https://github.com/DODOEX/contractV2/blob/c7202eeae7/contracts/Factory/Registries/DODOMineV3Registr y.sol#L44 function addMineV3( address mine, 24 bool isLpToken, address stakeToken ) override external { require(isAdminListed[msg.sender], \"ACCESS_DENIED\"); _MINE_REGISTRY_[mine] = stakeToken; if(isLpToken) { _LP_REGISTRY_[stakeToken] = mine; }else { require(_SINGLE_REGISTRY_[stakeToken].length == 0 || singleTokenList[stakeToken], \"ALREADY_EXSIT_POOL\"); _SINGLE_REGISTRY_[stakeToken].push(mine); } emit NewMineV3(mine, stakeToken, isLpToken); }",
        "labels": [
            "SlowMist",
            "DODO-MiningV3 and NFT",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Security reminder on architecture design",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DODO-MiningV3 and NFT_en-us.pdf",
        "body": "createStdERC20 and createMintableERC20 are open-ended calls. The user creates a contract using the createStdERC20 function to record the created information in _USER_STD_REGISTRY_ , and then can get the information through getTokenByUser. Because it is an open call, it is not recommended to use the data obtained by getTokenByUser. As input for other businesses, after communication and feedback, the project party will not rely on the data obtained by getTokenByUser in the business logic of the project. https://github.com/DODOEX/contractV2/blob/c7202eeae7/contracts/Factory/ERC20V2Factory.sol#L72-L123 function createStdERC20( uint256 totalSupply, string memory name, 25 string memory symbol, uint256 decimals ) external returns (address newERC20) { newERC20 = ICloneFactory(_CLONE_FACTORY_).clone(_ERC20_TEMPLATE_); IStdERC20(newERC20).init(msg.sender, totalSupply, name, symbol, decimals); _USER_STD_REGISTRY_[msg.sender].push(newERC20); emit NewERC20(newERC20, msg.sender, 0); } function createCustomERC20( uint256 initSupply, string memory name, string memory symbol, uint256 decimals, uint256 tradeBurnRatio, uint256 tradeFeeRatio, address teamAccount, bool isMintable ) external returns (address newCustomERC20) { newCustomERC20 = ICloneFactory(_CLONE_FACTORY_).clone(_CUSTOM_ERC20_TEMPLATE_); ICustomERC20(newCustomERC20).init( msg.sender, initSupply, name, symbol, decimals, tradeBurnRatio, tradeFeeRatio, teamAccount, isMintable ); _USER_CUSTOM_REGISTRY_[msg.sender].push(newCustomERC20); if(isMintable) emit NewERC20(newCustomERC20, msg.sender, 2); else emit NewERC20(newCustomERC20, msg.sender, 1); } // ============ View ============ function getTokenByUser(address user) external 26 view returns (address[] memory stds,address[] memory customs) { return (_USER_STD_REGISTRY_[user], _USER_CUSTOM_REGISTRY_[user]); }",
        "labels": [
            "SlowMist",
            "DODO-MiningV3 and NFT",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Pages calculation issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SubDao_en-us.pdf",
        "body": "In the DaoFactory contract, calculatePages is used to calculate the start index and end index of a page. The size, start index and end index are checked in the function size <= 0 || start >= total || start < end , but in fact, size should not be less than 0, and start should not be greater than total. ",
        "labels": [
            "SlowMist",
            "SubDao",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Missing event records",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SubDao_en-us.pdf",
        "body": "In the DaoTemplate contract, the user can modify the actionCong parameter through the setActionCong function, but no event recording is performed. The same is true for the setActionCong function in the VentureTemplate contract. The same is true for the setCanFreeAddMember, transferOwner and updateOwnership functions in the OrgManager contract. ",
        "labels": [
            "SlowMist",
            "SubDao",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Owner update issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SubDao_en-us.pdf",
        "body": "In the DaoTemplate contract, the owner can update the owner of all components through the updateOwnership function. But it calls the updateOwnership interface of the templateCong contract by mistake. The same is true for the updateOwnership function in the VentureTemplate contract. ",
        "labels": [
            "SlowMist",
            "SubDao",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "State Coverage Risk",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SubDao_en-us.pdf",
        "body": "In the GrantMethodManager contract, DaoTemplate can operate the applyOp and setUserOpByOwner functions through the action contract. Since the parameters it receives are all passed in from the outside, if the incoming data is repeated, the encoded key will be repeated, which will cause the existing data to be overwritten. ",
        "labels": [
            "SlowMist",
            "SubDao",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "TODO label issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SubDao_en-us.pdf",
        "body": "There is still a TODO label in the spendTokenInLimit function of the GrantMethodManager contract. Is there still a function not perfect? The same is true for the _unsafeCancelVote function in the VoteManager contract. ",
        "labels": [
            "SlowMist",
            "SubDao",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Length check issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SubDao_en-us.pdf",
        "body": "The initialize function exists in the VenturesStockManager , VenturesManager and GovTokenManager contracts to initialize the contract according to the incoming parameters. It checks the byte length of the incoming parameter, but because some parameters are variable-length data, forcing an equals check will lead to unsuccessful initialization. ",
        "labels": [
            "SlowMist",
            "SubDao",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Vote check issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SubDao_en-us.pdf",
        "body": "In the VoteManager contract, the _canExecute function is used to check whether the proposal can be executed, but it does not check whether the number of yes votes is greater than the number of negative votes. ",
        "labels": [
            "SlowMist",
            "SubDao",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Cancel voting issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SubDao_en-us.pdf",
        "body": "29 In the VoteManager contract, the _canCancel function user checks whether the current vote can be cancelled. If the voting period for a proposal has passed, but the execution conditions are still not met, the proposal cannot be executed or cancelled. ",
        "labels": [
            "SlowMist",
            "SubDao",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Risk of Governance Attacks",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SubDao_en-us.pdf",
        "body": "DAO members can create new proposals through ActionVoteNew , ActionGrantMethodRegister , ActionVoteTransferPeriodRegister and other contracts. However, the proposal does not contain the data that needs to be executed. After the proposal is passed, the community members will pass in the specic execution data for execution. If malicious data is passed in, there is a risk that the protocol will be maliciously broken during proposal execution.",
        "labels": [
            "SlowMist",
            "SubDao",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Potential Fund Theft Risk",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SubDao_en-us.pdf",
        "body": "As mentioned in N12, when a DAO member creates an Operation through ActionGrantMethodRegister, the user's specic execution data is not recorded in the newVote operation. Although registerOp records the extra data passed in by the user, it is not used op_.extra in actual execution. Therefore, the user can pass in valid execution data when performing the registerOp operation. And malicious data is passed in during the ActionVaultUniswapV2Router02Swap operation. This will result in funds managed by the DAO being approved for malicious router contracts, or swapping through extremely illiquid pools, allowing malicious users to easily arbitrage. This would create huge risks for DAOs. The same is true in the ActionVaultUniswapV2SwapToken contract. ",
        "labels": [
            "SlowMist",
            "SubDao",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Lack of access control",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SubDao_en-us.pdf",
        "body": "In the VenturesManager contract, the gpRaiseMoney and lpRaiseMoney functions are not restricted to be called by the owner. ",
        "labels": [
            "SlowMist",
            "SubDao",
            "Type: Authority Control Vulnerability",
            "Severity: High"
        ]
    },
    {
        "title": "Period transfer issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SubDao_en-us.pdf",
        "body": "In the ActionVoteTransferPeriodApply contract, when performing a period transfer, the period will be obtained through the transferPeriodStates function of the VoteExecutionManager contract, and then the period will be transferred through the transferVenturePeriod function of the VenturesManager contract. But in the current action, period is directly transferred to SettlementPeriod. ",
        "labels": [
            "SlowMist",
            "SubDao",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - X2Y2 - NFT Lending_en-us.pdf",
        "body": "1.In the Cong contract, the owner role can add manager role and can update the adminShare, and the manager role can set or remove the ERC20 and ERC721 tokens through the setERC20Permits and setERC721Permits functions. If the ERC20 and ERC721 on the loan list, the manager sets these permit as false may cause the risk of excessive authority. ",
        "labels": [
            "SlowMist",
            "X2Y2 - NFT Lending",
            "Type: Authority Control Vulnerability",
            "Severity: High"
        ]
    },
    {
        "title": "Token compatibility issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - X2Y2 - NFT Lending_en-us.pdf",
        "body": "In the XY3 contract, the lender will transfer the ERC20 token to the borrower in the borrow function also to the lender and adminFeeReceiver in the repay function. And this transfer is used the SafeER20 safeTransferFrom function and transfer the exact amount of the borrowAmount, payoAmount and adminFee. If the borrowAsset ERC20 tokens are the deationary tokens (or other tokens that require a transfer fee) which will cause the call failed. ",
        "labels": [
            "SlowMist",
            "X2Y2 - NFT Lending",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Dev address setting enhancement suggestions",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - X2Y2 - NFT Lending_en-us.pdf",
        "body": "In the Cong contract, the manager role can update the adminFeeReceiver in the updateAdminFeeReceiver function to receive the adminFee. If the adminFeeReceiver address is an EOA address, in a scenario where the private key is leaked, the teams revenue will be stolen. ",
        "labels": [
            "SlowMist",
            "X2Y2 - NFT Lending",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "The deationary token docking issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - CakeVault_en-us.pdf",
        "body": "Users can transfer the cake token into the vault contract through the deposit function. Under normal circumstances, the number of staking tokens transferred by the user is the same as the _amount parameter passed in. But if the staking token is a deationary token, the number of tokens transferred by the user may be dierent from the number of tokens actually received in the contract. ",
        "labels": [
            "SlowMist",
            "CakeVault",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "CakeAtLastUserAction parameter record error issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - CakeVault_en-us.pdf",
        "body": "In the Vault contract, the user can withdraw the funds staked by the user through the withdraw function. If the user does not withdraw all funds (user.shares> 0), this function will recalculate the user's cakeAtLastUserAction value. In the calculation process, the number of cake tokens obtained by the balanceOf function is used to participate in the calculation. But at the end of this function, a certain amount of cake tokens will be transferred to the user through the safeTransfer function, so the number of cake tokens obtained by the balanceOf function used in the calculation of cakeAtLastUserAction is relatively large. ",
        "labels": [
            "SlowMist",
            "CakeVault",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing event records",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - CakeVault_en-us.pdf",
        "body": "In the contract, the owner role can set the addresses of the admin role and the treasure role through the setAdmin function and the setTreasury function, respectively, but no event recording is performed. In the contract, the admin role can change the sensitive parameters of the contract through the setPerformanceFee, setCallFee, setWithdrawFee, and setWithdrawFeePeriod functions, but no event recording is performed. ",
        "labels": [
            "SlowMist",
            "CakeVault",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Emergency withdrawal issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - CakeVault_en-us.pdf",
        "body": "In the Vault contract, the admin role can make emergency withdrawals of cake tokens from the MasterChef contract to the Vault contract via the emergencyWithdraw function. However, it should be noted that any user can obtain 0.25% of the cake token reward in the Vault contract through the harvest function, and re-stake the remaining cake tokens into the MasterChef contract. So if the emergencyWithdraw operation is performed while the contract is not suspended it may cause unintended results. 10 ",
        "labels": [
            "SlowMist",
            "CakeVault",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Partial logic not implemented",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Das Contract Reverse_en-us.pdf",
        "body": "In the setReverseName function of the ReverseLogic contract, after the previous check, the specic check logic when the owner is still 0 address is not implemented. ",
        "labels": [
            "SlowMist",
            "Das Contract Reverse",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Potential risk of arbitrarily setting reverse name",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Das Contract Reverse_en-us.pdf",
        "body": "In the ReverseLogic contract, the user can set the reverse name through the setReverseName function, which allows the contract to set itself. However, some contracts have the feature of arbitrary external calls, which will allow any user to set the reverse name of the contract. ",
        "labels": [
            "SlowMist",
            "Das Contract Reverse",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "4.2.1.1 The settleHolderInterest is not used to update user interest before Withdraw",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - dFuture_en-us.pdf",
        "body": "The code uses payOffInterest to process the user's interest when processing the user's withdraw, but it did not use settleHolderInterest to update the user's interest situation before, resulting in a deviation in the interest payment. ",
        "labels": [
            "SlowMist",
            "dFuture",
            "Severity: Low"
        ]
    },
    {
        "title": "4.2.1.2 The global status is not updated when using the getMarginRatioOf function",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - dFuture_en-us.pdf",
        "body": "to calculate the user's position When using the getMarginRationOf function to calculate the user's position, the global state is not updated with updateGlobalInterestRate first, which may cause calculation errors. ",
        "labels": [
            "SlowMist",
            "dFuture",
            "Severity: Low"
        ]
    },
    {
        "title": "4.2.1.3 When calculating the user's position,",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - dFuture_en-us.pdf",
        "body": "the user's intereset <0 is not considered When using the getMarginRationOf function to calculate the user's position, the case of rate <0 is not 22 processed. ",
        "labels": [
            "SlowMist",
            "dFuture",
            "Severity: Low"
        ]
    },
    {
        "title": "4.2.2.1 did not consider the issue of system compensation, and did not limit the",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - dFuture_en-us.pdf",
        "body": "maximum benefits of users The system code does not consider whether the system can pay for this when processing the user's position closing. When this happens, it will cause an unknown error. ",
        "labels": [
            "SlowMist",
            "dFuture",
            "Severity: Low"
        ]
    },
    {
        "title": "Missing Checking",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap_en-us.pdf",
        "body": "In PancakeSwapRouter contract, the removeLiquidity / removeLiquidityETH / removeLiquidityWithPermit function does not check whether a pair is exist, which will leads to gas wasting when a pair does not exist. eg. removeLiquidity function function removeLiquidity( address tokenA, address tokenB, uint liquidity, uint amountAMin, uint amountBMin, address to, uint deadline ) public virtual override ensure(deadline) returns (uint amountA, uint amountB) { 13 address pair = PancakeLibrary.pairFor(factory, tokenA, tokenB); IPancakePair(pair).transferFrom(msg.sender, pair, liquidity); // send liquidity to pair (uint amount0, uint amount1) = IPancakePair(pair).burn(to); (address token0,) = PancakeLibrary.sortTokens(tokenA, tokenB); (amountA, amountB) = tokenA == token0 ? (amount0, amount1) : (amount1, amount0); require(amountA >= amountAMin, 'PancakeRouter: INSUFFICIENT_A_AMOUNT'); require(amountB >= amountBMin, 'PancakeRouter: INSUFFICIENT_B_AMOUNT'); }",
        "labels": [
            "SlowMist",
            "PancakeSwap",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Open Social - Abstract Account_en-us.pdf",
        "body": "1.In the VerifyingSingletonPaymaster contract, the DEFAULT_ADMIN_ROLE can arbitrarily set the unaccountedEPGasOverhead parameters. If this parameter is set too high, paymasterIdBalances may be consumed maliciously. ",
        "labels": [
            "SlowMist",
            "Open Social - Abstract Account",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Ordinary users with permitCalls may use the owner privilege through arbitrary contract calls",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Open Social - Abstract Account_en-us.pdf",
        "body": "The execute and executeBatch functions allow ordinary users to call the contracts which in the permitCalls with arbitrary calldata, can control their native token or ERC20 token assets by these functions. However, this functionality can be abused and users calling the contract itself (OspAccount) through the EntryPoint contract will then be able to call functions like setOwner, setRecoveryAddress, setPermitCall, and revokeSessionKey functions, thus overstepping their authority. ",
        "labels": [
            "SlowMist",
            "Open Social - Abstract Account",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing the event records",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Open Social - Abstract Account_en-us.pdf",
        "body": "In the WhitelistOperationVerifyingPaymaster and the OspAccountFactory contracts, the ADMIN and DEFAULT_ADMIN_ROLE can arbitrarily modify OperationInPut , enableWhitelistOperation , and accountImplementation parameters, but there are no event logs in these functions. ",
        "labels": [
            "SlowMist",
            "Open Social - Abstract Account",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing zero address validation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Open Social - Abstract Account_en-us.pdf",
        "body": "In the OspAccount and the OspAccountFactory contracts, it lacks a zero-check when setting addresses. ",
        "labels": [
            "SlowMist",
            "Open Social - Abstract Account",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "ERC777 reentrancy risk reminder",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Open Social - Abstract Account_en-us.pdf",
        "body": "ERC777 tokens are vulnerable to reentrancy attacks due to a design aw. In the TokenCallbackHandler contract, the deprecated ERC777 standard tokensReceived has been introduced into the contract. If there is any need to deal with ERC77 tokens in the project, strict attention needs to be paid to whether there is reentrancy risk. ",
        "labels": [
            "SlowMist",
            "Open Social - Abstract Account",
            "Type: Unsafe External Call Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing event log",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Arowana_en-us.pdf",
        "body": "The owner role can call the addToken and removeToken functions to add and remove the specied token address into the _addresses and _indexes . If there is no event record, it is not conducive to the review of community users. ",
        "labels": [
            "SlowMist",
            "Arowana",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing event log",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Arowana_en-us.pdf",
        "body": "7 The owner role can call the setValut function to set the source of reward token distribution. If there is no event record, it is not conducive to the review of community users. ",
        "labels": [
            "SlowMist",
            "Arowana",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing balance change",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Arowana_en-us.pdf",
        "body": "When the user calls the withdraw function for withdrawal ( block.timestap >= pool.end ), the balance of pool is not changed here. ",
        "labels": [
            "SlowMist",
            "Arowana",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Missing balance check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Arowana_en-us.pdf",
        "body": "When the user calls the withdraw function for withdrawal ( block.timestap >= pool.end ), there is a lack of judgment on the balance of valut. If the token balance of valut is not enough to pay the user's reward, the transaction will be rolled back and the user's principal and reward cannot be withdrawn. ",
        "labels": [
            "SlowMist",
            "Arowana",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Lack of access control issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning Farm - ETH Leverage_en-us.pdf",
        "body": "In the BalancerReceiver contract, the SS contract can initiate WETH ash loans through the ashLoan function, but the ashLoan function allows any user to call. Although the loanFallback function of the SS contract checks curState, it is undoubtedly more expected that the ashLoan function can only be called by the SS contract. 10 ",
        "labels": [
            "SlowMist",
            "Earning Farm - ETH Leverage",
            "Type: Authority Control Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Gas optimization",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning Farm - ETH Leverage_en-us.pdf",
        "body": "In the ETHLeverage contract, the _harvest function is used to collect fees, which will only be charged when lastEarnBlock and block.number are used. But the function does not check whether the dierence between lastEarnBlock and block.number is 0. If multiple users in the same block trigger the _harvest function, it will cause unnecessary gas consumption. ",
        "labels": [
            "SlowMist",
            "Earning Farm - ETH Leverage",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Redundant logic issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning Farm - ETH Leverage_en-us.pdf",
        "body": "In the Controller contract, the owner can set the exchange and harvestFee parameters respectively through the setExchange and setHarvestFee functions. But in this contract the exchange and harvestFee parameters are not used. ",
        "labels": [
            "SlowMist",
            "Earning Farm - ETH Leverage",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "The problem of checking the number of swaps",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning Farm - ETH Leverage_en-us.pdf",
        "body": "In the ETHLeverExchange contract, the swapExactETH function is used to exchange stETH to ETH during emergency withdrawal. It will get the amount of ETH that can be exchanged through the get_dy function and check if the swap amount is larger than the expected required amount. But in theory it is acceptable for the number of swaps to be equal to what is expected to be required. ",
        "labels": [
            "SlowMist",
            "Earning Farm - ETH Leverage",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning Farm - ETH Leverage_en-us.pdf",
        "body": "In the protocol, the owner role has many permissions, such as: the owner can set sensitive parameters, can suspend the contract, can make emergency withdrawals, can migrate the funds of the SS contract, etc. It is obviously inappropriate to give all the permissions of the protocol to the owner, which will greatly increase the single point of 13 risk.",
        "labels": [
            "SlowMist",
            "Earning Farm - ETH Leverage",
            "Type: Authority Control Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Risk of exchange slippage",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning Farm - ETH Leverage_en-us.pdf",
        "body": "When users make withdrawals in the protocol, they need to exchange stETH tokens for ETH tokens through CurvePool. However, the exchange slippage is not limited in the ETHLeverExchange contract, which will make users vulnerable to sandwich attacks when withdrawing. ",
        "labels": [
            "SlowMist",
            "Earning Farm - ETH Leverage",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Medium Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Ultiverse - Chips Contract_en-us.pdf",
        "body": "1.In the GoldChip contract, the owner role can modify key sensitive parameters such as the burnable status, the _baseTokenURI , and granting or revoking roles, which will lead to the risk of over-privilege of the owner role. ",
        "labels": [
            "SlowMist",
            "Ultiverse - Chips Contract",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Low-level call reminder",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Ultiverse - Chips Contract_en-us.pdf",
        "body": "In the ChipStakingPool contract, the contract uses low-level calls and does not limit the amount of gas used to transfer native tokens to users. ",
        "labels": [
            "SlowMist",
            "Ultiverse - Chips Contract",
            "Type: Others",
            "Severity: Information"
        ]
    },
    {
        "title": "Potential overow risks caused by type conversion",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Ultiverse - Chips Contract_en-us.pdf",
        "body": "In the ChipStakingPool contract, users can deposit the native tokens to gain the Lots. The deposit function uses a type conversion to convert the uint256 type values such as quantity, availableGoldLots, and availableSilverLots to the uint64 type. If the user passes in a quantity greater than uint64, this will cause the overow when converting the data to uint256. ",
        "labels": [
            "SlowMist",
            "Ultiverse - Chips Contract",
            "Type: Arithmetic Accuracy Deviation Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Refund lock reminder",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Ultiverse - Chips Contract_en-us.pdf",
        "body": "In the ChipStakingPool contract, users can deposit native tokens to get Lots and claim refunds to get the native back. When calling these two functions, these two functions will check the MerkleProof signed by the central. The claimRefund function will also check whether the user claimed before by checking the userRefundCount[_msgSender()] is larger than 0. If the signed MerkleProof quantity is not the same as the users deposit. There will be a situation where the user will not be able to call the claimRefund function again to withdraw native tokens after claiming refunds once. ",
        "labels": [
            "SlowMist",
            "Ultiverse - Chips Contract",
            "Type: Design Logic Audit",
            "Severity: Information"
        ]
    },
    {
        "title": "Transaction reordering issues",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - wault.finance(WUSD)_en-us.pdf",
        "body": "(1) In commit: 91c541c2f1c0ac781ddcfb2be6a62555a5e1e8d1, the swapExactTokensForTokensSupportingFeeOnTransferTokens in the stake function is not checked for slippage. https://github.com/WaultFinance/WUSD/blob/91c541c2f/WUSDMaster.sol#L716-L722 function stake(uint256 amount) external nonReentrant { require(amount > 0, 'amount cant be zero'); require(wusdClaimAmount[msg.sender] == 0, 'you have to claim first'); require(amount <= maxStakeAmount, 'amount too high'); usdt.safeTransferFrom(msg.sender, address(this), amount); if(feePermille > 0) { uint256 feeAmount = amount * feePermille / 1000; usdt.safeTransfer(treasury, feeAmount); amount = amount - feeAmount; } uint256 wexAmount = amount * wexPermille / 1000; usdt.approve(address(wswapRouter), wexAmount); wswapRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens( wexAmount, 0, swapPath, address(this), block.timestamp ); wusdClaimAmount[msg.sender] = amount; wusdClaimBlock[msg.sender] = block.number; emit Stake(msg.sender, amount); } 9 (2) In commit: de61d93cd7a35213484827cf32533919c34e732e amountOutMin is the parameter that limits the slippage, but it is entered by the user, the maxStakeAmount is added, but this limit can still be bypassed by sorting multiple transactions. https://github.com/WaultFinance/WUSD/blob/de61d93cd7a35213484827cf32533919c34e732e/WUSDMas ter.sol#L808-L834 function stake(uint256 amount, uint256 amountOutMin) external nonReentrant whenNotPaused { require(amount > 0, 'amount cant be zero'); require(wusdClaimAmount[msg.sender] == 0, 'you have to claim first'); require(amount <= maxStakeAmount, 'amount too high'); usdt.safeTransferFrom(msg.sender, address(this), amount); if(feePermille > 0) { uint256 feeAmount = amount * feePermille / 1000; usdt.safeTransfer(treasury, feeAmount); amount = amount - feeAmount; } wusd.mint(address(this), amount); uint256 wexAmount = amount * wexPermille / 1000; usdt.approve(address(wswapRouter), wexAmount); wswapRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens( wexAmount, amountOutMin, swapPath, address(this), block.timestamp ); wusdClaimAmount[msg.sender] = amount; wusdClaimBlock[msg.sender] = block.number; emit Stake(msg.sender, amount); } (3) In commit: 5f50a2c77828c70299e8a9217cfbb926b8c1, the maxStakePerBlock is added, but this limit can still be bypassed by sorting multiple transactions in multiple blocks. 10 https://github.com/WaultFinance/WUSD/blob/5f50a2c77828c70299e8a9217cfbb926b8c1/WUSDMaster. sol#L819-L851 function stake(uint256 amount, uint256 amountOutMin) external nonReentrant whenNotPaused { require(amount > 0, 'amount cant be zero'); require(wusdClaimAmount[msg.sender] == 0, 'you have to claim first'); require(amount <= maxStakeAmount, 'amount too high'); if(lastBlock != block.number) { lastBlockUsdtStaked = 0; lastBlock = block.number; } lastBlockUsdtStaked += amount; require(lastBlockUsdtStaked <= maxStakePerBlock, 'maximum stake per block exceeded'); usdt.safeTransferFrom(msg.sender, address(this), amount); if(feePermille > 0) { uint256 feeAmount = amount * feePermille / 1000; usdt.safeTransfer(treasury, feeAmount); amount = amount - feeAmount; } wusd.mint(address(this), amount); uint256 wexAmount = amount * wexPermille / 1000; usdt.approve(address(wswapRouter), wexAmount); wswapRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens( wexAmount, amountOutMin, swapPath, address(this), block.timestamp ); wusdClaimAmount[msg.sender] = amount; wusdClaimBlock[msg.sender] = block.number; emit Stake(msg.sender, amount); }",
        "labels": [
            "SlowMist",
            "wault.finance(WUSD)",
            "Type: Reordering Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Helio Money_en-us.pdf",
        "body": "Owner or special administrator accounts can operate the key functions. - auth auth auth auth auth auth auth auth - - auth auth auth - auth auth CeToken burn CeToken mint CeToken changeVault hBNB hBNB hBNB burn mint changeMinter HelioProvider liquidation HelioProvider daoBurn HelioProvider daoMint HelioProvider changeDao HelioProvider changeCeToken HelioProvider changeProxy HelioProvider changeCollateralToken HelioProvider changeOperator CerosRouter changeVault CerosRouter changeDex CerosRouter changePool CerosRouter changeProvider OwnableUpgradeable renounceOwnership OwnableUpgradeable transferOwnership CeVaultV2 updateStorage MasterVault _updateCerosStrategyDebt MasterVault depositAllToStrategy MasterVault depositToStrategy MasterVault withdrawFromStrategy MasterVault withdrawAllFromStrategy MasterVault setStrategy MasterVault retireStrat MasterVault migrateStrategy MasterVault withdrawFee MasterVault setDepositFee MasterVault setWithdrawalFee MasterVault addManager MasterVault removeManager MasterVault changeProvider MasterVault changeFeeReceiver MasterVault changeStrategyAllocation WaitingPool addToQueue WaitingPool tryRemove WaitingPool setCapLimit SlidingWindowOracle _authorizeUpgrade UUPSUpgradeable upgradeTo UUPSUpgradeable upgradeToAndCall PriceOracleTestnet _authorizeUpgrade PriceOracle _authorizeUpgrade BaseStrategy setStrategist BaseStrategy setRewards BnbxYieldConverterStrategy changeStakeManager CerosYieldConverterStrategy changeBinancePool CerosYieldConverterStrategy changeCeRouter EmergencyShutdown setMultiSig Ownable renounceOwnership Ownable transferOwnership Interaction addToWhitelist Interaction removeFromWhitelist Jar Jar Jar replenish setSpread setExitDelay",
        "labels": [
            "SlowMist",
            "Helio Money",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Sandwich attacks can aect slippage scope",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Helio Money_en-us.pdf",
        "body": "contracts/ceros/CerosRouter.sol function deposit() external payable override nonReentrant returns (uint256 value) { //...snip code...// uint256[] memory outAmounts = _dex.getAmountsOut(amount, path); //...snip code...// uint256[] memory amounts = _dex.swapExactETHForTokens{ value: amount }(dexABNBcAmount, path, address(this), block.timestamp + 300); realAmount = amounts[1]; //...snip code...// } function withdrawWithSlippage( address recipient, uint256 amount, uint256 outAmount ) external override nonReentrant returns (uint256 realAmount) { //...snip code...// uint256[] memory amounts = _dex.swapExactTokensForETH( realAmount, outAmount, path, recipient, block.timestamp + 300 ); //...snip code...// } Sandwich attacks, also known as MEV attacks, refer to attackers using the transaction order and execution results on the blockchain to gain additional value. This type of attack is usually carried out by miners or transaction order executors, who can gain additional value by reordering transactions or selectively including or excluding them.",
        "labels": [
            "SlowMist",
            "Helio Money",
            "Type: Reordering Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Ratio arbitrage attack vulnerability",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Helio Money_en-us.pdf",
        "body": "contracts/ceros/CeVault.sol contracts/ceros/upgrades/CeVaultV2.sol function _deposit(address account, uint256 amount) private returns (uint256) { uint256 ratio = _aBNBc.ratio(); _aBNBc.transferFrom(msg.sender, address(this), amount); uint256 toMint = (amount * 1e18) / ratio; //SlowMist// _depositors[account] += amount; // aBNBc _ceTokenBalances[account] += toMint; // mint ceToken to recipient ICertToken(_ceToken).mint(account, toMint); emit Deposited(msg.sender, account, toMint); return toMint; } function _withdraw( address owner, address recipient, uint256 amount ) private returns (uint256) { uint256 ratio = _aBNBc.ratio(); uint256 realAmount = (amount * ratio) / 1e18;//SlowMist// require( _aBNBc.balanceOf(address(this)) >= realAmount, \"not such amount in the vault\" ); uint256 balance = _ceTokenBalances[owner]; require(balance >= amount, \"insufficient balance\"); _ceTokenBalances[owner] -= amount; // BNB // burn ceToken from owner ICertToken(_ceToken).burn(owner, amount); _depositors[owner] -= realAmount; // aBNBc _aBNBc.transfer(recipient, realAmount); emit Withdrawn(owner, recipient, realAmount); return realAmount; } Here we can see that the amount of deposit and withdraw is related to the ratio. We can query the implementation of the ratio from the call chain: _aBNBc: function ratio() public view returns (uint256) { return IBondToken(_bondToken).ratio(); } _bondToken: function ratio() public view override returns (uint256) { return _ratio; } function repairRatio(uint256 newRatio) external onlyOwner { _ratio = newRatio; emit RatioUpdated(_ratio); } function updateRatio(uint256 totalRewards) external onlyOperator { uint256 totalShares = totalSharesSupply(); uint256 denominator = _totalStaked + totalRewards - _totalUnbondedBonds; _ratio = multiplyAndDivideFloor(totalShares, 1e18, denominator); // (totalShares * 1e18) / denominator; if (historicalRatios.length == 0) { historicalRatios = new uint256[](8); } if (block.timestamp - _lastUpdate > 1 days - 1 minutes) { uint256 _latestOffset = latestOffset; historicalRatios[((_latestOffset + 1) % 8)] = _ratio; latestOffset = _latestOffset + 1; _lastUpdate = block.timestamp; } emit RatioUpdated(_ratio); } The value of the ratio can be modied by Owner or through other mechanisms. We may trust the operations of the Owner, but changes in the ratio can cause serious arbitrage attacks that can be implemented without the Owner's permission. The main idea is to use MEV attacks by monitoring the transaction memory pool on the blockchain. When a transaction that increases the ratio is found, one transaction deposits the CeVault contract, and another transaction calls the withdraw function of CeVault. By adjusting the form of the transaction fees, these two transactions are placed before and after the ratio change transaction, allowing direct get aBNBc in CeVault. Asset changes like this: Tx1: deposit: 100 aBNBc Tx2: repairRatio: 1-->1.2 Tx3: withdraw: 120 aBNBc",
        "labels": [
            "SlowMist",
            "Helio Money",
            "Type: Unsafe External Call Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Missing check return value",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Helio Money_en-us.pdf",
        "body": "Code location: _aBNBc.transferFrom(msg.sender,address(this),amount) (CeVault.sol#70) _aBNBc.transfer(recipient,availableYields) (CeVault.sol#105) _aBNBc.transfer(recipient,realAmount) (CeVault.sol#143) _certToken.transferFrom(owner,address(this),amount) (CerosRouter.sol#125) _certToken.transfer(recipient,profit) (CerosRouter.sol#165) IERC20(wBnbToken).approve(dexAddress,type()(uint256).max) (CerosRouter.sol#59) IERC20(certToken).approve(dexAddress,type()(uint256).max) (CerosRouter.sol#60) IERC20(certToken).approve(bondToken,type()(uint256).max) (CerosRouter.sol#61) IERC20(certToken).approve(pool,type()(uint256).max) (CerosRouter.sol#62) IERC20(certToken).approve(vault,type()(uint256).max) (CerosRouter.sol#63) _certToken.approve(address(_vault),0) (CerosRouter.sol#250) _certToken.approve(address(_vault),type()(uint256).max) (CerosRouter.sol#252) IERC20(_wBnbAddress).approve(address(_dex),0) (CerosRouter.sol#256) _certToken.approve(address(_dex),0) (CerosRouter.sol#257) IERC20(_wBnbAddress).approve(address(_dex),type()(uint256).max) (CerosRouter.sol#260) _certToken.approve(address(_dex),type()(uint256).max) (CerosRouter.sol#261) _certToken.approve(address(_pool),0) (CerosRouter.sol#266) _certToken.approve(address(_pool),type()(uint256).max) (CerosRouter.sol#268) IERC20(_ceToken).approve(daoAddress,type()(uint256).max) (HelioProvider.sol#67) _ceRouter.withdrawABNBc(recipient,amount) (HelioProvider.sol#155) _dao.deposit(account,address(_ceToken),amount) (HelioProvider.sol#174) _dao.withdraw(account,address(_ceToken),amount) (HelioProvider.sol#178) IERC20(_ceToken).approve(address(_dao),0) (HelioProvider.sol#194) IERC20(_ceToken).approve(address(_dao),type()(uint256).max) (HelioProvider.sol#196) IERC20(_ceToken).approve(address(_dao),0) (HelioProvider.sol#200) IERC20(_ceToken).approve(address(_dao),type()(uint256).max) (HelioProvider.sol#202) IERC20Upgradeable(_rewardsToken).approve(address(target),reward) (mediator/ElipsisMediator.sol#59) _bnbxToken.approve(destination,type()(uint256).max) (strategy/BnbxYieldConverterStrategy.sol#58) _bnbxToken.approve(address(_stakeManager),0) (strategy/BnbxYieldConverterStrategy.sol#313) _bnbxToken.approve(address(_stakeManager),type()(uint256).max) (strategy/BnbxYieldConverterStrategy.sol#315) _certToken.approve(binancePool,type()(uint256).max) (strategy/CerosYieldConverterStrategy.sol#40) _certToken.approve(address(_binancePool),0) (strategy/CerosYieldConverterStrategy.sol#146) _certToken.approve(address(_binancePool),type()(uint256).max) (strategy/CerosYieldConverterStrategy.sol#148) _snBnbToken.approve(destination,type()(uint256).max) (strategy/SnBnbYieldConverterStrategy.sol#57) _snBnbToken.approve(address(_stakeManager),0) (strategy/SnBnbYieldConverterStrategy.sol#309) _snBnbToken.approve(address(_stakeManager),type()(uint256).max) (strategy/SnBnbYieldConverterStrategy.sol#311) hay.transferFrom(address(receiver), address(this), total)(contracts/flash.sol#110) hay.transfer(keeper,hayBal) (libraries/AuctionProxy.sol#39) hay.transfer(keeper,hayBal) (libraries/AuctionProxy.sol#62) hay.transferFrom(msg.sender,address(this),hayMaxAmount) (libraries/AuctionProxy.sol#83) hay.transfer(receiverAddress,hayBal) (libraries/AuctionProxy.sol#99) hay.approve(hayJoin_,type()(uint256).max) (Interaction.sol#103) hay.approve(address(hayJoin),0) (Interaction.sol#109) hay.approve(hayJoin_,type()(uint256).max) (Interaction.sol#118) hay.approve(address(hayJoin),type()(uint256).max) (Interaction.sol#122) IERC20Upgradeable(hay).transferFrom(msg.sender,address(this),wad) (vow.sol#99) Not verifying the return value may lead to logical errors.",
        "labels": [
            "SlowMist",
            "Helio Money",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Missing zero address validation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Helio Money_en-us.pdf",
        "body": "Code locations: CeToken.changeVault(address).vault (CeToken.sol#47) CeVault.changeRouter(address).router (CeVault.sol#194) CerosRouter.changeProvider(address).provider (CerosRouter.sol#271) hBNB.changeMinter(address).minter (hBNB.sol#42) HelioProvider.initialize(address,address,address,address,address,address).certToken (HelioProvider.sol#51) HelioProvider.initialize(address,address,address,address,address,address).ceToken (HelioProvider.sol#52) HelioProvider.changeCeToken(address).ceToken (HelioProvider.sol#199) HelioProvider.changeProxy(address).auctionProxy (HelioProvider.sol#205) HelioProvider.changeOperator(address).operator (HelioProvider.sol#213) MasterVault.initialize(uint256,uint256,uint8,address,address).ceToken (masterVault/MasterVault.sol#86) MasterVault.withdrawETH(address,uint256).account (masterVault/MasterVault.sol#126) PriceOracle.initialize(address,IMovingWindowOracle,bool,address,address)._tokenIn (oracle/PriceOracle.sol#22) PriceOracle.initialize(address,IMovingWindowOracle,bool,address,address)._wbnb (oracle/PriceOracle.sol#25) PriceOracle.initialize(address,IMovingWindowOracle,bool,address,address)._usd (oracle/PriceOracle.sol#26) PriceOracleTestnet.initialize(address,IMovingWindowOracle,bool)._tokenIn (oracle/PriceOracleTestnet.sol#31) SlidingWindowOracle.initialize(address,uint256,uint8).factory_ (oracle/SlidingWindowOracle.sol#46) BnbxYieldConverterStrategy.distributeManual(address).recipient (strategy/BnbxYieldConverterStrategy.sol#253) SnBnbYieldConverterStrategy.distributeManual(address).recipient (strategy/SnBnbYieldConverterStrategy.sol#253) StkBnbStrategy.distributeManual(address).recipient (strategy/StkBnbStrategy.sol#280) Interaction.setWhitelistOperator(address).usr (Interaction.sol#59) Interaction.initialize(address,address,address,address,address,address,address).dog_ (Interaction.sol#86) Jar.initialize(string,string,address,uint256,uint256,uint256)._hayToken (jar.sol#88) Clipper.file(bytes32,address).data (clip.sol#166) Dog.file(bytes32,address).data (dog.sol#133) EmergencyShutdown.constructor(address,address)._vat (es.sol#19) EmergencyShutdown.constructor(address,address)._multisig (es.sol#19) EmergencyShutdown.setMultiSig(address)._multisig (es.sol#28) Vow.initialize(address,address,address)._hayJoin (vow.sol#59) Vow.initialize(address,address,address).multisig_ (vow.sol#59) Vow.file(bytes32,address).data (vow.sol#78)",
        "labels": [
            "SlowMist",
            "Helio Money",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Performs a multiplication on the result of a division",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Helio Money_en-us.pdf",
        "body": "- price = oneTokenOut / amountOut * 10 ** 18 (oracle/PriceOracleTestnet.sol#55) - d /= pow2 (oracle/libraries/FullMath.sol#23) - r *= 2 - d * r (oracle/libraries/FullMath.sol#27) - d /= pow2 (oracle/libraries/FullMath.sol#23) - r *= 2 - d * r (oracle/libraries/FullMath.sol#28) - d /= pow2 (oracle/libraries/FullMath.sol#23) - r *= 2 - d * r (oracle/libraries/FullMath.sol#29) - d /= pow2 (oracle/libraries/FullMath.sol#23) - r *= 2 - d * r (oracle/libraries/FullMath.sol#30) - d /= pow2 (oracle/libraries/FullMath.sol#23) - r *= 2 - d * r (oracle/libraries/FullMath.sol#31) - d /= pow2 (oracle/libraries/FullMath.sol#23) - r *= 2 - d * r (oracle/libraries/FullMath.sol#32) - d /= pow2 (oracle/libraries/FullMath.sol#23) - r *= 2 - d * r (oracle/libraries/FullMath.sol#33) - d /= pow2 (oracle/libraries/FullMath.sol#23) - r *= 2 - d * r (oracle/libraries/FullMath.sol#34) - l /= pow2 (oracle/libraries/FullMath.sol#24) - l * r (oracle/libraries/FullMath.sol#35) - poolTokens = (poolTokensToBurn * 1e11) / (1e11 - stakePool.config().fee.withdraw) (strategy/StkBnbStrategy.sol#188) - poolTokensFee = (poolTokens * stakePool.config().fee.withdraw) / 1e11 (strategy/StkBnbStrategy.sol#198) - x = xxRound_rpow_asm_0 / b (hMath.sol#19) - zx_rpow_asm_0 = z * x (hMath.sol#21) - d /= pow2 (oracle/libraries/FullMath.sol#23) - r *= 2 - d * r (oracle/libraries/FullMath.sol#27) - d /= pow2 (oracle/libraries/FullMath.sol#23) - r *= 2 - d * r (oracle/libraries/FullMath.sol#28) - d /= pow2 (oracle/libraries/FullMath.sol#23) - r *= 2 - d * r (oracle/libraries/FullMath.sol#29) - d /= pow2 (oracle/libraries/FullMath.sol#23) - r *= 2 - d * r (oracle/libraries/FullMath.sol#30) - d /= pow2 (oracle/libraries/FullMath.sol#23) - r *= 2 - d * r (oracle/libraries/FullMath.sol#31) - d /= pow2 (oracle/libraries/FullMath.sol#23) - r *= 2 - d * r (oracle/libraries/FullMath.sol#32) - d /= pow2 (oracle/libraries/FullMath.sol#23) - r *= 2 - d * r (oracle/libraries/FullMath.sol#33) - d /= pow2 (oracle/libraries/FullMath.sol#23) - r *= 2 - d * r (oracle/libraries/FullMath.sol#34) - l /= pow2 (oracle/libraries/FullMath.sol#24) - l * r (oracle/libraries/FullMath.sol#35) - x = xxRound_rpow_asm_0 / b (abaci.sol#159) - zx_rpow_asm_0 = z * x (abaci.sol#161) - x = xxRound_rpow_asm_0 / b (abaci.sol#249) - zx_rpow_asm_0 = z * x (abaci.sol#251) - rate = wad / timeline (jar.sol#141) - leftover = remaining * rate (jar.sol#144) - x = xxRound_rpow_asm_0 / b (hMath.sol#19) - zx_rpow_asm_0 = z * x (hMath.sol#21) Solidity's integer division truncates. Thus, performing division before multiplication can lead to precision loss.",
        "labels": [
            "SlowMist",
            "Helio Money",
            "Type: Arithmetic Accuracy Deviation Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Anyone can call initialize on the logic contract",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Helio Money_en-us.pdf",
        "body": "contracts/ceros/upgrades/CeVaultV2.sol 33,5: function initialize( contracts/ceros/upgrades/HelioProviderV2.sol 43,5: function initialize( contracts/ceros/CerosRouter.sol 41,5: function initialize( contracts/ceros/CeToken.sol 31,5: function initialize(string calldata _name, string calldata _symbol) contracts/ceros/CeVault.sol 33,5: function initialize( contracts/ceros/hBNB.sol 29,5: function initialize() external initializer { contracts/ceros/HelioProvider.sol 49,5: function initialize( contracts/masterVault/MasterVault.sol 82,5: function initialize( contracts/masterVault/WaitingPool.sol 28,5: function initialize(address _masterVault, uint256 _capLimit) external initializer { contracts/mediator/ElipsisMediator.sol 43,5: function initialize(address targetContract) public initializer { contracts/oracle/interfaces/IUniswapV2Pair.sol 96,3: function initialize(address, address) external; contracts/oracle/BnbOracle.sol 11,5: function initialize(address aggregatorAddress) external initializer { contracts/oracle/BusdOracle.sol 11,5: function initialize(address aggregatorAddress) external initializer { contracts/oracle/HelioOracle.sol 17,5: function initialize(uint256 initialPrice) public initializer { contracts/oracle/PriceOracle.sol 21,3: function initialize( contracts/oracle/PriceOracleTestnet.sol 30,3: function initialize( contracts/oracle/SlidingWindowOracle.sol 45,3: function initialize( contracts/strategy/BnbxYieldConverterStrategy.sol 46,5: function initialize( contracts/strategy/CerosYieldConverterStrategy.sol 27,5: function initialize( contracts/strategy/SnBnbYieldConverterStrategy.sol 45,5: function initialize( contracts/strategy/StkBnbStrategy.sol 58,5: function initialize( contracts/abaci.sol 52,5: function initialize() external initializer { 123,5: function initialize() external initializer { 214,5: function initialize() external initializer { contracts/clip.sol 127,5: function initialize(address vat_, address spotter_, address dog_, bytes32 ilk_) external initializer { contracts/dog.sol 103,5: function initialize(address vat_) external initializer { contracts/flash.sol 58,5: function initialize(address _vat, address _hay, address _hayJoin, address _vow) external initializer { contracts/hay.sol 59,5: function initialize(uint256 chainId_, string memory symbol_, uint256 supplyCap_) external initializer { contracts/HelioRewards.sol 65,5: function initialize(address vat_, uint256 poolLimit_ ) public initializer { contracts/HelioToken.sol 28,5: function initialize(uint256 rewardsSupply_, address rewards_) public initializer { contracts/Interaction.sol 80,5: function initialize( contracts/jar.sol 88,5: function initialize(string memory _name, string memory _symbol, address _hayToken, uint _spread, uint _exitDelay, uint _flashLoanDelay) external initializer { contracts/join.sol 89,5: function initialize(address vat_, bytes32 ilk_, address gem_) external initializer { 149,5: function initialize(address vat_, address hay_) external initializer { contracts/jug.sol 54,5: function initialize(address vat_) external initializer { contracts/lock.sol 64,5: function initialize() external initializer { contracts/spot.sol 56,5: function initialize(address vat_) external initializer { contracts/vat.sol 74,5: function initialize() public initializer { contracts/vow.sol 59,5: function initialize(address vat_, address _hayJoin, address multisig_) external initializer { Anyone can call initialize on the logic contract.",
        "labels": [
            "SlowMist",
            "Helio Money",
            "Type: Race Conditions Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "vaultToken burned may exceed the actual number needed",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Helio Money_en-us.pdf",
        "body": "contracts/masterVault/MasterVault.sol function withdrawETH(address account, uint256 amount) external override nonReentrant whenNotPaused onlyProvider returns (uint256 shares) { address src = msg.sender; ICertToken(vaultToken).burn(src, amount); uint256 ethBalance = totalAssetInVault(); shares = _assessFee(amount, withdrawalFee); if(ethBalance < shares) { payable(account).transfer(ethBalance); uint256 withdrawn = withdrawFromActiveStrategies(account, shares - ethBalance); shares = ethBalance + withdrawn; } else { payable(account).transfer(shares); } emit Withdraw(src, src, src, amount, shares); return amount; } When Strategy balance is not enough, the actual withdrawn amount return by withdrawFromActiveStrategies will lower than shares - ethBalance passed, it means the provider burn amount but do not get enough native token.",
        "labels": [
            "SlowMist",
            "Helio Money",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Missing check BnbOracle status",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Helio Money_en-us.pdf",
        "body": "contracts/oracle/BnbOracle.sol function peek() public view returns (bytes32, bool) { ( /*uint80 roundID*/, int price, /*uint startedAt*/, /*uint timeStamp*/, /*uint80 answeredInRound*/ ) = priceFeed.latestRoundData(); if (price < 0) { return (0, false); } return (bytes32(uint(price) * (10**10)), true); } In order to get a correct price, we need to check key values returned by priceFeed.",
        "labels": [
            "SlowMist",
            "Helio Money",
            "Type: Unsafe External Call Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Upgrading contracts may introduce new risks",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Helio Money_en-us.pdf",
        "body": "contracts/oracle/HelioOracle.sol contracts/oracle/PriceOracle.sol contracts/oracle/SlidingWindowOracle.sol The Proxy can upgrade the contract by calling upgradeTo/upgradeToAndCall , and upgrading the contract may introduce new risks.",
        "labels": [
            "SlowMist",
            "Helio Money",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "HelioOracle owner is never initialized",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Helio Money_en-us.pdf",
        "body": "contracts/oracle/HelioOracle.sol function changePriceToken(uint256 price_) external { require(msg.sender == _owner, \"HelioOracle/forbidden\"); price = price_; emit PriceChanged(price); } _owner is never initialized, changePriceToken call will fail in any condition.",
        "labels": [
            "SlowMist",
            "Helio Money",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "HelioOracle price oracle is not rigorous",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Helio Money_en-us.pdf",
        "body": "contracts/oracle/HelioOracle.sol function changePriceToken(uint256 price_) external { require(msg.sender == _owner, \"HelioOracle/forbidden\"); price = price_; emit PriceChanged(price); } This oracle price is too simple, there is not parameters for determining the validity of prices, such as timestamp.",
        "labels": [
            "SlowMist",
            "Helio Money",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Oracle price should not return 0",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Helio Money_en-us.pdf",
        "body": "contracts/HelioRewards.sol function helioPrice() public view returns(uint256) { // 1 HAY is helioPrice() helios (bytes32 price, bool has) = oracle.peek(); if (has) { return uint256(price); } else { return 0; } } contracts/Interaction.sol function collateralPrice(address token) public view returns (uint256) { CollateralType memory collateralType = collaterals[token]; _checkIsLive(collateralType.live); (PipLike pip,) = spotter.ilks(collateralType.ilk); (bytes32 price, bool has) = pip.peek(); if (has) { return uint256(price); } else { return 0; } } Price oracle should break the operation when peek an error, instead of return 0.",
        "labels": [
            "SlowMist",
            "Helio Money",
            "Type: Unsafe External Call Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "ERC777 reentrancy risks",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Helio Money_en-us.pdf",
        "body": "contracts/strategy/StkBnbStrategy.sol function _withdraw(address recipient, uint256 amount) internal returns (uint256) { //... stkBNB.send(address(stakePool), poolTokens, \"\"); // save it so that we can later dispatch the amount to the recipient on claim withdrawReqs[_endIndex++] = WithdrawRequest(recipient, value); // keep track of _netDeposits in StakePool _bnbDepositsInStakePool -= value; return value + ethBalance; } stkBNB is a ERC777 token , ERC777 tokens are vulnerable to reentrancy attacks due to a design aw.",
        "labels": [
            "SlowMist",
            "Helio Money",
            "Type: Reentrancy Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Missing events access control",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Helio Money_en-us.pdf",
        "body": "MasterVault._updateCerosStrategyDebt() MasterVault.withdrawFee() BnbxYieldConverterStrategy._deposit() BnbxYieldConverterStrategy._withdraw() BnbxYieldConverterStrategy._distributeFund() BnbxYieldConverterStrategy._harvestTo() CerosYieldConverterStrategy._deposit() CerosYieldConverterStrategy._withdraw() CerosYieldConverterStrategy._harvestTo() SnBnbYieldConverterStrategy._deposit() SnBnbYieldConverterStrategy.withdrawInToken() SnBnbYieldConverterStrategy._withdraw() SnBnbYieldConverterStrategy._distributeFund() SnBnbYieldConverterStrategy._harvestTo() StkBnbStrategy._deposit() StkBnbStrategy.withdrawInToken() StkBnbStrategy._withdraw() StkBnbStrategy.harvest()",
        "labels": [
            "SlowMist",
            "Helio Money",
            "Type: Malicious Event Log Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Reentry prevention best practices",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Helio Money_en-us.pdf",
        "body": "contracts/HelioRewards.sol function claim(uint256 amount) external { //... } contracts/Interaction.sol function deposit( address participant, address token, uint256 dink ) external whitelisted(participant) returns (uint256) { } function borrow(address token, uint256 hayAmount) external returns (uint256) { //... } function payback(address token, uint256 hayAmount) external returns (int256) { //... } Not apply check-eects-interactions pattern when making external calls in these functions.",
        "labels": [
            "SlowMist",
            "Helio Money",
            "Type: Reentrancy Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing check return value",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Helio Money_en-us.pdf",
        "body": "Code location: jug.drip(collateralType.ilk) (Interaction.sol#145) jug.drip(collateralType.ilk) (Interaction.sol#309) _deactivateStrategy(strategy)(contracts/masterVault/MasterVault.sol#315) _depositToStrategy(strategies[i], depositAmount) (contracts/masterVault/MasterVault.sol#342) Not verifying the return value may lead to logical errors.",
        "labels": [
            "SlowMist",
            "Helio Money",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - wBETH_en-us.pdf",
        "body": "1.In the UnwrapTokenV1 contract, the owner role can set the operatorAddress, the rechargeAddress, the ethBackAddress, the ethStaked address, and the lockTime. Wrong conguration and sudden modication will aect the user's normal withdrawal request and claim. ",
        "labels": [
            "SlowMist",
            "wBETH",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "call() should be used instead of transfer()",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - wBETH_en-us.pdf",
        "body": "The transfer() and send() functions forward a xed amount of 2300 gas. Historically, it has often been recommended to use these functions for value transfers to guard against reentrancy attacks. However, the gas cost of EVM instructions may change signicantly during hard forks which may break already deployed contract systems that make xed assumptions about gas costs. For example. EIP 1884 broke several existing smart contracts due to a cost increase in the SLOAD instruction. ",
        "labels": [
            "SlowMist",
            "wBETH",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Preemptive Initialization",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - wBETH_en-us.pdf",
        "body": "By calling the initialize and deploy functions to initialize the contracts, there is a potential issue that malicious attackers preemptively call the initialize function to initialize. ",
        "labels": [
            "SlowMist",
            "wBETH",
            "Type: Race Conditions Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Possible calculation truncation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - wBETH_en-us.pdf",
        "body": "In the RateLimit contract, the amountToReplenish is calculated by the division (secondsSinceAllowanceSet * maxAllowances[caller]) / intervals[caller]; . If the value of the numerator is less than intervals[caller], this division can truncate towards 0. Since the result of the division is returned by the _getReplenishAmount function and is used in the _replenishAllowance function to update the callers allowance, this truncation can lead to a failure in updating the callers allowance. ",
        "labels": [
            "SlowMist",
            "wBETH",
            "Type: Arithmetic Accuracy Deviation Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Multiple Solidity versions in use",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - wBETH_en-us.pdf",
        "body": "Throughout the code base there are dierent versions of Solidity being used. Token contracts are specically using version 0.6.12 while other contracts allow compiling with version 0.8.6.",
        "labels": [
            "SlowMist",
            "wBETH",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Dev address setting enhancement suggestions",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - wBETH_en-us.pdf",
        "body": "In the can set the StakedTokenV1 and StakedTokenV2 contracts, the owner role can set the ethReceiver address to move the eth. If the address is an EOA address, in a scenario where the private keys are leaked, the teams revenue will be stolen. ",
        "labels": [
            "SlowMist",
            "wBETH",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Inability to claim due to insucient availableAllocateAmount",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - wBETH_en-us.pdf",
        "body": "In the WrapTokenV2ETH and WrapTokenV2BSC contract, users can call the requestWithdrawEth function to burn their wbeth to withdraw their unwrap_ETH tokens. In this function, the withdraw operation is executed by the UnwrapTokenV1 requestWithdraw function. And in the requestWithdraw function, the _currentIndex value will be increased by the nextIndex++ self-increment. Once the availableAllocateAmount is less than the _ethAmount or the startAllocatedEthIndex is not equal to the currentIndex , the if judgment will pass to execute the else part only, and the startAllocatedEthIndex will not self-increment. This can lead to the allocation failing that users can not call the claimWithdraw function to withdraw their eth. Only in the UnwrapTokenV1 contract, the operator role can call the allocate function to allocate availableAllocateAmount of ethAmount to make the startAllocatedEthIndex++ self-increment to match the if judgment and the claimWithdraws allocated value will be set to true. ",
        "labels": [
            "SlowMist",
            "wBETH",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Potential error in the calculation of the withdrawal amount",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist_Audit_Report_StakeStone_NativeLendingETHStrategy&Symbi_en-us.pdf",
        "body": "In the NativeLendingETHStrategy contract, the owner role can call the withdrawFromNativeByAmount function and the withdrawFromNativeByShare function to redeem the AquaLpToken for ETH. The nal calculated withdrawal amount is simply the dierence between the current ETH balance of the contract and the ETH balance before the redemption operation. However, the redemption operation rst converts the AquaLpToken back to WETH tokens, and then uses the WETH tokens to obtain ETH. If there are surplus WETH tokens in the contract before the redemption (for example, if other users have mistakenly transferred them in), then this excess WETH amount will also be included in the calculated withdrawal amount. Code Location: contracts/strategies/NativeLendingETHStrategy.sol#L44-66 function withdrawFromNativeByAmount( uint256 _amount ) external onlyOwner returns (uint256 withdrawAmount) { uint256 beforeBalance = address(this).balance; IAquaLpToken(LPTOKEN).redeemUnderlying(_amount); WETH.withdraw(WETH.balanceOf(address(this))); withdrawAmount = address(this).balance - beforeBalance; } function withdrawFromNativeByShare( uint256 _share ) external onlyOwner returns (uint256 withdrawAmount) { uint256 beforeBalance = address(this).balance; IAquaLpToken(LPTOKEN).redeem(_share); WETH.withdraw(WETH.balanceOf(address(this))); withdrawAmount = address(this).balance - beforeBalance; }",
        "labels": [
            "SlowMist",
            "SlowMist_Audit_Report_StakeStone_NativeLendingETHStrategy&Symbi",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Missing event records",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist_Audit_Report_StakeStone_NativeLendingETHStrategy&Symbi_en-us.pdf",
        "body": "In the NativeLendingETHStrategy contract, the owner role can use the ETH in the contract to mint AquaLpToken, and then use the AquaLpToken to redeem for ETH, but there is no event record. Code Location: contracts/strategies/NativeLendingETHStrategy.sol#L28-66 function depositIntoNative( uint256 _amount ) external onlyOwner returns (uint256 mintAmount) { ... } function withdrawFromNativeByAmount( uint256 _amount ) external onlyOwner returns (uint256 withdrawAmount) { ... } function withdrawFromNativeByShare( uint256 _share ) external onlyOwner returns (uint256 withdrawAmount) { ... }",
        "labels": [
            "SlowMist",
            "SlowMist_Audit_Report_StakeStone_NativeLendingETHStrategy&Symbi",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing zero value check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist_Audit_Report_StakeStone_NativeLendingETHStrategy&Symbi_en-us.pdf",
        "body": "In the NativeLendingETHStrategy contract, The owner role does not check whether the input amount for minting and redeeming AquaLpToken tokens is 0 or not. If the input value is 0, the operation can still be executed successfully, but it will consume gas. Code Location: contracts/strategies/NativeLendingETHStrategy.sol#L28-66 function depositIntoNative( uint256 _amount ) external onlyOwner returns (uint256 mintAmount) { ... } function withdrawFromNativeByAmount( uint256 _amount ) external onlyOwner returns (uint256 withdrawAmount) { ... } function withdrawFromNativeByShare( uint256 _share ) external onlyOwner returns (uint256 withdrawAmount) { ... }",
        "labels": [
            "SlowMist",
            "SlowMist_Audit_Report_StakeStone_NativeLendingETHStrategy&Symbi",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Lack of external interest rate ination vulnerability check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist_Audit_Report_StakeStone_NativeLendingETHStrategy&Symbi_en-us.pdf",
        "body": "In the NativeLendingETHStrategy and SymbioticDepositWstETHStrategy contracts, the owner role can separately call the depositIntoNative function and the depositIntoSymbiotic function to deposit the funds in the strategy contract into a third-party protocol, and mint the corresponding deposit certicates. However, the functions do not check whether the minted deposit shares are zero in quantity. Since the code of the third-party protocol is not within the scope of this audit, if there is an interest rate ination vulnerability in the code of the third-party protocol, the funds in the contract may be damaged due to malicious users front-running. For details on the interest rate ination vulnerability, please refer to the following link: https://blog.openzeppelin.com/a-novel-defense-against-erc4626-ination-attacks Code Location: contracts/strategies/NativeLendingETHStrategy.sol#L28-42 function depositIntoNative( uint256 _amount ) external onlyOwner returns (uint256 mintAmount) { ... IAquaLpToken(LPTOKEN).mint(_amount); mintAmount = IAquaLpToken(LPTOKEN).balanceOf(address(this)) - beforeLPBalance; } contracts/strategies/SymbioticDepositWstETHStrategy.sol#L151-169 function depositIntoSymbiotic( uint256 _wstETHAmount ) external onlyOwner returns (uint256 shares) { ... shares = ICollateral(collateralAddr).deposit( address(this), _wstETHAmount ); emit DepositIntoSymbiotic( collateralAddr, address(this), _wstETHAmount, shares ); }",
        "labels": [
            "SlowMist",
            "SlowMist_Audit_Report_StakeStone_NativeLendingETHStrategy&Symbi",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Potentially unclaimed rewards",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the SingleTokenStaking contract, the calculation of staking rewards mainly depends on the rewardSpeed variable. The contract calculates the global reward accumulation accuedReward based on rewardSpeed and the block interval. When a user settles rewards, the dierence between the current global accuedReward and the user's last settled accuedReward is multiplied by the user's deposit amount to determine the user's claimable rewards. It is important to note that the contract does not limit users' minimum deposit amount. This means that when a user deposits an extremely small amount and rewardSpeed is set relatively low (for example, if the user deposits 1 wei and rewardSpeed is less than 1e18), the user's small rewards may be truncated due to decimal rounding during the reward settlement process. This may result in the user's rewards being left unclaimed in the contract. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Arithmetic Accuracy Deviation Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Optimizable refreshGlobalState",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the SingleTokenStaking contract, the refreshGlobalState function is used to update the global reward state accuedReward and update the accumulated rewards and the current block to the corresponding global variables. It is important to note that there may be a large number of users performing operations such as depositing, withdrawing, and claiming rewards within the same block, which will result in frequent calls to the refreshGlobalState function. This means that although accuedReward will not be accumulated within the same block, users still need to pay some gas to update gDeposits.accuedReward and gDeposits.accuedBlock , which is unnecessary within the same block. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Compatibility issues with deationary tokens",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the SingleTokenStaking contract, users can deposit supported tokens into the contract using the deposit function, and the addDeposit function directly records the amount of deposit tokens passed in by the user. If the token supported by the contract is deationary, the contract will actually receive fewer tokens than the deposit amount passed in by the user. This will cause the contract to record a higher user deposit than the actual amount of tokens received. When the user withdraws, it will result in a bad debt for the protocol. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Optimizable RFG token distribution method",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the RFGToken contract, the token distribution rules are hardcoded. 30% of the token supply will be allocated to liquidity, 10% will be allocated to airdrops, and the remaining tokens will be minted by the minter role. The contract uses three separate functions to mint tokens for these three dierent allocation purposes. However, it should be noted that in the claimAirdrop and claimLiquidity functions, although the tokens are minted for airdrop and liquidity purposes, the receiving addresses are not specied. The owner role can mint these tokens to any address. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Admin who has not set the Boss role",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "During the initialization of the Auction contract, the specied boss address is granted the BossRole. However, it should be noted that the BossRole is not assigned the AdminRole. This means that if the boss address experiences issues such as private key leakage, the protocol will not be able to handle the boss address through revokeRole/grantRole . ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Not checking the reasonableness of time when updating auctions",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the Auction contract, the admin role can update existing auction congurations through the updateAuction function. When updating, it checks whether the new startPrice is greater than 0, but it does not check whether the new endTime is greater than startTime. It should be noted that the admin can update an auction that has already ended to reopen it. This means that users who have already placed bids or claimed items can participate in the auction again. However, this will cause the restarted auction to conict with the previous claim/refund data. For example, if a user who successfully claimed an NFT in the previous auction wins the auction again, they will not be able to claim the new NFT successfully a second time. This does not align with the expected design. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Smart contracts cannot participate in the auction",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the Auction contract, users can participate in the auction through the bidAuction function. However, the function checks whether msg.sender is equal to tx.origin , which prevents smart contracts (including EIP4337 wallets) from participating in the auction. It should be noted that in the future, if the EIP3074 standard is approved, it may break this check. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Design Logic Audit",
            "Severity: Information"
        ]
    },
    {
        "title": "Time check when closing auction is awed",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the Auction contract, the operator can end the auction through the nishAuction function after the endTime. When performing the nishAuction operation, the endTime is checked using block.timestamp >= auction.endTime , while when performing the bidAuction operation, the endTime is checked using block.timestamp <= auction.endTime . This means that when the operator performs the nishAuction operation to set result.price exactly at the endTime, users can still perform the bidAuction operation to participate in the auction. This may not align with the intended design. It may also cause confusion for users, as they can place a bid higher than result.price at the endTime but are not included in the nal Merkle tree. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Not checking if the user's bid is as expected",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the Auction contract, users who successfully win the auction can obtain the NFT through the claimNft function. The operator sets the Merkle proof to verify the validity of the claiming user. When the user's bid price is higher than auctionResult.price , the contract processes a refund for them. However, the contract does not check whether the user's bid price is necessarily greater than or equal to auctionResult.price . If the Merkle tree erroneously includes users with bid prices lower than auctionResult.price , it may result in insucient funds in the contract for the boss role to withdraw. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Not checking if the user's bid is refundable",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the Auction contract, users who meet the refund conditions can use the operator's signature to request a refund. Theoretically, if a user is eligible to claim the NFT, the operator will not sign for them to avoid giving up their eligibility for a refund. However, the refund function does not strictly check whether the bid prices of all refunding users are less than auctionResult.price . If the operator erroneously signs a refund for a user who is eligible to claim the NFT, it will prevent the boss from withdrawing the remaining auction proceeds. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Risk of pseudo-randomness",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the Auction contract, when a user claims an NFT, the fakeRandomToken function is used to calculate the tokenId for the user. The fakeRandomToken function uses block.prevrandao , block.number , and the user-provided seed for calculation. Unfortunately, these parameters can be controlled or are already known. This allows malicious users to ensure that the tokenIds of the NFTs they obtain at specic blocks are all of high value. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Block data Dependence Vulnerability",
            "Severity: Critical"
        ]
    },
    {
        "title": "Redundant return value of adjustRandomtoken function",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the Auction contract, the adjustRandomtoken function is used to select a matching id for the user based on the current tokenId inventory. When all the inventory has been claimed, the function directly throws an error using require(false) . This makes the nal return 0 redundant because the function will never execute this return statement. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "The tokenId obtained by the user is related to the NFT inventory",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the Auction contract, the adjustRandomtoken function is used to adjust the nal tokenId based on the inventory of each tokenId's NFTs. If a user obtains the highest-value NFT but there is no inventory for this NFT, they may be assigned the lowest-value NFT instead, and vice versa. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Design Logic Audit",
            "Severity: Information"
        ]
    },
    {
        "title": "Unchecked boost bound parameters during initialization",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the initialize function of the RFGDeposit contract, when the proxy contract is initialized, parameters such as lowerBound and upperBound are passed in. However, the function does not check whether the passed-in lowerBound is less than upperBound. Incorrectly passing the corresponding values may cause the protocol to be unusable. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Rewards not settled as expected",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the RFGDeposit contract, users can make xed-term deposits through the xedDeposit function. When a user's autoRedeposit status is false, even if the user's deposit time is several times longer than the duration, only one cycle of rewards will be settled for the user. Unfortunately, the xedDeposit function does not handle the case where autoRedeposit is false. This allows users with autoRedeposit set to false to make a small deposit to the same xId after a long deposit period and still receive the full rewards, not just for one duration. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Incorrect whitelist pool check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the Pool contract, the assertCallerIsPool function is used to check whether the passed-in sender is a pool created in the stakingManager. The assertCallerIsPool function receives the msg.sender from SinglePool and CouplePool as a possible pool address, calls the poolID interface of msg.sender to obtain the pool id, and nally checks whether this pool id is valid in the stakingManager. Unfortunately, this check method is not eective. Malicious contracts can also implement the poolID interface and return a valid pool id (1~7) when called. Since the assertCallerIsPool function only checks whether the id is valid through the stakingManager contract, malicious contracts can easily bypass this check to perform malicious custodial staking and eventually exhaust the protocol's assets. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Unsafe External Call Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Unexpected rewards when staking in pairs",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the CouplePool contract, the stakingManager can stake a user's NFT through the socialStake function. When the staking has not been paired yet, CouplePool will custody the user's NFT to SinglePool to obtain SinglePool staking rewards. Once the pairing is complete, it will withdraw from SinglePool and stake in CouplePool. Theoretically, during the process of pairing, users should only receive rewards from SinglePool and not from CouplePool. Unfortunately, when SinglePool custody is performed, the user's ssInfo.stakeInfo.amount value in the CouplePool contract will be updated to the staked amount. This allows users to claim CouplePool staking rewards through the claimSocialReward function of the stakingManager contract even before the pairing is completed. Worse still, the user's ssInfo.stakeInfo.claimedToAccued has not been set at this point, so when settling rewards, calculateStakeReward will distribute large unexpected rewards to the user. Malicious users can exploit this issue to exhaust all reward tokens. Similarly, this issue also exists in the GroupPool contract. Users can still claim large rewards from GroupPool even before the three-party pairing is completed. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Manipulate boost to inuence the token id obtained in the auction",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the Auction contract, when a user claims the auctioned NFT, the token id of the NFT depends not only on the random number seed but also on the amount of the user's deposit in the RFGDeposit contract. The larger the user's deposit amount, the greater the user's boost, and the higher the probability of obtaining a high-value NFT. Unfortunately, the calculation of the boost only depends on the user's deposit amount. Users can increase their RFG deposit before claiming the NFT to improve the probability. When multiple addresses of a user have obtained NFTs, they only need to withdraw the staked RFG tokens from other addresses and transfer them to the address that needs to claim the NFT for staking before claiming the NFT, in order to increase the probability. In other words, users only need a high amount of staking and can continuously stake/unstake/transfer RFG tokens to increase the probability of obtaining high-value NFTs at a lower cost. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Redundant PoolMax enum",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the NftID library, PoolID lists an enumeration of all the pools supported by the protocol, but PoolMax is not used anywhere in the protocol, which is redundant. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Reward calculation for two stakers in GroupPool being the same user",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the GroupPool contract, when a user performs a socialUnstake/forceSocialUnstake operation, a portion of the bailed rewards of the initiator of the unstaking operation will be deducted and distributed to other users in the same group. However, it should be noted that one of the users in the same group may also be the initiator because the protocol allows the same user to provide two dierent NFTs for GroupPool staking. This means that a portion of the initiator's penalized rewards still belong to the initiator themselves. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Design Logic Audit",
            "Severity: Information"
        ]
    },
    {
        "title": "Potentially incorrect social staking reward information in GroupPool",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "As previously mentioned, GroupPool allows the same user to provide two NFTs for staking. However, during reward settlement, stakerShareReward and bailed are calculated based on three dierent staking users. Therefore, in the viewSocialStakeRewardInfo function, when obtaining the user's pendingRewards, it only considers the scenario where the three stakers are dierent users, while overlooking the possibility that two of the stakers might be the same user. This may cause the reward amount returned by the viewSocialStakeRewardInfo function to be lower than expected. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Potential Denial of Service Risk",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In Pool, users can freely choose dierent pools for staking. Theoretically, users can stake their owned NFTs in pools of dierent types or in dierent matchCodes within the same pool. The pool uses OpenZeppelin's EnumerableSet library to record the pools or matchCodes that users have joined, and retrieves all the pools or matchCodes joined by users through the values interface of EnumerableSet when claiming rewards. It is important to note that the values operation copies the entire storage space to memory. If the user participates in a large number of pools or matchCodes, the values operation will generate signicant gas costs, potentially exceeding the block's gasLimit and ultimately leading to DoS risks. Despite this, if a DoS issue arises, users can still avoid their rewards being locked by claiming rewards individually. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Denial of Service Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "The validity of the pid was not checked when creating the pool",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the StakingManager contract, operators can create pools using the createPool function, but the validity of the passed-in pid value is not checked. Theoretically, the pid of a pool should only be between 1 and 7. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "When creating a matchCode, it does not check whether the pool has been created.",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the StakingManager contract, users can create matchCodes for social staking using the createMatch2Code and createMatch3Code functions. However, when creating a matchCode, there is no check to verify if the pool corresponding to the pid has already been created. If the pool has not been created, users will be unable to successfully create a matchCode, and no error message will be thrown, which may cause confusion for users. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "There is an upper limit on the matchCodes available in the pool",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the StakingManager contract, when a user creates a matchCode for social staking, the protocol assigns a matchCode to this staking. The matchCode is obtained through the nextMatchCode function of the pool, which is calculated using poolID * 10 ** 8 + matchCodeNonce . It is important to note that if the value of matchCodeNonce exceeds 1e8, it will aect the matchCode of the next pool. In reality, it is highly unlikely for a pool to have 1e8 matchCodes, but the project team should still remain attentive to this matter. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Checks-Eects-Interactions are not followed when transferring out NFT",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the StakingManager contract, the returnNftsBackAndClaimReward function is used to transfer users' staked NFTs from the contract back to the users and claim social staking rewards for users through the claimSocialReward function. The practice of transferring assets before modifying the contract state does not comply with the Checks- Eects-Interactions pattern. Although it does not lead to reentrancy risks in the current business scenario, it cannot be guaranteed that new exploitable business scenarios will not be introduced in the future. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Optimizable reward information update",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the updateRewardInfo function of the GroupPool contract, the currently claimable social staking rewards are calculated through the calculateStakeReward function, and the rewards are distributed to the stakers. It is important to note that when users exit staking through the StakingManager contract, multiple calls to the updateRewardInfo function may be involved in a single transaction. The pendingReward for reward settlement is only greater than 0 during the rst call, and when pendingReward is 0, the updateRewardInfo function still performs reward distribution operations, which will consume a lot of unnecessary gas. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risks of excessive privilege",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the StakingManager contract, the admin role can upgrade any pool through the upgradePool function. Moreover, in the protocol, except for the InviteReward, Airdrop, RFGToken, and NftCard contracts, all other contracts use an upgradable model, where the admin of the proxy contract can arbitrarily upgrade these contracts. This leads to the risk of excessive privileges. In the Auction contract, after the auction is completed, the project team will calculate o-chain the users who can obtain NFTs and the nal auction price, and establish a Merkle proof for users to claim. This also increases the centralization risk to a certain extent. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Protocol Missing Emergency Operations Role",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "The protocol has planned for multiple roles to manage dierent contracts, but it is important to note that the protocol lacks an emergency pause functionality and a role to manage this function. When an emergency occurs in the protocol, the emergency operation role can close the protocol through the pause function to minimize losses as much as possible.",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing event records",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the NftCard contract, the owner can modify the URI of the NFT through the setUri function, but no event is recorded. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "4.2.1.1 Sandwich attacks issues",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - autofarm_en-us.pdf",
        "body": "The earn(), buyBack(), convertDustToEarned(), _convertMDXToEarned functions no limit slippage, there is a sandwich attacks issues. It is recommended to add a slippage limit, and the slippage parameter can only be modified by the Owner.  AutofarmV2_CrossChain/StratVLEV2.sol function earn() external whenNotPaused { if (onlyGov) { require(msg.sender == govAddress, \"!gov\"); } 6 IVenusDistribution(venusDistributionAddress).claimVenus(address(this)); uint256 earnedAmt = IERC20(venusAddress).balanceOf(address(this)); earnedAmt = distributeFees(earnedAmt); earnedAmt = buyBack(earnedAmt); if (venusAddress != wantAddress) { IPancakeRouter02(uniRouterAddress).swapExactTokensForTokens( earnedAmt, 0, venusToWantPath, address(this), now.add(600) ); } lastEarnBlock = block.number; _farm(false); //SupplywantTokenwithoutleverage,tocaterfornet-veinterestrates. }  AutofarmV2_CrossChain/StratVLEV2.sol function buyBack(uint256 _earnedAmt) internal returns (uint256) { if (buyBackRate <= 0) { return _earnedAmt; } uint256 buyBackAmt = _earnedAmt.mul(buyBackRate).div(buyBackRateMax); IPancakeRouter02(uniRouterAddress).swapExactTokensForTokens( buyBackAmt, 0, earnedToAUTOPath, buyBackAddress, now + 600 ); return _earnedAmt.sub(buyBackAmt); 7 }  AutofarmV2_CrossChain/StratX2_MDEX.sol function convertDustToEarned() public whenNotPaused { require(isAutoComp, \"!isAutoComp\"); require(!isCAKEStaking, \"isCAKEStaking\"); //Convertsdusttokensintoearnedtokens,whichwillbereinvestedonthenextearn(). //Convertstoken0dust(ifany)toearnedtokens uint256 token0Amt = IERC20(token0Address).balanceOf(address(this)); if (token0Address != earnedAddress && token0Amt > 0) { IERC20(token0Address).safeIncreaseAllowance( uniRouterAddress, token0Amt ); //Swapalldusttokenstoearnedtokens IPancakeRouter02(uniRouterAddress) .swapExactTokensForTokensSupportingFeeOnTransferTokens( token0Amt, 0, token0ToEarnedPath, address(this), now + 600 ); } //Convertstoken1dust(ifany)toearnedtokens uint256 token1Amt = IERC20(token1Address).balanceOf(address(this)); if (token1Address != earnedAddress && token1Amt > 0) { IERC20(token1Address).safeIncreaseAllowance( uniRouterAddress, token1Amt ); //Swapalldusttokenstoearnedtokens IPancakeRouter02(uniRouterAddress) .swapExactTokensForTokensSupportingFeeOnTransferTokens( 8 token1Amt, 0, token1ToEarnedPath, address(this), now + 600 ); } }  AutofarmV2_CrossChain/StratX2_MDEX.sol function _convertMDXToEarned() internal { //ConvertsMDX(ifany)toearnedtokens uint256 MDXAmt = IERC20(MDXAddress).balanceOf(address(this)); if (MDXAddress != earnedAddress && MDXAmt > 0) { IERC20(MDXAddress).safeIncreaseAllowance(uniRouterAddress, MDXAmt); //Swapalldusttokenstoearnedtokens IPancakeRouter02(uniRouterAddress) .swapExactTokensForTokensSupportingFeeOnTransferTokens( MDXAmt, 0, MDXToEarnedPath, address(this), now + 60 ); } }  AutofarmV2_CrossChain/StratX2_MDEX.sol function buyBack(uint256 _earnedAmt) internal returns (uint256) { if (buyBackRate <= 0) { return _earnedAmt; } uint256 buyBackAmt = _earnedAmt.mul(buyBackRate).div(buyBackRateMax); if (earnedAddress == AUTOAddress) { IERC20(earnedAddress).safeTransfer(buyBackAddress, buyBackAmt); } else { IERC20(earnedAddress).safeIncreaseAllowance( uniRouterAddress, 9 buyBackAmt ); IPancakeRouter02(uniRouterAddress) .swapExactTokensForTokensSupportingFeeOnTransferTokens( buyBackAmt, 0, earnedToAUTOPath, buyBackAddress, now + 600 ); } return _earnedAmt.sub(buyBackAmt); }  AutofarmV2_CrossChain/StratVLEV2.sol function earn() external whenNotPaused { if (onlyGov) { require(msg.sender == govAddress, \"!gov\"); } IVenusDistribution(venusDistributionAddress).claimVenus(address(this)); uint256 earnedAmt = IERC20(venusAddress).balanceOf(address(this)); earnedAmt = distributeFees(earnedAmt); earnedAmt = buyBack(earnedAmt); if (venusAddress != wantAddress) { IPancakeRouter02(uniRouterAddress).swapExactTokensForTokens( earnedAmt, 0, venusToWantPath, address(this), now.add(600) ); } lastEarnBlock = block.number; 10 _farm(false); //SupplywantTokenwithoutleverage,tocaterfornet-veinterestrates. } Fix Status: The issue has been fixed in this commit: b27f2cafcf51667726bd70220420707c89b75975",
        "labels": [
            "SlowMist",
            "autofarm",
            "Severity: High"
        ]
    },
    {
        "title": "4.2.2.1 Excessive authority issues",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - autofarm_en-us.pdf",
        "body": "The add function has excessive authority issues, Owner can add mining pool arbitrarily, there is a risk of stealing mining by himself, and _strat is the destination address of the final sending of funds, the owner can set this address arbitrarily, pay attention to compatibility issues with external contracts, it is recommended to set the ownership to the timelock contract, and add events to record in the add function.  AutofarmV2_CrossChain/AutoFarmV2_CrossChain.sol function add( uint256 _allocPoint, IERC20 _want, bool _withUpdate, address _strat ) public onlyOwner { if (_withUpdate) { massUpdatePools(); } totalAllocPoint = totalAllocPoint.add(_allocPoint); poolInfo.push( PoolInfo({ want: _want, allocPoint: _allocPoint, lastRewardBlock: 0, accAUTOPerShare: 0, 11 strat: _strat }) ); } Fix Status: The ownership has been transfer to timelock contract. Reference https://hecoinfo.com/tx/0xbe90b5dba8315b30a010ea957e9631154857b93d84cdb344c11b339b 5f3e5421 The authority of the Gov role is large, and the address of the external contract can be set arbitrarily. Malicious and wrong external contracts will cause the user's funds to be lost, and there is a issues of excessive authorityit is recommended to set the gov to the timelock contract.  AutofarmV2_CrossChain/StratX2.sol function setEntranceFeeFactor(uint256 _entranceFeeFactor) public { require(msg.sender == govAddress, \"!gov\"); require(_entranceFeeFactor >= entranceFeeFactorLL, \"!safe - too low\"); require(_entranceFeeFactor <= entranceFeeFactorMax, \"!safe - too high\"); entranceFeeFactor = _entranceFeeFactor; } function setWithdrawFeeFactor(uint256 _withdrawFeeFactor) public { require(msg.sender == govAddress, \"!gov\"); require(_withdrawFeeFactor >= withdrawFeeFactorLL, \"!safe - too low\"); require(_withdrawFeeFactor <= withdrawFeeFactorMax, \"!safe - too high\"); withdrawFeeFactor = _withdrawFeeFactor; } function setControllerFee(uint256 _controllerFee) public { require(msg.sender == govAddress, \"!gov\"); require(_controllerFee <= controllerFeeUL, \"too high\"); controllerFee = _controllerFee; } function setbuyBackRate(uint256 _buyBackRate) public { require(msg.sender == govAddress, \"!gov\"); 12 require(buyBackRate <= buyBackRateUL, \"too high\"); buyBackRate = _buyBackRate; } function setGov(address _govAddress) public { require(msg.sender == govAddress, \"!gov\"); govAddress = _govAddress; } function setOnlyGov(bool _onlyGov) public { require(msg.sender == govAddress, \"!gov\"); onlyGov = _onlyGov; } function setUniRouterAddress(address _uniRouterAddress) public { require(msg.sender == govAddress, \"!gov\"); uniRouterAddress = _uniRouterAddress; } function setBuyBackAddress(address _buyBackAddress) public { require(msg.sender == govAddress, \"!gov\"); buyBackAddress = _buyBackAddress; } function setRewardsAddress(address _rewardsAddress) public { require(msg.sender == govAddress, \"!gov\"); rewardsAddress = _rewardsAddress; } Fix Status: The Gov has been transfer to timelock contract. Reference https://hecoinfo.com/tx/0xfdf183915b5659473f9e8e3438c295cb859e022faa073a0a8f12c38e0a 4c257d",
        "labels": [
            "SlowMist",
            "autofarm",
            "Severity: Medium"
        ]
    },
    {
        "title": "4.2.2.2 DoS issues",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - autofarm_en-us.pdf",
        "body": "In the massUpdatePools function, if the length of poolInfo is too large, there is a risk of DoS. It is 13 recommended to limit poolInfo.length to avoid DoS caused by too large length.  AutofarmV2_CrossChain/AutoFarmV2_CrossChain.sol function massUpdatePools() public { uint256 length = poolInfo.length; for (uint256 pid = 0; pid < length; ++pid) { updatePool(pid); } } Fix Status: The issue has been fixed in this commit: b27f2cafcf51667726bd70220420707c89b75975",
        "labels": [
            "SlowMist",
            "autofarm",
            "Severity: Medium"
        ]
    },
    {
        "title": "4.2.3.1 Missing event log",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - autofarm_en-us.pdf",
        "body": "\"setEntranceFeeFactor\" function, \"setWithdrawFeeFactor\" function, \"setControllerFee\" function, \"setbuyBackRate\" function, \"setGov\" function, \"setOnlyGov\" function, \"setUniRouterAddress\" function, \"setBuyBackAddress\" function, \"setRewardsAddress\" function, no events are added to record. It is recommended to add events for recording.  AutofarmV2_CrossChain/StratX2_MDEX.sol  AutofarmV2_CrossChain/StratVLEV2.sol function setEntranceFeeFactor(uint256 _entranceFeeFactor) public { require(msg.sender == govAddress, \"!gov\"); require(_entranceFeeFactor >= entranceFeeFactorLL, \"!safe - too low\"); require(_entranceFeeFactor <= entranceFeeFactorMax, \"!safe - too high\"); entranceFeeFactor = _entranceFeeFactor; } function setWithdrawFeeFactor(uint256 _withdrawFeeFactor) public { require(msg.sender == govAddress, \"!gov\"); require(_withdrawFeeFactor >= withdrawFeeFactorLL, \"!safe - too low\"); 14 require(_withdrawFeeFactor <= withdrawFeeFactorMax, \"!safe - too high\"); withdrawFeeFactor = _withdrawFeeFactor; } function setControllerFee(uint256 _controllerFee) public { require(msg.sender == govAddress, \"!gov\"); require(_controllerFee <= controllerFeeUL, \"too high\"); controllerFee = _controllerFee; } function setbuyBackRate(uint256 _buyBackRate) public { require(msg.sender == govAddress, \"!gov\"); require(buyBackRate <= buyBackRateUL, \"too high\"); buyBackRate = _buyBackRate; } function setGov(address _govAddress) public { require(msg.sender == govAddress, \"!gov\"); govAddress = _govAddress; } function setOnlyGov(bool _onlyGov) public { require(msg.sender == govAddress, \"!gov\"); onlyGov = _onlyGov; } function setUniRouterAddress(address _uniRouterAddress) public { require(msg.sender == govAddress, \"!gov\"); uniRouterAddress = _uniRouterAddress; } function setBuyBackAddress(address _buyBackAddress) public { require(msg.sender == govAddress, \"!gov\"); buyBackAddress = _buyBackAddress; } function setRewardsAddress(address _rewardsAddress) public { require(msg.sender == govAddress, \"!gov\"); rewardsAddress = _rewardsAddress; } Fix Status: 15 The issue has been fixed in this commit: b27f2cafcf51667726bd70220420707c89b75975",
        "labels": [
            "SlowMist",
            "autofarm",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.2.3.2 Missing nonReentrant modifier",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - autofarm_en-us.pdf",
        "body": "The deposit function missing the nonReentrant modifier, it is recommended to add the nonReentrant modifier.  AutofarmV2_CrossChain/StratX2_MDEX.sol function deposit(address _userAddress, uint256 _wantAmt) public onlyOwner whenNotPaused returns (uint256) IERC20(wantAddress).safeTransferFrom( address(msg.sender), address(this), _wantAmt ); uint256 sharesAdded = _wantAmt; if (wantLockedTotal > 0 && sharesTotal > 0) { sharesAdded = _wantAmt .mul(sharesTotal) .mul(entranceFeeFactor) .div(wantLockedTotal) .div(entranceFeeFactorMax); } sharesTotal = sharesTotal.add(sharesAdded); if (isAutoComp) { _farm(); } else { wantLockedTotal = wantLockedTotal.add(_wantAmt); } return sharesAdded; 16 { } Fix Status: The issue has been fixed in this commit: b27f2cafcf51667726bd70220420707c89b75975 5.",
        "labels": [
            "SlowMist",
            "autofarm",
            "Severity: Informational"
        ]
    },
    {
        "title": "Overow issues",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - WombatExchange_en-us.pdf",
        "body": "The data type of priceStruct.expo is int32, and the return result is negative, so uint256(int256(priceStruct.expo)) will get a large value, and 10 ** uint256(int256(priceStruct.expo) will overflow. Because the compiler version used is pragma solidity ^0.8.5;`. ",
        "labels": [
            "SlowMist",
            "WombatExchange",
            "Type: Integer Overow and Underow Vulnerability",
            "Severity: Critical"
        ]
    },
    {
        "title": "Missing event record",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - WombatExchange_en-us.pdf",
        "body": "The owner has the ability to modify the values of the maxPriceAge, shouldCapEquilCovRatio, startCovRatio, endCovRatio parameters, etc. which are global variables, but any modications made to them are not recorded with events. ",
        "labels": [
            "SlowMist",
            "WombatExchange",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Excessive authority issues",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - WombatExchange_en-us.pdf",
        "body": "The Owner can modify priceIDs[_token], priceFeed, fallbackPriceFeed. This will aect the price at which the project gets oracle. The wrong price will lead to a fatal vulnerability in the project. ",
        "labels": [
            "SlowMist",
            "WombatExchange",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Redundant judgment",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - WombatExchange_en-us.pdf",
        "body": "If fromAmount is 0, the code will revert, so if (fromAmount >= 0) should be changed to if (fromAmount > 0). ",
        "labels": [
            "SlowMist",
            "WombatExchange",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "fee management suggestions",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - WombatExchange_en-us.pdf",
        "body": "If the receiving address of fee is an EOA address, there will be a single point risk of private key management. ",
        "labels": [
            "SlowMist",
            "WombatExchange",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "conditional competition issues",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - WombatExchange_en-us.pdf",
        "body": "The llPool function and the transferTipBucket function are controlled by the two roles of dev and owner respectively. When the opinions of the dev and owner are inconsistent, there will be conditional competition issues. ",
        "labels": [
            "SlowMist",
            "WombatExchange",
            "Type: Race Conditions Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Suggestions for variable type conversion",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - WombatExchange_en-us.pdf",
        "body": "The following functions when using uint256 to convert int256, it is not judged whether the variable to be converted is less than type(int256).max, and when using int256 to convert uint256, it is not judged whether the variable is greater than 0. CoreV3.quoteDepositLiquidity CoreV3.quoteWithdrawAmount CoreV3.quoteWithdrawAmountFromOtherAsset CoreV3.quoteSwap CoreV3.quoteSwapTokensForCredit CoreV3.quoteSwapCreditForTokens PoolV3._globalInvariantFunc PoolV3.globalEquilCovRatioWithCredit DynamicPoolV3._globalInvariantFunc PythPriceFeed.getLatestPrice",
        "labels": [
            "SlowMist",
            "WombatExchange",
            "Type: Others",
            "Severity: Low"
        ]
    },
    {
        "title": "Business logic is unclear",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - WombatExchange_en-us.pdf",
        "body": "The _quoteFactor function returns a xed value of 1e18, but the function receives parameters, and the parameters do not need to be used. ",
        "labels": [
            "SlowMist",
            "WombatExchange",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Token compatibility issues",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - WombatExchange_en-us.pdf",
        "body": "When the project is transferred to the token, it does not judge the balance change before and after the transfer of the target address receiving the token, so it is incompatible with reective tokens (deation/ination type tokens), which will cause the balance of the transfer to be inconsistent with the balance actually received, which will lead to calculation errors. ",
        "labels": [
            "SlowMist",
            "WombatExchange",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Redundant type conversion code",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - WombatExchange_en-us.pdf",
        "body": "The _quoteFrom function is using uint256 nalToAssetCovRatio = (toAssetCash + uint256(actualToAmount)).wdiv(toAssetLiability); to convert uint256(actualToAmount), But actualToAmount is of the type uint256, it is no need to convert. ",
        "labels": [
            "SlowMist",
            "WombatExchange",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Authorization limit issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - TransitSwap v4 Core_en-us.pdf",
        "body": "There are two roles Owner and Executor in the contract, and the permissions of the two roles are not clearly divided.",
        "labels": [
            "SlowMist",
            "TransitSwap v4 Core",
            "Type: Authority Control Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Security suggestion",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - TransitSwap v4 Core_en-us.pdf",
        "body": "Since the TransitSwapRouter contract will retain the user's authorization limit, it is recommended to allow the user to allocate on demand during the front-end authorization, and do not authorize the maximum value at one time to prevent the user's funds from being stolen. 11",
        "labels": [
            "SlowMist",
            "TransitSwap v4 Core",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing zero address check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - TransitSwap v4 Core_en-us.pdf",
        "body": "When modifying important addresses in the contract, it is not checked whether the incoming address is a zero address. ",
        "labels": [
            "SlowMist",
            "TransitSwap v4 Core",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - TransitSwap v4 Core_en-us.pdf",
        "body": "The Owner has the risk of over-authorization, and this role can withdraw the tokens in the contract to any address. ",
        "labels": [
            "SlowMist",
            "TransitSwap v4 Core",
            "Type: Authority Control Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Authority control issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - TransitSwap v4 Core_en-us.pdf",
        "body": "The contract adopts a completely open calling logic. There is an operation to authorize the approveAddress address in the _beforeSwap function. The calling path of this function is TransitSwapRouter.swap() -> TransitSwap.swap() -> TransitSwap._beforeSwap(). The calldata parameter is also passed in when calling the top-level function TransitSwapRouter.swap(). The code does not check whether the approveAddress is legal. If a malicious approveAddress is passed in, the contract will be incorrectly authorized and the tokens in the contract will be lost. ",
        "labels": [
            "SlowMist",
            "TransitSwap v4 Core",
            "Type: Authority Control Vulnerability",
            "Severity: High"
        ]
    },
    {
        "title": "Uninitialized parameter",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - TransitSwap v4 Core_en-us.pdf",
        "body": "The swapAmount parameter is declared in the contract but not initialized. ",
        "labels": [
            "SlowMist",
            "TransitSwap v4 Core",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Unsafe external call",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - TransitSwap v4 Core_en-us.pdf",
        "body": "The path and pair parameters in the supportingFeeOn function are controllable. If an attacker passes in malicious path and pair parameters, it may cause unexpected errors. ",
        "labels": [
            "SlowMist",
            "TransitSwap v4 Core",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing Approve amount reset",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - TransitSwap v4 Core_en-us.pdf",
        "body": "The _beforeSwap function in the TransitSwap contract will set the authorization limit to the maximum value when accessing the token for the rst time, but the function to remake the authorization is not found in the contract. When the authorization limit is used up, it will not be able to remake and the token cannot be used.",
        "labels": [
            "SlowMist",
            "TransitSwap v4 Core",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "4.2.1.1 __Guard_init function was not call when initialize",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Hot Cross BSC Bridge V1.0.0_en-us.pdf",
        "body": "ForeignProcessor contract and HomeRequest contract are inherit the Guard contract but dost not call the __Gurad_init function function __ForeignProcessor_init( IERC20 token, ValidatorRegistry validatorRegistry_ ) internal initializer { //SlowMist// Missing call of __Guard_init function require( address(token) != address(0) && Misc.isContract(address(token)), \"ForeignProcessor:Invalid erc20 address provided\" 10 ); require( address(validatorRegistry_) != address(0) && Misc.isContract(address(validatorRegistry_)), \"ForeignProcessor:Invalid validator registry address\" ); erc20 = token; validatorRegistry = validatorRegistry_; } function __HomeRequest_init( BEP20 token, ValidatorRegistry validatorRegistry_ ) internal initializer { //SlowMist// Missing call of __Guard_init function require( address(token) != address(0) && Misc.isContract(address(token)), \"HomeRequest:Invalid BEP20 address\" ); require( address(validatorRegistry_) != address(0) && Misc.isContract(address(validatorRegistry_)), \"HomeRequest:Invalid validator registry address\" ); bep20 = token; validatorRegistry = validatorRegistry_; } Fix status: fixed. 11 5.",
        "labels": [
            "SlowMist",
            "Hot Cross BSC Bridge V1.0.0",
            "Severity: Informational"
        ]
    },
    {
        "title": "Tokens Obtained from Emergency Withdrawal Partly Locked",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist_Audit_Report_StakeStone_MellowDepositWstETHStrategy_en-us.pdf",
        "body": "In the MellowDepositWstETHStrategy contract, the owner role can execute an emergency withdrawal operation from the mellowVault contract by calling the emergencyWithdrawFromMellow function. In the mellowVault contract, during an emergency withdrawal operation, the specied amount of LP tokens from previous withdrawal requests are burned, and two types of tokens, wstETH and DC_wstETH, are transferred to the address indicated in the withdrawal request. The amounts transferred are calculated based on the burned LP tokens and the current balance of these two tokens in the pool. However, in the MellowDepositWstETHStrategy contract, there is no implementation for redeeming DC_wstETH tokens back into wstETH, which results in these DC_wstETH tokens being locked within the contract. Furthermore, when calculating the total invested value of the contract using the getInvestedValue function, it fails to account for the value of the held DC_wstETH tokens. Code Location: contracts/strategies/MellowDepositWstETHStrategy.sol function getInvestedValue() public override returns (uint256 value) { uint256 etherValue = address(this).balance; uint256 stETHValue = IERC20(stETHAddr).balanceOf(address(this)); (, uint256 claimableValue, uint256 pendingValue) = checkPendingAssets(); uint256 mellowPending = getPendingValueFromMellow(); value = etherValue + stETHValue + claimableValue + pendingValue + getWstETHValue() + getDepositedValue() + mellowPending; } ... function emergencyWithdrawFromMellow( uint256[] memory _minAmounts, uint256 _deadline ) external onlyOwner returns (uint256 wstETHAmount) { IMellowVault(mellowVaultAddr).emergencyWithdraw(_minAmounts, _deadline); }",
        "labels": [
            "SlowMist",
            "SlowMist_Audit_Report_StakeStone_MellowDepositWstETHStrategy",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "The Potential Risk of Fixed Array Lengths",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist_Audit_Report_StakeStone_MellowDepositWstETHStrategy_en-us.pdf",
        "body": "In the MellowDepositWstETHStrategy contract, the owner role can call the depositIntoMellow function to deposit wstETH tokens from the contract into the MellowVault, where the length of the passed amounts array is xed at 1. Within the deposit function of the MellowVault contract, a check is performed to ensure that the lengths of the contract's _underlyingTokens array and the passed amounts array are equal. Currently, as the _underlyingTokens array in the MellowVault contract also contains only 1 element, this check passes successfully. However, the MellowVault contract features a function (addToken) that allows for adding new token data to the _underlyingTokens array. If, in the future, the _underlyingTokens array expands due to the addition of new tokens, the depositIntoMellow function may fail this length check and consequently be unable to execute properly. The same issues also apply when making a withdrawal request. Code Location: contracts/strategies/MellowDepositWstETHStrategy.sol#L177&L200 function depositIntoMellow( uint256 _wstETHAmount, uint256 _minLpAmount ) external onlyOwner returns (uint256 lpAmount) { require(_wstETHAmount != 0, \"zero\"); TransferHelper.safeApprove(wstETHAddr, mellowVaultAddr, _wstETHAmount); uint256[] memory amounts = new uint256[](1); amounts[0] = _wstETHAmount; (, lpAmount) = IMellowVault(mellowVaultAddr).deposit( address(this), amounts, _minLpAmount, block.timestamp ); emit DepositIntoMellow( mellowVaultAddr, address(this), _wstETHAmount, lpAmount ); } function requestWithdrawFromMellow( uint256 _share, uint256 _minAmount ) external onlyOwner { require(_share != 0, \"zero\"); uint256[] memory amounts = new uint256[](1); amounts[0] = _minAmount; IMellowVault(mellowVaultAddr).registerWithdrawal( address(this), _share, amounts, block.timestamp, type(uint256).max, true ); emit WithdrawFromMellow(mellowVaultAddr, address(this), _share); }",
        "labels": [
            "SlowMist",
            "SlowMist_Audit_Report_StakeStone_MellowDepositWstETHStrategy",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Conict in withdrawal requests",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist_Audit_Report_StakeStone_MellowDepositWstETHStrategy_en-us.pdf",
        "body": "In the MellowDepositWstETHStrategy contract, The owner role can initiate a withdrawal request for wstETH by calling the requestWithdrawFromMellow function, with the closePrevious parameter set to true by default. This implies that if a previous withdrawal request has been submitted and is still pending, it will rst be canceled before replacing it with the newly submitted withdrawal request. Code Location: contracts/strategies/MellowDepositWstETHStrategy.sol#L208 function requestWithdrawFromMellow( uint256 _share, uint256 _minAmount ) external onlyOwner { require(_share != 0, \"zero\"); uint256[] memory amounts = new uint256[](1); amounts[0] = _minAmount; IMellowVault(mellowVaultAddr).registerWithdrawal( address(this), _share, amounts, block.timestamp, type(uint256).max, true ); emit WithdrawFromMellow(mellowVaultAddr, address(this), _share); }",
        "labels": [
            "SlowMist",
            "SlowMist_Audit_Report_StakeStone_MellowDepositWstETHStrategy",
            "Type: Design Logic Audit",
            "Severity: Information"
        ]
    },
    {
        "title": "Redundant code",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Owlto Depositor_en-us.pdf",
        "body": "There are useless codes in the le and codes that are not used in actual business. Code Location: Depositor.sol#L225-227 contract Depositor { ... error NotOwnerError(); error LengthError(); error ZeroAddressError(); ... }",
        "labels": [
            "SlowMist",
            "Owlto Depositor",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Spelling mistake",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Owlto Depositor_en-us.pdf",
        "body": "Spelling mistake was identied within the code. Code Location: Depositor.sol function isContractt(address account) internal view returns (bool) { // This method relies on extcodesize, which returns 0 for contracts in // construction, since the code is only stored at the end of the // constructor execution. uint256 size; // solhint-disable-next-line no-inline-assembly assembly { size := extcodesize(account) } return size > 0; } ... function callOptionalReturn(IERC20 token, bytes memory data) private { ... require(address(token).isContractt(), \"SafeERC20: call to non-contract\"); ... }",
        "labels": [
            "SlowMist",
            "Owlto Depositor",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "4.2.1.1 Excessive auditing authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - MoonSwap_en-us.pdf",
        "body": "The owner in MasterStar contract can add a new lpToken through the add function, but if there is a black swan event, such as the addition of a malicious lpToken, there will be useless lpToken to recharge to get rewards. It is suggested that the owner can be handed over to the governance contract or time lock contract for management. function add(uint256 _allocPoint, IERC20 _lpToken, bool _withUpdate) public onlyOwner { if (_withUpdate) { massUpdatePools(); } require(poolIndexs[address(_lpToken)] < 1, \"LpToken exists\"); uint256 lastRewardBlock = block.number > startBlock ? block.number : startBlock; totalAllocPoint = totalAllocPoint.add(_allocPoint); poolInfo.push(PoolInfo({ lpToken: _lpToken, allocPoint: _allocPoint, lastRewardBlock: lastRewardBlock, tokenPerBlock: currentTokenPerBlock, accTokenPerShare: 0, finishMigrate: false, lockCrosschainAmount:0, crosschain_enable: false })); poolIndexs[address(_lpToken)] = poolInfo.length; } Owner can set migrator , It is suggested that the owner can be handed over to the governance contract or time lock contract for management. function setMigrator(IMigratorStar _migrator) public onlyOwner { migrator = _migrator; 7 } //Migratelptokentoanotherlpcontract.Canbecalledbyanyone.Wetrustthatmigratorcontractisgood. function migrate(uint256 _pid) public { require(address(migrator) != address(0), \"migrate: no migrator\"); PoolInfo storage pool = poolInfo[_pid]; IERC20 lpToken = pool.lpToken; uint256 bal = lpToken.balanceOf(address(this)); lpToken.safeApprove(address(migrator), bal); IERC20 newLpToken = migrator.migrate(lpToken); require(bal == newLpToken.balanceOf(address(this)), \"migrate: bad\"); pool.lpToken = newLpToken; pool.finishMigrate = true; } Fixed: The owner authority has been transferred to the timelock contract. Reference: https://etherscan.io/tx/0x3e8be2489c824906c7fe1abe376ccea198e3cd28cb225dee91d4f9c3e9 62a889",
        "labels": [
            "SlowMist",
            "MoonSwap",
            "Severity: Low"
        ]
    },
    {
        "title": "4.2.2.1 Compiler version is inconsistent",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - MoonSwap_en-us.pdf",
        "body": "The compiler version used by the imported contract is inconsistent. It is recommended to use a unified fixed compiler version when deploying. pragma solidity ^0.6.0; pragma solidity ^0.6.2; pragma solidity 0.6.12;",
        "labels": [
            "SlowMist",
            "MoonSwap",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.2.2.2 Better handling of ownership transfers",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - MoonSwap_en-us.pdf",
        "body": "When using the transferOwnership function to change the owner, it is recommended to add a 8 confirmation method that newOwner accepts the owner. The real authority transfer is performed after the new address is signed and confirmed to avoid the loss of authority. function transferOwnership(address newOwner) public virtual onlyOwner { require(newOwner != address(0), \"Ownable: new owner is the zero address\"); emit OwnershipTransferred(_owner, newOwner); _owner = newOwner; }",
        "labels": [
            "SlowMist",
            "MoonSwap",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.2.2.3 Enhancement point of delegateBySig function",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - MoonSwap_en-us.pdf",
        "body": "The nonce in the delegateBySig function is input by the user. When the user input a larger nonce, the current transaction cannot be success but the relevant signature data will still remain on the chain, causing this signature to be available for some time in the future. It is recommended to fix it according to EIP-2612. Reference: https://github.com/ethereum/EIPs/blob/master/EIPS/eip-2612.md#implementation. function delegateBySig( address delegatee, uint nonce, uint expiry, uint8 v, bytes32 r, bytes32 s external ) { bytes32 domainSeparator = keccak256( abi.encode( DOMAIN_TYPEHASH, keccak256(bytes(name())), getChainId(), address(this) ) ); 9 bytes32 structHash = keccak256( abi.encode( DELEGATION_TYPEHASH, delegatee, nonce, expiry ) ); bytes32 digest = keccak256( abi.encodePacked( \"\\x19\\x01\", domainSeparator, structHash ) ); address signatory = ecrecover(digest, v, r, s); require(signatory != address(0), \"MOON::delegateBySig: invalid signature\"); require(nonce == nonces[signatory]++, \"MOON::delegateBySig: invalid nonce\"); require(now <= expiry, \"MOON::delegateBySig: signature expired\"); return _delegate(signatory, delegatee); }",
        "labels": [
            "SlowMist",
            "MoonSwap",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.2.2.4 Mint issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - MoonSwap_en-us.pdf",
        "body": "The owner can mint tokens unlimitedly through mint function, but the owner's authority of the token contract is changed to MasterStar contract for the first time. function mint(address _to, uint256 _amount) public onlyOwner { _mint(_to, _amount); _moveDelegates(address(0), _delegates[_to], _amount); } Fixed: The owner authority has actually been transferred to the MasterStar contract. Reference: 10 https://etherscan.io/tx/0x0303672ee5045cd01102fdb50787541d11bddc3e1bfc446d4f6b46db85 e65bff",
        "labels": [
            "SlowMist",
            "MoonSwap",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.2.2.5 Using now globally available variables that will be deprecated",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - MoonSwap_en-us.pdf",
        "body": "The now globally available variables is used, which has been deprecated in compiler solidity 0.7.0. require(signatory != address(0), \"MOON::delegateBySig: invalid signature\"); require(nonce == nonces[signatory]++, \"MOON::delegateBySig: invalid nonce\"); require(now <= expiry, \"MOON::delegateBySig: signature expired\");",
        "labels": [
            "SlowMist",
            "MoonSwap",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.2.2.6 0 value is not checked",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - MoonSwap_en-us.pdf",
        "body": "The withdraw function suggests adding a check of _amount> 0, which can optimize the gas consumption when _amount is 0. function withdraw(uint256 _pid, uint256 _amount) public { PoolInfo storage pool = poolInfo[_pid]; require(!pool.finishMigrate, \"migrate not withdraw\"); UserInfo storage user = userInfo[_pid][msg.sender]; require(user.amount >= _amount, \"withdraw: not good\"); updatePool(_pid); uint256 pending = user.amount.mul(pool.accTokenPerShare).div(1e12).sub(user.rewardDebt); safeTokenTransfer(msg.sender, pending); user.amount = user.amount.sub(_amount); user.rewardDebt = user.amount.mul(pool.accTokenPerShare).div(1e12); pool.lpToken.safeTransfer(address(msg.sender), _amount); emit Withdraw(msg.sender, _pid, _amount); }",
        "labels": [
            "SlowMist",
            "MoonSwap",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.2.2.7 Prompt Error",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - MoonSwap_en-us.pdf",
        "body": "The prompt of setCrosschain function require has an error \"migrate not deposit\", it is recommended to modify the prompt to \"migrate not setCrosschain\". 11 function setCrosschain(uint256 _pid, bool isOk, address cmoonAddr) public onlyOwner { PoolInfo storage pool = poolInfo[_pid]; require(pool.finishMigrate, \"migrate not deposit\"); pool.crosschain_enable = isOk; require(cmoonAddr != address(0), \"address invalid\"); migratePoolAddrs[_pid] = cmoonAddr; } Fixed: The issue has been fixed by this commit: ef19afe4b6bfd624dd79903c36ea335be6a7b283.",
        "labels": [
            "SlowMist",
            "MoonSwap",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.2.2.8 Better handling of devaddr transfers",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - MoonSwap_en-us.pdf",
        "body": "When changing devaddr in the dev function, it is recommended to add newDevaddr to accept the replacement confirmation method. After the new address is signed and confirmed, the real change to devaddr can be made to avoid setting errors and the income cannot be normally obtained. function dev(address _devaddr) public { require(msg.sender == devaddr, \"dev: wut?\"); devaddr = _devaddr; }",
        "labels": [
            "SlowMist",
            "MoonSwap",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.2.2.9 Coding Standards",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - MoonSwap_en-us.pdf",
        "body": "The coding style of emergencyWithdraw function is to make an external call first, and then change the value of the contract variable. This way of writing, because lpToken is considered safe, there is no reentrancy problem, but it is recommended to use the correct coding standard: The variable is changed, and then an external call is made. A lock modifier for reentrancy prevention can also be added. function emergencyWithdraw(uint256 _pid) public { PoolInfo storage pool = poolInfo[_pid]; require(!pool.finishMigrate, \"migrate not withdraw\"); UserInfo storage user = userInfo[_pid][msg.sender]; pool.lpToken.safeTransfer(address(msg.sender), user.amount); 12 emit EmergencyWithdraw(msg.sender, _pid, user.amount); user.amount = 0; user.rewardDebt = 0; } Fixed: The issue has been fixed by this commit: ef19afe4b6bfd624dd79903c36ea335be6a7b283 5.",
        "labels": [
            "SlowMist",
            "MoonSwap",
            "Severity: Informational"
        ]
    },
    {
        "title": "Lack of previous pool status check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Stake Mask_en-us.pdf",
        "body": "In the StakeManager contract, the user can deposit funds into the contract by calling the depositAndLock function and withdraw funds by calling the withdraw function. However, when a new pool is added and currentPoolId is updated to the id of the new pool, the user calls depositAndLock function again to make a deposit without checking the unlocked state of the pool that the user deposited in before. So the poolId in the user's information will be directly overwritten with the new currentPoolId, even if the pool state at the time of the previous deposit was a locked state. If the state of the new pool is unlocked, the withdraw function can be called directly to withdraw all of the user's deposits, even if the pool where the rst deposit was made was in a locked state. Code Location: src/StakeManager.sol function depositAndLock(uint256 _amount) public nonReentrant { Pool storage pool = pools[currentPoolId]; require(pool.stakingEnabled, \"Staking is disabled for this pool\"); require(maskToken.transferFrom(msg.sender, address(this), _amount), \"Transfer failed\"); userInfos[msg.sender].stakedAmount += _amount; // depositAndLock will always stake to currentPoolId // it will init userInfos[msg.sender].poolId for the first time // it will change userInfos[msg.sender].poolId to currntPoolId(which means new pool) when // user deposit after prev pool unlocked userInfos[msg.sender].poolId = currentPoolId; emit Staked(msg.sender, currentPoolId, _amount); } function withdraw(uint256 _amount) public nonReentrant { Pool storage pool = pools[userInfos[msg.sender].poolId]; require(pool.unlocked, \"Pool is locked\"); require(userInfos[msg.sender].stakedAmount >= _amount, \"Insufficient balance\"); userInfos[msg.sender].stakedAmount -= _amount; require(maskToken.transfer(msg.sender, _amount), \"Transfer failed\"); emit unstaked(msg.sender, userInfos[msg.sender].poolId, _amount); }",
        "labels": [
            "SlowMist",
            "Stake Mask",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Dierence check when changing pools",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Stake Mask_en-us.pdf",
        "body": "In the StakeManager contract, the user can update the poolId in the user information to the latest currentPoolId by calling the changePool function. However, there is no check to see if the currentPoolId matches the poolId in the user information. Code Location: src/StakeManager.sol function changePool() public nonReentrant { uint8 fromPoolId = userInfos[msg.sender].poolId; Pool storage fromPool = pools[userInfos[msg.sender].poolId]; Pool storage toPool = pools[currentPoolId]; require(toPool.stakingEnabled, \"Staking is disabled for this pool\"); require(fromPool.unlocked, \"From pool is locked\"); require(userInfos[msg.sender].stakedAmount > 0, \"No staked amount\"); userInfos[msg.sender].poolId = currentPoolId; emit StakeChanged(msg.sender, fromPoolId, currentPoolId); }",
        "labels": [
            "SlowMist",
            "Stake Mask",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing return value check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Stake Mask_en-us.pdf",
        "body": "In the Reward contract, the owner can call the emergencyWithdraw function to transfer any tokens in the contract. But it does not check the return value. If external tokens do not adopt the EIP20 standard, it may lead to false top-up issues. ",
        "labels": [
            "SlowMist",
            "Stake Mask",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Stake Mask_en-us.pdf",
        "body": "In the Reward contract, the owner can call the emergencyWithdraw function to transfer any tokens in the contract. If the privilege is lost or misused, there may be an impact on the user's funds. ",
        "labels": [
            "SlowMist",
            "Stake Mask",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "4.3.1.2 Risk of loss of user funds",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DODOV2_en-us.pdf",
        "body": "In the LockTokenVault contract, when transferring the user's locked token, it did not check whether the _to address is msg.sender itself, which caused the user to abuse the transfer and cause a loss of funds. function transferLockedToken(address to) external { originBalances[to] = originBalances[to].add(originBalances[msg.sender]); claimedBalances[to] = claimedBalances[to].add(claimedBalances[msg.sender]); originBalances[msg.sender] = 0; claimedBalances[msg.sender] = 0; } Fix status: fixed, repair commit: main-08a06609604779c31db493bc0d755efa1c3f0a61.",
        "labels": [
            "SlowMist",
            "DODOV2",
            "Severity: Low"
        ]
    },
    {
        "title": "4.2.2.1 Missing events",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DODOV2_en-us.pdf",
        "body": "Contract  DODOApproveProxy  Function list  init / unlockAddProxy / addDODOProxy / LockAddProxy / removeDODOProxy ContractDODOApproveFunction listinit / unlockSetProxy / setDODOProxy / LockSetProxy ContractDODV2Proxy02Function listaddWhiteList / removeWhiteList / updateGasReturn ContractDVMFactorFunction listupdateDvmTemplate ContractDPPAdvanceFunction listtunePrice ContractDPPAdvance Function listsetOperator / setFreezeTimestamp ContractDPPVaultFunction listratioSync / retrieve 6 ContractDVMVault Function list_setReserve_sync The above functions does not have an event declaration, it is recommended to add the corresponding event declaration Fix status: After communicating with the project party, it is confirmed that the above event statement is not currently used in business and will be fixed in subsequent iterations.",
        "labels": [
            "SlowMist",
            "DODOV2",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.2.2.2 The contract balance was not verified when the reward was distributed",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DODOV2_en-us.pdf",
        "body": "In the RewardVault contract, the contract balance is not verified when the reward is distributed, which may cause the contract balance to fail to be distributed function reward(address to, uint256 amount) external onlyOwner { //SlowMist// Not verify if contract balance is larger than the transfer amount IERC20(dodoToken).safeTransfer(to, amount); } Fix situation: After confirming with the project party, they ignore this problem.",
        "labels": [
            "SlowMist",
            "DODOV2",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.2.2.3 Unchecked array length",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DODOV2_en-us.pdf",
        "body": "a. The getPendingReward function in the BaseMine contract did not verify whether the value of i passed in was less than the length of the array when obtaining the reward of the pool, which resulted in the failure to obtain the reward. function getPendingReward(address user, uint256 i) public view returns (uint256) { //SlowMist// Not verify the array length RewardTokenInfo storage rt = rewardTokenInfos[i]; uint256 accRewardPerShare = rt.accRewardPerShare; if (rt.lastRewardBlock != block.number) { accRewardPerShare = _getAccRewardPerShare(i); } return 7 DecimalMath.mulFloor( balanceOf(user), accRewardPerShare.sub(rt.userRewardPerSharePaid[user]) ).add(rt.userRewards[user]); } Fix status: fixed, repair commit: feature/mineV2AndDSP- 5917c95439cac06241f108038043d2 2348c863e6. b. The claimReward function in the BaseMine contract does not verify whether the value of i passed in is less than the length of the array, resulting in failure to obtain rewards function claimReward(uint256 i) public { require(i<rewardTokenInfos.length, \"DODOMineV2: REWARD_ID_NOT_FOUND\"); _updateReward(msg.sender, i); RewardTokenInfo storage rt = rewardTokenInfos[i]; uint256 reward = rt.userRewards[msg.sender]; if (reward > 0) { rt.userRewards[msg.sender] = 0; IRewardVault(rt.rewardVault).reward(msg.sender, reward); emit Claim(i, msg.sender, reward); } } Fix status: fixed, repair commit: feature/mineV2AndDSP- 5917c95439cac06241f108038043d2 2348c863e6.",
        "labels": [
            "SlowMist",
            "DODOV2",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.2.2.4 Compatibility risk of rebasing tokens",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DODOV2_en-us.pdf",
        "body": "The deposit function of the ERC20Mine contract does not verify the incoming amount. When it is compatible with rebasing tokens, it will cause an error to obtain the transfer amount. function claimReward(uint256 i) public { require(i<rewardTokenInfos.length, \"DODOMineV2: REWARD_ID_NOT_FOUND\"); _updateReward(msg.sender, i); 8 RewardTokenInfo storage rt = rewardTokenInfos[i]; uint256 reward = rt.userRewards[msg.sender]; if (reward > 0) { rt.userRewards[msg.sender] = 0; IRewardVault(rt.rewardVault).reward(msg.sender, reward); emit Claim(i, msg.sender, reward); } } Fix status: fixed, fix commit: main-d26b21bd814d4bfcc702521d52f6cb3af4f86e5c. 5.",
        "labels": [
            "SlowMist",
            "DODOV2",
            "Severity: Informational"
        ]
    },
    {
        "title": "Potential Unable to Borrow Issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn LeverageStaking - SlowMist Audit Report.pdf",
        "body": "In the LeverageStake contract, the batchDecreaseLever function reduces the leverage ratio of the ETF by withdrawing/repaying in AAVE, and may completely repay the debt in AAVE in the process. In this case, when the operator fully withdraws stETH from AAVE, the state of usingAsCollateral of the ETF in AAVE will be set to false. Theoretically, the aToken in the ETF will be 0 at this time, and usingAsCollateral will be automatically set to true when the ETF deposits in AAVE next time. But in fact, AAVE may still have 1wei of aToken left in the ETF due to arithmetic precision errors when calculating the number of aTokens that need to be burned by withdrawing the amount. Therefore, when the ETF deposits in AAVE next time, usingAsCollateral will not be set to true, and since there is no interface for calling the setUserUseReserveAsCollateral function in LeverageStake, this may cause the ETF to no longer be able to perform borrow operations. ",
        "labels": [
            "SlowMist",
            "DeSyn LeverageStaking - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Library function visibility issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn LeverageStaking - SlowMist Audit Report.pdf",
        "body": "In the protocol, the LeverageStake contract operates ETF through the interface of the AaveCall library, so the AaveCall library is stateless, and there is no need to set the visibility of the function to external/public. ",
        "labels": [
            "SlowMist",
            "DeSyn LeverageStaking - SlowMist Audit Report",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Function multiple logic mixes",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn LeverageStaking - SlowMist Audit Report.pdf",
        "body": "In the getLeverageInfo function comment of the LeverageStake contract, it is explained that this function is used to obtain the fund status of the ETF in AAVE. But it not only gets it through the getUserAccountData function but also rebinds the ETF. These are two completely unrelated functions but used in the same function. And due to the openness of the getLeverageInfo function, any user can perform rebind operations through this function, which may be contrary to the design philosophy of ETF. ",
        "labels": [
            "SlowMist",
            "DeSyn LeverageStaking - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Potential Malicious Liquidation ETF Issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn LeverageStaking - SlowMist Audit Report.pdf",
        "body": "In the LeverageStake contract, the operator can increase the leverage ratio of the ETF in AAVE through the borrow function. Since there is no maximum leverage limit, when the leverage ratio is too high and stETH is close to the liquidation line, the ETF may be liquidated due to the accumulation of loan interest. If the operator acts maliciously subjectively, the funds of users in the ETF will be at risk. ",
        "labels": [
            "SlowMist",
            "DeSyn LeverageStaking - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "min_dy without slippage and exchange fees",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn LeverageStaking - SlowMist Audit Report.pdf",
        "body": "In the LeverageStake contract, the increaseLever and convertToAstEth functions all have the function of exchanging stETH and ETH tokens through the exchange function. However, the min_dy parameter passed in is consistent with the dx parameter. Due to the existence of slippage and exchange fees, a certain amount of stETH cannot be exchanged for exactly the same amount of ETH tokens. Therefore, the exchange function in these functions cannot be executed normally. ",
        "labels": [
            "SlowMist",
            "DeSyn LeverageStaking - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Potential Operator Arbitrage Risk",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn LeverageStaking - SlowMist Audit Report.pdf",
        "body": "In the LeverageStake contract, the operator can exchange stETH and ETH tokens through the exchange function, but its min_dy parameter is also set by the operator. Therefore, if the caller does not pass in min_dy, the exchange operation of the ETF in the Curve Pool may suer from a sandwich attack, resulting in the loss of ETF assets. ",
        "labels": [
            "SlowMist",
            "DeSyn LeverageStaking - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Unreasonable defaultSlippage",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn LeverageStaking - SlowMist Audit Report.pdf",
        "body": "There is a defaultSlippage variable in the LeverageStake contract, which is used in the decreaseLever and convertToWeth functions to exchange the minimum received amount between stETH and ETH tokens. It defaults to 1 and cannot be modied, which will cause min_dy to be 1% of dx during the exchange operation, making the token exchange process vulnerable to sandwich attacks. ",
        "labels": [
            "SlowMist",
            "DeSyn LeverageStaking - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Redundant receive function",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn LeverageStaking - SlowMist Audit Report.pdf",
        "body": "There is a receive function in the LeverageStake contract to enable the contract to receive native tokens. However, in actual business, the contract does not need to receive native tokens, so the receive function is redundant, which may also cause users to mistakenly transfer native tokens to this contract and then fail to withdraw them. ",
        "labels": [
            "SlowMist",
            "DeSyn LeverageStaking - SlowMist Audit Report",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Issues with not updating bound tokens",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn LeverageStaking - SlowMist Audit Report.pdf",
        "body": "In the LeverageStake contract, the deposit, borrow, withdraw, and repayBorrow functions are used to operate the ETF to deposit, borrow, withdraw, and repay to AAVE, respectively. However, the _records of the bound tokens in the ETF are not updated in the above operations. This will cause the token _records in the ETF to be skewed after the operator operates through the above function. ",
        "labels": [
            "SlowMist",
            "DeSyn LeverageStaking - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Partial rebind issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn LeverageStaking - SlowMist Audit Report.pdf",
        "body": "In the LeverageStake contract, the increaseLever and decreaseLever functions respectively increase/decrease the leverage ratio of the ETF in AAVE, and at the same time rebind the astETH tokens in the ETF, but do not update the _records status of ETH and stETH in the ETF, which will cause The _records state does not match the actual token balance in the ETF. ",
        "labels": [
            "SlowMist",
            "DeSyn LeverageStaking - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Potential denial of service risk due to gulp operations",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase5 - SlowMist Audit Report_en-us.pdf",
        "body": "In the Actions contract, when the user performs the autoJoinSmartPool operation, the number of shares the user can obtain will be calculated through the _calculateShare function, and minPoolAmountOut will be checked at the end. The _calculateShare function obtains the number of tokens recorded in the pool through bPool's getBalance when calculating the share, but unfortunately any user can update this parameter through bPool's gulp function. Therefore, when an ordinary user performs an autoJoinSmartPool operation, a malicious user directly transfers funds to bPool and calls the gulp function to update the token balance recorded in the pool. At this time, ordinary users will not be able to successfully add liquidity due to the minPoolAmountOut check. If the minPoolAmountOut value passed in by an ordinary user is 0, it may cause an interest rate ination attack. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase5 - SlowMist Audit Report",
            "Type: Denial of Service Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Incorrect event logging",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase5 - SlowMist Audit Report_en-us.pdf",
        "body": "In the CRP contract, the createPool function adds the creator parameter as the real creator of the pool. However, the corresponding events were not modied accordingly. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase5 - SlowMist Audit Report",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Incorrect WETH address",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase5 - SlowMist Audit Report_en-us.pdf",
        "body": "The WETH address constant is hard-coded in the Actions contract, but this address is an EOA address on the Ethereum mainnet and is not the correct WETH address. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase5 - SlowMist Audit Report",
            "Type: Others",
            "Severity: High"
        ]
    },
    {
        "title": "Incorrect poolTokens check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase5 - SlowMist Audit Report_en-us.pdf",
        "body": "In the autoJoinSmartPool function of the Actions contract, it checks the tokens deposited by the user through poolTokens[i] == handleToken , but handleToken has been replaced by the issueToken parameter during the native token checking phase. Therefore, the poolTokens[i] == handleToken check is not accurate. If handleToken is WETH, it will cause an error in the _makeSwap operation. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase5 - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Redundant STBT token check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase5 - SlowMist Audit Report_en-us.pdf",
        "body": "In the autoJoinSmartPool and _exit functions of the Actions contract, when making a token transfer, it will be checked whether the transferred token is an STBT token. But in fact, the protocol does not allow deposits of STBT tokens, and STBT tokens will also be converted into stablecoins after the ETF expires. Therefore, theoretically, there will be no STBT tokens in the contract, so the STBT token check is redundant. . ",
        "labels": [
            "SlowMist",
            "DeSyn Phase5 - SlowMist Audit Report",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Potential risk of slot conict",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase5 - SlowMist Audit Report_en-us.pdf",
        "body": "In this protocol iteration, both SmartPoolManager and Actions contracts have changed their storage structures. If these contracts use an upgradeable model, and upgrading the contract directly on the original basis may lead to contract storage slot conicts. In fact, the Actions contract is an upgradeable contract, so special attention should be paid to such risks.",
        "labels": [
            "SlowMist",
            "DeSyn Phase5 - SlowMist Audit Report",
            "Type: Variable Coverage Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of event forgery",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase5 - SlowMist Audit Report_en-us.pdf",
        "body": "In the CRP contract, the exitPool function adds a user parameter to record the real caller when the user exits through the Actions contract. However, users can also exit by calling the exitPool function of the CRP contract. They can pass in any user parameter to make the LogExit event record an incorrect value. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase5 - SlowMist Audit Report",
            "Type: Malicious Event Log Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Potential risk of denial of service due to large CRPFactory array",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase5 - SlowMist Audit Report_en-us.pdf",
        "body": "In the CRPFactory contract, when the Blabs role performs addCRPFactory and removeCRPFactory operations, it will use a for loop to traverse the entire CRPFactorys array. If the array length is too large, it will lead to DoS risks. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase5 - SlowMist Audit Report",
            "Type: Denial of Service Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Potential risk of endless loop",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase5 - SlowMist Audit Report_en-us.pdf",
        "body": "In the CRPFactory contract, the isCrp function is used to check whether the address passed by the user is a CRP contract. If not, the CRPFactorys array will be circulated and the isCrp function of other CRPFactory will be called to check. However, it should be noted that if the Blabs role adds this contract address to the CRPFactorys array, the user will fall into an innite loop error when querying a CRP address that is not recorded in this contract through the isCrp function. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase5 - SlowMist Audit Report",
            "Type: Denial of Service Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Unchecked asset type in inputEth function allows potential asset mismatch",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Doubler Lite.pdf",
        "body": "The input function lacks a crucial check to verify if the _asset parameter corresponds to an ETH pool. This oversight creates a potential vulnerability. In a scenario where both ETH and BTC pools exist, a user could potentially input ETH but have it processed as BTC. This mismatch between the intended and actual asset type could lead to unexpected behavior and potential exploitation of the system. contracts/Doubler.sol function inputEth( address _asset, uint256 _qAmount, address _to ) external payable nonReentrant onlyOncePerBlock onlyAsset(_asset) { if (msg.value != _qAmount) revert E_Balance(); _input(_asset, _qAmount, _to, true); }",
        "labels": [
            "SlowMist",
            "Doubler Lite",
            "Type: Others",
            "Severity: Low"
        ]
    },
    {
        "title": "Issue with fee allocation in the _limitMint function",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Doubler Lite.pdf",
        "body": "In the _limitMint function, the distribution of minting fees should be based on the length of _srvFeeAddr . Currently, the number of _srvFeeAddr entries called from the Doubler contract is only 2. However, if other contracts call this function with a dierent length of _srvFeeAddr in the future, it will result in allocating more fees than intended. contracts/RBToken.sol function _limitMint( address _recipient, uint256 _tokenAmount, uint256 _poolTotalLimit, address[] memory _srvFeeAddr, uint16 _srvFeeRatio ) internal returns (uint256 recipientTokenAmount) { ... _totalShare = _totalShare + newShares; uint256 recipientNewShare = newShares; recipientTokenAmount = _tokenAmount; if (_srvFeeRatio > 0) { uint256 srvFee = (newShares * _srvFeeRatio) / _perMil; recipientTokenAmount = recipientTokenAmount - (_tokenAmount * _srvFeeRatio) / _perMil; for (uint8 i = 0; i < _srvFeeAddr.length; i++) { _shares[_srvFeeAddr[i]] = _shares[_srvFeeAddr[i]] + srvFee / 2; recipientNewShare = recipientNewShare - srvFee / 2; _emitTransferEvents(address(0x0), _recipient, (_tokenAmount * _srvFeeRatio) / _perMil, srvFee); } } _shares[_recipient] = _shares[_recipient] + recipientNewShare; _emitTransferEvents(address(0x0), _recipient, recipientTokenAmount, recipientNewShare); }",
        "labels": [
            "SlowMist",
            "Doubler Lite",
            "Type: Others",
            "Severity: Low"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Doubler Lite.pdf",
        "body": "The owner can modify the fees and fee recipients in the pool, which can cause damage to the project's funds if the private key is compromised. contracts/Doubler.sol owner can initializeDoubler owner can updateLowerOfInputMaximum owner can newPool owner can updatePool ADMIN can set the upper and lower price limits of the prediction machine, which will aect the functionality of the contract if ADMIN's private key is compromised. contracts/FastPriceFeed.sol ADMIN can setAssetPriceLimit ADMIN can setPriceFeedTimeLimit ADMIN can newAsset ADMIN can switchPriceFeed The owner can set the address where the fee will be charged, and if the private key is leaked, it will result in the loss of the project's funds. contracts/DoublerFactory.sol contracts/DoublerFactory.sol owner can updateEcoAddr owner can newPool",
        "labels": [
            "SlowMist",
            "Doubler Lite",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Potential bypass Issue with onlyOncePerBlock",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Doubler Lite.pdf",
        "body": "In the design logic of doubler lite, atoken, btoken, and ctoken are all transferable. The onlyOncePerBlock mechanism is intended to restrict a user to a single function operation within one block. However, this restriction only applies to msg.sender, allowing users to bypass the limitation by making calls through multiple contracts. contracts/Doubler.sol modifier onlyOncePerBlock() { if (_lastBlockCalled[msg.sender] >= block.number) revert E_BlockOnce(); _; _lastBlockCalled[msg.sender] = block.number; }",
        "labels": [
            "SlowMist",
            "Doubler Lite",
            "Type: Others",
            "Severity: Medium"
        ]
    },
    {
        "title": "Abnormal implementation logic in getPooledByShares",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Doubler Lite.pdf",
        "body": "In the getPooledByShares function, it should retrieve the corresponding token amount based on sharesAmount. However, the actual interface called retrieves sharesAmount based on the token amount. contracts/RBToken.sol function getPooledByShares(uint256 _sharesAmount) public view returns (uint256) { return _getSharesByPooledToken(_sharesAmount); }",
        "labels": [
            "SlowMist",
            "Doubler Lite",
            "Type: Others",
            "Severity: Low"
        ]
    },
    {
        "title": "Potential risk due to the unique nature of 10xBToken",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Doubler Lite.pdf",
        "body": "Since 10xBToken is a special type of token where users hold shares instead of actual quantities, there may be an extreme risk when users add liquidity providers. In an extreme scenario, subsequent investors can obtain a large number of shares, causing the price of BToken in the pool to rise sharply (because the actual token quantity obtainable by the pools shares decreases). This could result in liquidity providers incurring losses as a small amount of tokens might be used to exchange for a large amount of corresponding assets. Status Acknowledged",
        "labels": [
            "SlowMist",
            "Doubler Lite",
            "Type: Others",
            "Severity: Information"
        ]
    },
    {
        "title": "Impact of inationary or deationary tokens on the doubler lite economic model",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Doubler Lite.pdf",
        "body": "In the economic model of Doubler Lite, the use of inationary (e.g., stETH) or deationary tokens does not aect the overall economic model. This is because all calculations are based on shares, and the ination or deation impacts only the temporary average price of the tokens, which aligns with the design expectations. Status Acknowledged",
        "labels": [
            "SlowMist",
            "Doubler Lite",
            "Type: Others",
            "Severity: Information"
        ]
    },
    {
        "title": "Recommendations for parameter checking",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Doubler Lite.pdf",
        "body": "contracts/Doubler.sol Suggest checking startTime, endTime to make sure startTime is less than endTime, and checking creator to make sure creator is not address(0). function _checkPoolParam(Pool memory _pl) internal pure { if (_pl.inputFee > 20) revert E_FeeLimit(); if (_pl.withdrawFee > 20) revert E_FeeLimit(); }",
        "labels": [
            "SlowMist",
            "Doubler Lite",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Redundant code",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Send V1.0.1_en-us.pdf",
        "body": "Ether is not accepted by default, which is a redundant code. cross-send/contracts/CrossSend.sol#L41-L47 initial-hotcross-oering/contracts/BaseIHO.sol#L67-L73 fallback () external payable { revert(\"cannot directly accept currency transfers\"); } receive () external payable { revert(\"cannot directly receive currency transfers\"); 15 }",
        "labels": [
            "SlowMist",
            "Cross Send V1.0.1",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Gas optimization",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Send V1.0.1_en-us.pdf",
        "body": "If one of the batch transfers fails, the transaction that was previously transferred normally will be reverted, but Gas has been consumed. It is a gas optimization issue here. cross-send/contracts/CrossSend.sol#L175-L210 function sendToken( IERC20 token, address[] memory recipients, uint256[] memory amounts ) private returns(uint256) { uint256 total = 0; for (uint256 i = 0; i < recipients.length ; i++) { require(_msgSender() != recipients[i], \"sender != recipient\"); token.safeTransferFrom(_msgSender(), recipients[i], amounts[i]); total += amounts[i]; } return total; } function sendNative( address[] memory recipients, uint256[] memory amounts ) private returns(uint256) { uint256 total = 0; 16 for (uint256 i = 0; i < recipients.length ; i++) { total += amounts[i]; (bool success, ) = payable(recipients[i]).call{value: amounts[i]}(\"\"); require(success, \"native transfer failed\"); } return total; }",
        "labels": [
            "SlowMist",
            "Cross Send V1.0.1",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of allowance amount abuse",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Send V1.0.1_en-us.pdf",
        "body": "There have an allowance amount in the contract, but the distributeTokenFee function does not limit the caller, and there is an issue of being called arbitrarily, but it can only transfer the balance of the sender to the feeCollector. cross-send/contracts/fee-managers/RecipientCountFee.sol#L65-L83 function distributeTokenFee( uint256 txRecipientCount, uint256, uint256, uint256, uint256, address sender ) public override { uint256 payableFee = txRecipientCount * tokenFeePerRecipient; 17 if(payableFee < minTokenFee) { payableFee = minTokenFee; } else if (payableFee > maxTokenFee) { payableFee = maxTokenFee; } token.safeTransferFrom(sender, feeCollector, payableFee); }",
        "labels": [
            "SlowMist",
            "Cross Send V1.0.1",
            "Type: Authority Control Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Price manipulation issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Send V1.0.1_en-us.pdf",
        "body": "The IOUPrice is calculated using totalFarmingTokenBalance. Attackers can control totalFarmingTokenBalance to manipulate IOUPrice. The current code does not nd the location where IOUPrice is used. Referencehttps://slowmist.medium.com/cream-hacked-analysis-us-130-million-hacked-95c9410320ca cross-yield/contracts/core/CrossYield.sol#L95-L101 function IOUPrice() public view returns (uint256) { uint256 IOUSupply = totalSupply(); return IOUSupply == 0 ? 1e18 : (totalFarmingTokenBalance() * 1e18) / IOUSupply; } 18 cross-yield/contracts/core/CrossYield.sol#L65-L67 function totalFarmingTokenBalance() public view returns (uint256) { return farmingToken().balanceOf(address(this)) + strategy.balanceOf(); }",
        "labels": [
            "SlowMist",
            "Cross Send V1.0.1",
            "Type: Others",
            "Severity: Medium"
        ]
    },
    {
        "title": "Sandwich attacks issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Send V1.0.1_en-us.pdf",
        "body": "There is no slippage check during swap, and there is a risk of sandwich attack. IPancakeRouter02(pcsRouter).swapExactTokensForTokens(cakeBalance, 0,cakeToBaseRoute, address(this), block.timestamp); IPancakeRouter02(pcsRouter) .swapExactTokensForTokens(toSwap, 0, route, address(this), block.timestamp); Reference https://medium.com/coinmonks/demystify-the-dark-forest-on-ethereum-sandwich-attacks-5a3aec9fa33e cross-yield/contracts/libs/OptimalSwap.sol#L14-L63 function prepareLiquidity( address cake, address[2] memory lpTokens, 19 address wbnb, address busd, address farmingToken, address pcsRouter, uint256 fee ) external { uint256 cakeBalance = IERC20(cake).balanceOf(address(this)); bool isCakeInLp = lpTokens[0] == cake || lpTokens[1] == cake; bool isWbnbBased = lpTokens[0] == wbnb || lpTokens[1] == wbnb; address baseToken = isWbnbBased ? wbnb : busd; // if cake is not part of the lp token, swap all cake for the base token if (!isCakeInLp) { address[] memory cakeToBaseRoute = new address[](2); cakeToBaseRoute[0] = cake; cakeToBaseRoute[1] = baseToken; IPancakeRouter02(pcsRouter) .swapExactTokensForTokens(cakeBalance, 0, cakeToBaseRoute, address(this), block.timestamp); } (uint256 reserve0, uint256 reserve1,) = IPancakePair(farmingToken).getReserves(); address[] memory route = new address[](2); uint256 lp0Bal = IERC20(lpTokens[0]).balanceOf(address(this)); uint256 lp1Bal = IERC20(lpTokens[1]).balanceOf(address(this)); uint256 toSwap; // The possible cases here are: // - Cake was not part of the LP token, so we swap for baseToken which could either be lpToken0 or lpToken // - Cake was part of the LP token, so it can either be lpTokens[0] or lpTokens[1] // So, depending on which token we have the highest balance for, we swap for the other one. if (lp0Bal > lp1Bal) { toSwap = SwapAmount.getSwapAmount(lp0Bal, reserve0, fee); route[0] = lpTokens[0]; route[1] = lpTokens[1]; } else { toSwap = SwapAmount.getSwapAmount(lp1Bal, reserve1, fee); route[0] = lpTokens[1]; route[1] = lpTokens[0]; 20 } // Perform the swap IPancakeRouter02(pcsRouter) .swapExactTokensForTokens(toSwap, 0, route, address(this), block.timestamp); } IPancakeRouter02(pcsRouter).swapExactTokensForTokens(toWbnb, 0, cakeToWbnbRoute, address(this), block.timestamp); cross-yield/contracts/strategies/StrategyCake.sol#L131 function collectFees() internal { // a percentant of the cake we get from the masterchef will be used to buy BNB and transfer to this address // this is the total fees that will be shared amongst the protocol, stategy dev and the harvester uint256 toWbnb = feeManager.calculateTotalFee(IERC20(farmingToken).balanceOf(address(this))); IPancakeRouter02(pcsRouter).swapExactTokensForTokens(toWbnb, 0, cakeToWbnbRoute, address(this), block.timestamp); uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this)); // distribute hervester fee uint256 harvesterFeeAmount = feeManager.calculateHarvestFee(wbnbBal); // collectFees is called indirectly from the CrossYield contract via the beforeDeposit hook. // This means that _msgSender() is the CrossYield contract and not the actuall EOA account // that send the transaction IERC20(wbnb).safeTransfer(tx.origin, harvesterFeeAmount); // distribute protocol fee uint256 protocolFeeAmount = feeManager.calculateProtocolFee(wbnbBal); // IERC20(wbnb).safeTransfer(protocolFeeRecipient, protocolFeeAmount); feeProcessor.process(protocolFeeAmount); // distribute strategy dev fee uint256 strategyDevFeeAmount = feeManager.calculateStrategyDevFee(wbnbBal); IERC20(wbnb).safeTransfer(feeManager.strategyDev(), strategyDevFeeAmount); emit FeeCollected( toWbnb, 21 harvesterFeeAmount, protocolFeeAmount, strategyDevFeeAmount, _msgSender() ); } cross-yield/contracts/strategies/StrategyCakeLP.sol#L174 function collectFees() internal { // a percentant of the cake we get from the masterchef will be used to buy BNB and transfer to this address // this is the total fees that will be shared amongst the protocol, stategy dev and the harvester uint256 toWbnb = feeManager.calculateTotalFee(IERC20(cake).balanceOf(address(this))); IPancakeRouter02(pcsRouter).swapExactTokensForTokens(toWbnb, 0, cakeToWbnbRoute, address(this), block.timestamp); uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this)); // distribute hervester fee uint256 harvesterFeeAmount = feeManager.calculateHarvestFee(wbnbBal); IERC20(wbnb).safeTransfer(_msgSender(), harvesterFeeAmount); // distribute protocol fee uint256 protocolFeeAmount = feeManager.calculateProtocolFee(wbnbBal); feeProcessor.process(protocolFeeAmount); // distribute strategy dev fee uint256 strategyDevFeeAmount = feeManager.calculateStrategyDevFee(wbnbBal); IERC20(wbnb).safeTransfer(feeManager.strategyDev(), strategyDevFeeAmount); emit FeeCollected( toWbnb, harvesterFeeAmount, protocolFeeAmount, strategyDevFeeAmount, _msgSender() ); } cross-yield/contracts/strategies/StrategyCake.sol 22 function harvest() public override whenNotPaused { // claim rewards IMasterChef(masterchef).leaveStaking(0); // because harvest can automatically be called after each user deposit // we might end up having multiple deposits in the same block and only one // would return rewards from masterchef so the rest will have 0 cake so // we don't need to waste gas to collect fees and call deposit uint256 farmingTokenBalance = balanceOfFarmingToken(); if(farmingTokenBalance > 0) { collectFees(); deposit(); emit HarvestTriggered(_msgSender(), farmingTokenBalance); } } cross-yield/contracts/strategies/StrategyCakeLP.sol#l137-L148 function harvest() external override whenNotPaused { // claim rewards IMasterChef(masterchef).deposit(poolId, 0); uint256 harvestedAmount = IERC20(cake).balanceOf(address(this)); collectFees(); addLiquidity(); deposit(); emit HarvestTriggered(_msgSender(), harvestedAmount); }",
        "labels": [
            "SlowMist",
            "Cross Send V1.0.1",
            "Type: Reordering Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Missing slippage check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Send V1.0.1_en-us.pdf",
        "body": "The addLiquidity function without slippage check, it doesn't have an impermanent loss check. cross-yield/contracts/strategies/StrategyCakeLP.sol#L218 function addLiquidity() internal { OptimalSwap.prepareLiquidity( cake, [lpToken0, lpToken1], wbnb, busd, farmingToken, pcsRouter, swapFee ); // add liquidity to AMM on PCS uint256 lp0Bal = IERC20(lpToken0).balanceOf(address(this)); uint256 lp1Bal = IERC20(lpToken1).balanceOf(address(this)); IPancakeRouter02(pcsRouter) .addLiquidity(lpToken0, lpToken1, lp0Bal, lp1Bal, 0, 0, address(this), block.timestamp); emit LiquidityAdded(lpToken0, lpToken1, lp0Bal, lp1Bal, _msgSender()); }",
        "labels": [
            "SlowMist",
            "Cross Send V1.0.1",
            "Type: Reordering Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Permission check Missing",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Send V1.0.1_en-us.pdf",
        "body": "There is no permission check for deposit function. The function is called by the CrossYieid contract. cross-yield/contracts/strategies/StrategyCakeLP.sol#L225-L231 function deposit() public override whenNotPaused { uint256 farmingTokenBalance = balanceOfFarmingToken(); if (farmingTokenBalance > 0) { IMasterChef(masterchef).deposit(poolId, farmingTokenBalance); } } cross-yield/contracts/strategies/StrategyCake.sol#L169-L175 function deposit() public override whenNotPaused { uint256 farmingTokenBalance = balanceOfFarmingToken(); if (farmingTokenBalance > 0) { IMasterChef(masterchef).enterStaking(farmingTokenBalance); } }",
        "labels": [
            "SlowMist",
            "Cross Send V1.0.1",
            "Type: Authority Control Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Excessive authority issue 25",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Send V1.0.1_en-us.pdf",
        "body": "Owner can modify the address of the strategy. The new strategy may have security risks if it is not audited, which will aect the user's funds. If the private key is leaked, it will aect the user's funds. cross-yield/contracts/core/CrossYield.sol#L224-L236 function upgradeStrategy() public onlyOwner { require(stratCandidate.strategy != address(0), \"No proposal exists\"); require(block.number > stratCandidate.proposedBlock + stratUpgradableAfter, \"Strategy cannot be replaced yet\"); emit NewStrategy(stratCandidate.strategy); strategy.retireStrategy(); strategy = IStrategy(stratCandidate.strategy); stratCandidate.strategy = address(0); stratCandidate.proposedBlock = 0; putFundsToWork(); } cross-yield/contracts/core/CrossYield.sol#L211-L220 function proposeStrategy(address _strategy) public onlyOwner { require(address(this) == IStrategy(_strategy).vault(), \"Invalid new strategy\"); stratCandidate = StrategyCandidate({ strategy: _strategy, proposedBlock: block.number }); emit NewStratCandidate(_strategy); }",
        "labels": [
            "SlowMist",
            "Cross Send V1.0.1",
            "Type: Authority Control Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Repeatable claims issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Send V1.0.1_en-us.pdf",
        "body": "After the claim, lottery.status is not set as claimed, and it is also necessary to check whether lotteryId has been claimed when the claim is executed. hotdrop/contracts/HotDrop.sol#L261-L274 function claim(uint256 lotteryId) external nonReentrant { Lottery storage lottery = lotteries[lotteryId]; require(lottery.status == Status.WinnerDrawn, \"winner not drawn\"); // if there is no winner transfer the total amount to the treasury if(tickets[lotteryId][lottery.winningNumber] == address(0)) { lottery.purchaseToken.safeTransfer(treasury, lottery.purchaseToken.balanceOf(address(this))); } else if(tickets[lotteryId][lottery.winningNumber] == _msgSender()) { // if the ticket is the winning ticket and belongs to the user then split the pot uint256 treasuryAmount = (lottery.totalRaised * lottery.treasuryFee) / FEE_BASE; lottery.purchaseToken.safeTransfer(treasury, treasuryAmount); lottery.purchaseToken.safeTransfer(_msgSender(), lottery.totalRaised - treasuryAmount); } }",
        "labels": [
            "SlowMist",
            "Cross Send V1.0.1",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Round plan security reminder",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Send V1.0.1_en-us.pdf",
        "body": "And the new round of lottery can only be opened when the last round of lottery is in WinnerDrawn, otherwise randomGenerator.latestLotteryId will be updated, which will cause the old lottery round to fail to execute drawWinner function due to this check. require(lotteryId == randomGenerator.latestLotteryId(), \"numbers not drawn\"); hotdrop/contracts/HotDrop.sol#L44-L256 function drawWinner(uint256 lotteryId) external nonReentrant { Lottery storage lottery = lotteries[lotteryId]; require(lottery.status == Status.Close, \"lottery still active\"); require(lotteryId == randomGenerator.latestLotteryId(), \"numbers not drawn\"); // get the winning number based on the randomResult generated by ChainLink's fallback uint256 winningNumber = randomGenerator.randomResult(); lottery.winningNumber = winningNumber; lottery.status = Status.WinnerDrawn; emit LotteryNumberDrawn(lotteryId, winningNumber); }",
        "labels": [
            "SlowMist",
            "Cross Send V1.0.1",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Trustin_en_us.pdf",
        "body": "In the Comptroller, CToken, SimplePriceOracle, and Unitroller contracts, the admin role can modify key sensitive parameters such as the manager roles, the rate model, the market, the pause status, the whitelist, the price of the underlying asset, and the admin role, which will lead to the risk of over-privilege of the admin role. ",
        "labels": [
            "SlowMist",
            "Trustin_en_us",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Decimal loss with an empty marke",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Trustin_en_us.pdf",
        "body": "If there are two markets, one of which was used by the UI, one of which was empty. Someone can mint collateral tokens in an empty market and redeem most minted tokens, then donate redeemed asset tokens to inate the exchange rate through the getAccountSnapshot function. Next, borrow a dierent asset with the manipulated exchange rate, and redeem collateral to recover donation. However, the redeemUnderlying function may wrongly be rounded down on the tokens to remove from a malicious caller, which causes the redemption of many tokens only to require little underlying assets. The last, liquidation borrower contract position with borrowed funds and redeem collateral tokens to reset the empty market. Reference: https://www.comp.xyz/t/hundred-nance-exploit-and-compound-v2/4266 ",
        "labels": [
            "SlowMist",
            "Trustin_en_us",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Receive can lock users native tokens",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Trustin_en_us.pdf",
        "body": "There is a receive function in the CErc20Delegator, Timelock, and Unitroller contracts so that the contracts can receive native tokens. However, the receive function can lock users native tokens when users transfer the native token in these contracts by mistake and there is no token processing logic. ",
        "labels": [
            "SlowMist",
            "Trustin_en_us",
            "Type: Others",
            "Severity: Low"
        ]
    },
    {
        "title": "Missing the event record",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Trustin_en_us.pdf",
        "body": "The admin role can modify the compAddress parameter, but there are no event logs in these functions. ",
        "labels": [
            "SlowMist",
            "Trustin_en_us",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "External call reminder",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Trustin_en_us.pdf",
        "body": "In the Comptroller contract, users can call the claimZnt to claim the comp in markets, but the implementation address is seting by the admin and the import Zenith is not in the audit scope. ",
        "labels": [
            "SlowMist",
            "Trustin_en_us",
            "Type: Unsafe External Call Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing event record",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cell Core_en-us.pdf",
        "body": "The following functions do not log events. contracts/Cell.sol updateStageRecordMaxCount updateStageRecordCostPoint updateStageRecordIncPoint updateStageRecordValid addSigner removeSigner setProxyer contracts/Nucleus.sol setOracleAddress contracts/Oracle.sol addOracleAddress removeOracleAddress setTokenNameAddress setRates setRatePeriod setFixedPrice revokeFixedPrice contracts/Proxy.sol setOracleAddress setCellAddress setMintPrice",
        "labels": [
            "SlowMist",
            "Cell Core",
            "Type: Malicious Event Log Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Safe transfer issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cell Core_en-us.pdf",
        "body": "contracts/Nucleus.sol Use transferFrom in the claim function to transfer the token. If the token in the operation does not meet the eip20 standard, the transaction may fail. contracts/Proxy.sol Use transferFrom in the mint function to transfer the token. If the token in the operation does not meet the eip20 standard, the transaction may fail.",
        "labels": [
            "SlowMist",
            "Cell Core",
            "Type: Others",
            "Severity: Low"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cell Core_en-us.pdf",
        "body": "contracts/Cell.sol The owner has too much authority, and if the owner's private key is leaked, the attacker can control the casting of NFT. contracts/Oracle.sol The owner has too much authority. If the owner's private key is leaked, the attacker can manipulate the price by setting setRates and setFixedPrice . contracts/Proxy.sol The owner's authority is too large. If the owner's private key is leaked, the attacker can withdraw the revenue in the contract. You can also set a malicious Oracle contract through setOracleAddress to control the price. contracts/Nucleus.sol The owner has too much authority. If the owner's private key is leaked, the attacker can set a malicious Oracle contract through setOracleAddress to control the price.",
        "labels": [
            "SlowMist",
            "Cell Core",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Preemptive Initialization",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Doubler - 20240117.pdf",
        "body": "contracts/FRNFT.sol This function has the problem of being preempted. function initialize(address doublerPool) external { require(_initialized == false, \"initialized err\"); _initialized = true; _doublerPool = doublerPool; _grantRole(DOUBLER_ROLE, doublerPool); } contracts/Doubler.sol This function has the problem of being preempted. function initialize( address _initTeam, address _initEco, address _initFastPriceFeed, address _initDoublerNFT, address _initDbrTokenAddress, address _initMultiSigWallet, uint16 _initProtectBlock ) external { if (_initialized == true) revert E_Initialized(); _initialized = true; _team = _initTeam; _eco = _initEco; _fastPriceFeed = _initFastPriceFeed; _FRNFT = _initDoublerNFT; _ecoFeeRatio = 2000; // 20% * 100 _feeRatio = 20; // 0.2% * 100 _protectBlock = _initProtectBlock; _grantRole(DEFAULT_ADMIN_ROLE, _initMultiSigWallet); emit Initialize(_initTeam, _initFastPriceFeed, _initDoublerNFT, _initDbrTokenAddress, _initMultiSigWallet); }",
        "labels": [
            "SlowMist",
            "Doubler - 20240117",
            "Type: Race Conditions Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Doubler - 20240117.pdf",
        "body": "contracts/FastPriceFeed.sol The admin role can be set to price related, if the private key leakage will cause the price anomaly caused by the pool function is impaired. admin can newAsset admin can updatePriceAggregator admin can upgradePlan admin can setTwapInterval",
        "labels": [
            "SlowMist",
            "Doubler - 20240117",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Pool depth and TWAP interval in uniswap V3 price queries",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Doubler - 20240117.pdf",
        "body": "contracts/FastPriceFeed.sol When getting the price of the token, you should pay attention to the depth of the corresponding pool, if the depth of the pool is too shallow and the price range is set too low, there is still a possibility of price manipulation. function getPriceFromDex(address _asset) internal view returns (uint256 price) { require(_isSupported[_asset], 'UniV3: oracle in mainnet not initialized yet!'); address uniswapV3Pool = _assetFeedMap[_asset]; uint32 twapInterval = _twapIntervals[_asset]; IUniswapV3Pool pool = IUniswapV3Pool(uniswapV3Pool); IUniswapV3Pool.Slot0 memory slot0; IUniswapV3Pool.Observation memory obs; slot0 = pool.slot0(); obs = pool.observations((slot0.observationIndex + 1) % slot0.observationCardinality); require(obs.initialized, \"UNIV3: Pair did't initialized\"); uint32 delta = uint32(block.timestamp) - obs.blockTimestamp; require(delta >= twapInterval, 'UniV3: token pool does not have enough transaction history in mainnet'); uint32[] memory secondsAgos = new uint32[](2); secondsAgos[0] = twapInterval; secondsAgos[1] = 0; (int56[] memory tickCumulatives, ) = pool.observe(secondsAgos); uint160 sqrtPriceX96 = TickMath.getSqrtRatioAtTick( int24((tickCumulatives[1] - tickCumulatives[0]) / int56(uint56(twapInterval))) ); (uint256 price0, uint256 price1) = mockDexPrice(pool, sqrtPriceX96); return pool.token0() == _asset ? price0 : price1; }",
        "labels": [
            "SlowMist",
            "Doubler - 20240117",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Recommendations on the conditions of winner",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Doubler - 20240117.pdf",
        "body": "contracts/Doubler.sol In some extreme cases, it may be possible to control the nal winner.",
        "labels": [
            "SlowMist",
            "Doubler - 20240117",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Suggestions for setTwapInterval",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Doubler - 20240117.pdf",
        "body": "contracts/FastPriceFeed.sol It should be a supported token to set the interval. function setTwapInterval(address _asset, uint32 _twapInterval) external onlyRole(DEFAULT_ADMIN_ROLE) { require(!_isSupported[_asset], 'Oracle: do not support this token'); require(_plans[_asset] == Plan.DEX, \"setTwapInterval: Only dex _asset\"); require( MAX_INTERVA >= _twapIntervals[_asset] && _twapIntervals[_asset] >= MIN_INTERVA, 'setTwapInterval: Invalid twapInterval' ); emit SetTwapInterval(_asset, _twapIntervals[_asset], _twapInterval); _twapIntervals[_asset] = _twapInterval; }",
        "labels": [
            "SlowMist",
            "Doubler - 20240117",
            "Type: Others",
            "Severity: Low"
        ]
    },
    {
        "title": "Redundant code",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Doubler - 20240117.pdf",
        "body": "contracts/Doubler.sol The hot in the structure is not used. struct Pool { address asset; address creator; address terminator; uint16 fallRatio; uint16 profitRatio; uint16 rewardRatio; uint16 winnerRatio; uint32 double; uint32 lastLayer; uint256 tokenId; uint256 unitSize; uint256 maxRewardUnits; uint256 winnerOffset; uint256 endPrice; uint256 hot; //SLOWMIST// unused uint256 lastOpenPrice; uint256 tvl; uint256 amount; uint256 margin; uint256 joins; uint256 lastInputBlockNo; uint256 kTotal; }",
        "labels": [
            "SlowMist",
            "Doubler - 20240117",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Function permission control issues",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Doubler - 20240117.pdf",
        "body": "contracts/FRNFT.sol The roles used by these functions are not set and cannot be executed subsequently. setTokenRoyalty resetTokenRoyalty setDefaultRoyaltyInfo deleteDefaultRoyalty",
        "labels": [
            "SlowMist",
            "Doubler - 20240117",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Overlooking purchase price relative to target prot in pool ending logic",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Doubler - 20240117.pdf",
        "body": "contracts/Doubler.sol The scenario where the purchase price is less than or equal to the target prot price has not been considered. When the price at the time of purchase is less than or equal to the target prot price, the purchase should not be allowed. Otherwise, users can manipulate the ending of the pool after purchasing to position themselves as the winner. function _input(AddInput memory _addInput, uint8 _decimals) internal returns (uint256 tokenId) { Pool memory pool = _poolMap[_addInput.poolId]; if (_addInput.margin == 0 || _addInput.margin > _addInput.amount || _addInput.margin.mod(pool.unitSize) != 0) revert E_Margin(); if (IERC20(pool.asset).allowance(_msgSender(), address(this)) < _addInput.margin) revert E_Approve(); if (IERC20(pool.asset).balanceOf(_msgSender()) < _addInput.margin) revert E_Balance(); if (_addInput.multiple < 1 || _addInput.margin.mul(_addInput.multiple) != _addInput.amount) revert E_Multiple(); if (_addInput.multiple > 1 && _addInput.multiple > _getMaxMultiple(pool, _addInput.curPrice, _decimals)) revert E_MultipleLimit(); _addInput.layer = _getLastLayer(_addInput.poolId, _addInput.curPrice, _addInput.amount); LayerData memory layer = _layerDataMap[_addInput.poolId][_addInput.layer]; if (layer.amount >= layer.cap) revert E_LayerCap(); if (layer.cap.sub(layer.amount) < _addInput.margin) { _addInput.margin = _addInput.amount = layer.cap.sub(layer.amount); } else { _addInput.amount = layer.cap.sub(layer.amount) < _addInput.amount ? layer.cap.sub(layer.amount) : _addInput.amount; } IERC20(pool.asset).safeTransferFrom(_msgSender(), address(this), _addInput.margin); uint256 layerAmount = _addTvl(_addInput); uint256 layerRanking = layerAmount.div(pool.unitSize); tokenId = IFRNFT(_FRNFT).mint( _msgSender(), _addInput.poolId, _addInput.layer, _addInput.margin, _addInput.amount, _addInput.curPrice, layerRanking ); emit NewInput( tokenId, _addInput.poolId, _msgSender(), _addInput.layer, _addInput.margin, _addInput.amount, _addInput.curPrice ); }",
        "labels": [
            "SlowMist",
            "Doubler - 20240117",
            "Type: Others",
            "Severity: High"
        ]
    },
    {
        "title": "Excessive Authority Issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - wault.finance(WEXPolyMaster)_en-us.pdf",
        "body": "The owner can set the value of wexPerBlock arbitrarily, which will affect the profit of wexReward, and there is no limit on the value range of wexPerBlock, and there is a issue of excessive authority. https://polygonscan.com/address/0xC8Bd86E5a132Ac0bf10134e270De06A8Ba317BFe#code function setWexPerBlock(uint256 _wexPerBlock) public onlyOwner { require(_wexPerBlock > 0, \"!wexPerBlock-0\"); wexPerBlock = _wexPerBlock; } Owner can add pool, can set the allocPoint of pool, there is a issue of selfish mining. function add( uint256 _allocPoint, IERC20 _lpToken, bool _withUpdate ) public onlyOwner { if (_withUpdate) { massUpdatePools(); } uint256 lastRewardBlock = block.number > startBlock ? block.number : startBlock; totalAllocPoint = totalAllocPoint.add(_allocPoint); poolInfo.push( 6 PoolInfo({ lpToken: _lpToken, allocPoint: _allocPoint, lastRewardBlock: lastRewardBlock, accWexPerShare: 0 }) ); function set( uint256 _pid, uint256 _allocPoint, bool _withUpdate ) public onlyOwner { if (_withUpdate) { massUpdatePools(); } totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add( _allocPoint ); poolInfo[_pid].allocPoint = _allocPoint; }",
        "labels": [
            "SlowMist",
            "wault.finance(WEXPolyMaster)",
            "Type: Others",
            "Severity: Low"
        ]
    },
    {
        "title": "Event log missing",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - earning.farm_en-us.pdf",
        "body": "12 contracts/core/EFLeverVault.sol Modifying important variables in the contract requires corresponding event records. function initAddresses(address[7] memory addr) public onlyOwner{ aave = addr[0]; balancer = addr[1]; balancer_fee = addr[2]; lido = addr[3]; asteth = addr[4]; curve_pool = addr[5]; weth = addr[6]; } contracts/core/EFCRVVault.sol Modifying important variables in the contract requires corresponding event records. function initAddresses(address[11] memory addr) public onlyOwner{ crv = addr[0]; usdc = addr[1]; eth_usdc_router = addr[2]; weth = addr[3]; cvxcrv = addr[4]; eth_crv_router = addr[5]; crv_cvxcrv_router = addr[6]; eth_usdt_router = addr[7]; usdt = addr[8]; oracle = addr[9]; staker = addr[10]; }",
        "labels": [
            "SlowMist",
            "earning.farm",
            "Type: Malicious Event Log Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - earning.farm_en-us.pdf",
        "body": "contracts/core/EFLeverVault.sol The owner's authority is too large. If the private key is lost, the attacker can use the pause function to transfer the funds in the contract through callWithData ,or directly transfer astheth. function callWithData(address payable to, bytes memory data, uint256 amount)public payable onlyOwner{ (bool status, ) = to.call.value(amount)(data); require(status, \"call failed\"); } function delegateCallWithData(address payable to, bytes memory data)public payable onlyOwner{ (bool status, ) = to.delegatecall(data); require(status, \"call failed\"); }",
        "labels": [
            "SlowMist",
            "earning.farm",
            "Type: Authority Control Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Potential Sandwich Attack Risk",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - earning.farm_en-us.pdf",
        "body": "contracts/core/EFCRVVault.sol 14 it will perform the token swap operation through the swapExactTokensForTokens function. But the incoming minAmountOut is 0 , which will not do slippage checking,There is a risk of being attacked by sandwiches. function depositStable(uint256 _amount) public payable nonReentrant{ require(!is_paused, \"paused\"); require(IERC20(usdc).allowance(msg.sender, address(this)) >= _amount, \"CFVault: not enough allowance\"); IERC20(usdc).safeTransferFrom(msg.sender, address(this), _amount); if (IERC20(usdc).allowance(address(this), eth_usdc_router) != 0){ IERC20(usdc).approve(eth_usdc_router, 0); } IERC20(usdc).approve(eth_usdc_router, _amount); uint256 weth_before = IERC20(weth).balanceOf(address(this)); address[] memory t = new address[](2); t[0] = usdc; t[1] = weth; UniswapV3Interface(eth_usdc_router).swapExactTokensForTokens(_amount, 0, t, address(this)); uint256 weth_amount = IERC20(weth).balanceOf(address(this)).safeSub(weth_before); if (IERC20(weth).allowance(address(this), eth_crv_router) != 0){ IERC20(weth).approve(eth_crv_router, 0); } IERC20(weth).approve(eth_crv_router, weth_amount); uint256 tt_before = IERC20(crv).balanceOf(address(this)); CurveInterface256(eth_crv_router).exchange(0, 1, weth_amount, 0); uint256 tt_amount = IERC20(crv).balanceOf(address(this)).safeSub(tt_before); _deposit(_amount, tt_amount); }",
        "labels": [
            "SlowMist",
            "earning.farm",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Potential Sandwich Attack Risk",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - earning.farm_en-us.pdf",
        "body": "contracts/core/EFCRVVault.sol it will perform the token swap operation through the swapExactTokensForTokens function. But the incoming minAmountOut is 0 , which will not do slippage checking,There is a risk of being attacked by sandwiches. function withdraw(uint256 _amount, bool _use_stable) public nonReentrant{ require(!is_paused, \"paused\"); { uint256 total_balance = IERC20(ef_token).balanceOf(msg.sender); require(total_balance >= _amount, \"not enough LP tokens\"); } uint256 target_amount; { //if (IERC20(ef_token).totalSupply() == 0) require(false, \"000\"); uint256 lp_amount = _amount.safeMul(lp_balance).safeDiv(IERC20(ef_token).totalSupply()); uint256 target_before = IERC20(crv).balanceOf(address(this)); _withdraw(lp_amount); target_amount = IERC20(crv).balanceOf(address(this)).safeSub(target_before); } uint256 f = 0; if(withdraw_fee_ratio != 0 && fee_pool != address(0x0)){ f = target_amount.safeMul(withdraw_fee_ratio).safeDiv(ratio_base); target_amount = target_amount.safeSub(f); IERC20(crv).transfer(fee_pool, f); TokenInterfaceERC20(ef_token).destroyTokens(msg.sender, _amount); }else{ TokenInterfaceERC20(ef_token).destroyTokens(msg.sender, _amount); } if (!_use_stable){ IERC20(crv).transfer(msg.sender, target_amount); emit CFFWithdraw(msg.sender, target_amount, target_amount.safeMul(uint256(ChainlinkInterface(oracle).latestAnswer())).safeDiv(1e2 16 0), _amount, f, getVirtualPrice()); } else{ if (IERC20(crv).allowance(address(this), eth_crv_router) != 0){ IERC20(crv).approve(eth_crv_router, 0); } IERC20(crv).approve(eth_crv_router, target_amount); uint256 weth_amount; { uint256 weth_before = IERC20(weth).balanceOf(address(this)); CurveInterface256(eth_crv_router).exchange(1, 0, target_amount, 0); weth_amount = IERC20(weth).balanceOf(address(this)).safeSub(weth_before); } if (IERC20(weth).allowance(address(this), eth_usdc_router) != 0){ IERC20(weth).approve(eth_usdc_router, 0); } IERC20(weth).approve(eth_usdc_router, weth_amount); uint256 usdc_amount; { address[] memory t = new address[](2); t[0] = weth; t[1] = usdc; uint256 usdc_before = IERC20(usdc).balanceOf(address(this)); UniswapV3Interface(eth_usdc_router).swapExactTokensForTokens(weth_amount, 0, t, address(this)); usdc_amount = IERC20(usdc).balanceOf(address(this)).safeSub(usdc_before); } IERC20(usdc).transfer(msg.sender, usdc_amount); emit CFFWithdraw(msg.sender, target_amount, usdc_amount, _amount, f, getVirtualPrice()); } }",
        "labels": [
            "SlowMist",
            "earning.farm",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Redundant code",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - earning.farm_en-us.pdf",
        "body": "contracts/erc20/ERC20Impl.sol onTransferDone function not being called function onTransferDone(address _from, address _to, uint256 _amount) internal { for(uint i = 0; i < transferListeners.length; i++){ TransferEventCallBack t = TransferEventCallBack(transferListeners[i]); t.onTransfer(_from, _to, _amount); } }",
        "labels": [
            "SlowMist",
            "earning.farm",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Redundant code",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - earning.farm_en-us.pdf",
        "body": "contracts/core/EFLeverVault.sol IERC20(weth).balanceOf(address(this)) return result unused. function raiseActualLTV(uint256 lt) public onlyOwner{//take lt = 7500 uint256 e = getDebt(); uint256 st = getCollecteral(); require(e.safeMul(10000) < st.safeMul(mlr), \"no need to raise\"); uint256 x = st.safeMul(mlr).safeSub(e.safeMul(10000)).safeDiv(uint256(10000).safeSub(mlr));//x = 18 (mST-E)/(1-m) uint256 y = st.safeMul(lt).safeDiv(10000).safeSub(e).safeSub(1); if (x > y) {x = y;} IAAVE(aave).borrow(weth, x, 2, 0, address(this)); IWETH(weth).withdraw(IERC20(weth).balanceOf(address(this))); ILido(lido).submit.value(address(this).balance)(address(this)); IERC20(weth).balanceOf(address(this));//SlowMist//return result unused if (IERC20(lido).allowance(address(this), aave) != 0) {IERC20(lido).safeApprove(aave, 0);} IERC20(lido).safeApprove(aave, IERC20(lido).balanceOf(address(this))); IAAVE(aave).deposit(lido, IERC20(lido).balanceOf(address(this)), address(this), 0); emit ActualLTVChanged(e, st, getDebt(), getCollecteral()); }",
        "labels": [
            "SlowMist",
            "earning.farm",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - earning.farm_en-us.pdf",
        "body": "contracts/core/EFLeverVault.sol If the owner permission is lost, the attacker can achieve free recharge by changing the address of the token, thereby taking away the funds in the contract. function initAddresses(address[7] memory addr) public onlyOwner{ aave = addr[0]; balancer = addr[1]; balancer_fee = addr[2]; lido = addr[3]; 19 asteth = addr[4]; curve_pool = addr[5]; weth = addr[6]; emit CFFNewAddress(addr); } contracts/core/EFCRVVault.sol function initAddresses(address[11] memory addr) public onlyOwner{ crv = addr[0]; usdc = addr[1]; eth_usdc_router = addr[2]; weth = addr[3]; cvxcrv = addr[4]; eth_crv_router = addr[5]; crv_cvxcrv_router = addr[6]; eth_usdt_router = addr[7]; usdt = addr[8]; oracle = addr[9]; staker = addr[10]; emit CFFNewAddress(addr); }",
        "labels": [
            "SlowMist",
            "earning.farm",
            "Type: Authority Control Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - earning.farm_en-us.pdf",
        "body": "contracts/core/EFCRVVault.sol 20 delegateCallWithData is an arbitrary external call, if the private key is lost the attacker can unstake and transfer the funds And for users who have previously authorized the current contract, the attacker can transfer funds that are not operated by the user himself by constructing a malicious contract. function delegateCallWithData(address payable to, bytes memory data)public payable onlyOwner{ (bool status, ) = to.delegatecall(data); require(status, \"call failed\"); }",
        "labels": [
            "SlowMist",
            "earning.farm",
            "Type: Authority Control Vulnerability",
            "Severity: Critical"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Bitlayer Bridge.pdf",
        "body": "1.The BitlayerBridge contracts are implemented using the OpenZeppelin upgradeable model, allowing the AdminRole role to perform contract upgrades. However, this design introduces an excessive privilege risk. 2.In the BitlayerBridge contract, the UnlockRole role can call the unlock function to unlock the ETH locked in the contract; the LiquidityRole role can call the removeLiquidityTo function to remove the liquidity of any address. BitlayerBridge.sol#L125-L134,L148-L163 function removeLiquidityTo(address to, uint256 amount) external onlyRole(LiquidityRole) whenNotPaused { ``` } function unlock(string memory _txHash, address to, uint256 amount) external onlyRole(UnlockRole) whenNotPaused { ``` } } 3.In the BitlayerBridge contract, AdminRole role can set important parameters of the contract. BitlayerBridge.sol function setFeeAddress function setLockFee function setMinLockAmount function setMaxLockAmount",
        "labels": [
            "SlowMist",
            "Bitlayer Bridge",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Missing zero address check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Bitlayer Bridge.pdf",
        "body": "In the BitlayerBridge contract, the zero address check is missing in the initialize function and unlock function. BitlayerBridge.sol#L36-L75,L148-L163 function initialize(  ) public initializer {  feeAddress = _feeAddress;  } function unlock(string memory _txHash, address to, uint256 amount) external onlyRole(UnlockRole) whenNotPaused {  (bool success, bytes memory returndata) = payable(to).call{value: amount} (\"\");  }",
        "labels": [
            "SlowMist",
            "Bitlayer Bridge",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Return value not checked",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Bitlayer Bridge.pdf",
        "body": "In the BitlayerBridge contract, the return value is not checked when the initialize function calls the _grantRole function. BitlayerBridge.sol#L36-L75 function initialize( ``` ) public initializer { _grantRole(AdminRole, admin); ``` }",
        "labels": [
            "SlowMist",
            "Bitlayer Bridge",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Parameter Validation Missing in unlock Function",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Bitlayer Bridge.pdf",
        "body": "In the BitlayerBridge contract, the unlock function does not verify the validity of the parameters passed in. The UnlockRole role can enter any _txHash (not recorded by txUnlocked mapping) and amount to unlock the ETH in the contract and transfer it to the specied address. BitlayerBridge.sol#L148-L163 function unlock(string memory _txHash, address to, uint256 amount) external onlyRole(UnlockRole) whenNotPaused { bytes32 txHash = keccak256(abi.encode(_txHash)); require(!txUnlocked[txHash], \"txHash already unlocked\"); txUnlocked[txHash] = true; (bool success, bytes memory returndata) = payable(to).call{value: amount} (\"\"); require(success, string(returndata)); totalUnlocked += amount; emit NativeUnlocked(_txHash, to, amount); }",
        "labels": [
            "SlowMist",
            "Bitlayer Bridge",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Min lock amount not checked against max",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Bitlayer Bridge.pdf",
        "body": "In the BitlayerBridge contract, whether the variable minLockAmount is less than the variable maxLockAmount is not checked in the initialize function, setMinLockAmount function, and setMaxLockAmount function. If the variable minLockAmount is greater than the variable maxLockAmount , the lock function cannot be used. BitlayerBridge.sol#L41-L85,L113-L118,L120-L125 function initialize( ``` ) public initializer { ``` minLockAmount = _minLockAmount; maxLockAmount = _maxLockAmount; } function setMinLockAmount(uint256 min) external onlyRole(AdminRole) { uint256 oldMin = minLockAmount; minLockAmount = min; emit MinLockAmountSet(oldMin, min); } function setMaxLockAmount(uint256 max) external onlyRole(AdminRole) { uint256 oldMax = maxLockAmount; maxLockAmount = max; emit MaxLockAmountSet(oldMax, max); }",
        "labels": [
            "SlowMist",
            "Bitlayer Bridge",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Reentrancy risks",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DappOS Contracts Core.pdf",
        "body": "In the PayDB contract, the executeDstOrderETH , executeDstOrderETH , tryExecuteDstOrderETH , cancelOrderETH , _executeIsolateOrder , and _createSrcOrder functions do not add anti-reentrancy locks, and there is a risk of reentrancy attacks when calling the safeTransferETH function. contracts/core/PayDB.sol#L75-L153,L162-L249,L287-L335,L337-L383,L385-L475 function executeDstOrderETH( address orderOwner, address receiver, address wallet, ExePayOrderParam[] calldata eparams, IVWManager.VWExecuteParam calldata vwExeParam ) external payable override{ ```` if (eparams[i].tokenOut == address(0)) { TransferHelper.safeTransferETH( _realReceiver, eparams[i].amountOut ); totalETH += eparams[i].amountOut; } else { TransferHelper.safeTransferFrom( eparams[i].tokenOut, msg.sender, _realReceiver, eparams[i].amountOut ); } ```` } function tryExecuteDstOrderETH( address orderOwner, address receiver, address wallet, ExePayOrderParam[] calldata eparams, IVWManager.VWExecuteParam calldata vwExeParam ) external payable override { ```` if (eparams[i].tokenOut == address(0)) { TransferHelper.safeTransferETH( _realReceiver, eparams[i].amountOut ); totalETH += eparams[i].amountOut; } else { TransferHelper.safeTransferFrom( eparams[i].tokenOut, msg.sender, _realReceiver, eparams[i].amountOut ); } ```` } function cancelOrderETH( address sender, address receiver, CreatePayOrderParam[] calldata cparams, bytes32[] calldata workFlowHashs ) external payable override { ```` require(msg.value == totalETH,\"E18\"); if(totalETH > 0){ TransferHelper.safeTransferETH(sender, msg.value); } ```` } function _executeIsolateOrder( address receiver, address wallet, ExePayOrderParam[] calldata eparams, IVWManager.VWExecuteParam calldata vwExeParam ) internal { ```` if (eparams[i].tokenOut == address(0)) { TransferHelper.safeTransferETH( receiver, eparams[i].amountOut ); totalETH += eparams[i].amountOut; } else { TransferHelper.safeTransferFrom( eparams[i].tokenOut, msg.sender, receiver, eparams[i].amountOut ); } ```` } function _createSrcOrder( address _orderOwner, address wallet, address receiver, CreatePayOrderParam[] calldata cparams, VwOrderDetail calldata vwDetail, CallParam calldata callParam ) internal { ```` if (cparams[i].tokenIn == address(0)) { // Transfer ETH to node TransferHelper.safeTransferETH( cparams[i].node, cparams[i].amountIn ); totalEth += cparams[i].amountIn; } else { // Transfer ERC20 to node TransferHelper.safeTransferFrom( cparams[i].tokenIn, msg.sender, cparams[i].node, cparams[i].amountIn ); } ```` }",
        "labels": [
            "SlowMist",
            "DappOS Contracts Core",
            "Type: Reentrancy Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Unauthorized information status modication",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DappOS Contracts Core.pdf",
        "body": "In the storeInfo function of the VWManager contract, we found the following issues 1. Any user can set the willDelete parameter of information stored by other users to false, thereby deleting infoSender[infoHash] so that it cannot be deleted. 2. Key Parameter Settings Unrecorded Events. 3. The function may be subject to MEV attacks, causing the user to store infoSender[infoHash] = msg.sender as the attacker's address when storing information. contracts/core/vwmanager/VWManager.sol#L295-L311 function storeInfo( bytes calldata info, bool willDelete ) external { if(info.length > 0){ bytes32 infoHash = keccak256(info); if(eip1271Info[infoHash].length == 0){ eip1271Info[infoHash] = info; emit InfoStored(infoHash, info); if(willDelete){ infoSender[infoHash] = msg.sender; } } else if(!willDelete) { delete infoSender[infoHash]; } } }",
        "labels": [
            "SlowMist",
            "DappOS Contracts Core",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Unveried feeReceiver parameter",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DappOS Contracts Core.pdf",
        "body": "The cancelTx , changeOwner , approveResetter , and resetOwner functions of the VWManagerService contract, the feeReceiver parameter is not veried. It may be subject to MEV attack risk. The attacker replaces the feeReceiver parameters, causing losses. contracts/core/vwmanager/VWManagerService.sol#L53-L92,L123-L161,L177-L217,L227-L256 function cancelTx( uint256 code, address wallet, uint256 codeToCancel, FeeParam calldata fParam, bytes calldata signature ) external {  bytes32 dataHash = keccak256( abi.encode( CANCEL_TYPEHASH, code, codeToCancel, fParam.gasToken, fParam.gasTokenPrice, fParam.priorityFee, fParam.gasLimit ) ); result[walletOwner[wallet]][codeToCancel] = uint256(CodeStatus.CANCELED); result[walletOwner[wallet]][code] = uint256(CodeStatus.SUCCEED); emit TxCanceled(codeToCancel); verifyOperation( walletOwner[wallet], domainSeparator[srcChain], dataHash, signature, CANCEL_TYPEHASH ); _walletPayFee(wallet, preGas, fParam); } function changeOwner( uint256 code, address wallet, address newOwner, FeeParam calldata fParam, bytes calldata signature ) external {  bytes32 dataHash = keccak256( abi.encode( CHANGE_OWNER_TX_TYPEHASH, code, newOwner, fParam.gasToken, fParam.gasTokenPrice, fParam.priorityFee, fParam.gasLimit ) ); address previousOwner = _resetOwner(wallet, newOwner); result[walletOwner[wallet]][code] = uint256(CodeStatus.SUCCEED); verifyOperation( previousOwner, domainSeparator[srcChain], dataHash, signature, CHANGE_OWNER_TX_TYPEHASH ); _walletPayFee(wallet, preGas, fParam); } function approveResetter( uint256 code, address wallet, address resetter, bool approved, FeeParam calldata fParam, bytes calldata signature ) external returns (bytes32 dataHash) {  dataHash = keccak256( abi.encode( RESETTER_APPROVE_TYPEHASH, code, resetter, approved, fParam.gasToken, fParam.gasTokenPrice, fParam.priorityFee, fParam.gasLimit ) ); approvedResetter[wallet] = approved ? resetter : address(0); emit ResetterChanged(approvedResetter[wallet]); result[walletOwner[wallet]][code] = uint256(CodeStatus.SUCCEED); verifyOperation( walletOwner[wallet], domainSeparator[srcChain], dataHash, signature, RESETTER_APPROVE_TYPEHASH ); _walletPayFee(wallet, preGas, fParam); } function resetOwner( uint256 code, address wallet, address newOwner, FeeParam calldata fParam, bytes calldata data ) external nonReentrant{  require ( IVWResetter(approvedResetter[wallet]).verify( wallet, newOwner, data, fParam.gasToken, fParam.gasTokenPrice, fParam.priorityFee, fParam.gasLimit ), \"E5\"); _resetOwner(wallet, newOwner); result[walletOwner[wallet]][code] = uint256(CodeStatus.SUCCEED); _walletPayFee(wallet, preGas, fParam); }",
        "labels": [
            "SlowMist",
            "DappOS Contracts Core",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Reentrancy risks",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DappOS Contracts Core.pdf",
        "body": "In the PayLock contract, the deposit function does not add an anti-reentrancy lock, and there is a risk of reentrancy attacks when calling the safeTransferFrom function. contracts/core/PayLock.sol#L73-L78 function deposit(address token, uint amount, address node) external { uint256 beforeTransfer = IERC20(token).balanceOf(address(this)); TransferHelper.safeTransferFrom(token, msg.sender, address(this), amount); uint256 afterTransfer = IERC20(token).balanceOf(address(this)); _deposit(token, afterTransfer - beforeTransfer, node); }",
        "labels": [
            "SlowMist",
            "DappOS Contracts Core",
            "Type: Reentrancy Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DappOS Contracts Core.pdf",
        "body": "Owner accounts can operate the key functions. PayLock punish PayLock configToken PayLock configWithdrawPendingTime VWManager configFee VWManager VWManager requestConfigSrcChain configSrcChain",
        "labels": [
            "SlowMist",
            "DappOS Contracts Core",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Unveried manager and feeReceiver parameter",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DappOS Contracts Core.pdf",
        "body": "In the verifyProof function of the VWManager contract, only the 8 parameters in vweParam were veried, and the manager and feeReceiver parameters were not veried. contracts/core/vwmanager/VWManager.sol#L113-L145 function verifyProof(uint resCode, address wallet, VWExecuteParam calldata vweParam) internal { address vwOwner = walletOwner[wallet]; result[vwOwner][vweParam.code] = resCode; (uint256 dstChainId, uint256 srcChain, uint256 expTime) = VWCode.chainidsAndExpTime(vweParam.code); require(dstChainId == block.chainid, 'E3'); require(block.timestamp <= expTime, 'E6'); require(domainSeparator[srcChain] != bytes32(0), 'E31'); bytes32 rootHash = keccak256( abi.encode( APPROVE_SERVICE_TX_TYPEHASH, vweParam.code, keccak256(vweParam.data), vweParam.service, vweParam.gasToken, vweParam.gasTokenPrice, vweParam.priorityFee, vweParam.gasLimit, vweParam.isGateway ) ); if (vweParam.proof.length > 0) { rootHash = MerkleProof.processProof(vweParam.proof, rootHash); rootHash = keccak256(abi.encode(APPROVE_SERVICE_PROOF_TX_TYPEHASH, rootHash)); } // srcChain is the chain where user sign the rootHash if (Address.isContract(vwOwner)) { require(IWalletOwner(vwOwner).verifyVWParam(rootHash, domainSeparator[srcChain], vweParam), 'E1'); } else { SignLibrary.verify(vwOwner, domainSeparator[srcChain], rootHash, vweParam.serviceSignature); } emit TxExecuted(wallet, vwOwner, vweParam.code, rootHash, resCode); }",
        "labels": [
            "SlowMist",
            "DappOS Contracts Core",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Redundant code",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DappOS Contracts Core.pdf",
        "body": "The functions implemented in library OrderId are the same as those in library VWCode. contracts/libraries/OrderId.sol#L7-L17 function genCode( uint128 nonce, uint32 time, uint32 srcChainId, uint32 dstChainId, uint16 oType, uint16 flag ) internal pure returns (uint code){ code = (uint(nonce) << 128) + (uint(time) << 96) + (uint(srcChainId) << 64) + (uint(dstChainId) << 32) + (uint(oType) << 16) + uint(flag); } function chainidsAndExpTime(uint code) internal pure returns (uint dstChainId, uint srcChainId, uint time){ dstChainId = (code >> 32) & ((1 << 32) - 1); srcChainId = (code >> 64) & ((1 << 32) - 1); time = (code >> 96) & ((1 << 32) - 1); }",
        "labels": [
            "SlowMist",
            "DappOS Contracts Core",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Reentrancy risks",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DappOS Contracts Core.pdf",
        "body": "In the PayLock contract punish function, the punishes mapping is not used correctly, resulting in the risk of reentrancy. contracts/governance/PayLock.sol#L131-L159 function punish( uint orderId, address node, address to, address[] calldata tokens, uint[] calldata amounts ) external onlyOwner { require(tokens.length > 0 && tokens.length == amounts.length, \"Invalid length\"); for (uint i = 0; i < tokens.length; i++) { require(validTokens[tokens[i]], \"INVALID_TOKEN\"); TokenBalance storage bal = nodeTokenBalance[node][tokens[i]]; uint256 realAmount = amounts[i]; if (amounts[i] > bal.numOnWithdraw) { if (bal.numTotal <= amounts[i].sub(uint(bal.numOnWithdraw))) { realAmount = uint(bal.numTotal + bal.numOnWithdraw); (bal.numTotal, bal.numOnWithdraw) = (0, 0); } else { bal.numTotal -= (amounts[i] - uint(bal.numOnWithdraw)).toUint128(); bal.numOnWithdraw = 0; } } else { bal.numOnWithdraw = (uint(bal.numOnWithdraw).sub(amounts[i])).toUint128(); } TransferHelper.safeTransfer2(tokens[i], to, realAmount); } punishes[node]++; emit NodePunished(orderId, amounts, tokens, node, to); }",
        "labels": [
            "SlowMist",
            "DappOS Contracts Core",
            "Type: Reentrancy Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Insucient WithdrawPendingTime error",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DappOS Contracts Core.pdf",
        "body": "In the PayLock contract congWithdrawPendingTime function, the withdrawPendingTime parameter should be set to greater than or equal to 7 days. Since congWithdrawPendingTime is associated with the order's term, congWithdrawPendingTime should be greater than the order's term. contracts/governance/PayLock.sol#L168-L172 function configWithdrawPendingTime(uint period) external onlyOwner { require(period <= 7 days, \"E27\"); withdrawPendingTime = period; emit WithdrawPendingTime(period); }",
        "labels": [
            "SlowMist",
            "DappOS Contracts Core",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Unveried Node Mortgage Requirement",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DappOS Contracts Core.pdf",
        "body": "In the PayDB contract, when the user creates an order through the createSrcOrder function or createSrcOrderETH function, it is not veried whether the node's mortgage assets meet the mortgage requirements required for the created order.",
        "labels": [
            "SlowMist",
            "DappOS Contracts Core",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Service nodes are at risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DappOS Contracts Core.pdf",
        "body": "In the PayDB contract, when the user creates an order through the createSrcOrder function or createSrcOrderETH function, he transfer assets to the cparams[i].node , and these nodes are at risk of rug-pull ,or private key leak.",
        "labels": [
            "SlowMist",
            "DappOS Contracts Core",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Redundant collectEndTime check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase3_en-us.pdf",
        "body": "In the CongurableRightsPool contract, users can redeem underlying assets through the exitPool function. When the pool is a closed ETF, it will check isCompletedCollect and collectEndTime to decide whether to perform _claimManagerFee operation. But when isCompletedCollect is true, the collectEndTime check will be performed in snapshotEndAssets, and when isCompletedCollect is false, the collectEndTime check will be performed in exitPoolHandleB. Hence the collectEndTime check before the _claimManagerFee operation is redundant. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase3",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Redundant closureEndTime check on exitPool",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase3_en-us.pdf",
        "body": "In the CongurableRightsPool contract, users can redeem underlying assets through the exitPool function. When the pool is a closed ETF and isCloseEtfCollectEndWithFailure is false, it will check that the current time must be greater than closureEndTime + 5 minutes before allowing the user to exit. However, it should be noted that the snapshotEndAssets operation will be performed before this. The snapshotEndAssets function will also check whether the current time is greater than closureEndTime + 5 minutes . Only the admin and owner can execute snapshotEndAssets within 5 minutes after the closure period ends. Otherwise, the transaction will be reverted. Therefore, the closureEndTime check in the exitPool function is redundant. When snapshotEndAssets cannot be performed, the entire transaction will be reverted, and subsequent closureEndTime checks will not be performed. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase3",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Redundant performance fee calculation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase3_en-us.pdf",
        "body": "In the exitPool function of the CongurableRightsPool contract, redeemAndPerformanceFeeReceived, nalAmountOut and redeemFeeReceived are calculated through exitPoolHandleA. However, since the performance fee will be calculated uniformly in the snapshotEndAssets operation, there is no need to process the performance fee in the exitPool function. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase3",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "The time allowed for snapshots is too short",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase3_en-us.pdf",
        "body": "In the CongurableRightsPool contract when the closed ETF completes collect and the collection period has ended, the current total value of the ETF can be recorded through the snapshotBeginAssets function. However, users can only call the snapshotBeginAssets function within 15 minutes after the end of the collection period. If there is congestion on the chain, it may not be possible to call the snapshot in time within 15 minutes. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase3",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Duplicate decimal processing issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase3_en-us.pdf",
        "body": "In the DesynChainlinkOracle contract, the getPrice function is used to obtain the corresponding token price from prices, getChainlinkPrice, and getUniswapPrice, and perform decimal processing. However, decimal has been processed in getChainlinkPrice and getUniswapPrice, and theoretically, the returned decimal will be 1e18. Therefore, processing decimals through decimalDelta will cause decimals to be enlarged. Note that the amountIn passed in for the consult in the getUniswapPrice function is 1e18, which needs to be ensured that the token decimal in twapOracle matches it in practice ",
        "labels": [
            "SlowMist",
            "DeSyn Phase3",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Decimal processing issue in AllPrice calculation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase3_en-us.pdf",
        "body": "In the DesynChainlinkOracle contract, the getAllPrice function is used to calculate the total value of the specied amount of tokens. It is calculated by badd(fundAll, bmul(getPrice(t), tokenAmountOut)) , theoretically the decimal returned by getPrice is 1e18, and the decimal of tokenAmountOut is consistent with the decimal of the token itself. Therefore, multiplying these two values will result in a very large decimal in the nal result. The getNormalizedWeight function is also aected by this, but this is not harmful to normal business. Note: ",
        "labels": [
            "SlowMist",
            "DeSyn Phase3",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Redundant code issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase3_en-us.pdf",
        "body": "In the SmartPoolManager library, the exitPoolHandle function has been deprecated since closed ETF prots are calculated in snapshotEndAssets. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase3",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Token list conict in recordTokenInfo",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase3_en-us.pdf",
        "body": "When the user performs createPool and joinPool, if the Pool is a closed ETF and the current time is within the collection period, the KOL invitation amount will be recorded through UserVault's recordTokenInfo interface. But unfortunately, the tokens in the Pool can be Bind/unBind at any time, which will cause the list of tokens supported by the Pool to change. If the recordTokenInfo operation is performed when the Pool token list changes, the amount recorded by variables such as poolInviteTotal, kolTotalAmountList, and kolUserInfo may be disturbed. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase3",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "couldManagerClaim not checked when managerClaim",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase3_en-us.pdf",
        "body": "In the UserVault contract, the Manager role can claim management fees through the managerClaim function, but it does not check whether the couldManagerClaim parameter is true. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase3",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Some redundant invoke functions",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase3_en-us.pdf",
        "body": "In the Invoke library, the strictInvokeTransfer, invokeUnwrapWETH, invokeWrapWETH, and invokeMint functions are not used. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase3",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of ETF falsication",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase3_en-us.pdf",
        "body": "In the RebalanceAdapter contract, the Manager role can adjust the position of the pool through the rebalance function. But the address of the ETF is obtained from the rebalanceInfo passed in by the user. If a malicious user passes in a fake ETF, the check in the onlyManager decorator will be bypassed, and the _verifyWhiteToken check of token1 and the isCompletedCollect and collectEndTime checks will be useless. Malicious users can steal bPool funds through _makeSwap and bind malicious tokens. The approve function also has this risk, but it doesn't break the protocol too much ",
        "labels": [
            "SlowMist",
            "DeSyn Phase3",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Risk of the Manager role potentially disrupting the protocol",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase3_en-us.pdf",
        "body": "In the RebalanceAdapter contract, the Manager role can adjust the position of the ETF through the rebalance function. It will use the _makeSwap function to call Uniswap, 1inch and other DEXs for token swaps to adjust token positions. But unfortunately, the swap path of the token is not checked during the token swap process, which will cause the Manager role to pass in a carefully constructed malicious swap path to steal the middle token0 of the ETF. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase3",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Double slippage check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase3_en-us.pdf",
        "body": "In the RebalanceAdapter contract, the Manager role can adjust the position of the ETF through the rebalance function. It will use the _makeSwap function to call Uniswap, 1inch and other DEXs for token swaps to adjust token positions. During the swap process, the slippage will be checked by passing minReturn to the external DEXs, but the implementation of the slippage check of the external DEXs is uncontrollable. If the slippage protection of the external DEXs fails, it will aect the funds of users in the protocol. (1inch users encountered invalid slippage check before) ",
        "labels": [
            "SlowMist",
            "DeSyn Phase3",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Does not follow the Checks-Eects-Interactions specication",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase3_en-us.pdf",
        "body": "In the RebalanceAdapter contract, the _makeSwap function is used for token swap. When the swap type is not UNISWAPV3 and UNISWAPV2, the parameters passed in by the user will be checked through _validateData . However, the execute operation is performed rst, and the _validateData operation is performed after the token exchange is completed. This is not in line with the follow the Checks-Effects-Interactions principle. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase3",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Perform strict parameter checking",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase3_en-us.pdf",
        "body": "In the RebalanceAdapter contract, the _validateData function is used to check the exchange parameters, but it only parses the recipient and amountIn for checking, but does not check whether other key parameters such as srcToken, dstToken, clipperExchange, makerAsset, takerAsset are in line with expectations. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase3",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Redundant aggregator parameter",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase3_en-us.pdf",
        "body": "In the RebalanceAdapter contract, the _validateData function is used to check the conversion parameters, but the aggregator parameter it receives is not used. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase3",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Incorrect approval operation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase3_en-us.pdf",
        "body": "In the RebalanceAdapter contract, the Manager role can adjust the position of the ETF through the rebalance function. If token1 has not been bound in bPool, it will be approved rst. However, the subsidy of this contract was wrongly approved to bPool, which will cause bPool to be unable to transfer tokens from CRP in the future. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase3",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase3_en-us.pdf",
        "body": "There is an execute function in the CRP and bPool contracts so that the Manager can manage the ETF. In bFactory, the Blabs role can arbitrarily register modules to gain control over CRP. The registered modules can use the execute function in CRP to call the execute function in bPool to perform any operations. This would pose a huge risk to users' funds. And the Manager can approve the tokens in the bPool through the approve function of the RebalanceAdapter contract, which will also bring huge risks to the user's funds. The above problems lead to the risk of excessive permissions of the Blabs role and the Manager role. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase3",
            "Type: Authority Control Vulnerability Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Enforce strict permission controls",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase3_en-us.pdf",
        "body": "In the LiquidityPool contract, any user can call the joinPool, exitPool, and gulp functions to add/remove liquidity/record token balances, which will make it impossible to charge various fees to users in CRP. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase3",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Function visibility issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Alpaca Finance Oracle_en-us.pdf",
        "body": "In the OracleMedianizer contract, the user can get the price of the pair token through the getPrice function. The getPrice function will call the _getPrice function to get the price, but the visibility of the _getPrice function is public. ",
        "labels": [
            "SlowMist",
            "Alpaca Finance Oracle",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "The Token Pair Check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Alpaca Finance Oracle_en-us.pdf",
        "body": "There is a _setPriceFeed function in the ChainLinkPriceOracle contract, which is used to set the source of the token pair. In the function, check whether priceFeeds[token1][token0] already exists, but then set the source for priceFeeds[token0][token1] . ",
        "labels": [
            "SlowMist",
            "Alpaca Finance Oracle",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Redundant parameter issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ENF_WBTC_Borrow_ETH_en-us.pdf",
        "body": "In the PriceOracle contract, the getAssetPrice function is used to obtain the relative price of WBTC and ETH. But the _asset parameter it receives is not used. ",
        "labels": [
            "SlowMist",
            "ENF_WBTC_Borrow_ETH",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Token swap defect when withdrawing",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ENF_WBTC_Borrow_ETH_en-us.pdf",
        "body": "In the WBTCBorrowETH contract, the withdraw function is used to withdraw WBTC tokens. When the repayable amount of the contract is less than the required loan amount (ethWithdrawn < ethDebt), the contract will withdraw wbtcToSwap amount of WBTC from AAVE to swap it into WETH, and use the wbtcAmt value as the amountInMaximum in the Swap exchange. However, since the wbtcAmt value is indirectly calculated through the ChainLink price, there may be a deviation from the price in Uniswap v3, so using the wbtcAmt value as the amountInMaximum parameter may not be successfully swapped due to the price deviation. ",
        "labels": [
            "SlowMist",
            "ENF_WBTC_Borrow_ETH",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Swap balance has not been processed",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ENF_WBTC_Borrow_ETH_en-us.pdf",
        "body": "In the _withdraw function of the WBTCBorrowETH contract, when ethWithdrawn < ethDebt , the contract will withdraw WBTC tokens from AAVE and swap them into ETH to repay the loan. If the amount of ETH is greater than the amount of debt required to be repaid (ethBal > ethDebt), the contract will swap the excess part into WBTC, but these excess WBTC tokens have not been sent to the user, nor have they been re-staked into AAVE. It was left in the SS contract. When the next user deposit, it will be billed as part of the user's deposit. And when ethWithdrawn >= ethDebt , the contract will convert the excess ETH to WBTC, but the contract has not yet processed these WBTC. ",
        "labels": [
            "SlowMist",
            "ENF_WBTC_Borrow_ETH",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Defects in LTV operation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ENF_WBTC_Borrow_ETH_en-us.pdf",
        "body": "In the reduceLTV operation, the contract will rst extract x amount of WBTC from AAVE and exchange it into WETH 12 for repayment. In this operation, although the liabilities of the contract are reduced, the amount of collateral of the contract is also reduced. At the same time, due to the impact of the slippage of the swap operation, the reduceLTV operation may not be able to eectively control the risk as expected. ",
        "labels": [
            "SlowMist",
            "ENF_WBTC_Borrow_ETH",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Reduced availability for LTV operations 13",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ENF_WBTC_Borrow_ETH_en-us.pdf",
        "body": "In the protocol, the raiseLTV and reduceLTV functions are important means to improve capital utilization and prevent bad debts, but in these two functions, the token exchange is performed through the _swapExactInput function. The _swapExactInput function does not check for slippage, which will reduce the availability of raiseLTV and reduceLTV for the protocol. ",
        "labels": [
            "SlowMist",
            "ENF_WBTC_Borrow_ETH",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "The withdraw function will not work when the market is extreme",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ENF_WBTC_Borrow_ETH_en-us.pdf",
        "body": "In the protocol, when extreme market conditions occur (such as a sharp unilateral drop of BTC) and the owner has no time to adjust the protocol LTV through the reduceLTV function, the protocols WBTC position will be liquidated. If 14 the protocol's liabilities are fully liquidated (getDebt will become 0), ethDebt will be 0. This will cause the _withdraw function to fail to perform the repay operation, and the emergencyWithdraw operation will also not work. Users' funds will be locked in the protocol. In the repay operation of AAVE, if the repayment amount is 0, it will fail the validateRepay check.",
        "labels": [
            "SlowMist",
            "ENF_WBTC_Borrow_ETH",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Risk of multiple leverages in unilateral market conditions",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ENF_WBTC_Borrow_ETH_en-us.pdf",
        "body": "The protocol deposits WBTC tokens deposited by users into AAVE and lends ETH, and then deposits the loaned ETH into the ENF_ETH_Leverage protocol. The ENF_ETH_Leverage protocol also creates positions in AAVE via ETH/stETH. This makes the ENF_WBTC_Borrow_ETH protocol have multiple leverages, which means it is extremely sensitive to market stability. Once the agreement does not manage LTV properly, it will lead to risks such as bad debts of the agreement. ",
        "labels": [
            "SlowMist",
            "ENF_WBTC_Borrow_ETH",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of excessive authority 16",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ENF_WBTC_Borrow_ETH_en-us.pdf",
        "body": "In the protocol, the owner role has many permissions, such as the owner can set sensitive parameters, can suspend the contract, can make emergency withdrawals, etc. It is obviously inappropriate to give all the permissions of the protocol to the owner, which will greatly increase the single point of risk.",
        "labels": [
            "SlowMist",
            "ENF_WBTC_Borrow_ETH",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Swap Path Issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Oddz Finance_en-us.pdf",
        "body": "In the PancakeSwapForUnderlyingAsset contract, the owner can swap fromToken to toToken through the 11 swapTokensForUA function. The path set is [fromToken, toToken] . If fromToken and toToken in PancakeSwap do not have a directly related token pair, then using this path will not be able to successfully swap. contracts/Integrations/Dex/PancakeSwap/PancakeSwapForUnderlyingAsset.sol#L29-L44 function swapTokensForUA( address _fromToken, address _toToken, address _account, uint256 _amountIn, uint256 _amountOutMin, uint256 _deadline ) public override onlyOwner returns (uint256[] memory result) { address[] memory path = new address[](2); path[0] = _fromToken; path[1] = _toToken; ERC20(_fromToken).safeApprove(address(pancakeSwap), _amountIn); result = pancakeSwap.swapExactTokensForTokens(_amountIn, _amountOutMin, path, address(this), _deadline); // converting address to address payable ERC20(address(uint160(_toToken))).safeTransfer(_account, result[1]); }",
        "labels": [
            "SlowMist",
            "Oddz Finance",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Missing event records",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Oddz Finance_en-us.pdf",
        "body": "12 In the ChainlinkIVOracle contract, the owner can set allowedPeriods, minVolatilityBound, maxVolatilityBound and other parameters at will, but no event recording is performed. contracts/Integrations/VolatilityOracle/Chainlink/ChainlinkIVOracle.sol function addAllowedPeriods(uint8 _ivAgg) public onlyOwner(msg.sender) { allowedPeriods[_ivAgg] = true; } function setMinVolatilityBound(uint256 _minVolatility) public onlyOwner(msg.sender) { minVolatilityBound = _minVolatility; } function setMaxVolatilityBound(uint256 _maxVolatility) public onlyOwner(msg.sender) { maxVolatilityBound = _maxVolatility; } function setDelay(uint256 _delay) public onlyOwner(msg.sender) { delayInSeconds = _delay; } function setVolatilityPrecision(uint8 _precision) public onlyOwner(msg.sender) { volatilityPrecision = _precision; }",
        "labels": [
            "SlowMist",
            "Oddz Finance",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "The deationary token docking issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Oddz Finance_en-us.pdf",
        "body": "13 Users can transfer the staking token into the staking contract through the deposit function. Under normal circumstances, the number of staking tokens transferred by the user is the same as the _amount parameter passed in. But if the staking token is a deationary token, the number of tokens transferred by the user may be dierent from the number of tokens actually received in the contract. contracts/Staking/OddzStakingManager.sol, OddzTokenStaking.sol, OUsdTokenStaking function stake(IERC20 _token, uint256 _amount) external override validToken(_token) { require(_amount > 0, \"Staking: invalid amount\"); tokens[_token]._stakingContract.stake(msg.sender, _amount); emit Stake(msg.sender, address(_token), _amount); } function stake(address _staker, uint256 _amount) external override onlyOwner { _stake(_staker, _amount); _mint(_staker, _amount); IERC20(token).safeTransferFrom(_staker, address(this), _amount); }",
        "labels": [
            "SlowMist",
            "Oddz Finance",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Token active status change issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Oddz Finance_en-us.pdf",
        "body": "In the OddzStakingManager contract, the owner can set the active state of the token to true through the activateToken function, and the timelock contract can set the active state to false through the deactivateToken 14 function. But after the state change, the txnFeeReward, settlementFeeReward, and allotedReward parameters of each valid token did not change accordingly, so the totalTxnFee, totalSettlementFee, and totalAllotedFee parameters are not equal to 100. contracts/Staking/OddzStakingManager.sol function deactivateToken(IERC20 _token) external onlyTimeLocker(msg.sender) validToken(_token) { tokens[_token]._active = false; emit TokenDeactivate(address(_token)); } function activateToken(IERC20 _token) external onlyOwner(msg.sender) inactiveToken(_token) { tokens[_token]._active = true; emit TokenActivate(address(_token)); }",
        "labels": [
            "SlowMist",
            "Oddz Finance",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Redundant code",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Oddz Finance_en-us.pdf",
        "body": "There is _transferRewards function in the OddzStakingManager contract, which checks whether the staker's collateral time is greater than rewardsLockupDuration, while the actual _transferRewards function is only called by the withdraw function and the claimRewards function. But in both withdraw and claimRewards functions, there is a check to see if the staker's collateral time is greater than 15 rewardsLockupDuration. So the _transferRewards function does not need to check again if the staker's collateral time is greater than the rewardsLockupDuration. contracts/Staking/OddzStakingManager.sol function _transferRewards( address _staker, IERC20 _token, uint256 _date ) private returns (uint256 reward) { if (_date - tokens[_token]._stakingContract.getLastStakedAt(_staker) >= tokens[_token]._rewardsLockupDuration) { reward = tokens[_token]._stakingContract.withdrawRewards(_staker); oddzToken.safeTransfer(_staker, reward); emit TransferReward(_staker, address(_token), reward); } }",
        "labels": [
            "SlowMist",
            "Oddz Finance",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Unsafe External Call",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Oddz Finance_en-us.pdf",
        "body": "_pool is entered by the user. When the user enters a malicious contract address and returns the malicious premium through the malicious contract, the tokens in the OddzLiquidityPoolManager contract can be transferred to a malicious address. 16 contracts/Pool/OddzLiquidityPoolManager.sol#L300 function withdrawProfits(IOddzLiquidityPool _pool) external { uint256 premium = _pool.collectPremium(msg.sender, premiumLockupDuration); require(premium > 0, \"LP Error: No premium allocated\"); token.safeTransfer(msg.sender, premium); } The getSortedEligiblePools function does not check the input _liquidityParams and does not ensure that allPools is in the whitelist. When other functions depend on the data of getSortedEligiblePools, the same issues may occur. contracts/Pool/OddzLiquidityPoolManager.sol#L341 function getSortedEligiblePools(LiquidityParams memory _liquidityParams) public view returns (address[] memory pools, uint256[] memory poolBalance) { // if _expiration is 86401 i.e. 1 day 1 second, then max 1 day expiration pool will not be eligible IOddzLiquidityPool[] memory allPools = poolMapper[ keccak256( abi.encode( _liquidityParams._pair, _liquidityParams._type, _liquidityParams._model, periodMapper[getActiveDayTimestamp(_liquidityParams._expiration) / 1 days] ) ) ]; uint256 count = 0; for (uint8 i = 0; i < allPools.length; i++) { if (allPools[i].availableBalance() > 0) { count++; } } poolBalance = new uint256[](count); pools = new address[](count); uint256 j = 0; 17 uint256 balance = 0; for (uint256 i = 0; i < allPools.length; i++) { if (allPools[i].availableBalance() > 0) { pools[j] = address(allPools[i]); poolBalance[j] = allPools[i].availableBalance(); balance += poolBalance[j]; j++; } } (poolBalance, pools) = _sort(poolBalance, pools); require(balance > _liquidityParams._amount, \"LP Error: Amount is too large\"); }",
        "labels": [
            "SlowMist",
            "Oddz Finance",
            "Type: Unsafe External Call Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Race conditions issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Oddz Finance_en-us.pdf",
        "body": "The enableOptionTransfer function can be called repeatedly, When the attacker calls enableOptionTransfer to set a small value of _minAmount.The user does not need to enter minAmount to check when calling the optionTransfer function.Therefore, the attacker can call enableOptionTransfer again with a higher gas price to set a new minAmount, so that if the allowance is greater than the minAmount + transferFee , the user can normally execute optionTransfer calls and trade with a larger amount, and the attacker can prot. contracts/Option/OddzOptionManager.sol function enableOptionTransfer(uint256 _optionId, uint256 _minAmount) external { Option storage option = options[_optionId]; require( option.expiration > (block.timestamp + 18 assetManager.getMinPeriod(option.pair)), \"Option not eligble for transfer\" ); require(option.holder == msg.sender, \"Invalid Caller\"); require(option.state == State.Active, \"Invalid state\"); require(_minAmount >= minimumPremium, \"amount is lower than minimum premium\"); optionTransferMap[_optionId] = _minAmount; emit OptionTransferEnabled(_optionId, _minAmount); } function optionTransfer(uint256 _optionId) external { Option storage option = options[_optionId]; require( option.expiration > (block.timestamp + assetManager.getMinPeriod(option.pair)), \"Option not eligble for transfer\" ); uint256 minAmount = optionTransferMap[_optionId]; require(minAmount > 0, \"Option not enabled for transfer\"); require(option.state == State.Active, \"Invalid state\"); require(option.holder != msg.sender, \"Self option transfer is not allowed\"); // once transfer initiated update option tranfer map delete optionTransferMap[_optionId]; uint256 transferFee = _getTransactionFee(minAmount, msg.sender); txnFeeAggregate += transferFee; _validateOptionAmount(token.allowance(msg.sender, address(this)), minAmount + transferFee); token.safeTransferFrom(msg.sender, option.holder, minAmount); token.safeTransferFrom(msg.sender, address(this), transferFee); address oldHolder = option.holder; option.holder = msg.sender; emit OptionTransfer(_optionId, oldHolder, msg.sender, minAmount, transferFee); } 19",
        "labels": [
            "SlowMist",
            "Oddz Finance",
            "Type: Reordering Vulnerability",
            "Severity: Critical"
        ]
    },
    {
        "title": "Excessive authority issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Oddz Finance_en-us.pdf",
        "body": "(1) The owner of the OddzIVOracleManager and OddzPriceOracleManager contracts can change the conguration of the contract and does not use timelock for management, there is a risk of excessive authority. The oracle aects the price of the asset. When the oracle contract is maliciously manipulated, it will cause the user's asset to be damaged. (2) After the contracts are deployed, it is necessary to check whether TimeLocker is set correctly.",
        "labels": [
            "SlowMist",
            "Oddz Finance",
            "Type: Authority Control Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - EarningFarm v3 Iterative_en-us.pdf",
        "body": "In the Exchange contract, the owner role can set swapCaller and router through the setSwapCaller and listRouter functions. If it is set to a malicious address, funds will be lost. In the CDai contract, the owner role can set sensitive parameters through the setSwapPath function. This will lead to the risk of excessive owner permissions. ",
        "labels": [
            "SlowMist",
            "EarningFarm v3 Iterative",
            "Type: Authority Control Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Variable storage issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - EarningFarm v3 Iterative_en-us.pdf",
        "body": "In the Curve3Pool contract, the swap function is used for token exchange. When fetching pools[_index], it uses storage to store the curve variable, but in this function there is no need to modify pools[_index], so this will consume more gas. ",
        "labels": [
            "SlowMist",
            "EarningFarm v3 Iterative",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Slippage issue 9",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - EarningFarm v3 Iterative_en-us.pdf",
        "body": "In the Curve3Pool contract, the swap function is used to exchange tokens in 3pool, but the _min_received passed in during the exchange is 0, which will cause the exchange process to be subject to a sandwich attack. ",
        "labels": [
            "SlowMist",
            "EarningFarm v3 Iterative",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "get_dy index issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - EarningFarm v3 Iterative_en-us.pdf",
        "body": "In the CDai contract, the _totalAssets function converts DAI to USDC as total assets via CurvePool's get_dy. But Calculate withdraw amout of usdc - from Dai (j) to USDC(i) is stated in the comments, while according to the get_dy function description (https://curve.readthedocs.io/factory-pools.html#StableSwap.get_dy ), the i index should be DAI, and the j index should be USDC. ",
        "labels": [
            "SlowMist",
            "EarningFarm v3 Iterative",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of breaching contract integrity",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - EarningFarm v3 Iterative_en-us.pdf",
        "body": "When the user makes a withdrawal, the protocol will withdraw from the SS contract through the controller contract, and then burn the user's share. 11 In the withdraw function of the SS contract, it will rst calculate the number of LPs that the user can withdraw (lpAmt), then extract the LP tokens from the convex, and then use balanceOf(address(this)) to obtain the LP balance of this contract as lpWithdrawn. TotalLP will then subtract lpWithdrawn and remove liquidity from CurvePool. The amount to remove liquidity is also lpWithdrawn. Then transfer all USDC tokens in the SS contract to the controller. Finally, the controller contract transfers the USDC token to the user. In the withdraw function of the vault contract, after the controller completes the withdrawal, the number of burned shares is calculated based on the assets passed in by the user. This will lead to the destruction of the totalLP value if a malicious user transfers a large amount of LP tokens to the SS contract and withdraws them after depositing. ",
        "labels": [
            "SlowMist",
            "EarningFarm v3 Iterative",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Risk of slippage checks being bypassed",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - EarningFarm v3 Iterative_en-us.pdf",
        "body": "In the CDai contract, the totalAssets function calculates the total collateral amount of the SS contract in the strategy through the get_dy function of CurvePool. When the user withdraws, the contract will participate in the calculation of 12 the nDAI value to be withdrawn through totalAssets. Unfortunately, a malicious user can manipulate the CurvePool with large sums of money so that the value obtained by the get_dy function is much smaller than expected, which will cause the nDAI value to be much larger than expected when withdrawing. Malicious users can deplete the liquidity in CDai by stealing collateral that does not belong to them. ",
        "labels": [
            "SlowMist",
            "EarningFarm v3 Iterative",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Arbitrary permission initialization of lend/oracle contract",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Larix Obsolete_en-us.pdf",
        "body": "Anyone can initialize the lend/oracle contract, which may lead to the illegal use of the contract, and malicious users may use the ocially deployed Program to conduct fraudulent activities.",
        "labels": [
            "SlowMist",
            "Larix Obsolete",
            "Type: Authority Control Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Flash loan repayment detection bypass",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Larix Obsolete_en-us.pdf",
        "body": "After the attacker calls process_flash_loan to borrow, he uses the borrowed funds to recharge to the contract. In this way, the ash loan will detect that the funds have been returned during the repayment check, which leads to the success of the ash loan, but the funds are not actually returned. Instead, the attacker get a deposit position is established, and the attacker can withdraw this fund at any time, thereby stealing all the funds in the fund pool.",
        "labels": [
            "SlowMist",
            "Larix Obsolete",
            "Type: Reentrancy Vulnerability",
            "Severity: Critical"
        ]
    },
    {
        "title": "Process_ash_loan forged account risk 7",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Larix Obsolete_en-us.pdf",
        "body": "Code location: larix-lending/src/processor.rs fn process_flash_loan( program_id: &Pubkey, liquidity_amount: u64, accounts: &[AccountInfo], ) If the owner or key of the reserve_info account is not veried, the attacker may attack the contract by maliciously constructing the data stored in the account.",
        "labels": [
            "SlowMist",
            "Larix Obsolete",
            "Type: Forged account attack",
            "Severity: Critical"
        ]
    },
    {
        "title": "Process_reserve forged account risk",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Larix Obsolete_en-us.pdf",
        "body": "Code location: larix-lending/src/cong/cong_process.rs fn process_reserve(program_id: & Pubkey, accounts: & [AccountInfo],reserve_type:ConfigReserveType) If the owner or key of the reserve_info account is not veried, the attacker may attack the contract by maliciously constructing the data stored in the account.",
        "labels": [
            "SlowMist",
            "Larix Obsolete",
            "Type: Forged account attack",
            "Severity: Critical"
        ]
    },
    {
        "title": "process_borrow_obligation_liquidity host_fee transfer target is not veried",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Larix Obsolete_en-us.pdf",
        "body": "Code location: larix-lending/src/processor.rs if let Ok(host_fee_receiver_info) = next_account_info(account_info_iter) { if host_fee > 0 { owner_fee = owner_fee .checked_sub(host_fee) .ok_or(LendingError::MathOverflow)?; spl_token_transfer(TokenTransferParams { source: source_liquidity_info.clone(), destination: host_fee_receiver_info.clone(), amount: host_fee, authority: lending_market_authority_info.clone(), authority_signer_seeds, token_program: token_program_id.clone(), })?; } } The owner or key of the host_fee_receiver_info account is not veried, and the user can steal host_fee by specifying host_fee_receiver_info .",
        "labels": [
            "SlowMist",
            "Larix Obsolete",
            "Type: Forged account attack",
            "Severity: Critical"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap_v3_Phase2_en-us.pdf",
        "body": "1.The owner role can change the external part contract FARM_BOOSTER through the updateFarmBoostContract function and the external part contract can aect the boostMultiplier . ",
        "labels": [
            "SlowMist",
            "PancakeSwap_v3_Phase2",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "LP token locking issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap_v3_Phase2_en-us.pdf",
        "body": "In the MasterChefV3 contract, users will transfer their ERC721 LP tokens for staking to get the CAKE as reward. Users can only call the safeTransferFrom function to transfer their ERC721 LP token in the MasterChefV3 contract to trigger the _checkOnERC721Received hook to let the NonfungiblePositionManager contract call back the onERC721Received function. After this, the positionInfo can be recorded and make the staking eective. If users miss transferring the LP token by using the transferFrom function, the LP tokens will be locked in this contract. ",
        "labels": [
            "SlowMist",
            "PancakeSwap_v3_Phase2",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Cast truncation issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap_v3_Phase2_en-us.pdf",
        "body": "In the PancakeV3LmPool contract, the Pool or MasterChef will calculate the reward through the accumulateReward function. The uint256 endTime is assigned by getLatestPeriodInfo in the MasterChef contract and the endTime is assigned by an uint256 value latestPeriodEndTime , then the endTime will cast to an uint32 to endTimestamp . If the latestPeriodEndTime is larger than type(uin32).max , there will be a cast truncation issue. And PancakeV3LmPool contract imports the SafeCast contract but doesnt use it for the uin32 cast. ",
        "labels": [
            "SlowMist",
            "PancakeSwap_v3_Phase2",
            "Type: Arithmetic Accuracy Deviation Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Potential risks of arbitrary transfer of ETF funds",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase7 - SlowMist Audit Report.pdf",
        "body": "In the MoveFunds contract, the admin role can transfer funds from the ETF to a specied receiver address through the makeTransfer function during the ETF's closed period. Additionally, the owner can arbitrarily modify the receiver address through the setReceiver function. For the ETF, this may pose an excessive privilege risk, and participants should be aware of this. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase7 - SlowMist Audit Report",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Information"
        ]
    },
    {
        "title": "Redundant logic issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - MasterChef v2_en-us.pdf",
        "body": "In the add function, the owner can add new pools. It will rst check whether the number of newly added lpTokens in the contract is greater than or equal to 0. But in fact, the number of lpTokens in the contract will be greater than or equal to 0 in any case, so this check is redundant. ",
        "labels": [
            "SlowMist",
            "MasterChef v2",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Permission control issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - MasterChef v2_en-us.pdf",
        "body": "If any user holds the dummy token, the user can stake the dummy token to the MasterChef v1 contract through the init function, which will cause the lastBurnedBlock parameter to be updated unexpectedly, and nally lead to an error in the calculation of the number of CAKE tokens waiting to be burned. ",
        "labels": [
            "SlowMist",
            "MasterChef v2",
            "Type: Authority Control Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "The number of pendingCakeToBurn is not checked",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - MasterChef v2_en-us.pdf",
        "body": "In the burnCake function, if the number of CAKE tokens in the contract is less than pendingCakeToBurn, it will harvest CAKE tokens from MasterChef v1 via the harvestFromMasterChef function. But it does not check if the balance of CAKE tokens in the contract after harvesting is greater than or equal to pendingCakeToBurn. ",
        "labels": [
            "SlowMist",
            "MasterChef v2",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Repeatable initialization issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap_MOVE_en-us.pdf",
        "body": "In the swap module RESOURCE_ACCOUNT can initialize SwapInfo through the init_storage function, but the function does not check for repeated initialization. ",
        "labels": [
            "SlowMist",
            "PancakeSwap_MOVE",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Gas optimization",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap_MOVE_en-us.pdf",
        "body": "In the swap module, the add_liquidity function is used to add liquidity and return the remaining tokens to the user. But without checking whether the token value to be returned is greater than 0, the coin::deposit function is called. If the returned token value is 0, this will cause unnecessary gas consumption. ",
        "labels": [
            "SlowMist",
            "PancakeSwap_MOVE",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Architecture optimization",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap_MOVE_en-us.pdf",
        "body": "The storage of LP tokens is realized through storage.move in the protocol. But the creation of Pair is realized through the create_pair of the swap module and the resource storage is carried out by TokenPairMetadata and TokenPairReserve. So LPToken can be implemented directly in swap module without having to implement it in storage.move separately. ",
        "labels": [
            "SlowMist",
            "PancakeSwap_MOVE",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Assertion aw issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap_MOVE_en-us.pdf",
        "body": "In the swap module, the mint function is used to mint LP tokens when liquidity is added. When adding liquidity for the rst time, the liquidity amount needs to meet MINIMUM_LIQUIDITY. If the MINIMUM_LIQUIDITY is not met, the 12 transaction will be revet. In this case the protocol will throw an overow error instead of ERROR_INSUFFICIENT_LIQUIDITY_MINTED. ",
        "labels": [
            "SlowMist",
            "PancakeSwap_MOVE",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Not checked if pair has been created",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap_MOVE_en-us.pdf",
        "body": "In the router module contract, users can remove liquidity and exchange tokens through the functions remove_liquidity, swap_exact_input, swap_exact_output, swap_exact_input_doublehop, 13 swap_exact_output_doublehop, swap_exact_input_triplehop and swap_exact_output_triplehop respectively, but do not check whether a pair is created rst. ",
        "labels": [
            "SlowMist",
            "PancakeSwap_MOVE",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Redundant code",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap_MOVE_en-us.pdf",
        "body": "In the Swap module, the quote_x_to_y_after_fees, quote_y_to_x_after_fees, transfer_x and transfer_y functions are all internal functions, but no other public functions call them. ",
        "labels": [
            "SlowMist",
            "PancakeSwap_MOVE",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "k value check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap_MOVE_en-us.pdf",
        "body": "During the swap process, it is necessary to check whether the multiplication of the token balance of the pair after the swap is strictly greater than or equal to the k value. However, due to the fee charged during the swap process, in theory, the multiplication of the token balance of the pair after swap must be strictly greater than the k value. While using u256 avoids close rounding errors it is still not necessary to check if it is equal to the k value. ",
        "labels": [
            "SlowMist",
            "PancakeSwap_MOVE",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap_MOVE_en-us.pdf",
        "body": "In the swap module contract, the admin role can call the upgrade_swap function to upgrade the entire contract. If administrator privileges are stolen, it may have an impact on the normal operation of the contract. ",
        "labels": [
            "SlowMist",
            "PancakeSwap_MOVE",
            "Type: Excessive Authority Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "The validity of the token contract address is not checked",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Bitlayer Bridge Phase 2.pdf",
        "body": "In the BitlayerBridgeV2 contract, the crossoutBurn function does not check the validity of the token address. An attacker can pass in the token contract address created by himself, and then transfer and burn the tokens created by the attacker through the crossoutBurn function to trigger the CrossoutBurned event. contracts/BitlayerBridgeV2.sol#L278-L307 function crossoutBurn( address token, uint256 value, string memory btcReceiver ) external payable { require(token != address(0), \"invalid token address\"); require(value != 0, \"invalid value\"); require(bytes(btcReceiver).length != 0, \"invalid btcReceiver\"); uint256 crossoutFeeAmount = tokenConfigs[token].crossoutFee; require(crossoutFeeAmount == 0 || msg.value >= crossoutFeeAmount, \"not enough fee paied\"); SafeERC20.safeTransferFrom(IERC20(token), msg.sender, address(this), value); IPegToken(token).burn(address(this), value); if (crossoutFeeAmount > 0) { (bool success, bytes memory returndata) = feeAddress.call{value: crossoutFeeAmount}(\"\"); require(success, string(returndata)); } uint256 unusedFee = msg.value - crossoutFeeAmount; if (unusedFee > 0) { (bool success, bytes memory returndata) = msg.sender.call{value: unusedFee}(\"\"); require(success, string(returndata)); } emit CrossoutBurned(msg.sender, btcReceiver, token, value); }",
        "labels": [
            "SlowMist",
            "Bitlayer Bridge Phase 2",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Unlimited huge amount minting",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Bitlayer Bridge Phase 2.pdf",
        "body": "In the BitlayerBridgeV2 contract, when huge amounts are minted through the proposeMint function and executeMint function, the minted amount is not limited by periodLimit , nor is it recorded in periodMinted , and the period will not be updated. contracts/BitlayerBridgeV2.sol#L235-L255,L258-L275 function proposeMint( MintInfo memory mInfo ) external onlyRole(ProposerRole) { bytes32 blExecHash = keccak256(abi.encodePacked(mInfo.btcTxHash)); require(!executedBtcHash[blExecHash], \"already executed\"); require(mInfo.receiver != address(0), \"receiver is null\"); require(proposedMint[blExecHash].receiver == address(0), \"already proposed\"); require(mInfo.value >= tokenConfigs[mInfo.token].mintSplitLine, \"mint value is less than configed\"); require( !IPegToken(mInfo.token).isBlacklist(mInfo.receiver), \"receiver is blacklisted\" ); proposedMint[blExecHash] = mInfo; emit MintProposed(mInfo.btcTxHash, blExecHash, mInfo.receiver, mInfo.token, mInfo.value); } function executeMint( bytes32 blExecHash ) external onlyRole(ExecutorRole) { MintInfo memory mInfo = proposedMint[blExecHash]; require(!executedBtcHash[blExecHash], \"already executed\"); require(mInfo.receiver != address(0), \"not proposed\"); executedBtcHash[blExecHash] = true; delete proposedMint[blExecHash]; IPegToken(mInfo.token).mint(mInfo.receiver, mInfo.value); emit MintExecuted(mInfo.btcTxHash, blExecHash, mInfo.receiver, mInfo.token, mInfo.value); }",
        "labels": [
            "SlowMist",
            "Bitlayer Bridge Phase 2",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "The returned leftQuota value is inaccurate",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Bitlayer Bridge Phase 2.pdf",
        "body": "In the BitlayerBridgeV2 contract, the getPeriodInfo function is inaccurate when returning the leftQuota of the specied token. If block.number has reached the next period and tokenConfigs[token] has not been updated, the value of leftQuota should be config.periodLimit . contracts/BitlayerBridgeV2.sol#L309-L319 function getPeriodInfo(address token) external view returns(uint256 periodLimit, uint256 leftQuota, uint256 leftBlocksToNextPeriod) { TokenConfig memory config = tokenConfigs[token]; periodLimit = config.periodLimit; leftQuota = config.periodLimit - config.periodMinted; leftBlocksToNextPeriod = config.periodInterval - (block.number - config.lastBlockNumber) % config.periodInterval; }",
        "labels": [
            "SlowMist",
            "Bitlayer Bridge Phase 2",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Missing zero address check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Bitlayer Bridge Phase 2.pdf",
        "body": "1.In the BitlayerBridgeV2 contract, the initToken function does not perform a zero address check on the token address. contracts/BitlayerBridgeV2.sol#L99-L119 function initToken( address token, ``` ) external onlyRole(AdminRole) { TokenConfig storage config = tokenConfigs[token]; ``` } 2.In the BitlayerBridgeV2 contract, the directMint function does not perform a zero address check on the mInfo.token address. contracts/BitlayerBridgeV2.sol#L198-L233 function directMint( MintInfo memory mInfo ) external onlyRole(MinterRole) { ``` IPegToken(mInfo.token).mint(mInfo.receiver, mInfo.value); ``` } 3.In the BitlayerBridgeV2 contract, the proposeMint function does not perform a zero address check on the mInfo.token address. BitlayerBridgeV2.sol#L235-L255 function proposeMint( MintInfo memory mInfo ) external onlyRole(ProposerRole) { ``` require( !IPegToken(mInfo.token).isBlacklist(mInfo.receiver), \"receiver is blacklisted\" ); ``` }",
        "labels": [
            "SlowMist",
            "Bitlayer Bridge Phase 2",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Unchecked parameter value is not 0",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Bitlayer Bridge Phase 2.pdf",
        "body": "1.In the BitlayerBridgeV2 contract, the initToken function does not check whether the values of periodInterval and mintSplitLine are not 0. contracts/BitlayerBridgeV2.sol#L99-L119 function initToken( address token, uint256 periodLimit, uint256 periodInterval, uint256 mintSplitLine, uint256 crossoutFee ) external onlyRole(AdminRole) { TokenConfig storage config = tokenConfigs[token]; require(config.lastBlockNumber == 0, \"already inited\"); config.lastBlockNumber = block.number; config.periodLimit = periodLimit; config.periodInterval = periodInterval; config.mintSplitLine = mintSplitLine; config.crossoutFee = crossoutFee; emit TokenInited(token, periodLimit, periodInterval, mintSplitLine, crossoutFee); } 2.In the BitlayerBridgeV2 contract, the setMintSplitLine function does not check whether the value of limit is not 0. contracts/BitlayerBridgeV2.sol#L137-L149 function setMintSplitLine( address token, uint256 limit ) public onlyRole(AdminRole) { require(token != address(0), \"invalid token address\"); tokenConfigs[token].mintSplitLine = limit; emit MintSplitLineSet(token, limit); } 3.In the BitlayerBridgeV2 contract, the directMint function does not check whether the value of mInfo.value is not 0. BitlayerBridgeV2.sol#L198-L233 function directMint( MintInfo memory mInfo ) external onlyRole(MinterRole) { ``` require( mInfo.value < config.mintSplitLine, \"mint value is greater than configed\" ); ``` }",
        "labels": [
            "SlowMist",
            "Bitlayer Bridge Phase 2",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Redundant code",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Bitlayer Bridge Phase 2.pdf",
        "body": "In the BitlayerBridgeV2 contract, the directMint function repeatedly performs a zero address check on the mInfo.receiver address because the zero address check has already been performed on this address in the mint function of the token contract. contracts/BitlayerBridgeV2.sol#L198-L233 function directMint( MintInfo memory mInfo ) external onlyRole(MinterRole) { ``` require(mInfo.receiver != address(0), \"receiver is null\"); ``` }",
        "labels": [
            "SlowMist",
            "Bitlayer Bridge Phase 2",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Bitlayer Bridge Phase 2.pdf",
        "body": "1.In the BitlayerBridgeV2 contract, the AdminRole role can set important parameters in the contract through the following functions. contracts/BitlayerBridgeV2.sol function setRoles function initToken function setPeriodMintLimit function setMintSplitLine function setCrossoutFee function setPeriodInterval function startNewPeriod 2.The BitlayerBridge contracts are implemented using the OpenZeppelin upgradeable model, allowing the AdminRole role to perform contract upgrades.Since the BitlayerBridgeV2 contract inherits the BitlayerBridge contract, it is also an upgradeable contract. However, this design introduces an excessive privilege risk. contracts/BitlayerBridge.sol#L4 import \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\"; 3.In the BitlayerBridge contract, AdminRole role can set important parameters of the contract.And the BitlayerBridgeV2 contract also inherits these privileged functions. contracts/BitlayerBridge.sol function setFeeAddress function setLockFee function setMinLockAmount function setMaxLockAmount 4.In the BitlayerBridge contract, the LiquidityRole role can call the removeLiquidityTo function to remove the liquidity of any address.And the BitlayerBridgeV2 contract also inherits this privileged functions. contracts/BitlayerBridge.sol#L159-L162 function removeLiquidity(uint256 amount) external whenNotPaused { require(amount > 0, \"invalid amount\"); doRemoveLiquidity(msg.sender, amount); } 5.In the BitlayerBridge contract, UnlockRole can pass in any _txHash through the unlock function to unlock any amount of native tokens. In the BitlayerBridgeV2 contract, MinterRole , ProposerRole and ExecutorRole can mint any amount of PegToken by passing in any btcTxHash parameter through their respective functions ( directMint , proposeMint and executeMint ). These vulnerabilities stem from the contract's inability to verify Bitcoin networks transaction hash at the EVM level, instead leaving verication to a centralized validator. contracts/BitlayerBridge.sol function unlock contracts/BitlayerBridgeV2.sol function directMint function proposeMint function executeMint",
        "labels": [
            "SlowMist",
            "Bitlayer Bridge Phase 2",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Missing event record",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap_Pottery_en-us.pdf",
        "body": "When the sensitive parameters of the contract are modied, the corresponding events are not recorded, which is not conducive to the supervision of the community and users. ",
        "labels": [
            "SlowMist",
            "PancakeSwap_Pottery",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Business logic problem",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap_Pottery_en-us.pdf",
        "body": "The contract does not check whether the incoming address and ID exist. If the wrong data is passed in in the actual operation, it will lead to waste of resources. ",
        "labels": [
            "SlowMist",
            "PancakeSwap_Pottery",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap_Pottery_en-us.pdf",
        "body": "The Owner has the right to modify the address of the contract to any address. ",
        "labels": [
            "SlowMist",
            "PancakeSwap_Pottery",
            "Type: Authority Control Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Defects in the defaultDepositSS check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ENF_ETH_Lowrisk_en-us.pdf",
        "body": "In the harvest function of the Controller contract, before re-depositing the protocol income into the strategy, it will check whether the default SS exists through subStrategies.length > defaultDepositSS . But actually, defaultDepositSS will be 0 when the default SS does not exist, so the subStrategies.length > defaultDepositSS check will always pass. Eventually the protocol will fail to re-deposit. ",
        "labels": [
            "SlowMist",
            "ENF_ETH_Lowrisk",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "ownerDeposit remaining deposit issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ENF_ETH_Lowrisk_en-us.pdf",
        "body": "In the ownerDeposit function of the StETH contract, the owner role will directly deposit ETH into the strategy. It checks that msg.value must be greater than or equal to the amount to be deposited through _amount <= msg.value . But when the owner's msg.value is greater than _amount , the ownerDeposit function does not implement the refund of excess ETH. This will result in funds being locked. The same is true for the ownerDeposit function of the CEth contract. ",
        "labels": [
            "SlowMist",
            "ENF_ETH_Lowrisk",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Redundant variable",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ENF_ETH_Lowrisk_en-us.pdf",
        "body": "There is a weth global variable in the CEth contract, but this variable is not used in the contract. ",
        "labels": [
            "SlowMist",
            "ENF_ETH_Lowrisk",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ENF_ETH_Lowrisk_en-us.pdf",
        "body": "10 In the protocol, the owner role has many permissions, such as: the owner can set sensitive parameters, can suspend the contract, can make emergency withdrawals, can migrate the funds of the SS contract, etc. It is obviously inappropriate to give all the permissions of the protocol to the owner, which will greatly increase the single point of risk.",
        "labels": [
            "SlowMist",
            "ENF_ETH_Lowrisk",
            "Type: Authority Control Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Compound interest slippage check issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ENF_ETH_Lowrisk_en-us.pdf",
        "body": "In the router contract, no slippage check is performed during the swap operation. If there are more funds with compound interest, there will be a risk of being attacked by sandwiches. ",
        "labels": [
            "SlowMist",
            "ENF_ETH_Lowrisk",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Redundant collectEndTime check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report_en-us.pdf",
        "body": "In the CongurableRightsPool contract, users can redeem underlying assets through the exitPool function. When the pool is a closed ETF, it will check isCompletedCollect and collectEndTime to decide whether to perform _claimManagerFee operation. But when isCompletedCollect is true, the collectEndTime check will be performed in snapshotEndAssets, and when isCompletedCollect is false, the collectEndTime check will be performed in exitPoolHandleB. Hence the collectEndTime check before the _claimManagerFee operation is redundant. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Redundant closureEndTime check on exitPool",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report_en-us.pdf",
        "body": "In the CongurableRightsPool contract, users can redeem underlying assets through the exitPool function. When the pool is a closed ETF and isCloseEtfCollectEndWithFailure is false, it will check that the current time must be greater than closureEndTime + 5 minutes before allowing the user to exit. However, it should be noted that the snapshotEndAssets operation will be performed before this. The snapshotEndAssets function will also check whether the current time is greater than closureEndTime + 5 minutes . Only the admin and owner can execute snapshotEndAssets within 5 minutes after the closure period ends. Otherwise, the transaction will be reverted. Therefore, the closureEndTime check in the exitPool function is redundant. When snapshotEndAssets cannot be performed, the entire transaction will be reverted, and subsequent closureEndTime checks will not be performed. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Redundant performance fee calculation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report_en-us.pdf",
        "body": "In the exitPool function of the CongurableRightsPool contract, redeemAndPerformanceFeeReceived, nalAmountOut and redeemFeeReceived are calculated through exitPoolHandleA. However, since the performance fee will be calculated uniformly in the snapshotEndAssets operation, there is no need to process the performance fee in the exitPool function. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "The time allowed for snapshots is too short",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report_en-us.pdf",
        "body": "In the CongurableRightsPool contract when the closed ETF completes collect and the collection period has ended, the current total value of the ETF can be recorded through the snapshotBeginAssets function. However, users can only call the snapshotBeginAssets function within 15 minutes after the end of the collection period. If there is congestion on the chain, it may not be possible to call the snapshot in time within 15 minutes. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Duplicate decimal processing issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report_en-us.pdf",
        "body": "In the DesynChainlinkOracle contract, the getPrice function is used to obtain the corresponding token price from prices, getChainlinkPrice, and getUniswapPrice, and perform decimal processing. However, decimal has been processed in getChainlinkPrice and getUniswapPrice, and theoretically, the returned decimal will be 1e18. Therefore, processing decimals through decimalDelta will cause decimals to be enlarged. Note that the amountIn passed in for the consult in the getUniswapPrice function is 1e18, which needs to be ensured that the token decimal in twapOracle matches it in practice ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Decimal processing issue in AllPrice calculation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report_en-us.pdf",
        "body": "In the DesynChainlinkOracle contract, the getAllPrice function is used to calculate the total value of the specied amount of tokens. It is calculated by badd(fundAll, bmul(getPrice(t), tokenAmountOut)) , theoretically the decimal returned by getPrice is 1e18, and the decimal of tokenAmountOut is consistent with the decimal of the token itself. Therefore, multiplying these two values will result in a very large decimal in the nal result. The getNormalizedWeight function is also aected by this, but this is not harmful to normal business. Note: ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Redundant code issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report_en-us.pdf",
        "body": "In the SmartPoolManager library, the exitPoolHandle function has been deprecated since closed ETF prots are calculated in snapshotEndAssets. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Token list conict in recordTokenInfo",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report_en-us.pdf",
        "body": "When the user performs createPool and joinPool, if the Pool is a closed ETF and the current time is within the collection period, the KOL invitation amount will be recorded through UserVault's recordTokenInfo interface. But unfortunately, the tokens in the Pool can be Bind/unBind at any time, which will cause the list of tokens supported by the Pool to change. If the recordTokenInfo operation is performed when the Pool token list changes, the amount recorded by variables such as poolInviteTotal, kolTotalAmountList, and kolUserInfo may be disturbed. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "couldManagerClaim not checked when managerClaim",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report_en-us.pdf",
        "body": "In the UserVault contract, the Manager role can claim management fees through the managerClaim function, but it does not check whether the couldManagerClaim parameter is true. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Some redundant invoke functions",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report_en-us.pdf",
        "body": "In the Invoke library, the strictInvokeTransfer, invokeUnwrapWETH, invokeWrapWETH, and invokeMint functions are not used. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of ETF falsication",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report_en-us.pdf",
        "body": "In the RebalanceAdapter contract, the Manager role can adjust the position of the pool through the rebalance function. But the address of the ETF is obtained from the rebalanceInfo passed in by the user. If a malicious user passes in a fake ETF, the check in the onlyManager decorator will be bypassed, and the _verifyWhiteToken check of token1 and the isCompletedCollect and collectEndTime checks will be useless. Malicious users can steal bPool funds through _makeSwap and bind malicious tokens. The approve function also has this risk, but it doesn't break the protocol too much ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Risk of the Manager role potentially disrupting the protocol",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report_en-us.pdf",
        "body": "In the RebalanceAdapter contract, the Manager role can adjust the position of the ETF through the rebalance function. It will use the _makeSwap function to call Uniswap, 1inch and other DEXs for token swaps to adjust token positions. But unfortunately, the swap path of the token is not checked during the token swap process, which will cause the Manager role to pass in a carefully constructed malicious swap path to steal the middle token0 of the ETF. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Double slippage check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report_en-us.pdf",
        "body": "In the RebalanceAdapter contract, the Manager role can adjust the position of the ETF through the rebalance function. It will use the _makeSwap function to call Uniswap, 1inch and other DEXs for token swaps to adjust token positions. During the swap process, the slippage will be checked by passing minReturn to the external DEXs, but the implementation of the slippage check of the external DEXs is uncontrollable. If the slippage protection of the external DEXs fails, it will aect the funds of users in the protocol. (1inch users encountered invalid slippage check before) ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Does not follow the Checks-Eects-Interactions specication",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report_en-us.pdf",
        "body": "In the RebalanceAdapter contract, the _makeSwap function is used for token swap. When the swap type is not UNISWAPV3 and UNISWAPV2, the parameters passed in by the user will be checked through _validateData . However, the execute operation is performed rst, and the _validateData operation is performed after the token exchange is completed. This is not in line with the follow the Checks-Effects-Interactions principle. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Perform strict parameter checking",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report_en-us.pdf",
        "body": "In the RebalanceAdapter contract, the _validateData function is used to check the exchange parameters, but it only parses the recipient and amountIn for checking, but does not check whether other key parameters such as srcToken, dstToken, clipperExchange, makerAsset, takerAsset are in line with expectations. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Redundant aggregator parameter",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report_en-us.pdf",
        "body": "In the RebalanceAdapter contract, the _validateData function is used to check the conversion parameters, but the aggregator parameter it receives is not used. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Incorrect approval operation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report_en-us.pdf",
        "body": "In the RebalanceAdapter contract, the Manager role can adjust the position of the ETF through the rebalance function. If token1 has not been bound in bPool, it will be approved rst. However, the subsidy of this contract was wrongly approved to bPool, which will cause bPool to be unable to transfer tokens from CRP in the future. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report_en-us.pdf",
        "body": "There is an execute function in the CRP and bPool contracts so that the Manager can manage the ETF. In bFactory, the Blabs role can arbitrarily register modules to gain control over CRP. The registered modules can use the execute function in CRP to call the execute function in bPool to perform any operations. This would pose a huge risk to users' funds. And the Manager can approve the tokens in the bPool through the approve function of the RebalanceAdapter contract, which will also bring huge risks to the user's funds. The above problems lead to the risk of excessive permissions of the Blabs role and the Manager role. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Authority Control Vulnerability Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Enforce strict permission controls",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report_en-us.pdf",
        "body": "In the LiquidityPool contract, any user can call the joinPool, exitPool, and gulp functions to add/remove liquidity/record token balances, which will make it impossible to charge various fees to users in CRP. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Business logic issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Unemeta_en-us.pdf",
        "body": "1.In the UnemetaMarket contract, the matchSellerOrdersWETH and matchSellerOrders use the strategy to match orders, but the canExecuteTakerBid function is not in the StrategyFixedPrice contract. ",
        "labels": [
            "SlowMist",
            "Unemeta",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Unemeta_en-us.pdf",
        "body": "The owner role of the RoyaltyFeeRegistry and RoyaltyFeeSetter contract can update the royaltyFeeLimit and the FeeInfo of the NFT collection. ",
        "labels": [
            "SlowMist",
            "Unemeta",
            "Type: Authority Control Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Risk of replay attack",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Unemeta_en-us.pdf",
        "body": "13 The chainid is dened when the contract is initialized, but it is not reimplemented when DOMAIN(domainSeparator) is used in the verify function. So the domainSeparator contains the chainId and is dened at contract deployment instead of reconstructed for every signature, there is a risk of possible replay attacks between chains in the event of a future chain split. ",
        "labels": [
            "SlowMist",
            "Unemeta",
            "Type: Replay Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing event records",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap Stable Swap_en-us.pdf",
        "body": "In the PancakeStableSwap contract, the owner can set the is_killed, balances and admin_actions_deadline parameters respectively through the kill_me, unkill_me, donate_admin_fees and revert_new_parameters functions, but no event recording is performed. ",
        "labels": [
            "SlowMist",
            "PancakeSwap Stable Swap",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Ring Protocol_en-us.pdf",
        "body": "1.In the FewWrappedToken contract, the burner role can burn any users Wrapped tokens through the burnFrom function without users approval. All role settings are completed in the core contract, which is not within the scope of this audit. ",
        "labels": [
            "SlowMist",
            "Ring Protocol",
            "Type: Authority Control Vulnerability Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Token compatibility reminder",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Ring Protocol_en-us.pdf",
        "body": "In the FixedStakingRewards contract, users can stake, stakeWithPermit, and withdraw the stakeingTokens by safetransferFrom and safetransfer functions to the staking contract and the amount will be directly recorded in the totalSupply. If the stakingTokens are deationary tokens, the actual amount of tokens received by the FixedStakingRewards contract will be less than the amount recorded by the amount parameter. ",
        "labels": [
            "SlowMist",
            "Ring Protocol",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Potential token decimal compatibility reminder",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Ring Protocol_en-us.pdf",
        "body": "In the FixedStakingRewards contract, users can stake the tokens through the stake and stakeWithPermit functions. It will update each totalSupply and balances parameters according to the amount of user deposits. These parameters will not distinguish dierent stakingTokens, if the stakingTokens deposit with dierent decimals will may lead to errors in the calculation of rewards in the protocol.",
        "labels": [
            "SlowMist",
            "Ring Protocol",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing the event records",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Ring Protocol_en-us.pdf",
        "body": "In the FixedStakingRewards contract, the rewardSetter can arbitrarily modify every rewardPerTokenPerSecond , periodFinish , and rewardSetter parameters in each StakingInfo, but there are no event logs. ",
        "labels": [
            "SlowMist",
            "Ring Protocol",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing the 0 address check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Ring Protocol_en-us.pdf",
        "body": "In the FixedStakingRewards and CoreRef contract, the Governor role can modify the _core address and the rewardSetter can modify the rewardSetter address, but there are no 0 address checks. ",
        "labels": [
            "SlowMist",
            "Ring Protocol",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Malleable attack risk",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Ring Protocol_en-us.pdf",
        "body": "In the permit function of the FewWrappedToken contract, it restores the address of the signer through the ecrecover function, but does not check the value of v and s. Since EIP2 still allows the malleability for ecrecover, this will lead to the risk of transaction malleability attacks. ",
        "labels": [
            "SlowMist",
            "Ring Protocol",
            "Type: Replay Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of replay attack",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Ring Protocol_en-us.pdf",
        "body": "DOMAIN_SEPARATOR is dened when the contract is initialized, but it is not reimplemented when DOMAIN_SEPARATOR is used in the permit function. So the DOMAIN_SEPARATOR contains the chainId and is dened at contract deployment instead of reconstructed for every signature, there is a risk of possible replay attacks between chains in the event of a future chain split. ",
        "labels": [
            "SlowMist",
            "Ring Protocol",
            "Type: Replay Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Preemptive Initialization",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Ring Protocol_en-us.pdf",
        "body": "By calling the initialize and deploy functions to initialize the contracts, there is a potential issue that malicious attackers preemptively call the initialize function to initialize. ",
        "labels": [
            "SlowMist",
            "Ring Protocol",
            "Type: Race Conditions Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - getBTC.pdf",
        "body": "1.In the TokenExchange contract, the owner role can set vaults mapping through the setVaults function. TokenExchange.sol#L74-L77 function setVaults(address valut, bool status) external onlyOwner { vaults[valut] = status; emit SetVaults(valut, status); } 2.In the TokenExchange contract, the owner role can set the Operator role address through the setOperator function; the owner's ownership can be transferred through the transferOwnership function. TokenExchange.sol#L90-L94,L95-L99 function transferOwnership(address newOwner) external onlyOwner { require(newOwner != address(0),\"Owner_Should_Not_Zero_Address\"); owner = newOwner; emit TransferOwnership(newOwner); } function setOperator(address newOp) external onlyOwner { operator = newOp; emit SetOperator(newOp); } 3.In the TokenExchange contract, the owner role can withdraw the ERC20 token in the contract through the withdrawERC20 function; the Native token in the contract can be withdrawn through the withdrawBTC function. TokenExchange.sol#L78-L82,L82-L88 function withdrawERC20(address tokenAddress, address receiver, uint256 amount) external onlyOwner { require(amount <= IERC20(tokenAddress).balanceOf(address(this)),\"Token_Not_Enough\"); SafeERC20.safeTransfer(IERC20(tokenAddress), receiver, amount); emit Withdrawn(tokenAddress, receiver, amount); } function withdrawBTC(address payable receiver, uint256 amount) external onlyOwner { require(amount <= address(this).balance,\"BTC_Not_Enough\"); (bool success, bytes memory returnData) = receiver.call{value: amount}(\"\"); require(success, string(returnData)); emit Withdrawn(address(0), receiver, amount); }",
        "labels": [
            "SlowMist",
            "getBTC",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Missing zero address check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - getBTC.pdf",
        "body": "In the TokenExchange contract, the withdrawBTC function and setOperator function lack zero address check. TokenExchange.sol#L83-L88,L95-L98 function withdrawBTC(address payable receiver, uint256 amount) external onlyOwner { require(amount <= address(this).balance,\"BTC_Not_Enough\"); (bool success, bytes memory returnData) = receiver.call{value: amount}(\"\"); require(success, string(returnData)); emit Withdrawn(address(0), receiver, amount); } function setOperator(address newOp) external onlyOwner { operator = newOp; emit SetOperator(newOp); }",
        "labels": [
            "SlowMist",
            "getBTC",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Variable names are the same",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - getBTC.pdf",
        "body": "The private string variable _name dened in the TokenExchange contract has the same name as the private immutable string _name inherited from the EIP712 contract. TokenExchange.sol#L19 string private _name; EIP712.sol#L49 ShortString private immutable _name;",
        "labels": [
            "SlowMist",
            "getBTC",
            "Type: Others",
            "Severity: Information"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - peg-Token.pdf",
        "body": "1.The PegToken contracts and the TokenManager contract are implemented using the OpenZeppelin upgradeable model, allowing the AdminRole role to perform contract upgrades. In the TokenManager contract, the Operator role can upgrade the specied PegToken contract through the upgradeToken function.However, this design introduces an excessive privilege risk. TokenManager.sol#L123-L131 function upgradeToken(string memory symbol, address newImpl, bytes memory callData) external onlyRole(Operator) { require(newImpl != address(0), \"invalid new impl\"); PegToken peg = getDeployedTokenOrRevert(symbol); peg.upgradeToAndCall(newImpl, callData); } 2.In the TokenManager contract, the Operator role can call the setBlacklist function of the specied PegToken contract through the setBlackList function to add a blacklist address. TokenManager.sol#L79-L87 function setBlackList(string memory symbol, address account, bool toBlacklist) external onlyRole(Operator) { require(account != address(0), \"invalid account\"); PegToken peg = getDeployedTokenOrRevert(symbol); peg.setBlacklist(account, toBlacklist); } PegToken.sol#L86-L92 function setBlacklist(address account, bool toBlacklist) external onlyManager { isBlacklist[account] = toBlacklist; emit BlacklistAdded(account, toBlacklist); } 3.In the TokenManager contract, the Operator role can add the Minter role by calling the setMinter function of the specied PegToken contract through the setMinter function. TokenManager.sol#L89-L97 function setMinter(string memory symbol, address account, bool asMinter) external onlyRole(Operator) { require(account != address(0), \"invalid account\"); PegToken peg = getDeployedTokenOrRevert(symbol); peg.setMinter(account, asMinter); } PegToken.sol#L94-L100 function setMinter(address account, bool asMinter) external onlyManager { minters[account] = asMinter; emit MinterSet(account, asMinter); } 4.In the PegToken contract, the Minter role can mint any number of tokens by calling the mint function through the mint function. PegToken.sol#L112-L118 function mint(address to, uint256 amount) external onlyMinter notBlacklisted(to) { _mint(to, amount); } 5.In the TokenManager contract, the FreezeRole role can perform transfer operations by calling the recall function of the specied PegToken contract through the recall function. TokenManager.sol#L159-L165 function recall(string memory symbol, address from, address to, uint256 value) external onlyRole(FreezeRole) { PegToken peg = getDeployedTokenOrRevert(symbol); peg.recall(from, to, value); } PegToken.sol#L120-L126 function recall(address from, address to, uint256 value) external onlyManager { _transfer(from, to, value); emit TokenRecalled(from, to, value); } 6.In the TokenManager contract, the FreezeRole role can freeze the specied token at the specied address by calling the freeze function of the specied PegToken contract through the freezeToken function. TokenManager.sol#L143-L149 function freezeToken(string memory symbol, address account, uint256 value) external onlyRole(FreezeRole) { PegToken peg = getDeployedTokenOrRevert(symbol); peg.freeze(account, value); } PegToken.sol#L128-L136 function freeze(address account, uint256 value) external onlyManager { _transfer(account, address(this), value); freezedToken[account] += value; emit TokenFreezed(account, value); }",
        "labels": [
            "SlowMist",
            "peg-Token",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "DoS issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Flurry Bridge_en-us.pdf",
        "body": "The getVoteCount function uses a for loop to count members votes. When the number of members is large, it will cause DoS due to the increased number of for loops. bridge/contracts/contracts/Federation.sol#L242-L249 function getVoteCount(bytes32 processId) public view override returns(uint) { uint count = 0; for (uint i = 0; i < members.length; i++) { if (votes[processId][members[i]]) count += 1; } return count; }",
        "labels": [
            "SlowMist",
            "Flurry Bridge",
            "Type: Denial of Service Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Safety Reminders",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Flurry Bridge_en-us.pdf",
        "body": "To capture events in the cross-chain bridge, the implementation of subscribing to the events of the specied contract should be adopted to avoid the attacks of fake contract events.",
        "labels": [
            "SlowMist",
            "Flurry Bridge",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Limit of value range",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Flurry Bridge_en-us.pdf",
        "body": "Owner can set fee arbitrarily, and there is no restriction on the value range. and the fee variable is not used in the contract code. bridge/contracts/contracts/Registry.sol#L87-L91 function setFee(address localaddr_, uint256 fee_) external override onlyOwner { require(fee_ > 0, \"Registry: Fee Should be> 0\"); fee[localaddr_] = fee_; emit FeeChanged(localaddr_, fee_); } 8",
        "labels": [
            "SlowMist",
            "Flurry Bridge",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Useless code",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Flurry Bridge_en-us.pdf",
        "body": "There are a lot of comment codes in the contract. It is necessary to conrm whether the comment codes are redundant codes. bridge/contracts/contracts/Registry.sol#L43-L85 // function registerCall( // uint256 alienChainId_, // address alienChainContractAddr_, // address localChainContractAddr_, // bytes4 callSig_ // ) external onlyOwner { // bytes32 callRegistryID = Utils.getCallRegistryId( // alienChainId_, // alienChainContractAddr_, // localChainContractAddr_, // callSig_ // ); // require(!callRegistry[callRegistryID], \"Registry: Call already exists in callRegistry\"); // callRegistry[callRegistryID] = true; // emit CallRegistered( // alienChainId_, // alienChainContractAddr_, // localChainContractAddr_, // callSig_ // ); // } // function unregisterCall( 9 // uint256 alienChainId_, // address alienChainContractAddr_, // address localChainContractAddr_, // bytes4 callSig_ // ) external onlyOwner { // bytes32 callRegistryID = Utils.getCallRegistryId( // alienChainId_, // alienChainContractAddr_, // localChainContractAddr_, // callSig_ // ); // require(callRegistry[callRegistryID], \"Registry: Call not registered\"); // delete callRegistry[callRegistryID]; // emit CallUnregistered( // alienChainId_, // alienChainContractAddr_, // localChainContractAddr_, // callSig_ // ); // } bridge/contracts/contracts/Federation.sol#L159-L240 // function voteCall( // uint256 srcChainID_, // address srcChainContractAddress_, // address dstChainContractAddress_, // bytes32 transactionHash_, // uint32 logIndex_, // bytes calldata payload // ) external override onlyMember { // if (bridge.isCallProcessed( // srcChainID_, // srcChainContractAddress_, // dstChainContractAddress_, // transactionHash_, // logIndex_, // payload // )) { // return; // } // bytes32 callId = Utils.getCallId( 10 // srcChainID_, // srcChainContractAddress_, // dstChainContractAddress_, // transactionHash_, // logIndex_, // payload // ); // if (votes[callId][_msgSender()]) // return; // votes[callId][_msgSender()] = true; // emit VotedCall( // srcChainID_, // srcChainContractAddress_, // dstChainContractAddress_, // transactionHash_, // logIndex_, // _msgSender(), // callId, // payload // ); // uint voteCount = getVoteCount(callId); // if ((voteCount >= required) && (voteCount >= members.length / 2 + 1)) { // bridge.acceptCall( // srcChainID_, // srcChainContractAddress_, // dstChainContractAddress_, // transactionHash_, // logIndex_, // payload // ); // emit ExecutedCall(callId); // } // } // function hasVotedCall( // uint256 srcChainID_, // address srcChainContractAddress_, // address dstChainContractAddress_, // bytes32 transactionHash_, // uint32 logIndex_, // bytes calldata payload // ) external view override returns(bool) { // bytes32 callId = Utils.getCallId( 11 // srcChainID_, // srcChainContractAddress_, // dstChainContractAddress_, // transactionHash_, // logIndex_, // payload // ); // return votes[callId][_msgSender()]; // } // function isCallProcessed( // uint256 srcChainID_, // address srcChainContractAddress_, // address dstChainContractAddress_, // bytes32 transactionHash_, // uint32 logIndex_, // bytes calldata payload // ) external view override returns(bool) { // return bridge.isCallProcessed(srcChainID_, srcChainContractAddress_, dstChainContractAddress_, transactionHash_, logIndex_, payload); // } bridge/contracts/contracts/Bridge.sol#L114-L154 // function acceptCall( // uint256 srcChainID_, // address srcChainTokenAddress_, // address dstChainTokenAddress_, // bytes32 transactionHash_, // uint32 logIndex_, // bytes calldata payload // ) external override onlyFederation nonReentrant { // require(dstChainTokenAddress_ != address(0), \"Bridge: destination chain token address is null\"); // require(srcChainTokenAddress_ != address(0), \"Bridge: src chain token address is null\"); // require(transactionHash_ != bytes32(0), \"Bridge: Transaction is null\"); // require(srcChainTokenAddress_ != address(0), \"src token address is null\"); // bytes4 sig = // payload[0] | // (bytes4(payload[1]) >> 8) | // (bytes4(payload[2]) >> 16) | // (bytes4(payload[3]) >> 24); 12 // bytes32 callRegistryID = Utils.getCallRegistryId( // srcChainID_, // srcChainTokenAddress_, // dstChainTokenAddress_, // sig // ); // require(tokenRegistry.callRegistry(callRegistryID), \"Call Not Registered\"); // bytes32 callId = Utils.getCallId( // srcChainID_, // srcChainTokenAddress_, // dstChainTokenAddress_, // transactionHash_, // logIndex_, // payload // ); // require(processed[callId] == 0, \"Bridge: Already processed\"); // processed[callId] = block.number; // // call the function // (bool success, ) = dstChainTokenAddress_.call(payload); // require(success, \"call fail\"); // } bridge/contracts/libraries/Utils.sol#L6-L18 // function getCallRegistryId( // uint256 alienChainId_, // address alienChainContractAddr_, // address localChainContractAddr_, // bytes4 callSig_ // ) internal pure returns(bytes32) { // return keccak256(abi.encodePacked( // alienChainId_, // alienChainContractAddr_, // localChainContractAddr_, // callSig_ // )); // } 13 bridge/contracts/libraries/Utils.sol#L50-L67 // function getCallId( // uint256 srcChainID_, // address srcChainTokenAddress_, // address dstChainTokenAddress_, // bytes32 transactionHash_, // uint32 logIndex_, // bytes calldata payload // ) internal pure returns (bytes32) { // return keccak256(abi.encodePacked( // \"Call\", // srcChainID_, // srcChainTokenAddress_, // dstChainTokenAddress_, // transactionHash_, // logIndex_, // payload // )); // }",
        "labels": [
            "SlowMist",
            "Flurry Bridge",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Redundant Code Usage",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm_Phase5_en-us.pdf",
        "body": "In the Vault contract of ENFv3/ENF_lowrisk_farm/ENF_lowrisk_ETH_farm, the user will rst calculate the share when performing the withdraw operation. But it is calculated in the same way as the convertToShares function, so it is not necessary to use duplicate code for the calculation without using the convertToShares function. ",
        "labels": [
            "SlowMist",
            "Earning.Farm_Phase5",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Potential Precision Calculation Issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm_Phase5_en-us.pdf",
        "body": "In the Vault contract of ENFv3/ENF_lowrisk_farm/ENF_lowrisk_ETH_farm, users can burn shares through the redeem function to get back staked assets. It uses (shares * assetsPerShare()) / 1e24 to calculate the number of assets corresponding to the share, and the assetsPerShare function will multiply (assetDecimal * 1e18) when performing calculations. If assetDecimal is not equal to 6, dividing 1e24 when performing assets calculation will cause the decimal of the result to deviate. ",
        "labels": [
            "SlowMist",
            "Earning.Farm_Phase5",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Business logic aws in reward distribution",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm_Phase5_en-us.pdf",
        "body": "In the Vault contract of ENF_lowrisk_farm/ENF_lowrisk_ETH_farm, users can obtain shares through deposits, and receive harvest dividends according to the amount of shares held. The key to reward calculation is the accRewardPerTokens and prevBalace parameters. The owner role will increase the accRewardPerTokens parameter every time the harvest operation is performed, and prevBalace represents the user's share balance before reward settlement. But there will be a way to collect rewards by front-run deposits to improve the eciency of capital utilization: When the owner role performs the harvest operation, the user deposits at a higher gas fee. At this point the accRewardPerShares of the protocol has not been updated, and the user will get a portion of the shares. Then the owner performs the harvest operation, and the accRewardPerShares of the protocol will increase. Finally the user makes withdrawal and gets reward. Malicious users can use this method to obtain rewards in the blocks before and after the harvest operation, or even in the same block, without worrying about the problem of liquidity being locked in the protocol, which improves the utilization rate of funds. ",
        "labels": [
            "SlowMist",
            "Earning.Farm_Phase5",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Token Transfer Missing Rewards Update",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm_Phase5_en-us.pdf",
        "body": "In the Vault contract of ENF_lowrisk_farm/ENF_lowrisk_ETH_farm, the _updateUserData function is used to update the user's reward, but it is not updated when the user's share is transferred. This will result in accounting errors during share token transfers. Users can steal rewards by continuously transferring share tokens to new addresses. ",
        "labels": [
            "SlowMist",
            "Earning.Farm_Phase5",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Issue with checking on fromToken",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm_Phase5_en-us.pdf",
        "body": "In the vault contract of ENF_lowrisk_farm/ENF_lowrisk_ETH_farm, the _swap function is used to exchange reward tokens for the specied toToken. It will check whether fromToken is WETH, if the check is true, it will be exchanged through the swapExactETHInput function, if the check is false, it will be exchanged through swapExactTokenInput. However, when fromToken is address(0), the token exchange will also be performed through the swapExactTokenInput function, which may cause the _swap function to fail to perform as expected. ",
        "labels": [
            "SlowMist",
            "Earning.Farm_Phase5",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Incorrect reward receiving address",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm_Phase5_en-us.pdf",
        "body": "In the Vault contract of ENF_lowrisk_farm/ENF_lowrisk_ETH_farm, users can claim rewards through the claim function and specify the receiving address of the rewards. When toAsset is false, the protocol will issue the reward directly to the user, but the destination address of the reward is not the receiver address specied by the user but msg.sender. This is not as expected. ",
        "labels": [
            "SlowMist",
            "Earning.Farm_Phase5",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Direct distribution of rewards is not available",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm_Phase5_en-us.pdf",
        "body": "In the Vault contract of ENF_lowrisk_farm/ENF_lowrisk_ETH_farm, users can claim rewards through the claim function. When toAsset is false, the protocol will directly issue rewards to users. The safeTransferFrom function is used to transfer tokens when issuing rewards, but the contract has not been approved before. This will cause the contract to be unable to successfully execute the safeTransferFrom operation due to insucient allowances, and ultimately result in failure to issue rewards. ",
        "labels": [
            "SlowMist",
            "Earning.Farm_Phase5",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of price manipulation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm_Phase5_en-us.pdf",
        "body": "In the stETH contract of ENF_lowrisk_ETH_farm, the slippage check of SS depends on the virtual price (get_virtual_price) of Curve Pool, which will be aected by the reentrancy vulnerability of ETH/stETH Pool (please check to Ref[1][2]). Failure to check for slippage will result in malicious theft of funds from the strategy. Ref: [1] https://chainsecurity.com/curve-lp-oracle-manipulation-post-mortem/ [2] https://chainsecurity.com/heartbreaks-curve-lp-oracles/",
        "labels": [
            "SlowMist",
            "Earning.Farm_Phase5",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "4.2.1.1 __Guard_init function was not call when initialize",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Hot Cross BSC Bridge V1.0.1_en-us.pdf",
        "body": "ForeignProcessor contract and HomeRequest contract are inherit the Guard contract but dost not call the __Gurad_init function function __ForeignProcessor_init( IERC20 token, ValidatorRegistry validatorRegistry_ ) internal initializer { //SlowMist// Missing call of __Guard_init function require( address(token) != address(0) && Misc.isContract(address(token)), \"ForeignProcessor:Invalid erc20 address provided\" 10 ); require( address(validatorRegistry_) != address(0) && Misc.isContract(address(validatorRegistry_)), \"ForeignProcessor:Invalid validator registry address\" ); erc20 = token; validatorRegistry = validatorRegistry_; } function __HomeRequest_init( BEP20 token, ValidatorRegistry validatorRegistry_ ) internal initializer { //SlowMist// Missing call of __Guard_init function require( address(token) != address(0) && Misc.isContract(address(token)), \"HomeRequest:Invalid BEP20 address\" ); require( address(validatorRegistry_) != address(0) && Misc.isContract(address(validatorRegistry_)), \"HomeRequest:Invalid validator registry address\" ); bep20 = token; validatorRegistry = validatorRegistry_; } Fix status: fixed. 11 5.",
        "labels": [
            "SlowMist",
            "Hot Cross BSC Bridge V1.0.1",
            "Severity: Informational"
        ]
    },
    {
        "title": "Access control issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - CheersUp_alpha8_en-us.pdf",
        "body": "The Owner role has the right to call the giveaway function to airdrop any number of blind boxes to any address at any time. function giveaway(address address_, uint64 numberOfTokens_) external onlyOwner nonReentrant { require(address_ != address(0), \"zero address\"); require(numberOfTokens_ > 0, \"invalid number of tokens\"); require(totalMinted() + numberOfTokens_ <= MAX_TOKEN, \"max supply exceeded\"); _safeMint(address_, numberOfTokens_); } The Owner role has the right to modify the cucpContractAddress contract address through the setCUCPContractAddress function, and unauthorized modication will result in the user's blind box being unable to be opened or arbitrarily modifying the blind box. function setCUCPContractAddress(address address_) public onlyOwner { cucpContractAddress = address_; } The Owner role has the right to modify the price of the blind box purchased by the user through the setWhitelistSaleCong function and the setPublicSaleCong function at any time. If the price of the blind box is modied after the sale starts, the user's transaction will fail. function setWhitelistSaleConfig(WhitelistSaleConfig calldata config_) external onlyOwner { require(config_.price > 0, \"sale price must greater than zero\"); whitelistSaleConfig = config_; } 9 function setPublicSaleConfig(PublicSaleConfig calldata config_) external onlyOwner { require(config_.price > 0, \"sale price must greater than zero\"); publicSaleConfig = config_; } The Owner has the right to modify the revealCong parameter through the setRevealCong function, which includes the address of the contract that opens the blind box, and the time and closing time of the blind box sale. function setRevealConfig(RevealConfig calldata config_) external onlyOwner { revealConfig = config_; }",
        "labels": [
            "SlowMist",
            "CheersUp_alpha8",
            "Type: Authority Control Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Random number problem",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - CheersUp_alpha8_en-us.pdf",
        "body": "The tokenId in the contract is related to the properties of the NFT. The tokenId is randomly generated through the random number on the chain, which will cause the random number to be predicted. function mint(address address_, uint256 cucpTokenId_) public returns(uint256) { require(_msgSender() == cucpContractAddress, \"not authorized\"); 10 require(_numberMinted + 1 <= MAX_TOKEN, \"mint would exceed max supply\"); uint256 tokenId = randomToken(address_); _safeMint(address_, tokenId); unchecked { _numberMinted += 1; } emit CheersUpRevealed(cucpTokenId_, tokenId); return tokenId; } function getRandomTokenId() internal returns (uint256) { unchecked { uint256 remain = MAX_TOKEN - _numberMinted; uint256 pos = unsafeRandom() % remain; uint256 val = _randIndices[pos] == 0 ? pos : _randIndices[pos]; _randIndices[pos] = _randIndices[remain - 1] == 0 ? remain - 1 : _randIndices[remain - 1]; return val; } } /** * @notice unsafeRandom is used to generate a random number by on-chain randomness. * Please note that on-chain random is potentially manipulated by miners, and most scenarios suggest using VRF. * @return randomly generated number. */ function unsafeRandom() internal view returns (uint256) { unchecked { return uint256(keccak256(abi.encodePacked( blockhash(block.number-1), block.difficulty, block.timestamp, _numberMinted, tx.origin ))); } }",
        "labels": [
            "SlowMist",
            "CheersUp_alpha8",
            "Type: Others",
            "Severity: Low"
        ]
    },
    {
        "title": "4.3.1.1 Risk of Oracle Manipulation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Shield_en-us.pdf",
        "body": "In DDSContracts, the price is obtained from Uniswap's getAmountsIn through the getPriceByWBTCDAI function, but this interface obtains the real-time price of the WBTC/DAI pool, and there is a risk of malicious manipulation. 6 Fix suggestion: It is recommended to use Uniswap's delayed price feed oracle for acquisition. ",
        "labels": [
            "SlowMist",
            "Shield",
            "Severity: Critical"
        ]
    },
    {
        "title": "4.3.1.2 Price acquisition issue when opening and closing positions",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Shield_en-us.pdf",
        "body": "In the DDSContracts contract, the price used when opening and closing a position is passed in from the outside, which will cause the user to pass in any price when opening and closing a position. After communicating with the project party, this is the test code, and the oracle will be used to feed the price during the formal deployment. Fix suggestion: It is recommended to use Uniswap's delayed price feed oracle for acquisition. ",
        "labels": [
            "SlowMist",
            "Shield",
            "Severity: Critical"
        ]
    },
    {
        "title": "4.3.2.1 The available funds were not processed when the riskControl",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Shield_en-us.pdf",
        "body": "closed the position In the Pool contract, when riskClose is triggered when the risk control liquidation is triggered, if the margin is insufficient and the pool order transfer fails, risk funds will be used to make up for the insufficient part, and all available funds of the user will be deducted. However, the user's available funds are not actually set to 0. Fix suggestion: It is recommended that the available funds should be emptied after the transfer of insurance funds. ",
        "labels": [
            "SlowMist",
            "Shield",
            "Severity: High"
        ]
    },
    {
        "title": "4.3.3.1 Insecure random number",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Shield_en-us.pdf",
        "body": "In the Pool contract, the getMatchLp2Object function uses block difficulty and block time now as the random number seed to participate in the calculation of random numbers. But block difficulty and time can be predicted or manipulated. Fix suggestion: It is recommended to use the random number provided by chainlink that cannot be manipulated. ",
        "labels": [
            "SlowMist",
            "Shield",
            "Severity: Low"
        ]
    },
    {
        "title": "4.3.4.1 Event missing",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Shield_en-us.pdf",
        "body": "In the DDSContracts contract, the owner can set the key parameters of the contract through the setExchageAddress, setPoolTokenAddr, setPrivatePool, setPublicPool, setFormular, and setrepayFudAddr functions, but no event recording is performed. Fix suggestion: In order to facilitate follow-up records and community viewing, it is recommended to record events for sensitive parameter modifications. ",
        "labels": [
            "SlowMist",
            "Shield",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.3.4.2 Does not follow the `Checks-effects-interactions` model",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Shield_en-us.pdf",
        "body": "In Contracts and Pool2 contracts, when deposit and provide functions are used to recharge, the state is changed first, and then the corresponding tokens are transferred to the contract. Fix suggestion: It is recommended to follow the Checks-effects-interactions model, first transfer the corresponding tokens and then change the state. 10 ",
        "labels": [
            "SlowMist",
            "Shield",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.3.4.3 Redundant code",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Shield_en-us.pdf",
        "body": "Provide price feed interfaces such as updateImpliedVolrate and updatePriceByOwner in the DDSFormular contract to update the price. However, these interfaces are not used by the Contracts contract, and these price-feeding interfaces have no permission control and can be called by any user. 11 Fix suggestion: If this interface is a test interface, it is recommended to remove it during formal deployment. If it will use the suggestions in subsequent iterations for permission control. ",
        "labels": [
            "SlowMist",
            "Shield",
            "Severity: Informational"
        ]
    },
    {
        "title": "Potential denial of service risk due to gulp operations",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase5 - SlowMist Audit Report.pdf",
        "body": "- - - - - - - - - - - - - - - - - In the Actions contract, when the user performs the autoJoinSmartPool operation, the number of shares the user can obtain will be calculated through the _calculateShare function, and minPoolAmountOut will be checked at the end. The _calculateShare function obtains the number of tokens recorded in the pool through bPool's getBalance when calculating the share, but unfortunately any user can update this parameter through bPool's gulp function. Therefore, when an ordinary user performs an autoJoinSmartPool operation, a malicious user directly transfers funds to bPool and calls the gulp function to update the token balance recorded in the pool. At this time, ordinary users will not be able to successfully add liquidity due to the minPoolAmountOut check. If the minPoolAmountOut value passed in by an ordinary user is 0, it may cause an interest rate ination attack. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase5 - SlowMist Audit Report",
            "Type: Denial of Service Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Incorrect event logging",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase5 - SlowMist Audit Report.pdf",
        "body": "In the CRP contract, the createPool function adds the creator parameter as the real creator of the pool. However, the corresponding events were not modied accordingly. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase5 - SlowMist Audit Report",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Incorrect WETH address",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase5 - SlowMist Audit Report.pdf",
        "body": "The WETH address constant is hard-coded in the Actions contract, but this address is an EOA address on the Ethereum mainnet and is not the correct WETH address. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase5 - SlowMist Audit Report",
            "Type: Others",
            "Severity: High"
        ]
    },
    {
        "title": "Incorrect poolTokens check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase5 - SlowMist Audit Report.pdf",
        "body": "In the autoJoinSmartPool function of the Actions contract, it checks the tokens deposited by the user through poolTokens[i] == handleToken , but handleToken has been replaced by the issueToken parameter during the native token checking phase. Therefore, the poolTokens[i] == handleToken check is not accurate. If handleToken is WETH, it will cause an error in the _makeSwap operation. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase5 - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Redundant STBT token check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase5 - SlowMist Audit Report.pdf",
        "body": "In the autoJoinSmartPool and _exit functions of the Actions contract, when making a token transfer, it will be checked whether the transferred token is an STBT token. But in fact, the protocol does not allow deposits of STBT tokens, and STBT tokens will also be converted into stablecoins after the ETF expires. Therefore, theoretically, there will be no STBT tokens in the contract, so the STBT token check is redundant. . ",
        "labels": [
            "SlowMist",
            "DeSyn Phase5 - SlowMist Audit Report",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Potential risk of slot conict",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase5 - SlowMist Audit Report.pdf",
        "body": "In this protocol iteration, both SmartPoolManager and Actions contracts have changed their storage structures. If these contracts use an upgradeable model, and upgrading the contract directly on the original basis may lead to contract storage slot conicts. In fact, the Actions contract is an upgradeable contract, so special attention should be paid to such risks.",
        "labels": [
            "SlowMist",
            "DeSyn Phase5 - SlowMist Audit Report",
            "Type: Variable Coverage Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of event forgery",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase5 - SlowMist Audit Report.pdf",
        "body": "In the CRP contract, the exitPool function adds a user parameter to record the real caller when the user exits through the Actions contract. However, users can also exit by calling the exitPool function of the CRP contract. They can pass in any user parameter to make the LogExit event record an incorrect value. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase5 - SlowMist Audit Report",
            "Type: Malicious Event Log Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Potential risk of denial of service due to large CRPFactory array",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase5 - SlowMist Audit Report.pdf",
        "body": "In the CRPFactory contract, when the Blabs role performs addCRPFactory and removeCRPFactory operations, it will use a for loop to traverse the entire CRPFactorys array. If the array length is too large, it will lead to DoS risks. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase5 - SlowMist Audit Report",
            "Type: Denial of Service Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Potential risk of endless loop",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase5 - SlowMist Audit Report.pdf",
        "body": "In the CRPFactory contract, the isCrp function is used to check whether the address passed by the user is a CRP contract. If not, the CRPFactorys array will be circulated and the isCrp function of other CRPFactory will be called to check. However, it should be noted that if the Blabs role adds this contract address to the CRPFactorys array, the user will fall into an innite loop error when querying a CRP address that is not recorded in this contract through the isCrp function. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase5 - SlowMist Audit Report",
            "Type: Denial of Service Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Potential Token Compatibility Issues",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/STONE BTC - SlowMist Audit Report_en-us.pdf",
        "body": "In the StoneBTCVault contract, users can deposit funds through the deposit/depositMultiple functions. The contract directly transfers the user-specied amount of wrapped BTC tokens using the safeTransferFrom function. It is important to note that the contract is not compatible with fee-on-transfer wrapped BTC tokens. Similarly, when users make deposits or withdrawals, the contract performs decimal conversion using 18- tokenDecimals[_token] . This renders the contract incompatible with any wrapped BTC tokens that have a decimal greater than 18. ",
        "labels": [
            "SlowMist",
            "STONE BTC - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Potential risk of not being able to collect fees",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/STONE BTC - SlowMist Audit Report_en-us.pdf",
        "body": "In the StoneBTCVault contract, users are charged a certain fee when making deposits or withdrawals. The fee amount is determined by amount * feeRate / FEE_BASE . Due to Solidity's division operation truncating the decimal part, if the user's deposit or withdrawal amount is relatively small, the calculated fee will be 0. This prevents the contract from collecting deposit/withdrawal fees. ",
        "labels": [
            "SlowMist",
            "STONE BTC - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Unnecessary unchecked",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/STONE BTC - SlowMist Audit Report_en-us.pdf",
        "body": "In the StoneBTCVault contract, all the for loop functionalities use unchecked for incrementing i to reduce gas consumption. However, the contract's Solidity compilation uses ^0.8.26 , and Solidity introduced the unchecked loop increments feature in version 0.8.22, making the use of unchecked unnecessary. ",
        "labels": [
            "SlowMist",
            "STONE BTC - SlowMist Audit Report",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of DoS when removing supported tokens",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/STONE BTC - SlowMist Audit Report_en-us.pdf",
        "body": "In the StoneBTCVault contract, privileged roles can add/remove supported wrapped BTC tokens through the addSupportedTokens/removeSupportedTokens functions. When performing the removeSupportedTokens operation, the contract checks that the balance of the token being removed must be zero. This can be easily exploited, as users can donate a small amount of tokens to prevent the removeSupportedTokens function from working properly. It is also important to note that when users withdraw, the contract converts the decimal to the decimal of the token being withdrawn. When the decimal of this token is smaller than the decimal of STONE BTC, there will always be a small amount of dust tokens left in the vault. This indirectly prevents the removeSupportedTokens function from working correctly. ",
        "labels": [
            "SlowMist",
            "STONE BTC - SlowMist Audit Report",
            "Type: Denial of Service Vulnerability",
            "Severity: High"
        ]
    },
    {
        "title": "The actual deposit amount may dier from the contract balance",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/STONE BTC - SlowMist Audit Report_en-us.pdf",
        "body": "In the StoneBTCVault contract, the _checkDepositAllowed function checks the depositCapacity based on the balance of wrapped BTC tokens in the contract. Similarly, the getDepositAmounts function retrieves token balances to determine the deposit amounts. These values may dier from the actual deposit amounts made by users. Users might accidentally transfer supported tokens into the vault, or some users might send small donations to the vault. Both scenarios will cause the above two functions to obtain amounts that are greater than the users' actual deposit amounts. ",
        "labels": [
            "SlowMist",
            "STONE BTC - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Not checking if withAmount is greater than 0 when retrieving all tokens",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/STONE BTC - SlowMist Audit Report_en-us.pdf",
        "body": "In the Proposal contract, users can retrieve all their STONE tokens used for voting through the retrieveAllToken function. It uses a temporary variable withAmount to record the amount of STONE tokens that can be withdrawn. However, it does not check if withAmount is greater than 0 before initiating the transfer, which may result in the contract sending a 0 transfer and wasting gas. ",
        "labels": [
            "SlowMist",
            "STONE BTC - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risks of excessive privilege",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/STONE BTC - SlowMist Audit Report_en-us.pdf",
        "body": "In the StoneBTC contract, the contract deployer is set as the DEFAULT_ADMIN_ROLE. The admin role can arbitrarily change the MINTER_ROLE/BURNER_ROLE roles, which are involved in minting and burning STONE BTC. This leads to the risk of excessive privileges. Similarly, in the StoneBTCVault and Proposal contracts, the initial DEFAULT_ADMIN_ROLE is also the deployer. Assigning sensitive permissions to an EOA address not only creates the risk of excessive privileges but also introduces a single point of failure. ",
        "labels": [
            "SlowMist",
            "STONE BTC - SlowMist Audit Report",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Low-level call issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - CFFv2_en-us.pdf",
        "body": "In the CRVExchangeV2 contract, the handleExtraToken function is used to perform the token transfer operation after the token swap. Low-level calls are used when transferring native tokens, but the amount of gas usage is not limited, which may lead to unknown security risks. ",
        "labels": [
            "SlowMist",
            "CFFv2",
            "Type: Others",
            "Severity: Low"
        ]
    },
    {
        "title": "Contract variable usage issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - CFFv2_en-us.pdf",
        "body": "In the IWbtcPoolBase contract, when the Controller role calls the deposit function, the deposit_wbtc_amount parameter will increase, but when the Controller role calls the withdraw function, the deposit_wbtc_amount parameter does not decrease accordingly. And the withdraw_wbtc_amount parameter in the contract is not used. 16 The deposit_eth_amount and withdraw_eth_amount parameters in the IETHPoolBase contract are the same. The deposit_usdc_amount and withdraw_usdc_amount parameters in the IUSDCPoolBase contract are the same. ",
        "labels": [
            "SlowMist",
            "CFFv2",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing event record",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - CFFv2_en-us.pdf",
        "body": "In the IWbtcPoolBase contract, the owner can modify the controller and vault addresses through the setController function, but no event recording is performed. ",
        "labels": [
            "SlowMist",
            "CFFv2",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Logical redundancy issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - CFFv2_en-us.pdf",
        "body": "In the AavePool contract, the withdraw_from_curve function will rst authorize the lp_token_addr token to the pool_deposit contract and then call the remove_liquidity_one_coin function of the pool_deposit contract to remove liquidity. However, since the minter role of the lp_token_addr contract is the pool_deposit contract, there is no need to perform an approve operation. ",
        "labels": [
            "SlowMist",
            "CFFv2",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Reentrancy risk 20",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - CFFv2_en-us.pdf",
        "body": "In the CFVaultV2 contract, the user can withdraw assets through the withdraw function, but in the withdraw function, it will rst transfer the assets to the user and then destroy the user's credentials through the destroyTokens function. If the transfer is native tokens, this will lead to a risk of reentrancy. ",
        "labels": [
            "SlowMist",
            "CFFv2",
            "Type: Reentrancy Vulnerability",
            "Severity: Critical"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - CFFv2_en-us.pdf",
        "body": "In the IWbtcPoolBase, IETHPoolBase and IUSDCPoolBase contracts, the owner can call any data through the callWithData function. Since these strategies contracts indirectly keep the user's assets, any data call will cause the risk of excessive owner authority. ",
        "labels": [
            "SlowMist",
            "CFFv2",
            "Type: Authority Control Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - TaprootChain - BTCLayer2Bridge_en-us.pdf",
        "body": "1.In the BTCLayer2Bridge contract, the superAdmin role is initialized in the initialize function and can be modied in the setSuperAdminAddress function. The superAdmin can also set the normalAdmin role through the setNormalAdminAddress function. ",
        "labels": [
            "SlowMist",
            "TaprootChain - BTCLayer2Bridge",
            "Type: Authority Control Vulnerability Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Receive can lock users native tokens",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - TaprootChain - BTCLayer2Bridge_en-us.pdf",
        "body": "There is a receive function in the BTCLayer2Bridge contract so that the contracts can receive native tokens. However, the receive function can lock users native tokens when users transfer the native token in these contracts by mistake. And the payable modier can help these functions which need to call with the native tokens. ",
        "labels": [
            "SlowMist",
            "TaprootChain - BTCLayer2Bridge",
            "Type: Others",
            "Severity: Low"
        ]
    },
    {
        "title": "Parameter _symbol is not case checked",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - TaprootChain - BTCLayer2Bridge_en-us.pdf",
        "body": "The _symbol eld of ERC20 tokens and ERC721 tokens on the Ethereum chain is case-sensitive, but for BRC20 Tick is not case-sensitive. In the BTCLayer2Bridge contract, the addERC20TokenWrapped function and the addERC721TokenWrapped function do not standardize the case format of the _symbol parameter passed in. ",
        "labels": [
            "SlowMist",
            "TaprootChain - BTCLayer2Bridge",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Delete the address without popping up the list",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - TaprootChain - BTCLayer2Bridge_en-us.pdf",
        "body": "In the addUnlockTokenAdminAddress function, the superAdmin and normalAdmin roles can add user address into the unlockTokenAdminAddressList and set the unlockTokenAdminAddressSupported to true. But in the delUnlockTokenAdminAddress function, the superAdmin and normalAdmin roles remove the unlockTokenAdminAddress just by setting the unlockTokenAdminAddressSupported to false without popping up from the unlockTokenAdminAddressList . Once called the delUnlockTokenAdminAddress function deletes the address, the superAdmin and normalAdmin roles can call the addUnlockTokenAdminAddress function to add the same address added before into the unlockTokenAdminAddressList and the length of the unlockTokenAdminAddressList will increase. ",
        "labels": [
            "SlowMist",
            "TaprootChain - BTCLayer2Bridge",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "SuperAdmin Transfer Recommendations",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - TaprootChain - BTCLayer2Bridge_en-us.pdf",
        "body": "In the BTCLayer2Bridge contract, superAdmin directly overwrites the previous address with the new address during transfer. If superAdmin calls the setSuperAdminAddress function with the wrong address when the operation is wrong, this will result in the loss of the superAdmin role permissions. ",
        "labels": [
            "SlowMist",
            "TaprootChain - BTCLayer2Bridge",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Low-level call reminder",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - TaprootChain - BTCLayer2Bridge_en-us.pdf",
        "body": "In the BTCLayer2Bridge contract, the burnERC20Token, batchBurnERC721Token, lockNativeToken, and unlockNativeToken use low-level calls to transfer native tokens to the feeAddress and to address from the unlockNativeToken function. But do not limit the amount of gas used to transfer native tokens to the user. ",
        "labels": [
            "SlowMist",
            "TaprootChain - BTCLayer2Bridge",
            "Type: Reentrancy Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Preemptive Initialization",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - TaprootChain - BTCLayer2Bridge_en-us.pdf",
        "body": "By calling the initialize and deploy functions to initialize the contracts, there is a potential issue that malicious attackers preemptively call the initialize function to initialize. ",
        "labels": [
            "SlowMist",
            "TaprootChain - BTCLayer2Bridge",
            "Type: Race Conditions Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Dev address setting enhancement suggestions",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - TaprootChain - BTCLayer2Bridge_en-us.pdf",
        "body": "In the contract, the superAdmin role can set the feeAddress to receive the fee. If the addfeeAddress is an EOA address, in a scenario where the private keys are leaked, the teams revenue will be stolen. ",
        "labels": [
            "SlowMist",
            "TaprootChain - BTCLayer2Bridge",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "External call reminder",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - TaprootChain - BTCLayer2Bridge_en-us.pdf",
        "body": "In the contract, the core functions mintERC20Token , burnERC20Token , batchMintERC721Token , batchBurnERC721Token , unlockNativeToken , and lockNativeToken , which are mainly used for fund interaction by unlockTokenAdminAddressSupported users, are all completed by external calls to bridgeERC20Address and bridgeERC721Address. The current contract also does complete verication of the incoming parameters txHash , _symbol , _baseURI , destBtcAddr , inscriptionNumbers , inscriptionIds , etc., and these verications may be completed by a centralized system or these external call contracts. This audit does not include centralized systems or external call contracts. Users need to pay attention to these external risks when calling these functions.",
        "labels": [
            "SlowMist",
            "TaprootChain - BTCLayer2Bridge",
            "Type: Unsafe External Call Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Excessive Authority Issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - wault.finance(WSwap)_en-us.pdf",
        "body": "The owner can set the value of wexPerBlock arbitrarily, which will affect the profit of wexReward, and there is no limit on the value range of wexPerBlock, and there is a issue of excessive authority. https://bscscan.com/address/0x22fB2663C7ca71Adc2cc99481C77Aaf21E152e2D function setWexPerBlock(uint256 _wexPerBlock) public onlyOwner { require(_wexPerBlock > 0, \"!wexPerBlock-0\"); wexPerBlock = _wexPerBlock; } Owner can add pool, can set the allocPoint of pool, there is a issue of selfish mining. function add( uint256 _allocPoint, IERC20 _lpToken, bool _withUpdate ) public onlyOwner { if (_withUpdate) { massUpdatePools(); } uint256 lastRewardBlock = block.number > startBlock ? block.number : startBlock; totalAllocPoint = totalAllocPoint.add(_allocPoint); poolInfo.push( PoolInfo({ lpToken: _lpToken, allocPoint: _allocPoint, lastRewardBlock: lastRewardBlock, accWexPerShare: 0 }) ); 12 function set( uint256 _pid, uint256 _allocPoint, bool _withUpdate ) public onlyOwner { if (_withUpdate) { massUpdatePools(); } totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add( _allocPoint ); poolInfo[_pid].allocPoint = _allocPoint; }",
        "labels": [
            "SlowMist",
            "wault.finance(WSwap)",
            "Type: Others",
            "Severity: Low"
        ]
    },
    {
        "title": "Ignoring the Return Value",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist_Audit_Report_StakeStone_SymbioticDepositWBETHStrategy_en-us.pdf",
        "body": "In the SymbioticDepositWBETHStrategy contract, the owner can extract the claimable ETH by calling the claimPendingAssets function. This function will call the claimWithdraw function of the UnwrapTokenV1ETH contract to claim the corresponding ETH by passing in a specic index. The claimWithDraw function returns a value (_ethAmount) after each call to represent the number of ETH claimed. Code Location: contracts/strategies/SymbioticDepositWBETHStrategy.sol#L176 function claimPendingAssets(uint256 _index) external onlyOwner { IUnwrapTokenV1ETH(unwrapTokenV1ETHAddr).claimWithdraw(_index); }",
        "labels": [
            "SlowMist",
            "SlowMist_Audit_Report_StakeStone_SymbioticDepositWBETHStrategy",
            "Type: Others",
            "Severity: Information"
        ]
    },
    {
        "title": "Unable to perform uniswapV3FlashCallback operation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn ETH Flashloan Leverage Staking - SlowMist Audit Report.pdf",
        "body": "In LeverageStake contracts, the uniswapV3FlashCallback function is called by the Uniswap v3 Pool ash function. It will call the repayBorrow/withdraw/deposit function within the LeverageStake contract to interact with the AAVE. However, the repayBorrow/withdraw/deposit function uses _checkTx for permission checking and can only be called by the admin role. This will result in the Uniswap v3 Pool not being able to call back to the uniswapV3FlashCallback function properly. ",
        "labels": [
            "SlowMist",
            "DeSyn ETH Flashloan Leverage Staking - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Potential liquidation risk caused by unrestricted ash loan leverage",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn ETH Flashloan Leverage Staking - SlowMist Audit Report.pdf",
        "body": "In LeverageStake contracts, the user can ashloan from the Uniswap v3 Pool with the function createLeverByFlashloan in order to make deposits in AAVE for higher prots. Unfortunately the increaseLeverByFlashloan function does not check the amount of leverage on the current bPool debt. This allows a malicious caller to increase the leverage of the bPool with the increaseLeverByFlashloan function to bring the user's funds closer to the liquidation line. This puts the user's funds at risk of liquidation when the stETH price uctuates. ",
        "labels": [
            "SlowMist",
            "DeSyn ETH Flashloan Leverage Staking - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Flashloan function missing privilege control",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn ETH Flashloan Leverage Staking - SlowMist Audit Report.pdf",
        "body": "In the LeverageStake contract, any user can call the increaseLeverByFlashloan/decreaseLeverByFlashloan function. Malicious users can consume bPool funds through frequent calls, for example: exchange slippage leads to capital damage, frequent entry/exit of the AAVE pool leads to losses in fees, and frequent ash loans lead to losses in ash loan fees. Although this consumes gas for the malicious caller, it can reduce losses or even make a prot by arbitraging in the Curve Pool or providing liquidity in the Uniswap Pool. ",
        "labels": [
            "SlowMist",
            "DeSyn ETH Flashloan Leverage Staking - SlowMist Audit Report",
            "Type: Authority Control Vulnerability Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Allowing the free choice of isTrade leads to a potential risk of arbitrage",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn ETH Flashloan Leverage Staking - SlowMist Audit Report.pdf",
        "body": "The increaseLever/increaseLeverByFlashloan/convertToAstEth functions of the LeverageStake contract allow the user to freely choose whether or not to exchange ETH-stETH through the Curve Pool by passing in the isTrade parameter. Even though the contract has a slippage check via the defaultSlippage parameter, the user still has an arbitrage prot. ",
        "labels": [
            "SlowMist",
            "DeSyn ETH Flashloan Leverage Staking - SlowMist Audit Report",
            "Type: Reordering Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Allow any type of ETF to interact with AAVE",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn ETH Flashloan Leverage Staking - SlowMist Audit Report.pdf",
        "body": "In the _checkTx function of the LeverageStake contract, it uses if conditions to check the status of the ETF, which means that both open and closed ETFs can interact with AAVE. And for closed ETFs, it will no longer check whether the closed period of the pool has ended. This is dierent from the previous version's implementation. ",
        "labels": [
            "SlowMist",
            "DeSyn ETH Flashloan Leverage Staking - SlowMist Audit Report",
            "Type: Others",
            "Severity: Information"
        ]
    },
    {
        "title": "Risk of unintended claim operations",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - pufETH_en-us.pdf",
        "body": "In the PuerVault contract, Users can collect ETH tokens to be claimed in the lido withdrawal process by calling the claimWithdrawalsFromLido function. The normal expectation of this function is that the incoming requestIds parameter should be created by the initiateETHWithdrawalsFromLido function, and only then the lidoLockedETH variable will be deducted correctly. However, a malicious user can directly call requestWithdrawals function in lido to generate requestIds, and then call claimWithdrawalsFromLido function, lidoLockedETH will be deducted additionally, resulting in a normal claim operation failing due to insucient lidoLockedETH. The following scenarios can be used as a reference: 1. The contract has a total of 10 ETH total deposited in Lido, at which point a normal user calls the initiateETHWithdrawalsFromLido function to submit a request to withdraw 10 ETH($.lidoLockedETH = 10). 2. A malicious user calls requestWithdrawals function directly on Lido to generate a withdrawal request to withdraw 1 ETH(need to specify WithdrawalRequest._owner as puerVault). 3. The malicious user calls the claimWithdrawalsFromLido function and passes in the requestIds generated in step 2, the value of $.lidoLockedETH is equal to 9. 4. A normal user calls the claimWithdrawalsFromLido function and passes in the requestIds generated in the rst step, at which point the amount of ETH to be fetched is 10, while the value of $.lidoLockedETH is 9, which causes $.lidoLockedETH -= msg.value to overow and the entire transaction fails. 5. So the nal result is that 10 ETH cannot be successfully withdrawn through the puerVault contract. And this security risk also exists when withdrawing ETH from EigenLayer(Specify withdrawer as the puerVault address to achieve the same eect). ",
        "labels": [
            "SlowMist",
            "pufETH",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Authority transfer enhancement",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - pufETH_en-us.pdf",
        "body": "The pauserMultisig role does not adopt the pending and access processes. If the pauserMultisig is incorrectly set, the owner permission will be lost. ",
        "labels": [
            "SlowMist",
            "pufETH",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Gas optimization",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Laqira NFT marketplace_en-us.pdf",
        "body": "Using assert will consume the remaining gas when the transaction fails to execute. ",
        "labels": [
            "SlowMist",
            "Laqira NFT marketplace",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Unused return",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Laqira NFT marketplace_en-us.pdf",
        "body": "There is a return value in the setRoyalties function in the RoyaltiesProvider contract, and the function is called here without checking its return value. Laqira-Collectibles-and-NFT-Marketplace/contracts/LaqiraNFT.sol #L58-L76 function mint(string memory _tokenURI, address[] memory royaltyOwners, uint96[] memory values) public virtual payable { uint256 transferredAmount = msg.value; require(transferredAmount >= mintingFee, 'Insufficient paid amount'); (bool success, ) = feeAddress.call{value: transferredAmount}(new bytes(0)); 14 require(success, 'Transfer failed'); _tokenIds.increment(); uint256 newTokenId = _tokenIds.current(); pendingRequests.push(newTokenId); _pendingIds[newTokenId].owner = _msgSender(); _pendingIds[newTokenId].tokenURI = _tokenURI; _userPendingIds[_msgSender()].push(newTokenId); IRoyaltiesProvider(royaltiesProviderAddress).setRoyalties(newTokenId, royaltyOwners, values); }",
        "labels": [
            "SlowMist",
            "Laqira NFT marketplace",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing event record",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Laqira NFT marketplace_en-us.pdf",
        "body": "Modifying sensitive parameters in the contract does not log an event. Laqira-Collectibles-and-NFT-Marketplace/contracts/LaqiraNFT.sol #L123-L133 function setMintingFeeAmount(uint256 _amount) public virtual onlyOwner { mintingFee = _amount; } function setAsOperator(address _operator) public virtual onlyOwner { operators[_operator] = true; } function removeOperator(address _operator) public virtual onlyOwner { operators[_operator] = false; } 15 ",
        "labels": [
            "SlowMist",
            "Laqira NFT marketplace",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing zero address validation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Laqira NFT marketplace_en-us.pdf",
        "body": "Missing zero address validation when setting the address in the function. ",
        "labels": [
            "SlowMist",
            "Laqira NFT marketplace",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Redundant code",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - IHO V1.0.0_en-us.pdf",
        "body": "Ether is not accepted by default, which is a redundant code. cross-send/contracts/CrossSend.sol#L41-L47 initial-hotcross-oering/contracts/BaseIHO.sol#L67-L73 fallback () external payable { revert(\"cannot directly accept currency transfers\"); } receive () external payable { revert(\"cannot directly receive currency transfers\"); 15 }",
        "labels": [
            "SlowMist",
            "IHO V1.0.0",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Gas optimization",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - IHO V1.0.0_en-us.pdf",
        "body": "If one of the batch transfers fails, the transaction that was previously transferred normally will be reverted, but Gas has been consumed. It is a gas optimization issue here. cross-send/contracts/CrossSend.sol#L175-L210 function sendToken( IERC20 token, address[] memory recipients, uint256[] memory amounts ) private returns(uint256) { uint256 total = 0; for (uint256 i = 0; i < recipients.length ; i++) { require(_msgSender() != recipients[i], \"sender != recipient\"); token.safeTransferFrom(_msgSender(), recipients[i], amounts[i]); total += amounts[i]; } return total; } function sendNative( address[] memory recipients, uint256[] memory amounts ) private returns(uint256) { uint256 total = 0; 16 for (uint256 i = 0; i < recipients.length ; i++) { total += amounts[i]; (bool success, ) = payable(recipients[i]).call{value: amounts[i]}(\"\"); require(success, \"native transfer failed\"); } return total; }",
        "labels": [
            "SlowMist",
            "IHO V1.0.0",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of allowance amount abuse",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - IHO V1.0.0_en-us.pdf",
        "body": "There have an allowance amount in the contract, but the distributeTokenFee function does not limit the caller, and there is an issue of being called arbitrarily, but it can only transfer the balance of the sender to the feeCollector. cross-send/contracts/fee-managers/RecipientCountFee.sol#L65-L83 function distributeTokenFee( uint256 txRecipientCount, uint256, uint256, uint256, uint256, address sender ) public override { uint256 payableFee = txRecipientCount * tokenFeePerRecipient; 17 if(payableFee < minTokenFee) { payableFee = minTokenFee; } else if (payableFee > maxTokenFee) { payableFee = maxTokenFee; } token.safeTransferFrom(sender, feeCollector, payableFee); }",
        "labels": [
            "SlowMist",
            "IHO V1.0.0",
            "Type: Authority Control Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Price manipulation issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - IHO V1.0.0_en-us.pdf",
        "body": "The IOUPrice is calculated using totalFarmingTokenBalance. Attackers can control totalFarmingTokenBalance to manipulate IOUPrice. The current code does not nd the location where IOUPrice is used. Referencehttps://slowmist.medium.com/cream-hacked-analysis-us-130-million-hacked-95c9410320ca cross-yield/contracts/core/CrossYield.sol#L95-L101 function IOUPrice() public view returns (uint256) { uint256 IOUSupply = totalSupply(); return IOUSupply == 0 ? 1e18 : (totalFarmingTokenBalance() * 1e18) / IOUSupply; } 18 cross-yield/contracts/core/CrossYield.sol#L65-L67 function totalFarmingTokenBalance() public view returns (uint256) { return farmingToken().balanceOf(address(this)) + strategy.balanceOf(); }",
        "labels": [
            "SlowMist",
            "IHO V1.0.0",
            "Type: Others",
            "Severity: Medium"
        ]
    },
    {
        "title": "Sandwich attacks issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - IHO V1.0.0_en-us.pdf",
        "body": "There is no slippage check during swap, and there is a risk of sandwich attack. IPancakeRouter02(pcsRouter).swapExactTokensForTokens(cakeBalance, 0,cakeToBaseRoute, address(this), block.timestamp); IPancakeRouter02(pcsRouter) .swapExactTokensForTokens(toSwap, 0, route, address(this), block.timestamp); Reference https://medium.com/coinmonks/demystify-the-dark-forest-on-ethereum-sandwich-attacks-5a3aec9fa33e cross-yield/contracts/libs/OptimalSwap.sol#L14-L63 function prepareLiquidity( address cake, address[2] memory lpTokens, 19 address wbnb, address busd, address farmingToken, address pcsRouter, uint256 fee ) external { uint256 cakeBalance = IERC20(cake).balanceOf(address(this)); bool isCakeInLp = lpTokens[0] == cake || lpTokens[1] == cake; bool isWbnbBased = lpTokens[0] == wbnb || lpTokens[1] == wbnb; address baseToken = isWbnbBased ? wbnb : busd; // if cake is not part of the lp token, swap all cake for the base token if (!isCakeInLp) { address[] memory cakeToBaseRoute = new address[](2); cakeToBaseRoute[0] = cake; cakeToBaseRoute[1] = baseToken; IPancakeRouter02(pcsRouter) .swapExactTokensForTokens(cakeBalance, 0, cakeToBaseRoute, address(this), block.timestamp); } (uint256 reserve0, uint256 reserve1,) = IPancakePair(farmingToken).getReserves(); address[] memory route = new address[](2); uint256 lp0Bal = IERC20(lpTokens[0]).balanceOf(address(this)); uint256 lp1Bal = IERC20(lpTokens[1]).balanceOf(address(this)); uint256 toSwap; // The possible cases here are: // - Cake was not part of the LP token, so we swap for baseToken which could either be lpToken0 or lpToken // - Cake was part of the LP token, so it can either be lpTokens[0] or lpTokens[1] // So, depending on which token we have the highest balance for, we swap for the other one. if (lp0Bal > lp1Bal) { toSwap = SwapAmount.getSwapAmount(lp0Bal, reserve0, fee); route[0] = lpTokens[0]; route[1] = lpTokens[1]; } else { toSwap = SwapAmount.getSwapAmount(lp1Bal, reserve1, fee); route[0] = lpTokens[1]; route[1] = lpTokens[0]; 20 } // Perform the swap IPancakeRouter02(pcsRouter) .swapExactTokensForTokens(toSwap, 0, route, address(this), block.timestamp); } IPancakeRouter02(pcsRouter).swapExactTokensForTokens(toWbnb, 0, cakeToWbnbRoute, address(this), block.timestamp); cross-yield/contracts/strategies/StrategyCake.sol#L131 function collectFees() internal { // a percentant of the cake we get from the masterchef will be used to buy BNB and transfer to this address // this is the total fees that will be shared amongst the protocol, stategy dev and the harvester uint256 toWbnb = feeManager.calculateTotalFee(IERC20(farmingToken).balanceOf(address(this))); IPancakeRouter02(pcsRouter).swapExactTokensForTokens(toWbnb, 0, cakeToWbnbRoute, address(this), block.timestamp); uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this)); // distribute hervester fee uint256 harvesterFeeAmount = feeManager.calculateHarvestFee(wbnbBal); // collectFees is called indirectly from the CrossYield contract via the beforeDeposit hook. // This means that _msgSender() is the CrossYield contract and not the actuall EOA account // that send the transaction IERC20(wbnb).safeTransfer(tx.origin, harvesterFeeAmount); // distribute protocol fee uint256 protocolFeeAmount = feeManager.calculateProtocolFee(wbnbBal); // IERC20(wbnb).safeTransfer(protocolFeeRecipient, protocolFeeAmount); feeProcessor.process(protocolFeeAmount); // distribute strategy dev fee uint256 strategyDevFeeAmount = feeManager.calculateStrategyDevFee(wbnbBal); IERC20(wbnb).safeTransfer(feeManager.strategyDev(), strategyDevFeeAmount); emit FeeCollected( toWbnb, 21 harvesterFeeAmount, protocolFeeAmount, strategyDevFeeAmount, _msgSender() ); } cross-yield/contracts/strategies/StrategyCakeLP.sol#L174 function collectFees() internal { // a percentant of the cake we get from the masterchef will be used to buy BNB and transfer to this address // this is the total fees that will be shared amongst the protocol, stategy dev and the harvester uint256 toWbnb = feeManager.calculateTotalFee(IERC20(cake).balanceOf(address(this))); IPancakeRouter02(pcsRouter).swapExactTokensForTokens(toWbnb, 0, cakeToWbnbRoute, address(this), block.timestamp); uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this)); // distribute hervester fee uint256 harvesterFeeAmount = feeManager.calculateHarvestFee(wbnbBal); IERC20(wbnb).safeTransfer(_msgSender(), harvesterFeeAmount); // distribute protocol fee uint256 protocolFeeAmount = feeManager.calculateProtocolFee(wbnbBal); feeProcessor.process(protocolFeeAmount); // distribute strategy dev fee uint256 strategyDevFeeAmount = feeManager.calculateStrategyDevFee(wbnbBal); IERC20(wbnb).safeTransfer(feeManager.strategyDev(), strategyDevFeeAmount); emit FeeCollected( toWbnb, harvesterFeeAmount, protocolFeeAmount, strategyDevFeeAmount, _msgSender() ); } cross-yield/contracts/strategies/StrategyCake.sol 22 function harvest() public override whenNotPaused { // claim rewards IMasterChef(masterchef).leaveStaking(0); // because harvest can automatically be called after each user deposit // we might end up having multiple deposits in the same block and only one // would return rewards from masterchef so the rest will have 0 cake so // we don't need to waste gas to collect fees and call deposit uint256 farmingTokenBalance = balanceOfFarmingToken(); if(farmingTokenBalance > 0) { collectFees(); deposit(); emit HarvestTriggered(_msgSender(), farmingTokenBalance); } } cross-yield/contracts/strategies/StrategyCakeLP.sol#l137-L148 function harvest() external override whenNotPaused { // claim rewards IMasterChef(masterchef).deposit(poolId, 0); uint256 harvestedAmount = IERC20(cake).balanceOf(address(this)); collectFees(); addLiquidity(); deposit(); emit HarvestTriggered(_msgSender(), harvestedAmount); }",
        "labels": [
            "SlowMist",
            "IHO V1.0.0",
            "Type: Reordering Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Missing slippage check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - IHO V1.0.0_en-us.pdf",
        "body": "The addLiquidity function without slippage check, it doesn't have an impermanent loss check. cross-yield/contracts/strategies/StrategyCakeLP.sol#L218 function addLiquidity() internal { OptimalSwap.prepareLiquidity( cake, [lpToken0, lpToken1], wbnb, busd, farmingToken, pcsRouter, swapFee ); // add liquidity to AMM on PCS uint256 lp0Bal = IERC20(lpToken0).balanceOf(address(this)); uint256 lp1Bal = IERC20(lpToken1).balanceOf(address(this)); IPancakeRouter02(pcsRouter) .addLiquidity(lpToken0, lpToken1, lp0Bal, lp1Bal, 0, 0, address(this), block.timestamp); emit LiquidityAdded(lpToken0, lpToken1, lp0Bal, lp1Bal, _msgSender()); }",
        "labels": [
            "SlowMist",
            "IHO V1.0.0",
            "Type: Reordering Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Permission check Missing",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - IHO V1.0.0_en-us.pdf",
        "body": "There is no permission check for deposit function. The function is called by the CrossYieid contract. cross-yield/contracts/strategies/StrategyCakeLP.sol#L225-L231 function deposit() public override whenNotPaused { uint256 farmingTokenBalance = balanceOfFarmingToken(); if (farmingTokenBalance > 0) { IMasterChef(masterchef).deposit(poolId, farmingTokenBalance); } } cross-yield/contracts/strategies/StrategyCake.sol#L169-L175 function deposit() public override whenNotPaused { uint256 farmingTokenBalance = balanceOfFarmingToken(); if (farmingTokenBalance > 0) { IMasterChef(masterchef).enterStaking(farmingTokenBalance); } }",
        "labels": [
            "SlowMist",
            "IHO V1.0.0",
            "Type: Authority Control Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Excessive authority issue 25",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - IHO V1.0.0_en-us.pdf",
        "body": "Owner can modify the address of the strategy. The new strategy may have security risks if it is not audited, which will aect the user's funds. If the private key is leaked, it will aect the user's funds. cross-yield/contracts/core/CrossYield.sol#L224-L236 function upgradeStrategy() public onlyOwner { require(stratCandidate.strategy != address(0), \"No proposal exists\"); require(block.number > stratCandidate.proposedBlock + stratUpgradableAfter, \"Strategy cannot be replaced yet\"); emit NewStrategy(stratCandidate.strategy); strategy.retireStrategy(); strategy = IStrategy(stratCandidate.strategy); stratCandidate.strategy = address(0); stratCandidate.proposedBlock = 0; putFundsToWork(); } cross-yield/contracts/core/CrossYield.sol#L211-L220 function proposeStrategy(address _strategy) public onlyOwner { require(address(this) == IStrategy(_strategy).vault(), \"Invalid new strategy\"); stratCandidate = StrategyCandidate({ strategy: _strategy, proposedBlock: block.number }); emit NewStratCandidate(_strategy); }",
        "labels": [
            "SlowMist",
            "IHO V1.0.0",
            "Type: Authority Control Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Repeatable claims issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - IHO V1.0.0_en-us.pdf",
        "body": "After the claim, lottery.status is not set as claimed, and it is also necessary to check whether lotteryId has been claimed when the claim is executed. hotdrop/contracts/HotDrop.sol#L261-L274 function claim(uint256 lotteryId) external nonReentrant { Lottery storage lottery = lotteries[lotteryId]; require(lottery.status == Status.WinnerDrawn, \"winner not drawn\"); // if there is no winner transfer the total amount to the treasury if(tickets[lotteryId][lottery.winningNumber] == address(0)) { lottery.purchaseToken.safeTransfer(treasury, lottery.purchaseToken.balanceOf(address(this))); } else if(tickets[lotteryId][lottery.winningNumber] == _msgSender()) { // if the ticket is the winning ticket and belongs to the user then split the pot uint256 treasuryAmount = (lottery.totalRaised * lottery.treasuryFee) / FEE_BASE; lottery.purchaseToken.safeTransfer(treasury, treasuryAmount); lottery.purchaseToken.safeTransfer(_msgSender(), lottery.totalRaised - treasuryAmount); } }",
        "labels": [
            "SlowMist",
            "IHO V1.0.0",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Round plan security reminder",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - IHO V1.0.0_en-us.pdf",
        "body": "And the new round of lottery can only be opened when the last round of lottery is in WinnerDrawn, otherwise randomGenerator.latestLotteryId will be updated, which will cause the old lottery round to fail to execute drawWinner function due to this check. require(lotteryId == randomGenerator.latestLotteryId(), \"numbers not drawn\"); hotdrop/contracts/HotDrop.sol#L44-L256 function drawWinner(uint256 lotteryId) external nonReentrant { Lottery storage lottery = lotteries[lotteryId]; require(lottery.status == Status.Close, \"lottery still active\"); require(lotteryId == randomGenerator.latestLotteryId(), \"numbers not drawn\"); // get the winning number based on the randomResult generated by ChainLink's fallback uint256 winningNumber = randomGenerator.randomResult(); lottery.winningNumber = winningNumber; lottery.status = Status.WinnerDrawn; emit LotteryNumberDrawn(lotteryId, winningNumber); }",
        "labels": [
            "SlowMist",
            "IHO V1.0.0",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Deposit defect issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "In the EFVault contract, it is not restricted to call the deposit function only by the DepositApprover contract. If the user transfers funds to the EFVault contract by mistake, any user can call the deposit function to deposit for himself. 19 ",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Incorrect withdrawal amount check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "In the vault contract, users can withdraw funds through the withdraw function. It will check if the funds withdrawn by the user is less than the user's total deposit, but this will prevent the user from withdrawing all of their total deposit. ",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Risk of overburning shares",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "In the vault contract, users can burn their shares to withdraw funds through the withdraw function. However, when calculating the required burning share, it incorrectly divides the user's total deposit. This will cause the number of shares to be burned to be much larger than expected. ",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Small deposit issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "When a user makes a deposit, the vault contract will deposit the user's funds into the strategy pool and then mint the 21 corresponding share to the user. If the total deposit of the contract is very large at this time, when the user deposits a small amount of funds, the nal result of the division operation will be 0 when the amount is too small when withdrawing. Causes the problem that small assets cannot be withdrawn.",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "The deationary token issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "In the DepositApprover contract, the amount of the deposit is the amount passed in by the user. If the tokens supported by the protocol become deationary tokens in the future (for example, USDT enables the transfer fee function), this will cause the actual number of tokens received by the protocol to be inconsistent with the number of dedicated incoming tokens. The same is true for Controller and SS contracts. ",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of share manipulation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "When the user deposits in the agreement, the contract will mint the corresponding share to the user, and when the user withdraws, the corresponding share will be burned. The totalAssets function is used to participate in the calculation when calculating the share, and in the SS contract of the convex, the totalAssets are obtained through the calc_withdraw_one_coin function of the Curve Pool. However, the calc_withdraw_one_coin function is vulnerable to the balance in the Curve Pool, so malicious users can manipulate the calc_withdraw_one_coin function to aect the number of shares minted by the contract. ",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Missing event records 23",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "In the vault contract, the owner can modify the maxDeposit, maxWithdraw, controller and depositApprover parameters through the setMaxDeposit, setMaxWithdraw, setController and setDepositApprover functions respectively. But event logging is not used. In the Controller contract, the owner can modify the vault, apySort, treasury, exchange, withdrawFee, defaultDepositSS and isDefault parameters through the setVault, setAPYSort, setTreasury, setExchange, setWithdrawFee, setDefaultDepositSS and setDefaultOption functions. But event logging is not used. In the contracts under the exchanges folder, the owner can set the exchange contract address through the setExchange function. But event logging is not used. In the contracts under the subStrategies/convex folder, the owner can modify the controller, depositSlippage, pId, lpToken, curvePool, harvestGap, maxDeposit, rewardTokens parameters through the setController, setDepositSlippage, setWithdrawSlippage, setPoolId, setLPToken, setCurvePool, setHarvestGap, setMaxDeposit, addRewardToken and removeRewardToken functions. But event logging is not used. In the cusdc contract, the owner can modify the controller, depositSlippage, withdrawSlippage, harvestGap and maxDeposit parameters through the setController, setDepositSlippage, setWithdrawSlippage, setHarvestGap and setMaxDeposit functions. But event logging is not used. ",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "AllocPoint deposit issue 28",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "In the Controller contract, deposits are made according to the allocPoint of each SS, which calculates the number of tokens transferred to each SS through the following algorithm amountForSS = (_amount * subStrategies[i].allocPoint) / totalAllocPoint; However, due to the loss of precision in the division calculation, a small amount of funds cannot be transferred into SS. ",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "check withdrawal amount issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "After the Controller contract withdraws from SS, it will check whether withdrawAmt is greater than 0. But since the protocol will havest periodically, theoretically withdrawAmt should be greater than or equal to the _amount parameter passed in by the user. ",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Risks of fake routers",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "In the Controller contract, the owner role can compound interest through the harvest function. However, it is not checked whether the router list passed in by owner is as expected. If an unexpected router is passed in, it may lead to failure to harvest normally or loss of funds. ",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Loss of computational precision",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "In the vault contract, the convertToAssets function is used to convert shares to corresponding asset amounts. 31 However, it performs the calculation by performing the division operation rst and then the multiplication operation, which will result in loss of calculation accuracy. ",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Risks of strict equality checks",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "In Convex's SS contract, when the user makes a withdrawal, it is checked whether the LP balance of the current contract is strictly equal to the LP amount required by the user. If a malicious user intentionally transfers any amount of LP tokens to the current contract, this will cause the SS contract to become unusable. ",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Negative number check issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "In the Cusdc contract, the _totalAssets function is used to obtain the total collateralized assets. It is calculated by multiplying the number of nTokens held by the protocol by the price of nTokens and dividing the total supply of nTokens. The price of nToken is obtained through the getPresentValueUnderlyingDenominated function, but the return value of the getPresentValueUnderlyingDenominated function is int256, while the return value of the INusdc interface is dened as uint256. If it returns a negative number, it will overow. ",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "In the Controller contract, the owner can set allocation point of a sub strategy, register the substrategies to the controller contract and withdraw the assets from one SS and deposit to other SS. This will have an impact on the user's deposit and withdrawal operations. ",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Authority Control Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Code redundancy issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "In the vault contract, the convertToShares function is dened, but it is not actually used in the contract. ",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Invalid minimum output calculation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "In the SS contract, the calc_token_amount function will be used to calculate the minimum amount of LP tokens received during the deposit operation; the minimum amount of staking tokens received will be calculated through the calc_withdraw_one_coin function during the withdrawal operation. However, the calc_token_amount function and the calc_withdraw_one_coin function are easily aected by the last transaction of CurvePool, so they cannot play the role of slippage protection. Lusd and Tri contracts also have slippage issue, but the slippage check is annotated in the deposit function. ",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Risk of pid acquisition",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "In the Alusd contract, the getPID function user obtains the corresponding LP pool address in the ConvexBooster contract. It will return 0 if LpToken does not exist, but pid0 has a value in the ConvexBooster contract. So when getPID returns 0, it will be hard to tell if pid exists. 37 ",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Redundant approval issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "In the swapExactTokenInput function of the Exchange contract, it will rst transfer the tokens that need to be swapped from the controller contract to the router contract. But the swapExactTokenInput function approves the router contract again, which is unnecessary. ",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Incorrect storage of temporary variables",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "In the router contract, the removePath function is used to remove the swap path recorded in the contract. It will rst store the balancerBatchAssets variable through storage, then delete it, and then use this variable for event recording after deletion. ",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Compound interest slippage check issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "In the router contract, no slippage check is performed during the swap operation. If there are more funds with compound interest, there will be a risk of being attacked by sandwiches. ",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Lack of access control",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "The swap function in the UniswapV3 contract is not subject to permission control, which will allow any user to call it. ",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Authority Control Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Analyzing inaccuracies in reward calculation due to time span misalignment",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Lumiterra Community Contracts_en-us.pdf",
        "body": "contracts/UtilityStake.sol In the _calcClaimableAmount function, if di (the time elapsed since the last reward claim) exceeds timeoutClaimPeriod , then the result of the modulo operation diff % timeoutClaimPeriod , which yields claimD , will be less than the actual time span that should be considered. This leads to an inaccurate calculation of the reward amount. function _calcClaimableAmount( address staker ) internal view returns (uint256) { StakeInfo memory stakeInfo = stakeInfoByStaker[staker]; if (stakeInfo.stakedAmount == 0) { return 0; } if (stakeInfo.latestClaimedAt == 0) { return 0; } if (stakeInfo.latestClaimedAt > block.timestamp) { return 0; } if (totalStakeAmount == 0) { return 0; } if (rate == 0) { return 0; } uint256 diff = block.timestamp - stakeInfo.latestClaimedAt; uint256 claimD = diff % timeoutClaimPeriod; // Avoid delayed on-chain submissions resulting in zero rewards 0 if (diff == timeoutClaimPeriod) { claimD = timeoutClaimPeriod; } uint256 claimableAmount = Math.mulDiv( stakeInfo.stakedAmount * claimD, rate, totalStakeAmount, Math.Rounding.Zero ); return claimableAmount; }",
        "labels": [
            "SlowMist",
            "Lumiterra Community Contracts",
            "Type: Others",
            "Severity: Medium"
        ]
    },
    {
        "title": "Handling reward calculation issues and function restrictions in reward cycles",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Lumiterra Community Contracts_en-us.pdf",
        "body": "contracts/UtilityStake.sol Users will still be able to use the old rate to calculate rewards and collect them when the next cycle has not yet been set up. This also causes a problem. When there are not enough reward tokens in the pool, users can't use the unstake and stake functions. function _calcClaimableAmount( address staker ) internal view returns (uint256) { StakeInfo memory stakeInfo = stakeInfoByStaker[staker]; if (stakeInfo.stakedAmount == 0) { return 0; } if (stakeInfo.latestClaimedAt == 0) { return 0; } if (stakeInfo.latestClaimedAt > block.timestamp) { return 0; } if (totalStakeAmount == 0) { return 0; } if (rate == 0) { return 0; } uint256 diff = block.timestamp - stakeInfo.latestClaimedAt; uint256 claimD = diff % timeoutClaimPeriod; // Avoid delayed on-chain submissions resulting in zero rewards 0 if (diff == timeoutClaimPeriod) { claimD = timeoutClaimPeriod; } uint256 claimableAmount = Math.mulDiv( stakeInfo.stakedAmount * claimD, rate, totalStakeAmount, Math.Rounding.Zero ); return claimableAmount; }",
        "labels": [
            "SlowMist",
            "Lumiterra Community Contracts",
            "Type: Others",
            "Severity: High"
        ]
    },
    {
        "title": "Addressing overpayment risk in reward distribution due to rate update delays",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Lumiterra Community Contracts_en-us.pdf",
        "body": "contracts/UtilityStake.sol In the current reward mechanism, a signicant issue arises if users claim their rewards after an update to the reward rate. Specically, if a user claims rewards accrued before the rate update, the calculation will be based on the new, potentially higher rate, leading to an overestimation of their rightful reward. This overpayment can deplete the reward pool more rapidly than anticipated, potentially leaving insucient funds for later users. Consequently, this could impede the normal operation of unstake and stake functions, as the reward pool might not sustain the demands. function depositRewardToken(address token, uint256 amount) external { IUtilityToken rewardToken = config.getPRToken(); require(token == address(rewardToken), \"UtilityStake: invalid token\"); rewardToken.transferFrom(msg.sender, address(this), amount); if (block.timestamp >= periodFinish) { rate = amount / periodDuration; } else { uint256 remaining = periodFinish - block.timestamp; uint256 leftover = remaining * rate; rate = (amount + leftover) / periodDuration; } periodFinish = block.timestamp + periodDuration; emit DepositRewardToken(amount); }",
        "labels": [
            "SlowMist",
            "Lumiterra Community Contracts",
            "Type: Others",
            "Severity: Critical"
        ]
    },
    {
        "title": "Inaccuracies in reward calculation due to misuse of total supply in liquidity pool",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Lumiterra Community Contracts_en-us.pdf",
        "body": "contracts/LiquidityStake.sol In the _checkpoint function, the use of _sc2crvPool().totalSupply() for calculating rewards may lead to inaccuracies. This is because it utilizes the total supply of the entire liquidity pool, rather than the quantity of LP tokens controlled by the contract itself. Indeed, this approach can result in the calculation of rewards being less than what is rightfully due, consequently leading to users receiving fewer rewards than they are actually entitled to. function _checkpoint(address staker) internal { _metaGauge().claim_rewards(); StakeInfo memory stakeInfo = stakeInfoByStaker[staker]; uint256 totalSupplay = _sc2crvPool().totalSupply(); if (totalSupplay == 0) { return; } for (uint256 i = 0; i < MAX_REWARDS; i++) { address tokenAddress = _metaGauge().reward_tokens(i); if (tokenAddress == address(0)) { break; } uint256 dI = 0; uint256 tokenBalance = IERC20Metadata(tokenAddress).balanceOf( address(this) ); dI = (10 ** 18 * (tokenBalance - rewardBalances[tokenAddress])) / totalSupplay; rewardBalances[tokenAddress] = tokenBalance; // integral: uint256 = self.reward_integral[token] + dI uint256 integral = rewardIntegral[tokenAddress] + dI; if (dI != 0) { rewardIntegral[tokenAddress] = integral; } uint256 integralFor = rewardIntegralFor[tokenAddress][staker]; uint256 newClaimable = 0; if (integralFor < integral) { rewardIntegralFor[tokenAddress][staker] = integral; (stakeInfo.totalSC2CRVLP * ((integral - integralFor))) / PRICE_PRECISION; } uint256 claimData = claimDataByStaker[staker][tokenAddress]; uint256 totalClaimable = (claimData >> 128) + newClaimable; if (totalClaimable > 0) { uint256 totalClaimed = claimData % 2 ** 128; claimDataByStaker[staker][tokenAddress] = totalClaimed + (totalClaimable << 128); } } } }",
        "labels": [
            "SlowMist",
            "Lumiterra Community Contracts",
            "Type: Others",
            "Severity: Critical"
        ]
    },
    {
        "title": "Redundant logic in _setFloorPrice function of smart contract",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Lumiterra Community Contracts_en-us.pdf",
        "body": "contracts/PriceField.sol The else if (_floorPrice == 0) conditional branch in this function will not actually be executed. This is because _floorPrice is set to the new floorPrice_ before any conditional judgment is entered, and floorPrice_ cannot be zero, as veried at the beginning of the function. function _setFloorPrice(uint256 floorPrice_) internal { require(floorPrice_ >= PRICE_PRECISION / 2, \"floor price too low\"); require(floorPrice_ > _floorPrice, \"floor price too low\"); uint256 previousFloorPrice = _floorPrice; uint256 x3 = _config.getUtilityToken().totalSupply(); _floorPrice = floorPrice_; if (x3 > c()) { uint256 maxFloorPrice = (Math.mulDiv( x3 - c(), _slope, PRECENT_DENOMINATOR, Math.Rounding.Zero ) + PRICE_PRECISION) / 2; if (maxFloorPrice > floorPrice_) { _floorPrice = floorPrice_; } } else if (_floorPrice == 0) { //SLOWMIST//will not be implemented _floorPrice = floorPrice_; } else if (x3 > x1(floorPrice_) + _exerciseAmount) { _floorPrice = floorPrice_; } else if (x3 == 0) { _floorPrice = floorPrice_; } require(_floorPrice > previousFloorPrice, \"floor price too low\"); emit UpdateFloorPrice(_floorPrice); }",
        "labels": [
            "SlowMist",
            "Lumiterra Community Contracts",
            "Type: Others",
            "Severity: Low"
        ]
    },
    {
        "title": "Potential reentrancy risk in VAMM's _mintByPRToken function",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Lumiterra Community Contracts_en-us.pdf",
        "body": "contracts/VAMM.sol The payToken can be passed in arbitrarily from the outside, and if the payToken is a token that implements a callback function, then this call may trigger malicious code.An attacker can exploit this by calling the _mintByPRToken function again during the callback. Since the _mintByPRToken function calls payToken.transferFrom before updating _floorPrice and minting new tokens, a reentry attack could allow an attacker to mint tokens multiple times at the old, more favorable price, rather than at the updated price. This could lead to improper minting of assets. function _mintByPRToken( address payTokenAddress, uint256 mintAmount, uint256 maxPayAmount, address recipient ) internal { IERC20Metadata payToken = IERC20Metadata(payTokenAddress); IUtilityToken _utilityToken = _config.getUtilityToken(); IUtilityToken _prToken = _config.getPRToken(); require(_prToken.balanceOf(msg.sender) >= mintAmount, \"VAMM:mp0\"); require( _prToken.allowance(msg.sender, address(this)) >= mintAmount, \"VAMM:mp1\" ); (uint256 toLiquidityPrice, uint256 fees) = _priceField.getUseFPBuyPrice( mintAmount ); require(toLiquidityPrice + fees <= maxPayAmount, \"VAMM:mp2\"); // Include slippage as fee income fees = maxPayAmount - toLiquidityPrice; //SLOWMIST// uint256 maxPayAmountInPayToken = _convertPrice( maxPayAmount, payToken, true ); _priceField.increaseSupplyWithNoPriceImpact(mintAmount); require( payToken.transferFrom( msg.sender, address(this), maxPayAmountInPayToken ), \"VAMM:mp3\" );//The paytoken is an arbitrary token, so any worthless token can be used as the key to transfer money to the contract. // burn pr token _prToken.burnFrom(msg.sender, mintAmount); _collectFees(fees); /// mint token _totalLiquidity += toLiquidityPrice; _utilityToken.mint(recipient, mintAmount); _deposit(payTokenAddress); _autoUpFP(); emit Mint(recipient, mintAmount, toLiquidityPrice, fees); }",
        "labels": [
            "SlowMist",
            "Lumiterra Community Contracts",
            "Type: Others",
            "Severity: High"
        ]
    },
    {
        "title": "Exploitation risk with arbitrary payToken in VAMM's _mintByPRToken function",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Lumiterra Community Contracts_en-us.pdf",
        "body": "contracts/VAMM.sol The payToken can be any token, so it can be used to construct a malicious token to make a payment. function _mintByPRToken( address payTokenAddress, uint256 mintAmount, uint256 maxPayAmount, address recipient ) internal { IERC20Metadata payToken = IERC20Metadata(payTokenAddress); IUtilityToken _utilityToken = _config.getUtilityToken(); IUtilityToken _prToken = _config.getPRToken(); require(_prToken.balanceOf(msg.sender) >= mintAmount, \"VAMM:mp0\"); require( _prToken.allowance(msg.sender, address(this)) >= mintAmount, \"VAMM:mp1\" ); (uint256 toLiquidityPrice, uint256 fees) = _priceField.getUseFPBuyPrice( mintAmount ); require(toLiquidityPrice + fees <= maxPayAmount, \"VAMM:mp2\"); // Include slippage as fee income fees = maxPayAmount - toLiquidityPrice; //SLOWMIST// uint256 maxPayAmountInPayToken = _convertPrice( maxPayAmount, payToken, true ); _priceField.increaseSupplyWithNoPriceImpact(mintAmount); require( payToken.transferFrom( msg.sender, address(this), maxPayAmountInPayToken ), \"VAMM:mp3\" );//The paytoken is an arbitrary token, so any worthless token can be used as the key to transfer money to the contract. // burn pr token _prToken.burnFrom(msg.sender, mintAmount); _collectFees(fees); /// mint token _totalLiquidity += toLiquidityPrice; _utilityToken.mint(recipient, mintAmount); _deposit(payTokenAddress); _autoUpFP(); emit Mint(recipient, mintAmount, toLiquidityPrice, fees); }",
        "labels": [
            "SlowMist",
            "Lumiterra Community Contracts",
            "Type: Others",
            "Severity: High"
        ]
    },
    {
        "title": "Preemptive Initialization",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Lumiterra Community Contracts_en-us.pdf",
        "body": "contracts/LiquidityStake.sol function initialize(IConfig config_) public initializer { __Ownable_init(); __UUPSUpgradeable_init(); _transferOwnership(tx.origin); config = config_; } contracts/UtilityStake.sol function initialize(IConfig config_) public initializer { __Ownable_init(); __UUPSUpgradeable_init(); _transferOwnership(tx.origin); config = config_; unstakeFee = 300000000; periodDuration = 1 weeks; timeoutClaimPeriod = 2 days; } contracts/VAMM.sol function initialize( IConfig config_, PriceField priceField_, uint256 t_, uint256 x_, uint256 c_ ) public initializer { __Ownable_init(); __UUPSUpgradeable_init(); _transferOwnership(tx.origin); _config = config_; _priceField = priceField_; tForMFR = t_; maxTForMFR = 5000000000; minTForMFR = t_; cForMFR = c_; // ethereum block time 13s reduceTBlocks = 6600; xForMFR = x_; }",
        "labels": [
            "SlowMist",
            "Lumiterra Community Contracts",
            "Type: Race Conditions Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Lacking event logging in critical contract functions alters state without transparency issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Lumiterra Community Contracts_en-us.pdf",
        "body": "contracts/LiquidityStake.sol function setHook(LiquidityStakeHook hook_) external onlyOwner { hook = hook_; } contracts/UtilityStake.sol function setHook(UtilityStakeHook hook_) external onlyOwner { hook = hook_; } contracts/PriceField.sol function increaseSupplyWithNoPriceImpact(uint256 amount) external onlyVamm { _exerciseAmount += amount; } contracts/VAMM.sol function setPriceField(PriceField priceField_) external onlyOwner { _priceField = priceField_; }",
        "labels": [
            "SlowMist",
            "Lumiterra Community Contracts",
            "Type: Malicious Event Log Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Redundant functions",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Lumiterra Community Contracts_en-us.pdf",
        "body": "contracts/VAMM.sol Redundant function code, which can be deleted if it is not useful. function liquidityTesting() external { }",
        "labels": [
            "SlowMist",
            "Lumiterra Community Contracts",
            "Type: Others",
            "Severity: Information"
        ]
    },
    {
        "title": "Missing check return value",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Lumiterra Community Contracts_en-us.pdf",
        "body": "It is recommended to check the return value of transferFrom, as there may be problems if a non-ERC20 standard token is subsequently used. contracts/UtilityStake.sol line 142: utilityToken.transferFrom(staker, address(this), amount); line 196: stablecoin.transferFrom(staker, address(this), fees); line 287: rewardToken.transferFrom(msg.sender, address(this), amount); contracts/LiquidityStake.sol line 154: stablecoin.transferFrom(staker, address(this), _amount); contracts/VAMM.sol line 504: token.transferFrom(msg.sender, address(this), _repayAmount);",
        "labels": [
            "SlowMist",
            "Lumiterra Community Contracts",
            "Type: Others",
            "Severity: Low"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Lumiterra Community Contracts_en-us.pdf",
        "body": "contracts/VAMM.sol The owner can set the key parameters, if the private key is lost, the price will be out of control. owner can setPriceField operator can updateMFR contracts/UtilityToken.sol The owner can mint the token, if the private key is lost it will cause the token to be incremented. owner can mint owner can transferOwnership Other contracts have key roles and key parameters that are mostly controlled by external config contracts.",
        "labels": [
            "SlowMist",
            "Lumiterra Community Contracts",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Recommendation to Implement reentrancy",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Lumiterra Community Contracts_en-us.pdf",
        "body": "contracts/VAMM.sol In _mint , _burn , there is no utilization scenario at the moment, but it is recommended to add reentrant locks.",
        "labels": [
            "SlowMist",
            "Lumiterra Community Contracts",
            "Type: Reentrancy Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing zero address check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Kayak-UniswapV3-Contract.pdf",
        "body": "1.In the KayakSwapRouter contract, the constructor function lacks a zero address check for the _WETH parameter. contracts/swaprouter/KayakSwapRouter.sol#L67-L69 constructor(address _WETH) { weth = IWETH(_WETH); } 2.In the KayakSwapRouter contract, the swap function lacks a zero address check for the params.pool parameter. contracts/swaprouter/KayakSwapRouter.sol#L113-L141 function swap(SwapParams calldata params) public payable nonReentrant returns (uint256 returnAmount) { ``` if (params.flag) { _swapOnStableSwap(params.srcToken, params.dstToken, params.pool, receivedAmount); } else { _swapOnV3ExactIn(params.srcToken, params.dstToken, params.pool, receivedAmount); } ``` } 3.In the KayakSwapQuoter contract, the constructor function lacks a zero address check for the _WETH parameter. contracts/swaprouter/KayakSwapQuoter.sol#L34-L36 constructor(address _WETH) { weth = IWETH(_WETH); } 4.In the KayakSwapQuoter contract, the getReturnStableSwap function and getReturnUniswapV3 function lack a zero address check for the pool parameter. contracts/swaprouter/KayakSwapQuoter.sol#L87-L103, L105-L130 function getReturnStableSwap( address srcToken, address dstToken, address pool, uint256 amount ) public view returns (uint256 returnAmount) { ``` uint256 n_coins = IStableSwap(pool).N_COINS(); ``` } function getReturnUniswapV3( address srcToken, address dstToken, address pool, uint256 amount ) public returns (uint256 returnAmount) { ``` IUniswapV3Pool(pool).swap( ``` ) ``` }",
        "labels": [
            "SlowMist",
            "Kayak-UniswapV3-Contract",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "The identity of msg.sender is not veried",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Kayak-UniswapV3-Contract.pdf",
        "body": "In the KayakSwapRouter contract, the uniswapV3SwapCallback function does not verify whether msg.sender is a valid Uniswap V3 Pool. When there are assets in the contract, the attacker can construct malicious parameters and transfer any assets in the contract through the uniTransfer function called in the uniswapV3SwapCallback function. contracts/swaprouter/KayakSwapRouter.sol#L187-L197 function uniswapV3SwapCallback(int256 amount0Delta, int256 amount1Delta, bytes calldata _data) external { require(amount0Delta > 0 || amount1Delta > 0); // swaps entirely within 0- liquidity regions are not supported SwapCallbackData memory data = abi.decode(_data, (SwapCallbackData)); (address tokenIn, address tokenOut, , ) = data.path.decodeFirstPool(); (, uint256 amountToPay) = amount0Delta > 0 ? (tokenIn < tokenOut, uint256(amount0Delta)) : (tokenOut < tokenIn, uint256(amount1Delta)); IERC20(tokenIn).uniTransfer(msg.sender, amountToPay); }",
        "labels": [
            "SlowMist",
            "Kayak-UniswapV3-Contract",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Unchecked return value",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Kayak-UniswapV3-Contract.pdf",
        "body": "In the UniERC20 library, the uniApprove function did not check the return value when calling the approve function. contracts/swaprouter/libraries/UniERC20.sol#L68-L72 function uniApprove(IERC20 token, address to, uint256 amount) internal { if (isETH(token)) return; token.approve(to, amount); }",
        "labels": [
            "SlowMist",
            "Kayak-UniswapV3-Contract",
            "Type: Others",
            "Severity: Low"
        ]
    },
    {
        "title": "Redundant code",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Kayak-UniswapV3-Contract.pdf",
        "body": "In the KayakSwapQuoter contract, amountOutCached is not used. contracts/swaprouter/KayakSwapQuoter.sol#L22 uint256 private amountOutCached;",
        "labels": [
            "SlowMist",
            "Kayak-UniswapV3-Contract",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Insucient ETH balance causes the function to be unavailable",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Kayak-UniswapV3-Contract.pdf",
        "body": "In the KayakSwapQuoter contract, the purpose of the getReturnUniswapV3 function is to return the number of tokens that can be exchanged in the UniswapV3 pool, so there is no need to call the weth.deposit function to exchange WETH. Calling the weth.deposit function will fail because the contract does not have enough ETH balance and subsequent operations cannot be performed, which will make the function unusable. contracts/swaprouter/KayakSwapQuoter.sol function getReturnUniswapV3( address srcToken, address dstToken, address pool, uint256 amount ) public returns (uint256 returnAmount) { if (IERC20(srcToken).isETH()) { weth.deposit{ value: amount }(); } address srcTokenReal = IERC20(srcToken).isETH() ? address(weth) : srcToken; address dstTokenReal = IERC20(dstToken).isETH() ? address(weth) : dstToken; bool zeroForOne = srcTokenReal < dstTokenReal; try IUniswapV3Pool(pool).swap( address(this), // address(0) might cause issues with some tokens zeroForOne, amount.toInt256(), zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1, abi.encodePacked(srcTokenReal, dstTokenReal, pool, false) ) {} catch (bytes memory reason) { return parseRevertReason(reason); } }",
        "labels": [
            "SlowMist",
            "Kayak-UniswapV3-Contract",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "External dependency changes may cause logic failure",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Kayak-UniswapV3-Contract.pdf",
        "body": "In the KayakSwapQuoter contract, the parseRevertReason function can parse the error information returned by UniswapV3Pool. If the Uniswap V3 contract interface or error return format changes, it may cause errors in error message parsing. contracts/swaprouter/KayakSwapQuoter.sol#L133-L142 function parseRevertReason(bytes memory reason) private pure returns (uint256) { if (reason.length != 32) { if (reason.length < 68) revert(\"Unexpected error\"); assembly { reason := add(reason, 0x04) } revert(abi.decode(reason, (string))); } return abi.decode(reason, (uint256)); }",
        "labels": [
            "SlowMist",
            "Kayak-UniswapV3-Contract",
            "Type: Others",
            "Severity: Information"
        ]
    },
    {
        "title": "Returns incorrect swap result",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Kayak-UniswapV3-Contract.pdf",
        "body": "In the KayakSwapQuoter contract, the getReturnStableSwap function and getReturnUniswapV3 function do not verify whether the pool contract is the correct address. If the user passes in a malicious contract address, an incorrect exchange result may be returned. contracts/swaprouter/KayakSwapQuoter.sol#L87-L103, L105-L130 function getReturnStableSwap( address srcToken, address dstToken, address pool, uint256 amount ) public view returns (uint256 returnAmount) { address[] memory tokens = new address[](3); uint256 n_coins = IStableSwap(pool).N_COINS(); tokens[0] = IStableSwap(pool).coins(uint256(0)); tokens[1] = IStableSwap(pool).coins(uint256(1)); if (n_coins == 3) { tokens[2] = IStableSwap(pool).coins(uint256(2)); } uint256 i = (srcToken == tokens[0] ? 1 : 0) + (srcToken == tokens[1] ? 2 : 0) + (srcToken == tokens[2] ? 3 : 0); uint256 j = (dstToken == tokens[0] ? 1 : 0) + (dstToken == tokens[1] ? 2 : 0) + (dstToken == tokens[2] ? 3 : 0); return IStableSwap(pool).get_dy(i - 1, j - 1, amount); } function getReturnUniswapV3( address srcToken, address dstToken, address pool, uint256 amount ) public returns (uint256 returnAmount) { if (IERC20(srcToken).isETH()) { weth.deposit{ value: amount }(); } address srcTokenReal = IERC20(srcToken).isETH() ? address(weth) : srcToken; address dstTokenReal = IERC20(dstToken).isETH() ? address(weth) : dstToken; bool zeroForOne = srcTokenReal < dstTokenReal; try IUniswapV3Pool(pool).swap( address(this), // address(0) might cause issues with some tokens zeroForOne, amount.toInt256(), zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1, abi.encodePacked(srcTokenReal, dstTokenReal, pool, false) ) {} catch (bytes memory reason) { return parseRevertReason(reason); } }",
        "labels": [
            "SlowMist",
            "Kayak-UniswapV3-Contract",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Kayak-UniswapV3-Contract.pdf",
        "body": "In the UniswapV3Factory contract, the owner role can transfer owner permissions and set feeAmountTickSpacing mapping. contracts/core/UniswapV3Factory.sol#L54-L58, L61-L72 function setOwner function enableFeeAmount",
        "labels": [
            "SlowMist",
            "Kayak-UniswapV3-Contract",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Redundant authorization operations",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Kayak-UniswapV3-Contract.pdf",
        "body": "In the KayakSwapRouter contract, the _swapOnV3ExactIn function calls the uniApprove function to authorize the pool contract, but in the uniswapV3SwapCallback function, the uniTransfer function is called to pay the tokenIn token, and the uniTransferFrom function is not used, so the authorized amount will continue to exist and accumulate. If the pool contract is a malicious contract, this authorization operation may cause the assets in the KayakSwapRouter contract to be transferred away. contracts/swaprouter/KayakSwapRouter.sol#L162-L185, L187-L197 function _swapOnV3ExactIn(address srcToken, address dstToken, address pool, uint256 amount) internal { ``` IERC20(srcTokenReal).uniApprove(payable(pool), amount); ``` } function uniswapV3SwapCallback(int256 amount0Delta, int256 amount1Delta, bytes calldata _data) external { ``` IERC20(tokenIn).uniTransfer(msg.sender, amountToPay); }",
        "labels": [
            "SlowMist",
            "Kayak-UniswapV3-Contract",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Potential denial of service risk due to gulp operations",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase5_en-us.pdf",
        "body": "In the Actions contract, when the user performs the autoJoinSmartPool operation, the number of shares the user can obtain will be calculated through the _calculateShare function, and minPoolAmountOut will be checked at the end. The _calculateShare function obtains the number of tokens recorded in the pool through bPool's getBalance when calculating the share, but unfortunately any user can update this parameter through bPool's gulp function. Therefore, when an ordinary user performs an autoJoinSmartPool operation, a malicious user directly transfers funds to bPool and calls the gulp function to update the token balance recorded in the pool. At this time, ordinary users will not be able to successfully add liquidity due to the minPoolAmountOut check. If the minPoolAmountOut value passed in by an ordinary user is 0, it may cause an interest rate ination attack. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase5",
            "Type: Denial of Service Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Incorrect event logging",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase5_en-us.pdf",
        "body": "In the CRP contract, the createPool function adds the creator parameter as the real creator of the pool. However, the corresponding events were not modied accordingly. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase5",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Incorrect WETH address",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase5_en-us.pdf",
        "body": "The WETH address constant is hard-coded in the Actions contract, but this address is an EOA address on the Ethereum mainnet and is not the correct WETH address. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase5",
            "Type: Others",
            "Severity: High"
        ]
    },
    {
        "title": "Incorrect poolTokens check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase5_en-us.pdf",
        "body": "In the autoJoinSmartPool function of the Actions contract, it checks the tokens deposited by the user through poolTokens[i] == handleToken , but handleToken has been replaced by the issueToken parameter during the native token checking phase. Therefore, the poolTokens[i] == handleToken check is not accurate. If handleToken is WETH, it will cause an error in the _makeSwap operation. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase5",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Redundant STBT token check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase5_en-us.pdf",
        "body": "In the autoJoinSmartPool and _exit functions of the Actions contract, when making a token transfer, it will be checked whether the transferred token is an STBT token. But in fact, the protocol does not allow deposits of STBT tokens, and STBT tokens will also be converted into stablecoins after the ETF expires. Therefore, theoretically, there will be no STBT tokens in the contract, so the STBT token check is redundant. . ",
        "labels": [
            "SlowMist",
            "DeSyn Phase5",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Potential risk of slot conict",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase5_en-us.pdf",
        "body": "In this protocol iteration, both SmartPoolManager and Actions contracts have changed their storage structures. If these contracts use an upgradeable model, and upgrading the contract directly on the original basis may lead to contract storage slot conicts. In fact, the Actions contract is an upgradeable contract, so special attention should be paid to such risks.",
        "labels": [
            "SlowMist",
            "DeSyn Phase5",
            "Type: Variable Coverage Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of event forgery",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase5_en-us.pdf",
        "body": "In the CRP contract, the exitPool function adds a user parameter to record the real caller when the user exits through the Actions contract. However, users can also exit by calling the exitPool function of the CRP contract. They can pass in any user parameter to make the LogExit event record an incorrect value. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase5",
            "Type: Malicious Event Log Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Potential risk of denial of service due to large CRPFactory array",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase5_en-us.pdf",
        "body": "In the CRPFactory contract, when the Blabs role performs addCRPFactory and removeCRPFactory operations, it will use a for loop to traverse the entire CRPFactorys array. If the array length is too large, it will lead to DoS risks. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase5",
            "Type: Denial of Service Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Potential risk of endless loop",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase5_en-us.pdf",
        "body": "In the CRPFactory contract, the isCrp function is used to check whether the address passed by the user is a CRP contract. If not, the CRPFactorys array will be circulated and the isCrp function of other CRPFactory will be called to check. However, it should be noted that if the Blabs role adds this contract address to the CRPFactorys array, the user will fall into an innite loop error when querying a CRP address that is not recorded in this contract through the isCrp function. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase5",
            "Type: Denial of Service Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Debug functions buer oset stack overow",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ccToken.pdf",
        "body": "There is no check to see if oset exceeds the size of debug_buer. If data_len is too large, it may cause a stack overow. contracts/c/common.h static void debug_print_data_impl(const char *prefix, const uint8_t *data, uint32_t data_len) { int offset = 0; offset += sprintf_(debug_buffer, \"%s\", prefix); for (size_t i = 0; i < data_len; i++) { offset += sprintf_(debug_buffer + offset, \"%02x\", data[i]); } debug_buffer[offset] = '\\0'; ckb_debug(debug_buffer); } static void debug_print_int_impl(const char *prefix, int ret) { int offset = 0; offset += sprintf_(debug_buffer, \"%s(%d)\", prefix, ret); debug_buffer[offset] = '\\0'; ckb_debug(debug_buffer); } static void debug_print_string_impl(const char *prefix, const uint8_t *data, uint32_t data_len) { int offset = 0; offset += sprintf_(debug_buffer, \"%s\", prefix); for (size_t i = 0; i < data_len; i++) { offset += sprintf_(debug_buffer + offset, \"%c\", data[i]); } debug_buffer[offset] = '\\0'; ckb_debug(debug_buffer); }",
        "labels": [
            "SlowMist",
            "ccToken",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "char2hex Logic error",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ccToken.pdf",
        "body": "This function assumes that the input hexChar is a valid hexadecimal character, but does not check if the character is in the valid range. If the input hexChar is an illegal character, the result of the calculation will be wrong. For example, entering 'G' or 'H' will result in undesired output. Also, the function only handles hexadecimal characters with uppercase letters ('A' through 'F'), but hexadecimal characters also include lowercase letters ('a' through 'f'). contracts/c/utils.h char char2hex(char hexChar) { char tmp; if(hexChar<='9') { tmp = hexChar-'0'; } else if(hexChar<='F') { tmp = hexChar-'7'; } else { tmp = hexChar-'W'; } return tmp; }",
        "labels": [
            "SlowMist",
            "ccToken",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ccToken.pdf",
        "body": "Custodian has the following unlock permissions: update_merchants confirm_mint reject_mint confirm_burn reject_burn Merchant has the following unlock permissions: update_merchants Request mint Request burn",
        "labels": [
            "SlowMist",
            "ccToken",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "simple_udt should check the size of the input and output amounts",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ccToken.pdf",
        "body": "simple_udt should check the size of the input and output amounts. contracts/c/tx_parser.h int simple_udt(uint128_t *ia, uint128_t *oa) { //... *ia = input_amount; *oa = output_amount; return CKB_SUCCESS; }",
        "labels": [
            "SlowMist",
            "ccToken",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Missing array bounds checking",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ccToken.pdf",
        "body": "Accessing data[0] and data[1...] without boundary checking may result in an array out-of-bounds error. without boundary checking may result in an array out-of-bounds error. libs/core/src/data_parser/cong_cell.rs pub fn parse(data: Vec<u8>) -> Result<(u8, Vec<(ConfigKey, Vec<u8>)>), CoreError> { let version = data[0]; let mut configs = vec![]; match version { 0 => { let config_mol = BytesVec::from_compatible_slice(&data[1..]).map_err(|_| CoreError::ParseCellDataFailed { //... } The code does not check if the input args and data are of sucient length. Direct access to args[0] and data[0] may result in out-of-bounds access, which can trigger a crash. libs/core/src/data_parser/governance_member_cell.rs pub fn parse_type_args(args: Vec<u8>) -> Result<(GovernanceMemberRole, Vec<u8>), CoreError> { let role = GovernanceMemberRole::try_from(args[0]).map_err(|_| CoreError::ParseCellDataFailed { cell_name: String::from(\"GovernanceMemberCell\"), msg: format!(\"Unknown role value {}\", args[0]), })?; let cell_id = (&args[1..]).to_vec(); //... Ok((role, cell_id)) } pub fn parse_data(data: Vec<u8>) -> Result<(u8, GovernanceMembers), CoreError> { let version = data[0]; //... GovernanceMembers::from_compatible_slice(&data[1..]).map_err(|_| CoreError::ParseCellDataFailed { //... } libs/core/src/data_parser/tick_cell.rs pub fn parse_data(data: Vec<u8>) -> Result<(u8, Tick), CoreError> { let version = data[0]; //... tick = Tick::from_compatible_slice(&data[1..]).map_err(|_| CoreError::ParseCellDataFailed { //... Ok((version, tick)) } libs/core/src/veriers/permission.rs pub fn verify_input_has_deploy_lock(index: usize) -> Result<(), CoreError> { //... cc_assert!(cells[0] == index, CoreError::DeployLockIsRequired { index }); Ok(()) } pub fn verify_input_has_owner_lock(index: usize) -> Result<(), CoreError> { //... cc_assert!(cells[0] == index, CoreError::OwnerLockIsRequired { index }); Ok(()) }",
        "labels": [
            "SlowMist",
            "ccToken",
            "Type: Others",
            "Severity: Low"
        ]
    },
    {
        "title": "Avoid unnecessary memory copies",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ccToken.pdf",
        "body": "Function arguments can accept slice references (&[u8]) instead of ownership (Vec), which avoids unnecessary memory copies. libs/core/src/data_parser/cong_cell.rs pub fn parse(data: Vec<u8>) -> Result<(u8, Vec<(ConfigKey, Vec<u8>)>), CoreError> { //... } libs/core/src/data_parser/governance_member_cell.rs pub fn parse_type_args(args: Vec<u8>) -> Result<(GovernanceMemberRole, Vec<u8>), CoreError> { //... } pub fn parse_data(data: Vec<u8>) -> Result<(u8, GovernanceMembers), CoreError> { //... } libs/core/src/data_parser/tick_cell.rs pub fn parse_data(data: Vec<u8>) -> Result<(u8, Tick), CoreError> { //... } libs/core/src/util.rs pub fn get_tx_action() -> Result<Action, CoreError> { //... let version_byte = witness[0]; //... let action_bytes = &witness[1..]; //... }",
        "labels": [
            "SlowMist",
            "ccToken",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Ambiguous error handling",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ccToken.pdf",
        "body": "Use the warn! log to record potential parsing errors, which is not uncommon in smart contracts, without explicitly indicating whether the error should be interrupted or accepted. libs/core/src/data_parser/cong_cell.rs pub fn parse(data: Vec<u8>) -> Result<(u8, Vec<(ConfigKey, Vec<u8>)>), CoreError> { //... let key = match ConfigKey::try_from(u32::from_le_bytes(key_bytes)) { Ok(key) => key, Err(_) => { warn!( \"[{}] Parse [0..4]({}) to config key failed, the key is removed or not defined.\", i, hex_string(key_bytes.as_ref()) ); continue; } }; //... } Ok((version, configs)) }",
        "labels": [
            "SlowMist",
            "ccToken",
            "Type: Others",
            "Severity: Low"
        ]
    },
    {
        "title": "Missing system shutdown status check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ccToken.pdf",
        "body": "When the system is processing the shutdown state, all other features except conguration should be disabled, including disabling the following features: init_governance update_owner update_custodians update_merchants confirm_mint reject_mint confirm_burn reject_burn Currently only the request function request for token minting and destruction checks if the system is disabled.",
        "labels": [
            "SlowMist",
            "ccToken",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "It is recommended to use the encapsulated method",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ccToken.pdf",
        "body": "A wrapped lock validation function already exists, and reusing it improves the readability of the code. contracts/cong-cell-type/src/entry.rs fn verify_output_lock(index: usize) -> Result<(), Box<dyn AsI8>> { //... lock.as_slice() == owner_lock.as_slice(), //... Ok(()) }",
        "labels": [
            "SlowMist",
            "ccToken",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap_v3_en-us.pdf",
        "body": "In the StableSwapRouter, the Owner role can set the stableSwapFactory to any address. If a fake stableSwapFactory address is passed in, the SmartRouterHelper will obtain a malicious transaction pair from the getStableInfo function, resulting in loss of funds. And this function is also missing the event log and 0 address check. ",
        "labels": [
            "SlowMist",
            "PancakeSwap_v3",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Token compatibility issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap_v3_en-us.pdf",
        "body": "1.In the StableSwapRouter, the exactOutputStableSwap and exactInputStableSwap functions will call swap to transfer by the pay function via the input data amountIn and the input data is recorded directly into it. In the swap function, although amountIn is re-recorded. However, the amountIn_ data is still recorded in the _swap function when the exchange is performed in the swapContract of the transferring third-party contract. If the third-party contract token balance is used to directly participate in the calculation, the contract cannot be compatible with the rebase token. ",
        "labels": [
            "SlowMist",
            "PancakeSwap_v3",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing event records",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap_v3_en-us.pdf",
        "body": "1.In the PancakeV3FactoryOwner contract, the owner role can set the lmPoolDeployer address, but there is no event log and 0 address check. ",
        "labels": [
            "SlowMist",
            "PancakeSwap_v3",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of initial operation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap_v3_en-us.pdf",
        "body": "In the PancakeV3Pool contract, by calling the initialize function to initialize the contracts, there is a potential issue that malicious attackers preemptively call the initialize function to initialize and there is no access control verication for the initialize functions ",
        "labels": [
            "SlowMist",
            "PancakeSwap_v3",
            "Type: Race Conditions Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of denial of service",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap_v3_en-us.pdf",
        "body": "In the UniswapV3Pool contract, the swap function can be disrupted by forcing the loop to go through too many operations, potentially trapping the swap due to a lack of gas. ",
        "labels": [
            "SlowMist",
            "PancakeSwap_v3",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of replay attack",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Coordinape protocol_en-us.pdf",
        "body": "In the ApeToken contract, DOMAIN_SEPARATOR is dened when the contract is initialized, but it is not reimplemented when DOMAIN_SEPARATOR is used in the permit function. So the DOMAIN_SEPARATOR contains 15 the chainId and is dened at contract deployment instead of reconstructed for every signature, there is a risk of possible replay attacks between chains in the event of a future chain split. coordinape-protocol/contracts/ApeProtocol/token/ApeToken.sol#L18 constructor() { uint chainId = block.chainid; DOMAIN_SEPARATOR = keccak256( abi.encode( keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'), keccak256(bytes(\"coordinape.com\")), keccak256(bytes('1')), chainId, address(this) ) ); } coordinape-protocol/contracts/ApeProtocol/token/ApeToken.sol#L42 function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public { require(block.timestamp <= deadline, \"COToken: expired deadline\"); require(owner != address(0), \"COToken: owner can't be ZERO address \"); bytes32 digest = keccak256( abi.encode( DOMAIN_SEPARATOR, '\\x19\\x01', keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline)) ) ); address signer = ECDSA.recover(digest, v, r, s); require(signer == owner, \"COToken: invalid signature\"); 16 _approve(owner, spender, value); }",
        "labels": [
            "SlowMist",
            "Coordinape protocol",
            "Type: Replay Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing event records",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Coordinape protocol_en-us.pdf",
        "body": "Missing event records are not conducive to the review of community users. coordinape-protocol/contracts/ApeProtocol/token/TokenAccessControl.sol#L32-47 function disableAllowlist() external onlyOwner { require(!allowlistDisabled, \"AccessControl: Allowlist already disabled\"); } allowlistDisabled = true; function changePauseStatus(bool _status) external onlyOwner { require(!foreverUnpaused, \"AccessControl: Contract is unpaused forever\"); } paused = _status; function disablePausingForever() external onlyOwner { require(!foreverUnpaused, \"AccessControl: Contract is unpaused forever\"); } foreverUnpaused = true; paused = false; 17 coordinape-protocol/contracts/ApeProtocol/token/TokenAccessControl.sol#L81-84 function disableMintingForever() external onlyOwner { require(!mintingDisabled, \"AccessControl: Contract cannot mint anymore\"); } mintingDisabled = true; coordinape-protocol/contracts/ApeProtocol/wrapper/beacon/ApeBeacon.sol#L23-28 function transferProxyOwnership(address _newOwner) external { require(msg.sender == proxyOwner()); assembly { sstore(_OWNER_SLOT, _newOwner) } } coordinape-protocol/contracts/ApeProtocol/wrapper/beacon/ApeRegistryBeacon.sol#37-L40 function pushNewImplementation(address _newImplementation) public itself { require(Address.isContract(_newImplementation), \"ApeRegistryBeacon: implementaion is not a contract\"); deployments[++deploymentCount] = _newImplementation; } coordinape-protocol/contracts/ApeProtocol/ApeRegistry.sol#L17-L35 function setFeeRegistry(address _registry) external itself { feeRegistry = _registry; } function setRouter(address _router) external itself { router = _router; } function setDistributor(address _distributor) external itself { distributor = _distributor; } 18 function setFactory(address _factory) external itself { factory = _factory; } function setTreasury(address _treasury) external itself { treasury = _treasury; } coordinape-protocol/contracts/ApeProtocol/ApeRouter.sol#L87-L89 function setRegistry(address _registry) external itself { yearnRegistry = _registry; }",
        "labels": [
            "SlowMist",
            "Coordinape protocol",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Coding optimization",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Coordinape protocol_en-us.pdf",
        "body": "getVariableFee function does not modify contract data, but does not use view. coordinape-protocol/contracts/ApeProtocol/FeeRegistry.sol#L24 function getVariableFee(uint256 _yield, uint256 _tapTotal) external returns(uint256 variableFee) { if (!on) return 0; uint256 yieldRatio = _yield * 1000 / _tapTotal; uint256 baseFee = 100; if (yieldRatio >= 900) variableFee = baseFee; // 1% @ 90% yield ratio else if (yieldRatio >= 800) variableFee = baseFee + 25; // 1.25% @ 80% yield ratio 19 else if (yieldRatio >= 700) variableFee = baseFee + 50; // 1.50% @ 70% yield ratio else if (yieldRatio >= 600) variableFee = baseFee + 75; // 1.75% @ 60% yield ratio else if (yieldRatio >= 500) variableFee = baseFee + 100; // 2.00% @ 80% yield ratio else if (yieldRatio >= 400) variableFee = baseFee + 125; // 2.25% @ 80% yield ratio else if (yieldRatio >= 300) variableFee = baseFee + 150; // 2.50% @ 80% yield ratio else if (yieldRatio >= 200) variableFee = baseFee + 175; // 2.75% @ 80% yield ratio else if (yieldRatio >= 100) variableFee = baseFee + 200; // 3.00% @ 80% yield ratio else } variableFee = baseFee + 250; // 3.50% @ 0% yield ratio",
        "labels": [
            "SlowMist",
            "Coordinape protocol",
            "Type: Authority Control Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Business logic is not clear",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Coordinape protocol_en-us.pdf",
        "body": "The _issueInvite function will execute the mint logic, but the burn is annotated in _revokeInvite, the business logic is not clear. coordinape-protocol/contracts/circles_obsolete/CoordinapeCircle.sol#L158-L175 function _issueInvite(address recipient, uint8 role) internal { Counters.increment(_inviteIds); uint256 tokenId = Counters.current(_inviteIds); _mint(recipient, tokenId); _roles[tokenId] = role; 20 _invites[recipient] = tokenId; _vouches[recipient] = 0; emit InviteIssued(recipient, role); } function _revokeInvite(address recipient) internal { uint256 tokenId = _invites[recipient]; _inactiveMembers.increment(); //_burn(tokenId); _roles[tokenId] = 0; _invites[recipient] = 0; emit InviteRevoked(recipient, 0); } _epochEnds is never initialized, and used in _epochInProgress function. coordinape-protocol/contracts/circles_obsolete/CoordinapeCircle.sol#L155 function _epochInProgress() internal view returns (bool) { uint256 epochId = Counters.current(_epochIds); // return epochId > 0 && !CoordinapeEpoch(_epochs[epochId]).ended(); return epochId > 0 && block.number < _epochEnds[epochId]; } _epochState is never initialized. and it is used in state function. coordinape-protocol/contracts/circles_obsolete/CoordinapeCircle.sol#L105 function state(uint256 _epoch) external view returns (uint8) { return _epochState[_epoch]; } The address passed in by the _migrate function is address(this), which means migrating to the address(this) contract, the logic here is not clear. coordinape-protocol/contracts/ApeProtocol/wrapper/beacon/ApeVault.sol#L166-L169 21 function apeMigrate() external onlyOwner returns(uint256 migrated){ migrated = _migrate(address(this)); vault = VaultAPI(registry.latestVault(address(token))); } migrated = _deposit(address(this), account, withdrawn, false); account is address(this), the logic here is wrong coordinape-protocol/contracts/ApeProtocol/wrapper/beacon/BaseWrapperImplementation.sol#L387-L427 function _migrate(address account) internal returns (uint256) { return _migrate(account, MIGRATE_EVERYTHING); } function _migrate(address account, uint256 amount) internal returns (uint256) { // NOTE: In practice, it was discovered that <50 was the maximum we've see for this variance return _migrate(account, amount, 0); } function _migrate( address account, uint256 amount, uint256 maxMigrationLoss ) internal returns (uint256 migrated) { VaultAPI _bestVault = bestVault(); // NOTE: Only override if we aren't migrating everything uint256 _depositLimit = _bestVault.depositLimit(); uint256 _totalAssets = _bestVault.totalAssets(); if (_depositLimit <= _totalAssets) return 0; // Nothing to migrate (not a failure) uint256 _amount = amount; if (_depositLimit < UNCAPPED_DEPOSITS && _amount < WITHDRAW_EVERYTHING) { // Can only deposit up to this amount uint256 _depositLeft = _depositLimit.sub(_totalAssets); if (_amount > _depositLeft) _amount = _depositLeft; } 22 if (_amount > 0) { // NOTE: `false` = don't withdraw from `_bestVault` uint256 withdrawn = _withdraw(account, address(this), _amount, false); if (withdrawn == 0) return 0; // Nothing to migrate (not a failure) // NOTE: `false` = don't do `transferFrom` because it's already local migrated = _deposit(address(this), account, withdrawn, false); // NOTE: Due to the precision loss of certain calculations, there is a small inefficency // on how migrations are calculated, and this could lead to a DoS issue. Hence, this // value is made to be configurable to allow the user to specify how much is acceptable require(withdrawn.sub(migrated) <= maxMigrationLoss); } // else: nothing to migrate! (not a failure) } The return value of decimals is 0, and developers need to conrm the business logic here. coordinape-protocol/contracts/circles_obsolete/CoordinapeEpoch.sol#L143-L145 function decimals() public pure override returns (uint8) { return 0; }",
        "labels": [
            "SlowMist",
            "Coordinape protocol",
            "Type: Others",
            "Severity: High"
        ]
    },
    {
        "title": "Coding standards issues 23",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Coordinape protocol_en-us.pdf",
        "body": "Executed rst _call(id, _target, _data); and then executed timestamps[id] = _DONE_TIMESTAMP; , which does not meet the specication(Checks-Eects-Interactions). coordinape-protocol/contracts/ApeProtocol/TimeLock.sol#L72-L73 function execute(address _target, bytes calldata _data, bytes32 _predecessor, bytes32 _salt, uint256 _delay) external onlyOwner { bytes32 id = hashOperation(_target, _data, _predecessor, _salt); require(isReadyCall(id), \"TimeLock: Not ready for execution or executed\"); require(_predecessor == bytes32(0) || isDoneCall(_predecessor), \"TimeLock: Predecessor call not executed\"); _call(id, _target, _data); timestamps[id] = _DONE_TIMESTAMP; } function _call( bytes32 id, address target, bytes calldata data ) internal { (bool success, ) = target.call(data); require(success, \"Timelock: underlying transaction reverted\"); emit CallExecuted(id, target, data); }",
        "labels": [
            "SlowMist",
            "Coordinape protocol",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "The external call does not judge the return value 24",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Coordinape protocol_en-us.pdf",
        "body": "The external call in the _withdraw function does not evaluate the return value E.g vaults[id].transferFrom , vault.transfer , IERC20(_token).transfer If the transferFrom function and transfer of the externally called token contract return false, the code logic will be wrong. coordinape-protocol/contracts/ApeProtocol/wrapper/beacon/BaseWrapperImplementation.sol#L353-L362 function _withdraw( address sender, address receiver, uint256 amount, // if `MAX_UINT256`, just withdraw everything bool withdrawFromBest // If true, also withdraw from `_bestVault` ) internal returns (uint256 withdrawn) { VaultAPI _bestVault = bestVault(); VaultAPI[] memory vaults = allVaults(); _updateVaultCache(vaults); // NOTE: This loop will attempt to withdraw from each Vault in `allVaults` that `sender` // is deposited in, up to `amount` tokens. The withdraw action can be expensive, // so it if there is a denial of service issue in withdrawing, the downstream usage // of this wrapper contract must give an alternative method of withdrawing using // this function so that `amount` is less than the full amount requested to withdraw // (e.g. \"piece-wise withdrawals\"), leading to less loop iterations such that the // DoS issue is mitigated (at a tradeoff of requiring more txns from the end user). for (uint256 id = 0; id < vaults.length; id++) { if (!withdrawFromBest && vaults[id] == _bestVault) { continue; // Don't withdraw from the best } 25 // Start with the total shares that `sender` has uint256 availableShares = vaults[id].balanceOf(sender); // Restrict by the allowance that `sender` has to this contract // NOTE: No need for allowance check if `sender` is this contract if (sender != address(this)) { availableShares = Math.min(availableShares, vaults[id].allowance(sender, address(this))); } // Limit by maximum withdrawal size from each vault availableShares = Math.min(availableShares, vaults[id].maxAvailableShares()); if (availableShares > 0) { // Intermediate step to move shares to this contract before withdrawing // NOTE: No need for share transfer if this contract is `sender` // if (sender != address(this)) vaults[id].transferFrom(sender, address(this), availableShares); if (amount != WITHDRAW_EVERYTHING) { // Compute amount to withdraw fully to satisfy the request uint256 estimatedShares = amount .sub(withdrawn) // NOTE: Changes every iteration .mul(10**uint256(vaults[id].decimals())) .div(vaults[id].pricePerShare()); // NOTE: Every Vault is different // Limit amount to withdraw to the maximum made available to this contract // NOTE: Avoid corner case where `estimatedShares` isn't precise enough // NOTE: If `0 < estimatedShares < 1` but `availableShares > 1`, this will withdraw more than necessary if (estimatedShares > 0 && estimatedShares < availableShares) { if (sender != address(this)) vaults[id].transferFrom(sender, address(this), estimatedShares); withdrawn = withdrawn.add(vaults[id].withdraw(estimatedShares)); } else { if (sender != address(this)) vaults[id].transferFrom(sender, address(this), availableShares); 26 withdrawn = withdrawn.add(vaults[id].withdraw(availableShares)); } } else { if (sender != address(this)) vaults[id].transferFrom(sender, address(this), availableShares); withdrawn = withdrawn.add(vaults[id].withdraw()); } // Check if we have fully satisfied the request // NOTE: use `amount = WITHDRAW_EVERYTHING` for withdrawing everything if (amount <= withdrawn) break; // withdrawn as much as we needed } } // If we have extra, deposit back into `_bestVault` for `sender` // NOTE: Invariant is `withdrawn <= amount` if (withdrawn > amount && withdrawn.sub(amount) > _bestVault.pricePerShare().div(10**_bestVault.decimals())) { // Don't forget to approve the deposit if (token.allowance(address(this), address(_bestVault)) < withdrawn.sub(amount)) { token.safeApprove(address(_bestVault), UNLIMITED_APPROVAL); // Vaults are trusted } _bestVault.deposit(withdrawn.sub(amount), sender); withdrawn = amount; } // `receiver` now has `withdrawn` tokens as balance if (receiver != address(this)) token.safeTransfer(receiver, withdrawn); } coordinape-protocol/contracts/ApeProtocol/ApeDistributor.sol#L147 function tapEpochAndDistribute( address _vault, bytes32 _circle, address _token, address[] calldata _users, 27 uint256[] calldata _amounts, uint256 _amount, uint8 _tapType) external { require(_users.length == _amounts.length, \"ApeDistributor: Array lengths do not match\"); require(sum(_amounts) == _amount, \"ApeDistributor: Amount does not match sum of values\"); _tap(_vault, _circle, _token, _amount, _tapType, bytes32(type(uint256).max)); for (uint256 i = 0; i < _users.length; i++) IERC20(_token).transfer(_users[i], _amounts[i]); } coordinape-vesting-contracts/contracts/Vesting.sol#L77-L99 function fetchTokens(uint256 _amount) external onlyOwner { IERC20(co).transfer(msg.sender, _amount); } function claim(uint256 _index) external override { uint256 _now = block.timestamp; Vehicule storage vehicule = vehicules[msg.sender][_index]; uint256 upfront = _claimUpfront(vehicule); uint256 start = vehicule.start; if (start == 0) revert(\"Vesting: vehicule does not exist\"); require(_now > start, \"Vesting: cliff !started\"); uint256 end = vehicule.end; uint256 elapsed = min(end, _now) - start; uint256 maxDelta = end - start; // yield = amount * delta / vest_duration - claimed_amount uint256 yield = (vehicule.amount * elapsed / maxDelta) - vehicule.claimed; vehicule.claimed += yield; IERC20(co).transfer(msg.sender, yield + upfront); 28 emit YieldClaimed(msg.sender, yield); }",
        "labels": [
            "SlowMist",
            "Coordinape protocol",
            "Type: Unsafe External Call Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Excessive authority issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Coordinape protocol_en-us.pdf",
        "body": "Owner can transfer assets in the contract. coordinape-protocol/contracts/ApeProtocol/wrapper/beacon/ApeVault.sol#L129 function apeWithdrawSimpleToken(uint256 _amount) public onlyOwner { simpleToken.safeTransfer(msg.sender, _amount); } coordinape-protocol/contracts/ApeProtocol/wrapper/beacon/ApeVault.sol#L139 function apeWithdraw(uint256 _shareAmount, bool _underlying) external onlyOwner { uint256 underlyingAmount = shareValue(_shareAmount); require(underlyingAmount <= underlyingValue, \"underlying amount higher than vault value\"); address router = ApeRegistry(apeRegistry).router(); underlyingValue -= underlyingAmount; vault.safeTransfer(router, _shareAmount); ApeRouter(router).delegateWithdrawal(owner(), address(this), vault.token(), _shareAmount, _underlying); } 29 coordinape-protocol/contracts/ApeProtocol/wrapper/beacon/ApeVault.sol#L154 function exitVaultToken(bool _underlying) external onlyOwner { underlyingValue = 0; uint256 totalShares = vault.balanceOf(address(this)); address router = ApeRegistry(apeRegistry).router(); vault.safeTransfer(router, totalShares); ApeRouter(router).delegateWithdrawal(owner(), address(this), vault.token(), totalShares, _underlying); } Owner can transfer the tokens in the contract. coordinape-vesting-contracts/contracts/Vesting.sol#L77 function fetchTokens(uint256 _amount) external onlyOwner { IERC20(co).transfer(msg.sender, _amount); }",
        "labels": [
            "SlowMist",
            "Coordinape protocol",
            "Type: Authority Control Vulnerability",
            "Severity: High"
        ]
    },
    {
        "title": "Lack of permission checks 30",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Coordinape protocol_en-us.pdf",
        "body": "The createApeVault function does not perform permission checks. Anyone can create ApeVault. If the incoming parameters are malicious (malicious Token or incompatible Token), it will aect the funds in the project. coordinape-protocol/contracts/ApeProtocol/wrapper/beacon/ApeVaultFactory.sol#L22-L27 function createApeVault(address _token, address _simpleToken) external { bytes memory data = abi.encodeWithSignature(\"init(address,address,address,address,address)\", apeRegistry, _token, yearnRegistry, _simpleToken, msg.sender); ApeBeacon proxy = new ApeBeacon(beacon, msg.sender, data); vaultRegistry[address(proxy)] = true; emit VaultCreated(address(proxy)); }",
        "labels": [
            "SlowMist",
            "Coordinape protocol",
            "Type: Authority Control Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "4.3.1.1 Reordering attack risk",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - InsurAce_en-us.pdf",
        "body": "When the owner calls preparePaymentForPayout, it will go to uniswap to calculate the required amountIn, and then perform the swap operation according to the amountIn. There is a risk of rearrangement attacks that may cause losses in the InsurAce pool. It is recommended to check the slippage of swap. Reference https://www.odaily.com/post/5162888 https://medium.com/coinmonks/demystify-the-dark-forest-on-ethereum-sandwich-attacks-5a3ae c9fa33e  contracts/pool/StakersPool.sol function claimPayout( address _fromToken, address _paymentToken, uint256 _settleAmtPT, address _claimTo, uint256 _claimId ) external override allowedCaller { require(_fromToken == poolToken, \"CP:1\"); 23 if (_settleAmtPT == 0) { return; } uint256 temp = _getTokenforExactPaymentToken(_fromToken, _paymentToken, _settleAmtPT); uint256 amountInMax = Math.min(stakedAmount, temp.mul(11).div(10)); uint256 convertOut = _convertTokenforExactPaymentToken(_fromToken, _paymentToken, _settleAmtPT, amountInMax); stakedAmount = stakedAmount.sub(convertOut); claimPayouts.push(convertOut); claimPayoutsClaimId.push(_claimId); _transferTokenTo(_paymentToken, _settleAmtPT, _claimTo, _claimId); } function _convertTokenforExactPaymentToken( address _tokenFrom, address _tokenTo, uint256 _amountOut, uint256 _amountInMax ) private returns (uint256) { require(_tokenFrom != _tokenTo, \"CT2EPT:1\"); address[] memory path = new address[](2); uint256[] memory ret; if (_tokenFrom == Constant.ETHTOKENADDRESS) { path[0] = uniswapRouter.WETH(); path[1] = _tokenTo; ret = uniswapRouter.swapETHForExactTokens{value: _amountInMax}( _amountOut, path, address(this), block.timestamp + 120 //solhint-disable-linenot-rely-on-time ); return ret[0]; } if (_tokenTo == Constant.ETHTOKENADDRESS) { path[0] = _tokenFrom; path[1] = uniswapRouter.WETH(); IERC20Upgradeable(path[0]).approve(Constant.UNISWAPV2_ROUTER_ADDRESS, _amountInMax); ret = uniswapRouter.swapTokensForExactETH( _amountOut, _amountInMax, path, 24 address(this), block.timestamp + 120 //solhint-disable-linenot-rely-on-time ); return ret[0]; } path[0] = _tokenFrom; path[1] = _tokenTo; IERC20Upgradeable(path[0]).approve(Constant.UNISWAPV2_ROUTER_ADDRESS, _amountInMax); ret = uniswapRouter.swapTokensForExactTokens( _amountOut, _amountInMax, path, address(this), block.timestamp + 120 //solhint-disable-linenot-rely-on-time ); return ret[0]; }  contracts/pool/StakersPool.sol function _getTokenforExactPaymentToken( address _tokenFrom, address _tokenTo, uint256 _amount ) private view returns (uint256) { if (_tokenFrom == _tokenTo) { return _amount; } address[] memory path = new address[](2); if (_tokenFrom == Constant.ETHTOKENADDRESS) { path[0] = uniswapRouter.WETH(); } else { path[0] = _tokenFrom; } if (_tokenTo == Constant.ETHTOKENADDRESS) { path[1] = uniswapRouter.WETH(); } else { path[1] = _tokenTo; } 25 uint256[] memory ret = uniswapRouter.getAmountsIn(_amount, path); return ret[0]; } Fix Status: The issues has been fixed.",
        "labels": [
            "SlowMist",
            "InsurAce",
            "Severity: High"
        ]
    },
    {
        "title": "4.3.1.2 Missing permission check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - InsurAce_en-us.pdf",
        "body": "The addCoverOwner function does not perform permission checking, any user can call this function to add owner. It is recommended to add permission check code.  contracts/cover/CoverData.sol function addCoverOwner(address owner) public { require(owner != address(0), \"ACO: 1\"); require(!allCoverOwnerFlagMap[owner], \"ACO: 2\"); allCoverOwnerList.push(owner); allCoverOwnerFlagMap[owner] = true; } Fix Status: The issues has been fixed.",
        "labels": [
            "SlowMist",
            "InsurAce",
            "Severity: High"
        ]
    },
    {
        "title": "4.3.2.1 DoS issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - InsurAce_en-us.pdf",
        "body": "_getDelAccuRwAmtPS has 3 while loop nestings, which will be affected by the parameters of lastScheduleCounter, gRewardTokenRatePerStakedTokenArray, _unstakeLockArrayBlockPerStaker, and dos due to more users or more mining cycles added.  contracts/staking/ScheduledMiningProgram.sol function _getDelAccuRwAmtPS( uint256 _lastCalculatedBlockPerStaker, uint256 _stakedAmtPerStaker, uint256[] memory _unstakeLockArrayBlockPerStaker, uint256[] memory _unstakeLockArrayAmtPerStaker 26 ) private view returns (uint256) { console.log(\"getDeltaAccumulativeRewardAmtPerStaker++\"); console.log(_lastCalculatedBlockPerStaker); console.log(_stakedAmtPerStaker); console.log(_unstakeLockArrayBlockPerStaker.length); uint256 retV = 0; //gothruthelistofallschedules uint256 scheduleIndex = lastScheduleCounter; while (scheduleIndex >= 1) { if (_lastCalculatedBlockPerStaker >= endMiningBlockPerSchedule[scheduleIndex]) { break; } //narrowdownblockdelta uint256 minWall = Math.max(_lastCalculatedBlockPerStaker, startMiningBlockPerSchedule[scheduleIndex]); uint256 maxWall = Math.min(block.number, endMiningBlockPerSchedule[scheduleIndex]); console.log(\"minWall: \", minWall); console.log(\"maxWall: \", maxWall); if (minWall >= maxWall) { scheduleIndex = scheduleIndex.sub(1); continue; } uint256 rateChangeIndex = gRewardTokenRatePerStakedTokenArray.length; if (rateChangeIndex == 0) { break; } uint256 rewardAccumulatedBetweenWalls = 0; while (rateChangeIndex > 0) { uint256 blockNumber = gRewardTokenRatePerStakedTokenArray[rateChangeIndex - 1]; console.log(\"blockNumber: \", blockNumber); if (blockNumber >= maxWall) { rateChangeIndex = rateChangeIndex.sub(1); continue; } if (blockNumber >= minWall) { uint256 delta = _getDeltaAccumulativeRewardsWithFixRatePerStaker(blockNumber, maxWall, gRewardTokenRatePerStakedTokenMap[blockNumber], _stakedAmtPerStaker, _unstakeLockArrayBlockPerStaker, _unstakeLockArrayAmtPerStaker); rewardAccumulatedBetweenWalls = delta.add(rewardAccumulatedBetweenWalls); maxWall = blockNumber; rateChangeIndex = rateChangeIndex.sub(1); continue; 27 } if (blockNumber < minWall) { uint256 delta = _getDeltaAccumulativeRewardsWithFixRatePerStaker(minWall, maxWall, gRewardTokenRatePerStakedTokenMap[blockNumber], _stakedAmtPerStaker, _unstakeLockArrayBlockPerStaker, _unstakeLockArrayAmtPerStaker); rewardAccumulatedBetweenWalls = delta.add(rewardAccumulatedBetweenWalls); break; } } retV = rewardAccumulatedBetweenWalls.add(retV); scheduleIndex = scheduleIndex.sub(1); } return retV; } Fix Status: This issue has been fixed",
        "labels": [
            "SlowMist",
            "InsurAce",
            "Severity: Medium"
        ]
    },
    {
        "title": "4.3.3.1 Excessive authority issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - InsurAce_en-us.pdf",
        "body": "Admin has permission to add sender, There is a issues of excessive authority. It is recommended to set Owner to Timelock contract or governance contract.  contracts/token/INSURToken.sol function addSender(address _from) external onlyAdmin { if (1 == transferFromAllowedList[_from]) { return; } membersFrom.push(_from); transferFromAllowedList[_from] = 1; } The admin can remove the sender arbitrarily, and there is a risk of denial of service. When the admin adds too many senders, the data in the memberFrom array will be very large, so when the removeSender is removed, the depth of the for loop call will be too large, resulting in The call fails. It 28 is recommended to change memberFrom to storage in the way of mapping, and use address as the key to avoid dos caused by this type of looping to obtain data.  contracts/token/INSURToken.sol function removeSender(address _from) external onlyAdmin { uint256 arrayLength = membersFrom.length; uint256 indexToBeDeleted; bool toDelete = false; for (uint256 i = 0; i < arrayLength; i++) { if (membersFrom[i] == _from) { indexToBeDeleted = i; toDelete = true; break; } } if (!toDelete) { return; } //ifindextobedeletedisnotthelastindex,swapposition. if (indexToBeDeleted < arrayLength - 1) { membersFrom[indexToBeDeleted] = membersFrom[arrayLength - 1]; } //wecannowreducethearraylengthby1 membersFrom.pop(); delete transferFromAllowedList[_from]; } MINTER can call mint arbitrarily, and there is no upper limit for minting.  contracts/token/INSURToken.sol function mint(address to, uint256 amount) public virtual { require(hasRole(MINTER_ROLE, _msgSender()), \"ERC20PresetMinterPauser: must have minter role to mint\"); _mint(to, amount); } Fix Status: This issue has been confirmed  after communication and feedback, the minting and Owner permissions may be transferred to address(0) in the future. 29 Owner can set lpTokenMinter and lpTokenBurner. The roles of lpTokenMinter and lpTokenBurner can mint and burn the user's LP. There is a issues of excessive authority. It is recommended to set Owner to Timelock contract or governance contract. And make sure the lpTokenMinter and lpTokenBurner cannot be EOA account.  contracts/token/LPToken.sol function setup(address _lpTokenMinter, address _lpTokenBurner) external onlyOwner { require(_lpTokenMinter != address(0), \"S:1\"); lpTokenMinter = _lpTokenMinter; require(_lpTokenBurner != address(0), \"S:2\"); lpTokenBurner = _lpTokenBurner; } Fix Status: This issue has been communicated back to the project team. The project team is aware of this and will adopt governance mechanism to secure the permission when the governance module goes live.",
        "labels": [
            "SlowMist",
            "InsurAce",
            "Severity: Low"
        ]
    },
    {
        "title": "4.3.3.2 DoS issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - InsurAce_en-us.pdf",
        "body": "The incoming _callers will add data to allowedCallersArray[_callee]. If too many _callers are added at one time, it will cause Out of Gas. When there are too many data in allowedCallersArray[_callee], the setAllowdCallersPerCallee function will DoS. It is recommended to set the data Use the mapping method to store instead, avoid using the for loop to find the value.  contracts/secmatrix/SecurityMatrix.sol function addAllowdCallersPerCallee(address _callee, address[] memory _callers) external onlyOwner { require(_callers.length != 0, \"AACPC:1\"); require(allowedCallersArray[_callee].length != 0, \"AACPC:2\"); for (uint256 index = 0; index < _callers.length; index++) { console.log(\"_callers index: \", _callers[index], index); allowedCallersArray[_callee].push(_callers[index]); 30 allowedCallersMap[_callee][_callers[index]] = 1; } }  contracts/secmatrix/SecurityMatrix.sol function setAllowdCallersPerCallee(address _callee, address[] memory _callers) external onlyOwner { console.log(\"_callee: \", _callee); console.log(\"_callers.length: \", _callers.length); require(_callers.length != 0, \"SACPC:1\"); //checkifcalleeexist if (allowedCallersArray[_callee].length == 0) { //notexist,soaddcallee allowedCallees.push(_callee); } else { //ifcalleeexist,thenpurgedata for (uint256 i = 0; i < allowedCallersArray[_callee].length; i++) { delete allowedCallersMap[_callee][allowedCallersArray[_callee][i]]; } delete allowedCallersArray[_callee]; } //andoverwrite for (uint256 index = 0; index < _callers.length; index++) { console.log(\"_callers index: \", _callers[index], index); allowedCallersArray[_callee].push(_callers[index]); allowedCallersMap[_callee][_callers[index]] = 1; } } Fix Status: This issue has been communicated back to project team. The project team is aware of this issue and the method will only be used by admin when setting up security matrix. The setAllowdCallersPerCallee method will be used to create security matrix entries, and the addAllowdCallersPerCallee method will be used to add delta matrix if needed.",
        "labels": [
            "SlowMist",
            "InsurAce",
            "Severity: Low"
        ]
    },
    {
        "title": "4.3.3.3 Repeatable call risk",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - InsurAce_en-us.pdf",
        "body": "If Owner call setupVestors function multiple times, there will be duplicate vestors in the vestor 31 array.When the setupVestors is called multiple times, if the vestor calls withdrawRewardPV intentionally or unintentionally during the calling process, initRewardPV and insurVestingTotalPV may get unexpected values. If setupVestors can be called multiple times, then when the owner is called, the vestor also calls withdrawRewardPV. In this case, the gas price of calling withdrawRewardPV is higher than that of calling setupVestors. Will execute withdrawRewardPV first, and then execute setupVestors, the data will appear unexpected. Competitive conditions similar to approve.  contracts/fixedvesting/FixedVesting.sol function setupVestors( address[] memory _vestors, uint256[] memory _vestingRewardPV, uint256[] memory _initRewardPV ) external onlyOwner { require(_vestors.length == _vestingRewardPV.length, \"AV:1\"); require(_initRewardPV.length == _vestingRewardPV.length, \"AV:2\"); for (uint256 i = 0; i < _vestors.length; i++) { address vestor = _vestors[i]; vestors.push(vestor); initRewardPV[vestor] = _initRewardPV[i]; insurVestingTotalPV[vestor] = _vestingRewardPV[i]; } } Fix Status: This issue has been fixed.",
        "labels": [
            "SlowMist",
            "InsurAce",
            "Severity: Low"
        ]
    },
    {
        "title": "4.3.3.4 Overflow risk",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - InsurAce_en-us.pdf",
        "body": "safemath should be used to calculate the length of the array to avoid overflow issues: if Currency is not added, the removal may cause overflow issues.  contracts/cover/CoverConfig.sol 32 function removeCurrency(address currency) external allowedCaller { require(currency != address(0), \"RC: 1\"); uint256 arrayLength = currencyValidAddressArray.length; uint256 indexToBeDeleted; bool toDelete = false; for (uint256 i = 0; i < arrayLength; i++) { if (currencyValidAddressArray[i] == currency) { indexToBeDeleted = i; toDelete = true; break; } } if (!toDelete) { require(toDelete, \"RC: 1\"); } //ifindextobedeletedisnotthelastindex,swapposition. if (indexToBeDeleted < arrayLength - 1) { currencyValidAddressArray[indexToBeDeleted] = currencyValidAddressArray[arrayLength - 1]; } //wecannowreducethearraylengthby1 currencyValidAddressArray.pop(); delete currencyValidAddressMap[currency]; } Fix Status: This issue has been fixed.",
        "labels": [
            "SlowMist",
            "InsurAce",
            "Severity: Low"
        ]
    },
    {
        "title": "4.3.3.5 FlashLoan attack risk",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - InsurAce_en-us.pdf",
        "body": "Unstake is judged by >= when there are already voting tasks. If claimsAssessorMinUnstakeTime is 0, then there will be a issue of using flashloan to vote.  contracts/claim/Claim.sol function unstake(address insurTokenAddress, uint256 insurAmount) external payable whenNotPaused nonReentrant { require(insurTokenAddress != address(0), \"USTK: 1\"); address payable assessor = _msgSender(); ClaimReward(crw).recalculateAssessor(assessor); bool canUnstake = false; 33 uint256 latestVoteTimestamp = ClaimAssessor(asr).getLatestVoteTimestamp(assessor); if (latestVoteTimestamp == 0) { canUnstake = true; } else { if ( block.timestamp >= ClaimAssessor(asr).getVoteStakePeriodEndTime(assessor) //solhint-disable-line not-rely-on-time canUnstake = true; ) { } } require(canUnstake, \"USTK: 2\"); require(insurAmount <= ClaimAssessor(asr).getNumOfVotes(assessor), \"USTK: 3\"); require(IERC20Upgradeable(insurTokenAddress).balanceOf(address(this)) >= insurAmount, \"USTK: 4\"); ClaimAssessor(asr).decreaseVotes(assessor, insurAmount); IERC20Upgradeable(insurTokenAddress).safeTransfer(assessor, insurAmount); } Fix Status: This issue has been fixed.",
        "labels": [
            "SlowMist",
            "InsurAce",
            "Severity: Low"
        ]
    },
    {
        "title": "4.3.4.1 Token compatibility risk",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - InsurAce_en-us.pdf",
        "body": "IERC20Upgradeable(stakedToken).safeTransferFrom(_msgSender(), address(this), _amount); The transfer operation of an external token is adopted. It is recommended to pay attention to the compatibility of the project and the token when adding a new token, such as: token return Value issues, fake token recharge issues, compatibility issues with deflationary tokens, etc.  contracts/staking/StakeOps.sol function stakeTokens(uint256 _amount, address _token) external payable whenNotPaused nonReentrant { require(IMiningProgram(iMiningProgram).canStake(_amount), \"ST:1\"); address stakedToken = StakersData(stakerDataAddr).stakedToken(); require(_token == stakedToken, \"ST:2\"); 34 if (stakedToken == Constant.ETHTOKENADDRESS) { require(_amount <= msg.value, \"ST:3\"); } else { require(IERC20Upgradeable(stakedToken).balanceOf(_msgSender()) >= _amount, \"ST:4\"); uint256 allowanceAmt = IERC20Upgradeable(stakedToken).allowance(_msgSender(), address(this)); require(allowanceAmt >= _amount, \"ST:5\"); } _reCalcPerStaker(); if (stakedToken != Constant.ETHTOKENADDRESS) { IERC20Upgradeable(stakedToken).safeTransferFrom(_msgSender(), address(this), _amount); } //dispatchtokentopool if (stakedToken == Constant.ETHTOKENADDRESS) { IStakersPool(iStakersPool).addStkAmount{value: _amount}(stakedToken, _amount); } else { IERC20Upgradeable(stakedToken).safeTransfer(iStakersPool, _amount); Fix Status: This issue has been communicated back to project team. The project team is aware of this and has already performed compatibility checks on the staking tokens, such as ETH, WETH, USDC, USDT, DAI, and INSUR, which are all compatible with the relevant standards.",
        "labels": [
            "SlowMist",
            "InsurAce",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.3.4.2 Event log is missing",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - InsurAce_en-us.pdf",
        "body": "It is recommended to add an event to record securityMatrix changes, applicable to all set functions. function setup(address _securityMatrix) external onlyOwner { require(_securityMatrix != address(0), \"S:1\"); securityMatrix = _securityMatrix; } Fix Status: This issue has been communicated back to project team. The project team will add more event logs in their development, including not limited to \"setup\".",
        "labels": [
            "SlowMist",
            "InsurAce",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.3.4.3 Redundant code",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - InsurAce_en-us.pdf",
        "body": "The `if (!toDelete) {require(toDelete, \"RC: 1\"); }` code can be simplified to `require(toDelete, \"RC: 1\");`. 35  contracts/cover/CoverConfig.sol function removeCurrency(address currency) external allowedCaller { require(currency != address(0), \"RC: 1\"); uint256 arrayLength = currencyValidAddressArray.length; uint256 indexToBeDeleted; bool toDelete = false; for (uint256 i = 0; i < arrayLength; i++) { if (currencyValidAddressArray[i] == currency) { indexToBeDeleted = i; toDelete = true; break; } } if (!toDelete) { require(toDelete, \"RC: 1\"); } //ifindextobedeletedisnotthelastindex,swapposition. if (indexToBeDeleted < arrayLength - 1) { currencyValidAddressArray[indexToBeDeleted] = currencyValidAddressArray[arrayLength - 1]; } //wecannowreducethearraylengthby1 currencyValidAddressArray.pop(); delete currencyValidAddressMap[currency]; } Fix Status: This issue has been fixed.",
        "labels": [
            "SlowMist",
            "InsurAce",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.3.4.4 Hard coded issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - InsurAce_en-us.pdf",
        "body": "The external contract address is hard-coded and cannot be modified. It is recommended that the external contract adopts a changeable method to avoid the problem that the project cannot operate normally due to the upgrade of the external contract.  common/Constant.sol address public constant UNISWAPV2_ROUTER_ADDRESS = address(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D); 36 Fix Status: This issue has been communicated back to project team. The project team is aware of this issue, and made design changes, such as adding exchange library lately, which will include token to token exchange queries from 1inch and Uniswap. In the case of address change, the ABI of the address may change accordingly, as such the project team will need to double check, and/or extend exchange library in tandem. 5.",
        "labels": [
            "SlowMist",
            "InsurAce",
            "Severity: Informational"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - LightDAO_en-us.pdf",
        "body": "1.In the HOPESalesAgent contract, the owner can add currency that can buy HOPE tokendelete the currency and change the currency exhange rate. If the owners privileges are lost, it could lead to a contract being maliciously added with a worthless currency and used it to unintentionally buy large amounts of hope tokens. ",
        "labels": [
            "SlowMist",
            "LightDAO",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "The DoS issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - LightDAO_en-us.pdf",
        "body": "The user can pass in the gombocAddressList array through the mintMany function to mint the LT. If the length of gombocAddressList is large, it will cause DoS because of the number of for loops. ",
        "labels": [
            "SlowMist",
            "LightDAO",
            "Type: Denial of Service Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Missing event records",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - LightDAO_en-us.pdf",
        "body": "1.In the Minter contract, the caller can toggle the approval status for mintingUser, but there are no event logs. ",
        "labels": [
            "SlowMist",
            "LightDAO",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing zero address check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - LightDAO_en-us.pdf",
        "body": "When modifying important addresses in the contract, it is not checked whether the incoming address is a zero address. ",
        "labels": [
            "SlowMist",
            "LightDAO",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing return value check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - LightDAO_en-us.pdf",
        "body": "When transferring ERC20 tokens, the return value after the transfer is not checked. If return false, the logical should be reverted. ",
        "labels": [
            "SlowMist",
            "LightDAO",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "No value is assigned to the fee parameter",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap Lottery_en-us.pdf",
        "body": "The fee parameter is dened in the RandomNumberGenerator contract and is used in the getRandomNumber function, but the contract is initialized without assigning a value to the fee parameter. ",
        "labels": [
            "SlowMist",
            "PancakeSwap Lottery",
            "Type: Others",
            "Severity: Low"
        ]
    },
    {
        "title": "Issue with reusable joinNFT",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Open Social Core_en-us.pdf",
        "body": "In the RelationLogic contract, users can join a specied community by calling the join or batchJoin function. A joinNFT is minted for the users, and the processJoin function in the community-specic JoinCondition contract is executed to enforce the corresponding join conditions. However, the joinNFT transfers are not restricted in any way, which leads to the following scenario: If a user joins a community that requires a fee, and pays a specied fee to obtain a joinNFT for the community, he can then transfer that NFT to other users, and since the transfer of the joinNFT is not subject to any checking, multiple users can view or manipulate the community's resources or information using a single NFT (paying for it only once). Code Location: contracts/core/logic/RelationLogic.sol function _executeJoin( uint256 communityId, bytes calldata joinConditionData, uint256 value ) internal returns (uint256 tokenId) { OspDataTypes.CommunityStruct memory community = _getCommunityStorage()._communityById[ communityId ]; if (community.joinNFT == address(0)) revert OspErrors.InvalidCommunityId(); tokenId = IJoinNFT(community.joinNFT).mint(msg.sender); if (community.joinCondition != address(0)) { IJoinCondition(community.joinCondition).processJoin{value: value}( msg.sender, communityId, joinConditionData ); } }",
        "labels": [
            "SlowMist",
            "Open Social Core",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Lack of the repeatability check for creating OpenReactions",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Open Social Core_en-us.pdf",
        "body": "In the",
        "labels": [
            "SlowMist",
            "Open Social Core",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Missing inviter check when creating a prole",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Open Social Core_en-us.pdf",
        "body": "In the ProleLogic contract, the user can create a prole by calling the createProle function, but here the inviter parameter is not checked. If the inviter passed in is equal to msg.sender, it does not follow the normal logic. Code Location: contracts/core/logic/ProleLogic.sol#L274 function _createProfile( OspDataTypes.CreateProfileData calldata vars ) internal returns (uint256) { ... if (vars.inviter != 0) { if (_getProfileStorage()._profileById[vars.inviter].owner == address(0)) { revert OspErrors.ProfileDoesNotExist(); } profileStruct.inviter = vars.inviter; } ... }",
        "labels": [
            "SlowMist",
            "Open Social Core",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Lack of check when following other users",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Open Social Core_en-us.pdf",
        "body": "In the RelationLogic contract, anyone can follow other users by calling the follow or batchFollow function. But here it doesn't check if the object to follow is equal to msg.sender, which doesn't follow the normal logic if you can follow yourself. Code Location: contracts/core/logic/RelationLogic.sol#L186-211 function _executeFollow( uint256 profileId, bytes calldata followConditionData, uint256 value ) internal returns (uint256 tokenId) { if (_getProfileStorage()._profileById[profileId].owner == address(0)) revert OspErrors.TokenDoesNotExist(); address followCondition = _getProfileStorage()._profileById[profileId].followCondition; address followSBT = _getProfileStorage()._profileById[profileId].followSBT; if (followSBT == address(0)) { followSBT = _deployFollowSBT(profileId); _getProfileStorage()._profileById[profileId].followSBT = followSBT; } ... }",
        "labels": [
            "SlowMist",
            "Open Social Core",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Lack of check whether a community has been joined",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Open Social Core_en-us.pdf",
        "body": "In the RelationLogic contract, anyone can join a specied community by calling the join or batchJoin function. However, there is no check to see if the user has already joined the community. If the condition of joining the community is that the number of tokens held reaches a set value, then the user can join the community several times to mint joinNFT, and then transfer the NFT to other users (even if the other users' token balances don't meet the requirements). Code Location: contracts/core/logic/RelationLogic.sol#L318-335 function _executeJoin( uint256 communityId, bytes calldata joinConditionData, uint256 value ) internal returns (uint256 tokenId) { OspDataTypes.CommunityStruct memory community = _getCommunityStorage()._communityById[ communityId ]; if (community.joinNFT == address(0)) revert OspErrors.InvalidCommunityId(); tokenId = IJoinNFT(community.joinNFT).mint(msg.sender); ... }",
        "labels": [
            "SlowMist",
            "Open Social Core",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Missing event record",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Open Social Core_en-us.pdf",
        "body": "The following functions in several contracts are for event logging of key parameter settings. Code Location: contracts/core/conditions/community/SlotNFTCommunityCond.sol#L34-36 function whitelistCommunitySlot(address slot, bool whitelist) external onlyOperation { _slotNFTWhitelisted[slot] = whitelist; } contracts/core/conditions/community/WhitelistAddressCommunityCond.sol#L37-39 function setMaxCreationNumber(address to, uint256 _maxCreationNumber) external onlyOperation { maxCreationNumber[to] = _maxCreationNumber; } Code Location: contracts/core/logic/GovernanceLogic.sol#L108-112 function setERC6551AccountImpl( address accountImpl ) external override onlyRole(Constants.GOVERNANCE) { _getGovernanceStorage()._erc6551AccountImpl = accountImpl; }",
        "labels": [
            "SlowMist",
            "Open Social Core",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "call() should be used instead of transfer() and send()",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Open Social Core_en-us.pdf",
        "body": "The transfer() and send() functions forward a xed amount of 2300 gas. Historically, it has often been recommended to use these functions for value transfers to guard against reentrancy attacks. However, the gas cost of EVM instructions may change signicantly during hard forks which may break already deployed contract systems that make xed assumptions about gas costs. For example. EIP 1884 broke several existing smart contracts due to a cost increase of the SLOAD instruction. ",
        "labels": [
            "SlowMist",
            "Open Social Core",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Open Social Core_en-us.pdf",
        "body": "In the OspUniversalProxy contract, the gov role can directly upgrade the implementation contract and call the functions of the new contract. If the privilege is lost or misused, This could lead to malicious tampering with the contract's functionality. ",
        "labels": [
            "SlowMist",
            "Open Social Core",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Authority transfer enhancement",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Open Social Core_en-us.pdf",
        "body": "In the Account contract, the admin role does not adopt the pending and access processes. If the admin is incorrectly set, the permission will be lost. Code Location: contracts/upgradeability/OspRouterImmutable.sol function changeAdmin(address _admin) public onlyAdmin { _changeAdmin(_admin); } ... function _changeAdmin(address admin_) internal { Data storage data = routerStorage(); emit AdminChanged(data.admin, admin_); data.admin = admin_; }",
        "labels": [
            "SlowMist",
            "Open Social Core",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Optimizable bytecode concatenation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase8 - SlowMist Audit Report.pdf",
        "body": "In the setByteCodes function of the Factory and CRPFactory contracts on the Scroll chain, due to the block gasLimit restriction, it is not possible to write the complete contract bytecode into bytecodes in a single transaction. Therefore, the bytecode is concatenated using the concatenate function. The concatenate function uses a for loop to copy and concatenate the bytecode, which consumes a large amount of gas compared to using calldatacopy. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase8 - SlowMist Audit Report",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Ination attack in StoneVault",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - StakeStone_en-us.pdf",
        "body": "In the StoneVault contract, users can can deposit assets and obtain the corresponding share of the vault by calling the deposit function, But there is a risk of interest rate ination attacks here: Consider this example: bob nds out that alice is making a deposit (e.g. via mempool). Pre-condition: no one deposit before( latestRoundID == 0 ) Assume raito = 1e18. Now, alice wants to deposit 1 (1 * 1e18 wei) WETH and the tx is spied on by the attacker(bob). Here is the breakdown: original state (after) Step 1 (after) Step 2 (after) Step 3 totalStone AssetsVault.getBalance() 0 1 1 1 0 1 1e18 + 1 2 * 1e18 + 1 1.bob front-runs alice and deposits 1 wei WETH and gets 1 share: since totalStone is 0, shares = amount = 1. 2.bob also transfers 1 * 1e18 wei WETH, making the WETH balance of the AssetsVault (AssetsVault.getBalance()) become 1e18 + 1 wei. And then directly call the rollToNextRoundId function to update the latestRoundId and price. (Since rebaseTime starts at 0, it can be called successfully directly). 3.alice deposits 1e18 wei WETH. However, alice gets 0 shares: 1e18 * 1 (totalStone) / (1e18 + 1) = 1e18 / (1e18 + 1) = 0. Since alice gets 0 shares, totalStone remains at 1. 4.bob still has the 1 only share ever minted, thus after waiting for the next rollToNextWETH function call for updating the price and the withdrawal of that 1 share takes away everything in the AssetsVault, including the alices 1e18 wei WETH.(Directly by calling the instantWithdraw function and passing in _amount parameter with a value of 0, _shares parameter with a value of 1). Code Location: contracts/StoneVault.sol#L150-173 function _depositFor( uint256 _amount, address _user ) internal returns (uint256 mintAmount) { require(_amount != 0, \"too small\"); uint256 sharePrice; uint256 currSharePrice = currentSharePrice(); if (latestRoundID == 0) { sharePrice = MULTIPLIER; } else { uint256 latestSharePrice = roundPricePerShare[latestRoundID - 1]; sharePrice = latestSharePrice > currSharePrice ? latestSharePrice : currSharePrice; } mintAmount = (_amount * MULTIPLIER) / sharePrice; AssetsVault(assetsVault).deposit{value: address(this).balance}(); Minter(minter).mint(_user, mintAmount); emit Deposit(_user, _amount, mintAmount, latestRoundID); } contracts/StoneVault.sol#L436-453 function currentSharePrice() public returns (uint256 price) { Stone stoneToken = Stone(stone); uint256 totalStone = stoneToken.totalSupply(); if ( latestRoundID == 0 || totalStone == 0 || totalStone == withdrawingSharesInPast ) { return MULTIPLIER; } uint256 etherAmount = AssetsVault(assetsVault).getBalance() + StrategyController(strategyController).getAllStrategiesValue() - withdrawableAmountInPast; uint256 activeShare = totalStone - withdrawingSharesInPast; return (etherAmount * MULTIPLIER) / activeShare; }",
        "labels": [
            "SlowMist",
            "StakeStone",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Missing setting rebaseTime when initializing",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - StakeStone_en-us.pdf",
        "body": "In the StoneVault contract, rebaseTime defaults to 0 and is not set in the constructor function. This could result in any user can call the function directly after the vault is created, potentially combining with other issues to have a signicant impact.(Refer to the N1 issue) Code Location: contracts/StoneVault.sol#L347 function rollToNextRound() external { require( block.timestamp > rebaseTime + rebaseTimeInterval, \"already rebased\" ); ... }",
        "labels": [
            "SlowMist",
            "StakeStone",
            "Type: Others",
            "Severity: Low"
        ]
    },
    {
        "title": "Risks of incorrect withdrawableAmountInPast updates",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - StakeStone_en-us.pdf",
        "body": "In the StoneVault contract, the rollToNextRound function moves the contract to the next round and updates the current round, including withdrawableAmountInPast. However, the price used in the withdrawableAmountInPast update is newSharePrice instead of the current round price (undPricePerShare [latestRoundID]). This results in newSharePrice being larger than the current round price (roundPricePerShare [latestRoundID]) if newSharePrice > previewSharePrice. In the withdrawal operation (instantWithdraw), the number of user withdrawals is actually calculated using roundPricePerShare, so if newSharePrice is larger than roundPricePerShare in the round of commit withdrawals, it may cause the withdrawal withdrawableAmountInPast is actually larger than the total remaining withdrawals. Then there may be the following situation: hypothesis After most withdrawals, totalStone has very little left (such as 1wei), and withdrawableAmountInPast the result of the price bias in statistics mentioned above is actually larger than expected. Then when calculating the current price (currentSharePrice), the calculation of etherAmount may be 0 or even an error due to overow. Code Location: contracts/StoneVault.sol#L387 function rollToNextRound() external { ... uint256 newSharePrice = currentSharePrice(); roundPricePerShare[latestRoundID] = previewSharePrice < newSharePrice ? previewSharePrice : newSharePrice; ... withdrawableAmountInPast = withdrawableAmountInPast + VaultMath.sharesToAsset(withdrawingSharesInRound, newSharePrice); withdrawingSharesInRound = 0; rebaseTime = block.timestamp; emit RollToNextRound(latestRoundID, vaultIn, vaultOut, newSharePrice); }",
        "labels": [
            "SlowMist",
            "StakeStone",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Missing check when migrating the vault",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - StakeStone_en-us.pdf",
        "body": "In the StoneVault contract, the migrateVault function is used to update the stoneVault address in the minter, assetsVault, and strategyController to achieve the eect of migration contracts. However, the migration does not check whether there are pending withdrawal requests in the current stoneVault contract. If the withdrawal request pending in the old stoneVault contract has not been nished during the migration process, then the data has been reset in the new stoneVault contract after the migration, which will cause the shares (stone tokens) transferred to the old stoneVault contract when the user committed the withdrawal request before to be locked and cannot be retrieved. Code Location: contracts/StoneVault.sol#L430-434 function migrateVault(address _vault) external onlyProposal { Minter(minter).setNewVault(_vault); AssetsVault(assetsVault).setNewVault(_vault); StrategyController(strategyController).setNewVault(_vault); }",
        "labels": [
            "SlowMist",
            "StakeStone",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Incorrect return value if the balance is sucient",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - StakeStone_en-us.pdf",
        "body": "When executing a withdrawal, if the eth balance in the AssetsVault contract is insucient, the forceWithdraw function of the controller contract will be called to make up the remaining eth by forcing a withdrawal. In the StrategyController contract, if the eth balance of this contract is sucient, the return value of actualAmount should normally be just what is needed (i.e. the passed ethAmount). But here all eth balances in the contract are returned, which may cause the user to withdraw more tokens than expected. Code Location: contracts/strategies/StrategyController.sol#L63 function forceWithdraw( uint256 _amount ) external onlyVault returns (uint256 actualAmount) { uint256 balanceBeforeRepay = address(this).balance; if (balanceBeforeRepay >= _amount) { _repayToVault(); actualAmount = balanceBeforeRepay; } else { actualAmount = _forceWithdraw(_amount - balanceBeforeRepay) + balanceBeforeRepay; } }",
        "labels": [
            "SlowMist",
            "StakeStone",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Incorrect withdrawal quantity calculation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - StakeStone_en-us.pdf",
        "body": "If the ETH balance in the contract is insucient during forced withdrawals, the instantWithdraw function in each strategy will be called in a loop to make up the dierence. The number of withdrawals for each strategy is calculated as _amount * ratios [strategy])/ONE_HUNDRED_PERCENT. Then there is a situation where if the sum of all ratios is less than ONE_HUNDRED_PERCENT, then the total number of forced withdrawals will be less than expected. (This is possible because the ratio of each strategy is set to only require the sum of all ratios to be less than or equal to ONE_HUNDRED_PERCENT, or a strategy is cleared). Code Location: contracts/strategies/StrategyController.sol#L187 function _forceWithdraw( uint256 _amount ) internal returns (uint256 actualAmount) { uint256 length = strategies.length(); for (uint i; i < length; i++) { address strategy = strategies.at(i); uint256 withAmount = (_amount * ratios[strategy]) / ONE_HUNDRED_PERCENT; if (withAmount != 0) { actualAmount = Strategy(strategy).instantWithdraw(withAmount) + actualAmount; } } _repayToVault(); }",
        "labels": [
            "SlowMist",
            "StakeStone",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Redundant code",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - StakeStone_en-us.pdf",
        "body": "There are useless codes in the le and codes that are not used in actual business. Code Location: contracts/strategies/StrategyController.sol#L51-53 function onlyRebaseStrategies() external { _rebase(0, 0); }",
        "labels": [
            "SlowMist",
            "StakeStone",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Incorrect PendingValue calculations in the STETHHoldingStrategy",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - StakeStone_en-us.pdf",
        "body": "In the STETHHoldingStrategy contract, the getPendingValue function is used to calculate the value of eth in the withdrawal process. However, only the amount of eth that has not passed the request during the withdrawal process is calculated here, and the part that has passed the request but has not been claimed is not calculated. This may cause the rollToNextRound function in the TokenVault contract to call the getAllStrategyPendingValue function to obtain all pending eth values less than expected. Code Location: contracts/strategies/STETHHoldingStrategy.sol#L155-157 function getPendingValue() public override returns (uint256 value) { (, , value) = checkPendingAssets(); } function checkPendingAssets() public returns ( uint256[] memory ids, uint256 totalClaimable, uint256 totalPending ) { ... for (uint256 i; i < length; i++) { ILidoWithdrawalQueue.WithdrawalRequestStatus memory status = statuses[i]; if (status.isClaimed) { continue; } if (status.isFinalized) { ids[j++] = allIds[i]; totalClaimable = totalClaimable + status.amountOfStETH; } else { totalPending = totalPending + status.amountOfStETH; } } ... }",
        "labels": [
            "SlowMist",
            "StakeStone",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Lack of event records",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - StakeStone_en-us.pdf",
        "body": "There is no corresponding event logged when a sensitive parameter in the contract is modied. Code Location: contracts/token/Minter.sol#L30-32 function setNewVault(address _vault) external onlyVault { vault = payable(_vault); } contracts/token/StoneCross.sol#L64-110 function _nonblockingLzReceive( uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload ) internal virtual override { ... if (packetType == PT_SEND) { _sendAck(_srcChainId, _srcAddress, _nonce, _payload); } else if (packetType == PT_FEED) { ... tokenPrice = price; updatedTime = time; } else if (packetType == PT_SET_ENABLE) { ... enable = flag; } else if (packetType == PT_SET_CAP) { ... cap = _cap; } else { revert(\"unknown packet type\"); } } contracts/AssetsVault.sol#L35-37 function setNewVault(address _vault) external onlyPermit { stoneVault = _vault; } contracts/strategies/RETHHoldingStrategy.sol#L158-164 function setRouter( bool _buyOnDex, bool _sellOnDex ) external onlyGovernance { buyOnDex = _buyOnDex; sellOnDex = _sellOnDex; } contracts/strategies/SFraxETHHoldingStrategy.sol#L151-157 function setRouter( bool _buyOnDex, bool _sellOnDex ) external onlyGovernance { buyOnDex = _buyOnDex; sellOnDex = _sellOnDex; } contracts/strategies/STETHHoldingStrategy.sol#L253-259 function setRouter( bool _buyOnDex, bool _sellOnDex ) external onlyGovernance { buyOnDex = _buyOnDex; sellOnDex = _sellOnDex; } contracts/strategies/Strategy.sol#L89-91 function setBufferTime(uint256 _time) external onlyGovernance { bufferTime = _time; } contracts/strategies/StrategyController.sol#L322-324 function setNewVault(address _vault) external onlyVault { stoneVault = _vault; } contracts/strategies/SwappingAggregator.sol#L396-420 function setUniRouter( address _token, address _uniPool, uint256 _slippage, uint24 _fee ) external onlyGovernance { require(_token != address(0), \"ZERO ADDRESS\"); uniV3Pools[_token] = _uniPool; slippage[_token] = _slippage; fees[_token] = _fee; } function setCurveRouter( address _token, address _curvePool, uint8 _curvePoolType, uint256 _slippage ) external onlyGovernance { require(_token != address(0), \"ZERO ADDRESS\"); curvePools[_token] = _curvePool; curvePoolType[_curvePool] = _curvePoolType; slippage[_token] = _slippage; }",
        "labels": [
            "SlowMist",
            "StakeStone",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Authority transfer enhancement",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - StakeStone_en-us.pdf",
        "body": "The permission transfer method for the core roles(like proposer and governance) does not adopt the pending and access processes. If set incorrectly, the permission of the core roles will be lost. Code Location: contracts/strategies/Strategy.sol#L84-87 function setGovernance(address governance_) external onlyGovernance { emit TransferGovernance(governance, governance_); governance = governance_; } contracts/strategies/SwappingAggregator.sol#L422-426 function setGovernance(address governance_) external onlyGovernance { emit TransferGovernance(governance, governance_); governance = governance_; } contracts/governance/Proposal.sol#L138-142 function setProposer(address _proposer) external onlyProposer { emit SetProposer(proposer, _proposer); proposer = _proposer; }",
        "labels": [
            "SlowMist",
            "StakeStone",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Lack of CrossChain fee checking in the bridgeTo function",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - StakeStone_en-us.pdf",
        "body": "In the DepositBridge contract, there is no check in the bridgeTo function to see if the incoming _gasPaidForCrossChain parameter is greater than or equal to the handling fee required to send across the chain. If passed in too small it may cause the cross-chain operation to fail. Code Location: contracts/mining/DepositBridge.sol#L30-41 function bridgeTo( uint256 _amount, bytes calldata _dstAddress, uint256 _gasPaidForCrossChain ) public payable returns (uint256 stoneMinted) { stoneMinted = bridge( msg.sender, _amount, _dstAddress, _gasPaidForCrossChain ); }",
        "labels": [
            "SlowMist",
            "StakeStone",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Missing check for dstChainId on initialisation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - StakeStone_en-us.pdf",
        "body": "In the DepositBridge contract, the dstChainId is set on initialisation, but there is no check to see if the value set is not equal to the chainId of the current chain, which would cause the sendFrom function in the stone tokens to revert and the cross-chain operation to fail. Code Location: contracts/mining/DepositBridge.sol#L27 constructor(address _stone, address payable _vault, uint16 _dstChainId) { ... dstChainId = _dstChainId; }",
        "labels": [
            "SlowMist",
            "StakeStone",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Lack of scope check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - StakeStone_en-us.pdf",
        "body": "1.In Strategy contracts, the setBuerTime function can be used to set the delay time for strategy operations. However, there is no check on the range of the _time parameter passed in, and if it is too large, the normal operation of the strategy contract will be aected. Code Location: contracts/strategies/Strategy.sol#L89-91 function setBufferTime(uint256 _time) external onlyGovernance { bufferTime = _time; } 2.In SwappingAggregator contracts, the Governance role can set the slips corresponding to dierent tokens and the fees charged by calling the setSlippage function, the setUniRouter function, and the setCurveRouter function. However, there is no range checking of incoming new slippage and fees at the time of setup, which could result in arbitrage or unintended depletion of the user's funds if set too high. Code Location: contracts/strategies/SwappingAggregator.sol#L387-420 function setSlippage( address _token, uint256 _slippage ) external onlyGovernance { emit SetSlippage(_token, slippage[_token], _slippage); slippage[_token] = _slippage; } function setUniRouter( address _token, address _uniPool, uint256 _slippage, uint24 _fee ) external onlyGovernance { require(_token != address(0), \"ZERO ADDRESS\"); uniV3Pools[_token] = _uniPool; slippage[_token] = _slippage; fees[_token] = _fee; } function setCurveRouter( address _token, address _curvePool, uint8 _curvePoolType, uint256 _slippage ) external onlyGovernance { require(_token != address(0), \"ZERO ADDRESS\"); curvePools[_token] = _curvePool; curvePoolType[_curvePool] = _curvePoolType; slippage[_token] = _slippage; }",
        "labels": [
            "SlowMist",
            "StakeStone",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Potential governance attacks",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - StakeStone_en-us.pdf",
        "body": "In a Proposal contract, users can call the voteFor function to transfer their holdings of stone tokens into that contract and vote on a specied proposal. However, if the Proposer role is evil (e.g. in the case of lost permissions), it is possible to call the instantWithdraw function or requestWithdraw function in the Stone Vault contract by submitting a proposal and transferring a large number of stone tokens towards the end of the vote to ensure that the proposal passes. After the proposal is executed, it will consume other users' stone tokens and make additional prot (enough to cover the cost of the attack). Code Location: contracts/governance/Proposal.sol#L76-96 function voteFor(address _proposal, uint256 _poll, bool _flag) external { require(canVote(_proposal), \"cannot vote\"); TransferHelper.safeTransferFrom( stoneToken, msg.sender, address(this), _poll ); ... }",
        "labels": [
            "SlowMist",
            "StakeStone",
            "Type: Design Logic Audit",
            "Severity: Information"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - StakeStone_en-us.pdf",
        "body": "1.In SwappingAggregator contracts, the Governance role can set the slips, the exchange router and the fee corresponding to dierent tokens by calling the setSlippage function, the setUniRouter function, and the setCurveRouter function. If the privilege is lost or misused, this may have an impact on the user's assets. Code Location: contracts/strategies/SwappingAggregator.sol#L387-420 function setSlippage( address _token, uint256 _slippage ) external onlyGovernance { emit SetSlippage(_token, slippage[_token], _slippage); slippage[_token] = _slippage; } function setUniRouter( address _token, address _uniPool, uint256 _slippage, uint24 _fee ) external onlyGovernance { require(_token != address(0), \"ZERO ADDRESS\"); uniV3Pools[_token] = _uniPool; slippage[_token] = _slippage; fees[_token] = _fee; } function setCurveRouter( address _token, address _curvePool, uint8 _curvePoolType, uint256 _slippage ) external onlyGovernance { require(_token != address(0), \"ZERO ADDRESS\"); curvePools[_token] = _curvePool; curvePoolType[_curvePool] = _curvePoolType; slippage[_token] = _slippage; } 2.In Proposal contracts, the Proposer role can initiate a proposal by calling the propose function. If the privilege is lost or misused, the Proposer role may launch a malicious proposal causing the user to suer a loss of funds. Code Location: contracts/governance/Proposal.sol#L57-74 function propose(bytes calldata _data) external onlyProposer { ... }",
        "labels": [
            "SlowMist",
            "StakeStone",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Missing return value check when adding strategies",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - StakeStone_en-us.pdf",
        "body": "In StrategyController contracts, the type of data structure used for strategy storage is the EnumerableSet library from openzeppelin. When using the .add() function, it will return false if the added data already exists and will not add the data repeatedly. However, the StrategyController contract does not check the return value of the .add() function when adding or setting a strategy, which may result in strategies not being added but ratios being changed. Code Location: contracts/strategies/StrategyController.sol function _initStrategies( address[] memory _strategies, uint256[] memory _ratios ) internal { ... for (uint i; i < length; i++) { strategies.add(_strategies[i]); ratios[_strategies[i]] = _ratios[i]; totalRatio = totalRatio + _ratios[i]; } require(totalRatio <= ONE_HUNDRED_PERCENT, \"exceed 100%\"); } function _setStrategies( address[] memory _strategies, uint256[] memory _ratios ) internal { ... for (uint i; i < length; i++) { ... strategies.add(_strategies[i]); ratios[_strategies[i]] = _ratios[i]; totalRatio = totalRatio + _ratios[i]; } require(totalRatio <= ONE_HUNDRED_PERCENT, \"exceed 100%\"); }",
        "labels": [
            "SlowMist",
            "StakeStone",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Synclub_en-us.pdf",
        "body": "1.In the SnBnb contract, the DEFAULT_ADMIN_ROLE can set the stakeManager contract as the StakeManager role and the StakeManager role can call the mint and burn functions to mint tokens arbitrarily and burn any users tokens. ",
        "labels": [
            "SlowMist",
            "Synclub",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "The mint amount can be 0 in the deposit function",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Synclub_en-us.pdf",
        "body": "In the SnStakeManager contract, users deposit their BNB into this contract and obtain the SnBNB as the staking certicate. And the calculation of the snBnbToMint is dependent on the convertBnbToSnBnb function, the totalSupply of the SnBNB, and the totalPooledBnb in this contract. If the deposit amount of the BNB is small enough or the totalPooledBnb is big enough, the calculation of the snBnbToMint can be 0. But the amount of the BNB can still add to the amountToDelegate to cause the increment of the totalPooledBnb. ",
        "labels": [
            "SlowMist",
            "Synclub",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "The BNB can be remained in the contract",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Synclub_en-us.pdf",
        "body": "In the SnStakeManager contract when users claim to withdraw their BNB tokens in the claimWithdraw in the same uuid, the calculation of the amount = (totalBnbToWithdraw_ * amountInSnBnb) / totalSnBnbToBurn_; has the rounding to obtain one of the users withdrawal amount. It will cause the rounded amount of the BNB to remain in this contract and can not be withdrawn. ",
        "labels": [
            "SlowMist",
            "Synclub",
            "Type: Arithmetic Accuracy Deviation Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "The business logic is unclear",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Synclub_en-us.pdf",
        "body": "In the SnStakeManager contract, the claimUndelegated function calculates the claimUndelegated withdrawal value in one uuid and assigns it to two temporary variables. The two temporary variables are just for recording and have no other usage. ",
        "labels": [
            "SlowMist",
            "Synclub",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing the validator check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Synclub_en-us.pdf",
        "body": "In the SnStakeManager contract, the Manager role can change the Validator through the redelegate function, and this check is done by the NATIVE_STAKING contract, and if the call of the redelegate function failed, it will consume the gas of this call. ",
        "labels": [
            "SlowMist",
            "Synclub",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing the event records",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Synclub_en-us.pdf",
        "body": "There are no event logs of the claimUndelegated and claimFailedDelegation in this SnStakeManager contract. ",
        "labels": [
            "SlowMist",
            "Synclub",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Preemptive initialization",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Synclub_en-us.pdf",
        "body": "By calling the initialize function to initialize the contracts, there is a potential issue that malicious attackers preemptively call the initialize function to initialize. ",
        "labels": [
            "SlowMist",
            "Synclub",
            "Type: Race Conditions Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Dev address setting enhancement suggestions",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Synclub_en-us.pdf",
        "body": "In the SnStakeManager contract, the GOVERNANCE_ROLE role can set the revenuePool address to receive the fee. If the address is an EOA address, in a scenario where the private keys are leaked, the teams revenue will be stolen. ",
        "labels": [
            "SlowMist",
            "Synclub",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Business logic error Payable Payable Can Modify State - Can Modify State Can Modify State Can Modify State - - - - - - - 13",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ioTube_en-us.pdf",
        "body": "When originalAssetByID gets the data of originalAssets, the _assetID passed in should be reduced by 1, and then readout. activateAsset, deactivateAsset function directly passes in _assetID, and then read originalAssets[_assetID], The judgment is _assetID <= originalAssets.length . There are two issues here: 1. When _assetID == originalAssets.length, originalAssets[_assetID] cannot read data. 2. The originalAssets data obtained here is not obtained using the originalAssetByID function, and the business logic needs to be conrmed. contracts/AssetRegistry.sol#L101-L133 function activateAsset(uint256 _assetID, uint256 _tubeID) public onlyOperator { require(_assetID > 0 && _assetID <= originalAssets.length, \"invalid asset id\"); Asset storage oa = originalAssets[_assetID]; if (_tubeID == 0 || oa.tubeID == _tubeID) { if (oa.active == false) { oa.active = true; emit AssetActivated(_assetID, oa.tubeID); } } else { Asset storage sa = shadowAssets[_assetID][_tubeID]; if (sa.asset != address(0) && sa.active == false) { sa.active = true; emit AssetActivated(_assetID, _tubeID); } } } function deactivateAsset(uint256 _assetID, uint256 _tubeID) public onlyOperator { require(_assetID > 0 && _assetID <= originalAssets.length, \"invalid asset id\"); Asset storage oa = originalAssets[_assetID]; if (_tubeID == 0 || oa.tubeID == _tubeID) { if (oa.active == true) { oa.active = false; 14 emit AssetDeactivated(_assetID, oa.tubeID); } } else { Asset storage sa = shadowAssets[_assetID][_tubeID]; if (sa.asset != address(0) && sa.active == true) { sa.active = false; emit AssetDeactivated(_assetID, _tubeID); } } } originalAssetIDs[_tubeID][_asset] = id; The record is originalAssets.length;, so to take the value of originalAssets, the index should be originalAssetIDs[_tubeID][_asset]-1, combined with the processing logic here, you need to conrm the issues with the developer. contracts/AssetRegistry.sol#L74-L84 function addOriginalAsset(uint256 _tubeID, address _asset) public onlyOperator returns (uint256) { require(_tubeID > 0 && _asset != address(0), \"invalid parameter\"); uint256 id = assetID(_tubeID, _asset); if (id == 0) { originalAssets.push(Asset(_tubeID, _asset, true)); id = originalAssets.length; originalAssetIDs[_tubeID][_asset] = id; emit NewOriginalAsset(_tubeID, _asset, id); } return id; }",
        "labels": [
            "SlowMist",
            "ioTube",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Authority transfer enhancement",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ioTube_en-us.pdf",
        "body": "There is no pending and accept mechanism for authority transfer to avoid loss of authority contracts/CrosschainERC20.sol#L34-L37 function transferMintership(address _newMinter) public onlyMinter { minter = _newMinter; 16 emit MinterSet(_newMinter); } contracts/CrosschainERC721.sol#L29-L32 function transferMintership(address _newMinter) public onlyMinter { minter = _newMinter; emit MinterSet(_newMinter); }",
        "labels": [
            "SlowMist",
            "ioTube",
            "Type: Authority Control Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "unsafe external call risk",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ioTube_en-us.pdf",
        "body": "The withdraw function in the contract code does not check the whitelist of _recipient and _data. There is an unsafe external call (success,) = _recipient.call(_data); . The attacker can use _recipient.call(_data); to call any function of the lord contract, or transfer the token approved by the user to the Tube contract. contracts/Tube.sol#L179-L207 function withdraw( uint256 _srcTubeID, uint256 _txIdx, address _token, address _recipient, uint256 _amount, bytes memory _data, bytes memory _signatures ) public whenNotPaused { require(_amount != 0, \"amount is 0\"); 17 require(_recipient != address(0), \"invalid recipient\"); require(_signatures.length % 65 == 0, \"invalid signature length\"); bytes32 key = genKey(_srcTubeID, _txIdx, _token, _recipient, _amount, _data); ledger.record(key); (bool isValid, address[] memory signers) = verifier.verify(key, _signatures); require(isValid, \"insufficient validators\"); bool success = true; if (_data.length > 0) { lord.mint(_token, address(this), _amount); IERC20(_token).safeApprove(_recipient, _amount); (success, ) = _recipient.call(_data); if (!success) { IERC20(_token).safeDecreaseAllowance(_recipient, _amount); } } else { lord.mint(_token, _recipient, _amount); } emit Settled(key, signers, success); }",
        "labels": [
            "SlowMist",
            "ioTube",
            "Type: Unsafe External Call Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Excessive authority issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ioTube_en-us.pdf",
        "body": "The Owner of the Tube contract has too much authority. The owner of the Lord contract can be changed, and the owner of the Lord contract can execute mint and burn arbitrarily. This will aect the users assets. contracts/Tube.sol#L71-L78 function upgrade(address _newTube) public onlyOwner { if (ledger.owner() == address(this)) { ledger.transferOwnership(_newTube); } 18 if (lord.owner() == address(this)) { lord.transferOwnership(_newTube); } } contracts/Lord.sol#L94-L131 function burn( address _token, address _sender, uint256 _amount ) public onlyOwner { if (address(standardTokenList) != address(0) && standardTokenList.isAllowed(_token)) { // transfer token to standardTokenList _callOptionalReturn( _token, abi.encodeWithSelector(IToken(_token).transferFrom.selector, _sender, tokenSafe, _amount) ); return; } if (address(proxyTokenList) != address(0) && proxyTokenList.isAllowed(_token)) { _callOptionalReturn( _token, abi.encodeWithSelector(IToken(_token).transferFrom.selector, _sender, address(this), _amount) ); _callOptionalReturn(_token, abi.encodeWithSelector(IToken(_token).burn.selector, _amount)); return; } _callOptionalReturn(_token, abi.encodeWithSelector(IToken(_token).burnFrom.selector, _sender, _amount)); } function mint( address _token, address _recipient, uint256 _amount ) public onlyOwner { if (address(standardTokenList) != address(0) && 19 standardTokenList.isAllowed(_token)) { require(tokenSafe.mint(_token, _recipient, _amount), \"token safe mint failed\"); return; } if (address(proxyTokenList) != address(0) && proxyTokenList.isAllowed(_token)) { require(minterPool.mint(_token, _recipient, _amount), \"proxy token mint failed\"); } _callOptionalReturn(_token, abi.encodeWithSelector(IToken(_token).mint.selector, _recipient, _amount)); } function mintNFT( address _token, uint256 _tokenID, address _recipient, bytes memory _data ) public onlyOwner { IERC721Mintable(_token).safeMint(_recipient, _tokenID, _data); } function upgrade(address _newLord) public onlyOwner { if (minterPool.owner() == address(this)) { _callOptionalReturn( address(tokenSafe), abi.encodeWithSelector(minterPool.transferOwnership.selector, _newLord) ); } if (tokenSafe.owner() == address(this)) { _callOptionalReturn( address(tokenSafe), abi.encodeWithSelector(tokenSafe.transferOwnership.selector, _newLord) ); } }",
        "labels": [
            "SlowMist",
            "ioTube",
            "Type: Authority Control Vulnerability",
            "Severity: High"
        ]
    },
    {
        "title": "Business logic aws",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ioTube_en-us.pdf",
        "body": "The swapCoinForCrosschainCoin function will call cerc20.depositTo. contracts/CrosschainCoinRouter.sol#L37-L40 function swapCoinForCrosschainCoin(uint256 _amount) public payable { wrappedCoin.deposit{value: _amount}(); cerc20.depositTo(msg.sender, _amount); } cerc20.depositTo will call safeTransferFrom, where msg.sender is the CrosschainCoinRouter contract, but CrosschainCoinRouter has authorized CrosschainERC20 contract operation assets. contracts/CrosschainERC20.sol#L43-L47 function depositTo(address _to, uint256 _amount) public { require(address(coToken) != address(0), \"no co-token\"); coToken.safeTransferFrom(msg.sender, address(this), _amount); _mint(_to, _amount); } Although the allowance is set to -1, under extreme conditions, the continuous consumption quota will still be reduced to no quota. At this time, the contract cannot be used without re-approve. contracts/CrosschainCoinRouter.sol#L20-L25 constructor(CrosschainERC20 _cerc20) public { ERC20 ct = _cerc20.coToken(); cerc20 = _cerc20; ct.safeApprove(address(cerc20), uint256(-1)); 21 wrappedCoin = WrappedCoin(address(ct)); }",
        "labels": [
            "SlowMist",
            "ioTube",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Excessive authority issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ioTube_en-us.pdf",
        "body": "Owner can set the relayfee arbitrarily, and there is no limit on the value range. When the relayfee is set to a large value, most of the user's funds will be used to pay the relayFees. contracts/TubeRouter.sol#L49-L55 function setRelayFee(uint256 _tubeID, uint256 _fee) public onlyOwner { if (_fee == 0) { relayFees[_tubeID].exists = false; } else { relayFees[_tubeID] = RelayFee(_fee, true); } }",
        "labels": [
            "SlowMist",
            "ioTube",
            "Type: Authority Control Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Coding optimization",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ioTube_en-us.pdf",
        "body": "22 Owner can withdraw ETH and token in the contract. There are relayFees in the TubeRouter contract, and the Owner can withdraw the relayFees through the withdrawToken function, However, withdrawCoin and withdrawToken are used to extract the assets that were unexpectedly credited into the contract. contracts/TubeRouter.sol#L97-L106 function withdrawCoin(address payable _to) external onlyOwner { _to.transfer(address(this).balance); } function withdrawToken(address _to, IERC20 _token) external onlyOwner { uint256 balance = _token.balanceOf(address(this)); if (balance > 0) { _token.safeTransfer(_to, balance); } } contracts/Tube.sol#L229-L238 function withdrawCoin(address payable _to) external onlyOwner { _to.transfer(address(this).balance); } function withdrawToken(address _to, IERC20 _token) external onlyOwner { uint256 balance = _token.balanceOf(address(this)); if (balance > 0) { _token.safeTransfer(_to, balance); } }",
        "labels": [
            "SlowMist",
            "ioTube",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Other safety reminders",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ioTube_en-us.pdf",
        "body": "Note that when signing, make sure that the K value is not the same in the signature implementation. In the elliptic curve signature algorithm, if the random number is not safe enough and the same K value random number is used, there will be two transactions with the same R value. , So that the private key can be calculated, please pay attention to investigate similar cryptographic implementations. Reference: https://panzhibiao.com/2019/03/13/important-random-k-and-fake-signatures/ To capture events in the cross-chain bridge, the implementation of subscribing to the events of the specied contract should be adopted to avoid the attacks of fake contract events",
        "labels": [
            "SlowMist",
            "ioTube",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Recommendations for Parameter Declarations - - - - - - - - - - - - - - - - - - -",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase4 - SlowMist Audit Report.pdf",
        "body": "In the DTBT contract, the _name and _symbol parameters are hardcoded with xed values, but they are not declared as constants, which will result in additional gas consumption. The same is true for stableCoinReceiver , sTBTReceiver , stbt , stableCoin parameters in the TBillSimple contract. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase4 - SlowMist Audit Report",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Invalid function return value",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase4 - SlowMist Audit Report.pdf",
        "body": "In the DTBT contract, the owner role can modify the decimals of the contract through the updateDecimals function. This function denes the return value, but it does not return any value. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase4 - SlowMist Audit Report",
            "Type: Others",
            "Severity: Low"
        ]
    },
    {
        "title": "The transfer return value that does not conform to the EIP20 interface standard",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase4 - SlowMist Audit Report.pdf",
        "body": "In the DTBT contract, users can transfer DTBT tokens through the transferFrom function. However, the implementation of this function does not comply with the return value standard specied in EIP20. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase4 - SlowMist Audit Report",
            "Type: Others",
            "Severity: Low"
        ]
    },
    {
        "title": "Redundant Period enum",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase4 - SlowMist Audit Report.pdf",
        "body": "The Period enum is dened in the TBillSimple contract, but it is not used in the contract. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase4 - SlowMist Audit Report",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing error message",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase4 - SlowMist Audit Report.pdf",
        "body": "In the DTBT contract, the add/sub function users add and subtract mathematically. It will perform overow checks through require , but no error message will be thrown when the check fails, which will prevent users from intuitively obtaining the cause of the error. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase4 - SlowMist Audit Report",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Hardcoded testnet address issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase4 - SlowMist Audit Report.pdf",
        "body": "In the TBillSimple contract, the parameters of stableCoinReceiver, sTBTReceiver, stbt, and stableCoin are all hardcoded with the address of the Goerli testnet. If the hard-coded address is not modied when the protocol is launched on the mainnet, the protocol will not work properly. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase4 - SlowMist Audit Report",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "collectEndTime is not checked",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase4 - SlowMist Audit Report.pdf",
        "body": "In the TBillSimple contract, managers can buy/sell STBT through the swap function. It checks whether the current time is less than the closing end time of the ETF, but does not check whether the current time is greater than the fundraising end time of the ETF. Although it will check whether the isCompletedCollect status of the ETF is true through _checkTx , users can still add liquidity to the ETF at this time. If the swap operation is performed at this time, the stableCoin will be unbound, and users will not be able to add liquidity during the fundraising period, which is inconsistent with the design expectation. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase4 - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Missing 0 balance check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase4 - SlowMist Audit Report.pdf",
        "body": "In the TBillSimple contract, managers can synchronize the stableCoin position data in bPool through the rebalance function. But it does not check whether the stableCoin balance in bPool is greater than 0, and if the balance is 0, the rebind operation is meaningless. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase4 - SlowMist Audit Report",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Decimal conversion causes data mismatch",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase4 - SlowMist Audit Report.pdf",
        "body": "In the TBillSimple contract, managers can buy/sell STBT through the swap function. It will adjust the ETF position through _sendStableCoin and _sendSTBT functions respectively, and use _decimalsHandle function to perform decimal conversion between stableCoin and stbt tokens. However, due to the fact that solidity will truncate decimals when performing division operations, there will be some precision loss when converting large decimals to small decimals. This will cause the calculation result of _decimalsHandle to be smaller than the actual amount of tokens received by the ETF, causing the Record data of the ETF to be inconsistent with the actual balance. In fact, the rebalance function in the TBillSimple contract can alleviate the problem of the mismatch between the stableCoin balance and Record data, but the contract does not implement the rebalance operation for STBT tokens. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase4 - SlowMist Audit Report",
            "Type: Arithmetic Accuracy Deviation Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Incorrect DTBT amount update",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase4 - SlowMist Audit Report.pdf",
        "body": "In the TBillSimple contract, it uses DTBT instead of STBT for timely accounting operations. When ETF sells STBT, it will burn the balance of DTBT tokens in bPool and unbond them, but it does update the DTBT with the same balance through _updateDtbtAmount function by mistake, which will make the amount of DTBT tokens in bPool not decrease , which is not as expected by design. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase4 - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Invalid execution result capture",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase4 - SlowMist Audit Report.pdf",
        "body": "In the TBillSimple contract, the _invokeUnbind function is used to unbind the specied token in the ETF. It captures the result of the operation through try-catch , but does not process the result of the operation in the catch. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase4 - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Typo issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase4 - SlowMist Audit Report.pdf",
        "body": "In the smart join/exit pool function of the Actions contract, it will receive the handleToken parameter to specify the source token or target token of the token swap. But it is wrong to write this parameter as handleToekn. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase4 - SlowMist Audit Report",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "The length of minAmountsOut is not checked",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase4 - SlowMist Audit Report.pdf",
        "body": "In the Actions contract, the autoExitSmartPool function user removes the user's liquidity and converts the obtained tokens into the specied tokens, and performs a slippage check through the minAmountsOut parameter passed in by the user. However, the function does not check whether the length of the minAmountsOut list is the same as the length of the tokens. If the length of the incoming list is shorter than the expected length, the transaction may fail and waste gas. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase4 - SlowMist Audit Report",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Redundant approval operation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase4 - SlowMist Audit Report.pdf",
        "body": "In the Actions contract, the autoExitSmartPool function user removes user liquidity and converts the obtained tokens into specied tokens. It will rst approve the pool tokens in this contract to the contract itself, and then perform _exit operation. But the self-approval operation is meaningless. If the contract needs to transfer tokens, it can be transferred directly through transfer without approval, which is a waste of gas. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase4 - SlowMist Audit Report",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "The validity of the aggregator is not checked",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase4 - SlowMist Audit Report.pdf",
        "body": "In the Actions contract, the smart join/exit pool mode will help users exchange tokens through the _makeSwap function. It performs token exchange operations by calling the aggregator address specied by the user. It stipulates that the aggregator is composed of UNISWAPV2, UNISWAPV3, and ONEINCH through the SwapType enumeration, but in fact, the contract does not check whether the aggregator called by the user is a real and valid address. If the user is phished or the wrong address is passed in, it will result in a loss of funds or use the Actions contract to perform sensitive operations on the ETF. For example: when performing the swap through ONEINCH, it will not check the address of the caller and can pass in any call data. This allows the attacker to perform operations such as setController, approveUnderlying, addTokenToWhitelist, etc. on the pool when the user is phished. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase4 - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Pancakeswap-CakePool_en-us.pdf",
        "body": "In the cakePool contract, the owner role can set the DURATION_FACTOR and DURATION_FACTOR_OVERDUE by 7 calling the setDurationFactor and setDurationFactorOverdue. If these values are set too large or too small, this may aect the calculation of user.shares when calling the deposit and withdraw function. ",
        "labels": [
            "SlowMist",
            "Pancakeswap-CakePool",
            "Type: Authority Control Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Missing event records",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Pancakeswap-CakePool_en-us.pdf",
        "body": "In the cakePool contract, the owner role can set admin, treasury, operator, boostContract, freeFeeUsers, performanceFee, performanceFeeContract, withdrawFee, withdrawFeeContract, withdrawFeePeriod, MAX_LOCK_DURATION, DURATION_FACTOR, DURATION_FACTOR_OVERDUE, UNLOCK_FREE_DURATION and 8 BOOST_WEIGHT by calling the setAdmin, setTreasury, setOperator, setBoostContract, setFreeFeeUser, setPerformanceFee, setPerformanceFeeContract, setWithdrawFee, setWithdrawFeeContract, setWithdrawFeePeriod, setMaxLockDuration, setDurationFactor, setDurationFactorOverdue, setUnlockFreeDuration and setBoostWeight. but there no event logging is preformed. ",
        "labels": [
            "SlowMist",
            "Pancakeswap-CakePool",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Redundant collectEndTime check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report.pdf",
        "body": "In the CongurableRightsPool contract, users can redeem underlying assets through the exitPool function. When the pool is a closed ETF, it will check isCompletedCollect and collectEndTime to decide whether to perform _claimManagerFee operation. But when isCompletedCollect is true, the collectEndTime check will be performed in snapshotEndAssets, and when isCompletedCollect is false, the collectEndTime check will be performed in exitPoolHandleB. Hence the collectEndTime check before the _claimManagerFee operation is redundant. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Redundant closureEndTime check on exitPool",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report.pdf",
        "body": "In the CongurableRightsPool contract, users can redeem underlying assets through the exitPool function. When the pool is a closed ETF and isCloseEtfCollectEndWithFailure is false, it will check that the current time must be greater than closureEndTime + 5 minutes before allowing the user to exit. However, it should be noted that the snapshotEndAssets operation will be performed before this. The snapshotEndAssets function will also check whether the current time is greater than closureEndTime + 5 minutes . Only the admin and owner can execute snapshotEndAssets within 5 minutes after the closure period ends. Otherwise, the transaction will be reverted. Therefore, the closureEndTime check in the exitPool function is redundant. When snapshotEndAssets cannot be performed, the entire transaction will be reverted, and subsequent closureEndTime checks will not be performed. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Redundant performance fee calculation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report.pdf",
        "body": "In the exitPool function of the CongurableRightsPool contract, redeemAndPerformanceFeeReceived, nalAmountOut and redeemFeeReceived are calculated through exitPoolHandleA. However, since the performance fee will be calculated uniformly in the snapshotEndAssets operation, there is no need to process the performance fee in the exitPool function. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "The time allowed for snapshots is too short",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report.pdf",
        "body": "In the CongurableRightsPool contract when the closed ETF completes collect and the collection period has ended, the current total value of the ETF can be recorded through the snapshotBeginAssets function. However, users can only call the snapshotBeginAssets function within 15 minutes after the end of the collection period. If there is congestion on the chain, it may not be possible to call the snapshot in time within 15 minutes. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Duplicate decimal processing issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report.pdf",
        "body": "In the DesynChainlinkOracle contract, the getPrice function is used to obtain the corresponding token price from prices, getChainlinkPrice, and getUniswapPrice, and perform decimal processing. However, decimal has been processed in getChainlinkPrice and getUniswapPrice, and theoretically, the returned decimal will be 1e18. Therefore, processing decimals through decimalDelta will cause decimals to be enlarged. Note that the amountIn passed in for the consult in the getUniswapPrice function is 1e18, which needs to be ensured that the token decimal in twapOracle matches it in practice ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Decimal processing issue in AllPrice calculation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report.pdf",
        "body": "In the DesynChainlinkOracle contract, the getAllPrice function is used to calculate the total value of the specied amount of tokens. It is calculated by badd(fundAll, bmul(getPrice(t), tokenAmountOut)) , theoretically the decimal returned by getPrice is 1e18, and the decimal of tokenAmountOut is consistent with the decimal of the token itself. Therefore, multiplying these two values will result in a very large decimal in the nal result. The getNormalizedWeight function is also aected by this, but this is not harmful to normal business. Note: ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Redundant code issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report.pdf",
        "body": "In the SmartPoolManager library, the exitPoolHandle function has been deprecated since closed ETF prots are calculated in snapshotEndAssets. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Token list conict in recordTokenInfo",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report.pdf",
        "body": "When the user performs createPool and joinPool, if the Pool is a closed ETF and the current time is within the collection period, the KOL invitation amount will be recorded through UserVault's recordTokenInfo interface. But unfortunately, the tokens in the Pool can be Bind/unBind at any time, which will cause the list of tokens supported by the Pool to change. If the recordTokenInfo operation is performed when the Pool token list changes, the amount recorded by variables such as poolInviteTotal, kolTotalAmountList, and kolUserInfo may be disturbed. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "couldManagerClaim not checked when managerClaim",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report.pdf",
        "body": "In the UserVault contract, the Manager role can claim management fees through the managerClaim function, but it does not check whether the couldManagerClaim parameter is true. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Some redundant invoke functions",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report.pdf",
        "body": "In the Invoke library, the strictInvokeTransfer, invokeUnwrapWETH, invokeWrapWETH, and invokeMint functions are not used. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of ETF falsication",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report.pdf",
        "body": "In the RebalanceAdapter contract, the Manager role can adjust the position of the pool through the rebalance function. But the address of the ETF is obtained from the rebalanceInfo passed in by the user. If a malicious user passes in a fake ETF, the check in the onlyManager decorator will be bypassed, and the _verifyWhiteToken check of token1 and the isCompletedCollect and collectEndTime checks will be useless. Malicious users can steal bPool funds through _makeSwap and bind malicious tokens. The approve function also has this risk, but it doesn't break the protocol too much ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Risk of the Manager role potentially disrupting the protocol",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report.pdf",
        "body": "In the RebalanceAdapter contract, the Manager role can adjust the position of the ETF through the rebalance function. It will use the _makeSwap function to call Uniswap, 1inch and other DEXs for token swaps to adjust token positions. But unfortunately, the swap path of the token is not checked during the token swap process, which will cause the Manager role to pass in a carefully constructed malicious swap path to steal the middle token0 of the ETF. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Double slippage check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report.pdf",
        "body": "In the RebalanceAdapter contract, the Manager role can adjust the position of the ETF through the rebalance function. It will use the _makeSwap function to call Uniswap, 1inch and other DEXs for token swaps to adjust token positions. During the swap process, the slippage will be checked by passing minReturn to the external DEXs, but the implementation of the slippage check of the external DEXs is uncontrollable. If the slippage protection of the external DEXs fails, it will aect the funds of users in the protocol. (1inch users encountered invalid slippage check before) ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Does not follow the Checks-Eects-Interactions specication",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report.pdf",
        "body": "In the RebalanceAdapter contract, the _makeSwap function is used for token swap. When the swap type is not UNISWAPV3 and UNISWAPV2, the parameters passed in by the user will be checked through _validateData . However, the execute operation is performed rst, and the _validateData operation is performed after the token exchange is completed. This is not in line with the follow the Checks-Effects-Interactions principle. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Perform strict parameter checking",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report.pdf",
        "body": "In the RebalanceAdapter contract, the _validateData function is used to check the exchange parameters, but it only parses the recipient and amountIn for checking, but does not check whether other key parameters such as srcToken, dstToken, clipperExchange, makerAsset, takerAsset are in line with expectations. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Redundant aggregator parameter",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report.pdf",
        "body": "In the RebalanceAdapter contract, the _validateData function is used to check the conversion parameters, but the aggregator parameter it receives is not used. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Incorrect approval operation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report.pdf",
        "body": "In the RebalanceAdapter contract, the Manager role can adjust the position of the ETF through the rebalance function. If token1 has not been bound in bPool, it will be approved rst. However, the subsidy of this contract was wrongly approved to bPool, which will cause bPool to be unable to transfer tokens from CRP in the future. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report.pdf",
        "body": "There is an execute function in the CRP and bPool contracts so that the Manager can manage the ETF. In bFactory, the Blabs role can arbitrarily register modules to gain control over CRP. The registered modules can use the execute function in CRP to call the execute function in bPool to perform any operations. This would pose a huge risk to users' funds. And the Manager can approve the tokens in the bPool through the approve function of the RebalanceAdapter contract, which will also bring huge risks to the user's funds. The above problems lead to the risk of excessive permissions of the Blabs role and the Manager role. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Authority Control Vulnerability Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Enforce strict permission controls",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report.pdf",
        "body": "In the LiquidityPool contract, any user can call the joinPool, exitPool, and gulp functions to add/remove liquidity/record token balances, which will make it impossible to charge various fees to users in CRP. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Index conict issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm_Phase6_en-us.pdf",
        "body": "In the MIM strategy of ENF_V3, the getPID function is used to obtain the pool id of the specied LP token in ConvexBooster. Returns the current index if the match is successful, otherwise returns the 0 index. However, there is a corresponding LP (Curve. cDAI/cUSDC) conguration for the 0 index in ConvexBooster, which will make it impossible for the caller to determine whether the return of the 0 index is due to a matching failure or LP tokens in the 0 pool of ConvexBooster. ",
        "labels": [
            "SlowMist",
            "Earning.Farm_Phase6",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Visibility issue with getPID function",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm_Phase6_en-us.pdf",
        "body": "There is a getPID function with public visibility in the MIM strategy of ENF_V3, but this function is not called by other functions in this contract, so using public visibility will consume more gas than external visibility. ",
        "labels": [
            "SlowMist",
            "Earning.Farm_Phase6",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Read-only reentrancy checks subject to rounding errors",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm_Phase6_en-us.pdf",
        "body": "In the StETH contract in ENF_ETH_Lowrisk, the remove_liquidity_one_coin function will be called during the deposit and withdraw operations to avoid virtual price manipulation. However, the remove_liquidity_one_coin operation does not always succeed due to rounding errors in the calculation of _get_y_D . ",
        "labels": [
            "SlowMist",
            "Earning.Farm_Phase6",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Slippage check issue when Vault gets totalAssets",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm_Phase6_en-us.pdf",
        "body": "In the Vault contract of ENF_ETH_Lowrisk, the totalAssets function is used to obtain the total assets held by the protocol, which will be counted by calling the totalAssets function of each SS contract. In the FrxETH strategy, in order to ensure that the amount of totalAssets obtained has not been manipulated, a slippage check will be performed according to the fetch ag. Fetch is passed as true in the Vault contract, which will ignore the slippage check. ",
        "labels": [
            "SlowMist",
            "Earning.Farm_Phase6",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Logic optimization",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm_Phase6_en-us.pdf",
        "body": "In the FrxETH contract of ENF_ETH_Lowrisk, there are some functions to convert between share and asset through the totalSupply and totalAssets values of sFrx. However, these interfaces have been provided in the sFrx contract, and the calculated decimal is more accurate. Here is some alternative logic: The frxBal calculation in _totalAssets function can be done by ISfrx(sFrx).convertToAssets(sFrxBal) The lastEarnPrice calculation in _deposit function can be done by ISfrx(sFrx).pricePerShare() The currentPrice calculation in harvest function can be done by ISfrx(sFrx).pricePerShare() ",
        "labels": [
            "SlowMist",
            "Earning.Farm_Phase6",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Swap optimization from ETH to FrxETH",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm_Phase6_en-us.pdf",
        "body": "In the FrxETH contract of ENF_ETH_Lowrisk, the _deposit function will select the optimal exchange path according to the price of CurvePool. When the amount exchanged by CurvePool is greater than or equal to _amount (curveExpect >= _amount), it will exchange tokens through CurvePool . If curveExpect == _amount , converting through CurvePool may consume more gas than minting through frxMinter. ",
        "labels": [
            "SlowMist",
            "Earning.Farm_Phase6",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Redundant code",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Yield V1.0.0_en-us.pdf",
        "body": "Ether is not accepted by default, which is a redundant code. cross-send/contracts/CrossSend.sol#L41-L47 initial-hotcross-oering/contracts/BaseIHO.sol#L67-L73 fallback () external payable { revert(\"cannot directly accept currency transfers\"); } receive () external payable { revert(\"cannot directly receive currency transfers\"); 15 }",
        "labels": [
            "SlowMist",
            "Cross Yield V1.0.0",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Gas optimization",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Yield V1.0.0_en-us.pdf",
        "body": "If one of the batch transfers fails, the transaction that was previously transferred normally will be reverted, but Gas has been consumed. It is a gas optimization issue here. cross-send/contracts/CrossSend.sol#L175-L210 function sendToken( IERC20 token, address[] memory recipients, uint256[] memory amounts ) private returns(uint256) { uint256 total = 0; for (uint256 i = 0; i < recipients.length ; i++) { require(_msgSender() != recipients[i], \"sender != recipient\"); token.safeTransferFrom(_msgSender(), recipients[i], amounts[i]); total += amounts[i]; } return total; } function sendNative( address[] memory recipients, uint256[] memory amounts ) private returns(uint256) { uint256 total = 0; 16 for (uint256 i = 0; i < recipients.length ; i++) { total += amounts[i]; (bool success, ) = payable(recipients[i]).call{value: amounts[i]}(\"\"); require(success, \"native transfer failed\"); } return total; }",
        "labels": [
            "SlowMist",
            "Cross Yield V1.0.0",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of allowance amount abuse",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Yield V1.0.0_en-us.pdf",
        "body": "There have an allowance amount in the contract, but the distributeTokenFee function does not limit the caller, and there is an issue of being called arbitrarily, but it can only transfer the balance of the sender to the feeCollector. cross-send/contracts/fee-managers/RecipientCountFee.sol#L65-L83 function distributeTokenFee( uint256 txRecipientCount, uint256, uint256, uint256, uint256, address sender ) public override { uint256 payableFee = txRecipientCount * tokenFeePerRecipient; 17 if(payableFee < minTokenFee) { payableFee = minTokenFee; } else if (payableFee > maxTokenFee) { payableFee = maxTokenFee; } token.safeTransferFrom(sender, feeCollector, payableFee); }",
        "labels": [
            "SlowMist",
            "Cross Yield V1.0.0",
            "Type: Authority Control Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Price manipulation issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Yield V1.0.0_en-us.pdf",
        "body": "The IOUPrice is calculated using totalFarmingTokenBalance. Attackers can control totalFarmingTokenBalance to manipulate IOUPrice. The current code does not nd the location where IOUPrice is used. Referencehttps://slowmist.medium.com/cream-hacked-analysis-us-130-million-hacked-95c9410320ca cross-yield/contracts/core/CrossYield.sol#L95-L101 function IOUPrice() public view returns (uint256) { uint256 IOUSupply = totalSupply(); return IOUSupply == 0 ? 1e18 : (totalFarmingTokenBalance() * 1e18) / IOUSupply; } 18 cross-yield/contracts/core/CrossYield.sol#L65-L67 function totalFarmingTokenBalance() public view returns (uint256) { return farmingToken().balanceOf(address(this)) + strategy.balanceOf(); }",
        "labels": [
            "SlowMist",
            "Cross Yield V1.0.0",
            "Type: Others",
            "Severity: Medium"
        ]
    },
    {
        "title": "Sandwich attacks issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Yield V1.0.0_en-us.pdf",
        "body": "There is no slippage check during swap, and there is a risk of sandwich attack. IPancakeRouter02(pcsRouter).swapExactTokensForTokens(cakeBalance, 0,cakeToBaseRoute, address(this), block.timestamp); IPancakeRouter02(pcsRouter) .swapExactTokensForTokens(toSwap, 0, route, address(this), block.timestamp); Reference https://medium.com/coinmonks/demystify-the-dark-forest-on-ethereum-sandwich-attacks-5a3aec9fa33e cross-yield/contracts/libs/OptimalSwap.sol#L14-L63 function prepareLiquidity( address cake, address[2] memory lpTokens, 19 address wbnb, address busd, address farmingToken, address pcsRouter, uint256 fee ) external { uint256 cakeBalance = IERC20(cake).balanceOf(address(this)); bool isCakeInLp = lpTokens[0] == cake || lpTokens[1] == cake; bool isWbnbBased = lpTokens[0] == wbnb || lpTokens[1] == wbnb; address baseToken = isWbnbBased ? wbnb : busd; // if cake is not part of the lp token, swap all cake for the base token if (!isCakeInLp) { address[] memory cakeToBaseRoute = new address[](2); cakeToBaseRoute[0] = cake; cakeToBaseRoute[1] = baseToken; IPancakeRouter02(pcsRouter) .swapExactTokensForTokens(cakeBalance, 0, cakeToBaseRoute, address(this), block.timestamp); } (uint256 reserve0, uint256 reserve1,) = IPancakePair(farmingToken).getReserves(); address[] memory route = new address[](2); uint256 lp0Bal = IERC20(lpTokens[0]).balanceOf(address(this)); uint256 lp1Bal = IERC20(lpTokens[1]).balanceOf(address(this)); uint256 toSwap; // The possible cases here are: // - Cake was not part of the LP token, so we swap for baseToken which could either be lpToken0 or lpToken // - Cake was part of the LP token, so it can either be lpTokens[0] or lpTokens[1] // So, depending on which token we have the highest balance for, we swap for the other one. if (lp0Bal > lp1Bal) { toSwap = SwapAmount.getSwapAmount(lp0Bal, reserve0, fee); route[0] = lpTokens[0]; route[1] = lpTokens[1]; } else { toSwap = SwapAmount.getSwapAmount(lp1Bal, reserve1, fee); route[0] = lpTokens[1]; route[1] = lpTokens[0]; 20 } // Perform the swap IPancakeRouter02(pcsRouter) .swapExactTokensForTokens(toSwap, 0, route, address(this), block.timestamp); } IPancakeRouter02(pcsRouter).swapExactTokensForTokens(toWbnb, 0, cakeToWbnbRoute, address(this), block.timestamp); cross-yield/contracts/strategies/StrategyCake.sol#L131 function collectFees() internal { // a percentant of the cake we get from the masterchef will be used to buy BNB and transfer to this address // this is the total fees that will be shared amongst the protocol, stategy dev and the harvester uint256 toWbnb = feeManager.calculateTotalFee(IERC20(farmingToken).balanceOf(address(this))); IPancakeRouter02(pcsRouter).swapExactTokensForTokens(toWbnb, 0, cakeToWbnbRoute, address(this), block.timestamp); uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this)); // distribute hervester fee uint256 harvesterFeeAmount = feeManager.calculateHarvestFee(wbnbBal); // collectFees is called indirectly from the CrossYield contract via the beforeDeposit hook. // This means that _msgSender() is the CrossYield contract and not the actuall EOA account // that send the transaction IERC20(wbnb).safeTransfer(tx.origin, harvesterFeeAmount); // distribute protocol fee uint256 protocolFeeAmount = feeManager.calculateProtocolFee(wbnbBal); // IERC20(wbnb).safeTransfer(protocolFeeRecipient, protocolFeeAmount); feeProcessor.process(protocolFeeAmount); // distribute strategy dev fee uint256 strategyDevFeeAmount = feeManager.calculateStrategyDevFee(wbnbBal); IERC20(wbnb).safeTransfer(feeManager.strategyDev(), strategyDevFeeAmount); emit FeeCollected( toWbnb, 21 harvesterFeeAmount, protocolFeeAmount, strategyDevFeeAmount, _msgSender() ); } cross-yield/contracts/strategies/StrategyCakeLP.sol#L174 function collectFees() internal { // a percentant of the cake we get from the masterchef will be used to buy BNB and transfer to this address // this is the total fees that will be shared amongst the protocol, stategy dev and the harvester uint256 toWbnb = feeManager.calculateTotalFee(IERC20(cake).balanceOf(address(this))); IPancakeRouter02(pcsRouter).swapExactTokensForTokens(toWbnb, 0, cakeToWbnbRoute, address(this), block.timestamp); uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this)); // distribute hervester fee uint256 harvesterFeeAmount = feeManager.calculateHarvestFee(wbnbBal); IERC20(wbnb).safeTransfer(_msgSender(), harvesterFeeAmount); // distribute protocol fee uint256 protocolFeeAmount = feeManager.calculateProtocolFee(wbnbBal); feeProcessor.process(protocolFeeAmount); // distribute strategy dev fee uint256 strategyDevFeeAmount = feeManager.calculateStrategyDevFee(wbnbBal); IERC20(wbnb).safeTransfer(feeManager.strategyDev(), strategyDevFeeAmount); emit FeeCollected( toWbnb, harvesterFeeAmount, protocolFeeAmount, strategyDevFeeAmount, _msgSender() ); } cross-yield/contracts/strategies/StrategyCake.sol 22 function harvest() public override whenNotPaused { // claim rewards IMasterChef(masterchef).leaveStaking(0); // because harvest can automatically be called after each user deposit // we might end up having multiple deposits in the same block and only one // would return rewards from masterchef so the rest will have 0 cake so // we don't need to waste gas to collect fees and call deposit uint256 farmingTokenBalance = balanceOfFarmingToken(); if(farmingTokenBalance > 0) { collectFees(); deposit(); emit HarvestTriggered(_msgSender(), farmingTokenBalance); } } cross-yield/contracts/strategies/StrategyCakeLP.sol#l137-L148 function harvest() external override whenNotPaused { // claim rewards IMasterChef(masterchef).deposit(poolId, 0); uint256 harvestedAmount = IERC20(cake).balanceOf(address(this)); collectFees(); addLiquidity(); deposit(); emit HarvestTriggered(_msgSender(), harvestedAmount); }",
        "labels": [
            "SlowMist",
            "Cross Yield V1.0.0",
            "Type: Reordering Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Missing slippage check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Yield V1.0.0_en-us.pdf",
        "body": "The addLiquidity function without slippage check, it doesn't have an impermanent loss check. cross-yield/contracts/strategies/StrategyCakeLP.sol#L218 function addLiquidity() internal { OptimalSwap.prepareLiquidity( cake, [lpToken0, lpToken1], wbnb, busd, farmingToken, pcsRouter, swapFee ); // add liquidity to AMM on PCS uint256 lp0Bal = IERC20(lpToken0).balanceOf(address(this)); uint256 lp1Bal = IERC20(lpToken1).balanceOf(address(this)); IPancakeRouter02(pcsRouter) .addLiquidity(lpToken0, lpToken1, lp0Bal, lp1Bal, 0, 0, address(this), block.timestamp); emit LiquidityAdded(lpToken0, lpToken1, lp0Bal, lp1Bal, _msgSender()); }",
        "labels": [
            "SlowMist",
            "Cross Yield V1.0.0",
            "Type: Reordering Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Permission check Missing",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Yield V1.0.0_en-us.pdf",
        "body": "There is no permission check for deposit function. The function is called by the CrossYieid contract. cross-yield/contracts/strategies/StrategyCakeLP.sol#L225-L231 function deposit() public override whenNotPaused { uint256 farmingTokenBalance = balanceOfFarmingToken(); if (farmingTokenBalance > 0) { IMasterChef(masterchef).deposit(poolId, farmingTokenBalance); } } cross-yield/contracts/strategies/StrategyCake.sol#L169-L175 function deposit() public override whenNotPaused { uint256 farmingTokenBalance = balanceOfFarmingToken(); if (farmingTokenBalance > 0) { IMasterChef(masterchef).enterStaking(farmingTokenBalance); } }",
        "labels": [
            "SlowMist",
            "Cross Yield V1.0.0",
            "Type: Authority Control Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Excessive authority issue 25",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Yield V1.0.0_en-us.pdf",
        "body": "Owner can modify the address of the strategy. The new strategy may have security risks if it is not audited, which will aect the user's funds. If the private key is leaked, it will aect the user's funds. cross-yield/contracts/core/CrossYield.sol#L224-L236 function upgradeStrategy() public onlyOwner { require(stratCandidate.strategy != address(0), \"No proposal exists\"); require(block.number > stratCandidate.proposedBlock + stratUpgradableAfter, \"Strategy cannot be replaced yet\"); emit NewStrategy(stratCandidate.strategy); strategy.retireStrategy(); strategy = IStrategy(stratCandidate.strategy); stratCandidate.strategy = address(0); stratCandidate.proposedBlock = 0; putFundsToWork(); } cross-yield/contracts/core/CrossYield.sol#L211-L220 function proposeStrategy(address _strategy) public onlyOwner { require(address(this) == IStrategy(_strategy).vault(), \"Invalid new strategy\"); stratCandidate = StrategyCandidate({ strategy: _strategy, proposedBlock: block.number }); emit NewStratCandidate(_strategy); }",
        "labels": [
            "SlowMist",
            "Cross Yield V1.0.0",
            "Type: Authority Control Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Repeatable claims issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Yield V1.0.0_en-us.pdf",
        "body": "After the claim, lottery.status is not set as claimed, and it is also necessary to check whether lotteryId has been claimed when the claim is executed. hotdrop/contracts/HotDrop.sol#L261-L274 function claim(uint256 lotteryId) external nonReentrant { Lottery storage lottery = lotteries[lotteryId]; require(lottery.status == Status.WinnerDrawn, \"winner not drawn\"); // if there is no winner transfer the total amount to the treasury if(tickets[lotteryId][lottery.winningNumber] == address(0)) { lottery.purchaseToken.safeTransfer(treasury, lottery.purchaseToken.balanceOf(address(this))); } else if(tickets[lotteryId][lottery.winningNumber] == _msgSender()) { // if the ticket is the winning ticket and belongs to the user then split the pot uint256 treasuryAmount = (lottery.totalRaised * lottery.treasuryFee) / FEE_BASE; lottery.purchaseToken.safeTransfer(treasury, treasuryAmount); lottery.purchaseToken.safeTransfer(_msgSender(), lottery.totalRaised - treasuryAmount); } }",
        "labels": [
            "SlowMist",
            "Cross Yield V1.0.0",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Round plan security reminder",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Yield V1.0.0_en-us.pdf",
        "body": "And the new round of lottery can only be opened when the last round of lottery is in WinnerDrawn, otherwise randomGenerator.latestLotteryId will be updated, which will cause the old lottery round to fail to execute drawWinner function due to this check. require(lotteryId == randomGenerator.latestLotteryId(), \"numbers not drawn\"); hotdrop/contracts/HotDrop.sol#L44-L256 function drawWinner(uint256 lotteryId) external nonReentrant { Lottery storage lottery = lotteries[lotteryId]; require(lottery.status == Status.Close, \"lottery still active\"); require(lotteryId == randomGenerator.latestLotteryId(), \"numbers not drawn\"); // get the winning number based on the randomResult generated by ChainLink's fallback uint256 winningNumber = randomGenerator.randomResult(); lottery.winningNumber = winningNumber; lottery.status = Status.WinnerDrawn; emit LotteryNumberDrawn(lotteryId, winningNumber); }",
        "labels": [
            "SlowMist",
            "Cross Yield V1.0.0",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Re-initialize issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cook Distribution and Reward_en-us.pdf",
        "body": "In RewardVesting contract, the Governance role can re-initialize the the contract through initialize function Location function initialize(IERC20 _cookReward) external onlyGovernance { cookReward = _cookReward; }",
        "labels": [
            "SlowMist",
            "Cook Distribution and Reward",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing authority check 7",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cook Distribution and Reward_en-us.pdf",
        "body": "The addEarning function exists in the RewardVesting contract. When the claim operation is performed in the StakingPool contract, if the corresponding reward needs to be time locked, the addEarning function of the RewardVesting contract will be called to perform the locking operation. However, the visibility of this function is external, which will cause any user to perform the addEarning operation.  function addEarning(address user, uint256 amount, uint256 durationInSecs) external { _addPendingEarning(user, amount, durationInSecs); cookReward.safeTransferFrom(msg.sender, address(this), amount); }",
        "labels": [
            "SlowMist",
            "Cook Distribution and Reward",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Code x situation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Penpie Contracts Exploit Fixes - SlowMist Audit Report_en-us.pdf",
        "body": "In the x, the project team used OpenZeppelin's ReentrancyGuard library to modify the harvestMarketReward and batchHarvestMarketRewards functions in the PendleStaking contract to address the issue of reentering depositMarket. Additionally, they restricted the registerPool function in the PendleStaking contract to be callable only by the owner role to ensure that newly registered pools are reviewed. ",
        "labels": [
            "SlowMist",
            "Penpie Contracts Exploit Fixes - SlowMist Audit Report",
            "Type: Others",
            "Severity: Information"
        ]
    },
    {
        "title": "4.3.1.1 Risk of repeated contract initialization",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SmoothyV1_en-us.pdf",
        "body": "In the SmoothyMasterV1 contract, the owner can initialize the contract through the initialize function to set the address of key parameters such as SMTYToken, startTime, and communityAddr. However, there is no restriction on the initialize function to prevent repeated initialization calls, which will cause the owner role to repeatedly initialize the contract through the initialize function. The same goes for VotingEscrow and SmoothyV1 contracts. Fix suggestion: It is suggested to restrict the initialization function that does not allow repeated calls. ",
        "labels": [
            "SlowMist",
            "SmoothyV1",
            "Severity: High"
        ]
    },
    {
        "title": "4.3.2.1 Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SmoothyV1_en-us.pdf",
        "body": "In the SMTYToken contract, the minter role can mint tokens arbitrarily through the mint function. The owner role can arbitrarily modify the minter role address through the changeMinter function, which 10 will lead to the risk of excessive owner authority. Fix suggestion: It is suggested to transfer the owner authority to community governance. ",
        "labels": [
            "SlowMist",
            "SmoothyV1",
            "Severity: Medium"
        ]
    },
    {
        "title": "4.3.2.2 Denial of Service Risk",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SmoothyV1_en-us.pdf",
        "body": "In the SmoothyMasterV1 contract, the user can update all pools through the massUpdatePools function, but it uses the for loop to update cyclically. If the number of pools exceeds too much, it will cause a DoS risk. Fix suggestion: It is suggested to limit the number of pools to avoid this problem. function massUpdatePools() public { uint256 length = poolInfo.length; for (uint256 pid = 0; pid < length; ++pid) { updatePool(pid); } } Fix status: No Fixed. 11",
        "labels": [
            "SlowMist",
            "SmoothyV1",
            "Severity: Medium"
        ]
    },
    {
        "title": "4.3.3.1 The lockDuration does not match the lockEnd",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SmoothyV1_en-us.pdf",
        "body": "In the SmoothyMasterV1 contract, the user can extend the mortgage lock period through the extendLock function. When reconfirming the lockDuration, take the new lock duration and the smaller value of MAX_TIME, but in the end, when determining the lockEnd, the _end parameter is still directly passed in. Assigned to lockEnd, if the new lock duration is greater than MAX_TIME, this will cause the lockDuration to not match the lockEnd. Fix suggestion: It is suggested to recalculate lockEnd based on lockDuration. ",
        "labels": [
            "SlowMist",
            "SmoothyV1",
            "Severity: Low"
        ]
    },
    {
        "title": "4.3.3.1 Inaccurate calculation of LP amount",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SmoothyV1_en-us.pdf",
        "body": "In the SmoothyV1 contract, in order to save gas in mint, redeem, and swap operations, the 12 calculation using getMintAmount uses cached data for calculation, which will cause the final calculation result to be inconsistent with expectations. Fix suggestion: Due to project design requirements, it is suggested that the project party manually invoke the update when the update is not performed to avoid this issue. ",
        "labels": [
            "SlowMist",
            "SmoothyV1",
            "Severity: Low"
        ]
    },
    {
        "title": "4.3.4.1 The change of LP pool weights affects users' income",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SmoothyV1_en-us.pdf",
        "body": "In the SmoothyMasterV1 contract, when the Owner calls the add function and the set function to add a new pool or reset the pool weight, all LP pool weights will change accordingly. The Owner can update all pools before adjusting the weight by passing in the _withUpdate parameter with a value of true to ensure that the user's income before the pool weight is changed will not be affected by the adjustment of the pool weight, but if the value of the _withUpdate parameter is false, then All pools will not be updated before the pool weight is adjusted, which will cause the user's income to be affected before the pool weight is changed. Fix suggestion: It is suggested to force all LP pools to be updated before the weights of LP pools are adjusted to avoid the impact of user income. ",
        "labels": [
            "SlowMist",
            "SmoothyV1",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.3.4.2 Loss of precision issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SmoothyV1_en-us.pdf",
        "body": "In the SmoothyMasterV1 contract, when using the _updateWorkingAmount function to calculate the number of workingAmount users participate in mining, divide first and then multiply, which will result in loss of accuracy. Fix suggestion: It is suggested to multiply and then divide to avoid this issue ",
        "labels": [
            "SlowMist",
            "SmoothyV1",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.3.4.3 Unrecoverable issue of pool imbalance",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SmoothyV1_en-us.pdf",
        "body": "In the SmoothyV1 contract, when the user performs operations such as recharge, redemption, and exchange, the penalty mechanism will be triggered when the weight of the coin exceeds the soft cap, but the contract does not have an incentive mechanism to perform exchange operations to reduce the proportion of the token pool. If the token pool is maliciously manipulated to exceed the soft cap, it may be difficult for the token pool to return to normal due to no incentive mechanism, which will affect normal business use. 17 Fix suggestion: It is suggested to add an incentive mechanism in an unbalanced state to avoid this problem. ",
        "labels": [
            "SlowMist",
            "SmoothyV1",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.3.4.4 Risk of Potential Token Transfer Failure",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SmoothyV1_en-us.pdf",
        "body": "In the SmoothyV1 contract, when the user deposits the token, the safeTransferFrom function is used to transfer the corresponding token, and the safeTransfer function is used to transfer the token when withdrawToken. The safeTransferFrom function and safeTransfer function will check the returned success and data , If the connected token defines the return value, but does not return according to the EIP20 specification, the user will not be able to pass the check here, resulting in the tokens being unable to be transferred in or out. Fix suggestion: It is suggested that when docking new tokens, the project party should check whether its writing complies with EIP20 specifications. ",
        "labels": [
            "SlowMist",
            "SmoothyV1",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.3.4.5 Token compatibility issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SmoothyV1_en-us.pdf",
        "body": "In the SmoothyV1 contract, under the condition that each pool is stable, the exchange operation will be performed in a 1:1 manner. However, if the project is connected to a stable rebase algorithm, the number of tokens in the pool will be changed when it undergoes deflation, resulting in an unexpected 18 number of users during the exchange. Fix suggestion: It is suggested to strictly evaluate the algorithm model of stablecoins to avoid this risk when accessing stablecoins. ",
        "labels": [
            "SlowMist",
            "SmoothyV1",
            "Severity: Informational"
        ]
    },
    {
        "title": "Excessive authority issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ROTL_en-us.pdf",
        "body": "In the ROTL contract, the DEFAULT_ADMIN_ROLE can set the minter role, the minter role can mint ERC721A tokens arbitrarily and the minter role is entitled to free mint without going through each rounds. 11 ",
        "labels": [
            "SlowMist",
            "ROTL",
            "Type: Authority Control Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Pausable is not implemented",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ROTL_en-us.pdf",
        "body": "In the ROLTMint contract, it heritates the Pausable contract, but there is no pause and unpause function implemented. That means the value ot the _paused is false and can not be changed. Which will impact the __isEnable function and whenNotPaused modier. ",
        "labels": [
            "SlowMist",
            "ROTL",
            "Type: Others",
            "Severity: Low"
        ]
    },
    {
        "title": "Missing event record",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ROTL_en-us.pdf",
        "body": "1.In the ROTLMint contract, the owner role can set the _nft, _merkleRoot, _currentRound, price, maxCount, onceMaxCount, addressMaxCount, and startBlock values through the setAddress, setMerkleRoot, setRound, and setRoundInfo functions. But there are no no events logging performed. ",
        "labels": [
            "SlowMist",
            "ROTL",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Dev address setting enhancement suggestion 14",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ROTL_en-us.pdf",
        "body": "In the ROTLMint contract, the owner role can withdraw the native token through the withdraw function. If the owner is an EOA address, in a scenario where the private key is leaked, the teams revenue will be stolen. ",
        "labels": [
            "SlowMist",
            "ROTL",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Variable not used",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ROTL_en-us.pdf",
        "body": "In the ROLT contract, the contract dened the _mintContractAddress and _revealIndex value. But these two values are not assigned and can not be set. ",
        "labels": [
            "SlowMist",
            "ROTL",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Potential risks of approving denial of service",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn - Restaking - SlowMist Audit Report.pdf",
        "body": "In the invest function, when the user passes in a rawToken that is neither NATIVE_TOKEN nor _WST_ETH token, the contract will call the user-provided depositor to execute custom user data. Prior to this, the contract approves the user's transferred funds to the depositor using the safeApprove function. It is important to note that the safeApprove function requires either the current approved amount to be 0 or the current allowance of the contract to the depositor to be 0 in order to safely approve; otherwise, it will revert. If a malicious user intentionally does not use up all the allowance during the depositor call, when the protocol attempts to execute safeApprove for this rawToken again, it will revert. This will cause a denial of service for some of the contract's functionality. ",
        "labels": [
            "SlowMist",
            "DeSyn - Restaking - SlowMist Audit Report",
            "Type: Denial of Service Vulnerability",
            "Severity: High"
        ]
    },
    {
        "title": "Accidentally transferred funds that can be stolen",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn - Restaking - SlowMist Audit Report.pdf",
        "body": "In the invest function, when the user-specied rawToken is neither NATIVE_TOKEN nor _WST_ETH, the contract directly calls the depositor contract to execute user-specied data. When other users accidentally transfer rawTokens into the Restaking contract and the Restaking contract still has a remaining allowance for the depositor, these other users can deposit the accidentally transferred tokens into the depositor as their own prot. It is obvious that the project team can also transfer out the erroneously transferred assets in the contract by approving a specic depositor. ",
        "labels": [
            "SlowMist",
            "DeSyn - Restaking - SlowMist Audit Report",
            "Type: Others",
            "Severity: Information"
        ]
    },
    {
        "title": "Risk of user assets being stolen due to arbitrary execution of data",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn - Restaking - SlowMist Audit Report.pdf",
        "body": "In the invest function, when the user-specied rawToken is neither NATIVE_TOKEN nor _WST_ETH, the contract directly calls the depositor contract to execute user-specied data. It is important to note that in some restaking protocols (such as stETH and pufETH), the deposit, borrowing, and token transfer interfaces are in the same contract. Taking pufETH as an example, users can call the pufETH contract to make deposits and obtain pufETH tokens, and they can also call the pufETH contract to transfer pufETH tokens. Therefore, although the legality of the depositor is checked in the invest function, the restakingParams.data passed in by the user is not checked. This allows users to call the transferFrom function of the LST/LRT contract via restakingParams.depositor.functionCallWithValue to transfer tokens of any user who has already approved this contract. ",
        "labels": [
            "SlowMist",
            "DeSyn - Restaking - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Decimal problems in share calculation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn - Restaking - SlowMist Audit Report.pdf",
        "body": "In the invest function, when a user completes a restaking operation, the contract deposits the restaking tokens into the user-specied ETF and transfers the ETF LP to the user. Prior to this, the contract calculates the amount of ETF LP the user can obtain when joining the pool through _calculateShare . It is important to note that if the user's deposit amount is relatively small, due to decimal errors during calculation, the amount of LP obtained during the joinPool operation may be 1 wei more than the amount calculated by _calculateShare . However, this does not aect the normal business logic of the protocol. ",
        "labels": [
            "SlowMist",
            "DeSyn - Restaking - SlowMist Audit Report",
            "Type: Arithmetic Accuracy Deviation Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Issues where issueFee maybe 0",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn - Restaking - SlowMist Audit Report.pdf",
        "body": "In the _calculateShare function, it calculates the amount of LP that can be obtained based on the amount of tokens that need to be deposited into the ETF. In this process, it considers the minting fee charged when depositing into the ETF. However, it is important to note that if the user-specied ETF is closed-ended and the current isCompletedCollect state is false, the ETF will waive the minting fee for the depositor. This will cause the share calculated by the _calculateShare function to be smaller than expected, ultimately resulting in some funds remaining in the Restaking contract and not being deposited into the ETF. ",
        "labels": [
            "SlowMist",
            "DeSyn - Restaking - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Wrong slippage check issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cook Index_en-us.pdf",
        "body": "In the IssuanceModule contract, the _createTradeInfo function is used to create a structure containing trade data. Among them, it will obtain the thresholdAmounts parameter oset by slippage through the getMinAmountsOut function and the getMaxAmountsIn function. After the trade data is created, the trade operation will be executed 8 through the _executeTrade function, which will use the thresholdAmounts parameter as the minimum amounts to receive for trading on uniswap. However, since slippage check and trade execution are carried out in the same transaction, the thresholdAmounts parameter will still be aected by the last swap transaction of uniswap. Therefore, the slippage check cannot play a protective role. ",
        "labels": [
            "SlowMist",
            "Cook Index",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Logical redundancy issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cook Index_en-us.pdf",
        "body": "In the VesperWrapAdapter contract, getSpenderAddress is used to obtain the source token address of the wrap token, but the actual function logic directly returns the passed _wrappedToken parameter. This seems to be dierent from what the function comments indicate. ",
        "labels": [
            "SlowMist",
            "Cook Index",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of external calls 11",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cook Index_en-us.pdf",
        "body": "There are a large number of external calls in the IssuanceModule contract, but the external call part is not within the scope of this audit. It is necessary to pay attention to the unknown risks of external calls.",
        "labels": [
            "SlowMist",
            "Cook Index",
            "Type: Unsafe External Call Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Random can be predicted issue 15",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DODO-MiningV3 and NFT_en-us.pdf",
        "body": "The random number is uncertain when buying a ticket. However, there is no separate operation of using the redeeming tickets and determining the random number when redeeming tickets, and there is an issue that the random number can be predicted. https://github.com/DODOEX/contractV2/blob/453e323af6/contracts/DODODrops/DODODropsV2/DODODro ps.sol#L114 function buyTickets(address ticketTo, uint256 ticketAmount) payable external preventReentrant { (uint256 curPrice, uint256 sellAmount, uint256 index) = getSellingInfo(); require(curPrice > 0 && sellAmount > 0, \"CAN_NOT_BUY\"); require(ticketAmount <= sellAmount, \"TICKETS_NOT_ENOUGH\"); (uint256 payAmount, uint256 feeAmount) = IDropsFeeModel(_FEE_MODEL_).getPayAmount(address(this), ticketTo, curPrice, ticketAmount); require(payAmount > 0, \"UnQualified\"); uint256 baseBalance = IERC20(_BUY_TOKEN_).universalBalanceOf(address(this)); uint256 buyInput = baseBalance.sub(_BUY_TOKEN_RESERVE_); require(payAmount <= buyInput, \"PAY_AMOUNT_NOT_ENOUGH\"); _SELLING_AMOUNT_SET_[index] = sellAmount.sub(ticketAmount); _BUY_TOKEN_RESERVE_ = baseBalance.sub(feeAmount); IERC20(_BUY_TOKEN_).universalTransfer(_MAINTAINER_,feeAmount); _mint(ticketTo, ticketAmount); emit BuyTicket(ticketTo, payAmount, feeAmount, ticketAmount); } The owner determines the value of _REVEAL_RN_ by calling the setRevealRn function. The value of _REVEAL_RN_ will affect the result of the random number. https://github.com/DODOEX/contractV2/blob/453e323af6/contracts/DODODrops/DODODropsV2/DODODro ps.sol#L229 function setRevealRn() external onlyOwner { require(_REVEAL_RN_ == 0, \"ALREADY_SET\"); 16 _REVEAL_RN_ = uint256(keccak256(abi.encodePacked(blockhash(block.number - 1)))); emit SetReveal(); } The value of random is related to _REVEAL_RN_ , msg.sender , balanceOf(msg.sender) and curNo in REVEAL_MODE mode when users use wallets for transactions. Attackers can generate addresses and balances values to control the random number. In non-REVEAL_MODE mode, the value of random is related to _RNG_ , block.number , and gasleft . The attackers can sort transactions through pre-execution or in cooperation with miners. In this way, they can manipulate block.number and gasleft to control random numbers. https://github.com/DODOEX/contractV2/blob/453e323af6/contracts/DODODrops/DODODropsV2/DODODro ps.sol#L154-L159 function _redeemSinglePrize(address to, uint256 curNo, address referer) internal { require(block.timestamp >= _REDEEM_ALLOWED_TIME_ && _REDEEM_ALLOWED_TIME_ != 0, \"REDEEM_CLOSE\"); uint256 range; if(_IS_PROB_MODE_) { range = _PROB_INTERVAL_[_PROB_INTERVAL_.length - 1]; }else { range = _TOKEN_ID_LIST_.length; } uint256 random; if(_IS_REVEAL_MODE_) { require(_REVEAL_RN_ != 0, \"REVEAL_NOT_SET\"); random = uint256(keccak256(abi.encodePacked(_REVEAL_RN_, msg.sender, balanceOf(msg.sender).add(curNo + 1)))) % range; }else { random = IRandomGenerator(_RNG_).random(gasleft() + block.number) % range; } uint256 tokenId; if(_IS_PROB_MODE_) { uint256 i; for (i = 0; i < _PROB_INTERVAL_.length; i++) { if (random <= _PROB_INTERVAL_[i]) { break; } } require(_TOKEN_ID_MAP_[i].length > 0, \"EMPTY_TOKEN_ID_MAP\"); 17 tokenId = _TOKEN_ID_MAP_[i][random % _TOKEN_ID_MAP_[i].length]; IDropsNft(_NFT_TOKEN_).mint(to, tokenId, 1, \"\"); } else { tokenId = _TOKEN_ID_LIST_[random]; if(random != range - 1) { _TOKEN_ID_LIST_[random] = _TOKEN_ID_LIST_[range - 1]; } _TOKEN_ID_LIST_.pop(); IDropsNft(_NFT_TOKEN_).mint(to, tokenId); } emit RedeemPrize(to, tokenId, referer); }",
        "labels": [
            "SlowMist",
            "DODO-MiningV3 and NFT",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "isContract can be bypassed",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DODO-MiningV3 and NFT_en-us.pdf",
        "body": "When redeeming tickets isContract is used to determine whether the caller msg.sender is a contract. The contract is not allowed to be called, but the implementation of this check has flaws and can be bypassed. https://github.com/DODOEX/contractV2/blob/453e323af6/contracts/DODODrops/DODODropsV2/DODODro ps.sol#L135 18 function redeemTicket(uint256 ticketNum, address referer) external { require(!address(msg.sender).isContract(), \"ONLY_ALLOW_EOA\"); require(ticketNum >= 1 && ticketNum <= balanceOf(msg.sender), \"TICKET_NUM_INVALID\"); _burn(msg.sender,ticketNum); for (uint256 i = 0; i < ticketNum; i++) { _redeemSinglePrize(msg.sender, i, referer); } } https://github.com/DODOEX/contractV2/blob/453e323af6/contracts/external/utils/Address.sol#L27 function isContract(address account) internal view returns (bool) { // This method relies on extcodesize, which returns 0 for contracts in // construction, since the code is only stored at the end of the // constructor execution. uint256 size; // solhint-disable-next-line no-inline-assembly assembly { size := extcodesize(account) } return size > 0; }",
        "labels": [
            "SlowMist",
            "DODO-MiningV3 and NFT",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Excessive authority issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DODO-MiningV3 and NFT_en-us.pdf",
        "body": "The owner can control the source of the seed of the random number. The seed of the random number will affect the value of the random number and affect the probability of redeeming the ticket. 19 https://github.com/DODOEX/contractV2/blob/453e323af6/contracts/DODODrops/DODODropsV2/DODODro ps.sol#L227 function setRevealRn() external onlyOwner { require(_REVEAL_RN_ == 0, \"ALREADY_SET\"); _REVEAL_RN_ = uint256(keccak256(abi.encodePacked(blockhash(block.number - 1)))); emit SetReveal(); } The owner can change the value of _RNG_ , which will affect the random number of the redemption ticket if it is not REVEAL_MODE. https://github.com/DODOEX/contractV2/blob/453e323af6/contracts/DODODrops/DODODropsV2/DODODro ps.sol#L259 function updateRNG(address newRNG) external onlyOwner { require(newRNG != address(0)); _RNG_ = newRNG; emit ChangeRNG(newRNG); } The owner can transfer _REWARD_TOKEN_ to any address. The current design framework Owner address will be sent to the address of the Mine contract. https://github.com/DODOEX/contractV2/blob/c7202eeae7/contracts/DODOToken/DODOMineV3/RewardVau lt.sol#L38-L49 function reward(address to, uint256 amount) external onlyOwner { require(_REWARD_RESERVE_ >= amount, \"VAULT_NOT_ENOUGH\"); _REWARD_RESERVE_ = _REWARD_RESERVE_.sub(amount); IERC20(_REWARD_TOKEN_).safeTransfer(to, amount); } function withdrawLeftOver(address to,uint256 amount) external onlyOwner { require(_REWARD_RESERVE_ >= amount, \"VAULT_NOT_ENOUGH\"); 20 _REWARD_RESERVE_ = _REWARD_RESERVE_.sub(amount); IERC20(_REWARD_TOKEN_).safeTransfer(to, amount); } The owner can mint tokens for any user and burn any user's tokens. https://github.com/DODOEX/contractV2/blob/c7202eeae7/contracts/external/ERC20/CustomERC20.sol#L12 3-L138 function mint(address user, uint256 value) external onlyOwner { require(isMintable, \"NOT_MINTABEL_TOKEN\"); balances[user] = balances[user].add(value); totalSupply = totalSupply.add(value); emit Mint(user, value); emit Transfer(address(0), user, value); } function burn(address user, uint256 value) external onlyOwner { require(isMintable, \"NOT_MINTABEL_TOKEN\"); balances[user] = balances[user].sub(value); totalSupply = totalSupply.sub(value); emit Burn(user, value); emit Transfer(user, address(0), value); } The owner can update the template contract. If an unaudited template contract is updated, this will affect the assets of the new user in the newly created contract. https://github.com/DODOEX/contractV2/blob/c7202eeae7/contracts/SmartRoute/proxies/DODOMineV3Prox y.sol#L128 function updateMineV2Template(address _newMineV3Template) external onlyOwner { _MINEV3_TEMPLATE_ = _newMineV3Template; } https://github.com/DODOEX/contractV2/blob/7e629d0e58/contracts/Factory/ERC20V2Factory.sol 21 function updateStdTemplate(address newStdTemplate) external onlyOwner { _ERC20_TEMPLATE_ = newStdTemplate; emit ChangeStdTemplate(newStdTemplate); } function updateCustomTemplate(address newCustomTemplate) external onlyOwner { _CUSTOM_ERC20_TEMPLATE_ = newCustomTemplate; emit ChangeCustomTemplate(newCustomTemplate); }",
        "labels": [
            "SlowMist",
            "DODO-MiningV3 and NFT",
            "Type: Authority Control Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "The DoS risk",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DODO-MiningV3 and NFT_en-us.pdf",
        "body": "Use a for loop to traverse the array. If the number of loops is large, it will cause an out of gas. After communication and feedback, the project team will ensure that the number of rewardTokenInfos will not be too much. 22 https://github.com/DODOEX/contractV2/blob/c7202eeae7/contracts/DODOToken/DODOMineV3/BaseMine.s ol#L258 function _updateAllReward(address user) internal { uint256 len = rewardTokenInfos.length; for (uint256 i = 0; i < len; i++) { _updateReward(user, i); } }",
        "labels": [
            "SlowMist",
            "DODO-MiningV3 and NFT",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Event log missing",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DODO-MiningV3 and NFT_en-us.pdf",
        "body": "The owner can arbitrarily set an external contract address as a template contract. When a user creates a new contract, it will be created based on the template contract. After creation, the asset needs to be recharged to the new contract. There is no event record, which is unfavorable for review by community users. https://github.com/DODOEX/contractV2/blob/c7202eeae7/contracts/SmartRoute/proxies/DODOMineV3Prox y.sol#L128 function updateMineV2Template(address _newMineV3Template) external onlyOwner { _MINEV3_TEMPLATE_ = _newMineV3Template; } The owner can modify the configuration of the contract, but there is no event record, which is unfavorable for review by community users. 23 https://github.com/DODOEX/contractV2/blob/c7202eeae7/contracts/Factory/Registries/DODOMineV3Registr y.sol#L87-L101 function addAdminList (address contractAddr) external onlyOwner { isAdminListed[contractAddr] = true; } function removeAdminList (address contractAddr) external onlyOwner { isAdminListed[contractAddr] = false; } function addSingleTokenList(address token) external onlyOwner { singleTokenList[token] = true; } function removeSingleTokenList(address token) external onlyOwner { singleTokenList[token] = false; }",
        "labels": [
            "SlowMist",
            "DODO-MiningV3 and NFT",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Check enhancement of isLpToken",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DODO-MiningV3 and NFT_en-us.pdf",
        "body": "Admin can add non-LPtoken assets but isLpToken is True, or belong to LPtoken assets but isLpToken is False Pool, which will affect the actual business logic. This part of the inspection is not implemented in the contract. https://github.com/DODOEX/contractV2/blob/c7202eeae7/contracts/Factory/Registries/DODOMineV3Registr y.sol#L44 function addMineV3( address mine, 24 bool isLpToken, address stakeToken ) override external { require(isAdminListed[msg.sender], \"ACCESS_DENIED\"); _MINE_REGISTRY_[mine] = stakeToken; if(isLpToken) { _LP_REGISTRY_[stakeToken] = mine; }else { require(_SINGLE_REGISTRY_[stakeToken].length == 0 || singleTokenList[stakeToken], \"ALREADY_EXSIT_POOL\"); _SINGLE_REGISTRY_[stakeToken].push(mine); } emit NewMineV3(mine, stakeToken, isLpToken); }",
        "labels": [
            "SlowMist",
            "DODO-MiningV3 and NFT",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Security reminder on architecture design",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DODO-MiningV3 and NFT_en-us.pdf",
        "body": "createStdERC20 and createMintableERC20 are open-ended calls. The user creates a contract using the createStdERC20 function to record the created information in _USER_STD_REGISTRY_ , and then can get the information through getTokenByUser. Because it is an open call, it is not recommended to use the data obtained by getTokenByUser. As input for other businesses, after communication and feedback, the project party will not rely on the data obtained by getTokenByUser in the business logic of the project. https://github.com/DODOEX/contractV2/blob/c7202eeae7/contracts/Factory/ERC20V2Factory.sol#L72-L123 function createStdERC20( uint256 totalSupply, string memory name, 25 string memory symbol, uint256 decimals ) external returns (address newERC20) { newERC20 = ICloneFactory(_CLONE_FACTORY_).clone(_ERC20_TEMPLATE_); IStdERC20(newERC20).init(msg.sender, totalSupply, name, symbol, decimals); _USER_STD_REGISTRY_[msg.sender].push(newERC20); emit NewERC20(newERC20, msg.sender, 0); } function createCustomERC20( uint256 initSupply, string memory name, string memory symbol, uint256 decimals, uint256 tradeBurnRatio, uint256 tradeFeeRatio, address teamAccount, bool isMintable ) external returns (address newCustomERC20) { newCustomERC20 = ICloneFactory(_CLONE_FACTORY_).clone(_CUSTOM_ERC20_TEMPLATE_); ICustomERC20(newCustomERC20).init( msg.sender, initSupply, name, symbol, decimals, tradeBurnRatio, tradeFeeRatio, teamAccount, isMintable ); _USER_CUSTOM_REGISTRY_[msg.sender].push(newCustomERC20); if(isMintable) emit NewERC20(newCustomERC20, msg.sender, 2); else emit NewERC20(newCustomERC20, msg.sender, 1); } // ============ View ============ function getTokenByUser(address user) external 26 view returns (address[] memory stds,address[] memory customs) { return (_USER_STD_REGISTRY_[user], _USER_CUSTOM_REGISTRY_[user]); }",
        "labels": [
            "SlowMist",
            "DODO-MiningV3 and NFT",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Pages calculation issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SubDao_en-us.pdf",
        "body": "In the DaoFactory contract, calculatePages is used to calculate the start index and end index of a page. The size, start index and end index are checked in the function size <= 0 || start >= total || start < end , but in fact, size should not be less than 0, and start should not be greater than total. ",
        "labels": [
            "SlowMist",
            "SubDao",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Missing event records",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SubDao_en-us.pdf",
        "body": "In the DaoTemplate contract, the user can modify the actionCong parameter through the setActionCong function, but no event recording is performed. The same is true for the setActionCong function in the VentureTemplate contract. The same is true for the setCanFreeAddMember, transferOwner and updateOwnership functions in the OrgManager contract. ",
        "labels": [
            "SlowMist",
            "SubDao",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Owner update issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SubDao_en-us.pdf",
        "body": "In the DaoTemplate contract, the owner can update the owner of all components through the updateOwnership function. But it calls the updateOwnership interface of the templateCong contract by mistake. The same is true for the updateOwnership function in the VentureTemplate contract. ",
        "labels": [
            "SlowMist",
            "SubDao",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "State Coverage Risk",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SubDao_en-us.pdf",
        "body": "In the GrantMethodManager contract, DaoTemplate can operate the applyOp and setUserOpByOwner functions through the action contract. Since the parameters it receives are all passed in from the outside, if the incoming data is repeated, the encoded key will be repeated, which will cause the existing data to be overwritten. ",
        "labels": [
            "SlowMist",
            "SubDao",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "TODO label issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SubDao_en-us.pdf",
        "body": "There is still a TODO label in the spendTokenInLimit function of the GrantMethodManager contract. Is there still a function not perfect? The same is true for the _unsafeCancelVote function in the VoteManager contract. ",
        "labels": [
            "SlowMist",
            "SubDao",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Length check issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SubDao_en-us.pdf",
        "body": "The initialize function exists in the VenturesStockManager , VenturesManager and GovTokenManager contracts to initialize the contract according to the incoming parameters. It checks the byte length of the incoming parameter, but because some parameters are variable-length data, forcing an equals check will lead to unsuccessful initialization. ",
        "labels": [
            "SlowMist",
            "SubDao",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Vote check issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SubDao_en-us.pdf",
        "body": "In the VoteManager contract, the _canExecute function is used to check whether the proposal can be executed, but it does not check whether the number of yes votes is greater than the number of negative votes. ",
        "labels": [
            "SlowMist",
            "SubDao",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Cancel voting issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SubDao_en-us.pdf",
        "body": "29 In the VoteManager contract, the _canCancel function user checks whether the current vote can be cancelled. If the voting period for a proposal has passed, but the execution conditions are still not met, the proposal cannot be executed or cancelled. ",
        "labels": [
            "SlowMist",
            "SubDao",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Risk of Governance Attacks",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SubDao_en-us.pdf",
        "body": "DAO members can create new proposals through ActionVoteNew , ActionGrantMethodRegister , ActionVoteTransferPeriodRegister and other contracts. However, the proposal does not contain the data that needs to be executed. After the proposal is passed, the community members will pass in the specic execution data for execution. If malicious data is passed in, there is a risk that the protocol will be maliciously broken during proposal execution.",
        "labels": [
            "SlowMist",
            "SubDao",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Potential Fund Theft Risk",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SubDao_en-us.pdf",
        "body": "As mentioned in N12, when a DAO member creates an Operation through ActionGrantMethodRegister, the user's specic execution data is not recorded in the newVote operation. Although registerOp records the extra data passed in by the user, it is not used op_.extra in actual execution. Therefore, the user can pass in valid execution data when performing the registerOp operation. And malicious data is passed in during the ActionVaultUniswapV2Router02Swap operation. This will result in funds managed by the DAO being approved for malicious router contracts, or swapping through extremely illiquid pools, allowing malicious users to easily arbitrage. This would create huge risks for DAOs. The same is true in the ActionVaultUniswapV2SwapToken contract. ",
        "labels": [
            "SlowMist",
            "SubDao",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Lack of access control",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SubDao_en-us.pdf",
        "body": "In the VenturesManager contract, the gpRaiseMoney and lpRaiseMoney functions are not restricted to be called by the owner. ",
        "labels": [
            "SlowMist",
            "SubDao",
            "Type: Authority Control Vulnerability",
            "Severity: High"
        ]
    },
    {
        "title": "Period transfer issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SubDao_en-us.pdf",
        "body": "In the ActionVoteTransferPeriodApply contract, when performing a period transfer, the period will be obtained through the transferPeriodStates function of the VoteExecutionManager contract, and then the period will be transferred through the transferVenturePeriod function of the VenturesManager contract. But in the current action, period is directly transferred to SettlementPeriod. ",
        "labels": [
            "SlowMist",
            "SubDao",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - X2Y2 - NFT Lending_en-us.pdf",
        "body": "1.In the Cong contract, the owner role can add manager role and can update the adminShare, and the manager role can set or remove the ERC20 and ERC721 tokens through the setERC20Permits and setERC721Permits functions. If the ERC20 and ERC721 on the loan list, the manager sets these permit as false may cause the risk of excessive authority. ",
        "labels": [
            "SlowMist",
            "X2Y2 - NFT Lending",
            "Type: Authority Control Vulnerability",
            "Severity: High"
        ]
    },
    {
        "title": "Token compatibility issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - X2Y2 - NFT Lending_en-us.pdf",
        "body": "In the XY3 contract, the lender will transfer the ERC20 token to the borrower in the borrow function also to the lender and adminFeeReceiver in the repay function. And this transfer is used the SafeER20 safeTransferFrom function and transfer the exact amount of the borrowAmount, payoAmount and adminFee. If the borrowAsset ERC20 tokens are the deationary tokens (or other tokens that require a transfer fee) which will cause the call failed. ",
        "labels": [
            "SlowMist",
            "X2Y2 - NFT Lending",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Dev address setting enhancement suggestions",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - X2Y2 - NFT Lending_en-us.pdf",
        "body": "In the Cong contract, the manager role can update the adminFeeReceiver in the updateAdminFeeReceiver function to receive the adminFee. If the adminFeeReceiver address is an EOA address, in a scenario where the private key is leaked, the teams revenue will be stolen. ",
        "labels": [
            "SlowMist",
            "X2Y2 - NFT Lending",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "The deationary token docking issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - CakeVault_en-us.pdf",
        "body": "Users can transfer the cake token into the vault contract through the deposit function. Under normal circumstances, the number of staking tokens transferred by the user is the same as the _amount parameter passed in. But if the staking token is a deationary token, the number of tokens transferred by the user may be dierent from the number of tokens actually received in the contract. ",
        "labels": [
            "SlowMist",
            "CakeVault",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "CakeAtLastUserAction parameter record error issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - CakeVault_en-us.pdf",
        "body": "In the Vault contract, the user can withdraw the funds staked by the user through the withdraw function. If the user does not withdraw all funds (user.shares> 0), this function will recalculate the user's cakeAtLastUserAction value. In the calculation process, the number of cake tokens obtained by the balanceOf function is used to participate in the calculation. But at the end of this function, a certain amount of cake tokens will be transferred to the user through the safeTransfer function, so the number of cake tokens obtained by the balanceOf function used in the calculation of cakeAtLastUserAction is relatively large. ",
        "labels": [
            "SlowMist",
            "CakeVault",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing event records",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - CakeVault_en-us.pdf",
        "body": "In the contract, the owner role can set the addresses of the admin role and the treasure role through the setAdmin function and the setTreasury function, respectively, but no event recording is performed. In the contract, the admin role can change the sensitive parameters of the contract through the setPerformanceFee, setCallFee, setWithdrawFee, and setWithdrawFeePeriod functions, but no event recording is performed. ",
        "labels": [
            "SlowMist",
            "CakeVault",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Emergency withdrawal issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - CakeVault_en-us.pdf",
        "body": "In the Vault contract, the admin role can make emergency withdrawals of cake tokens from the MasterChef contract to the Vault contract via the emergencyWithdraw function. However, it should be noted that any user can obtain 0.25% of the cake token reward in the Vault contract through the harvest function, and re-stake the remaining cake tokens into the MasterChef contract. So if the emergencyWithdraw operation is performed while the contract is not suspended it may cause unintended results. 10 ",
        "labels": [
            "SlowMist",
            "CakeVault",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Partial logic not implemented",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Das Contract Reverse_en-us.pdf",
        "body": "In the setReverseName function of the ReverseLogic contract, after the previous check, the specic check logic when the owner is still 0 address is not implemented. ",
        "labels": [
            "SlowMist",
            "Das Contract Reverse",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Potential risk of arbitrarily setting reverse name",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Das Contract Reverse_en-us.pdf",
        "body": "In the ReverseLogic contract, the user can set the reverse name through the setReverseName function, which allows the contract to set itself. However, some contracts have the feature of arbitrary external calls, which will allow any user to set the reverse name of the contract. ",
        "labels": [
            "SlowMist",
            "Das Contract Reverse",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "4.2.1.1 The settleHolderInterest is not used to update user interest before Withdraw",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - dFuture_en-us.pdf",
        "body": "The code uses payOffInterest to process the user's interest when processing the user's withdraw, but it did not use settleHolderInterest to update the user's interest situation before, resulting in a deviation in the interest payment. ",
        "labels": [
            "SlowMist",
            "dFuture",
            "Severity: Low"
        ]
    },
    {
        "title": "4.2.1.2 The global status is not updated when using the getMarginRatioOf function",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - dFuture_en-us.pdf",
        "body": "to calculate the user's position When using the getMarginRationOf function to calculate the user's position, the global state is not updated with updateGlobalInterestRate first, which may cause calculation errors. ",
        "labels": [
            "SlowMist",
            "dFuture",
            "Severity: Low"
        ]
    },
    {
        "title": "4.2.1.3 When calculating the user's position,",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - dFuture_en-us.pdf",
        "body": "the user's intereset <0 is not considered When using the getMarginRationOf function to calculate the user's position, the case of rate <0 is not 22 processed. ",
        "labels": [
            "SlowMist",
            "dFuture",
            "Severity: Low"
        ]
    },
    {
        "title": "4.2.2.1 did not consider the issue of system compensation, and did not limit the",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - dFuture_en-us.pdf",
        "body": "maximum benefits of users The system code does not consider whether the system can pay for this when processing the user's position closing. When this happens, it will cause an unknown error. ",
        "labels": [
            "SlowMist",
            "dFuture",
            "Severity: Low"
        ]
    },
    {
        "title": "Missing Checking",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap_en-us.pdf",
        "body": "In PancakeSwapRouter contract, the removeLiquidity / removeLiquidityETH / removeLiquidityWithPermit function does not check whether a pair is exist, which will leads to gas wasting when a pair does not exist. eg. removeLiquidity function function removeLiquidity( address tokenA, address tokenB, uint liquidity, uint amountAMin, uint amountBMin, address to, uint deadline ) public virtual override ensure(deadline) returns (uint amountA, uint amountB) { 13 address pair = PancakeLibrary.pairFor(factory, tokenA, tokenB); IPancakePair(pair).transferFrom(msg.sender, pair, liquidity); // send liquidity to pair (uint amount0, uint amount1) = IPancakePair(pair).burn(to); (address token0,) = PancakeLibrary.sortTokens(tokenA, tokenB); (amountA, amountB) = tokenA == token0 ? (amount0, amount1) : (amount1, amount0); require(amountA >= amountAMin, 'PancakeRouter: INSUFFICIENT_A_AMOUNT'); require(amountB >= amountBMin, 'PancakeRouter: INSUFFICIENT_B_AMOUNT'); }",
        "labels": [
            "SlowMist",
            "PancakeSwap",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Open Social - Abstract Account_en-us.pdf",
        "body": "1.In the VerifyingSingletonPaymaster contract, the DEFAULT_ADMIN_ROLE can arbitrarily set the unaccountedEPGasOverhead parameters. If this parameter is set too high, paymasterIdBalances may be consumed maliciously. ",
        "labels": [
            "SlowMist",
            "Open Social - Abstract Account",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Ordinary users with permitCalls may use the owner privilege through arbitrary contract calls",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Open Social - Abstract Account_en-us.pdf",
        "body": "The execute and executeBatch functions allow ordinary users to call the contracts which in the permitCalls with arbitrary calldata, can control their native token or ERC20 token assets by these functions. However, this functionality can be abused and users calling the contract itself (OspAccount) through the EntryPoint contract will then be able to call functions like setOwner, setRecoveryAddress, setPermitCall, and revokeSessionKey functions, thus overstepping their authority. ",
        "labels": [
            "SlowMist",
            "Open Social - Abstract Account",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing the event records",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Open Social - Abstract Account_en-us.pdf",
        "body": "In the WhitelistOperationVerifyingPaymaster and the OspAccountFactory contracts, the ADMIN and DEFAULT_ADMIN_ROLE can arbitrarily modify OperationInPut , enableWhitelistOperation , and accountImplementation parameters, but there are no event logs in these functions. ",
        "labels": [
            "SlowMist",
            "Open Social - Abstract Account",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing zero address validation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Open Social - Abstract Account_en-us.pdf",
        "body": "In the OspAccount and the OspAccountFactory contracts, it lacks a zero-check when setting addresses. ",
        "labels": [
            "SlowMist",
            "Open Social - Abstract Account",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "ERC777 reentrancy risk reminder",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Open Social - Abstract Account_en-us.pdf",
        "body": "ERC777 tokens are vulnerable to reentrancy attacks due to a design aw. In the TokenCallbackHandler contract, the deprecated ERC777 standard tokensReceived has been introduced into the contract. If there is any need to deal with ERC77 tokens in the project, strict attention needs to be paid to whether there is reentrancy risk. ",
        "labels": [
            "SlowMist",
            "Open Social - Abstract Account",
            "Type: Unsafe External Call Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing event log",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Arowana_en-us.pdf",
        "body": "The owner role can call the addToken and removeToken functions to add and remove the specied token address into the _addresses and _indexes . If there is no event record, it is not conducive to the review of community users. ",
        "labels": [
            "SlowMist",
            "Arowana",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing event log",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Arowana_en-us.pdf",
        "body": "7 The owner role can call the setValut function to set the source of reward token distribution. If there is no event record, it is not conducive to the review of community users. ",
        "labels": [
            "SlowMist",
            "Arowana",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing balance change",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Arowana_en-us.pdf",
        "body": "When the user calls the withdraw function for withdrawal ( block.timestap >= pool.end ), the balance of pool is not changed here. ",
        "labels": [
            "SlowMist",
            "Arowana",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Missing balance check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Arowana_en-us.pdf",
        "body": "When the user calls the withdraw function for withdrawal ( block.timestap >= pool.end ), there is a lack of judgment on the balance of valut. If the token balance of valut is not enough to pay the user's reward, the transaction will be rolled back and the user's principal and reward cannot be withdrawn. ",
        "labels": [
            "SlowMist",
            "Arowana",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Lack of access control issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning Farm - ETH Leverage_en-us.pdf",
        "body": "In the BalancerReceiver contract, the SS contract can initiate WETH ash loans through the ashLoan function, but the ashLoan function allows any user to call. Although the loanFallback function of the SS contract checks curState, it is undoubtedly more expected that the ashLoan function can only be called by the SS contract. 10 ",
        "labels": [
            "SlowMist",
            "Earning Farm - ETH Leverage",
            "Type: Authority Control Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Gas optimization",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning Farm - ETH Leverage_en-us.pdf",
        "body": "In the ETHLeverage contract, the _harvest function is used to collect fees, which will only be charged when lastEarnBlock and block.number are used. But the function does not check whether the dierence between lastEarnBlock and block.number is 0. If multiple users in the same block trigger the _harvest function, it will cause unnecessary gas consumption. ",
        "labels": [
            "SlowMist",
            "Earning Farm - ETH Leverage",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Redundant logic issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning Farm - ETH Leverage_en-us.pdf",
        "body": "In the Controller contract, the owner can set the exchange and harvestFee parameters respectively through the setExchange and setHarvestFee functions. But in this contract the exchange and harvestFee parameters are not used. ",
        "labels": [
            "SlowMist",
            "Earning Farm - ETH Leverage",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "The problem of checking the number of swaps",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning Farm - ETH Leverage_en-us.pdf",
        "body": "In the ETHLeverExchange contract, the swapExactETH function is used to exchange stETH to ETH during emergency withdrawal. It will get the amount of ETH that can be exchanged through the get_dy function and check if the swap amount is larger than the expected required amount. But in theory it is acceptable for the number of swaps to be equal to what is expected to be required. ",
        "labels": [
            "SlowMist",
            "Earning Farm - ETH Leverage",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning Farm - ETH Leverage_en-us.pdf",
        "body": "In the protocol, the owner role has many permissions, such as: the owner can set sensitive parameters, can suspend the contract, can make emergency withdrawals, can migrate the funds of the SS contract, etc. It is obviously inappropriate to give all the permissions of the protocol to the owner, which will greatly increase the single point of 13 risk.",
        "labels": [
            "SlowMist",
            "Earning Farm - ETH Leverage",
            "Type: Authority Control Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Risk of exchange slippage",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning Farm - ETH Leverage_en-us.pdf",
        "body": "When users make withdrawals in the protocol, they need to exchange stETH tokens for ETH tokens through CurvePool. However, the exchange slippage is not limited in the ETHLeverExchange contract, which will make users vulnerable to sandwich attacks when withdrawing. ",
        "labels": [
            "SlowMist",
            "Earning Farm - ETH Leverage",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Medium Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Ultiverse - Chips Contract_en-us.pdf",
        "body": "1.In the GoldChip contract, the owner role can modify key sensitive parameters such as the burnable status, the _baseTokenURI , and granting or revoking roles, which will lead to the risk of over-privilege of the owner role. ",
        "labels": [
            "SlowMist",
            "Ultiverse - Chips Contract",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Low-level call reminder",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Ultiverse - Chips Contract_en-us.pdf",
        "body": "In the ChipStakingPool contract, the contract uses low-level calls and does not limit the amount of gas used to transfer native tokens to users. ",
        "labels": [
            "SlowMist",
            "Ultiverse - Chips Contract",
            "Type: Others",
            "Severity: Information"
        ]
    },
    {
        "title": "Potential overow risks caused by type conversion",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Ultiverse - Chips Contract_en-us.pdf",
        "body": "In the ChipStakingPool contract, users can deposit the native tokens to gain the Lots. The deposit function uses a type conversion to convert the uint256 type values such as quantity, availableGoldLots, and availableSilverLots to the uint64 type. If the user passes in a quantity greater than uint64, this will cause the overow when converting the data to uint256. ",
        "labels": [
            "SlowMist",
            "Ultiverse - Chips Contract",
            "Type: Arithmetic Accuracy Deviation Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Refund lock reminder",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Ultiverse - Chips Contract_en-us.pdf",
        "body": "In the ChipStakingPool contract, users can deposit native tokens to get Lots and claim refunds to get the native back. When calling these two functions, these two functions will check the MerkleProof signed by the central. The claimRefund function will also check whether the user claimed before by checking the userRefundCount[_msgSender()] is larger than 0. If the signed MerkleProof quantity is not the same as the users deposit. There will be a situation where the user will not be able to call the claimRefund function again to withdraw native tokens after claiming refunds once. ",
        "labels": [
            "SlowMist",
            "Ultiverse - Chips Contract",
            "Type: Design Logic Audit",
            "Severity: Information"
        ]
    },
    {
        "title": "Transaction reordering issues",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - wault.finance(WUSD)_en-us.pdf",
        "body": "(1) In commit: 91c541c2f1c0ac781ddcfb2be6a62555a5e1e8d1, the swapExactTokensForTokensSupportingFeeOnTransferTokens in the stake function is not checked for slippage. https://github.com/WaultFinance/WUSD/blob/91c541c2f/WUSDMaster.sol#L716-L722 function stake(uint256 amount) external nonReentrant { require(amount > 0, 'amount cant be zero'); require(wusdClaimAmount[msg.sender] == 0, 'you have to claim first'); require(amount <= maxStakeAmount, 'amount too high'); usdt.safeTransferFrom(msg.sender, address(this), amount); if(feePermille > 0) { uint256 feeAmount = amount * feePermille / 1000; usdt.safeTransfer(treasury, feeAmount); amount = amount - feeAmount; } uint256 wexAmount = amount * wexPermille / 1000; usdt.approve(address(wswapRouter), wexAmount); wswapRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens( wexAmount, 0, swapPath, address(this), block.timestamp ); wusdClaimAmount[msg.sender] = amount; wusdClaimBlock[msg.sender] = block.number; emit Stake(msg.sender, amount); } 9 (2) In commit: de61d93cd7a35213484827cf32533919c34e732e amountOutMin is the parameter that limits the slippage, but it is entered by the user, the maxStakeAmount is added, but this limit can still be bypassed by sorting multiple transactions. https://github.com/WaultFinance/WUSD/blob/de61d93cd7a35213484827cf32533919c34e732e/WUSDMas ter.sol#L808-L834 function stake(uint256 amount, uint256 amountOutMin) external nonReentrant whenNotPaused { require(amount > 0, 'amount cant be zero'); require(wusdClaimAmount[msg.sender] == 0, 'you have to claim first'); require(amount <= maxStakeAmount, 'amount too high'); usdt.safeTransferFrom(msg.sender, address(this), amount); if(feePermille > 0) { uint256 feeAmount = amount * feePermille / 1000; usdt.safeTransfer(treasury, feeAmount); amount = amount - feeAmount; } wusd.mint(address(this), amount); uint256 wexAmount = amount * wexPermille / 1000; usdt.approve(address(wswapRouter), wexAmount); wswapRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens( wexAmount, amountOutMin, swapPath, address(this), block.timestamp ); wusdClaimAmount[msg.sender] = amount; wusdClaimBlock[msg.sender] = block.number; emit Stake(msg.sender, amount); } (3) In commit: 5f50a2c77828c70299e8a9217cfbb926b8c1, the maxStakePerBlock is added, but this limit can still be bypassed by sorting multiple transactions in multiple blocks. 10 https://github.com/WaultFinance/WUSD/blob/5f50a2c77828c70299e8a9217cfbb926b8c1/WUSDMaster. sol#L819-L851 function stake(uint256 amount, uint256 amountOutMin) external nonReentrant whenNotPaused { require(amount > 0, 'amount cant be zero'); require(wusdClaimAmount[msg.sender] == 0, 'you have to claim first'); require(amount <= maxStakeAmount, 'amount too high'); if(lastBlock != block.number) { lastBlockUsdtStaked = 0; lastBlock = block.number; } lastBlockUsdtStaked += amount; require(lastBlockUsdtStaked <= maxStakePerBlock, 'maximum stake per block exceeded'); usdt.safeTransferFrom(msg.sender, address(this), amount); if(feePermille > 0) { uint256 feeAmount = amount * feePermille / 1000; usdt.safeTransfer(treasury, feeAmount); amount = amount - feeAmount; } wusd.mint(address(this), amount); uint256 wexAmount = amount * wexPermille / 1000; usdt.approve(address(wswapRouter), wexAmount); wswapRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens( wexAmount, amountOutMin, swapPath, address(this), block.timestamp ); wusdClaimAmount[msg.sender] = amount; wusdClaimBlock[msg.sender] = block.number; emit Stake(msg.sender, amount); }",
        "labels": [
            "SlowMist",
            "wault.finance(WUSD)",
            "Type: Reordering Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Helio Money_en-us.pdf",
        "body": "Owner or special administrator accounts can operate the key functions. - auth auth auth auth auth auth auth auth - - auth auth auth - auth auth CeToken burn CeToken mint CeToken changeVault hBNB hBNB hBNB burn mint changeMinter HelioProvider liquidation HelioProvider daoBurn HelioProvider daoMint HelioProvider changeDao HelioProvider changeCeToken HelioProvider changeProxy HelioProvider changeCollateralToken HelioProvider changeOperator CerosRouter changeVault CerosRouter changeDex CerosRouter changePool CerosRouter changeProvider OwnableUpgradeable renounceOwnership OwnableUpgradeable transferOwnership CeVaultV2 updateStorage MasterVault _updateCerosStrategyDebt MasterVault depositAllToStrategy MasterVault depositToStrategy MasterVault withdrawFromStrategy MasterVault withdrawAllFromStrategy MasterVault setStrategy MasterVault retireStrat MasterVault migrateStrategy MasterVault withdrawFee MasterVault setDepositFee MasterVault setWithdrawalFee MasterVault addManager MasterVault removeManager MasterVault changeProvider MasterVault changeFeeReceiver MasterVault changeStrategyAllocation WaitingPool addToQueue WaitingPool tryRemove WaitingPool setCapLimit SlidingWindowOracle _authorizeUpgrade UUPSUpgradeable upgradeTo UUPSUpgradeable upgradeToAndCall PriceOracleTestnet _authorizeUpgrade PriceOracle _authorizeUpgrade BaseStrategy setStrategist BaseStrategy setRewards BnbxYieldConverterStrategy changeStakeManager CerosYieldConverterStrategy changeBinancePool CerosYieldConverterStrategy changeCeRouter EmergencyShutdown setMultiSig Ownable renounceOwnership Ownable transferOwnership Interaction addToWhitelist Interaction removeFromWhitelist Jar Jar Jar replenish setSpread setExitDelay",
        "labels": [
            "SlowMist",
            "Helio Money",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Sandwich attacks can aect slippage scope",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Helio Money_en-us.pdf",
        "body": "contracts/ceros/CerosRouter.sol function deposit() external payable override nonReentrant returns (uint256 value) { //...snip code...// uint256[] memory outAmounts = _dex.getAmountsOut(amount, path); //...snip code...// uint256[] memory amounts = _dex.swapExactETHForTokens{ value: amount }(dexABNBcAmount, path, address(this), block.timestamp + 300); realAmount = amounts[1]; //...snip code...// } function withdrawWithSlippage( address recipient, uint256 amount, uint256 outAmount ) external override nonReentrant returns (uint256 realAmount) { //...snip code...// uint256[] memory amounts = _dex.swapExactTokensForETH( realAmount, outAmount, path, recipient, block.timestamp + 300 ); //...snip code...// } Sandwich attacks, also known as MEV attacks, refer to attackers using the transaction order and execution results on the blockchain to gain additional value. This type of attack is usually carried out by miners or transaction order executors, who can gain additional value by reordering transactions or selectively including or excluding them.",
        "labels": [
            "SlowMist",
            "Helio Money",
            "Type: Reordering Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Ratio arbitrage attack vulnerability",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Helio Money_en-us.pdf",
        "body": "contracts/ceros/CeVault.sol contracts/ceros/upgrades/CeVaultV2.sol function _deposit(address account, uint256 amount) private returns (uint256) { uint256 ratio = _aBNBc.ratio(); _aBNBc.transferFrom(msg.sender, address(this), amount); uint256 toMint = (amount * 1e18) / ratio; //SlowMist// _depositors[account] += amount; // aBNBc _ceTokenBalances[account] += toMint; // mint ceToken to recipient ICertToken(_ceToken).mint(account, toMint); emit Deposited(msg.sender, account, toMint); return toMint; } function _withdraw( address owner, address recipient, uint256 amount ) private returns (uint256) { uint256 ratio = _aBNBc.ratio(); uint256 realAmount = (amount * ratio) / 1e18;//SlowMist// require( _aBNBc.balanceOf(address(this)) >= realAmount, \"not such amount in the vault\" ); uint256 balance = _ceTokenBalances[owner]; require(balance >= amount, \"insufficient balance\"); _ceTokenBalances[owner] -= amount; // BNB // burn ceToken from owner ICertToken(_ceToken).burn(owner, amount); _depositors[owner] -= realAmount; // aBNBc _aBNBc.transfer(recipient, realAmount); emit Withdrawn(owner, recipient, realAmount); return realAmount; } Here we can see that the amount of deposit and withdraw is related to the ratio. We can query the implementation of the ratio from the call chain: _aBNBc: function ratio() public view returns (uint256) { return IBondToken(_bondToken).ratio(); } _bondToken: function ratio() public view override returns (uint256) { return _ratio; } function repairRatio(uint256 newRatio) external onlyOwner { _ratio = newRatio; emit RatioUpdated(_ratio); } function updateRatio(uint256 totalRewards) external onlyOperator { uint256 totalShares = totalSharesSupply(); uint256 denominator = _totalStaked + totalRewards - _totalUnbondedBonds; _ratio = multiplyAndDivideFloor(totalShares, 1e18, denominator); // (totalShares * 1e18) / denominator; if (historicalRatios.length == 0) { historicalRatios = new uint256[](8); } if (block.timestamp - _lastUpdate > 1 days - 1 minutes) { uint256 _latestOffset = latestOffset; historicalRatios[((_latestOffset + 1) % 8)] = _ratio; latestOffset = _latestOffset + 1; _lastUpdate = block.timestamp; } emit RatioUpdated(_ratio); } The value of the ratio can be modied by Owner or through other mechanisms. We may trust the operations of the Owner, but changes in the ratio can cause serious arbitrage attacks that can be implemented without the Owner's permission. The main idea is to use MEV attacks by monitoring the transaction memory pool on the blockchain. When a transaction that increases the ratio is found, one transaction deposits the CeVault contract, and another transaction calls the withdraw function of CeVault. By adjusting the form of the transaction fees, these two transactions are placed before and after the ratio change transaction, allowing direct get aBNBc in CeVault. Asset changes like this: Tx1: deposit: 100 aBNBc Tx2: repairRatio: 1-->1.2 Tx3: withdraw: 120 aBNBc",
        "labels": [
            "SlowMist",
            "Helio Money",
            "Type: Unsafe External Call Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Missing check return value",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Helio Money_en-us.pdf",
        "body": "Code location: _aBNBc.transferFrom(msg.sender,address(this),amount) (CeVault.sol#70) _aBNBc.transfer(recipient,availableYields) (CeVault.sol#105) _aBNBc.transfer(recipient,realAmount) (CeVault.sol#143) _certToken.transferFrom(owner,address(this),amount) (CerosRouter.sol#125) _certToken.transfer(recipient,profit) (CerosRouter.sol#165) IERC20(wBnbToken).approve(dexAddress,type()(uint256).max) (CerosRouter.sol#59) IERC20(certToken).approve(dexAddress,type()(uint256).max) (CerosRouter.sol#60) IERC20(certToken).approve(bondToken,type()(uint256).max) (CerosRouter.sol#61) IERC20(certToken).approve(pool,type()(uint256).max) (CerosRouter.sol#62) IERC20(certToken).approve(vault,type()(uint256).max) (CerosRouter.sol#63) _certToken.approve(address(_vault),0) (CerosRouter.sol#250) _certToken.approve(address(_vault),type()(uint256).max) (CerosRouter.sol#252) IERC20(_wBnbAddress).approve(address(_dex),0) (CerosRouter.sol#256) _certToken.approve(address(_dex),0) (CerosRouter.sol#257) IERC20(_wBnbAddress).approve(address(_dex),type()(uint256).max) (CerosRouter.sol#260) _certToken.approve(address(_dex),type()(uint256).max) (CerosRouter.sol#261) _certToken.approve(address(_pool),0) (CerosRouter.sol#266) _certToken.approve(address(_pool),type()(uint256).max) (CerosRouter.sol#268) IERC20(_ceToken).approve(daoAddress,type()(uint256).max) (HelioProvider.sol#67) _ceRouter.withdrawABNBc(recipient,amount) (HelioProvider.sol#155) _dao.deposit(account,address(_ceToken),amount) (HelioProvider.sol#174) _dao.withdraw(account,address(_ceToken),amount) (HelioProvider.sol#178) IERC20(_ceToken).approve(address(_dao),0) (HelioProvider.sol#194) IERC20(_ceToken).approve(address(_dao),type()(uint256).max) (HelioProvider.sol#196) IERC20(_ceToken).approve(address(_dao),0) (HelioProvider.sol#200) IERC20(_ceToken).approve(address(_dao),type()(uint256).max) (HelioProvider.sol#202) IERC20Upgradeable(_rewardsToken).approve(address(target),reward) (mediator/ElipsisMediator.sol#59) _bnbxToken.approve(destination,type()(uint256).max) (strategy/BnbxYieldConverterStrategy.sol#58) _bnbxToken.approve(address(_stakeManager),0) (strategy/BnbxYieldConverterStrategy.sol#313) _bnbxToken.approve(address(_stakeManager),type()(uint256).max) (strategy/BnbxYieldConverterStrategy.sol#315) _certToken.approve(binancePool,type()(uint256).max) (strategy/CerosYieldConverterStrategy.sol#40) _certToken.approve(address(_binancePool),0) (strategy/CerosYieldConverterStrategy.sol#146) _certToken.approve(address(_binancePool),type()(uint256).max) (strategy/CerosYieldConverterStrategy.sol#148) _snBnbToken.approve(destination,type()(uint256).max) (strategy/SnBnbYieldConverterStrategy.sol#57) _snBnbToken.approve(address(_stakeManager),0) (strategy/SnBnbYieldConverterStrategy.sol#309) _snBnbToken.approve(address(_stakeManager),type()(uint256).max) (strategy/SnBnbYieldConverterStrategy.sol#311) hay.transferFrom(address(receiver), address(this), total)(contracts/flash.sol#110) hay.transfer(keeper,hayBal) (libraries/AuctionProxy.sol#39) hay.transfer(keeper,hayBal) (libraries/AuctionProxy.sol#62) hay.transferFrom(msg.sender,address(this),hayMaxAmount) (libraries/AuctionProxy.sol#83) hay.transfer(receiverAddress,hayBal) (libraries/AuctionProxy.sol#99) hay.approve(hayJoin_,type()(uint256).max) (Interaction.sol#103) hay.approve(address(hayJoin),0) (Interaction.sol#109) hay.approve(hayJoin_,type()(uint256).max) (Interaction.sol#118) hay.approve(address(hayJoin),type()(uint256).max) (Interaction.sol#122) IERC20Upgradeable(hay).transferFrom(msg.sender,address(this),wad) (vow.sol#99) Not verifying the return value may lead to logical errors.",
        "labels": [
            "SlowMist",
            "Helio Money",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Missing zero address validation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Helio Money_en-us.pdf",
        "body": "Code locations: CeToken.changeVault(address).vault (CeToken.sol#47) CeVault.changeRouter(address).router (CeVault.sol#194) CerosRouter.changeProvider(address).provider (CerosRouter.sol#271) hBNB.changeMinter(address).minter (hBNB.sol#42) HelioProvider.initialize(address,address,address,address,address,address).certToken (HelioProvider.sol#51) HelioProvider.initialize(address,address,address,address,address,address).ceToken (HelioProvider.sol#52) HelioProvider.changeCeToken(address).ceToken (HelioProvider.sol#199) HelioProvider.changeProxy(address).auctionProxy (HelioProvider.sol#205) HelioProvider.changeOperator(address).operator (HelioProvider.sol#213) MasterVault.initialize(uint256,uint256,uint8,address,address).ceToken (masterVault/MasterVault.sol#86) MasterVault.withdrawETH(address,uint256).account (masterVault/MasterVault.sol#126) PriceOracle.initialize(address,IMovingWindowOracle,bool,address,address)._tokenIn (oracle/PriceOracle.sol#22) PriceOracle.initialize(address,IMovingWindowOracle,bool,address,address)._wbnb (oracle/PriceOracle.sol#25) PriceOracle.initialize(address,IMovingWindowOracle,bool,address,address)._usd (oracle/PriceOracle.sol#26) PriceOracleTestnet.initialize(address,IMovingWindowOracle,bool)._tokenIn (oracle/PriceOracleTestnet.sol#31) SlidingWindowOracle.initialize(address,uint256,uint8).factory_ (oracle/SlidingWindowOracle.sol#46) BnbxYieldConverterStrategy.distributeManual(address).recipient (strategy/BnbxYieldConverterStrategy.sol#253) SnBnbYieldConverterStrategy.distributeManual(address).recipient (strategy/SnBnbYieldConverterStrategy.sol#253) StkBnbStrategy.distributeManual(address).recipient (strategy/StkBnbStrategy.sol#280) Interaction.setWhitelistOperator(address).usr (Interaction.sol#59) Interaction.initialize(address,address,address,address,address,address,address).dog_ (Interaction.sol#86) Jar.initialize(string,string,address,uint256,uint256,uint256)._hayToken (jar.sol#88) Clipper.file(bytes32,address).data (clip.sol#166) Dog.file(bytes32,address).data (dog.sol#133) EmergencyShutdown.constructor(address,address)._vat (es.sol#19) EmergencyShutdown.constructor(address,address)._multisig (es.sol#19) EmergencyShutdown.setMultiSig(address)._multisig (es.sol#28) Vow.initialize(address,address,address)._hayJoin (vow.sol#59) Vow.initialize(address,address,address).multisig_ (vow.sol#59) Vow.file(bytes32,address).data (vow.sol#78)",
        "labels": [
            "SlowMist",
            "Helio Money",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Performs a multiplication on the result of a division",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Helio Money_en-us.pdf",
        "body": "- price = oneTokenOut / amountOut * 10 ** 18 (oracle/PriceOracleTestnet.sol#55) - d /= pow2 (oracle/libraries/FullMath.sol#23) - r *= 2 - d * r (oracle/libraries/FullMath.sol#27) - d /= pow2 (oracle/libraries/FullMath.sol#23) - r *= 2 - d * r (oracle/libraries/FullMath.sol#28) - d /= pow2 (oracle/libraries/FullMath.sol#23) - r *= 2 - d * r (oracle/libraries/FullMath.sol#29) - d /= pow2 (oracle/libraries/FullMath.sol#23) - r *= 2 - d * r (oracle/libraries/FullMath.sol#30) - d /= pow2 (oracle/libraries/FullMath.sol#23) - r *= 2 - d * r (oracle/libraries/FullMath.sol#31) - d /= pow2 (oracle/libraries/FullMath.sol#23) - r *= 2 - d * r (oracle/libraries/FullMath.sol#32) - d /= pow2 (oracle/libraries/FullMath.sol#23) - r *= 2 - d * r (oracle/libraries/FullMath.sol#33) - d /= pow2 (oracle/libraries/FullMath.sol#23) - r *= 2 - d * r (oracle/libraries/FullMath.sol#34) - l /= pow2 (oracle/libraries/FullMath.sol#24) - l * r (oracle/libraries/FullMath.sol#35) - poolTokens = (poolTokensToBurn * 1e11) / (1e11 - stakePool.config().fee.withdraw) (strategy/StkBnbStrategy.sol#188) - poolTokensFee = (poolTokens * stakePool.config().fee.withdraw) / 1e11 (strategy/StkBnbStrategy.sol#198) - x = xxRound_rpow_asm_0 / b (hMath.sol#19) - zx_rpow_asm_0 = z * x (hMath.sol#21) - d /= pow2 (oracle/libraries/FullMath.sol#23) - r *= 2 - d * r (oracle/libraries/FullMath.sol#27) - d /= pow2 (oracle/libraries/FullMath.sol#23) - r *= 2 - d * r (oracle/libraries/FullMath.sol#28) - d /= pow2 (oracle/libraries/FullMath.sol#23) - r *= 2 - d * r (oracle/libraries/FullMath.sol#29) - d /= pow2 (oracle/libraries/FullMath.sol#23) - r *= 2 - d * r (oracle/libraries/FullMath.sol#30) - d /= pow2 (oracle/libraries/FullMath.sol#23) - r *= 2 - d * r (oracle/libraries/FullMath.sol#31) - d /= pow2 (oracle/libraries/FullMath.sol#23) - r *= 2 - d * r (oracle/libraries/FullMath.sol#32) - d /= pow2 (oracle/libraries/FullMath.sol#23) - r *= 2 - d * r (oracle/libraries/FullMath.sol#33) - d /= pow2 (oracle/libraries/FullMath.sol#23) - r *= 2 - d * r (oracle/libraries/FullMath.sol#34) - l /= pow2 (oracle/libraries/FullMath.sol#24) - l * r (oracle/libraries/FullMath.sol#35) - x = xxRound_rpow_asm_0 / b (abaci.sol#159) - zx_rpow_asm_0 = z * x (abaci.sol#161) - x = xxRound_rpow_asm_0 / b (abaci.sol#249) - zx_rpow_asm_0 = z * x (abaci.sol#251) - rate = wad / timeline (jar.sol#141) - leftover = remaining * rate (jar.sol#144) - x = xxRound_rpow_asm_0 / b (hMath.sol#19) - zx_rpow_asm_0 = z * x (hMath.sol#21) Solidity's integer division truncates. Thus, performing division before multiplication can lead to precision loss.",
        "labels": [
            "SlowMist",
            "Helio Money",
            "Type: Arithmetic Accuracy Deviation Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Anyone can call initialize on the logic contract",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Helio Money_en-us.pdf",
        "body": "contracts/ceros/upgrades/CeVaultV2.sol 33,5: function initialize( contracts/ceros/upgrades/HelioProviderV2.sol 43,5: function initialize( contracts/ceros/CerosRouter.sol 41,5: function initialize( contracts/ceros/CeToken.sol 31,5: function initialize(string calldata _name, string calldata _symbol) contracts/ceros/CeVault.sol 33,5: function initialize( contracts/ceros/hBNB.sol 29,5: function initialize() external initializer { contracts/ceros/HelioProvider.sol 49,5: function initialize( contracts/masterVault/MasterVault.sol 82,5: function initialize( contracts/masterVault/WaitingPool.sol 28,5: function initialize(address _masterVault, uint256 _capLimit) external initializer { contracts/mediator/ElipsisMediator.sol 43,5: function initialize(address targetContract) public initializer { contracts/oracle/interfaces/IUniswapV2Pair.sol 96,3: function initialize(address, address) external; contracts/oracle/BnbOracle.sol 11,5: function initialize(address aggregatorAddress) external initializer { contracts/oracle/BusdOracle.sol 11,5: function initialize(address aggregatorAddress) external initializer { contracts/oracle/HelioOracle.sol 17,5: function initialize(uint256 initialPrice) public initializer { contracts/oracle/PriceOracle.sol 21,3: function initialize( contracts/oracle/PriceOracleTestnet.sol 30,3: function initialize( contracts/oracle/SlidingWindowOracle.sol 45,3: function initialize( contracts/strategy/BnbxYieldConverterStrategy.sol 46,5: function initialize( contracts/strategy/CerosYieldConverterStrategy.sol 27,5: function initialize( contracts/strategy/SnBnbYieldConverterStrategy.sol 45,5: function initialize( contracts/strategy/StkBnbStrategy.sol 58,5: function initialize( contracts/abaci.sol 52,5: function initialize() external initializer { 123,5: function initialize() external initializer { 214,5: function initialize() external initializer { contracts/clip.sol 127,5: function initialize(address vat_, address spotter_, address dog_, bytes32 ilk_) external initializer { contracts/dog.sol 103,5: function initialize(address vat_) external initializer { contracts/flash.sol 58,5: function initialize(address _vat, address _hay, address _hayJoin, address _vow) external initializer { contracts/hay.sol 59,5: function initialize(uint256 chainId_, string memory symbol_, uint256 supplyCap_) external initializer { contracts/HelioRewards.sol 65,5: function initialize(address vat_, uint256 poolLimit_ ) public initializer { contracts/HelioToken.sol 28,5: function initialize(uint256 rewardsSupply_, address rewards_) public initializer { contracts/Interaction.sol 80,5: function initialize( contracts/jar.sol 88,5: function initialize(string memory _name, string memory _symbol, address _hayToken, uint _spread, uint _exitDelay, uint _flashLoanDelay) external initializer { contracts/join.sol 89,5: function initialize(address vat_, bytes32 ilk_, address gem_) external initializer { 149,5: function initialize(address vat_, address hay_) external initializer { contracts/jug.sol 54,5: function initialize(address vat_) external initializer { contracts/lock.sol 64,5: function initialize() external initializer { contracts/spot.sol 56,5: function initialize(address vat_) external initializer { contracts/vat.sol 74,5: function initialize() public initializer { contracts/vow.sol 59,5: function initialize(address vat_, address _hayJoin, address multisig_) external initializer { Anyone can call initialize on the logic contract.",
        "labels": [
            "SlowMist",
            "Helio Money",
            "Type: Race Conditions Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "vaultToken burned may exceed the actual number needed",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Helio Money_en-us.pdf",
        "body": "contracts/masterVault/MasterVault.sol function withdrawETH(address account, uint256 amount) external override nonReentrant whenNotPaused onlyProvider returns (uint256 shares) { address src = msg.sender; ICertToken(vaultToken).burn(src, amount); uint256 ethBalance = totalAssetInVault(); shares = _assessFee(amount, withdrawalFee); if(ethBalance < shares) { payable(account).transfer(ethBalance); uint256 withdrawn = withdrawFromActiveStrategies(account, shares - ethBalance); shares = ethBalance + withdrawn; } else { payable(account).transfer(shares); } emit Withdraw(src, src, src, amount, shares); return amount; } When Strategy balance is not enough, the actual withdrawn amount return by withdrawFromActiveStrategies will lower than shares - ethBalance passed, it means the provider burn amount but do not get enough native token.",
        "labels": [
            "SlowMist",
            "Helio Money",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Missing check BnbOracle status",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Helio Money_en-us.pdf",
        "body": "contracts/oracle/BnbOracle.sol function peek() public view returns (bytes32, bool) { ( /*uint80 roundID*/, int price, /*uint startedAt*/, /*uint timeStamp*/, /*uint80 answeredInRound*/ ) = priceFeed.latestRoundData(); if (price < 0) { return (0, false); } return (bytes32(uint(price) * (10**10)), true); } In order to get a correct price, we need to check key values returned by priceFeed.",
        "labels": [
            "SlowMist",
            "Helio Money",
            "Type: Unsafe External Call Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Upgrading contracts may introduce new risks",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Helio Money_en-us.pdf",
        "body": "contracts/oracle/HelioOracle.sol contracts/oracle/PriceOracle.sol contracts/oracle/SlidingWindowOracle.sol The Proxy can upgrade the contract by calling upgradeTo/upgradeToAndCall , and upgrading the contract may introduce new risks.",
        "labels": [
            "SlowMist",
            "Helio Money",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "HelioOracle owner is never initialized",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Helio Money_en-us.pdf",
        "body": "contracts/oracle/HelioOracle.sol function changePriceToken(uint256 price_) external { require(msg.sender == _owner, \"HelioOracle/forbidden\"); price = price_; emit PriceChanged(price); } _owner is never initialized, changePriceToken call will fail in any condition.",
        "labels": [
            "SlowMist",
            "Helio Money",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "HelioOracle price oracle is not rigorous",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Helio Money_en-us.pdf",
        "body": "contracts/oracle/HelioOracle.sol function changePriceToken(uint256 price_) external { require(msg.sender == _owner, \"HelioOracle/forbidden\"); price = price_; emit PriceChanged(price); } This oracle price is too simple, there is not parameters for determining the validity of prices, such as timestamp.",
        "labels": [
            "SlowMist",
            "Helio Money",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Oracle price should not return 0",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Helio Money_en-us.pdf",
        "body": "contracts/HelioRewards.sol function helioPrice() public view returns(uint256) { // 1 HAY is helioPrice() helios (bytes32 price, bool has) = oracle.peek(); if (has) { return uint256(price); } else { return 0; } } contracts/Interaction.sol function collateralPrice(address token) public view returns (uint256) { CollateralType memory collateralType = collaterals[token]; _checkIsLive(collateralType.live); (PipLike pip,) = spotter.ilks(collateralType.ilk); (bytes32 price, bool has) = pip.peek(); if (has) { return uint256(price); } else { return 0; } } Price oracle should break the operation when peek an error, instead of return 0.",
        "labels": [
            "SlowMist",
            "Helio Money",
            "Type: Unsafe External Call Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "ERC777 reentrancy risks",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Helio Money_en-us.pdf",
        "body": "contracts/strategy/StkBnbStrategy.sol function _withdraw(address recipient, uint256 amount) internal returns (uint256) { //... stkBNB.send(address(stakePool), poolTokens, \"\"); // save it so that we can later dispatch the amount to the recipient on claim withdrawReqs[_endIndex++] = WithdrawRequest(recipient, value); // keep track of _netDeposits in StakePool _bnbDepositsInStakePool -= value; return value + ethBalance; } stkBNB is a ERC777 token , ERC777 tokens are vulnerable to reentrancy attacks due to a design aw.",
        "labels": [
            "SlowMist",
            "Helio Money",
            "Type: Reentrancy Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Missing events access control",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Helio Money_en-us.pdf",
        "body": "MasterVault._updateCerosStrategyDebt() MasterVault.withdrawFee() BnbxYieldConverterStrategy._deposit() BnbxYieldConverterStrategy._withdraw() BnbxYieldConverterStrategy._distributeFund() BnbxYieldConverterStrategy._harvestTo() CerosYieldConverterStrategy._deposit() CerosYieldConverterStrategy._withdraw() CerosYieldConverterStrategy._harvestTo() SnBnbYieldConverterStrategy._deposit() SnBnbYieldConverterStrategy.withdrawInToken() SnBnbYieldConverterStrategy._withdraw() SnBnbYieldConverterStrategy._distributeFund() SnBnbYieldConverterStrategy._harvestTo() StkBnbStrategy._deposit() StkBnbStrategy.withdrawInToken() StkBnbStrategy._withdraw() StkBnbStrategy.harvest()",
        "labels": [
            "SlowMist",
            "Helio Money",
            "Type: Malicious Event Log Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Reentry prevention best practices",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Helio Money_en-us.pdf",
        "body": "contracts/HelioRewards.sol function claim(uint256 amount) external { //... } contracts/Interaction.sol function deposit( address participant, address token, uint256 dink ) external whitelisted(participant) returns (uint256) { } function borrow(address token, uint256 hayAmount) external returns (uint256) { //... } function payback(address token, uint256 hayAmount) external returns (int256) { //... } Not apply check-eects-interactions pattern when making external calls in these functions.",
        "labels": [
            "SlowMist",
            "Helio Money",
            "Type: Reentrancy Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing check return value",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Helio Money_en-us.pdf",
        "body": "Code location: jug.drip(collateralType.ilk) (Interaction.sol#145) jug.drip(collateralType.ilk) (Interaction.sol#309) _deactivateStrategy(strategy)(contracts/masterVault/MasterVault.sol#315) _depositToStrategy(strategies[i], depositAmount) (contracts/masterVault/MasterVault.sol#342) Not verifying the return value may lead to logical errors.",
        "labels": [
            "SlowMist",
            "Helio Money",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - wBETH_en-us.pdf",
        "body": "1.In the UnwrapTokenV1 contract, the owner role can set the operatorAddress, the rechargeAddress, the ethBackAddress, the ethStaked address, and the lockTime. Wrong conguration and sudden modication will aect the user's normal withdrawal request and claim. ",
        "labels": [
            "SlowMist",
            "wBETH",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "call() should be used instead of transfer()",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - wBETH_en-us.pdf",
        "body": "The transfer() and send() functions forward a xed amount of 2300 gas. Historically, it has often been recommended to use these functions for value transfers to guard against reentrancy attacks. However, the gas cost of EVM instructions may change signicantly during hard forks which may break already deployed contract systems that make xed assumptions about gas costs. For example. EIP 1884 broke several existing smart contracts due to a cost increase in the SLOAD instruction. ",
        "labels": [
            "SlowMist",
            "wBETH",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Preemptive Initialization",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - wBETH_en-us.pdf",
        "body": "By calling the initialize and deploy functions to initialize the contracts, there is a potential issue that malicious attackers preemptively call the initialize function to initialize. ",
        "labels": [
            "SlowMist",
            "wBETH",
            "Type: Race Conditions Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Possible calculation truncation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - wBETH_en-us.pdf",
        "body": "In the RateLimit contract, the amountToReplenish is calculated by the division (secondsSinceAllowanceSet * maxAllowances[caller]) / intervals[caller]; . If the value of the numerator is less than intervals[caller], this division can truncate towards 0. Since the result of the division is returned by the _getReplenishAmount function and is used in the _replenishAllowance function to update the callers allowance, this truncation can lead to a failure in updating the callers allowance. ",
        "labels": [
            "SlowMist",
            "wBETH",
            "Type: Arithmetic Accuracy Deviation Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Multiple Solidity versions in use",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - wBETH_en-us.pdf",
        "body": "Throughout the code base there are dierent versions of Solidity being used. Token contracts are specically using version 0.6.12 while other contracts allow compiling with version 0.8.6.",
        "labels": [
            "SlowMist",
            "wBETH",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Dev address setting enhancement suggestions",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - wBETH_en-us.pdf",
        "body": "In the can set the StakedTokenV1 and StakedTokenV2 contracts, the owner role can set the ethReceiver address to move the eth. If the address is an EOA address, in a scenario where the private keys are leaked, the teams revenue will be stolen. ",
        "labels": [
            "SlowMist",
            "wBETH",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Inability to claim due to insucient availableAllocateAmount",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - wBETH_en-us.pdf",
        "body": "In the WrapTokenV2ETH and WrapTokenV2BSC contract, users can call the requestWithdrawEth function to burn their wbeth to withdraw their unwrap_ETH tokens. In this function, the withdraw operation is executed by the UnwrapTokenV1 requestWithdraw function. And in the requestWithdraw function, the _currentIndex value will be increased by the nextIndex++ self-increment. Once the availableAllocateAmount is less than the _ethAmount or the startAllocatedEthIndex is not equal to the currentIndex , the if judgment will pass to execute the else part only, and the startAllocatedEthIndex will not self-increment. This can lead to the allocation failing that users can not call the claimWithdraw function to withdraw their eth. Only in the UnwrapTokenV1 contract, the operator role can call the allocate function to allocate availableAllocateAmount of ethAmount to make the startAllocatedEthIndex++ self-increment to match the if judgment and the claimWithdraws allocated value will be set to true. ",
        "labels": [
            "SlowMist",
            "wBETH",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Potential error in the calculation of the withdrawal amount",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist_Audit_Report_StakeStone_NativeLendingETHStrategy&Symbi_en-us.pdf",
        "body": "In the NativeLendingETHStrategy contract, the owner role can call the withdrawFromNativeByAmount function and the withdrawFromNativeByShare function to redeem the AquaLpToken for ETH. The nal calculated withdrawal amount is simply the dierence between the current ETH balance of the contract and the ETH balance before the redemption operation. However, the redemption operation rst converts the AquaLpToken back to WETH tokens, and then uses the WETH tokens to obtain ETH. If there are surplus WETH tokens in the contract before the redemption (for example, if other users have mistakenly transferred them in), then this excess WETH amount will also be included in the calculated withdrawal amount. Code Location: contracts/strategies/NativeLendingETHStrategy.sol#L44-66 function withdrawFromNativeByAmount( uint256 _amount ) external onlyOwner returns (uint256 withdrawAmount) { uint256 beforeBalance = address(this).balance; IAquaLpToken(LPTOKEN).redeemUnderlying(_amount); WETH.withdraw(WETH.balanceOf(address(this))); withdrawAmount = address(this).balance - beforeBalance; } function withdrawFromNativeByShare( uint256 _share ) external onlyOwner returns (uint256 withdrawAmount) { uint256 beforeBalance = address(this).balance; IAquaLpToken(LPTOKEN).redeem(_share); WETH.withdraw(WETH.balanceOf(address(this))); withdrawAmount = address(this).balance - beforeBalance; }",
        "labels": [
            "SlowMist",
            "SlowMist_Audit_Report_StakeStone_NativeLendingETHStrategy&Symbi",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Missing event records",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist_Audit_Report_StakeStone_NativeLendingETHStrategy&Symbi_en-us.pdf",
        "body": "In the NativeLendingETHStrategy contract, the owner role can use the ETH in the contract to mint AquaLpToken, and then use the AquaLpToken to redeem for ETH, but there is no event record. Code Location: contracts/strategies/NativeLendingETHStrategy.sol#L28-66 function depositIntoNative( uint256 _amount ) external onlyOwner returns (uint256 mintAmount) { ... } function withdrawFromNativeByAmount( uint256 _amount ) external onlyOwner returns (uint256 withdrawAmount) { ... } function withdrawFromNativeByShare( uint256 _share ) external onlyOwner returns (uint256 withdrawAmount) { ... }",
        "labels": [
            "SlowMist",
            "SlowMist_Audit_Report_StakeStone_NativeLendingETHStrategy&Symbi",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing zero value check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist_Audit_Report_StakeStone_NativeLendingETHStrategy&Symbi_en-us.pdf",
        "body": "In the NativeLendingETHStrategy contract, The owner role does not check whether the input amount for minting and redeeming AquaLpToken tokens is 0 or not. If the input value is 0, the operation can still be executed successfully, but it will consume gas. Code Location: contracts/strategies/NativeLendingETHStrategy.sol#L28-66 function depositIntoNative( uint256 _amount ) external onlyOwner returns (uint256 mintAmount) { ... } function withdrawFromNativeByAmount( uint256 _amount ) external onlyOwner returns (uint256 withdrawAmount) { ... } function withdrawFromNativeByShare( uint256 _share ) external onlyOwner returns (uint256 withdrawAmount) { ... }",
        "labels": [
            "SlowMist",
            "SlowMist_Audit_Report_StakeStone_NativeLendingETHStrategy&Symbi",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Lack of external interest rate ination vulnerability check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist_Audit_Report_StakeStone_NativeLendingETHStrategy&Symbi_en-us.pdf",
        "body": "In the NativeLendingETHStrategy and SymbioticDepositWstETHStrategy contracts, the owner role can separately call the depositIntoNative function and the depositIntoSymbiotic function to deposit the funds in the strategy contract into a third-party protocol, and mint the corresponding deposit certicates. However, the functions do not check whether the minted deposit shares are zero in quantity. Since the code of the third-party protocol is not within the scope of this audit, if there is an interest rate ination vulnerability in the code of the third-party protocol, the funds in the contract may be damaged due to malicious users front-running. For details on the interest rate ination vulnerability, please refer to the following link: https://blog.openzeppelin.com/a-novel-defense-against-erc4626-ination-attacks Code Location: contracts/strategies/NativeLendingETHStrategy.sol#L28-42 function depositIntoNative( uint256 _amount ) external onlyOwner returns (uint256 mintAmount) { ... IAquaLpToken(LPTOKEN).mint(_amount); mintAmount = IAquaLpToken(LPTOKEN).balanceOf(address(this)) - beforeLPBalance; } contracts/strategies/SymbioticDepositWstETHStrategy.sol#L151-169 function depositIntoSymbiotic( uint256 _wstETHAmount ) external onlyOwner returns (uint256 shares) { ... shares = ICollateral(collateralAddr).deposit( address(this), _wstETHAmount ); emit DepositIntoSymbiotic( collateralAddr, address(this), _wstETHAmount, shares ); }",
        "labels": [
            "SlowMist",
            "SlowMist_Audit_Report_StakeStone_NativeLendingETHStrategy&Symbi",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Potentially unclaimed rewards",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the SingleTokenStaking contract, the calculation of staking rewards mainly depends on the rewardSpeed variable. The contract calculates the global reward accumulation accuedReward based on rewardSpeed and the block interval. When a user settles rewards, the dierence between the current global accuedReward and the user's last settled accuedReward is multiplied by the user's deposit amount to determine the user's claimable rewards. It is important to note that the contract does not limit users' minimum deposit amount. This means that when a user deposits an extremely small amount and rewardSpeed is set relatively low (for example, if the user deposits 1 wei and rewardSpeed is less than 1e18), the user's small rewards may be truncated due to decimal rounding during the reward settlement process. This may result in the user's rewards being left unclaimed in the contract. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Arithmetic Accuracy Deviation Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Optimizable refreshGlobalState",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the SingleTokenStaking contract, the refreshGlobalState function is used to update the global reward state accuedReward and update the accumulated rewards and the current block to the corresponding global variables. It is important to note that there may be a large number of users performing operations such as depositing, withdrawing, and claiming rewards within the same block, which will result in frequent calls to the refreshGlobalState function. This means that although accuedReward will not be accumulated within the same block, users still need to pay some gas to update gDeposits.accuedReward and gDeposits.accuedBlock , which is unnecessary within the same block. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Compatibility issues with deationary tokens",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the SingleTokenStaking contract, users can deposit supported tokens into the contract using the deposit function, and the addDeposit function directly records the amount of deposit tokens passed in by the user. If the token supported by the contract is deationary, the contract will actually receive fewer tokens than the deposit amount passed in by the user. This will cause the contract to record a higher user deposit than the actual amount of tokens received. When the user withdraws, it will result in a bad debt for the protocol. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Optimizable RFG token distribution method",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the RFGToken contract, the token distribution rules are hardcoded. 30% of the token supply will be allocated to liquidity, 10% will be allocated to airdrops, and the remaining tokens will be minted by the minter role. The contract uses three separate functions to mint tokens for these three dierent allocation purposes. However, it should be noted that in the claimAirdrop and claimLiquidity functions, although the tokens are minted for airdrop and liquidity purposes, the receiving addresses are not specied. The owner role can mint these tokens to any address. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Admin who has not set the Boss role",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "During the initialization of the Auction contract, the specied boss address is granted the BossRole. However, it should be noted that the BossRole is not assigned the AdminRole. This means that if the boss address experiences issues such as private key leakage, the protocol will not be able to handle the boss address through revokeRole/grantRole . ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Not checking the reasonableness of time when updating auctions",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the Auction contract, the admin role can update existing auction congurations through the updateAuction function. When updating, it checks whether the new startPrice is greater than 0, but it does not check whether the new endTime is greater than startTime. It should be noted that the admin can update an auction that has already ended to reopen it. This means that users who have already placed bids or claimed items can participate in the auction again. However, this will cause the restarted auction to conict with the previous claim/refund data. For example, if a user who successfully claimed an NFT in the previous auction wins the auction again, they will not be able to claim the new NFT successfully a second time. This does not align with the expected design. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Smart contracts cannot participate in the auction",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the Auction contract, users can participate in the auction through the bidAuction function. However, the function checks whether msg.sender is equal to tx.origin , which prevents smart contracts (including EIP4337 wallets) from participating in the auction. It should be noted that in the future, if the EIP3074 standard is approved, it may break this check. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Design Logic Audit",
            "Severity: Information"
        ]
    },
    {
        "title": "Time check when closing auction is awed",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the Auction contract, the operator can end the auction through the nishAuction function after the endTime. When performing the nishAuction operation, the endTime is checked using block.timestamp >= auction.endTime , while when performing the bidAuction operation, the endTime is checked using block.timestamp <= auction.endTime . This means that when the operator performs the nishAuction operation to set result.price exactly at the endTime, users can still perform the bidAuction operation to participate in the auction. This may not align with the intended design. It may also cause confusion for users, as they can place a bid higher than result.price at the endTime but are not included in the nal Merkle tree. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Not checking if the user's bid is as expected",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the Auction contract, users who successfully win the auction can obtain the NFT through the claimNft function. The operator sets the Merkle proof to verify the validity of the claiming user. When the user's bid price is higher than auctionResult.price , the contract processes a refund for them. However, the contract does not check whether the user's bid price is necessarily greater than or equal to auctionResult.price . If the Merkle tree erroneously includes users with bid prices lower than auctionResult.price , it may result in insucient funds in the contract for the boss role to withdraw. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Not checking if the user's bid is refundable",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the Auction contract, users who meet the refund conditions can use the operator's signature to request a refund. Theoretically, if a user is eligible to claim the NFT, the operator will not sign for them to avoid giving up their eligibility for a refund. However, the refund function does not strictly check whether the bid prices of all refunding users are less than auctionResult.price . If the operator erroneously signs a refund for a user who is eligible to claim the NFT, it will prevent the boss from withdrawing the remaining auction proceeds. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Risk of pseudo-randomness",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the Auction contract, when a user claims an NFT, the fakeRandomToken function is used to calculate the tokenId for the user. The fakeRandomToken function uses block.prevrandao , block.number , and the user-provided seed for calculation. Unfortunately, these parameters can be controlled or are already known. This allows malicious users to ensure that the tokenIds of the NFTs they obtain at specic blocks are all of high value. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Block data Dependence Vulnerability",
            "Severity: Critical"
        ]
    },
    {
        "title": "Redundant return value of adjustRandomtoken function",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the Auction contract, the adjustRandomtoken function is used to select a matching id for the user based on the current tokenId inventory. When all the inventory has been claimed, the function directly throws an error using require(false) . This makes the nal return 0 redundant because the function will never execute this return statement. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "The tokenId obtained by the user is related to the NFT inventory",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the Auction contract, the adjustRandomtoken function is used to adjust the nal tokenId based on the inventory of each tokenId's NFTs. If a user obtains the highest-value NFT but there is no inventory for this NFT, they may be assigned the lowest-value NFT instead, and vice versa. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Design Logic Audit",
            "Severity: Information"
        ]
    },
    {
        "title": "Unchecked boost bound parameters during initialization",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the initialize function of the RFGDeposit contract, when the proxy contract is initialized, parameters such as lowerBound and upperBound are passed in. However, the function does not check whether the passed-in lowerBound is less than upperBound. Incorrectly passing the corresponding values may cause the protocol to be unusable. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Rewards not settled as expected",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the RFGDeposit contract, users can make xed-term deposits through the xedDeposit function. When a user's autoRedeposit status is false, even if the user's deposit time is several times longer than the duration, only one cycle of rewards will be settled for the user. Unfortunately, the xedDeposit function does not handle the case where autoRedeposit is false. This allows users with autoRedeposit set to false to make a small deposit to the same xId after a long deposit period and still receive the full rewards, not just for one duration. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Incorrect whitelist pool check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the Pool contract, the assertCallerIsPool function is used to check whether the passed-in sender is a pool created in the stakingManager. The assertCallerIsPool function receives the msg.sender from SinglePool and CouplePool as a possible pool address, calls the poolID interface of msg.sender to obtain the pool id, and nally checks whether this pool id is valid in the stakingManager. Unfortunately, this check method is not eective. Malicious contracts can also implement the poolID interface and return a valid pool id (1~7) when called. Since the assertCallerIsPool function only checks whether the id is valid through the stakingManager contract, malicious contracts can easily bypass this check to perform malicious custodial staking and eventually exhaust the protocol's assets. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Unsafe External Call Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Unexpected rewards when staking in pairs",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the CouplePool contract, the stakingManager can stake a user's NFT through the socialStake function. When the staking has not been paired yet, CouplePool will custody the user's NFT to SinglePool to obtain SinglePool staking rewards. Once the pairing is complete, it will withdraw from SinglePool and stake in CouplePool. Theoretically, during the process of pairing, users should only receive rewards from SinglePool and not from CouplePool. Unfortunately, when SinglePool custody is performed, the user's ssInfo.stakeInfo.amount value in the CouplePool contract will be updated to the staked amount. This allows users to claim CouplePool staking rewards through the claimSocialReward function of the stakingManager contract even before the pairing is completed. Worse still, the user's ssInfo.stakeInfo.claimedToAccued has not been set at this point, so when settling rewards, calculateStakeReward will distribute large unexpected rewards to the user. Malicious users can exploit this issue to exhaust all reward tokens. Similarly, this issue also exists in the GroupPool contract. Users can still claim large rewards from GroupPool even before the three-party pairing is completed. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Manipulate boost to inuence the token id obtained in the auction",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the Auction contract, when a user claims the auctioned NFT, the token id of the NFT depends not only on the random number seed but also on the amount of the user's deposit in the RFGDeposit contract. The larger the user's deposit amount, the greater the user's boost, and the higher the probability of obtaining a high-value NFT. Unfortunately, the calculation of the boost only depends on the user's deposit amount. Users can increase their RFG deposit before claiming the NFT to improve the probability. When multiple addresses of a user have obtained NFTs, they only need to withdraw the staked RFG tokens from other addresses and transfer them to the address that needs to claim the NFT for staking before claiming the NFT, in order to increase the probability. In other words, users only need a high amount of staking and can continuously stake/unstake/transfer RFG tokens to increase the probability of obtaining high-value NFTs at a lower cost. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Redundant PoolMax enum",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the NftID library, PoolID lists an enumeration of all the pools supported by the protocol, but PoolMax is not used anywhere in the protocol, which is redundant. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Reward calculation for two stakers in GroupPool being the same user",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the GroupPool contract, when a user performs a socialUnstake/forceSocialUnstake operation, a portion of the bailed rewards of the initiator of the unstaking operation will be deducted and distributed to other users in the same group. However, it should be noted that one of the users in the same group may also be the initiator because the protocol allows the same user to provide two dierent NFTs for GroupPool staking. This means that a portion of the initiator's penalized rewards still belong to the initiator themselves. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Design Logic Audit",
            "Severity: Information"
        ]
    },
    {
        "title": "Potentially incorrect social staking reward information in GroupPool",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "As previously mentioned, GroupPool allows the same user to provide two NFTs for staking. However, during reward settlement, stakerShareReward and bailed are calculated based on three dierent staking users. Therefore, in the viewSocialStakeRewardInfo function, when obtaining the user's pendingRewards, it only considers the scenario where the three stakers are dierent users, while overlooking the possibility that two of the stakers might be the same user. This may cause the reward amount returned by the viewSocialStakeRewardInfo function to be lower than expected. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Potential Denial of Service Risk",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In Pool, users can freely choose dierent pools for staking. Theoretically, users can stake their owned NFTs in pools of dierent types or in dierent matchCodes within the same pool. The pool uses OpenZeppelin's EnumerableSet library to record the pools or matchCodes that users have joined, and retrieves all the pools or matchCodes joined by users through the values interface of EnumerableSet when claiming rewards. It is important to note that the values operation copies the entire storage space to memory. If the user participates in a large number of pools or matchCodes, the values operation will generate signicant gas costs, potentially exceeding the block's gasLimit and ultimately leading to DoS risks. Despite this, if a DoS issue arises, users can still avoid their rewards being locked by claiming rewards individually. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Denial of Service Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "The validity of the pid was not checked when creating the pool",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the StakingManager contract, operators can create pools using the createPool function, but the validity of the passed-in pid value is not checked. Theoretically, the pid of a pool should only be between 1 and 7. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "When creating a matchCode, it does not check whether the pool has been created.",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the StakingManager contract, users can create matchCodes for social staking using the createMatch2Code and createMatch3Code functions. However, when creating a matchCode, there is no check to verify if the pool corresponding to the pid has already been created. If the pool has not been created, users will be unable to successfully create a matchCode, and no error message will be thrown, which may cause confusion for users. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "There is an upper limit on the matchCodes available in the pool",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the StakingManager contract, when a user creates a matchCode for social staking, the protocol assigns a matchCode to this staking. The matchCode is obtained through the nextMatchCode function of the pool, which is calculated using poolID * 10 ** 8 + matchCodeNonce . It is important to note that if the value of matchCodeNonce exceeds 1e8, it will aect the matchCode of the next pool. In reality, it is highly unlikely for a pool to have 1e8 matchCodes, but the project team should still remain attentive to this matter. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Checks-Eects-Interactions are not followed when transferring out NFT",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the StakingManager contract, the returnNftsBackAndClaimReward function is used to transfer users' staked NFTs from the contract back to the users and claim social staking rewards for users through the claimSocialReward function. The practice of transferring assets before modifying the contract state does not comply with the Checks- Eects-Interactions pattern. Although it does not lead to reentrancy risks in the current business scenario, it cannot be guaranteed that new exploitable business scenarios will not be introduced in the future. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Optimizable reward information update",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the updateRewardInfo function of the GroupPool contract, the currently claimable social staking rewards are calculated through the calculateStakeReward function, and the rewards are distributed to the stakers. It is important to note that when users exit staking through the StakingManager contract, multiple calls to the updateRewardInfo function may be involved in a single transaction. The pendingReward for reward settlement is only greater than 0 during the rst call, and when pendingReward is 0, the updateRewardInfo function still performs reward distribution operations, which will consume a lot of unnecessary gas. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risks of excessive privilege",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the StakingManager contract, the admin role can upgrade any pool through the upgradePool function. Moreover, in the protocol, except for the InviteReward, Airdrop, RFGToken, and NftCard contracts, all other contracts use an upgradable model, where the admin of the proxy contract can arbitrarily upgrade these contracts. This leads to the risk of excessive privileges. In the Auction contract, after the auction is completed, the project team will calculate o-chain the users who can obtain NFTs and the nal auction price, and establish a Merkle proof for users to claim. This also increases the centralization risk to a certain extent. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Protocol Missing Emergency Operations Role",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "The protocol has planned for multiple roles to manage dierent contracts, but it is important to note that the protocol lacks an emergency pause functionality and a role to manage this function. When an emergency occurs in the protocol, the emergency operation role can close the protocol through the pause function to minimize losses as much as possible.",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing event records",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the NftCard contract, the owner can modify the URI of the NFT through the setUri function, but no event is recorded. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "4.2.1.1 Sandwich attacks issues",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - autofarm_en-us.pdf",
        "body": "The earn(), buyBack(), convertDustToEarned(), _convertMDXToEarned functions no limit slippage, there is a sandwich attacks issues. It is recommended to add a slippage limit, and the slippage parameter can only be modified by the Owner.  AutofarmV2_CrossChain/StratVLEV2.sol function earn() external whenNotPaused { if (onlyGov) { require(msg.sender == govAddress, \"!gov\"); } 6 IVenusDistribution(venusDistributionAddress).claimVenus(address(this)); uint256 earnedAmt = IERC20(venusAddress).balanceOf(address(this)); earnedAmt = distributeFees(earnedAmt); earnedAmt = buyBack(earnedAmt); if (venusAddress != wantAddress) { IPancakeRouter02(uniRouterAddress).swapExactTokensForTokens( earnedAmt, 0, venusToWantPath, address(this), now.add(600) ); } lastEarnBlock = block.number; _farm(false); //SupplywantTokenwithoutleverage,tocaterfornet-veinterestrates. }  AutofarmV2_CrossChain/StratVLEV2.sol function buyBack(uint256 _earnedAmt) internal returns (uint256) { if (buyBackRate <= 0) { return _earnedAmt; } uint256 buyBackAmt = _earnedAmt.mul(buyBackRate).div(buyBackRateMax); IPancakeRouter02(uniRouterAddress).swapExactTokensForTokens( buyBackAmt, 0, earnedToAUTOPath, buyBackAddress, now + 600 ); return _earnedAmt.sub(buyBackAmt); 7 }  AutofarmV2_CrossChain/StratX2_MDEX.sol function convertDustToEarned() public whenNotPaused { require(isAutoComp, \"!isAutoComp\"); require(!isCAKEStaking, \"isCAKEStaking\"); //Convertsdusttokensintoearnedtokens,whichwillbereinvestedonthenextearn(). //Convertstoken0dust(ifany)toearnedtokens uint256 token0Amt = IERC20(token0Address).balanceOf(address(this)); if (token0Address != earnedAddress && token0Amt > 0) { IERC20(token0Address).safeIncreaseAllowance( uniRouterAddress, token0Amt ); //Swapalldusttokenstoearnedtokens IPancakeRouter02(uniRouterAddress) .swapExactTokensForTokensSupportingFeeOnTransferTokens( token0Amt, 0, token0ToEarnedPath, address(this), now + 600 ); } //Convertstoken1dust(ifany)toearnedtokens uint256 token1Amt = IERC20(token1Address).balanceOf(address(this)); if (token1Address != earnedAddress && token1Amt > 0) { IERC20(token1Address).safeIncreaseAllowance( uniRouterAddress, token1Amt ); //Swapalldusttokenstoearnedtokens IPancakeRouter02(uniRouterAddress) .swapExactTokensForTokensSupportingFeeOnTransferTokens( 8 token1Amt, 0, token1ToEarnedPath, address(this), now + 600 ); } }  AutofarmV2_CrossChain/StratX2_MDEX.sol function _convertMDXToEarned() internal { //ConvertsMDX(ifany)toearnedtokens uint256 MDXAmt = IERC20(MDXAddress).balanceOf(address(this)); if (MDXAddress != earnedAddress && MDXAmt > 0) { IERC20(MDXAddress).safeIncreaseAllowance(uniRouterAddress, MDXAmt); //Swapalldusttokenstoearnedtokens IPancakeRouter02(uniRouterAddress) .swapExactTokensForTokensSupportingFeeOnTransferTokens( MDXAmt, 0, MDXToEarnedPath, address(this), now + 60 ); } }  AutofarmV2_CrossChain/StratX2_MDEX.sol function buyBack(uint256 _earnedAmt) internal returns (uint256) { if (buyBackRate <= 0) { return _earnedAmt; } uint256 buyBackAmt = _earnedAmt.mul(buyBackRate).div(buyBackRateMax); if (earnedAddress == AUTOAddress) { IERC20(earnedAddress).safeTransfer(buyBackAddress, buyBackAmt); } else { IERC20(earnedAddress).safeIncreaseAllowance( uniRouterAddress, 9 buyBackAmt ); IPancakeRouter02(uniRouterAddress) .swapExactTokensForTokensSupportingFeeOnTransferTokens( buyBackAmt, 0, earnedToAUTOPath, buyBackAddress, now + 600 ); } return _earnedAmt.sub(buyBackAmt); }  AutofarmV2_CrossChain/StratVLEV2.sol function earn() external whenNotPaused { if (onlyGov) { require(msg.sender == govAddress, \"!gov\"); } IVenusDistribution(venusDistributionAddress).claimVenus(address(this)); uint256 earnedAmt = IERC20(venusAddress).balanceOf(address(this)); earnedAmt = distributeFees(earnedAmt); earnedAmt = buyBack(earnedAmt); if (venusAddress != wantAddress) { IPancakeRouter02(uniRouterAddress).swapExactTokensForTokens( earnedAmt, 0, venusToWantPath, address(this), now.add(600) ); } lastEarnBlock = block.number; 10 _farm(false); //SupplywantTokenwithoutleverage,tocaterfornet-veinterestrates. } Fix Status: The issue has been fixed in this commit: b27f2cafcf51667726bd70220420707c89b75975",
        "labels": [
            "SlowMist",
            "autofarm",
            "Severity: High"
        ]
    },
    {
        "title": "4.2.2.1 Excessive authority issues",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - autofarm_en-us.pdf",
        "body": "The add function has excessive authority issues, Owner can add mining pool arbitrarily, there is a risk of stealing mining by himself, and _strat is the destination address of the final sending of funds, the owner can set this address arbitrarily, pay attention to compatibility issues with external contracts, it is recommended to set the ownership to the timelock contract, and add events to record in the add function.  AutofarmV2_CrossChain/AutoFarmV2_CrossChain.sol function add( uint256 _allocPoint, IERC20 _want, bool _withUpdate, address _strat ) public onlyOwner { if (_withUpdate) { massUpdatePools(); } totalAllocPoint = totalAllocPoint.add(_allocPoint); poolInfo.push( PoolInfo({ want: _want, allocPoint: _allocPoint, lastRewardBlock: 0, accAUTOPerShare: 0, 11 strat: _strat }) ); } Fix Status: The ownership has been transfer to timelock contract. Reference https://hecoinfo.com/tx/0xbe90b5dba8315b30a010ea957e9631154857b93d84cdb344c11b339b 5f3e5421 The authority of the Gov role is large, and the address of the external contract can be set arbitrarily. Malicious and wrong external contracts will cause the user's funds to be lost, and there is a issues of excessive authorityit is recommended to set the gov to the timelock contract.  AutofarmV2_CrossChain/StratX2.sol function setEntranceFeeFactor(uint256 _entranceFeeFactor) public { require(msg.sender == govAddress, \"!gov\"); require(_entranceFeeFactor >= entranceFeeFactorLL, \"!safe - too low\"); require(_entranceFeeFactor <= entranceFeeFactorMax, \"!safe - too high\"); entranceFeeFactor = _entranceFeeFactor; } function setWithdrawFeeFactor(uint256 _withdrawFeeFactor) public { require(msg.sender == govAddress, \"!gov\"); require(_withdrawFeeFactor >= withdrawFeeFactorLL, \"!safe - too low\"); require(_withdrawFeeFactor <= withdrawFeeFactorMax, \"!safe - too high\"); withdrawFeeFactor = _withdrawFeeFactor; } function setControllerFee(uint256 _controllerFee) public { require(msg.sender == govAddress, \"!gov\"); require(_controllerFee <= controllerFeeUL, \"too high\"); controllerFee = _controllerFee; } function setbuyBackRate(uint256 _buyBackRate) public { require(msg.sender == govAddress, \"!gov\"); 12 require(buyBackRate <= buyBackRateUL, \"too high\"); buyBackRate = _buyBackRate; } function setGov(address _govAddress) public { require(msg.sender == govAddress, \"!gov\"); govAddress = _govAddress; } function setOnlyGov(bool _onlyGov) public { require(msg.sender == govAddress, \"!gov\"); onlyGov = _onlyGov; } function setUniRouterAddress(address _uniRouterAddress) public { require(msg.sender == govAddress, \"!gov\"); uniRouterAddress = _uniRouterAddress; } function setBuyBackAddress(address _buyBackAddress) public { require(msg.sender == govAddress, \"!gov\"); buyBackAddress = _buyBackAddress; } function setRewardsAddress(address _rewardsAddress) public { require(msg.sender == govAddress, \"!gov\"); rewardsAddress = _rewardsAddress; } Fix Status: The Gov has been transfer to timelock contract. Reference https://hecoinfo.com/tx/0xfdf183915b5659473f9e8e3438c295cb859e022faa073a0a8f12c38e0a 4c257d",
        "labels": [
            "SlowMist",
            "autofarm",
            "Severity: Medium"
        ]
    },
    {
        "title": "4.2.2.2 DoS issues",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - autofarm_en-us.pdf",
        "body": "In the massUpdatePools function, if the length of poolInfo is too large, there is a risk of DoS. It is 13 recommended to limit poolInfo.length to avoid DoS caused by too large length.  AutofarmV2_CrossChain/AutoFarmV2_CrossChain.sol function massUpdatePools() public { uint256 length = poolInfo.length; for (uint256 pid = 0; pid < length; ++pid) { updatePool(pid); } } Fix Status: The issue has been fixed in this commit: b27f2cafcf51667726bd70220420707c89b75975",
        "labels": [
            "SlowMist",
            "autofarm",
            "Severity: Medium"
        ]
    },
    {
        "title": "4.2.3.1 Missing event log",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - autofarm_en-us.pdf",
        "body": "\"setEntranceFeeFactor\" function, \"setWithdrawFeeFactor\" function, \"setControllerFee\" function, \"setbuyBackRate\" function, \"setGov\" function, \"setOnlyGov\" function, \"setUniRouterAddress\" function, \"setBuyBackAddress\" function, \"setRewardsAddress\" function, no events are added to record. It is recommended to add events for recording.  AutofarmV2_CrossChain/StratX2_MDEX.sol  AutofarmV2_CrossChain/StratVLEV2.sol function setEntranceFeeFactor(uint256 _entranceFeeFactor) public { require(msg.sender == govAddress, \"!gov\"); require(_entranceFeeFactor >= entranceFeeFactorLL, \"!safe - too low\"); require(_entranceFeeFactor <= entranceFeeFactorMax, \"!safe - too high\"); entranceFeeFactor = _entranceFeeFactor; } function setWithdrawFeeFactor(uint256 _withdrawFeeFactor) public { require(msg.sender == govAddress, \"!gov\"); require(_withdrawFeeFactor >= withdrawFeeFactorLL, \"!safe - too low\"); 14 require(_withdrawFeeFactor <= withdrawFeeFactorMax, \"!safe - too high\"); withdrawFeeFactor = _withdrawFeeFactor; } function setControllerFee(uint256 _controllerFee) public { require(msg.sender == govAddress, \"!gov\"); require(_controllerFee <= controllerFeeUL, \"too high\"); controllerFee = _controllerFee; } function setbuyBackRate(uint256 _buyBackRate) public { require(msg.sender == govAddress, \"!gov\"); require(buyBackRate <= buyBackRateUL, \"too high\"); buyBackRate = _buyBackRate; } function setGov(address _govAddress) public { require(msg.sender == govAddress, \"!gov\"); govAddress = _govAddress; } function setOnlyGov(bool _onlyGov) public { require(msg.sender == govAddress, \"!gov\"); onlyGov = _onlyGov; } function setUniRouterAddress(address _uniRouterAddress) public { require(msg.sender == govAddress, \"!gov\"); uniRouterAddress = _uniRouterAddress; } function setBuyBackAddress(address _buyBackAddress) public { require(msg.sender == govAddress, \"!gov\"); buyBackAddress = _buyBackAddress; } function setRewardsAddress(address _rewardsAddress) public { require(msg.sender == govAddress, \"!gov\"); rewardsAddress = _rewardsAddress; } Fix Status: 15 The issue has been fixed in this commit: b27f2cafcf51667726bd70220420707c89b75975",
        "labels": [
            "SlowMist",
            "autofarm",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.2.3.2 Missing nonReentrant modifier",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - autofarm_en-us.pdf",
        "body": "The deposit function missing the nonReentrant modifier, it is recommended to add the nonReentrant modifier.  AutofarmV2_CrossChain/StratX2_MDEX.sol function deposit(address _userAddress, uint256 _wantAmt) public onlyOwner whenNotPaused returns (uint256) IERC20(wantAddress).safeTransferFrom( address(msg.sender), address(this), _wantAmt ); uint256 sharesAdded = _wantAmt; if (wantLockedTotal > 0 && sharesTotal > 0) { sharesAdded = _wantAmt .mul(sharesTotal) .mul(entranceFeeFactor) .div(wantLockedTotal) .div(entranceFeeFactorMax); } sharesTotal = sharesTotal.add(sharesAdded); if (isAutoComp) { _farm(); } else { wantLockedTotal = wantLockedTotal.add(_wantAmt); } return sharesAdded; 16 { } Fix Status: The issue has been fixed in this commit: b27f2cafcf51667726bd70220420707c89b75975 5.",
        "labels": [
            "SlowMist",
            "autofarm",
            "Severity: Informational"
        ]
    },
    {
        "title": "Overow issues",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - WombatExchange_en-us.pdf",
        "body": "The data type of priceStruct.expo is int32, and the return result is negative, so uint256(int256(priceStruct.expo)) will get a large value, and 10 ** uint256(int256(priceStruct.expo) will overflow. Because the compiler version used is pragma solidity ^0.8.5;`. ",
        "labels": [
            "SlowMist",
            "WombatExchange",
            "Type: Integer Overow and Underow Vulnerability",
            "Severity: Critical"
        ]
    },
    {
        "title": "Missing event record",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - WombatExchange_en-us.pdf",
        "body": "The owner has the ability to modify the values of the maxPriceAge, shouldCapEquilCovRatio, startCovRatio, endCovRatio parameters, etc. which are global variables, but any modications made to them are not recorded with events. ",
        "labels": [
            "SlowMist",
            "WombatExchange",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Excessive authority issues",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - WombatExchange_en-us.pdf",
        "body": "The Owner can modify priceIDs[_token], priceFeed, fallbackPriceFeed. This will aect the price at which the project gets oracle. The wrong price will lead to a fatal vulnerability in the project. ",
        "labels": [
            "SlowMist",
            "WombatExchange",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Redundant judgment",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - WombatExchange_en-us.pdf",
        "body": "If fromAmount is 0, the code will revert, so if (fromAmount >= 0) should be changed to if (fromAmount > 0). ",
        "labels": [
            "SlowMist",
            "WombatExchange",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "fee management suggestions",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - WombatExchange_en-us.pdf",
        "body": "If the receiving address of fee is an EOA address, there will be a single point risk of private key management. ",
        "labels": [
            "SlowMist",
            "WombatExchange",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "conditional competition issues",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - WombatExchange_en-us.pdf",
        "body": "The llPool function and the transferTipBucket function are controlled by the two roles of dev and owner respectively. When the opinions of the dev and owner are inconsistent, there will be conditional competition issues. ",
        "labels": [
            "SlowMist",
            "WombatExchange",
            "Type: Race Conditions Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Suggestions for variable type conversion",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - WombatExchange_en-us.pdf",
        "body": "The following functions when using uint256 to convert int256, it is not judged whether the variable to be converted is less than type(int256).max, and when using int256 to convert uint256, it is not judged whether the variable is greater than 0. CoreV3.quoteDepositLiquidity CoreV3.quoteWithdrawAmount CoreV3.quoteWithdrawAmountFromOtherAsset CoreV3.quoteSwap CoreV3.quoteSwapTokensForCredit CoreV3.quoteSwapCreditForTokens PoolV3._globalInvariantFunc PoolV3.globalEquilCovRatioWithCredit DynamicPoolV3._globalInvariantFunc PythPriceFeed.getLatestPrice",
        "labels": [
            "SlowMist",
            "WombatExchange",
            "Type: Others",
            "Severity: Low"
        ]
    },
    {
        "title": "Business logic is unclear",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - WombatExchange_en-us.pdf",
        "body": "The _quoteFactor function returns a xed value of 1e18, but the function receives parameters, and the parameters do not need to be used. ",
        "labels": [
            "SlowMist",
            "WombatExchange",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Token compatibility issues",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - WombatExchange_en-us.pdf",
        "body": "When the project is transferred to the token, it does not judge the balance change before and after the transfer of the target address receiving the token, so it is incompatible with reective tokens (deation/ination type tokens), which will cause the balance of the transfer to be inconsistent with the balance actually received, which will lead to calculation errors. ",
        "labels": [
            "SlowMist",
            "WombatExchange",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Redundant type conversion code",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - WombatExchange_en-us.pdf",
        "body": "The _quoteFrom function is using uint256 nalToAssetCovRatio = (toAssetCash + uint256(actualToAmount)).wdiv(toAssetLiability); to convert uint256(actualToAmount), But actualToAmount is of the type uint256, it is no need to convert. ",
        "labels": [
            "SlowMist",
            "WombatExchange",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Authorization limit issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - TransitSwap v4 Core_en-us.pdf",
        "body": "There are two roles Owner and Executor in the contract, and the permissions of the two roles are not clearly divided.",
        "labels": [
            "SlowMist",
            "TransitSwap v4 Core",
            "Type: Authority Control Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Security suggestion",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - TransitSwap v4 Core_en-us.pdf",
        "body": "Since the TransitSwapRouter contract will retain the user's authorization limit, it is recommended to allow the user to allocate on demand during the front-end authorization, and do not authorize the maximum value at one time to prevent the user's funds from being stolen. 11",
        "labels": [
            "SlowMist",
            "TransitSwap v4 Core",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing zero address check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - TransitSwap v4 Core_en-us.pdf",
        "body": "When modifying important addresses in the contract, it is not checked whether the incoming address is a zero address. ",
        "labels": [
            "SlowMist",
            "TransitSwap v4 Core",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - TransitSwap v4 Core_en-us.pdf",
        "body": "The Owner has the risk of over-authorization, and this role can withdraw the tokens in the contract to any address. ",
        "labels": [
            "SlowMist",
            "TransitSwap v4 Core",
            "Type: Authority Control Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Authority control issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - TransitSwap v4 Core_en-us.pdf",
        "body": "The contract adopts a completely open calling logic. There is an operation to authorize the approveAddress address in the _beforeSwap function. The calling path of this function is TransitSwapRouter.swap() -> TransitSwap.swap() -> TransitSwap._beforeSwap(). The calldata parameter is also passed in when calling the top-level function TransitSwapRouter.swap(). The code does not check whether the approveAddress is legal. If a malicious approveAddress is passed in, the contract will be incorrectly authorized and the tokens in the contract will be lost. ",
        "labels": [
            "SlowMist",
            "TransitSwap v4 Core",
            "Type: Authority Control Vulnerability",
            "Severity: High"
        ]
    },
    {
        "title": "Uninitialized parameter",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - TransitSwap v4 Core_en-us.pdf",
        "body": "The swapAmount parameter is declared in the contract but not initialized. ",
        "labels": [
            "SlowMist",
            "TransitSwap v4 Core",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Unsafe external call",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - TransitSwap v4 Core_en-us.pdf",
        "body": "The path and pair parameters in the supportingFeeOn function are controllable. If an attacker passes in malicious path and pair parameters, it may cause unexpected errors. ",
        "labels": [
            "SlowMist",
            "TransitSwap v4 Core",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing Approve amount reset",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - TransitSwap v4 Core_en-us.pdf",
        "body": "The _beforeSwap function in the TransitSwap contract will set the authorization limit to the maximum value when accessing the token for the rst time, but the function to remake the authorization is not found in the contract. When the authorization limit is used up, it will not be able to remake and the token cannot be used.",
        "labels": [
            "SlowMist",
            "TransitSwap v4 Core",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "4.2.1.1 __Guard_init function was not call when initialize",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Hot Cross BSC Bridge V1.0.0_en-us.pdf",
        "body": "ForeignProcessor contract and HomeRequest contract are inherit the Guard contract but dost not call the __Gurad_init function function __ForeignProcessor_init( IERC20 token, ValidatorRegistry validatorRegistry_ ) internal initializer { //SlowMist// Missing call of __Guard_init function require( address(token) != address(0) && Misc.isContract(address(token)), \"ForeignProcessor:Invalid erc20 address provided\" 10 ); require( address(validatorRegistry_) != address(0) && Misc.isContract(address(validatorRegistry_)), \"ForeignProcessor:Invalid validator registry address\" ); erc20 = token; validatorRegistry = validatorRegistry_; } function __HomeRequest_init( BEP20 token, ValidatorRegistry validatorRegistry_ ) internal initializer { //SlowMist// Missing call of __Guard_init function require( address(token) != address(0) && Misc.isContract(address(token)), \"HomeRequest:Invalid BEP20 address\" ); require( address(validatorRegistry_) != address(0) && Misc.isContract(address(validatorRegistry_)), \"HomeRequest:Invalid validator registry address\" ); bep20 = token; validatorRegistry = validatorRegistry_; } Fix status: fixed. 11 5.",
        "labels": [
            "SlowMist",
            "Hot Cross BSC Bridge V1.0.0",
            "Severity: Informational"
        ]
    },
    {
        "title": "Tokens Obtained from Emergency Withdrawal Partly Locked",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist_Audit_Report_StakeStone_MellowDepositWstETHStrategy_en-us.pdf",
        "body": "In the MellowDepositWstETHStrategy contract, the owner role can execute an emergency withdrawal operation from the mellowVault contract by calling the emergencyWithdrawFromMellow function. In the mellowVault contract, during an emergency withdrawal operation, the specied amount of LP tokens from previous withdrawal requests are burned, and two types of tokens, wstETH and DC_wstETH, are transferred to the address indicated in the withdrawal request. The amounts transferred are calculated based on the burned LP tokens and the current balance of these two tokens in the pool. However, in the MellowDepositWstETHStrategy contract, there is no implementation for redeeming DC_wstETH tokens back into wstETH, which results in these DC_wstETH tokens being locked within the contract. Furthermore, when calculating the total invested value of the contract using the getInvestedValue function, it fails to account for the value of the held DC_wstETH tokens. Code Location: contracts/strategies/MellowDepositWstETHStrategy.sol function getInvestedValue() public override returns (uint256 value) { uint256 etherValue = address(this).balance; uint256 stETHValue = IERC20(stETHAddr).balanceOf(address(this)); (, uint256 claimableValue, uint256 pendingValue) = checkPendingAssets(); uint256 mellowPending = getPendingValueFromMellow(); value = etherValue + stETHValue + claimableValue + pendingValue + getWstETHValue() + getDepositedValue() + mellowPending; } ... function emergencyWithdrawFromMellow( uint256[] memory _minAmounts, uint256 _deadline ) external onlyOwner returns (uint256 wstETHAmount) { IMellowVault(mellowVaultAddr).emergencyWithdraw(_minAmounts, _deadline); }",
        "labels": [
            "SlowMist",
            "SlowMist_Audit_Report_StakeStone_MellowDepositWstETHStrategy",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "The Potential Risk of Fixed Array Lengths",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist_Audit_Report_StakeStone_MellowDepositWstETHStrategy_en-us.pdf",
        "body": "In the MellowDepositWstETHStrategy contract, the owner role can call the depositIntoMellow function to deposit wstETH tokens from the contract into the MellowVault, where the length of the passed amounts array is xed at 1. Within the deposit function of the MellowVault contract, a check is performed to ensure that the lengths of the contract's _underlyingTokens array and the passed amounts array are equal. Currently, as the _underlyingTokens array in the MellowVault contract also contains only 1 element, this check passes successfully. However, the MellowVault contract features a function (addToken) that allows for adding new token data to the _underlyingTokens array. If, in the future, the _underlyingTokens array expands due to the addition of new tokens, the depositIntoMellow function may fail this length check and consequently be unable to execute properly. The same issues also apply when making a withdrawal request. Code Location: contracts/strategies/MellowDepositWstETHStrategy.sol#L177&L200 function depositIntoMellow( uint256 _wstETHAmount, uint256 _minLpAmount ) external onlyOwner returns (uint256 lpAmount) { require(_wstETHAmount != 0, \"zero\"); TransferHelper.safeApprove(wstETHAddr, mellowVaultAddr, _wstETHAmount); uint256[] memory amounts = new uint256[](1); amounts[0] = _wstETHAmount; (, lpAmount) = IMellowVault(mellowVaultAddr).deposit( address(this), amounts, _minLpAmount, block.timestamp ); emit DepositIntoMellow( mellowVaultAddr, address(this), _wstETHAmount, lpAmount ); } function requestWithdrawFromMellow( uint256 _share, uint256 _minAmount ) external onlyOwner { require(_share != 0, \"zero\"); uint256[] memory amounts = new uint256[](1); amounts[0] = _minAmount; IMellowVault(mellowVaultAddr).registerWithdrawal( address(this), _share, amounts, block.timestamp, type(uint256).max, true ); emit WithdrawFromMellow(mellowVaultAddr, address(this), _share); }",
        "labels": [
            "SlowMist",
            "SlowMist_Audit_Report_StakeStone_MellowDepositWstETHStrategy",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Conict in withdrawal requests",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist_Audit_Report_StakeStone_MellowDepositWstETHStrategy_en-us.pdf",
        "body": "In the MellowDepositWstETHStrategy contract, The owner role can initiate a withdrawal request for wstETH by calling the requestWithdrawFromMellow function, with the closePrevious parameter set to true by default. This implies that if a previous withdrawal request has been submitted and is still pending, it will rst be canceled before replacing it with the newly submitted withdrawal request. Code Location: contracts/strategies/MellowDepositWstETHStrategy.sol#L208 function requestWithdrawFromMellow( uint256 _share, uint256 _minAmount ) external onlyOwner { require(_share != 0, \"zero\"); uint256[] memory amounts = new uint256[](1); amounts[0] = _minAmount; IMellowVault(mellowVaultAddr).registerWithdrawal( address(this), _share, amounts, block.timestamp, type(uint256).max, true ); emit WithdrawFromMellow(mellowVaultAddr, address(this), _share); }",
        "labels": [
            "SlowMist",
            "SlowMist_Audit_Report_StakeStone_MellowDepositWstETHStrategy",
            "Type: Design Logic Audit",
            "Severity: Information"
        ]
    },
    {
        "title": "Redundant code",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Owlto Depositor_en-us.pdf",
        "body": "There are useless codes in the le and codes that are not used in actual business. Code Location: Depositor.sol#L225-227 contract Depositor { ... error NotOwnerError(); error LengthError(); error ZeroAddressError(); ... }",
        "labels": [
            "SlowMist",
            "Owlto Depositor",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Spelling mistake",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Owlto Depositor_en-us.pdf",
        "body": "Spelling mistake was identied within the code. Code Location: Depositor.sol function isContractt(address account) internal view returns (bool) { // This method relies on extcodesize, which returns 0 for contracts in // construction, since the code is only stored at the end of the // constructor execution. uint256 size; // solhint-disable-next-line no-inline-assembly assembly { size := extcodesize(account) } return size > 0; } ... function callOptionalReturn(IERC20 token, bytes memory data) private { ... require(address(token).isContractt(), \"SafeERC20: call to non-contract\"); ... }",
        "labels": [
            "SlowMist",
            "Owlto Depositor",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "4.2.1.1 Excessive auditing authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - MoonSwap_en-us.pdf",
        "body": "The owner in MasterStar contract can add a new lpToken through the add function, but if there is a black swan event, such as the addition of a malicious lpToken, there will be useless lpToken to recharge to get rewards. It is suggested that the owner can be handed over to the governance contract or time lock contract for management. function add(uint256 _allocPoint, IERC20 _lpToken, bool _withUpdate) public onlyOwner { if (_withUpdate) { massUpdatePools(); } require(poolIndexs[address(_lpToken)] < 1, \"LpToken exists\"); uint256 lastRewardBlock = block.number > startBlock ? block.number : startBlock; totalAllocPoint = totalAllocPoint.add(_allocPoint); poolInfo.push(PoolInfo({ lpToken: _lpToken, allocPoint: _allocPoint, lastRewardBlock: lastRewardBlock, tokenPerBlock: currentTokenPerBlock, accTokenPerShare: 0, finishMigrate: false, lockCrosschainAmount:0, crosschain_enable: false })); poolIndexs[address(_lpToken)] = poolInfo.length; } Owner can set migrator , It is suggested that the owner can be handed over to the governance contract or time lock contract for management. function setMigrator(IMigratorStar _migrator) public onlyOwner { migrator = _migrator; 7 } //Migratelptokentoanotherlpcontract.Canbecalledbyanyone.Wetrustthatmigratorcontractisgood. function migrate(uint256 _pid) public { require(address(migrator) != address(0), \"migrate: no migrator\"); PoolInfo storage pool = poolInfo[_pid]; IERC20 lpToken = pool.lpToken; uint256 bal = lpToken.balanceOf(address(this)); lpToken.safeApprove(address(migrator), bal); IERC20 newLpToken = migrator.migrate(lpToken); require(bal == newLpToken.balanceOf(address(this)), \"migrate: bad\"); pool.lpToken = newLpToken; pool.finishMigrate = true; } Fixed: The owner authority has been transferred to the timelock contract. Reference: https://etherscan.io/tx/0x3e8be2489c824906c7fe1abe376ccea198e3cd28cb225dee91d4f9c3e9 62a889",
        "labels": [
            "SlowMist",
            "MoonSwap",
            "Severity: Low"
        ]
    },
    {
        "title": "4.2.2.1 Compiler version is inconsistent",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - MoonSwap_en-us.pdf",
        "body": "The compiler version used by the imported contract is inconsistent. It is recommended to use a unified fixed compiler version when deploying. pragma solidity ^0.6.0; pragma solidity ^0.6.2; pragma solidity 0.6.12;",
        "labels": [
            "SlowMist",
            "MoonSwap",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.2.2.2 Better handling of ownership transfers",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - MoonSwap_en-us.pdf",
        "body": "When using the transferOwnership function to change the owner, it is recommended to add a 8 confirmation method that newOwner accepts the owner. The real authority transfer is performed after the new address is signed and confirmed to avoid the loss of authority. function transferOwnership(address newOwner) public virtual onlyOwner { require(newOwner != address(0), \"Ownable: new owner is the zero address\"); emit OwnershipTransferred(_owner, newOwner); _owner = newOwner; }",
        "labels": [
            "SlowMist",
            "MoonSwap",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.2.2.3 Enhancement point of delegateBySig function",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - MoonSwap_en-us.pdf",
        "body": "The nonce in the delegateBySig function is input by the user. When the user input a larger nonce, the current transaction cannot be success but the relevant signature data will still remain on the chain, causing this signature to be available for some time in the future. It is recommended to fix it according to EIP-2612. Reference: https://github.com/ethereum/EIPs/blob/master/EIPS/eip-2612.md#implementation. function delegateBySig( address delegatee, uint nonce, uint expiry, uint8 v, bytes32 r, bytes32 s external ) { bytes32 domainSeparator = keccak256( abi.encode( DOMAIN_TYPEHASH, keccak256(bytes(name())), getChainId(), address(this) ) ); 9 bytes32 structHash = keccak256( abi.encode( DELEGATION_TYPEHASH, delegatee, nonce, expiry ) ); bytes32 digest = keccak256( abi.encodePacked( \"\\x19\\x01\", domainSeparator, structHash ) ); address signatory = ecrecover(digest, v, r, s); require(signatory != address(0), \"MOON::delegateBySig: invalid signature\"); require(nonce == nonces[signatory]++, \"MOON::delegateBySig: invalid nonce\"); require(now <= expiry, \"MOON::delegateBySig: signature expired\"); return _delegate(signatory, delegatee); }",
        "labels": [
            "SlowMist",
            "MoonSwap",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.2.2.4 Mint issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - MoonSwap_en-us.pdf",
        "body": "The owner can mint tokens unlimitedly through mint function, but the owner's authority of the token contract is changed to MasterStar contract for the first time. function mint(address _to, uint256 _amount) public onlyOwner { _mint(_to, _amount); _moveDelegates(address(0), _delegates[_to], _amount); } Fixed: The owner authority has actually been transferred to the MasterStar contract. Reference: 10 https://etherscan.io/tx/0x0303672ee5045cd01102fdb50787541d11bddc3e1bfc446d4f6b46db85 e65bff",
        "labels": [
            "SlowMist",
            "MoonSwap",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.2.2.5 Using now globally available variables that will be deprecated",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - MoonSwap_en-us.pdf",
        "body": "The now globally available variables is used, which has been deprecated in compiler solidity 0.7.0. require(signatory != address(0), \"MOON::delegateBySig: invalid signature\"); require(nonce == nonces[signatory]++, \"MOON::delegateBySig: invalid nonce\"); require(now <= expiry, \"MOON::delegateBySig: signature expired\");",
        "labels": [
            "SlowMist",
            "MoonSwap",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.2.2.6 0 value is not checked",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - MoonSwap_en-us.pdf",
        "body": "The withdraw function suggests adding a check of _amount> 0, which can optimize the gas consumption when _amount is 0. function withdraw(uint256 _pid, uint256 _amount) public { PoolInfo storage pool = poolInfo[_pid]; require(!pool.finishMigrate, \"migrate not withdraw\"); UserInfo storage user = userInfo[_pid][msg.sender]; require(user.amount >= _amount, \"withdraw: not good\"); updatePool(_pid); uint256 pending = user.amount.mul(pool.accTokenPerShare).div(1e12).sub(user.rewardDebt); safeTokenTransfer(msg.sender, pending); user.amount = user.amount.sub(_amount); user.rewardDebt = user.amount.mul(pool.accTokenPerShare).div(1e12); pool.lpToken.safeTransfer(address(msg.sender), _amount); emit Withdraw(msg.sender, _pid, _amount); }",
        "labels": [
            "SlowMist",
            "MoonSwap",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.2.2.7 Prompt Error",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - MoonSwap_en-us.pdf",
        "body": "The prompt of setCrosschain function require has an error \"migrate not deposit\", it is recommended to modify the prompt to \"migrate not setCrosschain\". 11 function setCrosschain(uint256 _pid, bool isOk, address cmoonAddr) public onlyOwner { PoolInfo storage pool = poolInfo[_pid]; require(pool.finishMigrate, \"migrate not deposit\"); pool.crosschain_enable = isOk; require(cmoonAddr != address(0), \"address invalid\"); migratePoolAddrs[_pid] = cmoonAddr; } Fixed: The issue has been fixed by this commit: ef19afe4b6bfd624dd79903c36ea335be6a7b283.",
        "labels": [
            "SlowMist",
            "MoonSwap",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.2.2.8 Better handling of devaddr transfers",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - MoonSwap_en-us.pdf",
        "body": "When changing devaddr in the dev function, it is recommended to add newDevaddr to accept the replacement confirmation method. After the new address is signed and confirmed, the real change to devaddr can be made to avoid setting errors and the income cannot be normally obtained. function dev(address _devaddr) public { require(msg.sender == devaddr, \"dev: wut?\"); devaddr = _devaddr; }",
        "labels": [
            "SlowMist",
            "MoonSwap",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.2.2.9 Coding Standards",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - MoonSwap_en-us.pdf",
        "body": "The coding style of emergencyWithdraw function is to make an external call first, and then change the value of the contract variable. This way of writing, because lpToken is considered safe, there is no reentrancy problem, but it is recommended to use the correct coding standard: The variable is changed, and then an external call is made. A lock modifier for reentrancy prevention can also be added. function emergencyWithdraw(uint256 _pid) public { PoolInfo storage pool = poolInfo[_pid]; require(!pool.finishMigrate, \"migrate not withdraw\"); UserInfo storage user = userInfo[_pid][msg.sender]; pool.lpToken.safeTransfer(address(msg.sender), user.amount); 12 emit EmergencyWithdraw(msg.sender, _pid, user.amount); user.amount = 0; user.rewardDebt = 0; } Fixed: The issue has been fixed by this commit: ef19afe4b6bfd624dd79903c36ea335be6a7b283 5.",
        "labels": [
            "SlowMist",
            "MoonSwap",
            "Severity: Informational"
        ]
    },
    {
        "title": "Lack of previous pool status check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Stake Mask_en-us.pdf",
        "body": "In the StakeManager contract, the user can deposit funds into the contract by calling the depositAndLock function and withdraw funds by calling the withdraw function. However, when a new pool is added and currentPoolId is updated to the id of the new pool, the user calls depositAndLock function again to make a deposit without checking the unlocked state of the pool that the user deposited in before. So the poolId in the user's information will be directly overwritten with the new currentPoolId, even if the pool state at the time of the previous deposit was a locked state. If the state of the new pool is unlocked, the withdraw function can be called directly to withdraw all of the user's deposits, even if the pool where the rst deposit was made was in a locked state. Code Location: src/StakeManager.sol function depositAndLock(uint256 _amount) public nonReentrant { Pool storage pool = pools[currentPoolId]; require(pool.stakingEnabled, \"Staking is disabled for this pool\"); require(maskToken.transferFrom(msg.sender, address(this), _amount), \"Transfer failed\"); userInfos[msg.sender].stakedAmount += _amount; // depositAndLock will always stake to currentPoolId // it will init userInfos[msg.sender].poolId for the first time // it will change userInfos[msg.sender].poolId to currntPoolId(which means new pool) when // user deposit after prev pool unlocked userInfos[msg.sender].poolId = currentPoolId; emit Staked(msg.sender, currentPoolId, _amount); } function withdraw(uint256 _amount) public nonReentrant { Pool storage pool = pools[userInfos[msg.sender].poolId]; require(pool.unlocked, \"Pool is locked\"); require(userInfos[msg.sender].stakedAmount >= _amount, \"Insufficient balance\"); userInfos[msg.sender].stakedAmount -= _amount; require(maskToken.transfer(msg.sender, _amount), \"Transfer failed\"); emit unstaked(msg.sender, userInfos[msg.sender].poolId, _amount); }",
        "labels": [
            "SlowMist",
            "Stake Mask",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Dierence check when changing pools",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Stake Mask_en-us.pdf",
        "body": "In the StakeManager contract, the user can update the poolId in the user information to the latest currentPoolId by calling the changePool function. However, there is no check to see if the currentPoolId matches the poolId in the user information. Code Location: src/StakeManager.sol function changePool() public nonReentrant { uint8 fromPoolId = userInfos[msg.sender].poolId; Pool storage fromPool = pools[userInfos[msg.sender].poolId]; Pool storage toPool = pools[currentPoolId]; require(toPool.stakingEnabled, \"Staking is disabled for this pool\"); require(fromPool.unlocked, \"From pool is locked\"); require(userInfos[msg.sender].stakedAmount > 0, \"No staked amount\"); userInfos[msg.sender].poolId = currentPoolId; emit StakeChanged(msg.sender, fromPoolId, currentPoolId); }",
        "labels": [
            "SlowMist",
            "Stake Mask",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing return value check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Stake Mask_en-us.pdf",
        "body": "In the Reward contract, the owner can call the emergencyWithdraw function to transfer any tokens in the contract. But it does not check the return value. If external tokens do not adopt the EIP20 standard, it may lead to false top-up issues. ",
        "labels": [
            "SlowMist",
            "Stake Mask",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Stake Mask_en-us.pdf",
        "body": "In the Reward contract, the owner can call the emergencyWithdraw function to transfer any tokens in the contract. If the privilege is lost or misused, there may be an impact on the user's funds. ",
        "labels": [
            "SlowMist",
            "Stake Mask",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "4.3.1.2 Risk of loss of user funds",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DODOV2_en-us.pdf",
        "body": "In the LockTokenVault contract, when transferring the user's locked token, it did not check whether the _to address is msg.sender itself, which caused the user to abuse the transfer and cause a loss of funds. function transferLockedToken(address to) external { originBalances[to] = originBalances[to].add(originBalances[msg.sender]); claimedBalances[to] = claimedBalances[to].add(claimedBalances[msg.sender]); originBalances[msg.sender] = 0; claimedBalances[msg.sender] = 0; } Fix status: fixed, repair commit: main-08a06609604779c31db493bc0d755efa1c3f0a61.",
        "labels": [
            "SlowMist",
            "DODOV2",
            "Severity: Low"
        ]
    },
    {
        "title": "4.2.2.1 Missing events",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DODOV2_en-us.pdf",
        "body": "Contract  DODOApproveProxy  Function list  init / unlockAddProxy / addDODOProxy / LockAddProxy / removeDODOProxy ContractDODOApproveFunction listinit / unlockSetProxy / setDODOProxy / LockSetProxy ContractDODV2Proxy02Function listaddWhiteList / removeWhiteList / updateGasReturn ContractDVMFactorFunction listupdateDvmTemplate ContractDPPAdvanceFunction listtunePrice ContractDPPAdvance Function listsetOperator / setFreezeTimestamp ContractDPPVaultFunction listratioSync / retrieve 6 ContractDVMVault Function list_setReserve_sync The above functions does not have an event declaration, it is recommended to add the corresponding event declaration Fix status: After communicating with the project party, it is confirmed that the above event statement is not currently used in business and will be fixed in subsequent iterations.",
        "labels": [
            "SlowMist",
            "DODOV2",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.2.2.2 The contract balance was not verified when the reward was distributed",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DODOV2_en-us.pdf",
        "body": "In the RewardVault contract, the contract balance is not verified when the reward is distributed, which may cause the contract balance to fail to be distributed function reward(address to, uint256 amount) external onlyOwner { //SlowMist// Not verify if contract balance is larger than the transfer amount IERC20(dodoToken).safeTransfer(to, amount); } Fix situation: After confirming with the project party, they ignore this problem.",
        "labels": [
            "SlowMist",
            "DODOV2",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.2.2.3 Unchecked array length",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DODOV2_en-us.pdf",
        "body": "a. The getPendingReward function in the BaseMine contract did not verify whether the value of i passed in was less than the length of the array when obtaining the reward of the pool, which resulted in the failure to obtain the reward. function getPendingReward(address user, uint256 i) public view returns (uint256) { //SlowMist// Not verify the array length RewardTokenInfo storage rt = rewardTokenInfos[i]; uint256 accRewardPerShare = rt.accRewardPerShare; if (rt.lastRewardBlock != block.number) { accRewardPerShare = _getAccRewardPerShare(i); } return 7 DecimalMath.mulFloor( balanceOf(user), accRewardPerShare.sub(rt.userRewardPerSharePaid[user]) ).add(rt.userRewards[user]); } Fix status: fixed, repair commit: feature/mineV2AndDSP- 5917c95439cac06241f108038043d2 2348c863e6. b. The claimReward function in the BaseMine contract does not verify whether the value of i passed in is less than the length of the array, resulting in failure to obtain rewards function claimReward(uint256 i) public { require(i<rewardTokenInfos.length, \"DODOMineV2: REWARD_ID_NOT_FOUND\"); _updateReward(msg.sender, i); RewardTokenInfo storage rt = rewardTokenInfos[i]; uint256 reward = rt.userRewards[msg.sender]; if (reward > 0) { rt.userRewards[msg.sender] = 0; IRewardVault(rt.rewardVault).reward(msg.sender, reward); emit Claim(i, msg.sender, reward); } } Fix status: fixed, repair commit: feature/mineV2AndDSP- 5917c95439cac06241f108038043d2 2348c863e6.",
        "labels": [
            "SlowMist",
            "DODOV2",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.2.2.4 Compatibility risk of rebasing tokens",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DODOV2_en-us.pdf",
        "body": "The deposit function of the ERC20Mine contract does not verify the incoming amount. When it is compatible with rebasing tokens, it will cause an error to obtain the transfer amount. function claimReward(uint256 i) public { require(i<rewardTokenInfos.length, \"DODOMineV2: REWARD_ID_NOT_FOUND\"); _updateReward(msg.sender, i); 8 RewardTokenInfo storage rt = rewardTokenInfos[i]; uint256 reward = rt.userRewards[msg.sender]; if (reward > 0) { rt.userRewards[msg.sender] = 0; IRewardVault(rt.rewardVault).reward(msg.sender, reward); emit Claim(i, msg.sender, reward); } } Fix status: fixed, fix commit: main-d26b21bd814d4bfcc702521d52f6cb3af4f86e5c. 5.",
        "labels": [
            "SlowMist",
            "DODOV2",
            "Severity: Informational"
        ]
    },
    {
        "title": "Potential Unable to Borrow Issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn LeverageStaking - SlowMist Audit Report.pdf",
        "body": "In the LeverageStake contract, the batchDecreaseLever function reduces the leverage ratio of the ETF by withdrawing/repaying in AAVE, and may completely repay the debt in AAVE in the process. In this case, when the operator fully withdraws stETH from AAVE, the state of usingAsCollateral of the ETF in AAVE will be set to false. Theoretically, the aToken in the ETF will be 0 at this time, and usingAsCollateral will be automatically set to true when the ETF deposits in AAVE next time. But in fact, AAVE may still have 1wei of aToken left in the ETF due to arithmetic precision errors when calculating the number of aTokens that need to be burned by withdrawing the amount. Therefore, when the ETF deposits in AAVE next time, usingAsCollateral will not be set to true, and since there is no interface for calling the setUserUseReserveAsCollateral function in LeverageStake, this may cause the ETF to no longer be able to perform borrow operations. ",
        "labels": [
            "SlowMist",
            "DeSyn LeverageStaking - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Library function visibility issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn LeverageStaking - SlowMist Audit Report.pdf",
        "body": "In the protocol, the LeverageStake contract operates ETF through the interface of the AaveCall library, so the AaveCall library is stateless, and there is no need to set the visibility of the function to external/public. ",
        "labels": [
            "SlowMist",
            "DeSyn LeverageStaking - SlowMist Audit Report",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Function multiple logic mixes",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn LeverageStaking - SlowMist Audit Report.pdf",
        "body": "In the getLeverageInfo function comment of the LeverageStake contract, it is explained that this function is used to obtain the fund status of the ETF in AAVE. But it not only gets it through the getUserAccountData function but also rebinds the ETF. These are two completely unrelated functions but used in the same function. And due to the openness of the getLeverageInfo function, any user can perform rebind operations through this function, which may be contrary to the design philosophy of ETF. ",
        "labels": [
            "SlowMist",
            "DeSyn LeverageStaking - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Potential Malicious Liquidation ETF Issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn LeverageStaking - SlowMist Audit Report.pdf",
        "body": "In the LeverageStake contract, the operator can increase the leverage ratio of the ETF in AAVE through the borrow function. Since there is no maximum leverage limit, when the leverage ratio is too high and stETH is close to the liquidation line, the ETF may be liquidated due to the accumulation of loan interest. If the operator acts maliciously subjectively, the funds of users in the ETF will be at risk. ",
        "labels": [
            "SlowMist",
            "DeSyn LeverageStaking - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "min_dy without slippage and exchange fees",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn LeverageStaking - SlowMist Audit Report.pdf",
        "body": "In the LeverageStake contract, the increaseLever and convertToAstEth functions all have the function of exchanging stETH and ETH tokens through the exchange function. However, the min_dy parameter passed in is consistent with the dx parameter. Due to the existence of slippage and exchange fees, a certain amount of stETH cannot be exchanged for exactly the same amount of ETH tokens. Therefore, the exchange function in these functions cannot be executed normally. ",
        "labels": [
            "SlowMist",
            "DeSyn LeverageStaking - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Potential Operator Arbitrage Risk",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn LeverageStaking - SlowMist Audit Report.pdf",
        "body": "In the LeverageStake contract, the operator can exchange stETH and ETH tokens through the exchange function, but its min_dy parameter is also set by the operator. Therefore, if the caller does not pass in min_dy, the exchange operation of the ETF in the Curve Pool may suer from a sandwich attack, resulting in the loss of ETF assets. ",
        "labels": [
            "SlowMist",
            "DeSyn LeverageStaking - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Unreasonable defaultSlippage",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn LeverageStaking - SlowMist Audit Report.pdf",
        "body": "There is a defaultSlippage variable in the LeverageStake contract, which is used in the decreaseLever and convertToWeth functions to exchange the minimum received amount between stETH and ETH tokens. It defaults to 1 and cannot be modied, which will cause min_dy to be 1% of dx during the exchange operation, making the token exchange process vulnerable to sandwich attacks. ",
        "labels": [
            "SlowMist",
            "DeSyn LeverageStaking - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Redundant receive function",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn LeverageStaking - SlowMist Audit Report.pdf",
        "body": "There is a receive function in the LeverageStake contract to enable the contract to receive native tokens. However, in actual business, the contract does not need to receive native tokens, so the receive function is redundant, which may also cause users to mistakenly transfer native tokens to this contract and then fail to withdraw them. ",
        "labels": [
            "SlowMist",
            "DeSyn LeverageStaking - SlowMist Audit Report",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Issues with not updating bound tokens",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn LeverageStaking - SlowMist Audit Report.pdf",
        "body": "In the LeverageStake contract, the deposit, borrow, withdraw, and repayBorrow functions are used to operate the ETF to deposit, borrow, withdraw, and repay to AAVE, respectively. However, the _records of the bound tokens in the ETF are not updated in the above operations. This will cause the token _records in the ETF to be skewed after the operator operates through the above function. ",
        "labels": [
            "SlowMist",
            "DeSyn LeverageStaking - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Partial rebind issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn LeverageStaking - SlowMist Audit Report.pdf",
        "body": "In the LeverageStake contract, the increaseLever and decreaseLever functions respectively increase/decrease the leverage ratio of the ETF in AAVE, and at the same time rebind the astETH tokens in the ETF, but do not update the _records status of ETH and stETH in the ETF, which will cause The _records state does not match the actual token balance in the ETF. ",
        "labels": [
            "SlowMist",
            "DeSyn LeverageStaking - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Potential denial of service risk due to gulp operations",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase5 - SlowMist Audit Report_en-us.pdf",
        "body": "In the Actions contract, when the user performs the autoJoinSmartPool operation, the number of shares the user can obtain will be calculated through the _calculateShare function, and minPoolAmountOut will be checked at the end. The _calculateShare function obtains the number of tokens recorded in the pool through bPool's getBalance when calculating the share, but unfortunately any user can update this parameter through bPool's gulp function. Therefore, when an ordinary user performs an autoJoinSmartPool operation, a malicious user directly transfers funds to bPool and calls the gulp function to update the token balance recorded in the pool. At this time, ordinary users will not be able to successfully add liquidity due to the minPoolAmountOut check. If the minPoolAmountOut value passed in by an ordinary user is 0, it may cause an interest rate ination attack. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase5 - SlowMist Audit Report",
            "Type: Denial of Service Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Incorrect event logging",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase5 - SlowMist Audit Report_en-us.pdf",
        "body": "In the CRP contract, the createPool function adds the creator parameter as the real creator of the pool. However, the corresponding events were not modied accordingly. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase5 - SlowMist Audit Report",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Incorrect WETH address",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase5 - SlowMist Audit Report_en-us.pdf",
        "body": "The WETH address constant is hard-coded in the Actions contract, but this address is an EOA address on the Ethereum mainnet and is not the correct WETH address. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase5 - SlowMist Audit Report",
            "Type: Others",
            "Severity: High"
        ]
    },
    {
        "title": "Incorrect poolTokens check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase5 - SlowMist Audit Report_en-us.pdf",
        "body": "In the autoJoinSmartPool function of the Actions contract, it checks the tokens deposited by the user through poolTokens[i] == handleToken , but handleToken has been replaced by the issueToken parameter during the native token checking phase. Therefore, the poolTokens[i] == handleToken check is not accurate. If handleToken is WETH, it will cause an error in the _makeSwap operation. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase5 - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Redundant STBT token check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase5 - SlowMist Audit Report_en-us.pdf",
        "body": "In the autoJoinSmartPool and _exit functions of the Actions contract, when making a token transfer, it will be checked whether the transferred token is an STBT token. But in fact, the protocol does not allow deposits of STBT tokens, and STBT tokens will also be converted into stablecoins after the ETF expires. Therefore, theoretically, there will be no STBT tokens in the contract, so the STBT token check is redundant. . ",
        "labels": [
            "SlowMist",
            "DeSyn Phase5 - SlowMist Audit Report",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Potential risk of slot conict",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase5 - SlowMist Audit Report_en-us.pdf",
        "body": "In this protocol iteration, both SmartPoolManager and Actions contracts have changed their storage structures. If these contracts use an upgradeable model, and upgrading the contract directly on the original basis may lead to contract storage slot conicts. In fact, the Actions contract is an upgradeable contract, so special attention should be paid to such risks.",
        "labels": [
            "SlowMist",
            "DeSyn Phase5 - SlowMist Audit Report",
            "Type: Variable Coverage Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of event forgery",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase5 - SlowMist Audit Report_en-us.pdf",
        "body": "In the CRP contract, the exitPool function adds a user parameter to record the real caller when the user exits through the Actions contract. However, users can also exit by calling the exitPool function of the CRP contract. They can pass in any user parameter to make the LogExit event record an incorrect value. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase5 - SlowMist Audit Report",
            "Type: Malicious Event Log Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Potential risk of denial of service due to large CRPFactory array",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase5 - SlowMist Audit Report_en-us.pdf",
        "body": "In the CRPFactory contract, when the Blabs role performs addCRPFactory and removeCRPFactory operations, it will use a for loop to traverse the entire CRPFactorys array. If the array length is too large, it will lead to DoS risks. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase5 - SlowMist Audit Report",
            "Type: Denial of Service Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Potential risk of endless loop",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase5 - SlowMist Audit Report_en-us.pdf",
        "body": "In the CRPFactory contract, the isCrp function is used to check whether the address passed by the user is a CRP contract. If not, the CRPFactorys array will be circulated and the isCrp function of other CRPFactory will be called to check. However, it should be noted that if the Blabs role adds this contract address to the CRPFactorys array, the user will fall into an innite loop error when querying a CRP address that is not recorded in this contract through the isCrp function. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase5 - SlowMist Audit Report",
            "Type: Denial of Service Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Unchecked asset type in inputEth function allows potential asset mismatch",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Doubler Lite.pdf",
        "body": "The input function lacks a crucial check to verify if the _asset parameter corresponds to an ETH pool. This oversight creates a potential vulnerability. In a scenario where both ETH and BTC pools exist, a user could potentially input ETH but have it processed as BTC. This mismatch between the intended and actual asset type could lead to unexpected behavior and potential exploitation of the system. contracts/Doubler.sol function inputEth( address _asset, uint256 _qAmount, address _to ) external payable nonReentrant onlyOncePerBlock onlyAsset(_asset) { if (msg.value != _qAmount) revert E_Balance(); _input(_asset, _qAmount, _to, true); }",
        "labels": [
            "SlowMist",
            "Doubler Lite",
            "Type: Others",
            "Severity: Low"
        ]
    },
    {
        "title": "Issue with fee allocation in the _limitMint function",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Doubler Lite.pdf",
        "body": "In the _limitMint function, the distribution of minting fees should be based on the length of _srvFeeAddr . Currently, the number of _srvFeeAddr entries called from the Doubler contract is only 2. However, if other contracts call this function with a dierent length of _srvFeeAddr in the future, it will result in allocating more fees than intended. contracts/RBToken.sol function _limitMint( address _recipient, uint256 _tokenAmount, uint256 _poolTotalLimit, address[] memory _srvFeeAddr, uint16 _srvFeeRatio ) internal returns (uint256 recipientTokenAmount) { ... _totalShare = _totalShare + newShares; uint256 recipientNewShare = newShares; recipientTokenAmount = _tokenAmount; if (_srvFeeRatio > 0) { uint256 srvFee = (newShares * _srvFeeRatio) / _perMil; recipientTokenAmount = recipientTokenAmount - (_tokenAmount * _srvFeeRatio) / _perMil; for (uint8 i = 0; i < _srvFeeAddr.length; i++) { _shares[_srvFeeAddr[i]] = _shares[_srvFeeAddr[i]] + srvFee / 2; recipientNewShare = recipientNewShare - srvFee / 2; _emitTransferEvents(address(0x0), _recipient, (_tokenAmount * _srvFeeRatio) / _perMil, srvFee); } } _shares[_recipient] = _shares[_recipient] + recipientNewShare; _emitTransferEvents(address(0x0), _recipient, recipientTokenAmount, recipientNewShare); }",
        "labels": [
            "SlowMist",
            "Doubler Lite",
            "Type: Others",
            "Severity: Low"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Doubler Lite.pdf",
        "body": "The owner can modify the fees and fee recipients in the pool, which can cause damage to the project's funds if the private key is compromised. contracts/Doubler.sol owner can initializeDoubler owner can updateLowerOfInputMaximum owner can newPool owner can updatePool ADMIN can set the upper and lower price limits of the prediction machine, which will aect the functionality of the contract if ADMIN's private key is compromised. contracts/FastPriceFeed.sol ADMIN can setAssetPriceLimit ADMIN can setPriceFeedTimeLimit ADMIN can newAsset ADMIN can switchPriceFeed The owner can set the address where the fee will be charged, and if the private key is leaked, it will result in the loss of the project's funds. contracts/DoublerFactory.sol contracts/DoublerFactory.sol owner can updateEcoAddr owner can newPool",
        "labels": [
            "SlowMist",
            "Doubler Lite",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Potential bypass Issue with onlyOncePerBlock",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Doubler Lite.pdf",
        "body": "In the design logic of doubler lite, atoken, btoken, and ctoken are all transferable. The onlyOncePerBlock mechanism is intended to restrict a user to a single function operation within one block. However, this restriction only applies to msg.sender, allowing users to bypass the limitation by making calls through multiple contracts. contracts/Doubler.sol modifier onlyOncePerBlock() { if (_lastBlockCalled[msg.sender] >= block.number) revert E_BlockOnce(); _; _lastBlockCalled[msg.sender] = block.number; }",
        "labels": [
            "SlowMist",
            "Doubler Lite",
            "Type: Others",
            "Severity: Medium"
        ]
    },
    {
        "title": "Abnormal implementation logic in getPooledByShares",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Doubler Lite.pdf",
        "body": "In the getPooledByShares function, it should retrieve the corresponding token amount based on sharesAmount. However, the actual interface called retrieves sharesAmount based on the token amount. contracts/RBToken.sol function getPooledByShares(uint256 _sharesAmount) public view returns (uint256) { return _getSharesByPooledToken(_sharesAmount); }",
        "labels": [
            "SlowMist",
            "Doubler Lite",
            "Type: Others",
            "Severity: Low"
        ]
    },
    {
        "title": "Potential risk due to the unique nature of 10xBToken",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Doubler Lite.pdf",
        "body": "Since 10xBToken is a special type of token where users hold shares instead of actual quantities, there may be an extreme risk when users add liquidity providers. In an extreme scenario, subsequent investors can obtain a large number of shares, causing the price of BToken in the pool to rise sharply (because the actual token quantity obtainable by the pools shares decreases). This could result in liquidity providers incurring losses as a small amount of tokens might be used to exchange for a large amount of corresponding assets. Status Acknowledged",
        "labels": [
            "SlowMist",
            "Doubler Lite",
            "Type: Others",
            "Severity: Information"
        ]
    },
    {
        "title": "Impact of inationary or deationary tokens on the doubler lite economic model",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Doubler Lite.pdf",
        "body": "In the economic model of Doubler Lite, the use of inationary (e.g., stETH) or deationary tokens does not aect the overall economic model. This is because all calculations are based on shares, and the ination or deation impacts only the temporary average price of the tokens, which aligns with the design expectations. Status Acknowledged",
        "labels": [
            "SlowMist",
            "Doubler Lite",
            "Type: Others",
            "Severity: Information"
        ]
    },
    {
        "title": "Recommendations for parameter checking",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Doubler Lite.pdf",
        "body": "contracts/Doubler.sol Suggest checking startTime, endTime to make sure startTime is less than endTime, and checking creator to make sure creator is not address(0). function _checkPoolParam(Pool memory _pl) internal pure { if (_pl.inputFee > 20) revert E_FeeLimit(); if (_pl.withdrawFee > 20) revert E_FeeLimit(); }",
        "labels": [
            "SlowMist",
            "Doubler Lite",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Redundant code",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Send V1.0.1_en-us.pdf",
        "body": "Ether is not accepted by default, which is a redundant code. cross-send/contracts/CrossSend.sol#L41-L47 initial-hotcross-oering/contracts/BaseIHO.sol#L67-L73 fallback () external payable { revert(\"cannot directly accept currency transfers\"); } receive () external payable { revert(\"cannot directly receive currency transfers\"); 15 }",
        "labels": [
            "SlowMist",
            "Cross Send V1.0.1",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Gas optimization",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Send V1.0.1_en-us.pdf",
        "body": "If one of the batch transfers fails, the transaction that was previously transferred normally will be reverted, but Gas has been consumed. It is a gas optimization issue here. cross-send/contracts/CrossSend.sol#L175-L210 function sendToken( IERC20 token, address[] memory recipients, uint256[] memory amounts ) private returns(uint256) { uint256 total = 0; for (uint256 i = 0; i < recipients.length ; i++) { require(_msgSender() != recipients[i], \"sender != recipient\"); token.safeTransferFrom(_msgSender(), recipients[i], amounts[i]); total += amounts[i]; } return total; } function sendNative( address[] memory recipients, uint256[] memory amounts ) private returns(uint256) { uint256 total = 0; 16 for (uint256 i = 0; i < recipients.length ; i++) { total += amounts[i]; (bool success, ) = payable(recipients[i]).call{value: amounts[i]}(\"\"); require(success, \"native transfer failed\"); } return total; }",
        "labels": [
            "SlowMist",
            "Cross Send V1.0.1",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of allowance amount abuse",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Send V1.0.1_en-us.pdf",
        "body": "There have an allowance amount in the contract, but the distributeTokenFee function does not limit the caller, and there is an issue of being called arbitrarily, but it can only transfer the balance of the sender to the feeCollector. cross-send/contracts/fee-managers/RecipientCountFee.sol#L65-L83 function distributeTokenFee( uint256 txRecipientCount, uint256, uint256, uint256, uint256, address sender ) public override { uint256 payableFee = txRecipientCount * tokenFeePerRecipient; 17 if(payableFee < minTokenFee) { payableFee = minTokenFee; } else if (payableFee > maxTokenFee) { payableFee = maxTokenFee; } token.safeTransferFrom(sender, feeCollector, payableFee); }",
        "labels": [
            "SlowMist",
            "Cross Send V1.0.1",
            "Type: Authority Control Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Price manipulation issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Send V1.0.1_en-us.pdf",
        "body": "The IOUPrice is calculated using totalFarmingTokenBalance. Attackers can control totalFarmingTokenBalance to manipulate IOUPrice. The current code does not nd the location where IOUPrice is used. Referencehttps://slowmist.medium.com/cream-hacked-analysis-us-130-million-hacked-95c9410320ca cross-yield/contracts/core/CrossYield.sol#L95-L101 function IOUPrice() public view returns (uint256) { uint256 IOUSupply = totalSupply(); return IOUSupply == 0 ? 1e18 : (totalFarmingTokenBalance() * 1e18) / IOUSupply; } 18 cross-yield/contracts/core/CrossYield.sol#L65-L67 function totalFarmingTokenBalance() public view returns (uint256) { return farmingToken().balanceOf(address(this)) + strategy.balanceOf(); }",
        "labels": [
            "SlowMist",
            "Cross Send V1.0.1",
            "Type: Others",
            "Severity: Medium"
        ]
    },
    {
        "title": "Sandwich attacks issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Send V1.0.1_en-us.pdf",
        "body": "There is no slippage check during swap, and there is a risk of sandwich attack. IPancakeRouter02(pcsRouter).swapExactTokensForTokens(cakeBalance, 0,cakeToBaseRoute, address(this), block.timestamp); IPancakeRouter02(pcsRouter) .swapExactTokensForTokens(toSwap, 0, route, address(this), block.timestamp); Reference https://medium.com/coinmonks/demystify-the-dark-forest-on-ethereum-sandwich-attacks-5a3aec9fa33e cross-yield/contracts/libs/OptimalSwap.sol#L14-L63 function prepareLiquidity( address cake, address[2] memory lpTokens, 19 address wbnb, address busd, address farmingToken, address pcsRouter, uint256 fee ) external { uint256 cakeBalance = IERC20(cake).balanceOf(address(this)); bool isCakeInLp = lpTokens[0] == cake || lpTokens[1] == cake; bool isWbnbBased = lpTokens[0] == wbnb || lpTokens[1] == wbnb; address baseToken = isWbnbBased ? wbnb : busd; // if cake is not part of the lp token, swap all cake for the base token if (!isCakeInLp) { address[] memory cakeToBaseRoute = new address[](2); cakeToBaseRoute[0] = cake; cakeToBaseRoute[1] = baseToken; IPancakeRouter02(pcsRouter) .swapExactTokensForTokens(cakeBalance, 0, cakeToBaseRoute, address(this), block.timestamp); } (uint256 reserve0, uint256 reserve1,) = IPancakePair(farmingToken).getReserves(); address[] memory route = new address[](2); uint256 lp0Bal = IERC20(lpTokens[0]).balanceOf(address(this)); uint256 lp1Bal = IERC20(lpTokens[1]).balanceOf(address(this)); uint256 toSwap; // The possible cases here are: // - Cake was not part of the LP token, so we swap for baseToken which could either be lpToken0 or lpToken // - Cake was part of the LP token, so it can either be lpTokens[0] or lpTokens[1] // So, depending on which token we have the highest balance for, we swap for the other one. if (lp0Bal > lp1Bal) { toSwap = SwapAmount.getSwapAmount(lp0Bal, reserve0, fee); route[0] = lpTokens[0]; route[1] = lpTokens[1]; } else { toSwap = SwapAmount.getSwapAmount(lp1Bal, reserve1, fee); route[0] = lpTokens[1]; route[1] = lpTokens[0]; 20 } // Perform the swap IPancakeRouter02(pcsRouter) .swapExactTokensForTokens(toSwap, 0, route, address(this), block.timestamp); } IPancakeRouter02(pcsRouter).swapExactTokensForTokens(toWbnb, 0, cakeToWbnbRoute, address(this), block.timestamp); cross-yield/contracts/strategies/StrategyCake.sol#L131 function collectFees() internal { // a percentant of the cake we get from the masterchef will be used to buy BNB and transfer to this address // this is the total fees that will be shared amongst the protocol, stategy dev and the harvester uint256 toWbnb = feeManager.calculateTotalFee(IERC20(farmingToken).balanceOf(address(this))); IPancakeRouter02(pcsRouter).swapExactTokensForTokens(toWbnb, 0, cakeToWbnbRoute, address(this), block.timestamp); uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this)); // distribute hervester fee uint256 harvesterFeeAmount = feeManager.calculateHarvestFee(wbnbBal); // collectFees is called indirectly from the CrossYield contract via the beforeDeposit hook. // This means that _msgSender() is the CrossYield contract and not the actuall EOA account // that send the transaction IERC20(wbnb).safeTransfer(tx.origin, harvesterFeeAmount); // distribute protocol fee uint256 protocolFeeAmount = feeManager.calculateProtocolFee(wbnbBal); // IERC20(wbnb).safeTransfer(protocolFeeRecipient, protocolFeeAmount); feeProcessor.process(protocolFeeAmount); // distribute strategy dev fee uint256 strategyDevFeeAmount = feeManager.calculateStrategyDevFee(wbnbBal); IERC20(wbnb).safeTransfer(feeManager.strategyDev(), strategyDevFeeAmount); emit FeeCollected( toWbnb, 21 harvesterFeeAmount, protocolFeeAmount, strategyDevFeeAmount, _msgSender() ); } cross-yield/contracts/strategies/StrategyCakeLP.sol#L174 function collectFees() internal { // a percentant of the cake we get from the masterchef will be used to buy BNB and transfer to this address // this is the total fees that will be shared amongst the protocol, stategy dev and the harvester uint256 toWbnb = feeManager.calculateTotalFee(IERC20(cake).balanceOf(address(this))); IPancakeRouter02(pcsRouter).swapExactTokensForTokens(toWbnb, 0, cakeToWbnbRoute, address(this), block.timestamp); uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this)); // distribute hervester fee uint256 harvesterFeeAmount = feeManager.calculateHarvestFee(wbnbBal); IERC20(wbnb).safeTransfer(_msgSender(), harvesterFeeAmount); // distribute protocol fee uint256 protocolFeeAmount = feeManager.calculateProtocolFee(wbnbBal); feeProcessor.process(protocolFeeAmount); // distribute strategy dev fee uint256 strategyDevFeeAmount = feeManager.calculateStrategyDevFee(wbnbBal); IERC20(wbnb).safeTransfer(feeManager.strategyDev(), strategyDevFeeAmount); emit FeeCollected( toWbnb, harvesterFeeAmount, protocolFeeAmount, strategyDevFeeAmount, _msgSender() ); } cross-yield/contracts/strategies/StrategyCake.sol 22 function harvest() public override whenNotPaused { // claim rewards IMasterChef(masterchef).leaveStaking(0); // because harvest can automatically be called after each user deposit // we might end up having multiple deposits in the same block and only one // would return rewards from masterchef so the rest will have 0 cake so // we don't need to waste gas to collect fees and call deposit uint256 farmingTokenBalance = balanceOfFarmingToken(); if(farmingTokenBalance > 0) { collectFees(); deposit(); emit HarvestTriggered(_msgSender(), farmingTokenBalance); } } cross-yield/contracts/strategies/StrategyCakeLP.sol#l137-L148 function harvest() external override whenNotPaused { // claim rewards IMasterChef(masterchef).deposit(poolId, 0); uint256 harvestedAmount = IERC20(cake).balanceOf(address(this)); collectFees(); addLiquidity(); deposit(); emit HarvestTriggered(_msgSender(), harvestedAmount); }",
        "labels": [
            "SlowMist",
            "Cross Send V1.0.1",
            "Type: Reordering Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Missing slippage check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Send V1.0.1_en-us.pdf",
        "body": "The addLiquidity function without slippage check, it doesn't have an impermanent loss check. cross-yield/contracts/strategies/StrategyCakeLP.sol#L218 function addLiquidity() internal { OptimalSwap.prepareLiquidity( cake, [lpToken0, lpToken1], wbnb, busd, farmingToken, pcsRouter, swapFee ); // add liquidity to AMM on PCS uint256 lp0Bal = IERC20(lpToken0).balanceOf(address(this)); uint256 lp1Bal = IERC20(lpToken1).balanceOf(address(this)); IPancakeRouter02(pcsRouter) .addLiquidity(lpToken0, lpToken1, lp0Bal, lp1Bal, 0, 0, address(this), block.timestamp); emit LiquidityAdded(lpToken0, lpToken1, lp0Bal, lp1Bal, _msgSender()); }",
        "labels": [
            "SlowMist",
            "Cross Send V1.0.1",
            "Type: Reordering Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Permission check Missing",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Send V1.0.1_en-us.pdf",
        "body": "There is no permission check for deposit function. The function is called by the CrossYieid contract. cross-yield/contracts/strategies/StrategyCakeLP.sol#L225-L231 function deposit() public override whenNotPaused { uint256 farmingTokenBalance = balanceOfFarmingToken(); if (farmingTokenBalance > 0) { IMasterChef(masterchef).deposit(poolId, farmingTokenBalance); } } cross-yield/contracts/strategies/StrategyCake.sol#L169-L175 function deposit() public override whenNotPaused { uint256 farmingTokenBalance = balanceOfFarmingToken(); if (farmingTokenBalance > 0) { IMasterChef(masterchef).enterStaking(farmingTokenBalance); } }",
        "labels": [
            "SlowMist",
            "Cross Send V1.0.1",
            "Type: Authority Control Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Excessive authority issue 25",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Send V1.0.1_en-us.pdf",
        "body": "Owner can modify the address of the strategy. The new strategy may have security risks if it is not audited, which will aect the user's funds. If the private key is leaked, it will aect the user's funds. cross-yield/contracts/core/CrossYield.sol#L224-L236 function upgradeStrategy() public onlyOwner { require(stratCandidate.strategy != address(0), \"No proposal exists\"); require(block.number > stratCandidate.proposedBlock + stratUpgradableAfter, \"Strategy cannot be replaced yet\"); emit NewStrategy(stratCandidate.strategy); strategy.retireStrategy(); strategy = IStrategy(stratCandidate.strategy); stratCandidate.strategy = address(0); stratCandidate.proposedBlock = 0; putFundsToWork(); } cross-yield/contracts/core/CrossYield.sol#L211-L220 function proposeStrategy(address _strategy) public onlyOwner { require(address(this) == IStrategy(_strategy).vault(), \"Invalid new strategy\"); stratCandidate = StrategyCandidate({ strategy: _strategy, proposedBlock: block.number }); emit NewStratCandidate(_strategy); }",
        "labels": [
            "SlowMist",
            "Cross Send V1.0.1",
            "Type: Authority Control Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Repeatable claims issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Send V1.0.1_en-us.pdf",
        "body": "After the claim, lottery.status is not set as claimed, and it is also necessary to check whether lotteryId has been claimed when the claim is executed. hotdrop/contracts/HotDrop.sol#L261-L274 function claim(uint256 lotteryId) external nonReentrant { Lottery storage lottery = lotteries[lotteryId]; require(lottery.status == Status.WinnerDrawn, \"winner not drawn\"); // if there is no winner transfer the total amount to the treasury if(tickets[lotteryId][lottery.winningNumber] == address(0)) { lottery.purchaseToken.safeTransfer(treasury, lottery.purchaseToken.balanceOf(address(this))); } else if(tickets[lotteryId][lottery.winningNumber] == _msgSender()) { // if the ticket is the winning ticket and belongs to the user then split the pot uint256 treasuryAmount = (lottery.totalRaised * lottery.treasuryFee) / FEE_BASE; lottery.purchaseToken.safeTransfer(treasury, treasuryAmount); lottery.purchaseToken.safeTransfer(_msgSender(), lottery.totalRaised - treasuryAmount); } }",
        "labels": [
            "SlowMist",
            "Cross Send V1.0.1",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Round plan security reminder",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Send V1.0.1_en-us.pdf",
        "body": "And the new round of lottery can only be opened when the last round of lottery is in WinnerDrawn, otherwise randomGenerator.latestLotteryId will be updated, which will cause the old lottery round to fail to execute drawWinner function due to this check. require(lotteryId == randomGenerator.latestLotteryId(), \"numbers not drawn\"); hotdrop/contracts/HotDrop.sol#L44-L256 function drawWinner(uint256 lotteryId) external nonReentrant { Lottery storage lottery = lotteries[lotteryId]; require(lottery.status == Status.Close, \"lottery still active\"); require(lotteryId == randomGenerator.latestLotteryId(), \"numbers not drawn\"); // get the winning number based on the randomResult generated by ChainLink's fallback uint256 winningNumber = randomGenerator.randomResult(); lottery.winningNumber = winningNumber; lottery.status = Status.WinnerDrawn; emit LotteryNumberDrawn(lotteryId, winningNumber); }",
        "labels": [
            "SlowMist",
            "Cross Send V1.0.1",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Trustin_en_us.pdf",
        "body": "In the Comptroller, CToken, SimplePriceOracle, and Unitroller contracts, the admin role can modify key sensitive parameters such as the manager roles, the rate model, the market, the pause status, the whitelist, the price of the underlying asset, and the admin role, which will lead to the risk of over-privilege of the admin role. ",
        "labels": [
            "SlowMist",
            "Trustin_en_us",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Decimal loss with an empty marke",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Trustin_en_us.pdf",
        "body": "If there are two markets, one of which was used by the UI, one of which was empty. Someone can mint collateral tokens in an empty market and redeem most minted tokens, then donate redeemed asset tokens to inate the exchange rate through the getAccountSnapshot function. Next, borrow a dierent asset with the manipulated exchange rate, and redeem collateral to recover donation. However, the redeemUnderlying function may wrongly be rounded down on the tokens to remove from a malicious caller, which causes the redemption of many tokens only to require little underlying assets. The last, liquidation borrower contract position with borrowed funds and redeem collateral tokens to reset the empty market. Reference: https://www.comp.xyz/t/hundred-nance-exploit-and-compound-v2/4266 ",
        "labels": [
            "SlowMist",
            "Trustin_en_us",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Receive can lock users native tokens",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Trustin_en_us.pdf",
        "body": "There is a receive function in the CErc20Delegator, Timelock, and Unitroller contracts so that the contracts can receive native tokens. However, the receive function can lock users native tokens when users transfer the native token in these contracts by mistake and there is no token processing logic. ",
        "labels": [
            "SlowMist",
            "Trustin_en_us",
            "Type: Others",
            "Severity: Low"
        ]
    },
    {
        "title": "Missing the event record",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Trustin_en_us.pdf",
        "body": "The admin role can modify the compAddress parameter, but there are no event logs in these functions. ",
        "labels": [
            "SlowMist",
            "Trustin_en_us",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "External call reminder",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Trustin_en_us.pdf",
        "body": "In the Comptroller contract, users can call the claimZnt to claim the comp in markets, but the implementation address is seting by the admin and the import Zenith is not in the audit scope. ",
        "labels": [
            "SlowMist",
            "Trustin_en_us",
            "Type: Unsafe External Call Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing event record",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cell Core_en-us.pdf",
        "body": "The following functions do not log events. contracts/Cell.sol updateStageRecordMaxCount updateStageRecordCostPoint updateStageRecordIncPoint updateStageRecordValid addSigner removeSigner setProxyer contracts/Nucleus.sol setOracleAddress contracts/Oracle.sol addOracleAddress removeOracleAddress setTokenNameAddress setRates setRatePeriod setFixedPrice revokeFixedPrice contracts/Proxy.sol setOracleAddress setCellAddress setMintPrice",
        "labels": [
            "SlowMist",
            "Cell Core",
            "Type: Malicious Event Log Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Safe transfer issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cell Core_en-us.pdf",
        "body": "contracts/Nucleus.sol Use transferFrom in the claim function to transfer the token. If the token in the operation does not meet the eip20 standard, the transaction may fail. contracts/Proxy.sol Use transferFrom in the mint function to transfer the token. If the token in the operation does not meet the eip20 standard, the transaction may fail.",
        "labels": [
            "SlowMist",
            "Cell Core",
            "Type: Others",
            "Severity: Low"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cell Core_en-us.pdf",
        "body": "contracts/Cell.sol The owner has too much authority, and if the owner's private key is leaked, the attacker can control the casting of NFT. contracts/Oracle.sol The owner has too much authority. If the owner's private key is leaked, the attacker can manipulate the price by setting setRates and setFixedPrice . contracts/Proxy.sol The owner's authority is too large. If the owner's private key is leaked, the attacker can withdraw the revenue in the contract. You can also set a malicious Oracle contract through setOracleAddress to control the price. contracts/Nucleus.sol The owner has too much authority. If the owner's private key is leaked, the attacker can set a malicious Oracle contract through setOracleAddress to control the price.",
        "labels": [
            "SlowMist",
            "Cell Core",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Preemptive Initialization",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Doubler - 20240117.pdf",
        "body": "contracts/FRNFT.sol This function has the problem of being preempted. function initialize(address doublerPool) external { require(_initialized == false, \"initialized err\"); _initialized = true; _doublerPool = doublerPool; _grantRole(DOUBLER_ROLE, doublerPool); } contracts/Doubler.sol This function has the problem of being preempted. function initialize( address _initTeam, address _initEco, address _initFastPriceFeed, address _initDoublerNFT, address _initDbrTokenAddress, address _initMultiSigWallet, uint16 _initProtectBlock ) external { if (_initialized == true) revert E_Initialized(); _initialized = true; _team = _initTeam; _eco = _initEco; _fastPriceFeed = _initFastPriceFeed; _FRNFT = _initDoublerNFT; _ecoFeeRatio = 2000; // 20% * 100 _feeRatio = 20; // 0.2% * 100 _protectBlock = _initProtectBlock; _grantRole(DEFAULT_ADMIN_ROLE, _initMultiSigWallet); emit Initialize(_initTeam, _initFastPriceFeed, _initDoublerNFT, _initDbrTokenAddress, _initMultiSigWallet); }",
        "labels": [
            "SlowMist",
            "Doubler - 20240117",
            "Type: Race Conditions Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Doubler - 20240117.pdf",
        "body": "contracts/FastPriceFeed.sol The admin role can be set to price related, if the private key leakage will cause the price anomaly caused by the pool function is impaired. admin can newAsset admin can updatePriceAggregator admin can upgradePlan admin can setTwapInterval",
        "labels": [
            "SlowMist",
            "Doubler - 20240117",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Pool depth and TWAP interval in uniswap V3 price queries",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Doubler - 20240117.pdf",
        "body": "contracts/FastPriceFeed.sol When getting the price of the token, you should pay attention to the depth of the corresponding pool, if the depth of the pool is too shallow and the price range is set too low, there is still a possibility of price manipulation. function getPriceFromDex(address _asset) internal view returns (uint256 price) { require(_isSupported[_asset], 'UniV3: oracle in mainnet not initialized yet!'); address uniswapV3Pool = _assetFeedMap[_asset]; uint32 twapInterval = _twapIntervals[_asset]; IUniswapV3Pool pool = IUniswapV3Pool(uniswapV3Pool); IUniswapV3Pool.Slot0 memory slot0; IUniswapV3Pool.Observation memory obs; slot0 = pool.slot0(); obs = pool.observations((slot0.observationIndex + 1) % slot0.observationCardinality); require(obs.initialized, \"UNIV3: Pair did't initialized\"); uint32 delta = uint32(block.timestamp) - obs.blockTimestamp; require(delta >= twapInterval, 'UniV3: token pool does not have enough transaction history in mainnet'); uint32[] memory secondsAgos = new uint32[](2); secondsAgos[0] = twapInterval; secondsAgos[1] = 0; (int56[] memory tickCumulatives, ) = pool.observe(secondsAgos); uint160 sqrtPriceX96 = TickMath.getSqrtRatioAtTick( int24((tickCumulatives[1] - tickCumulatives[0]) / int56(uint56(twapInterval))) ); (uint256 price0, uint256 price1) = mockDexPrice(pool, sqrtPriceX96); return pool.token0() == _asset ? price0 : price1; }",
        "labels": [
            "SlowMist",
            "Doubler - 20240117",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Recommendations on the conditions of winner",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Doubler - 20240117.pdf",
        "body": "contracts/Doubler.sol In some extreme cases, it may be possible to control the nal winner.",
        "labels": [
            "SlowMist",
            "Doubler - 20240117",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Suggestions for setTwapInterval",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Doubler - 20240117.pdf",
        "body": "contracts/FastPriceFeed.sol It should be a supported token to set the interval. function setTwapInterval(address _asset, uint32 _twapInterval) external onlyRole(DEFAULT_ADMIN_ROLE) { require(!_isSupported[_asset], 'Oracle: do not support this token'); require(_plans[_asset] == Plan.DEX, \"setTwapInterval: Only dex _asset\"); require( MAX_INTERVA >= _twapIntervals[_asset] && _twapIntervals[_asset] >= MIN_INTERVA, 'setTwapInterval: Invalid twapInterval' ); emit SetTwapInterval(_asset, _twapIntervals[_asset], _twapInterval); _twapIntervals[_asset] = _twapInterval; }",
        "labels": [
            "SlowMist",
            "Doubler - 20240117",
            "Type: Others",
            "Severity: Low"
        ]
    },
    {
        "title": "Redundant code",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Doubler - 20240117.pdf",
        "body": "contracts/Doubler.sol The hot in the structure is not used. struct Pool { address asset; address creator; address terminator; uint16 fallRatio; uint16 profitRatio; uint16 rewardRatio; uint16 winnerRatio; uint32 double; uint32 lastLayer; uint256 tokenId; uint256 unitSize; uint256 maxRewardUnits; uint256 winnerOffset; uint256 endPrice; uint256 hot; //SLOWMIST// unused uint256 lastOpenPrice; uint256 tvl; uint256 amount; uint256 margin; uint256 joins; uint256 lastInputBlockNo; uint256 kTotal; }",
        "labels": [
            "SlowMist",
            "Doubler - 20240117",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Function permission control issues",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Doubler - 20240117.pdf",
        "body": "contracts/FRNFT.sol The roles used by these functions are not set and cannot be executed subsequently. setTokenRoyalty resetTokenRoyalty setDefaultRoyaltyInfo deleteDefaultRoyalty",
        "labels": [
            "SlowMist",
            "Doubler - 20240117",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Overlooking purchase price relative to target prot in pool ending logic",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Doubler - 20240117.pdf",
        "body": "contracts/Doubler.sol The scenario where the purchase price is less than or equal to the target prot price has not been considered. When the price at the time of purchase is less than or equal to the target prot price, the purchase should not be allowed. Otherwise, users can manipulate the ending of the pool after purchasing to position themselves as the winner. function _input(AddInput memory _addInput, uint8 _decimals) internal returns (uint256 tokenId) { Pool memory pool = _poolMap[_addInput.poolId]; if (_addInput.margin == 0 || _addInput.margin > _addInput.amount || _addInput.margin.mod(pool.unitSize) != 0) revert E_Margin(); if (IERC20(pool.asset).allowance(_msgSender(), address(this)) < _addInput.margin) revert E_Approve(); if (IERC20(pool.asset).balanceOf(_msgSender()) < _addInput.margin) revert E_Balance(); if (_addInput.multiple < 1 || _addInput.margin.mul(_addInput.multiple) != _addInput.amount) revert E_Multiple(); if (_addInput.multiple > 1 && _addInput.multiple > _getMaxMultiple(pool, _addInput.curPrice, _decimals)) revert E_MultipleLimit(); _addInput.layer = _getLastLayer(_addInput.poolId, _addInput.curPrice, _addInput.amount); LayerData memory layer = _layerDataMap[_addInput.poolId][_addInput.layer]; if (layer.amount >= layer.cap) revert E_LayerCap(); if (layer.cap.sub(layer.amount) < _addInput.margin) { _addInput.margin = _addInput.amount = layer.cap.sub(layer.amount); } else { _addInput.amount = layer.cap.sub(layer.amount) < _addInput.amount ? layer.cap.sub(layer.amount) : _addInput.amount; } IERC20(pool.asset).safeTransferFrom(_msgSender(), address(this), _addInput.margin); uint256 layerAmount = _addTvl(_addInput); uint256 layerRanking = layerAmount.div(pool.unitSize); tokenId = IFRNFT(_FRNFT).mint( _msgSender(), _addInput.poolId, _addInput.layer, _addInput.margin, _addInput.amount, _addInput.curPrice, layerRanking ); emit NewInput( tokenId, _addInput.poolId, _msgSender(), _addInput.layer, _addInput.margin, _addInput.amount, _addInput.curPrice ); }",
        "labels": [
            "SlowMist",
            "Doubler - 20240117",
            "Type: Others",
            "Severity: High"
        ]
    },
    {
        "title": "Excessive Authority Issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - wault.finance(WEXPolyMaster)_en-us.pdf",
        "body": "The owner can set the value of wexPerBlock arbitrarily, which will affect the profit of wexReward, and there is no limit on the value range of wexPerBlock, and there is a issue of excessive authority. https://polygonscan.com/address/0xC8Bd86E5a132Ac0bf10134e270De06A8Ba317BFe#code function setWexPerBlock(uint256 _wexPerBlock) public onlyOwner { require(_wexPerBlock > 0, \"!wexPerBlock-0\"); wexPerBlock = _wexPerBlock; } Owner can add pool, can set the allocPoint of pool, there is a issue of selfish mining. function add( uint256 _allocPoint, IERC20 _lpToken, bool _withUpdate ) public onlyOwner { if (_withUpdate) { massUpdatePools(); } uint256 lastRewardBlock = block.number > startBlock ? block.number : startBlock; totalAllocPoint = totalAllocPoint.add(_allocPoint); poolInfo.push( 6 PoolInfo({ lpToken: _lpToken, allocPoint: _allocPoint, lastRewardBlock: lastRewardBlock, accWexPerShare: 0 }) ); function set( uint256 _pid, uint256 _allocPoint, bool _withUpdate ) public onlyOwner { if (_withUpdate) { massUpdatePools(); } totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add( _allocPoint ); poolInfo[_pid].allocPoint = _allocPoint; }",
        "labels": [
            "SlowMist",
            "wault.finance(WEXPolyMaster)",
            "Type: Others",
            "Severity: Low"
        ]
    },
    {
        "title": "Event log missing",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - earning.farm_en-us.pdf",
        "body": "12 contracts/core/EFLeverVault.sol Modifying important variables in the contract requires corresponding event records. function initAddresses(address[7] memory addr) public onlyOwner{ aave = addr[0]; balancer = addr[1]; balancer_fee = addr[2]; lido = addr[3]; asteth = addr[4]; curve_pool = addr[5]; weth = addr[6]; } contracts/core/EFCRVVault.sol Modifying important variables in the contract requires corresponding event records. function initAddresses(address[11] memory addr) public onlyOwner{ crv = addr[0]; usdc = addr[1]; eth_usdc_router = addr[2]; weth = addr[3]; cvxcrv = addr[4]; eth_crv_router = addr[5]; crv_cvxcrv_router = addr[6]; eth_usdt_router = addr[7]; usdt = addr[8]; oracle = addr[9]; staker = addr[10]; }",
        "labels": [
            "SlowMist",
            "earning.farm",
            "Type: Malicious Event Log Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - earning.farm_en-us.pdf",
        "body": "contracts/core/EFLeverVault.sol The owner's authority is too large. If the private key is lost, the attacker can use the pause function to transfer the funds in the contract through callWithData ,or directly transfer astheth. function callWithData(address payable to, bytes memory data, uint256 amount)public payable onlyOwner{ (bool status, ) = to.call.value(amount)(data); require(status, \"call failed\"); } function delegateCallWithData(address payable to, bytes memory data)public payable onlyOwner{ (bool status, ) = to.delegatecall(data); require(status, \"call failed\"); }",
        "labels": [
            "SlowMist",
            "earning.farm",
            "Type: Authority Control Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Potential Sandwich Attack Risk",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - earning.farm_en-us.pdf",
        "body": "contracts/core/EFCRVVault.sol 14 it will perform the token swap operation through the swapExactTokensForTokens function. But the incoming minAmountOut is 0 , which will not do slippage checking,There is a risk of being attacked by sandwiches. function depositStable(uint256 _amount) public payable nonReentrant{ require(!is_paused, \"paused\"); require(IERC20(usdc).allowance(msg.sender, address(this)) >= _amount, \"CFVault: not enough allowance\"); IERC20(usdc).safeTransferFrom(msg.sender, address(this), _amount); if (IERC20(usdc).allowance(address(this), eth_usdc_router) != 0){ IERC20(usdc).approve(eth_usdc_router, 0); } IERC20(usdc).approve(eth_usdc_router, _amount); uint256 weth_before = IERC20(weth).balanceOf(address(this)); address[] memory t = new address[](2); t[0] = usdc; t[1] = weth; UniswapV3Interface(eth_usdc_router).swapExactTokensForTokens(_amount, 0, t, address(this)); uint256 weth_amount = IERC20(weth).balanceOf(address(this)).safeSub(weth_before); if (IERC20(weth).allowance(address(this), eth_crv_router) != 0){ IERC20(weth).approve(eth_crv_router, 0); } IERC20(weth).approve(eth_crv_router, weth_amount); uint256 tt_before = IERC20(crv).balanceOf(address(this)); CurveInterface256(eth_crv_router).exchange(0, 1, weth_amount, 0); uint256 tt_amount = IERC20(crv).balanceOf(address(this)).safeSub(tt_before); _deposit(_amount, tt_amount); }",
        "labels": [
            "SlowMist",
            "earning.farm",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Potential Sandwich Attack Risk",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - earning.farm_en-us.pdf",
        "body": "contracts/core/EFCRVVault.sol it will perform the token swap operation through the swapExactTokensForTokens function. But the incoming minAmountOut is 0 , which will not do slippage checking,There is a risk of being attacked by sandwiches. function withdraw(uint256 _amount, bool _use_stable) public nonReentrant{ require(!is_paused, \"paused\"); { uint256 total_balance = IERC20(ef_token).balanceOf(msg.sender); require(total_balance >= _amount, \"not enough LP tokens\"); } uint256 target_amount; { //if (IERC20(ef_token).totalSupply() == 0) require(false, \"000\"); uint256 lp_amount = _amount.safeMul(lp_balance).safeDiv(IERC20(ef_token).totalSupply()); uint256 target_before = IERC20(crv).balanceOf(address(this)); _withdraw(lp_amount); target_amount = IERC20(crv).balanceOf(address(this)).safeSub(target_before); } uint256 f = 0; if(withdraw_fee_ratio != 0 && fee_pool != address(0x0)){ f = target_amount.safeMul(withdraw_fee_ratio).safeDiv(ratio_base); target_amount = target_amount.safeSub(f); IERC20(crv).transfer(fee_pool, f); TokenInterfaceERC20(ef_token).destroyTokens(msg.sender, _amount); }else{ TokenInterfaceERC20(ef_token).destroyTokens(msg.sender, _amount); } if (!_use_stable){ IERC20(crv).transfer(msg.sender, target_amount); emit CFFWithdraw(msg.sender, target_amount, target_amount.safeMul(uint256(ChainlinkInterface(oracle).latestAnswer())).safeDiv(1e2 16 0), _amount, f, getVirtualPrice()); } else{ if (IERC20(crv).allowance(address(this), eth_crv_router) != 0){ IERC20(crv).approve(eth_crv_router, 0); } IERC20(crv).approve(eth_crv_router, target_amount); uint256 weth_amount; { uint256 weth_before = IERC20(weth).balanceOf(address(this)); CurveInterface256(eth_crv_router).exchange(1, 0, target_amount, 0); weth_amount = IERC20(weth).balanceOf(address(this)).safeSub(weth_before); } if (IERC20(weth).allowance(address(this), eth_usdc_router) != 0){ IERC20(weth).approve(eth_usdc_router, 0); } IERC20(weth).approve(eth_usdc_router, weth_amount); uint256 usdc_amount; { address[] memory t = new address[](2); t[0] = weth; t[1] = usdc; uint256 usdc_before = IERC20(usdc).balanceOf(address(this)); UniswapV3Interface(eth_usdc_router).swapExactTokensForTokens(weth_amount, 0, t, address(this)); usdc_amount = IERC20(usdc).balanceOf(address(this)).safeSub(usdc_before); } IERC20(usdc).transfer(msg.sender, usdc_amount); emit CFFWithdraw(msg.sender, target_amount, usdc_amount, _amount, f, getVirtualPrice()); } }",
        "labels": [
            "SlowMist",
            "earning.farm",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Redundant code",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - earning.farm_en-us.pdf",
        "body": "contracts/erc20/ERC20Impl.sol onTransferDone function not being called function onTransferDone(address _from, address _to, uint256 _amount) internal { for(uint i = 0; i < transferListeners.length; i++){ TransferEventCallBack t = TransferEventCallBack(transferListeners[i]); t.onTransfer(_from, _to, _amount); } }",
        "labels": [
            "SlowMist",
            "earning.farm",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Redundant code",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - earning.farm_en-us.pdf",
        "body": "contracts/core/EFLeverVault.sol IERC20(weth).balanceOf(address(this)) return result unused. function raiseActualLTV(uint256 lt) public onlyOwner{//take lt = 7500 uint256 e = getDebt(); uint256 st = getCollecteral(); require(e.safeMul(10000) < st.safeMul(mlr), \"no need to raise\"); uint256 x = st.safeMul(mlr).safeSub(e.safeMul(10000)).safeDiv(uint256(10000).safeSub(mlr));//x = 18 (mST-E)/(1-m) uint256 y = st.safeMul(lt).safeDiv(10000).safeSub(e).safeSub(1); if (x > y) {x = y;} IAAVE(aave).borrow(weth, x, 2, 0, address(this)); IWETH(weth).withdraw(IERC20(weth).balanceOf(address(this))); ILido(lido).submit.value(address(this).balance)(address(this)); IERC20(weth).balanceOf(address(this));//SlowMist//return result unused if (IERC20(lido).allowance(address(this), aave) != 0) {IERC20(lido).safeApprove(aave, 0);} IERC20(lido).safeApprove(aave, IERC20(lido).balanceOf(address(this))); IAAVE(aave).deposit(lido, IERC20(lido).balanceOf(address(this)), address(this), 0); emit ActualLTVChanged(e, st, getDebt(), getCollecteral()); }",
        "labels": [
            "SlowMist",
            "earning.farm",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - earning.farm_en-us.pdf",
        "body": "contracts/core/EFLeverVault.sol If the owner permission is lost, the attacker can achieve free recharge by changing the address of the token, thereby taking away the funds in the contract. function initAddresses(address[7] memory addr) public onlyOwner{ aave = addr[0]; balancer = addr[1]; balancer_fee = addr[2]; lido = addr[3]; 19 asteth = addr[4]; curve_pool = addr[5]; weth = addr[6]; emit CFFNewAddress(addr); } contracts/core/EFCRVVault.sol function initAddresses(address[11] memory addr) public onlyOwner{ crv = addr[0]; usdc = addr[1]; eth_usdc_router = addr[2]; weth = addr[3]; cvxcrv = addr[4]; eth_crv_router = addr[5]; crv_cvxcrv_router = addr[6]; eth_usdt_router = addr[7]; usdt = addr[8]; oracle = addr[9]; staker = addr[10]; emit CFFNewAddress(addr); }",
        "labels": [
            "SlowMist",
            "earning.farm",
            "Type: Authority Control Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - earning.farm_en-us.pdf",
        "body": "contracts/core/EFCRVVault.sol 20 delegateCallWithData is an arbitrary external call, if the private key is lost the attacker can unstake and transfer the funds And for users who have previously authorized the current contract, the attacker can transfer funds that are not operated by the user himself by constructing a malicious contract. function delegateCallWithData(address payable to, bytes memory data)public payable onlyOwner{ (bool status, ) = to.delegatecall(data); require(status, \"call failed\"); }",
        "labels": [
            "SlowMist",
            "earning.farm",
            "Type: Authority Control Vulnerability",
            "Severity: Critical"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Bitlayer Bridge.pdf",
        "body": "1.The BitlayerBridge contracts are implemented using the OpenZeppelin upgradeable model, allowing the AdminRole role to perform contract upgrades. However, this design introduces an excessive privilege risk. 2.In the BitlayerBridge contract, the UnlockRole role can call the unlock function to unlock the ETH locked in the contract; the LiquidityRole role can call the removeLiquidityTo function to remove the liquidity of any address. BitlayerBridge.sol#L125-L134,L148-L163 function removeLiquidityTo(address to, uint256 amount) external onlyRole(LiquidityRole) whenNotPaused { ``` } function unlock(string memory _txHash, address to, uint256 amount) external onlyRole(UnlockRole) whenNotPaused { ``` } } 3.In the BitlayerBridge contract, AdminRole role can set important parameters of the contract. BitlayerBridge.sol function setFeeAddress function setLockFee function setMinLockAmount function setMaxLockAmount",
        "labels": [
            "SlowMist",
            "Bitlayer Bridge",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Missing zero address check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Bitlayer Bridge.pdf",
        "body": "In the BitlayerBridge contract, the zero address check is missing in the initialize function and unlock function. BitlayerBridge.sol#L36-L75,L148-L163 function initialize(  ) public initializer {  feeAddress = _feeAddress;  } function unlock(string memory _txHash, address to, uint256 amount) external onlyRole(UnlockRole) whenNotPaused {  (bool success, bytes memory returndata) = payable(to).call{value: amount} (\"\");  }",
        "labels": [
            "SlowMist",
            "Bitlayer Bridge",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Return value not checked",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Bitlayer Bridge.pdf",
        "body": "In the BitlayerBridge contract, the return value is not checked when the initialize function calls the _grantRole function. BitlayerBridge.sol#L36-L75 function initialize( ``` ) public initializer { _grantRole(AdminRole, admin); ``` }",
        "labels": [
            "SlowMist",
            "Bitlayer Bridge",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Parameter Validation Missing in unlock Function",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Bitlayer Bridge.pdf",
        "body": "In the BitlayerBridge contract, the unlock function does not verify the validity of the parameters passed in. The UnlockRole role can enter any _txHash (not recorded by txUnlocked mapping) and amount to unlock the ETH in the contract and transfer it to the specied address. BitlayerBridge.sol#L148-L163 function unlock(string memory _txHash, address to, uint256 amount) external onlyRole(UnlockRole) whenNotPaused { bytes32 txHash = keccak256(abi.encode(_txHash)); require(!txUnlocked[txHash], \"txHash already unlocked\"); txUnlocked[txHash] = true; (bool success, bytes memory returndata) = payable(to).call{value: amount} (\"\"); require(success, string(returndata)); totalUnlocked += amount; emit NativeUnlocked(_txHash, to, amount); }",
        "labels": [
            "SlowMist",
            "Bitlayer Bridge",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Min lock amount not checked against max",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Bitlayer Bridge.pdf",
        "body": "In the BitlayerBridge contract, whether the variable minLockAmount is less than the variable maxLockAmount is not checked in the initialize function, setMinLockAmount function, and setMaxLockAmount function. If the variable minLockAmount is greater than the variable maxLockAmount , the lock function cannot be used. BitlayerBridge.sol#L41-L85,L113-L118,L120-L125 function initialize( ``` ) public initializer { ``` minLockAmount = _minLockAmount; maxLockAmount = _maxLockAmount; } function setMinLockAmount(uint256 min) external onlyRole(AdminRole) { uint256 oldMin = minLockAmount; minLockAmount = min; emit MinLockAmountSet(oldMin, min); } function setMaxLockAmount(uint256 max) external onlyRole(AdminRole) { uint256 oldMax = maxLockAmount; maxLockAmount = max; emit MaxLockAmountSet(oldMax, max); }",
        "labels": [
            "SlowMist",
            "Bitlayer Bridge",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Reentrancy risks",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DappOS Contracts Core.pdf",
        "body": "In the PayDB contract, the executeDstOrderETH , executeDstOrderETH , tryExecuteDstOrderETH , cancelOrderETH , _executeIsolateOrder , and _createSrcOrder functions do not add anti-reentrancy locks, and there is a risk of reentrancy attacks when calling the safeTransferETH function. contracts/core/PayDB.sol#L75-L153,L162-L249,L287-L335,L337-L383,L385-L475 function executeDstOrderETH( address orderOwner, address receiver, address wallet, ExePayOrderParam[] calldata eparams, IVWManager.VWExecuteParam calldata vwExeParam ) external payable override{ ```` if (eparams[i].tokenOut == address(0)) { TransferHelper.safeTransferETH( _realReceiver, eparams[i].amountOut ); totalETH += eparams[i].amountOut; } else { TransferHelper.safeTransferFrom( eparams[i].tokenOut, msg.sender, _realReceiver, eparams[i].amountOut ); } ```` } function tryExecuteDstOrderETH( address orderOwner, address receiver, address wallet, ExePayOrderParam[] calldata eparams, IVWManager.VWExecuteParam calldata vwExeParam ) external payable override { ```` if (eparams[i].tokenOut == address(0)) { TransferHelper.safeTransferETH( _realReceiver, eparams[i].amountOut ); totalETH += eparams[i].amountOut; } else { TransferHelper.safeTransferFrom( eparams[i].tokenOut, msg.sender, _realReceiver, eparams[i].amountOut ); } ```` } function cancelOrderETH( address sender, address receiver, CreatePayOrderParam[] calldata cparams, bytes32[] calldata workFlowHashs ) external payable override { ```` require(msg.value == totalETH,\"E18\"); if(totalETH > 0){ TransferHelper.safeTransferETH(sender, msg.value); } ```` } function _executeIsolateOrder( address receiver, address wallet, ExePayOrderParam[] calldata eparams, IVWManager.VWExecuteParam calldata vwExeParam ) internal { ```` if (eparams[i].tokenOut == address(0)) { TransferHelper.safeTransferETH( receiver, eparams[i].amountOut ); totalETH += eparams[i].amountOut; } else { TransferHelper.safeTransferFrom( eparams[i].tokenOut, msg.sender, receiver, eparams[i].amountOut ); } ```` } function _createSrcOrder( address _orderOwner, address wallet, address receiver, CreatePayOrderParam[] calldata cparams, VwOrderDetail calldata vwDetail, CallParam calldata callParam ) internal { ```` if (cparams[i].tokenIn == address(0)) { // Transfer ETH to node TransferHelper.safeTransferETH( cparams[i].node, cparams[i].amountIn ); totalEth += cparams[i].amountIn; } else { // Transfer ERC20 to node TransferHelper.safeTransferFrom( cparams[i].tokenIn, msg.sender, cparams[i].node, cparams[i].amountIn ); } ```` }",
        "labels": [
            "SlowMist",
            "DappOS Contracts Core",
            "Type: Reentrancy Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Unauthorized information status modication",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DappOS Contracts Core.pdf",
        "body": "In the storeInfo function of the VWManager contract, we found the following issues 1. Any user can set the willDelete parameter of information stored by other users to false, thereby deleting infoSender[infoHash] so that it cannot be deleted. 2. Key Parameter Settings Unrecorded Events. 3. The function may be subject to MEV attacks, causing the user to store infoSender[infoHash] = msg.sender as the attacker's address when storing information. contracts/core/vwmanager/VWManager.sol#L295-L311 function storeInfo( bytes calldata info, bool willDelete ) external { if(info.length > 0){ bytes32 infoHash = keccak256(info); if(eip1271Info[infoHash].length == 0){ eip1271Info[infoHash] = info; emit InfoStored(infoHash, info); if(willDelete){ infoSender[infoHash] = msg.sender; } } else if(!willDelete) { delete infoSender[infoHash]; } } }",
        "labels": [
            "SlowMist",
            "DappOS Contracts Core",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Unveried feeReceiver parameter",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DappOS Contracts Core.pdf",
        "body": "The cancelTx , changeOwner , approveResetter , and resetOwner functions of the VWManagerService contract, the feeReceiver parameter is not veried. It may be subject to MEV attack risk. The attacker replaces the feeReceiver parameters, causing losses. contracts/core/vwmanager/VWManagerService.sol#L53-L92,L123-L161,L177-L217,L227-L256 function cancelTx( uint256 code, address wallet, uint256 codeToCancel, FeeParam calldata fParam, bytes calldata signature ) external {  bytes32 dataHash = keccak256( abi.encode( CANCEL_TYPEHASH, code, codeToCancel, fParam.gasToken, fParam.gasTokenPrice, fParam.priorityFee, fParam.gasLimit ) ); result[walletOwner[wallet]][codeToCancel] = uint256(CodeStatus.CANCELED); result[walletOwner[wallet]][code] = uint256(CodeStatus.SUCCEED); emit TxCanceled(codeToCancel); verifyOperation( walletOwner[wallet], domainSeparator[srcChain], dataHash, signature, CANCEL_TYPEHASH ); _walletPayFee(wallet, preGas, fParam); } function changeOwner( uint256 code, address wallet, address newOwner, FeeParam calldata fParam, bytes calldata signature ) external {  bytes32 dataHash = keccak256( abi.encode( CHANGE_OWNER_TX_TYPEHASH, code, newOwner, fParam.gasToken, fParam.gasTokenPrice, fParam.priorityFee, fParam.gasLimit ) ); address previousOwner = _resetOwner(wallet, newOwner); result[walletOwner[wallet]][code] = uint256(CodeStatus.SUCCEED); verifyOperation( previousOwner, domainSeparator[srcChain], dataHash, signature, CHANGE_OWNER_TX_TYPEHASH ); _walletPayFee(wallet, preGas, fParam); } function approveResetter( uint256 code, address wallet, address resetter, bool approved, FeeParam calldata fParam, bytes calldata signature ) external returns (bytes32 dataHash) {  dataHash = keccak256( abi.encode( RESETTER_APPROVE_TYPEHASH, code, resetter, approved, fParam.gasToken, fParam.gasTokenPrice, fParam.priorityFee, fParam.gasLimit ) ); approvedResetter[wallet] = approved ? resetter : address(0); emit ResetterChanged(approvedResetter[wallet]); result[walletOwner[wallet]][code] = uint256(CodeStatus.SUCCEED); verifyOperation( walletOwner[wallet], domainSeparator[srcChain], dataHash, signature, RESETTER_APPROVE_TYPEHASH ); _walletPayFee(wallet, preGas, fParam); } function resetOwner( uint256 code, address wallet, address newOwner, FeeParam calldata fParam, bytes calldata data ) external nonReentrant{  require ( IVWResetter(approvedResetter[wallet]).verify( wallet, newOwner, data, fParam.gasToken, fParam.gasTokenPrice, fParam.priorityFee, fParam.gasLimit ), \"E5\"); _resetOwner(wallet, newOwner); result[walletOwner[wallet]][code] = uint256(CodeStatus.SUCCEED); _walletPayFee(wallet, preGas, fParam); }",
        "labels": [
            "SlowMist",
            "DappOS Contracts Core",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Reentrancy risks",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DappOS Contracts Core.pdf",
        "body": "In the PayLock contract, the deposit function does not add an anti-reentrancy lock, and there is a risk of reentrancy attacks when calling the safeTransferFrom function. contracts/core/PayLock.sol#L73-L78 function deposit(address token, uint amount, address node) external { uint256 beforeTransfer = IERC20(token).balanceOf(address(this)); TransferHelper.safeTransferFrom(token, msg.sender, address(this), amount); uint256 afterTransfer = IERC20(token).balanceOf(address(this)); _deposit(token, afterTransfer - beforeTransfer, node); }",
        "labels": [
            "SlowMist",
            "DappOS Contracts Core",
            "Type: Reentrancy Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DappOS Contracts Core.pdf",
        "body": "Owner accounts can operate the key functions. PayLock punish PayLock configToken PayLock configWithdrawPendingTime VWManager configFee VWManager VWManager requestConfigSrcChain configSrcChain",
        "labels": [
            "SlowMist",
            "DappOS Contracts Core",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Unveried manager and feeReceiver parameter",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DappOS Contracts Core.pdf",
        "body": "In the verifyProof function of the VWManager contract, only the 8 parameters in vweParam were veried, and the manager and feeReceiver parameters were not veried. contracts/core/vwmanager/VWManager.sol#L113-L145 function verifyProof(uint resCode, address wallet, VWExecuteParam calldata vweParam) internal { address vwOwner = walletOwner[wallet]; result[vwOwner][vweParam.code] = resCode; (uint256 dstChainId, uint256 srcChain, uint256 expTime) = VWCode.chainidsAndExpTime(vweParam.code); require(dstChainId == block.chainid, 'E3'); require(block.timestamp <= expTime, 'E6'); require(domainSeparator[srcChain] != bytes32(0), 'E31'); bytes32 rootHash = keccak256( abi.encode( APPROVE_SERVICE_TX_TYPEHASH, vweParam.code, keccak256(vweParam.data), vweParam.service, vweParam.gasToken, vweParam.gasTokenPrice, vweParam.priorityFee, vweParam.gasLimit, vweParam.isGateway ) ); if (vweParam.proof.length > 0) { rootHash = MerkleProof.processProof(vweParam.proof, rootHash); rootHash = keccak256(abi.encode(APPROVE_SERVICE_PROOF_TX_TYPEHASH, rootHash)); } // srcChain is the chain where user sign the rootHash if (Address.isContract(vwOwner)) { require(IWalletOwner(vwOwner).verifyVWParam(rootHash, domainSeparator[srcChain], vweParam), 'E1'); } else { SignLibrary.verify(vwOwner, domainSeparator[srcChain], rootHash, vweParam.serviceSignature); } emit TxExecuted(wallet, vwOwner, vweParam.code, rootHash, resCode); }",
        "labels": [
            "SlowMist",
            "DappOS Contracts Core",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Redundant code",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DappOS Contracts Core.pdf",
        "body": "The functions implemented in library OrderId are the same as those in library VWCode. contracts/libraries/OrderId.sol#L7-L17 function genCode( uint128 nonce, uint32 time, uint32 srcChainId, uint32 dstChainId, uint16 oType, uint16 flag ) internal pure returns (uint code){ code = (uint(nonce) << 128) + (uint(time) << 96) + (uint(srcChainId) << 64) + (uint(dstChainId) << 32) + (uint(oType) << 16) + uint(flag); } function chainidsAndExpTime(uint code) internal pure returns (uint dstChainId, uint srcChainId, uint time){ dstChainId = (code >> 32) & ((1 << 32) - 1); srcChainId = (code >> 64) & ((1 << 32) - 1); time = (code >> 96) & ((1 << 32) - 1); }",
        "labels": [
            "SlowMist",
            "DappOS Contracts Core",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Reentrancy risks",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DappOS Contracts Core.pdf",
        "body": "In the PayLock contract punish function, the punishes mapping is not used correctly, resulting in the risk of reentrancy. contracts/governance/PayLock.sol#L131-L159 function punish( uint orderId, address node, address to, address[] calldata tokens, uint[] calldata amounts ) external onlyOwner { require(tokens.length > 0 && tokens.length == amounts.length, \"Invalid length\"); for (uint i = 0; i < tokens.length; i++) { require(validTokens[tokens[i]], \"INVALID_TOKEN\"); TokenBalance storage bal = nodeTokenBalance[node][tokens[i]]; uint256 realAmount = amounts[i]; if (amounts[i] > bal.numOnWithdraw) { if (bal.numTotal <= amounts[i].sub(uint(bal.numOnWithdraw))) { realAmount = uint(bal.numTotal + bal.numOnWithdraw); (bal.numTotal, bal.numOnWithdraw) = (0, 0); } else { bal.numTotal -= (amounts[i] - uint(bal.numOnWithdraw)).toUint128(); bal.numOnWithdraw = 0; } } else { bal.numOnWithdraw = (uint(bal.numOnWithdraw).sub(amounts[i])).toUint128(); } TransferHelper.safeTransfer2(tokens[i], to, realAmount); } punishes[node]++; emit NodePunished(orderId, amounts, tokens, node, to); }",
        "labels": [
            "SlowMist",
            "DappOS Contracts Core",
            "Type: Reentrancy Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Insucient WithdrawPendingTime error",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DappOS Contracts Core.pdf",
        "body": "In the PayLock contract congWithdrawPendingTime function, the withdrawPendingTime parameter should be set to greater than or equal to 7 days. Since congWithdrawPendingTime is associated with the order's term, congWithdrawPendingTime should be greater than the order's term. contracts/governance/PayLock.sol#L168-L172 function configWithdrawPendingTime(uint period) external onlyOwner { require(period <= 7 days, \"E27\"); withdrawPendingTime = period; emit WithdrawPendingTime(period); }",
        "labels": [
            "SlowMist",
            "DappOS Contracts Core",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Unveried Node Mortgage Requirement",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DappOS Contracts Core.pdf",
        "body": "In the PayDB contract, when the user creates an order through the createSrcOrder function or createSrcOrderETH function, it is not veried whether the node's mortgage assets meet the mortgage requirements required for the created order.",
        "labels": [
            "SlowMist",
            "DappOS Contracts Core",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Service nodes are at risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DappOS Contracts Core.pdf",
        "body": "In the PayDB contract, when the user creates an order through the createSrcOrder function or createSrcOrderETH function, he transfer assets to the cparams[i].node , and these nodes are at risk of rug-pull ,or private key leak.",
        "labels": [
            "SlowMist",
            "DappOS Contracts Core",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Redundant collectEndTime check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase3_en-us.pdf",
        "body": "In the CongurableRightsPool contract, users can redeem underlying assets through the exitPool function. When the pool is a closed ETF, it will check isCompletedCollect and collectEndTime to decide whether to perform _claimManagerFee operation. But when isCompletedCollect is true, the collectEndTime check will be performed in snapshotEndAssets, and when isCompletedCollect is false, the collectEndTime check will be performed in exitPoolHandleB. Hence the collectEndTime check before the _claimManagerFee operation is redundant. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase3",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Redundant closureEndTime check on exitPool",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase3_en-us.pdf",
        "body": "In the CongurableRightsPool contract, users can redeem underlying assets through the exitPool function. When the pool is a closed ETF and isCloseEtfCollectEndWithFailure is false, it will check that the current time must be greater than closureEndTime + 5 minutes before allowing the user to exit. However, it should be noted that the snapshotEndAssets operation will be performed before this. The snapshotEndAssets function will also check whether the current time is greater than closureEndTime + 5 minutes . Only the admin and owner can execute snapshotEndAssets within 5 minutes after the closure period ends. Otherwise, the transaction will be reverted. Therefore, the closureEndTime check in the exitPool function is redundant. When snapshotEndAssets cannot be performed, the entire transaction will be reverted, and subsequent closureEndTime checks will not be performed. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase3",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Redundant performance fee calculation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase3_en-us.pdf",
        "body": "In the exitPool function of the CongurableRightsPool contract, redeemAndPerformanceFeeReceived, nalAmountOut and redeemFeeReceived are calculated through exitPoolHandleA. However, since the performance fee will be calculated uniformly in the snapshotEndAssets operation, there is no need to process the performance fee in the exitPool function. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase3",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "The time allowed for snapshots is too short",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase3_en-us.pdf",
        "body": "In the CongurableRightsPool contract when the closed ETF completes collect and the collection period has ended, the current total value of the ETF can be recorded through the snapshotBeginAssets function. However, users can only call the snapshotBeginAssets function within 15 minutes after the end of the collection period. If there is congestion on the chain, it may not be possible to call the snapshot in time within 15 minutes. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase3",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Duplicate decimal processing issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase3_en-us.pdf",
        "body": "In the DesynChainlinkOracle contract, the getPrice function is used to obtain the corresponding token price from prices, getChainlinkPrice, and getUniswapPrice, and perform decimal processing. However, decimal has been processed in getChainlinkPrice and getUniswapPrice, and theoretically, the returned decimal will be 1e18. Therefore, processing decimals through decimalDelta will cause decimals to be enlarged. Note that the amountIn passed in for the consult in the getUniswapPrice function is 1e18, which needs to be ensured that the token decimal in twapOracle matches it in practice ",
        "labels": [
            "SlowMist",
            "DeSyn Phase3",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Decimal processing issue in AllPrice calculation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase3_en-us.pdf",
        "body": "In the DesynChainlinkOracle contract, the getAllPrice function is used to calculate the total value of the specied amount of tokens. It is calculated by badd(fundAll, bmul(getPrice(t), tokenAmountOut)) , theoretically the decimal returned by getPrice is 1e18, and the decimal of tokenAmountOut is consistent with the decimal of the token itself. Therefore, multiplying these two values will result in a very large decimal in the nal result. The getNormalizedWeight function is also aected by this, but this is not harmful to normal business. Note: ",
        "labels": [
            "SlowMist",
            "DeSyn Phase3",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Redundant code issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase3_en-us.pdf",
        "body": "In the SmartPoolManager library, the exitPoolHandle function has been deprecated since closed ETF prots are calculated in snapshotEndAssets. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase3",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Token list conict in recordTokenInfo",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase3_en-us.pdf",
        "body": "When the user performs createPool and joinPool, if the Pool is a closed ETF and the current time is within the collection period, the KOL invitation amount will be recorded through UserVault's recordTokenInfo interface. But unfortunately, the tokens in the Pool can be Bind/unBind at any time, which will cause the list of tokens supported by the Pool to change. If the recordTokenInfo operation is performed when the Pool token list changes, the amount recorded by variables such as poolInviteTotal, kolTotalAmountList, and kolUserInfo may be disturbed. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase3",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "couldManagerClaim not checked when managerClaim",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase3_en-us.pdf",
        "body": "In the UserVault contract, the Manager role can claim management fees through the managerClaim function, but it does not check whether the couldManagerClaim parameter is true. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase3",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Some redundant invoke functions",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase3_en-us.pdf",
        "body": "In the Invoke library, the strictInvokeTransfer, invokeUnwrapWETH, invokeWrapWETH, and invokeMint functions are not used. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase3",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of ETF falsication",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase3_en-us.pdf",
        "body": "In the RebalanceAdapter contract, the Manager role can adjust the position of the pool through the rebalance function. But the address of the ETF is obtained from the rebalanceInfo passed in by the user. If a malicious user passes in a fake ETF, the check in the onlyManager decorator will be bypassed, and the _verifyWhiteToken check of token1 and the isCompletedCollect and collectEndTime checks will be useless. Malicious users can steal bPool funds through _makeSwap and bind malicious tokens. The approve function also has this risk, but it doesn't break the protocol too much ",
        "labels": [
            "SlowMist",
            "DeSyn Phase3",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Risk of the Manager role potentially disrupting the protocol",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase3_en-us.pdf",
        "body": "In the RebalanceAdapter contract, the Manager role can adjust the position of the ETF through the rebalance function. It will use the _makeSwap function to call Uniswap, 1inch and other DEXs for token swaps to adjust token positions. But unfortunately, the swap path of the token is not checked during the token swap process, which will cause the Manager role to pass in a carefully constructed malicious swap path to steal the middle token0 of the ETF. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase3",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Double slippage check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase3_en-us.pdf",
        "body": "In the RebalanceAdapter contract, the Manager role can adjust the position of the ETF through the rebalance function. It will use the _makeSwap function to call Uniswap, 1inch and other DEXs for token swaps to adjust token positions. During the swap process, the slippage will be checked by passing minReturn to the external DEXs, but the implementation of the slippage check of the external DEXs is uncontrollable. If the slippage protection of the external DEXs fails, it will aect the funds of users in the protocol. (1inch users encountered invalid slippage check before) ",
        "labels": [
            "SlowMist",
            "DeSyn Phase3",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Does not follow the Checks-Eects-Interactions specication",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase3_en-us.pdf",
        "body": "In the RebalanceAdapter contract, the _makeSwap function is used for token swap. When the swap type is not UNISWAPV3 and UNISWAPV2, the parameters passed in by the user will be checked through _validateData . However, the execute operation is performed rst, and the _validateData operation is performed after the token exchange is completed. This is not in line with the follow the Checks-Effects-Interactions principle. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase3",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Perform strict parameter checking",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase3_en-us.pdf",
        "body": "In the RebalanceAdapter contract, the _validateData function is used to check the exchange parameters, but it only parses the recipient and amountIn for checking, but does not check whether other key parameters such as srcToken, dstToken, clipperExchange, makerAsset, takerAsset are in line with expectations. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase3",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Redundant aggregator parameter",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase3_en-us.pdf",
        "body": "In the RebalanceAdapter contract, the _validateData function is used to check the conversion parameters, but the aggregator parameter it receives is not used. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase3",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Incorrect approval operation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase3_en-us.pdf",
        "body": "In the RebalanceAdapter contract, the Manager role can adjust the position of the ETF through the rebalance function. If token1 has not been bound in bPool, it will be approved rst. However, the subsidy of this contract was wrongly approved to bPool, which will cause bPool to be unable to transfer tokens from CRP in the future. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase3",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase3_en-us.pdf",
        "body": "There is an execute function in the CRP and bPool contracts so that the Manager can manage the ETF. In bFactory, the Blabs role can arbitrarily register modules to gain control over CRP. The registered modules can use the execute function in CRP to call the execute function in bPool to perform any operations. This would pose a huge risk to users' funds. And the Manager can approve the tokens in the bPool through the approve function of the RebalanceAdapter contract, which will also bring huge risks to the user's funds. The above problems lead to the risk of excessive permissions of the Blabs role and the Manager role. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase3",
            "Type: Authority Control Vulnerability Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Enforce strict permission controls",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase3_en-us.pdf",
        "body": "In the LiquidityPool contract, any user can call the joinPool, exitPool, and gulp functions to add/remove liquidity/record token balances, which will make it impossible to charge various fees to users in CRP. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase3",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Function visibility issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Alpaca Finance Oracle_en-us.pdf",
        "body": "In the OracleMedianizer contract, the user can get the price of the pair token through the getPrice function. The getPrice function will call the _getPrice function to get the price, but the visibility of the _getPrice function is public. ",
        "labels": [
            "SlowMist",
            "Alpaca Finance Oracle",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "The Token Pair Check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Alpaca Finance Oracle_en-us.pdf",
        "body": "There is a _setPriceFeed function in the ChainLinkPriceOracle contract, which is used to set the source of the token pair. In the function, check whether priceFeeds[token1][token0] already exists, but then set the source for priceFeeds[token0][token1] . ",
        "labels": [
            "SlowMist",
            "Alpaca Finance Oracle",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Redundant parameter issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ENF_WBTC_Borrow_ETH_en-us.pdf",
        "body": "In the PriceOracle contract, the getAssetPrice function is used to obtain the relative price of WBTC and ETH. But the _asset parameter it receives is not used. ",
        "labels": [
            "SlowMist",
            "ENF_WBTC_Borrow_ETH",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Token swap defect when withdrawing",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ENF_WBTC_Borrow_ETH_en-us.pdf",
        "body": "In the WBTCBorrowETH contract, the withdraw function is used to withdraw WBTC tokens. When the repayable amount of the contract is less than the required loan amount (ethWithdrawn < ethDebt), the contract will withdraw wbtcToSwap amount of WBTC from AAVE to swap it into WETH, and use the wbtcAmt value as the amountInMaximum in the Swap exchange. However, since the wbtcAmt value is indirectly calculated through the ChainLink price, there may be a deviation from the price in Uniswap v3, so using the wbtcAmt value as the amountInMaximum parameter may not be successfully swapped due to the price deviation. ",
        "labels": [
            "SlowMist",
            "ENF_WBTC_Borrow_ETH",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Swap balance has not been processed",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ENF_WBTC_Borrow_ETH_en-us.pdf",
        "body": "In the _withdraw function of the WBTCBorrowETH contract, when ethWithdrawn < ethDebt , the contract will withdraw WBTC tokens from AAVE and swap them into ETH to repay the loan. If the amount of ETH is greater than the amount of debt required to be repaid (ethBal > ethDebt), the contract will swap the excess part into WBTC, but these excess WBTC tokens have not been sent to the user, nor have they been re-staked into AAVE. It was left in the SS contract. When the next user deposit, it will be billed as part of the user's deposit. And when ethWithdrawn >= ethDebt , the contract will convert the excess ETH to WBTC, but the contract has not yet processed these WBTC. ",
        "labels": [
            "SlowMist",
            "ENF_WBTC_Borrow_ETH",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Defects in LTV operation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ENF_WBTC_Borrow_ETH_en-us.pdf",
        "body": "In the reduceLTV operation, the contract will rst extract x amount of WBTC from AAVE and exchange it into WETH 12 for repayment. In this operation, although the liabilities of the contract are reduced, the amount of collateral of the contract is also reduced. At the same time, due to the impact of the slippage of the swap operation, the reduceLTV operation may not be able to eectively control the risk as expected. ",
        "labels": [
            "SlowMist",
            "ENF_WBTC_Borrow_ETH",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Reduced availability for LTV operations 13",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ENF_WBTC_Borrow_ETH_en-us.pdf",
        "body": "In the protocol, the raiseLTV and reduceLTV functions are important means to improve capital utilization and prevent bad debts, but in these two functions, the token exchange is performed through the _swapExactInput function. The _swapExactInput function does not check for slippage, which will reduce the availability of raiseLTV and reduceLTV for the protocol. ",
        "labels": [
            "SlowMist",
            "ENF_WBTC_Borrow_ETH",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "The withdraw function will not work when the market is extreme",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ENF_WBTC_Borrow_ETH_en-us.pdf",
        "body": "In the protocol, when extreme market conditions occur (such as a sharp unilateral drop of BTC) and the owner has no time to adjust the protocol LTV through the reduceLTV function, the protocols WBTC position will be liquidated. If 14 the protocol's liabilities are fully liquidated (getDebt will become 0), ethDebt will be 0. This will cause the _withdraw function to fail to perform the repay operation, and the emergencyWithdraw operation will also not work. Users' funds will be locked in the protocol. In the repay operation of AAVE, if the repayment amount is 0, it will fail the validateRepay check.",
        "labels": [
            "SlowMist",
            "ENF_WBTC_Borrow_ETH",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Risk of multiple leverages in unilateral market conditions",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ENF_WBTC_Borrow_ETH_en-us.pdf",
        "body": "The protocol deposits WBTC tokens deposited by users into AAVE and lends ETH, and then deposits the loaned ETH into the ENF_ETH_Leverage protocol. The ENF_ETH_Leverage protocol also creates positions in AAVE via ETH/stETH. This makes the ENF_WBTC_Borrow_ETH protocol have multiple leverages, which means it is extremely sensitive to market stability. Once the agreement does not manage LTV properly, it will lead to risks such as bad debts of the agreement. ",
        "labels": [
            "SlowMist",
            "ENF_WBTC_Borrow_ETH",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of excessive authority 16",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ENF_WBTC_Borrow_ETH_en-us.pdf",
        "body": "In the protocol, the owner role has many permissions, such as the owner can set sensitive parameters, can suspend the contract, can make emergency withdrawals, etc. It is obviously inappropriate to give all the permissions of the protocol to the owner, which will greatly increase the single point of risk.",
        "labels": [
            "SlowMist",
            "ENF_WBTC_Borrow_ETH",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Swap Path Issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Oddz Finance_en-us.pdf",
        "body": "In the PancakeSwapForUnderlyingAsset contract, the owner can swap fromToken to toToken through the 11 swapTokensForUA function. The path set is [fromToken, toToken] . If fromToken and toToken in PancakeSwap do not have a directly related token pair, then using this path will not be able to successfully swap. contracts/Integrations/Dex/PancakeSwap/PancakeSwapForUnderlyingAsset.sol#L29-L44 function swapTokensForUA( address _fromToken, address _toToken, address _account, uint256 _amountIn, uint256 _amountOutMin, uint256 _deadline ) public override onlyOwner returns (uint256[] memory result) { address[] memory path = new address[](2); path[0] = _fromToken; path[1] = _toToken; ERC20(_fromToken).safeApprove(address(pancakeSwap), _amountIn); result = pancakeSwap.swapExactTokensForTokens(_amountIn, _amountOutMin, path, address(this), _deadline); // converting address to address payable ERC20(address(uint160(_toToken))).safeTransfer(_account, result[1]); }",
        "labels": [
            "SlowMist",
            "Oddz Finance",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Missing event records",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Oddz Finance_en-us.pdf",
        "body": "12 In the ChainlinkIVOracle contract, the owner can set allowedPeriods, minVolatilityBound, maxVolatilityBound and other parameters at will, but no event recording is performed. contracts/Integrations/VolatilityOracle/Chainlink/ChainlinkIVOracle.sol function addAllowedPeriods(uint8 _ivAgg) public onlyOwner(msg.sender) { allowedPeriods[_ivAgg] = true; } function setMinVolatilityBound(uint256 _minVolatility) public onlyOwner(msg.sender) { minVolatilityBound = _minVolatility; } function setMaxVolatilityBound(uint256 _maxVolatility) public onlyOwner(msg.sender) { maxVolatilityBound = _maxVolatility; } function setDelay(uint256 _delay) public onlyOwner(msg.sender) { delayInSeconds = _delay; } function setVolatilityPrecision(uint8 _precision) public onlyOwner(msg.sender) { volatilityPrecision = _precision; }",
        "labels": [
            "SlowMist",
            "Oddz Finance",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "The deationary token docking issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Oddz Finance_en-us.pdf",
        "body": "13 Users can transfer the staking token into the staking contract through the deposit function. Under normal circumstances, the number of staking tokens transferred by the user is the same as the _amount parameter passed in. But if the staking token is a deationary token, the number of tokens transferred by the user may be dierent from the number of tokens actually received in the contract. contracts/Staking/OddzStakingManager.sol, OddzTokenStaking.sol, OUsdTokenStaking function stake(IERC20 _token, uint256 _amount) external override validToken(_token) { require(_amount > 0, \"Staking: invalid amount\"); tokens[_token]._stakingContract.stake(msg.sender, _amount); emit Stake(msg.sender, address(_token), _amount); } function stake(address _staker, uint256 _amount) external override onlyOwner { _stake(_staker, _amount); _mint(_staker, _amount); IERC20(token).safeTransferFrom(_staker, address(this), _amount); }",
        "labels": [
            "SlowMist",
            "Oddz Finance",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Token active status change issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Oddz Finance_en-us.pdf",
        "body": "In the OddzStakingManager contract, the owner can set the active state of the token to true through the activateToken function, and the timelock contract can set the active state to false through the deactivateToken 14 function. But after the state change, the txnFeeReward, settlementFeeReward, and allotedReward parameters of each valid token did not change accordingly, so the totalTxnFee, totalSettlementFee, and totalAllotedFee parameters are not equal to 100. contracts/Staking/OddzStakingManager.sol function deactivateToken(IERC20 _token) external onlyTimeLocker(msg.sender) validToken(_token) { tokens[_token]._active = false; emit TokenDeactivate(address(_token)); } function activateToken(IERC20 _token) external onlyOwner(msg.sender) inactiveToken(_token) { tokens[_token]._active = true; emit TokenActivate(address(_token)); }",
        "labels": [
            "SlowMist",
            "Oddz Finance",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Redundant code",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Oddz Finance_en-us.pdf",
        "body": "There is _transferRewards function in the OddzStakingManager contract, which checks whether the staker's collateral time is greater than rewardsLockupDuration, while the actual _transferRewards function is only called by the withdraw function and the claimRewards function. But in both withdraw and claimRewards functions, there is a check to see if the staker's collateral time is greater than 15 rewardsLockupDuration. So the _transferRewards function does not need to check again if the staker's collateral time is greater than the rewardsLockupDuration. contracts/Staking/OddzStakingManager.sol function _transferRewards( address _staker, IERC20 _token, uint256 _date ) private returns (uint256 reward) { if (_date - tokens[_token]._stakingContract.getLastStakedAt(_staker) >= tokens[_token]._rewardsLockupDuration) { reward = tokens[_token]._stakingContract.withdrawRewards(_staker); oddzToken.safeTransfer(_staker, reward); emit TransferReward(_staker, address(_token), reward); } }",
        "labels": [
            "SlowMist",
            "Oddz Finance",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Unsafe External Call",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Oddz Finance_en-us.pdf",
        "body": "_pool is entered by the user. When the user enters a malicious contract address and returns the malicious premium through the malicious contract, the tokens in the OddzLiquidityPoolManager contract can be transferred to a malicious address. 16 contracts/Pool/OddzLiquidityPoolManager.sol#L300 function withdrawProfits(IOddzLiquidityPool _pool) external { uint256 premium = _pool.collectPremium(msg.sender, premiumLockupDuration); require(premium > 0, \"LP Error: No premium allocated\"); token.safeTransfer(msg.sender, premium); } The getSortedEligiblePools function does not check the input _liquidityParams and does not ensure that allPools is in the whitelist. When other functions depend on the data of getSortedEligiblePools, the same issues may occur. contracts/Pool/OddzLiquidityPoolManager.sol#L341 function getSortedEligiblePools(LiquidityParams memory _liquidityParams) public view returns (address[] memory pools, uint256[] memory poolBalance) { // if _expiration is 86401 i.e. 1 day 1 second, then max 1 day expiration pool will not be eligible IOddzLiquidityPool[] memory allPools = poolMapper[ keccak256( abi.encode( _liquidityParams._pair, _liquidityParams._type, _liquidityParams._model, periodMapper[getActiveDayTimestamp(_liquidityParams._expiration) / 1 days] ) ) ]; uint256 count = 0; for (uint8 i = 0; i < allPools.length; i++) { if (allPools[i].availableBalance() > 0) { count++; } } poolBalance = new uint256[](count); pools = new address[](count); uint256 j = 0; 17 uint256 balance = 0; for (uint256 i = 0; i < allPools.length; i++) { if (allPools[i].availableBalance() > 0) { pools[j] = address(allPools[i]); poolBalance[j] = allPools[i].availableBalance(); balance += poolBalance[j]; j++; } } (poolBalance, pools) = _sort(poolBalance, pools); require(balance > _liquidityParams._amount, \"LP Error: Amount is too large\"); }",
        "labels": [
            "SlowMist",
            "Oddz Finance",
            "Type: Unsafe External Call Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Race conditions issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Oddz Finance_en-us.pdf",
        "body": "The enableOptionTransfer function can be called repeatedly, When the attacker calls enableOptionTransfer to set a small value of _minAmount.The user does not need to enter minAmount to check when calling the optionTransfer function.Therefore, the attacker can call enableOptionTransfer again with a higher gas price to set a new minAmount, so that if the allowance is greater than the minAmount + transferFee , the user can normally execute optionTransfer calls and trade with a larger amount, and the attacker can prot. contracts/Option/OddzOptionManager.sol function enableOptionTransfer(uint256 _optionId, uint256 _minAmount) external { Option storage option = options[_optionId]; require( option.expiration > (block.timestamp + 18 assetManager.getMinPeriod(option.pair)), \"Option not eligble for transfer\" ); require(option.holder == msg.sender, \"Invalid Caller\"); require(option.state == State.Active, \"Invalid state\"); require(_minAmount >= minimumPremium, \"amount is lower than minimum premium\"); optionTransferMap[_optionId] = _minAmount; emit OptionTransferEnabled(_optionId, _minAmount); } function optionTransfer(uint256 _optionId) external { Option storage option = options[_optionId]; require( option.expiration > (block.timestamp + assetManager.getMinPeriod(option.pair)), \"Option not eligble for transfer\" ); uint256 minAmount = optionTransferMap[_optionId]; require(minAmount > 0, \"Option not enabled for transfer\"); require(option.state == State.Active, \"Invalid state\"); require(option.holder != msg.sender, \"Self option transfer is not allowed\"); // once transfer initiated update option tranfer map delete optionTransferMap[_optionId]; uint256 transferFee = _getTransactionFee(minAmount, msg.sender); txnFeeAggregate += transferFee; _validateOptionAmount(token.allowance(msg.sender, address(this)), minAmount + transferFee); token.safeTransferFrom(msg.sender, option.holder, minAmount); token.safeTransferFrom(msg.sender, address(this), transferFee); address oldHolder = option.holder; option.holder = msg.sender; emit OptionTransfer(_optionId, oldHolder, msg.sender, minAmount, transferFee); } 19",
        "labels": [
            "SlowMist",
            "Oddz Finance",
            "Type: Reordering Vulnerability",
            "Severity: Critical"
        ]
    },
    {
        "title": "Excessive authority issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Oddz Finance_en-us.pdf",
        "body": "(1) The owner of the OddzIVOracleManager and OddzPriceOracleManager contracts can change the conguration of the contract and does not use timelock for management, there is a risk of excessive authority. The oracle aects the price of the asset. When the oracle contract is maliciously manipulated, it will cause the user's asset to be damaged. (2) After the contracts are deployed, it is necessary to check whether TimeLocker is set correctly.",
        "labels": [
            "SlowMist",
            "Oddz Finance",
            "Type: Authority Control Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - EarningFarm v3 Iterative_en-us.pdf",
        "body": "In the Exchange contract, the owner role can set swapCaller and router through the setSwapCaller and listRouter functions. If it is set to a malicious address, funds will be lost. In the CDai contract, the owner role can set sensitive parameters through the setSwapPath function. This will lead to the risk of excessive owner permissions. ",
        "labels": [
            "SlowMist",
            "EarningFarm v3 Iterative",
            "Type: Authority Control Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Variable storage issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - EarningFarm v3 Iterative_en-us.pdf",
        "body": "In the Curve3Pool contract, the swap function is used for token exchange. When fetching pools[_index], it uses storage to store the curve variable, but in this function there is no need to modify pools[_index], so this will consume more gas. ",
        "labels": [
            "SlowMist",
            "EarningFarm v3 Iterative",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Slippage issue 9",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - EarningFarm v3 Iterative_en-us.pdf",
        "body": "In the Curve3Pool contract, the swap function is used to exchange tokens in 3pool, but the _min_received passed in during the exchange is 0, which will cause the exchange process to be subject to a sandwich attack. ",
        "labels": [
            "SlowMist",
            "EarningFarm v3 Iterative",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "get_dy index issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - EarningFarm v3 Iterative_en-us.pdf",
        "body": "In the CDai contract, the _totalAssets function converts DAI to USDC as total assets via CurvePool's get_dy. But Calculate withdraw amout of usdc - from Dai (j) to USDC(i) is stated in the comments, while according to the get_dy function description (https://curve.readthedocs.io/factory-pools.html#StableSwap.get_dy ), the i index should be DAI, and the j index should be USDC. ",
        "labels": [
            "SlowMist",
            "EarningFarm v3 Iterative",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of breaching contract integrity",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - EarningFarm v3 Iterative_en-us.pdf",
        "body": "When the user makes a withdrawal, the protocol will withdraw from the SS contract through the controller contract, and then burn the user's share. 11 In the withdraw function of the SS contract, it will rst calculate the number of LPs that the user can withdraw (lpAmt), then extract the LP tokens from the convex, and then use balanceOf(address(this)) to obtain the LP balance of this contract as lpWithdrawn. TotalLP will then subtract lpWithdrawn and remove liquidity from CurvePool. The amount to remove liquidity is also lpWithdrawn. Then transfer all USDC tokens in the SS contract to the controller. Finally, the controller contract transfers the USDC token to the user. In the withdraw function of the vault contract, after the controller completes the withdrawal, the number of burned shares is calculated based on the assets passed in by the user. This will lead to the destruction of the totalLP value if a malicious user transfers a large amount of LP tokens to the SS contract and withdraws them after depositing. ",
        "labels": [
            "SlowMist",
            "EarningFarm v3 Iterative",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Risk of slippage checks being bypassed",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - EarningFarm v3 Iterative_en-us.pdf",
        "body": "In the CDai contract, the totalAssets function calculates the total collateral amount of the SS contract in the strategy through the get_dy function of CurvePool. When the user withdraws, the contract will participate in the calculation of 12 the nDAI value to be withdrawn through totalAssets. Unfortunately, a malicious user can manipulate the CurvePool with large sums of money so that the value obtained by the get_dy function is much smaller than expected, which will cause the nDAI value to be much larger than expected when withdrawing. Malicious users can deplete the liquidity in CDai by stealing collateral that does not belong to them. ",
        "labels": [
            "SlowMist",
            "EarningFarm v3 Iterative",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Arbitrary permission initialization of lend/oracle contract",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Larix Obsolete_en-us.pdf",
        "body": "Anyone can initialize the lend/oracle contract, which may lead to the illegal use of the contract, and malicious users may use the ocially deployed Program to conduct fraudulent activities.",
        "labels": [
            "SlowMist",
            "Larix Obsolete",
            "Type: Authority Control Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Flash loan repayment detection bypass",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Larix Obsolete_en-us.pdf",
        "body": "After the attacker calls process_flash_loan to borrow, he uses the borrowed funds to recharge to the contract. In this way, the ash loan will detect that the funds have been returned during the repayment check, which leads to the success of the ash loan, but the funds are not actually returned. Instead, the attacker get a deposit position is established, and the attacker can withdraw this fund at any time, thereby stealing all the funds in the fund pool.",
        "labels": [
            "SlowMist",
            "Larix Obsolete",
            "Type: Reentrancy Vulnerability",
            "Severity: Critical"
        ]
    },
    {
        "title": "Process_ash_loan forged account risk 7",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Larix Obsolete_en-us.pdf",
        "body": "Code location: larix-lending/src/processor.rs fn process_flash_loan( program_id: &Pubkey, liquidity_amount: u64, accounts: &[AccountInfo], ) If the owner or key of the reserve_info account is not veried, the attacker may attack the contract by maliciously constructing the data stored in the account.",
        "labels": [
            "SlowMist",
            "Larix Obsolete",
            "Type: Forged account attack",
            "Severity: Critical"
        ]
    },
    {
        "title": "Process_reserve forged account risk",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Larix Obsolete_en-us.pdf",
        "body": "Code location: larix-lending/src/cong/cong_process.rs fn process_reserve(program_id: & Pubkey, accounts: & [AccountInfo],reserve_type:ConfigReserveType) If the owner or key of the reserve_info account is not veried, the attacker may attack the contract by maliciously constructing the data stored in the account.",
        "labels": [
            "SlowMist",
            "Larix Obsolete",
            "Type: Forged account attack",
            "Severity: Critical"
        ]
    },
    {
        "title": "process_borrow_obligation_liquidity host_fee transfer target is not veried",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Larix Obsolete_en-us.pdf",
        "body": "Code location: larix-lending/src/processor.rs if let Ok(host_fee_receiver_info) = next_account_info(account_info_iter) { if host_fee > 0 { owner_fee = owner_fee .checked_sub(host_fee) .ok_or(LendingError::MathOverflow)?; spl_token_transfer(TokenTransferParams { source: source_liquidity_info.clone(), destination: host_fee_receiver_info.clone(), amount: host_fee, authority: lending_market_authority_info.clone(), authority_signer_seeds, token_program: token_program_id.clone(), })?; } } The owner or key of the host_fee_receiver_info account is not veried, and the user can steal host_fee by specifying host_fee_receiver_info .",
        "labels": [
            "SlowMist",
            "Larix Obsolete",
            "Type: Forged account attack",
            "Severity: Critical"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap_v3_Phase2_en-us.pdf",
        "body": "1.The owner role can change the external part contract FARM_BOOSTER through the updateFarmBoostContract function and the external part contract can aect the boostMultiplier . ",
        "labels": [
            "SlowMist",
            "PancakeSwap_v3_Phase2",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "LP token locking issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap_v3_Phase2_en-us.pdf",
        "body": "In the MasterChefV3 contract, users will transfer their ERC721 LP tokens for staking to get the CAKE as reward. Users can only call the safeTransferFrom function to transfer their ERC721 LP token in the MasterChefV3 contract to trigger the _checkOnERC721Received hook to let the NonfungiblePositionManager contract call back the onERC721Received function. After this, the positionInfo can be recorded and make the staking eective. If users miss transferring the LP token by using the transferFrom function, the LP tokens will be locked in this contract. ",
        "labels": [
            "SlowMist",
            "PancakeSwap_v3_Phase2",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Cast truncation issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap_v3_Phase2_en-us.pdf",
        "body": "In the PancakeV3LmPool contract, the Pool or MasterChef will calculate the reward through the accumulateReward function. The uint256 endTime is assigned by getLatestPeriodInfo in the MasterChef contract and the endTime is assigned by an uint256 value latestPeriodEndTime , then the endTime will cast to an uint32 to endTimestamp . If the latestPeriodEndTime is larger than type(uin32).max , there will be a cast truncation issue. And PancakeV3LmPool contract imports the SafeCast contract but doesnt use it for the uin32 cast. ",
        "labels": [
            "SlowMist",
            "PancakeSwap_v3_Phase2",
            "Type: Arithmetic Accuracy Deviation Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Potential risks of arbitrary transfer of ETF funds",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase7 - SlowMist Audit Report.pdf",
        "body": "In the MoveFunds contract, the admin role can transfer funds from the ETF to a specied receiver address through the makeTransfer function during the ETF's closed period. Additionally, the owner can arbitrarily modify the receiver address through the setReceiver function. For the ETF, this may pose an excessive privilege risk, and participants should be aware of this. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase7 - SlowMist Audit Report",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Information"
        ]
    },
    {
        "title": "Redundant logic issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - MasterChef v2_en-us.pdf",
        "body": "In the add function, the owner can add new pools. It will rst check whether the number of newly added lpTokens in the contract is greater than or equal to 0. But in fact, the number of lpTokens in the contract will be greater than or equal to 0 in any case, so this check is redundant. ",
        "labels": [
            "SlowMist",
            "MasterChef v2",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Permission control issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - MasterChef v2_en-us.pdf",
        "body": "If any user holds the dummy token, the user can stake the dummy token to the MasterChef v1 contract through the init function, which will cause the lastBurnedBlock parameter to be updated unexpectedly, and nally lead to an error in the calculation of the number of CAKE tokens waiting to be burned. ",
        "labels": [
            "SlowMist",
            "MasterChef v2",
            "Type: Authority Control Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "The number of pendingCakeToBurn is not checked",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - MasterChef v2_en-us.pdf",
        "body": "In the burnCake function, if the number of CAKE tokens in the contract is less than pendingCakeToBurn, it will harvest CAKE tokens from MasterChef v1 via the harvestFromMasterChef function. But it does not check if the balance of CAKE tokens in the contract after harvesting is greater than or equal to pendingCakeToBurn. ",
        "labels": [
            "SlowMist",
            "MasterChef v2",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Repeatable initialization issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap_MOVE_en-us.pdf",
        "body": "In the swap module RESOURCE_ACCOUNT can initialize SwapInfo through the init_storage function, but the function does not check for repeated initialization. ",
        "labels": [
            "SlowMist",
            "PancakeSwap_MOVE",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Gas optimization",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap_MOVE_en-us.pdf",
        "body": "In the swap module, the add_liquidity function is used to add liquidity and return the remaining tokens to the user. But without checking whether the token value to be returned is greater than 0, the coin::deposit function is called. If the returned token value is 0, this will cause unnecessary gas consumption. ",
        "labels": [
            "SlowMist",
            "PancakeSwap_MOVE",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Architecture optimization",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap_MOVE_en-us.pdf",
        "body": "The storage of LP tokens is realized through storage.move in the protocol. But the creation of Pair is realized through the create_pair of the swap module and the resource storage is carried out by TokenPairMetadata and TokenPairReserve. So LPToken can be implemented directly in swap module without having to implement it in storage.move separately. ",
        "labels": [
            "SlowMist",
            "PancakeSwap_MOVE",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Assertion aw issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap_MOVE_en-us.pdf",
        "body": "In the swap module, the mint function is used to mint LP tokens when liquidity is added. When adding liquidity for the rst time, the liquidity amount needs to meet MINIMUM_LIQUIDITY. If the MINIMUM_LIQUIDITY is not met, the 12 transaction will be revet. In this case the protocol will throw an overow error instead of ERROR_INSUFFICIENT_LIQUIDITY_MINTED. ",
        "labels": [
            "SlowMist",
            "PancakeSwap_MOVE",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Not checked if pair has been created",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap_MOVE_en-us.pdf",
        "body": "In the router module contract, users can remove liquidity and exchange tokens through the functions remove_liquidity, swap_exact_input, swap_exact_output, swap_exact_input_doublehop, 13 swap_exact_output_doublehop, swap_exact_input_triplehop and swap_exact_output_triplehop respectively, but do not check whether a pair is created rst. ",
        "labels": [
            "SlowMist",
            "PancakeSwap_MOVE",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Redundant code",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap_MOVE_en-us.pdf",
        "body": "In the Swap module, the quote_x_to_y_after_fees, quote_y_to_x_after_fees, transfer_x and transfer_y functions are all internal functions, but no other public functions call them. ",
        "labels": [
            "SlowMist",
            "PancakeSwap_MOVE",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "k value check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap_MOVE_en-us.pdf",
        "body": "During the swap process, it is necessary to check whether the multiplication of the token balance of the pair after the swap is strictly greater than or equal to the k value. However, due to the fee charged during the swap process, in theory, the multiplication of the token balance of the pair after swap must be strictly greater than the k value. While using u256 avoids close rounding errors it is still not necessary to check if it is equal to the k value. ",
        "labels": [
            "SlowMist",
            "PancakeSwap_MOVE",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap_MOVE_en-us.pdf",
        "body": "In the swap module contract, the admin role can call the upgrade_swap function to upgrade the entire contract. If administrator privileges are stolen, it may have an impact on the normal operation of the contract. ",
        "labels": [
            "SlowMist",
            "PancakeSwap_MOVE",
            "Type: Excessive Authority Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "The validity of the token contract address is not checked",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Bitlayer Bridge Phase 2.pdf",
        "body": "In the BitlayerBridgeV2 contract, the crossoutBurn function does not check the validity of the token address. An attacker can pass in the token contract address created by himself, and then transfer and burn the tokens created by the attacker through the crossoutBurn function to trigger the CrossoutBurned event. contracts/BitlayerBridgeV2.sol#L278-L307 function crossoutBurn( address token, uint256 value, string memory btcReceiver ) external payable { require(token != address(0), \"invalid token address\"); require(value != 0, \"invalid value\"); require(bytes(btcReceiver).length != 0, \"invalid btcReceiver\"); uint256 crossoutFeeAmount = tokenConfigs[token].crossoutFee; require(crossoutFeeAmount == 0 || msg.value >= crossoutFeeAmount, \"not enough fee paied\"); SafeERC20.safeTransferFrom(IERC20(token), msg.sender, address(this), value); IPegToken(token).burn(address(this), value); if (crossoutFeeAmount > 0) { (bool success, bytes memory returndata) = feeAddress.call{value: crossoutFeeAmount}(\"\"); require(success, string(returndata)); } uint256 unusedFee = msg.value - crossoutFeeAmount; if (unusedFee > 0) { (bool success, bytes memory returndata) = msg.sender.call{value: unusedFee}(\"\"); require(success, string(returndata)); } emit CrossoutBurned(msg.sender, btcReceiver, token, value); }",
        "labels": [
            "SlowMist",
            "Bitlayer Bridge Phase 2",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Unlimited huge amount minting",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Bitlayer Bridge Phase 2.pdf",
        "body": "In the BitlayerBridgeV2 contract, when huge amounts are minted through the proposeMint function and executeMint function, the minted amount is not limited by periodLimit , nor is it recorded in periodMinted , and the period will not be updated. contracts/BitlayerBridgeV2.sol#L235-L255,L258-L275 function proposeMint( MintInfo memory mInfo ) external onlyRole(ProposerRole) { bytes32 blExecHash = keccak256(abi.encodePacked(mInfo.btcTxHash)); require(!executedBtcHash[blExecHash], \"already executed\"); require(mInfo.receiver != address(0), \"receiver is null\"); require(proposedMint[blExecHash].receiver == address(0), \"already proposed\"); require(mInfo.value >= tokenConfigs[mInfo.token].mintSplitLine, \"mint value is less than configed\"); require( !IPegToken(mInfo.token).isBlacklist(mInfo.receiver), \"receiver is blacklisted\" ); proposedMint[blExecHash] = mInfo; emit MintProposed(mInfo.btcTxHash, blExecHash, mInfo.receiver, mInfo.token, mInfo.value); } function executeMint( bytes32 blExecHash ) external onlyRole(ExecutorRole) { MintInfo memory mInfo = proposedMint[blExecHash]; require(!executedBtcHash[blExecHash], \"already executed\"); require(mInfo.receiver != address(0), \"not proposed\"); executedBtcHash[blExecHash] = true; delete proposedMint[blExecHash]; IPegToken(mInfo.token).mint(mInfo.receiver, mInfo.value); emit MintExecuted(mInfo.btcTxHash, blExecHash, mInfo.receiver, mInfo.token, mInfo.value); }",
        "labels": [
            "SlowMist",
            "Bitlayer Bridge Phase 2",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "The returned leftQuota value is inaccurate",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Bitlayer Bridge Phase 2.pdf",
        "body": "In the BitlayerBridgeV2 contract, the getPeriodInfo function is inaccurate when returning the leftQuota of the specied token. If block.number has reached the next period and tokenConfigs[token] has not been updated, the value of leftQuota should be config.periodLimit . contracts/BitlayerBridgeV2.sol#L309-L319 function getPeriodInfo(address token) external view returns(uint256 periodLimit, uint256 leftQuota, uint256 leftBlocksToNextPeriod) { TokenConfig memory config = tokenConfigs[token]; periodLimit = config.periodLimit; leftQuota = config.periodLimit - config.periodMinted; leftBlocksToNextPeriod = config.periodInterval - (block.number - config.lastBlockNumber) % config.periodInterval; }",
        "labels": [
            "SlowMist",
            "Bitlayer Bridge Phase 2",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Missing zero address check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Bitlayer Bridge Phase 2.pdf",
        "body": "1.In the BitlayerBridgeV2 contract, the initToken function does not perform a zero address check on the token address. contracts/BitlayerBridgeV2.sol#L99-L119 function initToken( address token, ``` ) external onlyRole(AdminRole) { TokenConfig storage config = tokenConfigs[token]; ``` } 2.In the BitlayerBridgeV2 contract, the directMint function does not perform a zero address check on the mInfo.token address. contracts/BitlayerBridgeV2.sol#L198-L233 function directMint( MintInfo memory mInfo ) external onlyRole(MinterRole) { ``` IPegToken(mInfo.token).mint(mInfo.receiver, mInfo.value); ``` } 3.In the BitlayerBridgeV2 contract, the proposeMint function does not perform a zero address check on the mInfo.token address. BitlayerBridgeV2.sol#L235-L255 function proposeMint( MintInfo memory mInfo ) external onlyRole(ProposerRole) { ``` require( !IPegToken(mInfo.token).isBlacklist(mInfo.receiver), \"receiver is blacklisted\" ); ``` }",
        "labels": [
            "SlowMist",
            "Bitlayer Bridge Phase 2",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Unchecked parameter value is not 0",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Bitlayer Bridge Phase 2.pdf",
        "body": "1.In the BitlayerBridgeV2 contract, the initToken function does not check whether the values of periodInterval and mintSplitLine are not 0. contracts/BitlayerBridgeV2.sol#L99-L119 function initToken( address token, uint256 periodLimit, uint256 periodInterval, uint256 mintSplitLine, uint256 crossoutFee ) external onlyRole(AdminRole) { TokenConfig storage config = tokenConfigs[token]; require(config.lastBlockNumber == 0, \"already inited\"); config.lastBlockNumber = block.number; config.periodLimit = periodLimit; config.periodInterval = periodInterval; config.mintSplitLine = mintSplitLine; config.crossoutFee = crossoutFee; emit TokenInited(token, periodLimit, periodInterval, mintSplitLine, crossoutFee); } 2.In the BitlayerBridgeV2 contract, the setMintSplitLine function does not check whether the value of limit is not 0. contracts/BitlayerBridgeV2.sol#L137-L149 function setMintSplitLine( address token, uint256 limit ) public onlyRole(AdminRole) { require(token != address(0), \"invalid token address\"); tokenConfigs[token].mintSplitLine = limit; emit MintSplitLineSet(token, limit); } 3.In the BitlayerBridgeV2 contract, the directMint function does not check whether the value of mInfo.value is not 0. BitlayerBridgeV2.sol#L198-L233 function directMint( MintInfo memory mInfo ) external onlyRole(MinterRole) { ``` require( mInfo.value < config.mintSplitLine, \"mint value is greater than configed\" ); ``` }",
        "labels": [
            "SlowMist",
            "Bitlayer Bridge Phase 2",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Redundant code",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Bitlayer Bridge Phase 2.pdf",
        "body": "In the BitlayerBridgeV2 contract, the directMint function repeatedly performs a zero address check on the mInfo.receiver address because the zero address check has already been performed on this address in the mint function of the token contract. contracts/BitlayerBridgeV2.sol#L198-L233 function directMint( MintInfo memory mInfo ) external onlyRole(MinterRole) { ``` require(mInfo.receiver != address(0), \"receiver is null\"); ``` }",
        "labels": [
            "SlowMist",
            "Bitlayer Bridge Phase 2",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Bitlayer Bridge Phase 2.pdf",
        "body": "1.In the BitlayerBridgeV2 contract, the AdminRole role can set important parameters in the contract through the following functions. contracts/BitlayerBridgeV2.sol function setRoles function initToken function setPeriodMintLimit function setMintSplitLine function setCrossoutFee function setPeriodInterval function startNewPeriod 2.The BitlayerBridge contracts are implemented using the OpenZeppelin upgradeable model, allowing the AdminRole role to perform contract upgrades.Since the BitlayerBridgeV2 contract inherits the BitlayerBridge contract, it is also an upgradeable contract. However, this design introduces an excessive privilege risk. contracts/BitlayerBridge.sol#L4 import \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\"; 3.In the BitlayerBridge contract, AdminRole role can set important parameters of the contract.And the BitlayerBridgeV2 contract also inherits these privileged functions. contracts/BitlayerBridge.sol function setFeeAddress function setLockFee function setMinLockAmount function setMaxLockAmount 4.In the BitlayerBridge contract, the LiquidityRole role can call the removeLiquidityTo function to remove the liquidity of any address.And the BitlayerBridgeV2 contract also inherits this privileged functions. contracts/BitlayerBridge.sol#L159-L162 function removeLiquidity(uint256 amount) external whenNotPaused { require(amount > 0, \"invalid amount\"); doRemoveLiquidity(msg.sender, amount); } 5.In the BitlayerBridge contract, UnlockRole can pass in any _txHash through the unlock function to unlock any amount of native tokens. In the BitlayerBridgeV2 contract, MinterRole , ProposerRole and ExecutorRole can mint any amount of PegToken by passing in any btcTxHash parameter through their respective functions ( directMint , proposeMint and executeMint ). These vulnerabilities stem from the contract's inability to verify Bitcoin networks transaction hash at the EVM level, instead leaving verication to a centralized validator. contracts/BitlayerBridge.sol function unlock contracts/BitlayerBridgeV2.sol function directMint function proposeMint function executeMint",
        "labels": [
            "SlowMist",
            "Bitlayer Bridge Phase 2",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Missing event record",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap_Pottery_en-us.pdf",
        "body": "When the sensitive parameters of the contract are modied, the corresponding events are not recorded, which is not conducive to the supervision of the community and users. ",
        "labels": [
            "SlowMist",
            "PancakeSwap_Pottery",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Business logic problem",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap_Pottery_en-us.pdf",
        "body": "The contract does not check whether the incoming address and ID exist. If the wrong data is passed in in the actual operation, it will lead to waste of resources. ",
        "labels": [
            "SlowMist",
            "PancakeSwap_Pottery",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap_Pottery_en-us.pdf",
        "body": "The Owner has the right to modify the address of the contract to any address. ",
        "labels": [
            "SlowMist",
            "PancakeSwap_Pottery",
            "Type: Authority Control Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Defects in the defaultDepositSS check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ENF_ETH_Lowrisk_en-us.pdf",
        "body": "In the harvest function of the Controller contract, before re-depositing the protocol income into the strategy, it will check whether the default SS exists through subStrategies.length > defaultDepositSS . But actually, defaultDepositSS will be 0 when the default SS does not exist, so the subStrategies.length > defaultDepositSS check will always pass. Eventually the protocol will fail to re-deposit. ",
        "labels": [
            "SlowMist",
            "ENF_ETH_Lowrisk",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "ownerDeposit remaining deposit issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ENF_ETH_Lowrisk_en-us.pdf",
        "body": "In the ownerDeposit function of the StETH contract, the owner role will directly deposit ETH into the strategy. It checks that msg.value must be greater than or equal to the amount to be deposited through _amount <= msg.value . But when the owner's msg.value is greater than _amount , the ownerDeposit function does not implement the refund of excess ETH. This will result in funds being locked. The same is true for the ownerDeposit function of the CEth contract. ",
        "labels": [
            "SlowMist",
            "ENF_ETH_Lowrisk",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Redundant variable",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ENF_ETH_Lowrisk_en-us.pdf",
        "body": "There is a weth global variable in the CEth contract, but this variable is not used in the contract. ",
        "labels": [
            "SlowMist",
            "ENF_ETH_Lowrisk",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ENF_ETH_Lowrisk_en-us.pdf",
        "body": "10 In the protocol, the owner role has many permissions, such as: the owner can set sensitive parameters, can suspend the contract, can make emergency withdrawals, can migrate the funds of the SS contract, etc. It is obviously inappropriate to give all the permissions of the protocol to the owner, which will greatly increase the single point of risk.",
        "labels": [
            "SlowMist",
            "ENF_ETH_Lowrisk",
            "Type: Authority Control Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Compound interest slippage check issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ENF_ETH_Lowrisk_en-us.pdf",
        "body": "In the router contract, no slippage check is performed during the swap operation. If there are more funds with compound interest, there will be a risk of being attacked by sandwiches. ",
        "labels": [
            "SlowMist",
            "ENF_ETH_Lowrisk",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Redundant collectEndTime check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report_en-us.pdf",
        "body": "In the CongurableRightsPool contract, users can redeem underlying assets through the exitPool function. When the pool is a closed ETF, it will check isCompletedCollect and collectEndTime to decide whether to perform _claimManagerFee operation. But when isCompletedCollect is true, the collectEndTime check will be performed in snapshotEndAssets, and when isCompletedCollect is false, the collectEndTime check will be performed in exitPoolHandleB. Hence the collectEndTime check before the _claimManagerFee operation is redundant. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Redundant closureEndTime check on exitPool",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report_en-us.pdf",
        "body": "In the CongurableRightsPool contract, users can redeem underlying assets through the exitPool function. When the pool is a closed ETF and isCloseEtfCollectEndWithFailure is false, it will check that the current time must be greater than closureEndTime + 5 minutes before allowing the user to exit. However, it should be noted that the snapshotEndAssets operation will be performed before this. The snapshotEndAssets function will also check whether the current time is greater than closureEndTime + 5 minutes . Only the admin and owner can execute snapshotEndAssets within 5 minutes after the closure period ends. Otherwise, the transaction will be reverted. Therefore, the closureEndTime check in the exitPool function is redundant. When snapshotEndAssets cannot be performed, the entire transaction will be reverted, and subsequent closureEndTime checks will not be performed. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Redundant performance fee calculation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report_en-us.pdf",
        "body": "In the exitPool function of the CongurableRightsPool contract, redeemAndPerformanceFeeReceived, nalAmountOut and redeemFeeReceived are calculated through exitPoolHandleA. However, since the performance fee will be calculated uniformly in the snapshotEndAssets operation, there is no need to process the performance fee in the exitPool function. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "The time allowed for snapshots is too short",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report_en-us.pdf",
        "body": "In the CongurableRightsPool contract when the closed ETF completes collect and the collection period has ended, the current total value of the ETF can be recorded through the snapshotBeginAssets function. However, users can only call the snapshotBeginAssets function within 15 minutes after the end of the collection period. If there is congestion on the chain, it may not be possible to call the snapshot in time within 15 minutes. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Duplicate decimal processing issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report_en-us.pdf",
        "body": "In the DesynChainlinkOracle contract, the getPrice function is used to obtain the corresponding token price from prices, getChainlinkPrice, and getUniswapPrice, and perform decimal processing. However, decimal has been processed in getChainlinkPrice and getUniswapPrice, and theoretically, the returned decimal will be 1e18. Therefore, processing decimals through decimalDelta will cause decimals to be enlarged. Note that the amountIn passed in for the consult in the getUniswapPrice function is 1e18, which needs to be ensured that the token decimal in twapOracle matches it in practice ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Decimal processing issue in AllPrice calculation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report_en-us.pdf",
        "body": "In the DesynChainlinkOracle contract, the getAllPrice function is used to calculate the total value of the specied amount of tokens. It is calculated by badd(fundAll, bmul(getPrice(t), tokenAmountOut)) , theoretically the decimal returned by getPrice is 1e18, and the decimal of tokenAmountOut is consistent with the decimal of the token itself. Therefore, multiplying these two values will result in a very large decimal in the nal result. The getNormalizedWeight function is also aected by this, but this is not harmful to normal business. Note: ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Redundant code issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report_en-us.pdf",
        "body": "In the SmartPoolManager library, the exitPoolHandle function has been deprecated since closed ETF prots are calculated in snapshotEndAssets. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Token list conict in recordTokenInfo",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report_en-us.pdf",
        "body": "When the user performs createPool and joinPool, if the Pool is a closed ETF and the current time is within the collection period, the KOL invitation amount will be recorded through UserVault's recordTokenInfo interface. But unfortunately, the tokens in the Pool can be Bind/unBind at any time, which will cause the list of tokens supported by the Pool to change. If the recordTokenInfo operation is performed when the Pool token list changes, the amount recorded by variables such as poolInviteTotal, kolTotalAmountList, and kolUserInfo may be disturbed. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "couldManagerClaim not checked when managerClaim",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report_en-us.pdf",
        "body": "In the UserVault contract, the Manager role can claim management fees through the managerClaim function, but it does not check whether the couldManagerClaim parameter is true. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Some redundant invoke functions",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report_en-us.pdf",
        "body": "In the Invoke library, the strictInvokeTransfer, invokeUnwrapWETH, invokeWrapWETH, and invokeMint functions are not used. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of ETF falsication",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report_en-us.pdf",
        "body": "In the RebalanceAdapter contract, the Manager role can adjust the position of the pool through the rebalance function. But the address of the ETF is obtained from the rebalanceInfo passed in by the user. If a malicious user passes in a fake ETF, the check in the onlyManager decorator will be bypassed, and the _verifyWhiteToken check of token1 and the isCompletedCollect and collectEndTime checks will be useless. Malicious users can steal bPool funds through _makeSwap and bind malicious tokens. The approve function also has this risk, but it doesn't break the protocol too much ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Risk of the Manager role potentially disrupting the protocol",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report_en-us.pdf",
        "body": "In the RebalanceAdapter contract, the Manager role can adjust the position of the ETF through the rebalance function. It will use the _makeSwap function to call Uniswap, 1inch and other DEXs for token swaps to adjust token positions. But unfortunately, the swap path of the token is not checked during the token swap process, which will cause the Manager role to pass in a carefully constructed malicious swap path to steal the middle token0 of the ETF. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Double slippage check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report_en-us.pdf",
        "body": "In the RebalanceAdapter contract, the Manager role can adjust the position of the ETF through the rebalance function. It will use the _makeSwap function to call Uniswap, 1inch and other DEXs for token swaps to adjust token positions. During the swap process, the slippage will be checked by passing minReturn to the external DEXs, but the implementation of the slippage check of the external DEXs is uncontrollable. If the slippage protection of the external DEXs fails, it will aect the funds of users in the protocol. (1inch users encountered invalid slippage check before) ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Does not follow the Checks-Eects-Interactions specication",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report_en-us.pdf",
        "body": "In the RebalanceAdapter contract, the _makeSwap function is used for token swap. When the swap type is not UNISWAPV3 and UNISWAPV2, the parameters passed in by the user will be checked through _validateData . However, the execute operation is performed rst, and the _validateData operation is performed after the token exchange is completed. This is not in line with the follow the Checks-Effects-Interactions principle. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Perform strict parameter checking",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report_en-us.pdf",
        "body": "In the RebalanceAdapter contract, the _validateData function is used to check the exchange parameters, but it only parses the recipient and amountIn for checking, but does not check whether other key parameters such as srcToken, dstToken, clipperExchange, makerAsset, takerAsset are in line with expectations. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Redundant aggregator parameter",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report_en-us.pdf",
        "body": "In the RebalanceAdapter contract, the _validateData function is used to check the conversion parameters, but the aggregator parameter it receives is not used. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Incorrect approval operation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report_en-us.pdf",
        "body": "In the RebalanceAdapter contract, the Manager role can adjust the position of the ETF through the rebalance function. If token1 has not been bound in bPool, it will be approved rst. However, the subsidy of this contract was wrongly approved to bPool, which will cause bPool to be unable to transfer tokens from CRP in the future. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report_en-us.pdf",
        "body": "There is an execute function in the CRP and bPool contracts so that the Manager can manage the ETF. In bFactory, the Blabs role can arbitrarily register modules to gain control over CRP. The registered modules can use the execute function in CRP to call the execute function in bPool to perform any operations. This would pose a huge risk to users' funds. And the Manager can approve the tokens in the bPool through the approve function of the RebalanceAdapter contract, which will also bring huge risks to the user's funds. The above problems lead to the risk of excessive permissions of the Blabs role and the Manager role. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Authority Control Vulnerability Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Enforce strict permission controls",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report_en-us.pdf",
        "body": "In the LiquidityPool contract, any user can call the joinPool, exitPool, and gulp functions to add/remove liquidity/record token balances, which will make it impossible to charge various fees to users in CRP. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Business logic issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Unemeta_en-us.pdf",
        "body": "1.In the UnemetaMarket contract, the matchSellerOrdersWETH and matchSellerOrders use the strategy to match orders, but the canExecuteTakerBid function is not in the StrategyFixedPrice contract. ",
        "labels": [
            "SlowMist",
            "Unemeta",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Unemeta_en-us.pdf",
        "body": "The owner role of the RoyaltyFeeRegistry and RoyaltyFeeSetter contract can update the royaltyFeeLimit and the FeeInfo of the NFT collection. ",
        "labels": [
            "SlowMist",
            "Unemeta",
            "Type: Authority Control Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Risk of replay attack",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Unemeta_en-us.pdf",
        "body": "13 The chainid is dened when the contract is initialized, but it is not reimplemented when DOMAIN(domainSeparator) is used in the verify function. So the domainSeparator contains the chainId and is dened at contract deployment instead of reconstructed for every signature, there is a risk of possible replay attacks between chains in the event of a future chain split. ",
        "labels": [
            "SlowMist",
            "Unemeta",
            "Type: Replay Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing event records",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap Stable Swap_en-us.pdf",
        "body": "In the PancakeStableSwap contract, the owner can set the is_killed, balances and admin_actions_deadline parameters respectively through the kill_me, unkill_me, donate_admin_fees and revert_new_parameters functions, but no event recording is performed. ",
        "labels": [
            "SlowMist",
            "PancakeSwap Stable Swap",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Ring Protocol_en-us.pdf",
        "body": "1.In the FewWrappedToken contract, the burner role can burn any users Wrapped tokens through the burnFrom function without users approval. All role settings are completed in the core contract, which is not within the scope of this audit. ",
        "labels": [
            "SlowMist",
            "Ring Protocol",
            "Type: Authority Control Vulnerability Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Token compatibility reminder",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Ring Protocol_en-us.pdf",
        "body": "In the FixedStakingRewards contract, users can stake, stakeWithPermit, and withdraw the stakeingTokens by safetransferFrom and safetransfer functions to the staking contract and the amount will be directly recorded in the totalSupply. If the stakingTokens are deationary tokens, the actual amount of tokens received by the FixedStakingRewards contract will be less than the amount recorded by the amount parameter. ",
        "labels": [
            "SlowMist",
            "Ring Protocol",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Potential token decimal compatibility reminder",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Ring Protocol_en-us.pdf",
        "body": "In the FixedStakingRewards contract, users can stake the tokens through the stake and stakeWithPermit functions. It will update each totalSupply and balances parameters according to the amount of user deposits. These parameters will not distinguish dierent stakingTokens, if the stakingTokens deposit with dierent decimals will may lead to errors in the calculation of rewards in the protocol.",
        "labels": [
            "SlowMist",
            "Ring Protocol",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing the event records",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Ring Protocol_en-us.pdf",
        "body": "In the FixedStakingRewards contract, the rewardSetter can arbitrarily modify every rewardPerTokenPerSecond , periodFinish , and rewardSetter parameters in each StakingInfo, but there are no event logs. ",
        "labels": [
            "SlowMist",
            "Ring Protocol",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing the 0 address check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Ring Protocol_en-us.pdf",
        "body": "In the FixedStakingRewards and CoreRef contract, the Governor role can modify the _core address and the rewardSetter can modify the rewardSetter address, but there are no 0 address checks. ",
        "labels": [
            "SlowMist",
            "Ring Protocol",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Malleable attack risk",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Ring Protocol_en-us.pdf",
        "body": "In the permit function of the FewWrappedToken contract, it restores the address of the signer through the ecrecover function, but does not check the value of v and s. Since EIP2 still allows the malleability for ecrecover, this will lead to the risk of transaction malleability attacks. ",
        "labels": [
            "SlowMist",
            "Ring Protocol",
            "Type: Replay Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of replay attack",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Ring Protocol_en-us.pdf",
        "body": "DOMAIN_SEPARATOR is dened when the contract is initialized, but it is not reimplemented when DOMAIN_SEPARATOR is used in the permit function. So the DOMAIN_SEPARATOR contains the chainId and is dened at contract deployment instead of reconstructed for every signature, there is a risk of possible replay attacks between chains in the event of a future chain split. ",
        "labels": [
            "SlowMist",
            "Ring Protocol",
            "Type: Replay Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Preemptive Initialization",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Ring Protocol_en-us.pdf",
        "body": "By calling the initialize and deploy functions to initialize the contracts, there is a potential issue that malicious attackers preemptively call the initialize function to initialize. ",
        "labels": [
            "SlowMist",
            "Ring Protocol",
            "Type: Race Conditions Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - getBTC.pdf",
        "body": "1.In the TokenExchange contract, the owner role can set vaults mapping through the setVaults function. TokenExchange.sol#L74-L77 function setVaults(address valut, bool status) external onlyOwner { vaults[valut] = status; emit SetVaults(valut, status); } 2.In the TokenExchange contract, the owner role can set the Operator role address through the setOperator function; the owner's ownership can be transferred through the transferOwnership function. TokenExchange.sol#L90-L94,L95-L99 function transferOwnership(address newOwner) external onlyOwner { require(newOwner != address(0),\"Owner_Should_Not_Zero_Address\"); owner = newOwner; emit TransferOwnership(newOwner); } function setOperator(address newOp) external onlyOwner { operator = newOp; emit SetOperator(newOp); } 3.In the TokenExchange contract, the owner role can withdraw the ERC20 token in the contract through the withdrawERC20 function; the Native token in the contract can be withdrawn through the withdrawBTC function. TokenExchange.sol#L78-L82,L82-L88 function withdrawERC20(address tokenAddress, address receiver, uint256 amount) external onlyOwner { require(amount <= IERC20(tokenAddress).balanceOf(address(this)),\"Token_Not_Enough\"); SafeERC20.safeTransfer(IERC20(tokenAddress), receiver, amount); emit Withdrawn(tokenAddress, receiver, amount); } function withdrawBTC(address payable receiver, uint256 amount) external onlyOwner { require(amount <= address(this).balance,\"BTC_Not_Enough\"); (bool success, bytes memory returnData) = receiver.call{value: amount}(\"\"); require(success, string(returnData)); emit Withdrawn(address(0), receiver, amount); }",
        "labels": [
            "SlowMist",
            "getBTC",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Missing zero address check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - getBTC.pdf",
        "body": "In the TokenExchange contract, the withdrawBTC function and setOperator function lack zero address check. TokenExchange.sol#L83-L88,L95-L98 function withdrawBTC(address payable receiver, uint256 amount) external onlyOwner { require(amount <= address(this).balance,\"BTC_Not_Enough\"); (bool success, bytes memory returnData) = receiver.call{value: amount}(\"\"); require(success, string(returnData)); emit Withdrawn(address(0), receiver, amount); } function setOperator(address newOp) external onlyOwner { operator = newOp; emit SetOperator(newOp); }",
        "labels": [
            "SlowMist",
            "getBTC",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Variable names are the same",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - getBTC.pdf",
        "body": "The private string variable _name dened in the TokenExchange contract has the same name as the private immutable string _name inherited from the EIP712 contract. TokenExchange.sol#L19 string private _name; EIP712.sol#L49 ShortString private immutable _name;",
        "labels": [
            "SlowMist",
            "getBTC",
            "Type: Others",
            "Severity: Information"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - peg-Token.pdf",
        "body": "1.The PegToken contracts and the TokenManager contract are implemented using the OpenZeppelin upgradeable model, allowing the AdminRole role to perform contract upgrades. In the TokenManager contract, the Operator role can upgrade the specied PegToken contract through the upgradeToken function.However, this design introduces an excessive privilege risk. TokenManager.sol#L123-L131 function upgradeToken(string memory symbol, address newImpl, bytes memory callData) external onlyRole(Operator) { require(newImpl != address(0), \"invalid new impl\"); PegToken peg = getDeployedTokenOrRevert(symbol); peg.upgradeToAndCall(newImpl, callData); } 2.In the TokenManager contract, the Operator role can call the setBlacklist function of the specied PegToken contract through the setBlackList function to add a blacklist address. TokenManager.sol#L79-L87 function setBlackList(string memory symbol, address account, bool toBlacklist) external onlyRole(Operator) { require(account != address(0), \"invalid account\"); PegToken peg = getDeployedTokenOrRevert(symbol); peg.setBlacklist(account, toBlacklist); } PegToken.sol#L86-L92 function setBlacklist(address account, bool toBlacklist) external onlyManager { isBlacklist[account] = toBlacklist; emit BlacklistAdded(account, toBlacklist); } 3.In the TokenManager contract, the Operator role can add the Minter role by calling the setMinter function of the specied PegToken contract through the setMinter function. TokenManager.sol#L89-L97 function setMinter(string memory symbol, address account, bool asMinter) external onlyRole(Operator) { require(account != address(0), \"invalid account\"); PegToken peg = getDeployedTokenOrRevert(symbol); peg.setMinter(account, asMinter); } PegToken.sol#L94-L100 function setMinter(address account, bool asMinter) external onlyManager { minters[account] = asMinter; emit MinterSet(account, asMinter); } 4.In the PegToken contract, the Minter role can mint any number of tokens by calling the mint function through the mint function. PegToken.sol#L112-L118 function mint(address to, uint256 amount) external onlyMinter notBlacklisted(to) { _mint(to, amount); } 5.In the TokenManager contract, the FreezeRole role can perform transfer operations by calling the recall function of the specied PegToken contract through the recall function. TokenManager.sol#L159-L165 function recall(string memory symbol, address from, address to, uint256 value) external onlyRole(FreezeRole) { PegToken peg = getDeployedTokenOrRevert(symbol); peg.recall(from, to, value); } PegToken.sol#L120-L126 function recall(address from, address to, uint256 value) external onlyManager { _transfer(from, to, value); emit TokenRecalled(from, to, value); } 6.In the TokenManager contract, the FreezeRole role can freeze the specied token at the specied address by calling the freeze function of the specied PegToken contract through the freezeToken function. TokenManager.sol#L143-L149 function freezeToken(string memory symbol, address account, uint256 value) external onlyRole(FreezeRole) { PegToken peg = getDeployedTokenOrRevert(symbol); peg.freeze(account, value); } PegToken.sol#L128-L136 function freeze(address account, uint256 value) external onlyManager { _transfer(account, address(this), value); freezedToken[account] += value; emit TokenFreezed(account, value); }",
        "labels": [
            "SlowMist",
            "peg-Token",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "DoS issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Flurry Bridge_en-us.pdf",
        "body": "The getVoteCount function uses a for loop to count members votes. When the number of members is large, it will cause DoS due to the increased number of for loops. bridge/contracts/contracts/Federation.sol#L242-L249 function getVoteCount(bytes32 processId) public view override returns(uint) { uint count = 0; for (uint i = 0; i < members.length; i++) { if (votes[processId][members[i]]) count += 1; } return count; }",
        "labels": [
            "SlowMist",
            "Flurry Bridge",
            "Type: Denial of Service Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Safety Reminders",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Flurry Bridge_en-us.pdf",
        "body": "To capture events in the cross-chain bridge, the implementation of subscribing to the events of the specied contract should be adopted to avoid the attacks of fake contract events.",
        "labels": [
            "SlowMist",
            "Flurry Bridge",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Limit of value range",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Flurry Bridge_en-us.pdf",
        "body": "Owner can set fee arbitrarily, and there is no restriction on the value range. and the fee variable is not used in the contract code. bridge/contracts/contracts/Registry.sol#L87-L91 function setFee(address localaddr_, uint256 fee_) external override onlyOwner { require(fee_ > 0, \"Registry: Fee Should be> 0\"); fee[localaddr_] = fee_; emit FeeChanged(localaddr_, fee_); } 8",
        "labels": [
            "SlowMist",
            "Flurry Bridge",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Useless code",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Flurry Bridge_en-us.pdf",
        "body": "There are a lot of comment codes in the contract. It is necessary to conrm whether the comment codes are redundant codes. bridge/contracts/contracts/Registry.sol#L43-L85 // function registerCall( // uint256 alienChainId_, // address alienChainContractAddr_, // address localChainContractAddr_, // bytes4 callSig_ // ) external onlyOwner { // bytes32 callRegistryID = Utils.getCallRegistryId( // alienChainId_, // alienChainContractAddr_, // localChainContractAddr_, // callSig_ // ); // require(!callRegistry[callRegistryID], \"Registry: Call already exists in callRegistry\"); // callRegistry[callRegistryID] = true; // emit CallRegistered( // alienChainId_, // alienChainContractAddr_, // localChainContractAddr_, // callSig_ // ); // } // function unregisterCall( 9 // uint256 alienChainId_, // address alienChainContractAddr_, // address localChainContractAddr_, // bytes4 callSig_ // ) external onlyOwner { // bytes32 callRegistryID = Utils.getCallRegistryId( // alienChainId_, // alienChainContractAddr_, // localChainContractAddr_, // callSig_ // ); // require(callRegistry[callRegistryID], \"Registry: Call not registered\"); // delete callRegistry[callRegistryID]; // emit CallUnregistered( // alienChainId_, // alienChainContractAddr_, // localChainContractAddr_, // callSig_ // ); // } bridge/contracts/contracts/Federation.sol#L159-L240 // function voteCall( // uint256 srcChainID_, // address srcChainContractAddress_, // address dstChainContractAddress_, // bytes32 transactionHash_, // uint32 logIndex_, // bytes calldata payload // ) external override onlyMember { // if (bridge.isCallProcessed( // srcChainID_, // srcChainContractAddress_, // dstChainContractAddress_, // transactionHash_, // logIndex_, // payload // )) { // return; // } // bytes32 callId = Utils.getCallId( 10 // srcChainID_, // srcChainContractAddress_, // dstChainContractAddress_, // transactionHash_, // logIndex_, // payload // ); // if (votes[callId][_msgSender()]) // return; // votes[callId][_msgSender()] = true; // emit VotedCall( // srcChainID_, // srcChainContractAddress_, // dstChainContractAddress_, // transactionHash_, // logIndex_, // _msgSender(), // callId, // payload // ); // uint voteCount = getVoteCount(callId); // if ((voteCount >= required) && (voteCount >= members.length / 2 + 1)) { // bridge.acceptCall( // srcChainID_, // srcChainContractAddress_, // dstChainContractAddress_, // transactionHash_, // logIndex_, // payload // ); // emit ExecutedCall(callId); // } // } // function hasVotedCall( // uint256 srcChainID_, // address srcChainContractAddress_, // address dstChainContractAddress_, // bytes32 transactionHash_, // uint32 logIndex_, // bytes calldata payload // ) external view override returns(bool) { // bytes32 callId = Utils.getCallId( 11 // srcChainID_, // srcChainContractAddress_, // dstChainContractAddress_, // transactionHash_, // logIndex_, // payload // ); // return votes[callId][_msgSender()]; // } // function isCallProcessed( // uint256 srcChainID_, // address srcChainContractAddress_, // address dstChainContractAddress_, // bytes32 transactionHash_, // uint32 logIndex_, // bytes calldata payload // ) external view override returns(bool) { // return bridge.isCallProcessed(srcChainID_, srcChainContractAddress_, dstChainContractAddress_, transactionHash_, logIndex_, payload); // } bridge/contracts/contracts/Bridge.sol#L114-L154 // function acceptCall( // uint256 srcChainID_, // address srcChainTokenAddress_, // address dstChainTokenAddress_, // bytes32 transactionHash_, // uint32 logIndex_, // bytes calldata payload // ) external override onlyFederation nonReentrant { // require(dstChainTokenAddress_ != address(0), \"Bridge: destination chain token address is null\"); // require(srcChainTokenAddress_ != address(0), \"Bridge: src chain token address is null\"); // require(transactionHash_ != bytes32(0), \"Bridge: Transaction is null\"); // require(srcChainTokenAddress_ != address(0), \"src token address is null\"); // bytes4 sig = // payload[0] | // (bytes4(payload[1]) >> 8) | // (bytes4(payload[2]) >> 16) | // (bytes4(payload[3]) >> 24); 12 // bytes32 callRegistryID = Utils.getCallRegistryId( // srcChainID_, // srcChainTokenAddress_, // dstChainTokenAddress_, // sig // ); // require(tokenRegistry.callRegistry(callRegistryID), \"Call Not Registered\"); // bytes32 callId = Utils.getCallId( // srcChainID_, // srcChainTokenAddress_, // dstChainTokenAddress_, // transactionHash_, // logIndex_, // payload // ); // require(processed[callId] == 0, \"Bridge: Already processed\"); // processed[callId] = block.number; // // call the function // (bool success, ) = dstChainTokenAddress_.call(payload); // require(success, \"call fail\"); // } bridge/contracts/libraries/Utils.sol#L6-L18 // function getCallRegistryId( // uint256 alienChainId_, // address alienChainContractAddr_, // address localChainContractAddr_, // bytes4 callSig_ // ) internal pure returns(bytes32) { // return keccak256(abi.encodePacked( // alienChainId_, // alienChainContractAddr_, // localChainContractAddr_, // callSig_ // )); // } 13 bridge/contracts/libraries/Utils.sol#L50-L67 // function getCallId( // uint256 srcChainID_, // address srcChainTokenAddress_, // address dstChainTokenAddress_, // bytes32 transactionHash_, // uint32 logIndex_, // bytes calldata payload // ) internal pure returns (bytes32) { // return keccak256(abi.encodePacked( // \"Call\", // srcChainID_, // srcChainTokenAddress_, // dstChainTokenAddress_, // transactionHash_, // logIndex_, // payload // )); // }",
        "labels": [
            "SlowMist",
            "Flurry Bridge",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Redundant Code Usage",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm_Phase5_en-us.pdf",
        "body": "In the Vault contract of ENFv3/ENF_lowrisk_farm/ENF_lowrisk_ETH_farm, the user will rst calculate the share when performing the withdraw operation. But it is calculated in the same way as the convertToShares function, so it is not necessary to use duplicate code for the calculation without using the convertToShares function. ",
        "labels": [
            "SlowMist",
            "Earning.Farm_Phase5",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Potential Precision Calculation Issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm_Phase5_en-us.pdf",
        "body": "In the Vault contract of ENFv3/ENF_lowrisk_farm/ENF_lowrisk_ETH_farm, users can burn shares through the redeem function to get back staked assets. It uses (shares * assetsPerShare()) / 1e24 to calculate the number of assets corresponding to the share, and the assetsPerShare function will multiply (assetDecimal * 1e18) when performing calculations. If assetDecimal is not equal to 6, dividing 1e24 when performing assets calculation will cause the decimal of the result to deviate. ",
        "labels": [
            "SlowMist",
            "Earning.Farm_Phase5",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Business logic aws in reward distribution",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm_Phase5_en-us.pdf",
        "body": "In the Vault contract of ENF_lowrisk_farm/ENF_lowrisk_ETH_farm, users can obtain shares through deposits, and receive harvest dividends according to the amount of shares held. The key to reward calculation is the accRewardPerTokens and prevBalace parameters. The owner role will increase the accRewardPerTokens parameter every time the harvest operation is performed, and prevBalace represents the user's share balance before reward settlement. But there will be a way to collect rewards by front-run deposits to improve the eciency of capital utilization: When the owner role performs the harvest operation, the user deposits at a higher gas fee. At this point the accRewardPerShares of the protocol has not been updated, and the user will get a portion of the shares. Then the owner performs the harvest operation, and the accRewardPerShares of the protocol will increase. Finally the user makes withdrawal and gets reward. Malicious users can use this method to obtain rewards in the blocks before and after the harvest operation, or even in the same block, without worrying about the problem of liquidity being locked in the protocol, which improves the utilization rate of funds. ",
        "labels": [
            "SlowMist",
            "Earning.Farm_Phase5",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Token Transfer Missing Rewards Update",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm_Phase5_en-us.pdf",
        "body": "In the Vault contract of ENF_lowrisk_farm/ENF_lowrisk_ETH_farm, the _updateUserData function is used to update the user's reward, but it is not updated when the user's share is transferred. This will result in accounting errors during share token transfers. Users can steal rewards by continuously transferring share tokens to new addresses. ",
        "labels": [
            "SlowMist",
            "Earning.Farm_Phase5",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Issue with checking on fromToken",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm_Phase5_en-us.pdf",
        "body": "In the vault contract of ENF_lowrisk_farm/ENF_lowrisk_ETH_farm, the _swap function is used to exchange reward tokens for the specied toToken. It will check whether fromToken is WETH, if the check is true, it will be exchanged through the swapExactETHInput function, if the check is false, it will be exchanged through swapExactTokenInput. However, when fromToken is address(0), the token exchange will also be performed through the swapExactTokenInput function, which may cause the _swap function to fail to perform as expected. ",
        "labels": [
            "SlowMist",
            "Earning.Farm_Phase5",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Incorrect reward receiving address",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm_Phase5_en-us.pdf",
        "body": "In the Vault contract of ENF_lowrisk_farm/ENF_lowrisk_ETH_farm, users can claim rewards through the claim function and specify the receiving address of the rewards. When toAsset is false, the protocol will issue the reward directly to the user, but the destination address of the reward is not the receiver address specied by the user but msg.sender. This is not as expected. ",
        "labels": [
            "SlowMist",
            "Earning.Farm_Phase5",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Direct distribution of rewards is not available",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm_Phase5_en-us.pdf",
        "body": "In the Vault contract of ENF_lowrisk_farm/ENF_lowrisk_ETH_farm, users can claim rewards through the claim function. When toAsset is false, the protocol will directly issue rewards to users. The safeTransferFrom function is used to transfer tokens when issuing rewards, but the contract has not been approved before. This will cause the contract to be unable to successfully execute the safeTransferFrom operation due to insucient allowances, and ultimately result in failure to issue rewards. ",
        "labels": [
            "SlowMist",
            "Earning.Farm_Phase5",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of price manipulation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm_Phase5_en-us.pdf",
        "body": "In the stETH contract of ENF_lowrisk_ETH_farm, the slippage check of SS depends on the virtual price (get_virtual_price) of Curve Pool, which will be aected by the reentrancy vulnerability of ETH/stETH Pool (please check to Ref[1][2]). Failure to check for slippage will result in malicious theft of funds from the strategy. Ref: [1] https://chainsecurity.com/curve-lp-oracle-manipulation-post-mortem/ [2] https://chainsecurity.com/heartbreaks-curve-lp-oracles/",
        "labels": [
            "SlowMist",
            "Earning.Farm_Phase5",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "4.2.1.1 __Guard_init function was not call when initialize",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Hot Cross BSC Bridge V1.0.1_en-us.pdf",
        "body": "ForeignProcessor contract and HomeRequest contract are inherit the Guard contract but dost not call the __Gurad_init function function __ForeignProcessor_init( IERC20 token, ValidatorRegistry validatorRegistry_ ) internal initializer { //SlowMist// Missing call of __Guard_init function require( address(token) != address(0) && Misc.isContract(address(token)), \"ForeignProcessor:Invalid erc20 address provided\" 10 ); require( address(validatorRegistry_) != address(0) && Misc.isContract(address(validatorRegistry_)), \"ForeignProcessor:Invalid validator registry address\" ); erc20 = token; validatorRegistry = validatorRegistry_; } function __HomeRequest_init( BEP20 token, ValidatorRegistry validatorRegistry_ ) internal initializer { //SlowMist// Missing call of __Guard_init function require( address(token) != address(0) && Misc.isContract(address(token)), \"HomeRequest:Invalid BEP20 address\" ); require( address(validatorRegistry_) != address(0) && Misc.isContract(address(validatorRegistry_)), \"HomeRequest:Invalid validator registry address\" ); bep20 = token; validatorRegistry = validatorRegistry_; } Fix status: fixed. 11 5.",
        "labels": [
            "SlowMist",
            "Hot Cross BSC Bridge V1.0.1",
            "Severity: Informational"
        ]
    },
    {
        "title": "Access control issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - CheersUp_alpha8_en-us.pdf",
        "body": "The Owner role has the right to call the giveaway function to airdrop any number of blind boxes to any address at any time. function giveaway(address address_, uint64 numberOfTokens_) external onlyOwner nonReentrant { require(address_ != address(0), \"zero address\"); require(numberOfTokens_ > 0, \"invalid number of tokens\"); require(totalMinted() + numberOfTokens_ <= MAX_TOKEN, \"max supply exceeded\"); _safeMint(address_, numberOfTokens_); } The Owner role has the right to modify the cucpContractAddress contract address through the setCUCPContractAddress function, and unauthorized modication will result in the user's blind box being unable to be opened or arbitrarily modifying the blind box. function setCUCPContractAddress(address address_) public onlyOwner { cucpContractAddress = address_; } The Owner role has the right to modify the price of the blind box purchased by the user through the setWhitelistSaleCong function and the setPublicSaleCong function at any time. If the price of the blind box is modied after the sale starts, the user's transaction will fail. function setWhitelistSaleConfig(WhitelistSaleConfig calldata config_) external onlyOwner { require(config_.price > 0, \"sale price must greater than zero\"); whitelistSaleConfig = config_; } 9 function setPublicSaleConfig(PublicSaleConfig calldata config_) external onlyOwner { require(config_.price > 0, \"sale price must greater than zero\"); publicSaleConfig = config_; } The Owner has the right to modify the revealCong parameter through the setRevealCong function, which includes the address of the contract that opens the blind box, and the time and closing time of the blind box sale. function setRevealConfig(RevealConfig calldata config_) external onlyOwner { revealConfig = config_; }",
        "labels": [
            "SlowMist",
            "CheersUp_alpha8",
            "Type: Authority Control Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Random number problem",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - CheersUp_alpha8_en-us.pdf",
        "body": "The tokenId in the contract is related to the properties of the NFT. The tokenId is randomly generated through the random number on the chain, which will cause the random number to be predicted. function mint(address address_, uint256 cucpTokenId_) public returns(uint256) { require(_msgSender() == cucpContractAddress, \"not authorized\"); 10 require(_numberMinted + 1 <= MAX_TOKEN, \"mint would exceed max supply\"); uint256 tokenId = randomToken(address_); _safeMint(address_, tokenId); unchecked { _numberMinted += 1; } emit CheersUpRevealed(cucpTokenId_, tokenId); return tokenId; } function getRandomTokenId() internal returns (uint256) { unchecked { uint256 remain = MAX_TOKEN - _numberMinted; uint256 pos = unsafeRandom() % remain; uint256 val = _randIndices[pos] == 0 ? pos : _randIndices[pos]; _randIndices[pos] = _randIndices[remain - 1] == 0 ? remain - 1 : _randIndices[remain - 1]; return val; } } /** * @notice unsafeRandom is used to generate a random number by on-chain randomness. * Please note that on-chain random is potentially manipulated by miners, and most scenarios suggest using VRF. * @return randomly generated number. */ function unsafeRandom() internal view returns (uint256) { unchecked { return uint256(keccak256(abi.encodePacked( blockhash(block.number-1), block.difficulty, block.timestamp, _numberMinted, tx.origin ))); } }",
        "labels": [
            "SlowMist",
            "CheersUp_alpha8",
            "Type: Others",
            "Severity: Low"
        ]
    },
    {
        "title": "4.3.1.1 Risk of Oracle Manipulation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Shield_en-us.pdf",
        "body": "In DDSContracts, the price is obtained from Uniswap's getAmountsIn through the getPriceByWBTCDAI function, but this interface obtains the real-time price of the WBTC/DAI pool, and there is a risk of malicious manipulation. 6 Fix suggestion: It is recommended to use Uniswap's delayed price feed oracle for acquisition. ",
        "labels": [
            "SlowMist",
            "Shield",
            "Severity: Critical"
        ]
    },
    {
        "title": "4.3.1.2 Price acquisition issue when opening and closing positions",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Shield_en-us.pdf",
        "body": "In the DDSContracts contract, the price used when opening and closing a position is passed in from the outside, which will cause the user to pass in any price when opening and closing a position. After communicating with the project party, this is the test code, and the oracle will be used to feed the price during the formal deployment. Fix suggestion: It is recommended to use Uniswap's delayed price feed oracle for acquisition. ",
        "labels": [
            "SlowMist",
            "Shield",
            "Severity: Critical"
        ]
    },
    {
        "title": "4.3.2.1 The available funds were not processed when the riskControl",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Shield_en-us.pdf",
        "body": "closed the position In the Pool contract, when riskClose is triggered when the risk control liquidation is triggered, if the margin is insufficient and the pool order transfer fails, risk funds will be used to make up for the insufficient part, and all available funds of the user will be deducted. However, the user's available funds are not actually set to 0. Fix suggestion: It is recommended that the available funds should be emptied after the transfer of insurance funds. ",
        "labels": [
            "SlowMist",
            "Shield",
            "Severity: High"
        ]
    },
    {
        "title": "4.3.3.1 Insecure random number",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Shield_en-us.pdf",
        "body": "In the Pool contract, the getMatchLp2Object function uses block difficulty and block time now as the random number seed to participate in the calculation of random numbers. But block difficulty and time can be predicted or manipulated. Fix suggestion: It is recommended to use the random number provided by chainlink that cannot be manipulated. ",
        "labels": [
            "SlowMist",
            "Shield",
            "Severity: Low"
        ]
    },
    {
        "title": "4.3.4.1 Event missing",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Shield_en-us.pdf",
        "body": "In the DDSContracts contract, the owner can set the key parameters of the contract through the setExchageAddress, setPoolTokenAddr, setPrivatePool, setPublicPool, setFormular, and setrepayFudAddr functions, but no event recording is performed. Fix suggestion: In order to facilitate follow-up records and community viewing, it is recommended to record events for sensitive parameter modifications. ",
        "labels": [
            "SlowMist",
            "Shield",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.3.4.2 Does not follow the `Checks-effects-interactions` model",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Shield_en-us.pdf",
        "body": "In Contracts and Pool2 contracts, when deposit and provide functions are used to recharge, the state is changed first, and then the corresponding tokens are transferred to the contract. Fix suggestion: It is recommended to follow the Checks-effects-interactions model, first transfer the corresponding tokens and then change the state. 10 ",
        "labels": [
            "SlowMist",
            "Shield",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.3.4.3 Redundant code",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Shield_en-us.pdf",
        "body": "Provide price feed interfaces such as updateImpliedVolrate and updatePriceByOwner in the DDSFormular contract to update the price. However, these interfaces are not used by the Contracts contract, and these price-feeding interfaces have no permission control and can be called by any user. 11 Fix suggestion: If this interface is a test interface, it is recommended to remove it during formal deployment. If it will use the suggestions in subsequent iterations for permission control. ",
        "labels": [
            "SlowMist",
            "Shield",
            "Severity: Informational"
        ]
    },
    {
        "title": "Potential denial of service risk due to gulp operations",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase5 - SlowMist Audit Report.pdf",
        "body": "- - - - - - - - - - - - - - - - - In the Actions contract, when the user performs the autoJoinSmartPool operation, the number of shares the user can obtain will be calculated through the _calculateShare function, and minPoolAmountOut will be checked at the end. The _calculateShare function obtains the number of tokens recorded in the pool through bPool's getBalance when calculating the share, but unfortunately any user can update this parameter through bPool's gulp function. Therefore, when an ordinary user performs an autoJoinSmartPool operation, a malicious user directly transfers funds to bPool and calls the gulp function to update the token balance recorded in the pool. At this time, ordinary users will not be able to successfully add liquidity due to the minPoolAmountOut check. If the minPoolAmountOut value passed in by an ordinary user is 0, it may cause an interest rate ination attack. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase5 - SlowMist Audit Report",
            "Type: Denial of Service Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Incorrect event logging",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase5 - SlowMist Audit Report.pdf",
        "body": "In the CRP contract, the createPool function adds the creator parameter as the real creator of the pool. However, the corresponding events were not modied accordingly. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase5 - SlowMist Audit Report",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Incorrect WETH address",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase5 - SlowMist Audit Report.pdf",
        "body": "The WETH address constant is hard-coded in the Actions contract, but this address is an EOA address on the Ethereum mainnet and is not the correct WETH address. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase5 - SlowMist Audit Report",
            "Type: Others",
            "Severity: High"
        ]
    },
    {
        "title": "Incorrect poolTokens check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase5 - SlowMist Audit Report.pdf",
        "body": "In the autoJoinSmartPool function of the Actions contract, it checks the tokens deposited by the user through poolTokens[i] == handleToken , but handleToken has been replaced by the issueToken parameter during the native token checking phase. Therefore, the poolTokens[i] == handleToken check is not accurate. If handleToken is WETH, it will cause an error in the _makeSwap operation. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase5 - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Redundant STBT token check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase5 - SlowMist Audit Report.pdf",
        "body": "In the autoJoinSmartPool and _exit functions of the Actions contract, when making a token transfer, it will be checked whether the transferred token is an STBT token. But in fact, the protocol does not allow deposits of STBT tokens, and STBT tokens will also be converted into stablecoins after the ETF expires. Therefore, theoretically, there will be no STBT tokens in the contract, so the STBT token check is redundant. . ",
        "labels": [
            "SlowMist",
            "DeSyn Phase5 - SlowMist Audit Report",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Potential risk of slot conict",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase5 - SlowMist Audit Report.pdf",
        "body": "In this protocol iteration, both SmartPoolManager and Actions contracts have changed their storage structures. If these contracts use an upgradeable model, and upgrading the contract directly on the original basis may lead to contract storage slot conicts. In fact, the Actions contract is an upgradeable contract, so special attention should be paid to such risks.",
        "labels": [
            "SlowMist",
            "DeSyn Phase5 - SlowMist Audit Report",
            "Type: Variable Coverage Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of event forgery",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase5 - SlowMist Audit Report.pdf",
        "body": "In the CRP contract, the exitPool function adds a user parameter to record the real caller when the user exits through the Actions contract. However, users can also exit by calling the exitPool function of the CRP contract. They can pass in any user parameter to make the LogExit event record an incorrect value. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase5 - SlowMist Audit Report",
            "Type: Malicious Event Log Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Potential risk of denial of service due to large CRPFactory array",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase5 - SlowMist Audit Report.pdf",
        "body": "In the CRPFactory contract, when the Blabs role performs addCRPFactory and removeCRPFactory operations, it will use a for loop to traverse the entire CRPFactorys array. If the array length is too large, it will lead to DoS risks. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase5 - SlowMist Audit Report",
            "Type: Denial of Service Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Potential risk of endless loop",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase5 - SlowMist Audit Report.pdf",
        "body": "In the CRPFactory contract, the isCrp function is used to check whether the address passed by the user is a CRP contract. If not, the CRPFactorys array will be circulated and the isCrp function of other CRPFactory will be called to check. However, it should be noted that if the Blabs role adds this contract address to the CRPFactorys array, the user will fall into an innite loop error when querying a CRP address that is not recorded in this contract through the isCrp function. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase5 - SlowMist Audit Report",
            "Type: Denial of Service Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Potential Token Compatibility Issues",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/STONE BTC - SlowMist Audit Report_en-us.pdf",
        "body": "In the StoneBTCVault contract, users can deposit funds through the deposit/depositMultiple functions. The contract directly transfers the user-specied amount of wrapped BTC tokens using the safeTransferFrom function. It is important to note that the contract is not compatible with fee-on-transfer wrapped BTC tokens. Similarly, when users make deposits or withdrawals, the contract performs decimal conversion using 18- tokenDecimals[_token] . This renders the contract incompatible with any wrapped BTC tokens that have a decimal greater than 18. ",
        "labels": [
            "SlowMist",
            "STONE BTC - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Potential risk of not being able to collect fees",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/STONE BTC - SlowMist Audit Report_en-us.pdf",
        "body": "In the StoneBTCVault contract, users are charged a certain fee when making deposits or withdrawals. The fee amount is determined by amount * feeRate / FEE_BASE . Due to Solidity's division operation truncating the decimal part, if the user's deposit or withdrawal amount is relatively small, the calculated fee will be 0. This prevents the contract from collecting deposit/withdrawal fees. ",
        "labels": [
            "SlowMist",
            "STONE BTC - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Unnecessary unchecked",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/STONE BTC - SlowMist Audit Report_en-us.pdf",
        "body": "In the StoneBTCVault contract, all the for loop functionalities use unchecked for incrementing i to reduce gas consumption. However, the contract's Solidity compilation uses ^0.8.26 , and Solidity introduced the unchecked loop increments feature in version 0.8.22, making the use of unchecked unnecessary. ",
        "labels": [
            "SlowMist",
            "STONE BTC - SlowMist Audit Report",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of DoS when removing supported tokens",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/STONE BTC - SlowMist Audit Report_en-us.pdf",
        "body": "In the StoneBTCVault contract, privileged roles can add/remove supported wrapped BTC tokens through the addSupportedTokens/removeSupportedTokens functions. When performing the removeSupportedTokens operation, the contract checks that the balance of the token being removed must be zero. This can be easily exploited, as users can donate a small amount of tokens to prevent the removeSupportedTokens function from working properly. It is also important to note that when users withdraw, the contract converts the decimal to the decimal of the token being withdrawn. When the decimal of this token is smaller than the decimal of STONE BTC, there will always be a small amount of dust tokens left in the vault. This indirectly prevents the removeSupportedTokens function from working correctly. ",
        "labels": [
            "SlowMist",
            "STONE BTC - SlowMist Audit Report",
            "Type: Denial of Service Vulnerability",
            "Severity: High"
        ]
    },
    {
        "title": "The actual deposit amount may dier from the contract balance",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/STONE BTC - SlowMist Audit Report_en-us.pdf",
        "body": "In the StoneBTCVault contract, the _checkDepositAllowed function checks the depositCapacity based on the balance of wrapped BTC tokens in the contract. Similarly, the getDepositAmounts function retrieves token balances to determine the deposit amounts. These values may dier from the actual deposit amounts made by users. Users might accidentally transfer supported tokens into the vault, or some users might send small donations to the vault. Both scenarios will cause the above two functions to obtain amounts that are greater than the users' actual deposit amounts. ",
        "labels": [
            "SlowMist",
            "STONE BTC - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Not checking if withAmount is greater than 0 when retrieving all tokens",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/STONE BTC - SlowMist Audit Report_en-us.pdf",
        "body": "In the Proposal contract, users can retrieve all their STONE tokens used for voting through the retrieveAllToken function. It uses a temporary variable withAmount to record the amount of STONE tokens that can be withdrawn. However, it does not check if withAmount is greater than 0 before initiating the transfer, which may result in the contract sending a 0 transfer and wasting gas. ",
        "labels": [
            "SlowMist",
            "STONE BTC - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risks of excessive privilege",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/STONE BTC - SlowMist Audit Report_en-us.pdf",
        "body": "In the StoneBTC contract, the contract deployer is set as the DEFAULT_ADMIN_ROLE. The admin role can arbitrarily change the MINTER_ROLE/BURNER_ROLE roles, which are involved in minting and burning STONE BTC. This leads to the risk of excessive privileges. Similarly, in the StoneBTCVault and Proposal contracts, the initial DEFAULT_ADMIN_ROLE is also the deployer. Assigning sensitive permissions to an EOA address not only creates the risk of excessive privileges but also introduces a single point of failure. ",
        "labels": [
            "SlowMist",
            "STONE BTC - SlowMist Audit Report",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Low-level call issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - CFFv2_en-us.pdf",
        "body": "In the CRVExchangeV2 contract, the handleExtraToken function is used to perform the token transfer operation after the token swap. Low-level calls are used when transferring native tokens, but the amount of gas usage is not limited, which may lead to unknown security risks. ",
        "labels": [
            "SlowMist",
            "CFFv2",
            "Type: Others",
            "Severity: Low"
        ]
    },
    {
        "title": "Contract variable usage issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - CFFv2_en-us.pdf",
        "body": "In the IWbtcPoolBase contract, when the Controller role calls the deposit function, the deposit_wbtc_amount parameter will increase, but when the Controller role calls the withdraw function, the deposit_wbtc_amount parameter does not decrease accordingly. And the withdraw_wbtc_amount parameter in the contract is not used. 16 The deposit_eth_amount and withdraw_eth_amount parameters in the IETHPoolBase contract are the same. The deposit_usdc_amount and withdraw_usdc_amount parameters in the IUSDCPoolBase contract are the same. ",
        "labels": [
            "SlowMist",
            "CFFv2",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing event record",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - CFFv2_en-us.pdf",
        "body": "In the IWbtcPoolBase contract, the owner can modify the controller and vault addresses through the setController function, but no event recording is performed. ",
        "labels": [
            "SlowMist",
            "CFFv2",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Logical redundancy issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - CFFv2_en-us.pdf",
        "body": "In the AavePool contract, the withdraw_from_curve function will rst authorize the lp_token_addr token to the pool_deposit contract and then call the remove_liquidity_one_coin function of the pool_deposit contract to remove liquidity. However, since the minter role of the lp_token_addr contract is the pool_deposit contract, there is no need to perform an approve operation. ",
        "labels": [
            "SlowMist",
            "CFFv2",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Reentrancy risk 20",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - CFFv2_en-us.pdf",
        "body": "In the CFVaultV2 contract, the user can withdraw assets through the withdraw function, but in the withdraw function, it will rst transfer the assets to the user and then destroy the user's credentials through the destroyTokens function. If the transfer is native tokens, this will lead to a risk of reentrancy. ",
        "labels": [
            "SlowMist",
            "CFFv2",
            "Type: Reentrancy Vulnerability",
            "Severity: Critical"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - CFFv2_en-us.pdf",
        "body": "In the IWbtcPoolBase, IETHPoolBase and IUSDCPoolBase contracts, the owner can call any data through the callWithData function. Since these strategies contracts indirectly keep the user's assets, any data call will cause the risk of excessive owner authority. ",
        "labels": [
            "SlowMist",
            "CFFv2",
            "Type: Authority Control Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - TaprootChain - BTCLayer2Bridge_en-us.pdf",
        "body": "1.In the BTCLayer2Bridge contract, the superAdmin role is initialized in the initialize function and can be modied in the setSuperAdminAddress function. The superAdmin can also set the normalAdmin role through the setNormalAdminAddress function. ",
        "labels": [
            "SlowMist",
            "TaprootChain - BTCLayer2Bridge",
            "Type: Authority Control Vulnerability Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Receive can lock users native tokens",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - TaprootChain - BTCLayer2Bridge_en-us.pdf",
        "body": "There is a receive function in the BTCLayer2Bridge contract so that the contracts can receive native tokens. However, the receive function can lock users native tokens when users transfer the native token in these contracts by mistake. And the payable modier can help these functions which need to call with the native tokens. ",
        "labels": [
            "SlowMist",
            "TaprootChain - BTCLayer2Bridge",
            "Type: Others",
            "Severity: Low"
        ]
    },
    {
        "title": "Parameter _symbol is not case checked",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - TaprootChain - BTCLayer2Bridge_en-us.pdf",
        "body": "The _symbol eld of ERC20 tokens and ERC721 tokens on the Ethereum chain is case-sensitive, but for BRC20 Tick is not case-sensitive. In the BTCLayer2Bridge contract, the addERC20TokenWrapped function and the addERC721TokenWrapped function do not standardize the case format of the _symbol parameter passed in. ",
        "labels": [
            "SlowMist",
            "TaprootChain - BTCLayer2Bridge",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Delete the address without popping up the list",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - TaprootChain - BTCLayer2Bridge_en-us.pdf",
        "body": "In the addUnlockTokenAdminAddress function, the superAdmin and normalAdmin roles can add user address into the unlockTokenAdminAddressList and set the unlockTokenAdminAddressSupported to true. But in the delUnlockTokenAdminAddress function, the superAdmin and normalAdmin roles remove the unlockTokenAdminAddress just by setting the unlockTokenAdminAddressSupported to false without popping up from the unlockTokenAdminAddressList . Once called the delUnlockTokenAdminAddress function deletes the address, the superAdmin and normalAdmin roles can call the addUnlockTokenAdminAddress function to add the same address added before into the unlockTokenAdminAddressList and the length of the unlockTokenAdminAddressList will increase. ",
        "labels": [
            "SlowMist",
            "TaprootChain - BTCLayer2Bridge",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "SuperAdmin Transfer Recommendations",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - TaprootChain - BTCLayer2Bridge_en-us.pdf",
        "body": "In the BTCLayer2Bridge contract, superAdmin directly overwrites the previous address with the new address during transfer. If superAdmin calls the setSuperAdminAddress function with the wrong address when the operation is wrong, this will result in the loss of the superAdmin role permissions. ",
        "labels": [
            "SlowMist",
            "TaprootChain - BTCLayer2Bridge",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Low-level call reminder",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - TaprootChain - BTCLayer2Bridge_en-us.pdf",
        "body": "In the BTCLayer2Bridge contract, the burnERC20Token, batchBurnERC721Token, lockNativeToken, and unlockNativeToken use low-level calls to transfer native tokens to the feeAddress and to address from the unlockNativeToken function. But do not limit the amount of gas used to transfer native tokens to the user. ",
        "labels": [
            "SlowMist",
            "TaprootChain - BTCLayer2Bridge",
            "Type: Reentrancy Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Preemptive Initialization",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - TaprootChain - BTCLayer2Bridge_en-us.pdf",
        "body": "By calling the initialize and deploy functions to initialize the contracts, there is a potential issue that malicious attackers preemptively call the initialize function to initialize. ",
        "labels": [
            "SlowMist",
            "TaprootChain - BTCLayer2Bridge",
            "Type: Race Conditions Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Dev address setting enhancement suggestions",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - TaprootChain - BTCLayer2Bridge_en-us.pdf",
        "body": "In the contract, the superAdmin role can set the feeAddress to receive the fee. If the addfeeAddress is an EOA address, in a scenario where the private keys are leaked, the teams revenue will be stolen. ",
        "labels": [
            "SlowMist",
            "TaprootChain - BTCLayer2Bridge",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "External call reminder",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - TaprootChain - BTCLayer2Bridge_en-us.pdf",
        "body": "In the contract, the core functions mintERC20Token , burnERC20Token , batchMintERC721Token , batchBurnERC721Token , unlockNativeToken , and lockNativeToken , which are mainly used for fund interaction by unlockTokenAdminAddressSupported users, are all completed by external calls to bridgeERC20Address and bridgeERC721Address. The current contract also does complete verication of the incoming parameters txHash , _symbol , _baseURI , destBtcAddr , inscriptionNumbers , inscriptionIds , etc., and these verications may be completed by a centralized system or these external call contracts. This audit does not include centralized systems or external call contracts. Users need to pay attention to these external risks when calling these functions.",
        "labels": [
            "SlowMist",
            "TaprootChain - BTCLayer2Bridge",
            "Type: Unsafe External Call Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Excessive Authority Issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - wault.finance(WSwap)_en-us.pdf",
        "body": "The owner can set the value of wexPerBlock arbitrarily, which will affect the profit of wexReward, and there is no limit on the value range of wexPerBlock, and there is a issue of excessive authority. https://bscscan.com/address/0x22fB2663C7ca71Adc2cc99481C77Aaf21E152e2D function setWexPerBlock(uint256 _wexPerBlock) public onlyOwner { require(_wexPerBlock > 0, \"!wexPerBlock-0\"); wexPerBlock = _wexPerBlock; } Owner can add pool, can set the allocPoint of pool, there is a issue of selfish mining. function add( uint256 _allocPoint, IERC20 _lpToken, bool _withUpdate ) public onlyOwner { if (_withUpdate) { massUpdatePools(); } uint256 lastRewardBlock = block.number > startBlock ? block.number : startBlock; totalAllocPoint = totalAllocPoint.add(_allocPoint); poolInfo.push( PoolInfo({ lpToken: _lpToken, allocPoint: _allocPoint, lastRewardBlock: lastRewardBlock, accWexPerShare: 0 }) ); 12 function set( uint256 _pid, uint256 _allocPoint, bool _withUpdate ) public onlyOwner { if (_withUpdate) { massUpdatePools(); } totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add( _allocPoint ); poolInfo[_pid].allocPoint = _allocPoint; }",
        "labels": [
            "SlowMist",
            "wault.finance(WSwap)",
            "Type: Others",
            "Severity: Low"
        ]
    },
    {
        "title": "Ignoring the Return Value",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist_Audit_Report_StakeStone_SymbioticDepositWBETHStrategy_en-us.pdf",
        "body": "In the SymbioticDepositWBETHStrategy contract, the owner can extract the claimable ETH by calling the claimPendingAssets function. This function will call the claimWithdraw function of the UnwrapTokenV1ETH contract to claim the corresponding ETH by passing in a specic index. The claimWithDraw function returns a value (_ethAmount) after each call to represent the number of ETH claimed. Code Location: contracts/strategies/SymbioticDepositWBETHStrategy.sol#L176 function claimPendingAssets(uint256 _index) external onlyOwner { IUnwrapTokenV1ETH(unwrapTokenV1ETHAddr).claimWithdraw(_index); }",
        "labels": [
            "SlowMist",
            "SlowMist_Audit_Report_StakeStone_SymbioticDepositWBETHStrategy",
            "Type: Others",
            "Severity: Information"
        ]
    },
    {
        "title": "Unable to perform uniswapV3FlashCallback operation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn ETH Flashloan Leverage Staking - SlowMist Audit Report.pdf",
        "body": "In LeverageStake contracts, the uniswapV3FlashCallback function is called by the Uniswap v3 Pool ash function. It will call the repayBorrow/withdraw/deposit function within the LeverageStake contract to interact with the AAVE. However, the repayBorrow/withdraw/deposit function uses _checkTx for permission checking and can only be called by the admin role. This will result in the Uniswap v3 Pool not being able to call back to the uniswapV3FlashCallback function properly. ",
        "labels": [
            "SlowMist",
            "DeSyn ETH Flashloan Leverage Staking - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Potential liquidation risk caused by unrestricted ash loan leverage",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn ETH Flashloan Leverage Staking - SlowMist Audit Report.pdf",
        "body": "In LeverageStake contracts, the user can ashloan from the Uniswap v3 Pool with the function createLeverByFlashloan in order to make deposits in AAVE for higher prots. Unfortunately the increaseLeverByFlashloan function does not check the amount of leverage on the current bPool debt. This allows a malicious caller to increase the leverage of the bPool with the increaseLeverByFlashloan function to bring the user's funds closer to the liquidation line. This puts the user's funds at risk of liquidation when the stETH price uctuates. ",
        "labels": [
            "SlowMist",
            "DeSyn ETH Flashloan Leverage Staking - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Flashloan function missing privilege control",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn ETH Flashloan Leverage Staking - SlowMist Audit Report.pdf",
        "body": "In the LeverageStake contract, any user can call the increaseLeverByFlashloan/decreaseLeverByFlashloan function. Malicious users can consume bPool funds through frequent calls, for example: exchange slippage leads to capital damage, frequent entry/exit of the AAVE pool leads to losses in fees, and frequent ash loans lead to losses in ash loan fees. Although this consumes gas for the malicious caller, it can reduce losses or even make a prot by arbitraging in the Curve Pool or providing liquidity in the Uniswap Pool. ",
        "labels": [
            "SlowMist",
            "DeSyn ETH Flashloan Leverage Staking - SlowMist Audit Report",
            "Type: Authority Control Vulnerability Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Allowing the free choice of isTrade leads to a potential risk of arbitrage",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn ETH Flashloan Leverage Staking - SlowMist Audit Report.pdf",
        "body": "The increaseLever/increaseLeverByFlashloan/convertToAstEth functions of the LeverageStake contract allow the user to freely choose whether or not to exchange ETH-stETH through the Curve Pool by passing in the isTrade parameter. Even though the contract has a slippage check via the defaultSlippage parameter, the user still has an arbitrage prot. ",
        "labels": [
            "SlowMist",
            "DeSyn ETH Flashloan Leverage Staking - SlowMist Audit Report",
            "Type: Reordering Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Allow any type of ETF to interact with AAVE",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn ETH Flashloan Leverage Staking - SlowMist Audit Report.pdf",
        "body": "In the _checkTx function of the LeverageStake contract, it uses if conditions to check the status of the ETF, which means that both open and closed ETFs can interact with AAVE. And for closed ETFs, it will no longer check whether the closed period of the pool has ended. This is dierent from the previous version's implementation. ",
        "labels": [
            "SlowMist",
            "DeSyn ETH Flashloan Leverage Staking - SlowMist Audit Report",
            "Type: Others",
            "Severity: Information"
        ]
    },
    {
        "title": "Risk of unintended claim operations",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - pufETH_en-us.pdf",
        "body": "In the PuerVault contract, Users can collect ETH tokens to be claimed in the lido withdrawal process by calling the claimWithdrawalsFromLido function. The normal expectation of this function is that the incoming requestIds parameter should be created by the initiateETHWithdrawalsFromLido function, and only then the lidoLockedETH variable will be deducted correctly. However, a malicious user can directly call requestWithdrawals function in lido to generate requestIds, and then call claimWithdrawalsFromLido function, lidoLockedETH will be deducted additionally, resulting in a normal claim operation failing due to insucient lidoLockedETH. The following scenarios can be used as a reference: 1. The contract has a total of 10 ETH total deposited in Lido, at which point a normal user calls the initiateETHWithdrawalsFromLido function to submit a request to withdraw 10 ETH($.lidoLockedETH = 10). 2. A malicious user calls requestWithdrawals function directly on Lido to generate a withdrawal request to withdraw 1 ETH(need to specify WithdrawalRequest._owner as puerVault). 3. The malicious user calls the claimWithdrawalsFromLido function and passes in the requestIds generated in step 2, the value of $.lidoLockedETH is equal to 9. 4. A normal user calls the claimWithdrawalsFromLido function and passes in the requestIds generated in the rst step, at which point the amount of ETH to be fetched is 10, while the value of $.lidoLockedETH is 9, which causes $.lidoLockedETH -= msg.value to overow and the entire transaction fails. 5. So the nal result is that 10 ETH cannot be successfully withdrawn through the puerVault contract. And this security risk also exists when withdrawing ETH from EigenLayer(Specify withdrawer as the puerVault address to achieve the same eect). ",
        "labels": [
            "SlowMist",
            "pufETH",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Authority transfer enhancement",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - pufETH_en-us.pdf",
        "body": "The pauserMultisig role does not adopt the pending and access processes. If the pauserMultisig is incorrectly set, the owner permission will be lost. ",
        "labels": [
            "SlowMist",
            "pufETH",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Gas optimization",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Laqira NFT marketplace_en-us.pdf",
        "body": "Using assert will consume the remaining gas when the transaction fails to execute. ",
        "labels": [
            "SlowMist",
            "Laqira NFT marketplace",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Unused return",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Laqira NFT marketplace_en-us.pdf",
        "body": "There is a return value in the setRoyalties function in the RoyaltiesProvider contract, and the function is called here without checking its return value. Laqira-Collectibles-and-NFT-Marketplace/contracts/LaqiraNFT.sol #L58-L76 function mint(string memory _tokenURI, address[] memory royaltyOwners, uint96[] memory values) public virtual payable { uint256 transferredAmount = msg.value; require(transferredAmount >= mintingFee, 'Insufficient paid amount'); (bool success, ) = feeAddress.call{value: transferredAmount}(new bytes(0)); 14 require(success, 'Transfer failed'); _tokenIds.increment(); uint256 newTokenId = _tokenIds.current(); pendingRequests.push(newTokenId); _pendingIds[newTokenId].owner = _msgSender(); _pendingIds[newTokenId].tokenURI = _tokenURI; _userPendingIds[_msgSender()].push(newTokenId); IRoyaltiesProvider(royaltiesProviderAddress).setRoyalties(newTokenId, royaltyOwners, values); }",
        "labels": [
            "SlowMist",
            "Laqira NFT marketplace",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing event record",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Laqira NFT marketplace_en-us.pdf",
        "body": "Modifying sensitive parameters in the contract does not log an event. Laqira-Collectibles-and-NFT-Marketplace/contracts/LaqiraNFT.sol #L123-L133 function setMintingFeeAmount(uint256 _amount) public virtual onlyOwner { mintingFee = _amount; } function setAsOperator(address _operator) public virtual onlyOwner { operators[_operator] = true; } function removeOperator(address _operator) public virtual onlyOwner { operators[_operator] = false; } 15 ",
        "labels": [
            "SlowMist",
            "Laqira NFT marketplace",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing zero address validation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Laqira NFT marketplace_en-us.pdf",
        "body": "Missing zero address validation when setting the address in the function. ",
        "labels": [
            "SlowMist",
            "Laqira NFT marketplace",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Redundant code",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - IHO V1.0.0_en-us.pdf",
        "body": "Ether is not accepted by default, which is a redundant code. cross-send/contracts/CrossSend.sol#L41-L47 initial-hotcross-oering/contracts/BaseIHO.sol#L67-L73 fallback () external payable { revert(\"cannot directly accept currency transfers\"); } receive () external payable { revert(\"cannot directly receive currency transfers\"); 15 }",
        "labels": [
            "SlowMist",
            "IHO V1.0.0",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Gas optimization",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - IHO V1.0.0_en-us.pdf",
        "body": "If one of the batch transfers fails, the transaction that was previously transferred normally will be reverted, but Gas has been consumed. It is a gas optimization issue here. cross-send/contracts/CrossSend.sol#L175-L210 function sendToken( IERC20 token, address[] memory recipients, uint256[] memory amounts ) private returns(uint256) { uint256 total = 0; for (uint256 i = 0; i < recipients.length ; i++) { require(_msgSender() != recipients[i], \"sender != recipient\"); token.safeTransferFrom(_msgSender(), recipients[i], amounts[i]); total += amounts[i]; } return total; } function sendNative( address[] memory recipients, uint256[] memory amounts ) private returns(uint256) { uint256 total = 0; 16 for (uint256 i = 0; i < recipients.length ; i++) { total += amounts[i]; (bool success, ) = payable(recipients[i]).call{value: amounts[i]}(\"\"); require(success, \"native transfer failed\"); } return total; }",
        "labels": [
            "SlowMist",
            "IHO V1.0.0",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of allowance amount abuse",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - IHO V1.0.0_en-us.pdf",
        "body": "There have an allowance amount in the contract, but the distributeTokenFee function does not limit the caller, and there is an issue of being called arbitrarily, but it can only transfer the balance of the sender to the feeCollector. cross-send/contracts/fee-managers/RecipientCountFee.sol#L65-L83 function distributeTokenFee( uint256 txRecipientCount, uint256, uint256, uint256, uint256, address sender ) public override { uint256 payableFee = txRecipientCount * tokenFeePerRecipient; 17 if(payableFee < minTokenFee) { payableFee = minTokenFee; } else if (payableFee > maxTokenFee) { payableFee = maxTokenFee; } token.safeTransferFrom(sender, feeCollector, payableFee); }",
        "labels": [
            "SlowMist",
            "IHO V1.0.0",
            "Type: Authority Control Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Price manipulation issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - IHO V1.0.0_en-us.pdf",
        "body": "The IOUPrice is calculated using totalFarmingTokenBalance. Attackers can control totalFarmingTokenBalance to manipulate IOUPrice. The current code does not nd the location where IOUPrice is used. Referencehttps://slowmist.medium.com/cream-hacked-analysis-us-130-million-hacked-95c9410320ca cross-yield/contracts/core/CrossYield.sol#L95-L101 function IOUPrice() public view returns (uint256) { uint256 IOUSupply = totalSupply(); return IOUSupply == 0 ? 1e18 : (totalFarmingTokenBalance() * 1e18) / IOUSupply; } 18 cross-yield/contracts/core/CrossYield.sol#L65-L67 function totalFarmingTokenBalance() public view returns (uint256) { return farmingToken().balanceOf(address(this)) + strategy.balanceOf(); }",
        "labels": [
            "SlowMist",
            "IHO V1.0.0",
            "Type: Others",
            "Severity: Medium"
        ]
    },
    {
        "title": "Sandwich attacks issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - IHO V1.0.0_en-us.pdf",
        "body": "There is no slippage check during swap, and there is a risk of sandwich attack. IPancakeRouter02(pcsRouter).swapExactTokensForTokens(cakeBalance, 0,cakeToBaseRoute, address(this), block.timestamp); IPancakeRouter02(pcsRouter) .swapExactTokensForTokens(toSwap, 0, route, address(this), block.timestamp); Reference https://medium.com/coinmonks/demystify-the-dark-forest-on-ethereum-sandwich-attacks-5a3aec9fa33e cross-yield/contracts/libs/OptimalSwap.sol#L14-L63 function prepareLiquidity( address cake, address[2] memory lpTokens, 19 address wbnb, address busd, address farmingToken, address pcsRouter, uint256 fee ) external { uint256 cakeBalance = IERC20(cake).balanceOf(address(this)); bool isCakeInLp = lpTokens[0] == cake || lpTokens[1] == cake; bool isWbnbBased = lpTokens[0] == wbnb || lpTokens[1] == wbnb; address baseToken = isWbnbBased ? wbnb : busd; // if cake is not part of the lp token, swap all cake for the base token if (!isCakeInLp) { address[] memory cakeToBaseRoute = new address[](2); cakeToBaseRoute[0] = cake; cakeToBaseRoute[1] = baseToken; IPancakeRouter02(pcsRouter) .swapExactTokensForTokens(cakeBalance, 0, cakeToBaseRoute, address(this), block.timestamp); } (uint256 reserve0, uint256 reserve1,) = IPancakePair(farmingToken).getReserves(); address[] memory route = new address[](2); uint256 lp0Bal = IERC20(lpTokens[0]).balanceOf(address(this)); uint256 lp1Bal = IERC20(lpTokens[1]).balanceOf(address(this)); uint256 toSwap; // The possible cases here are: // - Cake was not part of the LP token, so we swap for baseToken which could either be lpToken0 or lpToken // - Cake was part of the LP token, so it can either be lpTokens[0] or lpTokens[1] // So, depending on which token we have the highest balance for, we swap for the other one. if (lp0Bal > lp1Bal) { toSwap = SwapAmount.getSwapAmount(lp0Bal, reserve0, fee); route[0] = lpTokens[0]; route[1] = lpTokens[1]; } else { toSwap = SwapAmount.getSwapAmount(lp1Bal, reserve1, fee); route[0] = lpTokens[1]; route[1] = lpTokens[0]; 20 } // Perform the swap IPancakeRouter02(pcsRouter) .swapExactTokensForTokens(toSwap, 0, route, address(this), block.timestamp); } IPancakeRouter02(pcsRouter).swapExactTokensForTokens(toWbnb, 0, cakeToWbnbRoute, address(this), block.timestamp); cross-yield/contracts/strategies/StrategyCake.sol#L131 function collectFees() internal { // a percentant of the cake we get from the masterchef will be used to buy BNB and transfer to this address // this is the total fees that will be shared amongst the protocol, stategy dev and the harvester uint256 toWbnb = feeManager.calculateTotalFee(IERC20(farmingToken).balanceOf(address(this))); IPancakeRouter02(pcsRouter).swapExactTokensForTokens(toWbnb, 0, cakeToWbnbRoute, address(this), block.timestamp); uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this)); // distribute hervester fee uint256 harvesterFeeAmount = feeManager.calculateHarvestFee(wbnbBal); // collectFees is called indirectly from the CrossYield contract via the beforeDeposit hook. // This means that _msgSender() is the CrossYield contract and not the actuall EOA account // that send the transaction IERC20(wbnb).safeTransfer(tx.origin, harvesterFeeAmount); // distribute protocol fee uint256 protocolFeeAmount = feeManager.calculateProtocolFee(wbnbBal); // IERC20(wbnb).safeTransfer(protocolFeeRecipient, protocolFeeAmount); feeProcessor.process(protocolFeeAmount); // distribute strategy dev fee uint256 strategyDevFeeAmount = feeManager.calculateStrategyDevFee(wbnbBal); IERC20(wbnb).safeTransfer(feeManager.strategyDev(), strategyDevFeeAmount); emit FeeCollected( toWbnb, 21 harvesterFeeAmount, protocolFeeAmount, strategyDevFeeAmount, _msgSender() ); } cross-yield/contracts/strategies/StrategyCakeLP.sol#L174 function collectFees() internal { // a percentant of the cake we get from the masterchef will be used to buy BNB and transfer to this address // this is the total fees that will be shared amongst the protocol, stategy dev and the harvester uint256 toWbnb = feeManager.calculateTotalFee(IERC20(cake).balanceOf(address(this))); IPancakeRouter02(pcsRouter).swapExactTokensForTokens(toWbnb, 0, cakeToWbnbRoute, address(this), block.timestamp); uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this)); // distribute hervester fee uint256 harvesterFeeAmount = feeManager.calculateHarvestFee(wbnbBal); IERC20(wbnb).safeTransfer(_msgSender(), harvesterFeeAmount); // distribute protocol fee uint256 protocolFeeAmount = feeManager.calculateProtocolFee(wbnbBal); feeProcessor.process(protocolFeeAmount); // distribute strategy dev fee uint256 strategyDevFeeAmount = feeManager.calculateStrategyDevFee(wbnbBal); IERC20(wbnb).safeTransfer(feeManager.strategyDev(), strategyDevFeeAmount); emit FeeCollected( toWbnb, harvesterFeeAmount, protocolFeeAmount, strategyDevFeeAmount, _msgSender() ); } cross-yield/contracts/strategies/StrategyCake.sol 22 function harvest() public override whenNotPaused { // claim rewards IMasterChef(masterchef).leaveStaking(0); // because harvest can automatically be called after each user deposit // we might end up having multiple deposits in the same block and only one // would return rewards from masterchef so the rest will have 0 cake so // we don't need to waste gas to collect fees and call deposit uint256 farmingTokenBalance = balanceOfFarmingToken(); if(farmingTokenBalance > 0) { collectFees(); deposit(); emit HarvestTriggered(_msgSender(), farmingTokenBalance); } } cross-yield/contracts/strategies/StrategyCakeLP.sol#l137-L148 function harvest() external override whenNotPaused { // claim rewards IMasterChef(masterchef).deposit(poolId, 0); uint256 harvestedAmount = IERC20(cake).balanceOf(address(this)); collectFees(); addLiquidity(); deposit(); emit HarvestTriggered(_msgSender(), harvestedAmount); }",
        "labels": [
            "SlowMist",
            "IHO V1.0.0",
            "Type: Reordering Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Missing slippage check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - IHO V1.0.0_en-us.pdf",
        "body": "The addLiquidity function without slippage check, it doesn't have an impermanent loss check. cross-yield/contracts/strategies/StrategyCakeLP.sol#L218 function addLiquidity() internal { OptimalSwap.prepareLiquidity( cake, [lpToken0, lpToken1], wbnb, busd, farmingToken, pcsRouter, swapFee ); // add liquidity to AMM on PCS uint256 lp0Bal = IERC20(lpToken0).balanceOf(address(this)); uint256 lp1Bal = IERC20(lpToken1).balanceOf(address(this)); IPancakeRouter02(pcsRouter) .addLiquidity(lpToken0, lpToken1, lp0Bal, lp1Bal, 0, 0, address(this), block.timestamp); emit LiquidityAdded(lpToken0, lpToken1, lp0Bal, lp1Bal, _msgSender()); }",
        "labels": [
            "SlowMist",
            "IHO V1.0.0",
            "Type: Reordering Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Permission check Missing",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - IHO V1.0.0_en-us.pdf",
        "body": "There is no permission check for deposit function. The function is called by the CrossYieid contract. cross-yield/contracts/strategies/StrategyCakeLP.sol#L225-L231 function deposit() public override whenNotPaused { uint256 farmingTokenBalance = balanceOfFarmingToken(); if (farmingTokenBalance > 0) { IMasterChef(masterchef).deposit(poolId, farmingTokenBalance); } } cross-yield/contracts/strategies/StrategyCake.sol#L169-L175 function deposit() public override whenNotPaused { uint256 farmingTokenBalance = balanceOfFarmingToken(); if (farmingTokenBalance > 0) { IMasterChef(masterchef).enterStaking(farmingTokenBalance); } }",
        "labels": [
            "SlowMist",
            "IHO V1.0.0",
            "Type: Authority Control Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Excessive authority issue 25",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - IHO V1.0.0_en-us.pdf",
        "body": "Owner can modify the address of the strategy. The new strategy may have security risks if it is not audited, which will aect the user's funds. If the private key is leaked, it will aect the user's funds. cross-yield/contracts/core/CrossYield.sol#L224-L236 function upgradeStrategy() public onlyOwner { require(stratCandidate.strategy != address(0), \"No proposal exists\"); require(block.number > stratCandidate.proposedBlock + stratUpgradableAfter, \"Strategy cannot be replaced yet\"); emit NewStrategy(stratCandidate.strategy); strategy.retireStrategy(); strategy = IStrategy(stratCandidate.strategy); stratCandidate.strategy = address(0); stratCandidate.proposedBlock = 0; putFundsToWork(); } cross-yield/contracts/core/CrossYield.sol#L211-L220 function proposeStrategy(address _strategy) public onlyOwner { require(address(this) == IStrategy(_strategy).vault(), \"Invalid new strategy\"); stratCandidate = StrategyCandidate({ strategy: _strategy, proposedBlock: block.number }); emit NewStratCandidate(_strategy); }",
        "labels": [
            "SlowMist",
            "IHO V1.0.0",
            "Type: Authority Control Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Repeatable claims issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - IHO V1.0.0_en-us.pdf",
        "body": "After the claim, lottery.status is not set as claimed, and it is also necessary to check whether lotteryId has been claimed when the claim is executed. hotdrop/contracts/HotDrop.sol#L261-L274 function claim(uint256 lotteryId) external nonReentrant { Lottery storage lottery = lotteries[lotteryId]; require(lottery.status == Status.WinnerDrawn, \"winner not drawn\"); // if there is no winner transfer the total amount to the treasury if(tickets[lotteryId][lottery.winningNumber] == address(0)) { lottery.purchaseToken.safeTransfer(treasury, lottery.purchaseToken.balanceOf(address(this))); } else if(tickets[lotteryId][lottery.winningNumber] == _msgSender()) { // if the ticket is the winning ticket and belongs to the user then split the pot uint256 treasuryAmount = (lottery.totalRaised * lottery.treasuryFee) / FEE_BASE; lottery.purchaseToken.safeTransfer(treasury, treasuryAmount); lottery.purchaseToken.safeTransfer(_msgSender(), lottery.totalRaised - treasuryAmount); } }",
        "labels": [
            "SlowMist",
            "IHO V1.0.0",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Round plan security reminder",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - IHO V1.0.0_en-us.pdf",
        "body": "And the new round of lottery can only be opened when the last round of lottery is in WinnerDrawn, otherwise randomGenerator.latestLotteryId will be updated, which will cause the old lottery round to fail to execute drawWinner function due to this check. require(lotteryId == randomGenerator.latestLotteryId(), \"numbers not drawn\"); hotdrop/contracts/HotDrop.sol#L44-L256 function drawWinner(uint256 lotteryId) external nonReentrant { Lottery storage lottery = lotteries[lotteryId]; require(lottery.status == Status.Close, \"lottery still active\"); require(lotteryId == randomGenerator.latestLotteryId(), \"numbers not drawn\"); // get the winning number based on the randomResult generated by ChainLink's fallback uint256 winningNumber = randomGenerator.randomResult(); lottery.winningNumber = winningNumber; lottery.status = Status.WinnerDrawn; emit LotteryNumberDrawn(lotteryId, winningNumber); }",
        "labels": [
            "SlowMist",
            "IHO V1.0.0",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Deposit defect issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "In the EFVault contract, it is not restricted to call the deposit function only by the DepositApprover contract. If the user transfers funds to the EFVault contract by mistake, any user can call the deposit function to deposit for himself. 19 ",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Incorrect withdrawal amount check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "In the vault contract, users can withdraw funds through the withdraw function. It will check if the funds withdrawn by the user is less than the user's total deposit, but this will prevent the user from withdrawing all of their total deposit. ",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Risk of overburning shares",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "In the vault contract, users can burn their shares to withdraw funds through the withdraw function. However, when calculating the required burning share, it incorrectly divides the user's total deposit. This will cause the number of shares to be burned to be much larger than expected. ",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Small deposit issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "When a user makes a deposit, the vault contract will deposit the user's funds into the strategy pool and then mint the 21 corresponding share to the user. If the total deposit of the contract is very large at this time, when the user deposits a small amount of funds, the nal result of the division operation will be 0 when the amount is too small when withdrawing. Causes the problem that small assets cannot be withdrawn.",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "The deationary token issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "In the DepositApprover contract, the amount of the deposit is the amount passed in by the user. If the tokens supported by the protocol become deationary tokens in the future (for example, USDT enables the transfer fee function), this will cause the actual number of tokens received by the protocol to be inconsistent with the number of dedicated incoming tokens. The same is true for Controller and SS contracts. ",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of share manipulation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "When the user deposits in the agreement, the contract will mint the corresponding share to the user, and when the user withdraws, the corresponding share will be burned. The totalAssets function is used to participate in the calculation when calculating the share, and in the SS contract of the convex, the totalAssets are obtained through the calc_withdraw_one_coin function of the Curve Pool. However, the calc_withdraw_one_coin function is vulnerable to the balance in the Curve Pool, so malicious users can manipulate the calc_withdraw_one_coin function to aect the number of shares minted by the contract. ",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Missing event records 23",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "In the vault contract, the owner can modify the maxDeposit, maxWithdraw, controller and depositApprover parameters through the setMaxDeposit, setMaxWithdraw, setController and setDepositApprover functions respectively. But event logging is not used. In the Controller contract, the owner can modify the vault, apySort, treasury, exchange, withdrawFee, defaultDepositSS and isDefault parameters through the setVault, setAPYSort, setTreasury, setExchange, setWithdrawFee, setDefaultDepositSS and setDefaultOption functions. But event logging is not used. In the contracts under the exchanges folder, the owner can set the exchange contract address through the setExchange function. But event logging is not used. In the contracts under the subStrategies/convex folder, the owner can modify the controller, depositSlippage, pId, lpToken, curvePool, harvestGap, maxDeposit, rewardTokens parameters through the setController, setDepositSlippage, setWithdrawSlippage, setPoolId, setLPToken, setCurvePool, setHarvestGap, setMaxDeposit, addRewardToken and removeRewardToken functions. But event logging is not used. In the cusdc contract, the owner can modify the controller, depositSlippage, withdrawSlippage, harvestGap and maxDeposit parameters through the setController, setDepositSlippage, setWithdrawSlippage, setHarvestGap and setMaxDeposit functions. But event logging is not used. ",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "AllocPoint deposit issue 28",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "In the Controller contract, deposits are made according to the allocPoint of each SS, which calculates the number of tokens transferred to each SS through the following algorithm amountForSS = (_amount * subStrategies[i].allocPoint) / totalAllocPoint; However, due to the loss of precision in the division calculation, a small amount of funds cannot be transferred into SS. ",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "check withdrawal amount issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "After the Controller contract withdraws from SS, it will check whether withdrawAmt is greater than 0. But since the protocol will havest periodically, theoretically withdrawAmt should be greater than or equal to the _amount parameter passed in by the user. ",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Risks of fake routers",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "In the Controller contract, the owner role can compound interest through the harvest function. However, it is not checked whether the router list passed in by owner is as expected. If an unexpected router is passed in, it may lead to failure to harvest normally or loss of funds. ",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Loss of computational precision",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "In the vault contract, the convertToAssets function is used to convert shares to corresponding asset amounts. 31 However, it performs the calculation by performing the division operation rst and then the multiplication operation, which will result in loss of calculation accuracy. ",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Risks of strict equality checks",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "In Convex's SS contract, when the user makes a withdrawal, it is checked whether the LP balance of the current contract is strictly equal to the LP amount required by the user. If a malicious user intentionally transfers any amount of LP tokens to the current contract, this will cause the SS contract to become unusable. ",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Negative number check issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "In the Cusdc contract, the _totalAssets function is used to obtain the total collateralized assets. It is calculated by multiplying the number of nTokens held by the protocol by the price of nTokens and dividing the total supply of nTokens. The price of nToken is obtained through the getPresentValueUnderlyingDenominated function, but the return value of the getPresentValueUnderlyingDenominated function is int256, while the return value of the INusdc interface is dened as uint256. If it returns a negative number, it will overow. ",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "In the Controller contract, the owner can set allocation point of a sub strategy, register the substrategies to the controller contract and withdraw the assets from one SS and deposit to other SS. This will have an impact on the user's deposit and withdrawal operations. ",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Authority Control Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Code redundancy issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "In the vault contract, the convertToShares function is dened, but it is not actually used in the contract. ",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Invalid minimum output calculation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "In the SS contract, the calc_token_amount function will be used to calculate the minimum amount of LP tokens received during the deposit operation; the minimum amount of staking tokens received will be calculated through the calc_withdraw_one_coin function during the withdrawal operation. However, the calc_token_amount function and the calc_withdraw_one_coin function are easily aected by the last transaction of CurvePool, so they cannot play the role of slippage protection. Lusd and Tri contracts also have slippage issue, but the slippage check is annotated in the deposit function. ",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Risk of pid acquisition",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "In the Alusd contract, the getPID function user obtains the corresponding LP pool address in the ConvexBooster contract. It will return 0 if LpToken does not exist, but pid0 has a value in the ConvexBooster contract. So when getPID returns 0, it will be hard to tell if pid exists. 37 ",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Redundant approval issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "In the swapExactTokenInput function of the Exchange contract, it will rst transfer the tokens that need to be swapped from the controller contract to the router contract. But the swapExactTokenInput function approves the router contract again, which is unnecessary. ",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Incorrect storage of temporary variables",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "In the router contract, the removePath function is used to remove the swap path recorded in the contract. It will rst store the balancerBatchAssets variable through storage, then delete it, and then use this variable for event recording after deletion. ",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Compound interest slippage check issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "In the router contract, no slippage check is performed during the swap operation. If there are more funds with compound interest, there will be a risk of being attacked by sandwiches. ",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Lack of access control",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "The swap function in the UniswapV3 contract is not subject to permission control, which will allow any user to call it. ",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Authority Control Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Analyzing inaccuracies in reward calculation due to time span misalignment",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Lumiterra Community Contracts_en-us.pdf",
        "body": "contracts/UtilityStake.sol In the _calcClaimableAmount function, if di (the time elapsed since the last reward claim) exceeds timeoutClaimPeriod , then the result of the modulo operation diff % timeoutClaimPeriod , which yields claimD , will be less than the actual time span that should be considered. This leads to an inaccurate calculation of the reward amount. function _calcClaimableAmount( address staker ) internal view returns (uint256) { StakeInfo memory stakeInfo = stakeInfoByStaker[staker]; if (stakeInfo.stakedAmount == 0) { return 0; } if (stakeInfo.latestClaimedAt == 0) { return 0; } if (stakeInfo.latestClaimedAt > block.timestamp) { return 0; } if (totalStakeAmount == 0) { return 0; } if (rate == 0) { return 0; } uint256 diff = block.timestamp - stakeInfo.latestClaimedAt; uint256 claimD = diff % timeoutClaimPeriod; // Avoid delayed on-chain submissions resulting in zero rewards 0 if (diff == timeoutClaimPeriod) { claimD = timeoutClaimPeriod; } uint256 claimableAmount = Math.mulDiv( stakeInfo.stakedAmount * claimD, rate, totalStakeAmount, Math.Rounding.Zero ); return claimableAmount; }",
        "labels": [
            "SlowMist",
            "Lumiterra Community Contracts",
            "Type: Others",
            "Severity: Medium"
        ]
    },
    {
        "title": "Handling reward calculation issues and function restrictions in reward cycles",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Lumiterra Community Contracts_en-us.pdf",
        "body": "contracts/UtilityStake.sol Users will still be able to use the old rate to calculate rewards and collect them when the next cycle has not yet been set up. This also causes a problem. When there are not enough reward tokens in the pool, users can't use the unstake and stake functions. function _calcClaimableAmount( address staker ) internal view returns (uint256) { StakeInfo memory stakeInfo = stakeInfoByStaker[staker]; if (stakeInfo.stakedAmount == 0) { return 0; } if (stakeInfo.latestClaimedAt == 0) { return 0; } if (stakeInfo.latestClaimedAt > block.timestamp) { return 0; } if (totalStakeAmount == 0) { return 0; } if (rate == 0) { return 0; } uint256 diff = block.timestamp - stakeInfo.latestClaimedAt; uint256 claimD = diff % timeoutClaimPeriod; // Avoid delayed on-chain submissions resulting in zero rewards 0 if (diff == timeoutClaimPeriod) { claimD = timeoutClaimPeriod; } uint256 claimableAmount = Math.mulDiv( stakeInfo.stakedAmount * claimD, rate, totalStakeAmount, Math.Rounding.Zero ); return claimableAmount; }",
        "labels": [
            "SlowMist",
            "Lumiterra Community Contracts",
            "Type: Others",
            "Severity: High"
        ]
    },
    {
        "title": "Addressing overpayment risk in reward distribution due to rate update delays",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Lumiterra Community Contracts_en-us.pdf",
        "body": "contracts/UtilityStake.sol In the current reward mechanism, a signicant issue arises if users claim their rewards after an update to the reward rate. Specically, if a user claims rewards accrued before the rate update, the calculation will be based on the new, potentially higher rate, leading to an overestimation of their rightful reward. This overpayment can deplete the reward pool more rapidly than anticipated, potentially leaving insucient funds for later users. Consequently, this could impede the normal operation of unstake and stake functions, as the reward pool might not sustain the demands. function depositRewardToken(address token, uint256 amount) external { IUtilityToken rewardToken = config.getPRToken(); require(token == address(rewardToken), \"UtilityStake: invalid token\"); rewardToken.transferFrom(msg.sender, address(this), amount); if (block.timestamp >= periodFinish) { rate = amount / periodDuration; } else { uint256 remaining = periodFinish - block.timestamp; uint256 leftover = remaining * rate; rate = (amount + leftover) / periodDuration; } periodFinish = block.timestamp + periodDuration; emit DepositRewardToken(amount); }",
        "labels": [
            "SlowMist",
            "Lumiterra Community Contracts",
            "Type: Others",
            "Severity: Critical"
        ]
    },
    {
        "title": "Inaccuracies in reward calculation due to misuse of total supply in liquidity pool",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Lumiterra Community Contracts_en-us.pdf",
        "body": "contracts/LiquidityStake.sol In the _checkpoint function, the use of _sc2crvPool().totalSupply() for calculating rewards may lead to inaccuracies. This is because it utilizes the total supply of the entire liquidity pool, rather than the quantity of LP tokens controlled by the contract itself. Indeed, this approach can result in the calculation of rewards being less than what is rightfully due, consequently leading to users receiving fewer rewards than they are actually entitled to. function _checkpoint(address staker) internal { _metaGauge().claim_rewards(); StakeInfo memory stakeInfo = stakeInfoByStaker[staker]; uint256 totalSupplay = _sc2crvPool().totalSupply(); if (totalSupplay == 0) { return; } for (uint256 i = 0; i < MAX_REWARDS; i++) { address tokenAddress = _metaGauge().reward_tokens(i); if (tokenAddress == address(0)) { break; } uint256 dI = 0; uint256 tokenBalance = IERC20Metadata(tokenAddress).balanceOf( address(this) ); dI = (10 ** 18 * (tokenBalance - rewardBalances[tokenAddress])) / totalSupplay; rewardBalances[tokenAddress] = tokenBalance; // integral: uint256 = self.reward_integral[token] + dI uint256 integral = rewardIntegral[tokenAddress] + dI; if (dI != 0) { rewardIntegral[tokenAddress] = integral; } uint256 integralFor = rewardIntegralFor[tokenAddress][staker]; uint256 newClaimable = 0; if (integralFor < integral) { rewardIntegralFor[tokenAddress][staker] = integral; (stakeInfo.totalSC2CRVLP * ((integral - integralFor))) / PRICE_PRECISION; } uint256 claimData = claimDataByStaker[staker][tokenAddress]; uint256 totalClaimable = (claimData >> 128) + newClaimable; if (totalClaimable > 0) { uint256 totalClaimed = claimData % 2 ** 128; claimDataByStaker[staker][tokenAddress] = totalClaimed + (totalClaimable << 128); } } } }",
        "labels": [
            "SlowMist",
            "Lumiterra Community Contracts",
            "Type: Others",
            "Severity: Critical"
        ]
    },
    {
        "title": "Redundant logic in _setFloorPrice function of smart contract",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Lumiterra Community Contracts_en-us.pdf",
        "body": "contracts/PriceField.sol The else if (_floorPrice == 0) conditional branch in this function will not actually be executed. This is because _floorPrice is set to the new floorPrice_ before any conditional judgment is entered, and floorPrice_ cannot be zero, as veried at the beginning of the function. function _setFloorPrice(uint256 floorPrice_) internal { require(floorPrice_ >= PRICE_PRECISION / 2, \"floor price too low\"); require(floorPrice_ > _floorPrice, \"floor price too low\"); uint256 previousFloorPrice = _floorPrice; uint256 x3 = _config.getUtilityToken().totalSupply(); _floorPrice = floorPrice_; if (x3 > c()) { uint256 maxFloorPrice = (Math.mulDiv( x3 - c(), _slope, PRECENT_DENOMINATOR, Math.Rounding.Zero ) + PRICE_PRECISION) / 2; if (maxFloorPrice > floorPrice_) { _floorPrice = floorPrice_; } } else if (_floorPrice == 0) { //SLOWMIST//will not be implemented _floorPrice = floorPrice_; } else if (x3 > x1(floorPrice_) + _exerciseAmount) { _floorPrice = floorPrice_; } else if (x3 == 0) { _floorPrice = floorPrice_; } require(_floorPrice > previousFloorPrice, \"floor price too low\"); emit UpdateFloorPrice(_floorPrice); }",
        "labels": [
            "SlowMist",
            "Lumiterra Community Contracts",
            "Type: Others",
            "Severity: Low"
        ]
    },
    {
        "title": "Potential reentrancy risk in VAMM's _mintByPRToken function",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Lumiterra Community Contracts_en-us.pdf",
        "body": "contracts/VAMM.sol The payToken can be passed in arbitrarily from the outside, and if the payToken is a token that implements a callback function, then this call may trigger malicious code.An attacker can exploit this by calling the _mintByPRToken function again during the callback. Since the _mintByPRToken function calls payToken.transferFrom before updating _floorPrice and minting new tokens, a reentry attack could allow an attacker to mint tokens multiple times at the old, more favorable price, rather than at the updated price. This could lead to improper minting of assets. function _mintByPRToken( address payTokenAddress, uint256 mintAmount, uint256 maxPayAmount, address recipient ) internal { IERC20Metadata payToken = IERC20Metadata(payTokenAddress); IUtilityToken _utilityToken = _config.getUtilityToken(); IUtilityToken _prToken = _config.getPRToken(); require(_prToken.balanceOf(msg.sender) >= mintAmount, \"VAMM:mp0\"); require( _prToken.allowance(msg.sender, address(this)) >= mintAmount, \"VAMM:mp1\" ); (uint256 toLiquidityPrice, uint256 fees) = _priceField.getUseFPBuyPrice( mintAmount ); require(toLiquidityPrice + fees <= maxPayAmount, \"VAMM:mp2\"); // Include slippage as fee income fees = maxPayAmount - toLiquidityPrice; //SLOWMIST// uint256 maxPayAmountInPayToken = _convertPrice( maxPayAmount, payToken, true ); _priceField.increaseSupplyWithNoPriceImpact(mintAmount); require( payToken.transferFrom( msg.sender, address(this), maxPayAmountInPayToken ), \"VAMM:mp3\" );//The paytoken is an arbitrary token, so any worthless token can be used as the key to transfer money to the contract. // burn pr token _prToken.burnFrom(msg.sender, mintAmount); _collectFees(fees); /// mint token _totalLiquidity += toLiquidityPrice; _utilityToken.mint(recipient, mintAmount); _deposit(payTokenAddress); _autoUpFP(); emit Mint(recipient, mintAmount, toLiquidityPrice, fees); }",
        "labels": [
            "SlowMist",
            "Lumiterra Community Contracts",
            "Type: Others",
            "Severity: High"
        ]
    },
    {
        "title": "Exploitation risk with arbitrary payToken in VAMM's _mintByPRToken function",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Lumiterra Community Contracts_en-us.pdf",
        "body": "contracts/VAMM.sol The payToken can be any token, so it can be used to construct a malicious token to make a payment. function _mintByPRToken( address payTokenAddress, uint256 mintAmount, uint256 maxPayAmount, address recipient ) internal { IERC20Metadata payToken = IERC20Metadata(payTokenAddress); IUtilityToken _utilityToken = _config.getUtilityToken(); IUtilityToken _prToken = _config.getPRToken(); require(_prToken.balanceOf(msg.sender) >= mintAmount, \"VAMM:mp0\"); require( _prToken.allowance(msg.sender, address(this)) >= mintAmount, \"VAMM:mp1\" ); (uint256 toLiquidityPrice, uint256 fees) = _priceField.getUseFPBuyPrice( mintAmount ); require(toLiquidityPrice + fees <= maxPayAmount, \"VAMM:mp2\"); // Include slippage as fee income fees = maxPayAmount - toLiquidityPrice; //SLOWMIST// uint256 maxPayAmountInPayToken = _convertPrice( maxPayAmount, payToken, true ); _priceField.increaseSupplyWithNoPriceImpact(mintAmount); require( payToken.transferFrom( msg.sender, address(this), maxPayAmountInPayToken ), \"VAMM:mp3\" );//The paytoken is an arbitrary token, so any worthless token can be used as the key to transfer money to the contract. // burn pr token _prToken.burnFrom(msg.sender, mintAmount); _collectFees(fees); /// mint token _totalLiquidity += toLiquidityPrice; _utilityToken.mint(recipient, mintAmount); _deposit(payTokenAddress); _autoUpFP(); emit Mint(recipient, mintAmount, toLiquidityPrice, fees); }",
        "labels": [
            "SlowMist",
            "Lumiterra Community Contracts",
            "Type: Others",
            "Severity: High"
        ]
    },
    {
        "title": "Preemptive Initialization",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Lumiterra Community Contracts_en-us.pdf",
        "body": "contracts/LiquidityStake.sol function initialize(IConfig config_) public initializer { __Ownable_init(); __UUPSUpgradeable_init(); _transferOwnership(tx.origin); config = config_; } contracts/UtilityStake.sol function initialize(IConfig config_) public initializer { __Ownable_init(); __UUPSUpgradeable_init(); _transferOwnership(tx.origin); config = config_; unstakeFee = 300000000; periodDuration = 1 weeks; timeoutClaimPeriod = 2 days; } contracts/VAMM.sol function initialize( IConfig config_, PriceField priceField_, uint256 t_, uint256 x_, uint256 c_ ) public initializer { __Ownable_init(); __UUPSUpgradeable_init(); _transferOwnership(tx.origin); _config = config_; _priceField = priceField_; tForMFR = t_; maxTForMFR = 5000000000; minTForMFR = t_; cForMFR = c_; // ethereum block time 13s reduceTBlocks = 6600; xForMFR = x_; }",
        "labels": [
            "SlowMist",
            "Lumiterra Community Contracts",
            "Type: Race Conditions Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Lacking event logging in critical contract functions alters state without transparency issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Lumiterra Community Contracts_en-us.pdf",
        "body": "contracts/LiquidityStake.sol function setHook(LiquidityStakeHook hook_) external onlyOwner { hook = hook_; } contracts/UtilityStake.sol function setHook(UtilityStakeHook hook_) external onlyOwner { hook = hook_; } contracts/PriceField.sol function increaseSupplyWithNoPriceImpact(uint256 amount) external onlyVamm { _exerciseAmount += amount; } contracts/VAMM.sol function setPriceField(PriceField priceField_) external onlyOwner { _priceField = priceField_; }",
        "labels": [
            "SlowMist",
            "Lumiterra Community Contracts",
            "Type: Malicious Event Log Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Redundant functions",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Lumiterra Community Contracts_en-us.pdf",
        "body": "contracts/VAMM.sol Redundant function code, which can be deleted if it is not useful. function liquidityTesting() external { }",
        "labels": [
            "SlowMist",
            "Lumiterra Community Contracts",
            "Type: Others",
            "Severity: Information"
        ]
    },
    {
        "title": "Missing check return value",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Lumiterra Community Contracts_en-us.pdf",
        "body": "It is recommended to check the return value of transferFrom, as there may be problems if a non-ERC20 standard token is subsequently used. contracts/UtilityStake.sol line 142: utilityToken.transferFrom(staker, address(this), amount); line 196: stablecoin.transferFrom(staker, address(this), fees); line 287: rewardToken.transferFrom(msg.sender, address(this), amount); contracts/LiquidityStake.sol line 154: stablecoin.transferFrom(staker, address(this), _amount); contracts/VAMM.sol line 504: token.transferFrom(msg.sender, address(this), _repayAmount);",
        "labels": [
            "SlowMist",
            "Lumiterra Community Contracts",
            "Type: Others",
            "Severity: Low"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Lumiterra Community Contracts_en-us.pdf",
        "body": "contracts/VAMM.sol The owner can set the key parameters, if the private key is lost, the price will be out of control. owner can setPriceField operator can updateMFR contracts/UtilityToken.sol The owner can mint the token, if the private key is lost it will cause the token to be incremented. owner can mint owner can transferOwnership Other contracts have key roles and key parameters that are mostly controlled by external config contracts.",
        "labels": [
            "SlowMist",
            "Lumiterra Community Contracts",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Recommendation to Implement reentrancy",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Lumiterra Community Contracts_en-us.pdf",
        "body": "contracts/VAMM.sol In _mint , _burn , there is no utilization scenario at the moment, but it is recommended to add reentrant locks.",
        "labels": [
            "SlowMist",
            "Lumiterra Community Contracts",
            "Type: Reentrancy Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing zero address check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Kayak-UniswapV3-Contract.pdf",
        "body": "1.In the KayakSwapRouter contract, the constructor function lacks a zero address check for the _WETH parameter. contracts/swaprouter/KayakSwapRouter.sol#L67-L69 constructor(address _WETH) { weth = IWETH(_WETH); } 2.In the KayakSwapRouter contract, the swap function lacks a zero address check for the params.pool parameter. contracts/swaprouter/KayakSwapRouter.sol#L113-L141 function swap(SwapParams calldata params) public payable nonReentrant returns (uint256 returnAmount) { ``` if (params.flag) { _swapOnStableSwap(params.srcToken, params.dstToken, params.pool, receivedAmount); } else { _swapOnV3ExactIn(params.srcToken, params.dstToken, params.pool, receivedAmount); } ``` } 3.In the KayakSwapQuoter contract, the constructor function lacks a zero address check for the _WETH parameter. contracts/swaprouter/KayakSwapQuoter.sol#L34-L36 constructor(address _WETH) { weth = IWETH(_WETH); } 4.In the KayakSwapQuoter contract, the getReturnStableSwap function and getReturnUniswapV3 function lack a zero address check for the pool parameter. contracts/swaprouter/KayakSwapQuoter.sol#L87-L103, L105-L130 function getReturnStableSwap( address srcToken, address dstToken, address pool, uint256 amount ) public view returns (uint256 returnAmount) { ``` uint256 n_coins = IStableSwap(pool).N_COINS(); ``` } function getReturnUniswapV3( address srcToken, address dstToken, address pool, uint256 amount ) public returns (uint256 returnAmount) { ``` IUniswapV3Pool(pool).swap( ``` ) ``` }",
        "labels": [
            "SlowMist",
            "Kayak-UniswapV3-Contract",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "The identity of msg.sender is not veried",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Kayak-UniswapV3-Contract.pdf",
        "body": "In the KayakSwapRouter contract, the uniswapV3SwapCallback function does not verify whether msg.sender is a valid Uniswap V3 Pool. When there are assets in the contract, the attacker can construct malicious parameters and transfer any assets in the contract through the uniTransfer function called in the uniswapV3SwapCallback function. contracts/swaprouter/KayakSwapRouter.sol#L187-L197 function uniswapV3SwapCallback(int256 amount0Delta, int256 amount1Delta, bytes calldata _data) external { require(amount0Delta > 0 || amount1Delta > 0); // swaps entirely within 0- liquidity regions are not supported SwapCallbackData memory data = abi.decode(_data, (SwapCallbackData)); (address tokenIn, address tokenOut, , ) = data.path.decodeFirstPool(); (, uint256 amountToPay) = amount0Delta > 0 ? (tokenIn < tokenOut, uint256(amount0Delta)) : (tokenOut < tokenIn, uint256(amount1Delta)); IERC20(tokenIn).uniTransfer(msg.sender, amountToPay); }",
        "labels": [
            "SlowMist",
            "Kayak-UniswapV3-Contract",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Unchecked return value",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Kayak-UniswapV3-Contract.pdf",
        "body": "In the UniERC20 library, the uniApprove function did not check the return value when calling the approve function. contracts/swaprouter/libraries/UniERC20.sol#L68-L72 function uniApprove(IERC20 token, address to, uint256 amount) internal { if (isETH(token)) return; token.approve(to, amount); }",
        "labels": [
            "SlowMist",
            "Kayak-UniswapV3-Contract",
            "Type: Others",
            "Severity: Low"
        ]
    },
    {
        "title": "Redundant code",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Kayak-UniswapV3-Contract.pdf",
        "body": "In the KayakSwapQuoter contract, amountOutCached is not used. contracts/swaprouter/KayakSwapQuoter.sol#L22 uint256 private amountOutCached;",
        "labels": [
            "SlowMist",
            "Kayak-UniswapV3-Contract",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Insucient ETH balance causes the function to be unavailable",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Kayak-UniswapV3-Contract.pdf",
        "body": "In the KayakSwapQuoter contract, the purpose of the getReturnUniswapV3 function is to return the number of tokens that can be exchanged in the UniswapV3 pool, so there is no need to call the weth.deposit function to exchange WETH. Calling the weth.deposit function will fail because the contract does not have enough ETH balance and subsequent operations cannot be performed, which will make the function unusable. contracts/swaprouter/KayakSwapQuoter.sol function getReturnUniswapV3( address srcToken, address dstToken, address pool, uint256 amount ) public returns (uint256 returnAmount) { if (IERC20(srcToken).isETH()) { weth.deposit{ value: amount }(); } address srcTokenReal = IERC20(srcToken).isETH() ? address(weth) : srcToken; address dstTokenReal = IERC20(dstToken).isETH() ? address(weth) : dstToken; bool zeroForOne = srcTokenReal < dstTokenReal; try IUniswapV3Pool(pool).swap( address(this), // address(0) might cause issues with some tokens zeroForOne, amount.toInt256(), zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1, abi.encodePacked(srcTokenReal, dstTokenReal, pool, false) ) {} catch (bytes memory reason) { return parseRevertReason(reason); } }",
        "labels": [
            "SlowMist",
            "Kayak-UniswapV3-Contract",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "External dependency changes may cause logic failure",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Kayak-UniswapV3-Contract.pdf",
        "body": "In the KayakSwapQuoter contract, the parseRevertReason function can parse the error information returned by UniswapV3Pool. If the Uniswap V3 contract interface or error return format changes, it may cause errors in error message parsing. contracts/swaprouter/KayakSwapQuoter.sol#L133-L142 function parseRevertReason(bytes memory reason) private pure returns (uint256) { if (reason.length != 32) { if (reason.length < 68) revert(\"Unexpected error\"); assembly { reason := add(reason, 0x04) } revert(abi.decode(reason, (string))); } return abi.decode(reason, (uint256)); }",
        "labels": [
            "SlowMist",
            "Kayak-UniswapV3-Contract",
            "Type: Others",
            "Severity: Information"
        ]
    },
    {
        "title": "Returns incorrect swap result",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Kayak-UniswapV3-Contract.pdf",
        "body": "In the KayakSwapQuoter contract, the getReturnStableSwap function and getReturnUniswapV3 function do not verify whether the pool contract is the correct address. If the user passes in a malicious contract address, an incorrect exchange result may be returned. contracts/swaprouter/KayakSwapQuoter.sol#L87-L103, L105-L130 function getReturnStableSwap( address srcToken, address dstToken, address pool, uint256 amount ) public view returns (uint256 returnAmount) { address[] memory tokens = new address[](3); uint256 n_coins = IStableSwap(pool).N_COINS(); tokens[0] = IStableSwap(pool).coins(uint256(0)); tokens[1] = IStableSwap(pool).coins(uint256(1)); if (n_coins == 3) { tokens[2] = IStableSwap(pool).coins(uint256(2)); } uint256 i = (srcToken == tokens[0] ? 1 : 0) + (srcToken == tokens[1] ? 2 : 0) + (srcToken == tokens[2] ? 3 : 0); uint256 j = (dstToken == tokens[0] ? 1 : 0) + (dstToken == tokens[1] ? 2 : 0) + (dstToken == tokens[2] ? 3 : 0); return IStableSwap(pool).get_dy(i - 1, j - 1, amount); } function getReturnUniswapV3( address srcToken, address dstToken, address pool, uint256 amount ) public returns (uint256 returnAmount) { if (IERC20(srcToken).isETH()) { weth.deposit{ value: amount }(); } address srcTokenReal = IERC20(srcToken).isETH() ? address(weth) : srcToken; address dstTokenReal = IERC20(dstToken).isETH() ? address(weth) : dstToken; bool zeroForOne = srcTokenReal < dstTokenReal; try IUniswapV3Pool(pool).swap( address(this), // address(0) might cause issues with some tokens zeroForOne, amount.toInt256(), zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1, abi.encodePacked(srcTokenReal, dstTokenReal, pool, false) ) {} catch (bytes memory reason) { return parseRevertReason(reason); } }",
        "labels": [
            "SlowMist",
            "Kayak-UniswapV3-Contract",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Kayak-UniswapV3-Contract.pdf",
        "body": "In the UniswapV3Factory contract, the owner role can transfer owner permissions and set feeAmountTickSpacing mapping. contracts/core/UniswapV3Factory.sol#L54-L58, L61-L72 function setOwner function enableFeeAmount",
        "labels": [
            "SlowMist",
            "Kayak-UniswapV3-Contract",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Redundant authorization operations",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Kayak-UniswapV3-Contract.pdf",
        "body": "In the KayakSwapRouter contract, the _swapOnV3ExactIn function calls the uniApprove function to authorize the pool contract, but in the uniswapV3SwapCallback function, the uniTransfer function is called to pay the tokenIn token, and the uniTransferFrom function is not used, so the authorized amount will continue to exist and accumulate. If the pool contract is a malicious contract, this authorization operation may cause the assets in the KayakSwapRouter contract to be transferred away. contracts/swaprouter/KayakSwapRouter.sol#L162-L185, L187-L197 function _swapOnV3ExactIn(address srcToken, address dstToken, address pool, uint256 amount) internal { ``` IERC20(srcTokenReal).uniApprove(payable(pool), amount); ``` } function uniswapV3SwapCallback(int256 amount0Delta, int256 amount1Delta, bytes calldata _data) external { ``` IERC20(tokenIn).uniTransfer(msg.sender, amountToPay); }",
        "labels": [
            "SlowMist",
            "Kayak-UniswapV3-Contract",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Potential denial of service risk due to gulp operations",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase5_en-us.pdf",
        "body": "In the Actions contract, when the user performs the autoJoinSmartPool operation, the number of shares the user can obtain will be calculated through the _calculateShare function, and minPoolAmountOut will be checked at the end. The _calculateShare function obtains the number of tokens recorded in the pool through bPool's getBalance when calculating the share, but unfortunately any user can update this parameter through bPool's gulp function. Therefore, when an ordinary user performs an autoJoinSmartPool operation, a malicious user directly transfers funds to bPool and calls the gulp function to update the token balance recorded in the pool. At this time, ordinary users will not be able to successfully add liquidity due to the minPoolAmountOut check. If the minPoolAmountOut value passed in by an ordinary user is 0, it may cause an interest rate ination attack. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase5",
            "Type: Denial of Service Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Incorrect event logging",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase5_en-us.pdf",
        "body": "In the CRP contract, the createPool function adds the creator parameter as the real creator of the pool. However, the corresponding events were not modied accordingly. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase5",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Incorrect WETH address",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase5_en-us.pdf",
        "body": "The WETH address constant is hard-coded in the Actions contract, but this address is an EOA address on the Ethereum mainnet and is not the correct WETH address. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase5",
            "Type: Others",
            "Severity: High"
        ]
    },
    {
        "title": "Incorrect poolTokens check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase5_en-us.pdf",
        "body": "In the autoJoinSmartPool function of the Actions contract, it checks the tokens deposited by the user through poolTokens[i] == handleToken , but handleToken has been replaced by the issueToken parameter during the native token checking phase. Therefore, the poolTokens[i] == handleToken check is not accurate. If handleToken is WETH, it will cause an error in the _makeSwap operation. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase5",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Redundant STBT token check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase5_en-us.pdf",
        "body": "In the autoJoinSmartPool and _exit functions of the Actions contract, when making a token transfer, it will be checked whether the transferred token is an STBT token. But in fact, the protocol does not allow deposits of STBT tokens, and STBT tokens will also be converted into stablecoins after the ETF expires. Therefore, theoretically, there will be no STBT tokens in the contract, so the STBT token check is redundant. . ",
        "labels": [
            "SlowMist",
            "DeSyn Phase5",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Potential risk of slot conict",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase5_en-us.pdf",
        "body": "In this protocol iteration, both SmartPoolManager and Actions contracts have changed their storage structures. If these contracts use an upgradeable model, and upgrading the contract directly on the original basis may lead to contract storage slot conicts. In fact, the Actions contract is an upgradeable contract, so special attention should be paid to such risks.",
        "labels": [
            "SlowMist",
            "DeSyn Phase5",
            "Type: Variable Coverage Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of event forgery",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase5_en-us.pdf",
        "body": "In the CRP contract, the exitPool function adds a user parameter to record the real caller when the user exits through the Actions contract. However, users can also exit by calling the exitPool function of the CRP contract. They can pass in any user parameter to make the LogExit event record an incorrect value. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase5",
            "Type: Malicious Event Log Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Potential risk of denial of service due to large CRPFactory array",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase5_en-us.pdf",
        "body": "In the CRPFactory contract, when the Blabs role performs addCRPFactory and removeCRPFactory operations, it will use a for loop to traverse the entire CRPFactorys array. If the array length is too large, it will lead to DoS risks. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase5",
            "Type: Denial of Service Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Potential risk of endless loop",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase5_en-us.pdf",
        "body": "In the CRPFactory contract, the isCrp function is used to check whether the address passed by the user is a CRP contract. If not, the CRPFactorys array will be circulated and the isCrp function of other CRPFactory will be called to check. However, it should be noted that if the Blabs role adds this contract address to the CRPFactorys array, the user will fall into an innite loop error when querying a CRP address that is not recorded in this contract through the isCrp function. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase5",
            "Type: Denial of Service Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Debug functions buer oset stack overow",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ccToken.pdf",
        "body": "There is no check to see if oset exceeds the size of debug_buer. If data_len is too large, it may cause a stack overow. contracts/c/common.h static void debug_print_data_impl(const char *prefix, const uint8_t *data, uint32_t data_len) { int offset = 0; offset += sprintf_(debug_buffer, \"%s\", prefix); for (size_t i = 0; i < data_len; i++) { offset += sprintf_(debug_buffer + offset, \"%02x\", data[i]); } debug_buffer[offset] = '\\0'; ckb_debug(debug_buffer); } static void debug_print_int_impl(const char *prefix, int ret) { int offset = 0; offset += sprintf_(debug_buffer, \"%s(%d)\", prefix, ret); debug_buffer[offset] = '\\0'; ckb_debug(debug_buffer); } static void debug_print_string_impl(const char *prefix, const uint8_t *data, uint32_t data_len) { int offset = 0; offset += sprintf_(debug_buffer, \"%s\", prefix); for (size_t i = 0; i < data_len; i++) { offset += sprintf_(debug_buffer + offset, \"%c\", data[i]); } debug_buffer[offset] = '\\0'; ckb_debug(debug_buffer); }",
        "labels": [
            "SlowMist",
            "ccToken",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "char2hex Logic error",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ccToken.pdf",
        "body": "This function assumes that the input hexChar is a valid hexadecimal character, but does not check if the character is in the valid range. If the input hexChar is an illegal character, the result of the calculation will be wrong. For example, entering 'G' or 'H' will result in undesired output. Also, the function only handles hexadecimal characters with uppercase letters ('A' through 'F'), but hexadecimal characters also include lowercase letters ('a' through 'f'). contracts/c/utils.h char char2hex(char hexChar) { char tmp; if(hexChar<='9') { tmp = hexChar-'0'; } else if(hexChar<='F') { tmp = hexChar-'7'; } else { tmp = hexChar-'W'; } return tmp; }",
        "labels": [
            "SlowMist",
            "ccToken",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ccToken.pdf",
        "body": "Custodian has the following unlock permissions: update_merchants confirm_mint reject_mint confirm_burn reject_burn Merchant has the following unlock permissions: update_merchants Request mint Request burn",
        "labels": [
            "SlowMist",
            "ccToken",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "simple_udt should check the size of the input and output amounts",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ccToken.pdf",
        "body": "simple_udt should check the size of the input and output amounts. contracts/c/tx_parser.h int simple_udt(uint128_t *ia, uint128_t *oa) { //... *ia = input_amount; *oa = output_amount; return CKB_SUCCESS; }",
        "labels": [
            "SlowMist",
            "ccToken",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Missing array bounds checking",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ccToken.pdf",
        "body": "Accessing data[0] and data[1...] without boundary checking may result in an array out-of-bounds error. without boundary checking may result in an array out-of-bounds error. libs/core/src/data_parser/cong_cell.rs pub fn parse(data: Vec<u8>) -> Result<(u8, Vec<(ConfigKey, Vec<u8>)>), CoreError> { let version = data[0]; let mut configs = vec![]; match version { 0 => { let config_mol = BytesVec::from_compatible_slice(&data[1..]).map_err(|_| CoreError::ParseCellDataFailed { //... } The code does not check if the input args and data are of sucient length. Direct access to args[0] and data[0] may result in out-of-bounds access, which can trigger a crash. libs/core/src/data_parser/governance_member_cell.rs pub fn parse_type_args(args: Vec<u8>) -> Result<(GovernanceMemberRole, Vec<u8>), CoreError> { let role = GovernanceMemberRole::try_from(args[0]).map_err(|_| CoreError::ParseCellDataFailed { cell_name: String::from(\"GovernanceMemberCell\"), msg: format!(\"Unknown role value {}\", args[0]), })?; let cell_id = (&args[1..]).to_vec(); //... Ok((role, cell_id)) } pub fn parse_data(data: Vec<u8>) -> Result<(u8, GovernanceMembers), CoreError> { let version = data[0]; //... GovernanceMembers::from_compatible_slice(&data[1..]).map_err(|_| CoreError::ParseCellDataFailed { //... } libs/core/src/data_parser/tick_cell.rs pub fn parse_data(data: Vec<u8>) -> Result<(u8, Tick), CoreError> { let version = data[0]; //... tick = Tick::from_compatible_slice(&data[1..]).map_err(|_| CoreError::ParseCellDataFailed { //... Ok((version, tick)) } libs/core/src/veriers/permission.rs pub fn verify_input_has_deploy_lock(index: usize) -> Result<(), CoreError> { //... cc_assert!(cells[0] == index, CoreError::DeployLockIsRequired { index }); Ok(()) } pub fn verify_input_has_owner_lock(index: usize) -> Result<(), CoreError> { //... cc_assert!(cells[0] == index, CoreError::OwnerLockIsRequired { index }); Ok(()) }",
        "labels": [
            "SlowMist",
            "ccToken",
            "Type: Others",
            "Severity: Low"
        ]
    },
    {
        "title": "Avoid unnecessary memory copies",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ccToken.pdf",
        "body": "Function arguments can accept slice references (&[u8]) instead of ownership (Vec), which avoids unnecessary memory copies. libs/core/src/data_parser/cong_cell.rs pub fn parse(data: Vec<u8>) -> Result<(u8, Vec<(ConfigKey, Vec<u8>)>), CoreError> { //... } libs/core/src/data_parser/governance_member_cell.rs pub fn parse_type_args(args: Vec<u8>) -> Result<(GovernanceMemberRole, Vec<u8>), CoreError> { //... } pub fn parse_data(data: Vec<u8>) -> Result<(u8, GovernanceMembers), CoreError> { //... } libs/core/src/data_parser/tick_cell.rs pub fn parse_data(data: Vec<u8>) -> Result<(u8, Tick), CoreError> { //... } libs/core/src/util.rs pub fn get_tx_action() -> Result<Action, CoreError> { //... let version_byte = witness[0]; //... let action_bytes = &witness[1..]; //... }",
        "labels": [
            "SlowMist",
            "ccToken",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Ambiguous error handling",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ccToken.pdf",
        "body": "Use the warn! log to record potential parsing errors, which is not uncommon in smart contracts, without explicitly indicating whether the error should be interrupted or accepted. libs/core/src/data_parser/cong_cell.rs pub fn parse(data: Vec<u8>) -> Result<(u8, Vec<(ConfigKey, Vec<u8>)>), CoreError> { //... let key = match ConfigKey::try_from(u32::from_le_bytes(key_bytes)) { Ok(key) => key, Err(_) => { warn!( \"[{}] Parse [0..4]({}) to config key failed, the key is removed or not defined.\", i, hex_string(key_bytes.as_ref()) ); continue; } }; //... } Ok((version, configs)) }",
        "labels": [
            "SlowMist",
            "ccToken",
            "Type: Others",
            "Severity: Low"
        ]
    },
    {
        "title": "Missing system shutdown status check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ccToken.pdf",
        "body": "When the system is processing the shutdown state, all other features except conguration should be disabled, including disabling the following features: init_governance update_owner update_custodians update_merchants confirm_mint reject_mint confirm_burn reject_burn Currently only the request function request for token minting and destruction checks if the system is disabled.",
        "labels": [
            "SlowMist",
            "ccToken",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "It is recommended to use the encapsulated method",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ccToken.pdf",
        "body": "A wrapped lock validation function already exists, and reusing it improves the readability of the code. contracts/cong-cell-type/src/entry.rs fn verify_output_lock(index: usize) -> Result<(), Box<dyn AsI8>> { //... lock.as_slice() == owner_lock.as_slice(), //... Ok(()) }",
        "labels": [
            "SlowMist",
            "ccToken",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap_v3_en-us.pdf",
        "body": "In the StableSwapRouter, the Owner role can set the stableSwapFactory to any address. If a fake stableSwapFactory address is passed in, the SmartRouterHelper will obtain a malicious transaction pair from the getStableInfo function, resulting in loss of funds. And this function is also missing the event log and 0 address check. ",
        "labels": [
            "SlowMist",
            "PancakeSwap_v3",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Token compatibility issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap_v3_en-us.pdf",
        "body": "1.In the StableSwapRouter, the exactOutputStableSwap and exactInputStableSwap functions will call swap to transfer by the pay function via the input data amountIn and the input data is recorded directly into it. In the swap function, although amountIn is re-recorded. However, the amountIn_ data is still recorded in the _swap function when the exchange is performed in the swapContract of the transferring third-party contract. If the third-party contract token balance is used to directly participate in the calculation, the contract cannot be compatible with the rebase token. ",
        "labels": [
            "SlowMist",
            "PancakeSwap_v3",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing event records",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap_v3_en-us.pdf",
        "body": "1.In the PancakeV3FactoryOwner contract, the owner role can set the lmPoolDeployer address, but there is no event log and 0 address check. ",
        "labels": [
            "SlowMist",
            "PancakeSwap_v3",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of initial operation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap_v3_en-us.pdf",
        "body": "In the PancakeV3Pool contract, by calling the initialize function to initialize the contracts, there is a potential issue that malicious attackers preemptively call the initialize function to initialize and there is no access control verication for the initialize functions ",
        "labels": [
            "SlowMist",
            "PancakeSwap_v3",
            "Type: Race Conditions Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of denial of service",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap_v3_en-us.pdf",
        "body": "In the UniswapV3Pool contract, the swap function can be disrupted by forcing the loop to go through too many operations, potentially trapping the swap due to a lack of gas. ",
        "labels": [
            "SlowMist",
            "PancakeSwap_v3",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of replay attack",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Coordinape protocol_en-us.pdf",
        "body": "In the ApeToken contract, DOMAIN_SEPARATOR is dened when the contract is initialized, but it is not reimplemented when DOMAIN_SEPARATOR is used in the permit function. So the DOMAIN_SEPARATOR contains 15 the chainId and is dened at contract deployment instead of reconstructed for every signature, there is a risk of possible replay attacks between chains in the event of a future chain split. coordinape-protocol/contracts/ApeProtocol/token/ApeToken.sol#L18 constructor() { uint chainId = block.chainid; DOMAIN_SEPARATOR = keccak256( abi.encode( keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'), keccak256(bytes(\"coordinape.com\")), keccak256(bytes('1')), chainId, address(this) ) ); } coordinape-protocol/contracts/ApeProtocol/token/ApeToken.sol#L42 function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public { require(block.timestamp <= deadline, \"COToken: expired deadline\"); require(owner != address(0), \"COToken: owner can't be ZERO address \"); bytes32 digest = keccak256( abi.encode( DOMAIN_SEPARATOR, '\\x19\\x01', keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline)) ) ); address signer = ECDSA.recover(digest, v, r, s); require(signer == owner, \"COToken: invalid signature\"); 16 _approve(owner, spender, value); }",
        "labels": [
            "SlowMist",
            "Coordinape protocol",
            "Type: Replay Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing event records",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Coordinape protocol_en-us.pdf",
        "body": "Missing event records are not conducive to the review of community users. coordinape-protocol/contracts/ApeProtocol/token/TokenAccessControl.sol#L32-47 function disableAllowlist() external onlyOwner { require(!allowlistDisabled, \"AccessControl: Allowlist already disabled\"); } allowlistDisabled = true; function changePauseStatus(bool _status) external onlyOwner { require(!foreverUnpaused, \"AccessControl: Contract is unpaused forever\"); } paused = _status; function disablePausingForever() external onlyOwner { require(!foreverUnpaused, \"AccessControl: Contract is unpaused forever\"); } foreverUnpaused = true; paused = false; 17 coordinape-protocol/contracts/ApeProtocol/token/TokenAccessControl.sol#L81-84 function disableMintingForever() external onlyOwner { require(!mintingDisabled, \"AccessControl: Contract cannot mint anymore\"); } mintingDisabled = true; coordinape-protocol/contracts/ApeProtocol/wrapper/beacon/ApeBeacon.sol#L23-28 function transferProxyOwnership(address _newOwner) external { require(msg.sender == proxyOwner()); assembly { sstore(_OWNER_SLOT, _newOwner) } } coordinape-protocol/contracts/ApeProtocol/wrapper/beacon/ApeRegistryBeacon.sol#37-L40 function pushNewImplementation(address _newImplementation) public itself { require(Address.isContract(_newImplementation), \"ApeRegistryBeacon: implementaion is not a contract\"); deployments[++deploymentCount] = _newImplementation; } coordinape-protocol/contracts/ApeProtocol/ApeRegistry.sol#L17-L35 function setFeeRegistry(address _registry) external itself { feeRegistry = _registry; } function setRouter(address _router) external itself { router = _router; } function setDistributor(address _distributor) external itself { distributor = _distributor; } 18 function setFactory(address _factory) external itself { factory = _factory; } function setTreasury(address _treasury) external itself { treasury = _treasury; } coordinape-protocol/contracts/ApeProtocol/ApeRouter.sol#L87-L89 function setRegistry(address _registry) external itself { yearnRegistry = _registry; }",
        "labels": [
            "SlowMist",
            "Coordinape protocol",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Coding optimization",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Coordinape protocol_en-us.pdf",
        "body": "getVariableFee function does not modify contract data, but does not use view. coordinape-protocol/contracts/ApeProtocol/FeeRegistry.sol#L24 function getVariableFee(uint256 _yield, uint256 _tapTotal) external returns(uint256 variableFee) { if (!on) return 0; uint256 yieldRatio = _yield * 1000 / _tapTotal; uint256 baseFee = 100; if (yieldRatio >= 900) variableFee = baseFee; // 1% @ 90% yield ratio else if (yieldRatio >= 800) variableFee = baseFee + 25; // 1.25% @ 80% yield ratio 19 else if (yieldRatio >= 700) variableFee = baseFee + 50; // 1.50% @ 70% yield ratio else if (yieldRatio >= 600) variableFee = baseFee + 75; // 1.75% @ 60% yield ratio else if (yieldRatio >= 500) variableFee = baseFee + 100; // 2.00% @ 80% yield ratio else if (yieldRatio >= 400) variableFee = baseFee + 125; // 2.25% @ 80% yield ratio else if (yieldRatio >= 300) variableFee = baseFee + 150; // 2.50% @ 80% yield ratio else if (yieldRatio >= 200) variableFee = baseFee + 175; // 2.75% @ 80% yield ratio else if (yieldRatio >= 100) variableFee = baseFee + 200; // 3.00% @ 80% yield ratio else } variableFee = baseFee + 250; // 3.50% @ 0% yield ratio",
        "labels": [
            "SlowMist",
            "Coordinape protocol",
            "Type: Authority Control Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Business logic is not clear",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Coordinape protocol_en-us.pdf",
        "body": "The _issueInvite function will execute the mint logic, but the burn is annotated in _revokeInvite, the business logic is not clear. coordinape-protocol/contracts/circles_obsolete/CoordinapeCircle.sol#L158-L175 function _issueInvite(address recipient, uint8 role) internal { Counters.increment(_inviteIds); uint256 tokenId = Counters.current(_inviteIds); _mint(recipient, tokenId); _roles[tokenId] = role; 20 _invites[recipient] = tokenId; _vouches[recipient] = 0; emit InviteIssued(recipient, role); } function _revokeInvite(address recipient) internal { uint256 tokenId = _invites[recipient]; _inactiveMembers.increment(); //_burn(tokenId); _roles[tokenId] = 0; _invites[recipient] = 0; emit InviteRevoked(recipient, 0); } _epochEnds is never initialized, and used in _epochInProgress function. coordinape-protocol/contracts/circles_obsolete/CoordinapeCircle.sol#L155 function _epochInProgress() internal view returns (bool) { uint256 epochId = Counters.current(_epochIds); // return epochId > 0 && !CoordinapeEpoch(_epochs[epochId]).ended(); return epochId > 0 && block.number < _epochEnds[epochId]; } _epochState is never initialized. and it is used in state function. coordinape-protocol/contracts/circles_obsolete/CoordinapeCircle.sol#L105 function state(uint256 _epoch) external view returns (uint8) { return _epochState[_epoch]; } The address passed in by the _migrate function is address(this), which means migrating to the address(this) contract, the logic here is not clear. coordinape-protocol/contracts/ApeProtocol/wrapper/beacon/ApeVault.sol#L166-L169 21 function apeMigrate() external onlyOwner returns(uint256 migrated){ migrated = _migrate(address(this)); vault = VaultAPI(registry.latestVault(address(token))); } migrated = _deposit(address(this), account, withdrawn, false); account is address(this), the logic here is wrong coordinape-protocol/contracts/ApeProtocol/wrapper/beacon/BaseWrapperImplementation.sol#L387-L427 function _migrate(address account) internal returns (uint256) { return _migrate(account, MIGRATE_EVERYTHING); } function _migrate(address account, uint256 amount) internal returns (uint256) { // NOTE: In practice, it was discovered that <50 was the maximum we've see for this variance return _migrate(account, amount, 0); } function _migrate( address account, uint256 amount, uint256 maxMigrationLoss ) internal returns (uint256 migrated) { VaultAPI _bestVault = bestVault(); // NOTE: Only override if we aren't migrating everything uint256 _depositLimit = _bestVault.depositLimit(); uint256 _totalAssets = _bestVault.totalAssets(); if (_depositLimit <= _totalAssets) return 0; // Nothing to migrate (not a failure) uint256 _amount = amount; if (_depositLimit < UNCAPPED_DEPOSITS && _amount < WITHDRAW_EVERYTHING) { // Can only deposit up to this amount uint256 _depositLeft = _depositLimit.sub(_totalAssets); if (_amount > _depositLeft) _amount = _depositLeft; } 22 if (_amount > 0) { // NOTE: `false` = don't withdraw from `_bestVault` uint256 withdrawn = _withdraw(account, address(this), _amount, false); if (withdrawn == 0) return 0; // Nothing to migrate (not a failure) // NOTE: `false` = don't do `transferFrom` because it's already local migrated = _deposit(address(this), account, withdrawn, false); // NOTE: Due to the precision loss of certain calculations, there is a small inefficency // on how migrations are calculated, and this could lead to a DoS issue. Hence, this // value is made to be configurable to allow the user to specify how much is acceptable require(withdrawn.sub(migrated) <= maxMigrationLoss); } // else: nothing to migrate! (not a failure) } The return value of decimals is 0, and developers need to conrm the business logic here. coordinape-protocol/contracts/circles_obsolete/CoordinapeEpoch.sol#L143-L145 function decimals() public pure override returns (uint8) { return 0; }",
        "labels": [
            "SlowMist",
            "Coordinape protocol",
            "Type: Others",
            "Severity: High"
        ]
    },
    {
        "title": "Coding standards issues 23",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Coordinape protocol_en-us.pdf",
        "body": "Executed rst _call(id, _target, _data); and then executed timestamps[id] = _DONE_TIMESTAMP; , which does not meet the specication(Checks-Eects-Interactions). coordinape-protocol/contracts/ApeProtocol/TimeLock.sol#L72-L73 function execute(address _target, bytes calldata _data, bytes32 _predecessor, bytes32 _salt, uint256 _delay) external onlyOwner { bytes32 id = hashOperation(_target, _data, _predecessor, _salt); require(isReadyCall(id), \"TimeLock: Not ready for execution or executed\"); require(_predecessor == bytes32(0) || isDoneCall(_predecessor), \"TimeLock: Predecessor call not executed\"); _call(id, _target, _data); timestamps[id] = _DONE_TIMESTAMP; } function _call( bytes32 id, address target, bytes calldata data ) internal { (bool success, ) = target.call(data); require(success, \"Timelock: underlying transaction reverted\"); emit CallExecuted(id, target, data); }",
        "labels": [
            "SlowMist",
            "Coordinape protocol",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "The external call does not judge the return value 24",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Coordinape protocol_en-us.pdf",
        "body": "The external call in the _withdraw function does not evaluate the return value E.g vaults[id].transferFrom , vault.transfer , IERC20(_token).transfer If the transferFrom function and transfer of the externally called token contract return false, the code logic will be wrong. coordinape-protocol/contracts/ApeProtocol/wrapper/beacon/BaseWrapperImplementation.sol#L353-L362 function _withdraw( address sender, address receiver, uint256 amount, // if `MAX_UINT256`, just withdraw everything bool withdrawFromBest // If true, also withdraw from `_bestVault` ) internal returns (uint256 withdrawn) { VaultAPI _bestVault = bestVault(); VaultAPI[] memory vaults = allVaults(); _updateVaultCache(vaults); // NOTE: This loop will attempt to withdraw from each Vault in `allVaults` that `sender` // is deposited in, up to `amount` tokens. The withdraw action can be expensive, // so it if there is a denial of service issue in withdrawing, the downstream usage // of this wrapper contract must give an alternative method of withdrawing using // this function so that `amount` is less than the full amount requested to withdraw // (e.g. \"piece-wise withdrawals\"), leading to less loop iterations such that the // DoS issue is mitigated (at a tradeoff of requiring more txns from the end user). for (uint256 id = 0; id < vaults.length; id++) { if (!withdrawFromBest && vaults[id] == _bestVault) { continue; // Don't withdraw from the best } 25 // Start with the total shares that `sender` has uint256 availableShares = vaults[id].balanceOf(sender); // Restrict by the allowance that `sender` has to this contract // NOTE: No need for allowance check if `sender` is this contract if (sender != address(this)) { availableShares = Math.min(availableShares, vaults[id].allowance(sender, address(this))); } // Limit by maximum withdrawal size from each vault availableShares = Math.min(availableShares, vaults[id].maxAvailableShares()); if (availableShares > 0) { // Intermediate step to move shares to this contract before withdrawing // NOTE: No need for share transfer if this contract is `sender` // if (sender != address(this)) vaults[id].transferFrom(sender, address(this), availableShares); if (amount != WITHDRAW_EVERYTHING) { // Compute amount to withdraw fully to satisfy the request uint256 estimatedShares = amount .sub(withdrawn) // NOTE: Changes every iteration .mul(10**uint256(vaults[id].decimals())) .div(vaults[id].pricePerShare()); // NOTE: Every Vault is different // Limit amount to withdraw to the maximum made available to this contract // NOTE: Avoid corner case where `estimatedShares` isn't precise enough // NOTE: If `0 < estimatedShares < 1` but `availableShares > 1`, this will withdraw more than necessary if (estimatedShares > 0 && estimatedShares < availableShares) { if (sender != address(this)) vaults[id].transferFrom(sender, address(this), estimatedShares); withdrawn = withdrawn.add(vaults[id].withdraw(estimatedShares)); } else { if (sender != address(this)) vaults[id].transferFrom(sender, address(this), availableShares); 26 withdrawn = withdrawn.add(vaults[id].withdraw(availableShares)); } } else { if (sender != address(this)) vaults[id].transferFrom(sender, address(this), availableShares); withdrawn = withdrawn.add(vaults[id].withdraw()); } // Check if we have fully satisfied the request // NOTE: use `amount = WITHDRAW_EVERYTHING` for withdrawing everything if (amount <= withdrawn) break; // withdrawn as much as we needed } } // If we have extra, deposit back into `_bestVault` for `sender` // NOTE: Invariant is `withdrawn <= amount` if (withdrawn > amount && withdrawn.sub(amount) > _bestVault.pricePerShare().div(10**_bestVault.decimals())) { // Don't forget to approve the deposit if (token.allowance(address(this), address(_bestVault)) < withdrawn.sub(amount)) { token.safeApprove(address(_bestVault), UNLIMITED_APPROVAL); // Vaults are trusted } _bestVault.deposit(withdrawn.sub(amount), sender); withdrawn = amount; } // `receiver` now has `withdrawn` tokens as balance if (receiver != address(this)) token.safeTransfer(receiver, withdrawn); } coordinape-protocol/contracts/ApeProtocol/ApeDistributor.sol#L147 function tapEpochAndDistribute( address _vault, bytes32 _circle, address _token, address[] calldata _users, 27 uint256[] calldata _amounts, uint256 _amount, uint8 _tapType) external { require(_users.length == _amounts.length, \"ApeDistributor: Array lengths do not match\"); require(sum(_amounts) == _amount, \"ApeDistributor: Amount does not match sum of values\"); _tap(_vault, _circle, _token, _amount, _tapType, bytes32(type(uint256).max)); for (uint256 i = 0; i < _users.length; i++) IERC20(_token).transfer(_users[i], _amounts[i]); } coordinape-vesting-contracts/contracts/Vesting.sol#L77-L99 function fetchTokens(uint256 _amount) external onlyOwner { IERC20(co).transfer(msg.sender, _amount); } function claim(uint256 _index) external override { uint256 _now = block.timestamp; Vehicule storage vehicule = vehicules[msg.sender][_index]; uint256 upfront = _claimUpfront(vehicule); uint256 start = vehicule.start; if (start == 0) revert(\"Vesting: vehicule does not exist\"); require(_now > start, \"Vesting: cliff !started\"); uint256 end = vehicule.end; uint256 elapsed = min(end, _now) - start; uint256 maxDelta = end - start; // yield = amount * delta / vest_duration - claimed_amount uint256 yield = (vehicule.amount * elapsed / maxDelta) - vehicule.claimed; vehicule.claimed += yield; IERC20(co).transfer(msg.sender, yield + upfront); 28 emit YieldClaimed(msg.sender, yield); }",
        "labels": [
            "SlowMist",
            "Coordinape protocol",
            "Type: Unsafe External Call Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Excessive authority issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Coordinape protocol_en-us.pdf",
        "body": "Owner can transfer assets in the contract. coordinape-protocol/contracts/ApeProtocol/wrapper/beacon/ApeVault.sol#L129 function apeWithdrawSimpleToken(uint256 _amount) public onlyOwner { simpleToken.safeTransfer(msg.sender, _amount); } coordinape-protocol/contracts/ApeProtocol/wrapper/beacon/ApeVault.sol#L139 function apeWithdraw(uint256 _shareAmount, bool _underlying) external onlyOwner { uint256 underlyingAmount = shareValue(_shareAmount); require(underlyingAmount <= underlyingValue, \"underlying amount higher than vault value\"); address router = ApeRegistry(apeRegistry).router(); underlyingValue -= underlyingAmount; vault.safeTransfer(router, _shareAmount); ApeRouter(router).delegateWithdrawal(owner(), address(this), vault.token(), _shareAmount, _underlying); } 29 coordinape-protocol/contracts/ApeProtocol/wrapper/beacon/ApeVault.sol#L154 function exitVaultToken(bool _underlying) external onlyOwner { underlyingValue = 0; uint256 totalShares = vault.balanceOf(address(this)); address router = ApeRegistry(apeRegistry).router(); vault.safeTransfer(router, totalShares); ApeRouter(router).delegateWithdrawal(owner(), address(this), vault.token(), totalShares, _underlying); } Owner can transfer the tokens in the contract. coordinape-vesting-contracts/contracts/Vesting.sol#L77 function fetchTokens(uint256 _amount) external onlyOwner { IERC20(co).transfer(msg.sender, _amount); }",
        "labels": [
            "SlowMist",
            "Coordinape protocol",
            "Type: Authority Control Vulnerability",
            "Severity: High"
        ]
    },
    {
        "title": "Lack of permission checks 30",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Coordinape protocol_en-us.pdf",
        "body": "The createApeVault function does not perform permission checks. Anyone can create ApeVault. If the incoming parameters are malicious (malicious Token or incompatible Token), it will aect the funds in the project. coordinape-protocol/contracts/ApeProtocol/wrapper/beacon/ApeVaultFactory.sol#L22-L27 function createApeVault(address _token, address _simpleToken) external { bytes memory data = abi.encodeWithSignature(\"init(address,address,address,address,address)\", apeRegistry, _token, yearnRegistry, _simpleToken, msg.sender); ApeBeacon proxy = new ApeBeacon(beacon, msg.sender, data); vaultRegistry[address(proxy)] = true; emit VaultCreated(address(proxy)); }",
        "labels": [
            "SlowMist",
            "Coordinape protocol",
            "Type: Authority Control Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "4.3.1.1 Reordering attack risk",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - InsurAce_en-us.pdf",
        "body": "When the owner calls preparePaymentForPayout, it will go to uniswap to calculate the required amountIn, and then perform the swap operation according to the amountIn. There is a risk of rearrangement attacks that may cause losses in the InsurAce pool. It is recommended to check the slippage of swap. Reference https://www.odaily.com/post/5162888 https://medium.com/coinmonks/demystify-the-dark-forest-on-ethereum-sandwich-attacks-5a3ae c9fa33e  contracts/pool/StakersPool.sol function claimPayout( address _fromToken, address _paymentToken, uint256 _settleAmtPT, address _claimTo, uint256 _claimId ) external override allowedCaller { require(_fromToken == poolToken, \"CP:1\"); 23 if (_settleAmtPT == 0) { return; } uint256 temp = _getTokenforExactPaymentToken(_fromToken, _paymentToken, _settleAmtPT); uint256 amountInMax = Math.min(stakedAmount, temp.mul(11).div(10)); uint256 convertOut = _convertTokenforExactPaymentToken(_fromToken, _paymentToken, _settleAmtPT, amountInMax); stakedAmount = stakedAmount.sub(convertOut); claimPayouts.push(convertOut); claimPayoutsClaimId.push(_claimId); _transferTokenTo(_paymentToken, _settleAmtPT, _claimTo, _claimId); } function _convertTokenforExactPaymentToken( address _tokenFrom, address _tokenTo, uint256 _amountOut, uint256 _amountInMax ) private returns (uint256) { require(_tokenFrom != _tokenTo, \"CT2EPT:1\"); address[] memory path = new address[](2); uint256[] memory ret; if (_tokenFrom == Constant.ETHTOKENADDRESS) { path[0] = uniswapRouter.WETH(); path[1] = _tokenTo; ret = uniswapRouter.swapETHForExactTokens{value: _amountInMax}( _amountOut, path, address(this), block.timestamp + 120 //solhint-disable-linenot-rely-on-time ); return ret[0]; } if (_tokenTo == Constant.ETHTOKENADDRESS) { path[0] = _tokenFrom; path[1] = uniswapRouter.WETH(); IERC20Upgradeable(path[0]).approve(Constant.UNISWAPV2_ROUTER_ADDRESS, _amountInMax); ret = uniswapRouter.swapTokensForExactETH( _amountOut, _amountInMax, path, 24 address(this), block.timestamp + 120 //solhint-disable-linenot-rely-on-time ); return ret[0]; } path[0] = _tokenFrom; path[1] = _tokenTo; IERC20Upgradeable(path[0]).approve(Constant.UNISWAPV2_ROUTER_ADDRESS, _amountInMax); ret = uniswapRouter.swapTokensForExactTokens( _amountOut, _amountInMax, path, address(this), block.timestamp + 120 //solhint-disable-linenot-rely-on-time ); return ret[0]; }  contracts/pool/StakersPool.sol function _getTokenforExactPaymentToken( address _tokenFrom, address _tokenTo, uint256 _amount ) private view returns (uint256) { if (_tokenFrom == _tokenTo) { return _amount; } address[] memory path = new address[](2); if (_tokenFrom == Constant.ETHTOKENADDRESS) { path[0] = uniswapRouter.WETH(); } else { path[0] = _tokenFrom; } if (_tokenTo == Constant.ETHTOKENADDRESS) { path[1] = uniswapRouter.WETH(); } else { path[1] = _tokenTo; } 25 uint256[] memory ret = uniswapRouter.getAmountsIn(_amount, path); return ret[0]; } Fix Status: The issues has been fixed.",
        "labels": [
            "SlowMist",
            "InsurAce",
            "Severity: High"
        ]
    },
    {
        "title": "4.3.1.2 Missing permission check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - InsurAce_en-us.pdf",
        "body": "The addCoverOwner function does not perform permission checking, any user can call this function to add owner. It is recommended to add permission check code.  contracts/cover/CoverData.sol function addCoverOwner(address owner) public { require(owner != address(0), \"ACO: 1\"); require(!allCoverOwnerFlagMap[owner], \"ACO: 2\"); allCoverOwnerList.push(owner); allCoverOwnerFlagMap[owner] = true; } Fix Status: The issues has been fixed.",
        "labels": [
            "SlowMist",
            "InsurAce",
            "Severity: High"
        ]
    },
    {
        "title": "4.3.2.1 DoS issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - InsurAce_en-us.pdf",
        "body": "_getDelAccuRwAmtPS has 3 while loop nestings, which will be affected by the parameters of lastScheduleCounter, gRewardTokenRatePerStakedTokenArray, _unstakeLockArrayBlockPerStaker, and dos due to more users or more mining cycles added.  contracts/staking/ScheduledMiningProgram.sol function _getDelAccuRwAmtPS( uint256 _lastCalculatedBlockPerStaker, uint256 _stakedAmtPerStaker, uint256[] memory _unstakeLockArrayBlockPerStaker, uint256[] memory _unstakeLockArrayAmtPerStaker 26 ) private view returns (uint256) { console.log(\"getDeltaAccumulativeRewardAmtPerStaker++\"); console.log(_lastCalculatedBlockPerStaker); console.log(_stakedAmtPerStaker); console.log(_unstakeLockArrayBlockPerStaker.length); uint256 retV = 0; //gothruthelistofallschedules uint256 scheduleIndex = lastScheduleCounter; while (scheduleIndex >= 1) { if (_lastCalculatedBlockPerStaker >= endMiningBlockPerSchedule[scheduleIndex]) { break; } //narrowdownblockdelta uint256 minWall = Math.max(_lastCalculatedBlockPerStaker, startMiningBlockPerSchedule[scheduleIndex]); uint256 maxWall = Math.min(block.number, endMiningBlockPerSchedule[scheduleIndex]); console.log(\"minWall: \", minWall); console.log(\"maxWall: \", maxWall); if (minWall >= maxWall) { scheduleIndex = scheduleIndex.sub(1); continue; } uint256 rateChangeIndex = gRewardTokenRatePerStakedTokenArray.length; if (rateChangeIndex == 0) { break; } uint256 rewardAccumulatedBetweenWalls = 0; while (rateChangeIndex > 0) { uint256 blockNumber = gRewardTokenRatePerStakedTokenArray[rateChangeIndex - 1]; console.log(\"blockNumber: \", blockNumber); if (blockNumber >= maxWall) { rateChangeIndex = rateChangeIndex.sub(1); continue; } if (blockNumber >= minWall) { uint256 delta = _getDeltaAccumulativeRewardsWithFixRatePerStaker(blockNumber, maxWall, gRewardTokenRatePerStakedTokenMap[blockNumber], _stakedAmtPerStaker, _unstakeLockArrayBlockPerStaker, _unstakeLockArrayAmtPerStaker); rewardAccumulatedBetweenWalls = delta.add(rewardAccumulatedBetweenWalls); maxWall = blockNumber; rateChangeIndex = rateChangeIndex.sub(1); continue; 27 } if (blockNumber < minWall) { uint256 delta = _getDeltaAccumulativeRewardsWithFixRatePerStaker(minWall, maxWall, gRewardTokenRatePerStakedTokenMap[blockNumber], _stakedAmtPerStaker, _unstakeLockArrayBlockPerStaker, _unstakeLockArrayAmtPerStaker); rewardAccumulatedBetweenWalls = delta.add(rewardAccumulatedBetweenWalls); break; } } retV = rewardAccumulatedBetweenWalls.add(retV); scheduleIndex = scheduleIndex.sub(1); } return retV; } Fix Status: This issue has been fixed",
        "labels": [
            "SlowMist",
            "InsurAce",
            "Severity: Medium"
        ]
    },
    {
        "title": "4.3.3.1 Excessive authority issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - InsurAce_en-us.pdf",
        "body": "Admin has permission to add sender, There is a issues of excessive authority. It is recommended to set Owner to Timelock contract or governance contract.  contracts/token/INSURToken.sol function addSender(address _from) external onlyAdmin { if (1 == transferFromAllowedList[_from]) { return; } membersFrom.push(_from); transferFromAllowedList[_from] = 1; } The admin can remove the sender arbitrarily, and there is a risk of denial of service. When the admin adds too many senders, the data in the memberFrom array will be very large, so when the removeSender is removed, the depth of the for loop call will be too large, resulting in The call fails. It 28 is recommended to change memberFrom to storage in the way of mapping, and use address as the key to avoid dos caused by this type of looping to obtain data.  contracts/token/INSURToken.sol function removeSender(address _from) external onlyAdmin { uint256 arrayLength = membersFrom.length; uint256 indexToBeDeleted; bool toDelete = false; for (uint256 i = 0; i < arrayLength; i++) { if (membersFrom[i] == _from) { indexToBeDeleted = i; toDelete = true; break; } } if (!toDelete) { return; } //ifindextobedeletedisnotthelastindex,swapposition. if (indexToBeDeleted < arrayLength - 1) { membersFrom[indexToBeDeleted] = membersFrom[arrayLength - 1]; } //wecannowreducethearraylengthby1 membersFrom.pop(); delete transferFromAllowedList[_from]; } MINTER can call mint arbitrarily, and there is no upper limit for minting.  contracts/token/INSURToken.sol function mint(address to, uint256 amount) public virtual { require(hasRole(MINTER_ROLE, _msgSender()), \"ERC20PresetMinterPauser: must have minter role to mint\"); _mint(to, amount); } Fix Status: This issue has been confirmed  after communication and feedback, the minting and Owner permissions may be transferred to address(0) in the future. 29 Owner can set lpTokenMinter and lpTokenBurner. The roles of lpTokenMinter and lpTokenBurner can mint and burn the user's LP. There is a issues of excessive authority. It is recommended to set Owner to Timelock contract or governance contract. And make sure the lpTokenMinter and lpTokenBurner cannot be EOA account.  contracts/token/LPToken.sol function setup(address _lpTokenMinter, address _lpTokenBurner) external onlyOwner { require(_lpTokenMinter != address(0), \"S:1\"); lpTokenMinter = _lpTokenMinter; require(_lpTokenBurner != address(0), \"S:2\"); lpTokenBurner = _lpTokenBurner; } Fix Status: This issue has been communicated back to the project team. The project team is aware of this and will adopt governance mechanism to secure the permission when the governance module goes live.",
        "labels": [
            "SlowMist",
            "InsurAce",
            "Severity: Low"
        ]
    },
    {
        "title": "4.3.3.2 DoS issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - InsurAce_en-us.pdf",
        "body": "The incoming _callers will add data to allowedCallersArray[_callee]. If too many _callers are added at one time, it will cause Out of Gas. When there are too many data in allowedCallersArray[_callee], the setAllowdCallersPerCallee function will DoS. It is recommended to set the data Use the mapping method to store instead, avoid using the for loop to find the value.  contracts/secmatrix/SecurityMatrix.sol function addAllowdCallersPerCallee(address _callee, address[] memory _callers) external onlyOwner { require(_callers.length != 0, \"AACPC:1\"); require(allowedCallersArray[_callee].length != 0, \"AACPC:2\"); for (uint256 index = 0; index < _callers.length; index++) { console.log(\"_callers index: \", _callers[index], index); allowedCallersArray[_callee].push(_callers[index]); 30 allowedCallersMap[_callee][_callers[index]] = 1; } }  contracts/secmatrix/SecurityMatrix.sol function setAllowdCallersPerCallee(address _callee, address[] memory _callers) external onlyOwner { console.log(\"_callee: \", _callee); console.log(\"_callers.length: \", _callers.length); require(_callers.length != 0, \"SACPC:1\"); //checkifcalleeexist if (allowedCallersArray[_callee].length == 0) { //notexist,soaddcallee allowedCallees.push(_callee); } else { //ifcalleeexist,thenpurgedata for (uint256 i = 0; i < allowedCallersArray[_callee].length; i++) { delete allowedCallersMap[_callee][allowedCallersArray[_callee][i]]; } delete allowedCallersArray[_callee]; } //andoverwrite for (uint256 index = 0; index < _callers.length; index++) { console.log(\"_callers index: \", _callers[index], index); allowedCallersArray[_callee].push(_callers[index]); allowedCallersMap[_callee][_callers[index]] = 1; } } Fix Status: This issue has been communicated back to project team. The project team is aware of this issue and the method will only be used by admin when setting up security matrix. The setAllowdCallersPerCallee method will be used to create security matrix entries, and the addAllowdCallersPerCallee method will be used to add delta matrix if needed.",
        "labels": [
            "SlowMist",
            "InsurAce",
            "Severity: Low"
        ]
    },
    {
        "title": "4.3.3.3 Repeatable call risk",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - InsurAce_en-us.pdf",
        "body": "If Owner call setupVestors function multiple times, there will be duplicate vestors in the vestor 31 array.When the setupVestors is called multiple times, if the vestor calls withdrawRewardPV intentionally or unintentionally during the calling process, initRewardPV and insurVestingTotalPV may get unexpected values. If setupVestors can be called multiple times, then when the owner is called, the vestor also calls withdrawRewardPV. In this case, the gas price of calling withdrawRewardPV is higher than that of calling setupVestors. Will execute withdrawRewardPV first, and then execute setupVestors, the data will appear unexpected. Competitive conditions similar to approve.  contracts/fixedvesting/FixedVesting.sol function setupVestors( address[] memory _vestors, uint256[] memory _vestingRewardPV, uint256[] memory _initRewardPV ) external onlyOwner { require(_vestors.length == _vestingRewardPV.length, \"AV:1\"); require(_initRewardPV.length == _vestingRewardPV.length, \"AV:2\"); for (uint256 i = 0; i < _vestors.length; i++) { address vestor = _vestors[i]; vestors.push(vestor); initRewardPV[vestor] = _initRewardPV[i]; insurVestingTotalPV[vestor] = _vestingRewardPV[i]; } } Fix Status: This issue has been fixed.",
        "labels": [
            "SlowMist",
            "InsurAce",
            "Severity: Low"
        ]
    },
    {
        "title": "4.3.3.4 Overflow risk",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - InsurAce_en-us.pdf",
        "body": "safemath should be used to calculate the length of the array to avoid overflow issues: if Currency is not added, the removal may cause overflow issues.  contracts/cover/CoverConfig.sol 32 function removeCurrency(address currency) external allowedCaller { require(currency != address(0), \"RC: 1\"); uint256 arrayLength = currencyValidAddressArray.length; uint256 indexToBeDeleted; bool toDelete = false; for (uint256 i = 0; i < arrayLength; i++) { if (currencyValidAddressArray[i] == currency) { indexToBeDeleted = i; toDelete = true; break; } } if (!toDelete) { require(toDelete, \"RC: 1\"); } //ifindextobedeletedisnotthelastindex,swapposition. if (indexToBeDeleted < arrayLength - 1) { currencyValidAddressArray[indexToBeDeleted] = currencyValidAddressArray[arrayLength - 1]; } //wecannowreducethearraylengthby1 currencyValidAddressArray.pop(); delete currencyValidAddressMap[currency]; } Fix Status: This issue has been fixed.",
        "labels": [
            "SlowMist",
            "InsurAce",
            "Severity: Low"
        ]
    },
    {
        "title": "4.3.3.5 FlashLoan attack risk",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - InsurAce_en-us.pdf",
        "body": "Unstake is judged by >= when there are already voting tasks. If claimsAssessorMinUnstakeTime is 0, then there will be a issue of using flashloan to vote.  contracts/claim/Claim.sol function unstake(address insurTokenAddress, uint256 insurAmount) external payable whenNotPaused nonReentrant { require(insurTokenAddress != address(0), \"USTK: 1\"); address payable assessor = _msgSender(); ClaimReward(crw).recalculateAssessor(assessor); bool canUnstake = false; 33 uint256 latestVoteTimestamp = ClaimAssessor(asr).getLatestVoteTimestamp(assessor); if (latestVoteTimestamp == 0) { canUnstake = true; } else { if ( block.timestamp >= ClaimAssessor(asr).getVoteStakePeriodEndTime(assessor) //solhint-disable-line not-rely-on-time canUnstake = true; ) { } } require(canUnstake, \"USTK: 2\"); require(insurAmount <= ClaimAssessor(asr).getNumOfVotes(assessor), \"USTK: 3\"); require(IERC20Upgradeable(insurTokenAddress).balanceOf(address(this)) >= insurAmount, \"USTK: 4\"); ClaimAssessor(asr).decreaseVotes(assessor, insurAmount); IERC20Upgradeable(insurTokenAddress).safeTransfer(assessor, insurAmount); } Fix Status: This issue has been fixed.",
        "labels": [
            "SlowMist",
            "InsurAce",
            "Severity: Low"
        ]
    },
    {
        "title": "4.3.4.1 Token compatibility risk",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - InsurAce_en-us.pdf",
        "body": "IERC20Upgradeable(stakedToken).safeTransferFrom(_msgSender(), address(this), _amount); The transfer operation of an external token is adopted. It is recommended to pay attention to the compatibility of the project and the token when adding a new token, such as: token return Value issues, fake token recharge issues, compatibility issues with deflationary tokens, etc.  contracts/staking/StakeOps.sol function stakeTokens(uint256 _amount, address _token) external payable whenNotPaused nonReentrant { require(IMiningProgram(iMiningProgram).canStake(_amount), \"ST:1\"); address stakedToken = StakersData(stakerDataAddr).stakedToken(); require(_token == stakedToken, \"ST:2\"); 34 if (stakedToken == Constant.ETHTOKENADDRESS) { require(_amount <= msg.value, \"ST:3\"); } else { require(IERC20Upgradeable(stakedToken).balanceOf(_msgSender()) >= _amount, \"ST:4\"); uint256 allowanceAmt = IERC20Upgradeable(stakedToken).allowance(_msgSender(), address(this)); require(allowanceAmt >= _amount, \"ST:5\"); } _reCalcPerStaker(); if (stakedToken != Constant.ETHTOKENADDRESS) { IERC20Upgradeable(stakedToken).safeTransferFrom(_msgSender(), address(this), _amount); } //dispatchtokentopool if (stakedToken == Constant.ETHTOKENADDRESS) { IStakersPool(iStakersPool).addStkAmount{value: _amount}(stakedToken, _amount); } else { IERC20Upgradeable(stakedToken).safeTransfer(iStakersPool, _amount); Fix Status: This issue has been communicated back to project team. The project team is aware of this and has already performed compatibility checks on the staking tokens, such as ETH, WETH, USDC, USDT, DAI, and INSUR, which are all compatible with the relevant standards.",
        "labels": [
            "SlowMist",
            "InsurAce",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.3.4.2 Event log is missing",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - InsurAce_en-us.pdf",
        "body": "It is recommended to add an event to record securityMatrix changes, applicable to all set functions. function setup(address _securityMatrix) external onlyOwner { require(_securityMatrix != address(0), \"S:1\"); securityMatrix = _securityMatrix; } Fix Status: This issue has been communicated back to project team. The project team will add more event logs in their development, including not limited to \"setup\".",
        "labels": [
            "SlowMist",
            "InsurAce",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.3.4.3 Redundant code",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - InsurAce_en-us.pdf",
        "body": "The `if (!toDelete) {require(toDelete, \"RC: 1\"); }` code can be simplified to `require(toDelete, \"RC: 1\");`. 35  contracts/cover/CoverConfig.sol function removeCurrency(address currency) external allowedCaller { require(currency != address(0), \"RC: 1\"); uint256 arrayLength = currencyValidAddressArray.length; uint256 indexToBeDeleted; bool toDelete = false; for (uint256 i = 0; i < arrayLength; i++) { if (currencyValidAddressArray[i] == currency) { indexToBeDeleted = i; toDelete = true; break; } } if (!toDelete) { require(toDelete, \"RC: 1\"); } //ifindextobedeletedisnotthelastindex,swapposition. if (indexToBeDeleted < arrayLength - 1) { currencyValidAddressArray[indexToBeDeleted] = currencyValidAddressArray[arrayLength - 1]; } //wecannowreducethearraylengthby1 currencyValidAddressArray.pop(); delete currencyValidAddressMap[currency]; } Fix Status: This issue has been fixed.",
        "labels": [
            "SlowMist",
            "InsurAce",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.3.4.4 Hard coded issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - InsurAce_en-us.pdf",
        "body": "The external contract address is hard-coded and cannot be modified. It is recommended that the external contract adopts a changeable method to avoid the problem that the project cannot operate normally due to the upgrade of the external contract.  common/Constant.sol address public constant UNISWAPV2_ROUTER_ADDRESS = address(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D); 36 Fix Status: This issue has been communicated back to project team. The project team is aware of this issue, and made design changes, such as adding exchange library lately, which will include token to token exchange queries from 1inch and Uniswap. In the case of address change, the ABI of the address may change accordingly, as such the project team will need to double check, and/or extend exchange library in tandem. 5.",
        "labels": [
            "SlowMist",
            "InsurAce",
            "Severity: Informational"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - LightDAO_en-us.pdf",
        "body": "1.In the HOPESalesAgent contract, the owner can add currency that can buy HOPE tokendelete the currency and change the currency exhange rate. If the owners privileges are lost, it could lead to a contract being maliciously added with a worthless currency and used it to unintentionally buy large amounts of hope tokens. ",
        "labels": [
            "SlowMist",
            "LightDAO",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "The DoS issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - LightDAO_en-us.pdf",
        "body": "The user can pass in the gombocAddressList array through the mintMany function to mint the LT. If the length of gombocAddressList is large, it will cause DoS because of the number of for loops. ",
        "labels": [
            "SlowMist",
            "LightDAO",
            "Type: Denial of Service Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Missing event records",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - LightDAO_en-us.pdf",
        "body": "1.In the Minter contract, the caller can toggle the approval status for mintingUser, but there are no event logs. ",
        "labels": [
            "SlowMist",
            "LightDAO",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing zero address check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - LightDAO_en-us.pdf",
        "body": "When modifying important addresses in the contract, it is not checked whether the incoming address is a zero address. ",
        "labels": [
            "SlowMist",
            "LightDAO",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing return value check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - LightDAO_en-us.pdf",
        "body": "When transferring ERC20 tokens, the return value after the transfer is not checked. If return false, the logical should be reverted. ",
        "labels": [
            "SlowMist",
            "LightDAO",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "No value is assigned to the fee parameter",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap Lottery_en-us.pdf",
        "body": "The fee parameter is dened in the RandomNumberGenerator contract and is used in the getRandomNumber function, but the contract is initialized without assigning a value to the fee parameter. ",
        "labels": [
            "SlowMist",
            "PancakeSwap Lottery",
            "Type: Others",
            "Severity: Low"
        ]
    },
    {
        "title": "Issue with reusable joinNFT",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Open Social Core_en-us.pdf",
        "body": "In the RelationLogic contract, users can join a specied community by calling the join or batchJoin function. A joinNFT is minted for the users, and the processJoin function in the community-specic JoinCondition contract is executed to enforce the corresponding join conditions. However, the joinNFT transfers are not restricted in any way, which leads to the following scenario: If a user joins a community that requires a fee, and pays a specied fee to obtain a joinNFT for the community, he can then transfer that NFT to other users, and since the transfer of the joinNFT is not subject to any checking, multiple users can view or manipulate the community's resources or information using a single NFT (paying for it only once). Code Location: contracts/core/logic/RelationLogic.sol function _executeJoin( uint256 communityId, bytes calldata joinConditionData, uint256 value ) internal returns (uint256 tokenId) { OspDataTypes.CommunityStruct memory community = _getCommunityStorage()._communityById[ communityId ]; if (community.joinNFT == address(0)) revert OspErrors.InvalidCommunityId(); tokenId = IJoinNFT(community.joinNFT).mint(msg.sender); if (community.joinCondition != address(0)) { IJoinCondition(community.joinCondition).processJoin{value: value}( msg.sender, communityId, joinConditionData ); } }",
        "labels": [
            "SlowMist",
            "Open Social Core",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Lack of the repeatability check for creating OpenReactions",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Open Social Core_en-us.pdf",
        "body": "In the",
        "labels": [
            "SlowMist",
            "Open Social Core",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Missing inviter check when creating a prole",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Open Social Core_en-us.pdf",
        "body": "In the ProleLogic contract, the user can create a prole by calling the createProle function, but here the inviter parameter is not checked. If the inviter passed in is equal to msg.sender, it does not follow the normal logic. Code Location: contracts/core/logic/ProleLogic.sol#L274 function _createProfile( OspDataTypes.CreateProfileData calldata vars ) internal returns (uint256) { ... if (vars.inviter != 0) { if (_getProfileStorage()._profileById[vars.inviter].owner == address(0)) { revert OspErrors.ProfileDoesNotExist(); } profileStruct.inviter = vars.inviter; } ... }",
        "labels": [
            "SlowMist",
            "Open Social Core",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Lack of check when following other users",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Open Social Core_en-us.pdf",
        "body": "In the RelationLogic contract, anyone can follow other users by calling the follow or batchFollow function. But here it doesn't check if the object to follow is equal to msg.sender, which doesn't follow the normal logic if you can follow yourself. Code Location: contracts/core/logic/RelationLogic.sol#L186-211 function _executeFollow( uint256 profileId, bytes calldata followConditionData, uint256 value ) internal returns (uint256 tokenId) { if (_getProfileStorage()._profileById[profileId].owner == address(0)) revert OspErrors.TokenDoesNotExist(); address followCondition = _getProfileStorage()._profileById[profileId].followCondition; address followSBT = _getProfileStorage()._profileById[profileId].followSBT; if (followSBT == address(0)) { followSBT = _deployFollowSBT(profileId); _getProfileStorage()._profileById[profileId].followSBT = followSBT; } ... }",
        "labels": [
            "SlowMist",
            "Open Social Core",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Lack of check whether a community has been joined",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Open Social Core_en-us.pdf",
        "body": "In the RelationLogic contract, anyone can join a specied community by calling the join or batchJoin function. However, there is no check to see if the user has already joined the community. If the condition of joining the community is that the number of tokens held reaches a set value, then the user can join the community several times to mint joinNFT, and then transfer the NFT to other users (even if the other users' token balances don't meet the requirements). Code Location: contracts/core/logic/RelationLogic.sol#L318-335 function _executeJoin( uint256 communityId, bytes calldata joinConditionData, uint256 value ) internal returns (uint256 tokenId) { OspDataTypes.CommunityStruct memory community = _getCommunityStorage()._communityById[ communityId ]; if (community.joinNFT == address(0)) revert OspErrors.InvalidCommunityId(); tokenId = IJoinNFT(community.joinNFT).mint(msg.sender); ... }",
        "labels": [
            "SlowMist",
            "Open Social Core",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Missing event record",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Open Social Core_en-us.pdf",
        "body": "The following functions in several contracts are for event logging of key parameter settings. Code Location: contracts/core/conditions/community/SlotNFTCommunityCond.sol#L34-36 function whitelistCommunitySlot(address slot, bool whitelist) external onlyOperation { _slotNFTWhitelisted[slot] = whitelist; } contracts/core/conditions/community/WhitelistAddressCommunityCond.sol#L37-39 function setMaxCreationNumber(address to, uint256 _maxCreationNumber) external onlyOperation { maxCreationNumber[to] = _maxCreationNumber; } Code Location: contracts/core/logic/GovernanceLogic.sol#L108-112 function setERC6551AccountImpl( address accountImpl ) external override onlyRole(Constants.GOVERNANCE) { _getGovernanceStorage()._erc6551AccountImpl = accountImpl; }",
        "labels": [
            "SlowMist",
            "Open Social Core",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "call() should be used instead of transfer() and send()",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Open Social Core_en-us.pdf",
        "body": "The transfer() and send() functions forward a xed amount of 2300 gas. Historically, it has often been recommended to use these functions for value transfers to guard against reentrancy attacks. However, the gas cost of EVM instructions may change signicantly during hard forks which may break already deployed contract systems that make xed assumptions about gas costs. For example. EIP 1884 broke several existing smart contracts due to a cost increase of the SLOAD instruction. ",
        "labels": [
            "SlowMist",
            "Open Social Core",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Open Social Core_en-us.pdf",
        "body": "In the OspUniversalProxy contract, the gov role can directly upgrade the implementation contract and call the functions of the new contract. If the privilege is lost or misused, This could lead to malicious tampering with the contract's functionality. ",
        "labels": [
            "SlowMist",
            "Open Social Core",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Authority transfer enhancement",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Open Social Core_en-us.pdf",
        "body": "In the Account contract, the admin role does not adopt the pending and access processes. If the admin is incorrectly set, the permission will be lost. Code Location: contracts/upgradeability/OspRouterImmutable.sol function changeAdmin(address _admin) public onlyAdmin { _changeAdmin(_admin); } ... function _changeAdmin(address admin_) internal { Data storage data = routerStorage(); emit AdminChanged(data.admin, admin_); data.admin = admin_; }",
        "labels": [
            "SlowMist",
            "Open Social Core",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Optimizable bytecode concatenation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase8 - SlowMist Audit Report.pdf",
        "body": "In the setByteCodes function of the Factory and CRPFactory contracts on the Scroll chain, due to the block gasLimit restriction, it is not possible to write the complete contract bytecode into bytecodes in a single transaction. Therefore, the bytecode is concatenated using the concatenate function. The concatenate function uses a for loop to copy and concatenate the bytecode, which consumes a large amount of gas compared to using calldatacopy. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase8 - SlowMist Audit Report",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Ination attack in StoneVault",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - StakeStone_en-us.pdf",
        "body": "In the StoneVault contract, users can can deposit assets and obtain the corresponding share of the vault by calling the deposit function, But there is a risk of interest rate ination attacks here: Consider this example: bob nds out that alice is making a deposit (e.g. via mempool). Pre-condition: no one deposit before( latestRoundID == 0 ) Assume raito = 1e18. Now, alice wants to deposit 1 (1 * 1e18 wei) WETH and the tx is spied on by the attacker(bob). Here is the breakdown: original state (after) Step 1 (after) Step 2 (after) Step 3 totalStone AssetsVault.getBalance() 0 1 1 1 0 1 1e18 + 1 2 * 1e18 + 1 1.bob front-runs alice and deposits 1 wei WETH and gets 1 share: since totalStone is 0, shares = amount = 1. 2.bob also transfers 1 * 1e18 wei WETH, making the WETH balance of the AssetsVault (AssetsVault.getBalance()) become 1e18 + 1 wei. And then directly call the rollToNextRoundId function to update the latestRoundId and price. (Since rebaseTime starts at 0, it can be called successfully directly). 3.alice deposits 1e18 wei WETH. However, alice gets 0 shares: 1e18 * 1 (totalStone) / (1e18 + 1) = 1e18 / (1e18 + 1) = 0. Since alice gets 0 shares, totalStone remains at 1. 4.bob still has the 1 only share ever minted, thus after waiting for the next rollToNextWETH function call for updating the price and the withdrawal of that 1 share takes away everything in the AssetsVault, including the alices 1e18 wei WETH.(Directly by calling the instantWithdraw function and passing in _amount parameter with a value of 0, _shares parameter with a value of 1). Code Location: contracts/StoneVault.sol#L150-173 function _depositFor( uint256 _amount, address _user ) internal returns (uint256 mintAmount) { require(_amount != 0, \"too small\"); uint256 sharePrice; uint256 currSharePrice = currentSharePrice(); if (latestRoundID == 0) { sharePrice = MULTIPLIER; } else { uint256 latestSharePrice = roundPricePerShare[latestRoundID - 1]; sharePrice = latestSharePrice > currSharePrice ? latestSharePrice : currSharePrice; } mintAmount = (_amount * MULTIPLIER) / sharePrice; AssetsVault(assetsVault).deposit{value: address(this).balance}(); Minter(minter).mint(_user, mintAmount); emit Deposit(_user, _amount, mintAmount, latestRoundID); } contracts/StoneVault.sol#L436-453 function currentSharePrice() public returns (uint256 price) { Stone stoneToken = Stone(stone); uint256 totalStone = stoneToken.totalSupply(); if ( latestRoundID == 0 || totalStone == 0 || totalStone == withdrawingSharesInPast ) { return MULTIPLIER; } uint256 etherAmount = AssetsVault(assetsVault).getBalance() + StrategyController(strategyController).getAllStrategiesValue() - withdrawableAmountInPast; uint256 activeShare = totalStone - withdrawingSharesInPast; return (etherAmount * MULTIPLIER) / activeShare; }",
        "labels": [
            "SlowMist",
            "StakeStone",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Missing setting rebaseTime when initializing",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - StakeStone_en-us.pdf",
        "body": "In the StoneVault contract, rebaseTime defaults to 0 and is not set in the constructor function. This could result in any user can call the function directly after the vault is created, potentially combining with other issues to have a signicant impact.(Refer to the N1 issue) Code Location: contracts/StoneVault.sol#L347 function rollToNextRound() external { require( block.timestamp > rebaseTime + rebaseTimeInterval, \"already rebased\" ); ... }",
        "labels": [
            "SlowMist",
            "StakeStone",
            "Type: Others",
            "Severity: Low"
        ]
    },
    {
        "title": "Risks of incorrect withdrawableAmountInPast updates",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - StakeStone_en-us.pdf",
        "body": "In the StoneVault contract, the rollToNextRound function moves the contract to the next round and updates the current round, including withdrawableAmountInPast. However, the price used in the withdrawableAmountInPast update is newSharePrice instead of the current round price (undPricePerShare [latestRoundID]). This results in newSharePrice being larger than the current round price (roundPricePerShare [latestRoundID]) if newSharePrice > previewSharePrice. In the withdrawal operation (instantWithdraw), the number of user withdrawals is actually calculated using roundPricePerShare, so if newSharePrice is larger than roundPricePerShare in the round of commit withdrawals, it may cause the withdrawal withdrawableAmountInPast is actually larger than the total remaining withdrawals. Then there may be the following situation: hypothesis After most withdrawals, totalStone has very little left (such as 1wei), and withdrawableAmountInPast the result of the price bias in statistics mentioned above is actually larger than expected. Then when calculating the current price (currentSharePrice), the calculation of etherAmount may be 0 or even an error due to overow. Code Location: contracts/StoneVault.sol#L387 function rollToNextRound() external { ... uint256 newSharePrice = currentSharePrice(); roundPricePerShare[latestRoundID] = previewSharePrice < newSharePrice ? previewSharePrice : newSharePrice; ... withdrawableAmountInPast = withdrawableAmountInPast + VaultMath.sharesToAsset(withdrawingSharesInRound, newSharePrice); withdrawingSharesInRound = 0; rebaseTime = block.timestamp; emit RollToNextRound(latestRoundID, vaultIn, vaultOut, newSharePrice); }",
        "labels": [
            "SlowMist",
            "StakeStone",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Missing check when migrating the vault",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - StakeStone_en-us.pdf",
        "body": "In the StoneVault contract, the migrateVault function is used to update the stoneVault address in the minter, assetsVault, and strategyController to achieve the eect of migration contracts. However, the migration does not check whether there are pending withdrawal requests in the current stoneVault contract. If the withdrawal request pending in the old stoneVault contract has not been nished during the migration process, then the data has been reset in the new stoneVault contract after the migration, which will cause the shares (stone tokens) transferred to the old stoneVault contract when the user committed the withdrawal request before to be locked and cannot be retrieved. Code Location: contracts/StoneVault.sol#L430-434 function migrateVault(address _vault) external onlyProposal { Minter(minter).setNewVault(_vault); AssetsVault(assetsVault).setNewVault(_vault); StrategyController(strategyController).setNewVault(_vault); }",
        "labels": [
            "SlowMist",
            "StakeStone",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Incorrect return value if the balance is sucient",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - StakeStone_en-us.pdf",
        "body": "When executing a withdrawal, if the eth balance in the AssetsVault contract is insucient, the forceWithdraw function of the controller contract will be called to make up the remaining eth by forcing a withdrawal. In the StrategyController contract, if the eth balance of this contract is sucient, the return value of actualAmount should normally be just what is needed (i.e. the passed ethAmount). But here all eth balances in the contract are returned, which may cause the user to withdraw more tokens than expected. Code Location: contracts/strategies/StrategyController.sol#L63 function forceWithdraw( uint256 _amount ) external onlyVault returns (uint256 actualAmount) { uint256 balanceBeforeRepay = address(this).balance; if (balanceBeforeRepay >= _amount) { _repayToVault(); actualAmount = balanceBeforeRepay; } else { actualAmount = _forceWithdraw(_amount - balanceBeforeRepay) + balanceBeforeRepay; } }",
        "labels": [
            "SlowMist",
            "StakeStone",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Incorrect withdrawal quantity calculation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - StakeStone_en-us.pdf",
        "body": "If the ETH balance in the contract is insucient during forced withdrawals, the instantWithdraw function in each strategy will be called in a loop to make up the dierence. The number of withdrawals for each strategy is calculated as _amount * ratios [strategy])/ONE_HUNDRED_PERCENT. Then there is a situation where if the sum of all ratios is less than ONE_HUNDRED_PERCENT, then the total number of forced withdrawals will be less than expected. (This is possible because the ratio of each strategy is set to only require the sum of all ratios to be less than or equal to ONE_HUNDRED_PERCENT, or a strategy is cleared). Code Location: contracts/strategies/StrategyController.sol#L187 function _forceWithdraw( uint256 _amount ) internal returns (uint256 actualAmount) { uint256 length = strategies.length(); for (uint i; i < length; i++) { address strategy = strategies.at(i); uint256 withAmount = (_amount * ratios[strategy]) / ONE_HUNDRED_PERCENT; if (withAmount != 0) { actualAmount = Strategy(strategy).instantWithdraw(withAmount) + actualAmount; } } _repayToVault(); }",
        "labels": [
            "SlowMist",
            "StakeStone",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Redundant code",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - StakeStone_en-us.pdf",
        "body": "There are useless codes in the le and codes that are not used in actual business. Code Location: contracts/strategies/StrategyController.sol#L51-53 function onlyRebaseStrategies() external { _rebase(0, 0); }",
        "labels": [
            "SlowMist",
            "StakeStone",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Incorrect PendingValue calculations in the STETHHoldingStrategy",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - StakeStone_en-us.pdf",
        "body": "In the STETHHoldingStrategy contract, the getPendingValue function is used to calculate the value of eth in the withdrawal process. However, only the amount of eth that has not passed the request during the withdrawal process is calculated here, and the part that has passed the request but has not been claimed is not calculated. This may cause the rollToNextRound function in the TokenVault contract to call the getAllStrategyPendingValue function to obtain all pending eth values less than expected. Code Location: contracts/strategies/STETHHoldingStrategy.sol#L155-157 function getPendingValue() public override returns (uint256 value) { (, , value) = checkPendingAssets(); } function checkPendingAssets() public returns ( uint256[] memory ids, uint256 totalClaimable, uint256 totalPending ) { ... for (uint256 i; i < length; i++) { ILidoWithdrawalQueue.WithdrawalRequestStatus memory status = statuses[i]; if (status.isClaimed) { continue; } if (status.isFinalized) { ids[j++] = allIds[i]; totalClaimable = totalClaimable + status.amountOfStETH; } else { totalPending = totalPending + status.amountOfStETH; } } ... }",
        "labels": [
            "SlowMist",
            "StakeStone",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Lack of event records",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - StakeStone_en-us.pdf",
        "body": "There is no corresponding event logged when a sensitive parameter in the contract is modied. Code Location: contracts/token/Minter.sol#L30-32 function setNewVault(address _vault) external onlyVault { vault = payable(_vault); } contracts/token/StoneCross.sol#L64-110 function _nonblockingLzReceive( uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload ) internal virtual override { ... if (packetType == PT_SEND) { _sendAck(_srcChainId, _srcAddress, _nonce, _payload); } else if (packetType == PT_FEED) { ... tokenPrice = price; updatedTime = time; } else if (packetType == PT_SET_ENABLE) { ... enable = flag; } else if (packetType == PT_SET_CAP) { ... cap = _cap; } else { revert(\"unknown packet type\"); } } contracts/AssetsVault.sol#L35-37 function setNewVault(address _vault) external onlyPermit { stoneVault = _vault; } contracts/strategies/RETHHoldingStrategy.sol#L158-164 function setRouter( bool _buyOnDex, bool _sellOnDex ) external onlyGovernance { buyOnDex = _buyOnDex; sellOnDex = _sellOnDex; } contracts/strategies/SFraxETHHoldingStrategy.sol#L151-157 function setRouter( bool _buyOnDex, bool _sellOnDex ) external onlyGovernance { buyOnDex = _buyOnDex; sellOnDex = _sellOnDex; } contracts/strategies/STETHHoldingStrategy.sol#L253-259 function setRouter( bool _buyOnDex, bool _sellOnDex ) external onlyGovernance { buyOnDex = _buyOnDex; sellOnDex = _sellOnDex; } contracts/strategies/Strategy.sol#L89-91 function setBufferTime(uint256 _time) external onlyGovernance { bufferTime = _time; } contracts/strategies/StrategyController.sol#L322-324 function setNewVault(address _vault) external onlyVault { stoneVault = _vault; } contracts/strategies/SwappingAggregator.sol#L396-420 function setUniRouter( address _token, address _uniPool, uint256 _slippage, uint24 _fee ) external onlyGovernance { require(_token != address(0), \"ZERO ADDRESS\"); uniV3Pools[_token] = _uniPool; slippage[_token] = _slippage; fees[_token] = _fee; } function setCurveRouter( address _token, address _curvePool, uint8 _curvePoolType, uint256 _slippage ) external onlyGovernance { require(_token != address(0), \"ZERO ADDRESS\"); curvePools[_token] = _curvePool; curvePoolType[_curvePool] = _curvePoolType; slippage[_token] = _slippage; }",
        "labels": [
            "SlowMist",
            "StakeStone",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Authority transfer enhancement",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - StakeStone_en-us.pdf",
        "body": "The permission transfer method for the core roles(like proposer and governance) does not adopt the pending and access processes. If set incorrectly, the permission of the core roles will be lost. Code Location: contracts/strategies/Strategy.sol#L84-87 function setGovernance(address governance_) external onlyGovernance { emit TransferGovernance(governance, governance_); governance = governance_; } contracts/strategies/SwappingAggregator.sol#L422-426 function setGovernance(address governance_) external onlyGovernance { emit TransferGovernance(governance, governance_); governance = governance_; } contracts/governance/Proposal.sol#L138-142 function setProposer(address _proposer) external onlyProposer { emit SetProposer(proposer, _proposer); proposer = _proposer; }",
        "labels": [
            "SlowMist",
            "StakeStone",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Lack of CrossChain fee checking in the bridgeTo function",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - StakeStone_en-us.pdf",
        "body": "In the DepositBridge contract, there is no check in the bridgeTo function to see if the incoming _gasPaidForCrossChain parameter is greater than or equal to the handling fee required to send across the chain. If passed in too small it may cause the cross-chain operation to fail. Code Location: contracts/mining/DepositBridge.sol#L30-41 function bridgeTo( uint256 _amount, bytes calldata _dstAddress, uint256 _gasPaidForCrossChain ) public payable returns (uint256 stoneMinted) { stoneMinted = bridge( msg.sender, _amount, _dstAddress, _gasPaidForCrossChain ); }",
        "labels": [
            "SlowMist",
            "StakeStone",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Missing check for dstChainId on initialisation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - StakeStone_en-us.pdf",
        "body": "In the DepositBridge contract, the dstChainId is set on initialisation, but there is no check to see if the value set is not equal to the chainId of the current chain, which would cause the sendFrom function in the stone tokens to revert and the cross-chain operation to fail. Code Location: contracts/mining/DepositBridge.sol#L27 constructor(address _stone, address payable _vault, uint16 _dstChainId) { ... dstChainId = _dstChainId; }",
        "labels": [
            "SlowMist",
            "StakeStone",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Lack of scope check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - StakeStone_en-us.pdf",
        "body": "1.In Strategy contracts, the setBuerTime function can be used to set the delay time for strategy operations. However, there is no check on the range of the _time parameter passed in, and if it is too large, the normal operation of the strategy contract will be aected. Code Location: contracts/strategies/Strategy.sol#L89-91 function setBufferTime(uint256 _time) external onlyGovernance { bufferTime = _time; } 2.In SwappingAggregator contracts, the Governance role can set the slips corresponding to dierent tokens and the fees charged by calling the setSlippage function, the setUniRouter function, and the setCurveRouter function. However, there is no range checking of incoming new slippage and fees at the time of setup, which could result in arbitrage or unintended depletion of the user's funds if set too high. Code Location: contracts/strategies/SwappingAggregator.sol#L387-420 function setSlippage( address _token, uint256 _slippage ) external onlyGovernance { emit SetSlippage(_token, slippage[_token], _slippage); slippage[_token] = _slippage; } function setUniRouter( address _token, address _uniPool, uint256 _slippage, uint24 _fee ) external onlyGovernance { require(_token != address(0), \"ZERO ADDRESS\"); uniV3Pools[_token] = _uniPool; slippage[_token] = _slippage; fees[_token] = _fee; } function setCurveRouter( address _token, address _curvePool, uint8 _curvePoolType, uint256 _slippage ) external onlyGovernance { require(_token != address(0), \"ZERO ADDRESS\"); curvePools[_token] = _curvePool; curvePoolType[_curvePool] = _curvePoolType; slippage[_token] = _slippage; }",
        "labels": [
            "SlowMist",
            "StakeStone",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Potential governance attacks",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - StakeStone_en-us.pdf",
        "body": "In a Proposal contract, users can call the voteFor function to transfer their holdings of stone tokens into that contract and vote on a specied proposal. However, if the Proposer role is evil (e.g. in the case of lost permissions), it is possible to call the instantWithdraw function or requestWithdraw function in the Stone Vault contract by submitting a proposal and transferring a large number of stone tokens towards the end of the vote to ensure that the proposal passes. After the proposal is executed, it will consume other users' stone tokens and make additional prot (enough to cover the cost of the attack). Code Location: contracts/governance/Proposal.sol#L76-96 function voteFor(address _proposal, uint256 _poll, bool _flag) external { require(canVote(_proposal), \"cannot vote\"); TransferHelper.safeTransferFrom( stoneToken, msg.sender, address(this), _poll ); ... }",
        "labels": [
            "SlowMist",
            "StakeStone",
            "Type: Design Logic Audit",
            "Severity: Information"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - StakeStone_en-us.pdf",
        "body": "1.In SwappingAggregator contracts, the Governance role can set the slips, the exchange router and the fee corresponding to dierent tokens by calling the setSlippage function, the setUniRouter function, and the setCurveRouter function. If the privilege is lost or misused, this may have an impact on the user's assets. Code Location: contracts/strategies/SwappingAggregator.sol#L387-420 function setSlippage( address _token, uint256 _slippage ) external onlyGovernance { emit SetSlippage(_token, slippage[_token], _slippage); slippage[_token] = _slippage; } function setUniRouter( address _token, address _uniPool, uint256 _slippage, uint24 _fee ) external onlyGovernance { require(_token != address(0), \"ZERO ADDRESS\"); uniV3Pools[_token] = _uniPool; slippage[_token] = _slippage; fees[_token] = _fee; } function setCurveRouter( address _token, address _curvePool, uint8 _curvePoolType, uint256 _slippage ) external onlyGovernance { require(_token != address(0), \"ZERO ADDRESS\"); curvePools[_token] = _curvePool; curvePoolType[_curvePool] = _curvePoolType; slippage[_token] = _slippage; } 2.In Proposal contracts, the Proposer role can initiate a proposal by calling the propose function. If the privilege is lost or misused, the Proposer role may launch a malicious proposal causing the user to suer a loss of funds. Code Location: contracts/governance/Proposal.sol#L57-74 function propose(bytes calldata _data) external onlyProposer { ... }",
        "labels": [
            "SlowMist",
            "StakeStone",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Missing return value check when adding strategies",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - StakeStone_en-us.pdf",
        "body": "In StrategyController contracts, the type of data structure used for strategy storage is the EnumerableSet library from openzeppelin. When using the .add() function, it will return false if the added data already exists and will not add the data repeatedly. However, the StrategyController contract does not check the return value of the .add() function when adding or setting a strategy, which may result in strategies not being added but ratios being changed. Code Location: contracts/strategies/StrategyController.sol function _initStrategies( address[] memory _strategies, uint256[] memory _ratios ) internal { ... for (uint i; i < length; i++) { strategies.add(_strategies[i]); ratios[_strategies[i]] = _ratios[i]; totalRatio = totalRatio + _ratios[i]; } require(totalRatio <= ONE_HUNDRED_PERCENT, \"exceed 100%\"); } function _setStrategies( address[] memory _strategies, uint256[] memory _ratios ) internal { ... for (uint i; i < length; i++) { ... strategies.add(_strategies[i]); ratios[_strategies[i]] = _ratios[i]; totalRatio = totalRatio + _ratios[i]; } require(totalRatio <= ONE_HUNDRED_PERCENT, \"exceed 100%\"); }",
        "labels": [
            "SlowMist",
            "StakeStone",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Synclub_en-us.pdf",
        "body": "1.In the SnBnb contract, the DEFAULT_ADMIN_ROLE can set the stakeManager contract as the StakeManager role and the StakeManager role can call the mint and burn functions to mint tokens arbitrarily and burn any users tokens. ",
        "labels": [
            "SlowMist",
            "Synclub",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "The mint amount can be 0 in the deposit function",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Synclub_en-us.pdf",
        "body": "In the SnStakeManager contract, users deposit their BNB into this contract and obtain the SnBNB as the staking certicate. And the calculation of the snBnbToMint is dependent on the convertBnbToSnBnb function, the totalSupply of the SnBNB, and the totalPooledBnb in this contract. If the deposit amount of the BNB is small enough or the totalPooledBnb is big enough, the calculation of the snBnbToMint can be 0. But the amount of the BNB can still add to the amountToDelegate to cause the increment of the totalPooledBnb. ",
        "labels": [
            "SlowMist",
            "Synclub",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "The BNB can be remained in the contract",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Synclub_en-us.pdf",
        "body": "In the SnStakeManager contract when users claim to withdraw their BNB tokens in the claimWithdraw in the same uuid, the calculation of the amount = (totalBnbToWithdraw_ * amountInSnBnb) / totalSnBnbToBurn_; has the rounding to obtain one of the users withdrawal amount. It will cause the rounded amount of the BNB to remain in this contract and can not be withdrawn. ",
        "labels": [
            "SlowMist",
            "Synclub",
            "Type: Arithmetic Accuracy Deviation Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "The business logic is unclear",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Synclub_en-us.pdf",
        "body": "In the SnStakeManager contract, the claimUndelegated function calculates the claimUndelegated withdrawal value in one uuid and assigns it to two temporary variables. The two temporary variables are just for recording and have no other usage. ",
        "labels": [
            "SlowMist",
            "Synclub",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing the validator check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Synclub_en-us.pdf",
        "body": "In the SnStakeManager contract, the Manager role can change the Validator through the redelegate function, and this check is done by the NATIVE_STAKING contract, and if the call of the redelegate function failed, it will consume the gas of this call. ",
        "labels": [
            "SlowMist",
            "Synclub",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing the event records",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Synclub_en-us.pdf",
        "body": "There are no event logs of the claimUndelegated and claimFailedDelegation in this SnStakeManager contract. ",
        "labels": [
            "SlowMist",
            "Synclub",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Preemptive initialization",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Synclub_en-us.pdf",
        "body": "By calling the initialize function to initialize the contracts, there is a potential issue that malicious attackers preemptively call the initialize function to initialize. ",
        "labels": [
            "SlowMist",
            "Synclub",
            "Type: Race Conditions Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Dev address setting enhancement suggestions",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Synclub_en-us.pdf",
        "body": "In the SnStakeManager contract, the GOVERNANCE_ROLE role can set the revenuePool address to receive the fee. If the address is an EOA address, in a scenario where the private keys are leaked, the teams revenue will be stolen. ",
        "labels": [
            "SlowMist",
            "Synclub",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Business logic error Payable Payable Can Modify State - Can Modify State Can Modify State Can Modify State - - - - - - - 13",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ioTube_en-us.pdf",
        "body": "When originalAssetByID gets the data of originalAssets, the _assetID passed in should be reduced by 1, and then readout. activateAsset, deactivateAsset function directly passes in _assetID, and then read originalAssets[_assetID], The judgment is _assetID <= originalAssets.length . There are two issues here: 1. When _assetID == originalAssets.length, originalAssets[_assetID] cannot read data. 2. The originalAssets data obtained here is not obtained using the originalAssetByID function, and the business logic needs to be conrmed. contracts/AssetRegistry.sol#L101-L133 function activateAsset(uint256 _assetID, uint256 _tubeID) public onlyOperator { require(_assetID > 0 && _assetID <= originalAssets.length, \"invalid asset id\"); Asset storage oa = originalAssets[_assetID]; if (_tubeID == 0 || oa.tubeID == _tubeID) { if (oa.active == false) { oa.active = true; emit AssetActivated(_assetID, oa.tubeID); } } else { Asset storage sa = shadowAssets[_assetID][_tubeID]; if (sa.asset != address(0) && sa.active == false) { sa.active = true; emit AssetActivated(_assetID, _tubeID); } } } function deactivateAsset(uint256 _assetID, uint256 _tubeID) public onlyOperator { require(_assetID > 0 && _assetID <= originalAssets.length, \"invalid asset id\"); Asset storage oa = originalAssets[_assetID]; if (_tubeID == 0 || oa.tubeID == _tubeID) { if (oa.active == true) { oa.active = false; 14 emit AssetDeactivated(_assetID, oa.tubeID); } } else { Asset storage sa = shadowAssets[_assetID][_tubeID]; if (sa.asset != address(0) && sa.active == true) { sa.active = false; emit AssetDeactivated(_assetID, _tubeID); } } } originalAssetIDs[_tubeID][_asset] = id; The record is originalAssets.length;, so to take the value of originalAssets, the index should be originalAssetIDs[_tubeID][_asset]-1, combined with the processing logic here, you need to conrm the issues with the developer. contracts/AssetRegistry.sol#L74-L84 function addOriginalAsset(uint256 _tubeID, address _asset) public onlyOperator returns (uint256) { require(_tubeID > 0 && _asset != address(0), \"invalid parameter\"); uint256 id = assetID(_tubeID, _asset); if (id == 0) { originalAssets.push(Asset(_tubeID, _asset, true)); id = originalAssets.length; originalAssetIDs[_tubeID][_asset] = id; emit NewOriginalAsset(_tubeID, _asset, id); } return id; }",
        "labels": [
            "SlowMist",
            "ioTube",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Authority transfer enhancement",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ioTube_en-us.pdf",
        "body": "There is no pending and accept mechanism for authority transfer to avoid loss of authority contracts/CrosschainERC20.sol#L34-L37 function transferMintership(address _newMinter) public onlyMinter { minter = _newMinter; 16 emit MinterSet(_newMinter); } contracts/CrosschainERC721.sol#L29-L32 function transferMintership(address _newMinter) public onlyMinter { minter = _newMinter; emit MinterSet(_newMinter); }",
        "labels": [
            "SlowMist",
            "ioTube",
            "Type: Authority Control Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "unsafe external call risk",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ioTube_en-us.pdf",
        "body": "The withdraw function in the contract code does not check the whitelist of _recipient and _data. There is an unsafe external call (success,) = _recipient.call(_data); . The attacker can use _recipient.call(_data); to call any function of the lord contract, or transfer the token approved by the user to the Tube contract. contracts/Tube.sol#L179-L207 function withdraw( uint256 _srcTubeID, uint256 _txIdx, address _token, address _recipient, uint256 _amount, bytes memory _data, bytes memory _signatures ) public whenNotPaused { require(_amount != 0, \"amount is 0\"); 17 require(_recipient != address(0), \"invalid recipient\"); require(_signatures.length % 65 == 0, \"invalid signature length\"); bytes32 key = genKey(_srcTubeID, _txIdx, _token, _recipient, _amount, _data); ledger.record(key); (bool isValid, address[] memory signers) = verifier.verify(key, _signatures); require(isValid, \"insufficient validators\"); bool success = true; if (_data.length > 0) { lord.mint(_token, address(this), _amount); IERC20(_token).safeApprove(_recipient, _amount); (success, ) = _recipient.call(_data); if (!success) { IERC20(_token).safeDecreaseAllowance(_recipient, _amount); } } else { lord.mint(_token, _recipient, _amount); } emit Settled(key, signers, success); }",
        "labels": [
            "SlowMist",
            "ioTube",
            "Type: Unsafe External Call Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Excessive authority issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ioTube_en-us.pdf",
        "body": "The Owner of the Tube contract has too much authority. The owner of the Lord contract can be changed, and the owner of the Lord contract can execute mint and burn arbitrarily. This will aect the users assets. contracts/Tube.sol#L71-L78 function upgrade(address _newTube) public onlyOwner { if (ledger.owner() == address(this)) { ledger.transferOwnership(_newTube); } 18 if (lord.owner() == address(this)) { lord.transferOwnership(_newTube); } } contracts/Lord.sol#L94-L131 function burn( address _token, address _sender, uint256 _amount ) public onlyOwner { if (address(standardTokenList) != address(0) && standardTokenList.isAllowed(_token)) { // transfer token to standardTokenList _callOptionalReturn( _token, abi.encodeWithSelector(IToken(_token).transferFrom.selector, _sender, tokenSafe, _amount) ); return; } if (address(proxyTokenList) != address(0) && proxyTokenList.isAllowed(_token)) { _callOptionalReturn( _token, abi.encodeWithSelector(IToken(_token).transferFrom.selector, _sender, address(this), _amount) ); _callOptionalReturn(_token, abi.encodeWithSelector(IToken(_token).burn.selector, _amount)); return; } _callOptionalReturn(_token, abi.encodeWithSelector(IToken(_token).burnFrom.selector, _sender, _amount)); } function mint( address _token, address _recipient, uint256 _amount ) public onlyOwner { if (address(standardTokenList) != address(0) && 19 standardTokenList.isAllowed(_token)) { require(tokenSafe.mint(_token, _recipient, _amount), \"token safe mint failed\"); return; } if (address(proxyTokenList) != address(0) && proxyTokenList.isAllowed(_token)) { require(minterPool.mint(_token, _recipient, _amount), \"proxy token mint failed\"); } _callOptionalReturn(_token, abi.encodeWithSelector(IToken(_token).mint.selector, _recipient, _amount)); } function mintNFT( address _token, uint256 _tokenID, address _recipient, bytes memory _data ) public onlyOwner { IERC721Mintable(_token).safeMint(_recipient, _tokenID, _data); } function upgrade(address _newLord) public onlyOwner { if (minterPool.owner() == address(this)) { _callOptionalReturn( address(tokenSafe), abi.encodeWithSelector(minterPool.transferOwnership.selector, _newLord) ); } if (tokenSafe.owner() == address(this)) { _callOptionalReturn( address(tokenSafe), abi.encodeWithSelector(tokenSafe.transferOwnership.selector, _newLord) ); } }",
        "labels": [
            "SlowMist",
            "ioTube",
            "Type: Authority Control Vulnerability",
            "Severity: High"
        ]
    },
    {
        "title": "Business logic aws",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ioTube_en-us.pdf",
        "body": "The swapCoinForCrosschainCoin function will call cerc20.depositTo. contracts/CrosschainCoinRouter.sol#L37-L40 function swapCoinForCrosschainCoin(uint256 _amount) public payable { wrappedCoin.deposit{value: _amount}(); cerc20.depositTo(msg.sender, _amount); } cerc20.depositTo will call safeTransferFrom, where msg.sender is the CrosschainCoinRouter contract, but CrosschainCoinRouter has authorized CrosschainERC20 contract operation assets. contracts/CrosschainERC20.sol#L43-L47 function depositTo(address _to, uint256 _amount) public { require(address(coToken) != address(0), \"no co-token\"); coToken.safeTransferFrom(msg.sender, address(this), _amount); _mint(_to, _amount); } Although the allowance is set to -1, under extreme conditions, the continuous consumption quota will still be reduced to no quota. At this time, the contract cannot be used without re-approve. contracts/CrosschainCoinRouter.sol#L20-L25 constructor(CrosschainERC20 _cerc20) public { ERC20 ct = _cerc20.coToken(); cerc20 = _cerc20; ct.safeApprove(address(cerc20), uint256(-1)); 21 wrappedCoin = WrappedCoin(address(ct)); }",
        "labels": [
            "SlowMist",
            "ioTube",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Excessive authority issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ioTube_en-us.pdf",
        "body": "Owner can set the relayfee arbitrarily, and there is no limit on the value range. When the relayfee is set to a large value, most of the user's funds will be used to pay the relayFees. contracts/TubeRouter.sol#L49-L55 function setRelayFee(uint256 _tubeID, uint256 _fee) public onlyOwner { if (_fee == 0) { relayFees[_tubeID].exists = false; } else { relayFees[_tubeID] = RelayFee(_fee, true); } }",
        "labels": [
            "SlowMist",
            "ioTube",
            "Type: Authority Control Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Coding optimization",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ioTube_en-us.pdf",
        "body": "22 Owner can withdraw ETH and token in the contract. There are relayFees in the TubeRouter contract, and the Owner can withdraw the relayFees through the withdrawToken function, However, withdrawCoin and withdrawToken are used to extract the assets that were unexpectedly credited into the contract. contracts/TubeRouter.sol#L97-L106 function withdrawCoin(address payable _to) external onlyOwner { _to.transfer(address(this).balance); } function withdrawToken(address _to, IERC20 _token) external onlyOwner { uint256 balance = _token.balanceOf(address(this)); if (balance > 0) { _token.safeTransfer(_to, balance); } } contracts/Tube.sol#L229-L238 function withdrawCoin(address payable _to) external onlyOwner { _to.transfer(address(this).balance); } function withdrawToken(address _to, IERC20 _token) external onlyOwner { uint256 balance = _token.balanceOf(address(this)); if (balance > 0) { _token.safeTransfer(_to, balance); } }",
        "labels": [
            "SlowMist",
            "ioTube",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Other safety reminders",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ioTube_en-us.pdf",
        "body": "Note that when signing, make sure that the K value is not the same in the signature implementation. In the elliptic curve signature algorithm, if the random number is not safe enough and the same K value random number is used, there will be two transactions with the same R value. , So that the private key can be calculated, please pay attention to investigate similar cryptographic implementations. Reference: https://panzhibiao.com/2019/03/13/important-random-k-and-fake-signatures/ To capture events in the cross-chain bridge, the implementation of subscribing to the events of the specied contract should be adopted to avoid the attacks of fake contract events",
        "labels": [
            "SlowMist",
            "ioTube",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Recommendations for Parameter Declarations - - - - - - - - - - - - - - - - - - -",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase4 - SlowMist Audit Report.pdf",
        "body": "In the DTBT contract, the _name and _symbol parameters are hardcoded with xed values, but they are not declared as constants, which will result in additional gas consumption. The same is true for stableCoinReceiver , sTBTReceiver , stbt , stableCoin parameters in the TBillSimple contract. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase4 - SlowMist Audit Report",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Invalid function return value",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase4 - SlowMist Audit Report.pdf",
        "body": "In the DTBT contract, the owner role can modify the decimals of the contract through the updateDecimals function. This function denes the return value, but it does not return any value. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase4 - SlowMist Audit Report",
            "Type: Others",
            "Severity: Low"
        ]
    },
    {
        "title": "The transfer return value that does not conform to the EIP20 interface standard",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase4 - SlowMist Audit Report.pdf",
        "body": "In the DTBT contract, users can transfer DTBT tokens through the transferFrom function. However, the implementation of this function does not comply with the return value standard specied in EIP20. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase4 - SlowMist Audit Report",
            "Type: Others",
            "Severity: Low"
        ]
    },
    {
        "title": "Redundant Period enum",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase4 - SlowMist Audit Report.pdf",
        "body": "The Period enum is dened in the TBillSimple contract, but it is not used in the contract. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase4 - SlowMist Audit Report",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing error message",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase4 - SlowMist Audit Report.pdf",
        "body": "In the DTBT contract, the add/sub function users add and subtract mathematically. It will perform overow checks through require , but no error message will be thrown when the check fails, which will prevent users from intuitively obtaining the cause of the error. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase4 - SlowMist Audit Report",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Hardcoded testnet address issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase4 - SlowMist Audit Report.pdf",
        "body": "In the TBillSimple contract, the parameters of stableCoinReceiver, sTBTReceiver, stbt, and stableCoin are all hardcoded with the address of the Goerli testnet. If the hard-coded address is not modied when the protocol is launched on the mainnet, the protocol will not work properly. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase4 - SlowMist Audit Report",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "collectEndTime is not checked",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase4 - SlowMist Audit Report.pdf",
        "body": "In the TBillSimple contract, managers can buy/sell STBT through the swap function. It checks whether the current time is less than the closing end time of the ETF, but does not check whether the current time is greater than the fundraising end time of the ETF. Although it will check whether the isCompletedCollect status of the ETF is true through _checkTx , users can still add liquidity to the ETF at this time. If the swap operation is performed at this time, the stableCoin will be unbound, and users will not be able to add liquidity during the fundraising period, which is inconsistent with the design expectation. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase4 - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Missing 0 balance check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase4 - SlowMist Audit Report.pdf",
        "body": "In the TBillSimple contract, managers can synchronize the stableCoin position data in bPool through the rebalance function. But it does not check whether the stableCoin balance in bPool is greater than 0, and if the balance is 0, the rebind operation is meaningless. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase4 - SlowMist Audit Report",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Decimal conversion causes data mismatch",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase4 - SlowMist Audit Report.pdf",
        "body": "In the TBillSimple contract, managers can buy/sell STBT through the swap function. It will adjust the ETF position through _sendStableCoin and _sendSTBT functions respectively, and use _decimalsHandle function to perform decimal conversion between stableCoin and stbt tokens. However, due to the fact that solidity will truncate decimals when performing division operations, there will be some precision loss when converting large decimals to small decimals. This will cause the calculation result of _decimalsHandle to be smaller than the actual amount of tokens received by the ETF, causing the Record data of the ETF to be inconsistent with the actual balance. In fact, the rebalance function in the TBillSimple contract can alleviate the problem of the mismatch between the stableCoin balance and Record data, but the contract does not implement the rebalance operation for STBT tokens. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase4 - SlowMist Audit Report",
            "Type: Arithmetic Accuracy Deviation Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Incorrect DTBT amount update",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase4 - SlowMist Audit Report.pdf",
        "body": "In the TBillSimple contract, it uses DTBT instead of STBT for timely accounting operations. When ETF sells STBT, it will burn the balance of DTBT tokens in bPool and unbond them, but it does update the DTBT with the same balance through _updateDtbtAmount function by mistake, which will make the amount of DTBT tokens in bPool not decrease , which is not as expected by design. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase4 - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Invalid execution result capture",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase4 - SlowMist Audit Report.pdf",
        "body": "In the TBillSimple contract, the _invokeUnbind function is used to unbind the specied token in the ETF. It captures the result of the operation through try-catch , but does not process the result of the operation in the catch. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase4 - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Typo issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase4 - SlowMist Audit Report.pdf",
        "body": "In the smart join/exit pool function of the Actions contract, it will receive the handleToken parameter to specify the source token or target token of the token swap. But it is wrong to write this parameter as handleToekn. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase4 - SlowMist Audit Report",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "The length of minAmountsOut is not checked",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase4 - SlowMist Audit Report.pdf",
        "body": "In the Actions contract, the autoExitSmartPool function user removes the user's liquidity and converts the obtained tokens into the specied tokens, and performs a slippage check through the minAmountsOut parameter passed in by the user. However, the function does not check whether the length of the minAmountsOut list is the same as the length of the tokens. If the length of the incoming list is shorter than the expected length, the transaction may fail and waste gas. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase4 - SlowMist Audit Report",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Redundant approval operation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase4 - SlowMist Audit Report.pdf",
        "body": "In the Actions contract, the autoExitSmartPool function user removes user liquidity and converts the obtained tokens into specied tokens. It will rst approve the pool tokens in this contract to the contract itself, and then perform _exit operation. But the self-approval operation is meaningless. If the contract needs to transfer tokens, it can be transferred directly through transfer without approval, which is a waste of gas. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase4 - SlowMist Audit Report",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "The validity of the aggregator is not checked",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase4 - SlowMist Audit Report.pdf",
        "body": "In the Actions contract, the smart join/exit pool mode will help users exchange tokens through the _makeSwap function. It performs token exchange operations by calling the aggregator address specied by the user. It stipulates that the aggregator is composed of UNISWAPV2, UNISWAPV3, and ONEINCH through the SwapType enumeration, but in fact, the contract does not check whether the aggregator called by the user is a real and valid address. If the user is phished or the wrong address is passed in, it will result in a loss of funds or use the Actions contract to perform sensitive operations on the ETF. For example: when performing the swap through ONEINCH, it will not check the address of the caller and can pass in any call data. This allows the attacker to perform operations such as setController, approveUnderlying, addTokenToWhitelist, etc. on the pool when the user is phished. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase4 - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Pancakeswap-CakePool_en-us.pdf",
        "body": "In the cakePool contract, the owner role can set the DURATION_FACTOR and DURATION_FACTOR_OVERDUE by 7 calling the setDurationFactor and setDurationFactorOverdue. If these values are set too large or too small, this may aect the calculation of user.shares when calling the deposit and withdraw function. ",
        "labels": [
            "SlowMist",
            "Pancakeswap-CakePool",
            "Type: Authority Control Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Missing event records",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Pancakeswap-CakePool_en-us.pdf",
        "body": "In the cakePool contract, the owner role can set admin, treasury, operator, boostContract, freeFeeUsers, performanceFee, performanceFeeContract, withdrawFee, withdrawFeeContract, withdrawFeePeriod, MAX_LOCK_DURATION, DURATION_FACTOR, DURATION_FACTOR_OVERDUE, UNLOCK_FREE_DURATION and 8 BOOST_WEIGHT by calling the setAdmin, setTreasury, setOperator, setBoostContract, setFreeFeeUser, setPerformanceFee, setPerformanceFeeContract, setWithdrawFee, setWithdrawFeeContract, setWithdrawFeePeriod, setMaxLockDuration, setDurationFactor, setDurationFactorOverdue, setUnlockFreeDuration and setBoostWeight. but there no event logging is preformed. ",
        "labels": [
            "SlowMist",
            "Pancakeswap-CakePool",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Redundant collectEndTime check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report.pdf",
        "body": "In the CongurableRightsPool contract, users can redeem underlying assets through the exitPool function. When the pool is a closed ETF, it will check isCompletedCollect and collectEndTime to decide whether to perform _claimManagerFee operation. But when isCompletedCollect is true, the collectEndTime check will be performed in snapshotEndAssets, and when isCompletedCollect is false, the collectEndTime check will be performed in exitPoolHandleB. Hence the collectEndTime check before the _claimManagerFee operation is redundant. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Redundant closureEndTime check on exitPool",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report.pdf",
        "body": "In the CongurableRightsPool contract, users can redeem underlying assets through the exitPool function. When the pool is a closed ETF and isCloseEtfCollectEndWithFailure is false, it will check that the current time must be greater than closureEndTime + 5 minutes before allowing the user to exit. However, it should be noted that the snapshotEndAssets operation will be performed before this. The snapshotEndAssets function will also check whether the current time is greater than closureEndTime + 5 minutes . Only the admin and owner can execute snapshotEndAssets within 5 minutes after the closure period ends. Otherwise, the transaction will be reverted. Therefore, the closureEndTime check in the exitPool function is redundant. When snapshotEndAssets cannot be performed, the entire transaction will be reverted, and subsequent closureEndTime checks will not be performed. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Redundant performance fee calculation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report.pdf",
        "body": "In the exitPool function of the CongurableRightsPool contract, redeemAndPerformanceFeeReceived, nalAmountOut and redeemFeeReceived are calculated through exitPoolHandleA. However, since the performance fee will be calculated uniformly in the snapshotEndAssets operation, there is no need to process the performance fee in the exitPool function. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "The time allowed for snapshots is too short",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report.pdf",
        "body": "In the CongurableRightsPool contract when the closed ETF completes collect and the collection period has ended, the current total value of the ETF can be recorded through the snapshotBeginAssets function. However, users can only call the snapshotBeginAssets function within 15 minutes after the end of the collection period. If there is congestion on the chain, it may not be possible to call the snapshot in time within 15 minutes. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Duplicate decimal processing issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report.pdf",
        "body": "In the DesynChainlinkOracle contract, the getPrice function is used to obtain the corresponding token price from prices, getChainlinkPrice, and getUniswapPrice, and perform decimal processing. However, decimal has been processed in getChainlinkPrice and getUniswapPrice, and theoretically, the returned decimal will be 1e18. Therefore, processing decimals through decimalDelta will cause decimals to be enlarged. Note that the amountIn passed in for the consult in the getUniswapPrice function is 1e18, which needs to be ensured that the token decimal in twapOracle matches it in practice ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Decimal processing issue in AllPrice calculation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report.pdf",
        "body": "In the DesynChainlinkOracle contract, the getAllPrice function is used to calculate the total value of the specied amount of tokens. It is calculated by badd(fundAll, bmul(getPrice(t), tokenAmountOut)) , theoretically the decimal returned by getPrice is 1e18, and the decimal of tokenAmountOut is consistent with the decimal of the token itself. Therefore, multiplying these two values will result in a very large decimal in the nal result. The getNormalizedWeight function is also aected by this, but this is not harmful to normal business. Note: ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Redundant code issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report.pdf",
        "body": "In the SmartPoolManager library, the exitPoolHandle function has been deprecated since closed ETF prots are calculated in snapshotEndAssets. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Token list conict in recordTokenInfo",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report.pdf",
        "body": "When the user performs createPool and joinPool, if the Pool is a closed ETF and the current time is within the collection period, the KOL invitation amount will be recorded through UserVault's recordTokenInfo interface. But unfortunately, the tokens in the Pool can be Bind/unBind at any time, which will cause the list of tokens supported by the Pool to change. If the recordTokenInfo operation is performed when the Pool token list changes, the amount recorded by variables such as poolInviteTotal, kolTotalAmountList, and kolUserInfo may be disturbed. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "couldManagerClaim not checked when managerClaim",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report.pdf",
        "body": "In the UserVault contract, the Manager role can claim management fees through the managerClaim function, but it does not check whether the couldManagerClaim parameter is true. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Some redundant invoke functions",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report.pdf",
        "body": "In the Invoke library, the strictInvokeTransfer, invokeUnwrapWETH, invokeWrapWETH, and invokeMint functions are not used. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of ETF falsication",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report.pdf",
        "body": "In the RebalanceAdapter contract, the Manager role can adjust the position of the pool through the rebalance function. But the address of the ETF is obtained from the rebalanceInfo passed in by the user. If a malicious user passes in a fake ETF, the check in the onlyManager decorator will be bypassed, and the _verifyWhiteToken check of token1 and the isCompletedCollect and collectEndTime checks will be useless. Malicious users can steal bPool funds through _makeSwap and bind malicious tokens. The approve function also has this risk, but it doesn't break the protocol too much ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Risk of the Manager role potentially disrupting the protocol",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report.pdf",
        "body": "In the RebalanceAdapter contract, the Manager role can adjust the position of the ETF through the rebalance function. It will use the _makeSwap function to call Uniswap, 1inch and other DEXs for token swaps to adjust token positions. But unfortunately, the swap path of the token is not checked during the token swap process, which will cause the Manager role to pass in a carefully constructed malicious swap path to steal the middle token0 of the ETF. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Double slippage check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report.pdf",
        "body": "In the RebalanceAdapter contract, the Manager role can adjust the position of the ETF through the rebalance function. It will use the _makeSwap function to call Uniswap, 1inch and other DEXs for token swaps to adjust token positions. During the swap process, the slippage will be checked by passing minReturn to the external DEXs, but the implementation of the slippage check of the external DEXs is uncontrollable. If the slippage protection of the external DEXs fails, it will aect the funds of users in the protocol. (1inch users encountered invalid slippage check before) ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Does not follow the Checks-Eects-Interactions specication",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report.pdf",
        "body": "In the RebalanceAdapter contract, the _makeSwap function is used for token swap. When the swap type is not UNISWAPV3 and UNISWAPV2, the parameters passed in by the user will be checked through _validateData . However, the execute operation is performed rst, and the _validateData operation is performed after the token exchange is completed. This is not in line with the follow the Checks-Effects-Interactions principle. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Perform strict parameter checking",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report.pdf",
        "body": "In the RebalanceAdapter contract, the _validateData function is used to check the exchange parameters, but it only parses the recipient and amountIn for checking, but does not check whether other key parameters such as srcToken, dstToken, clipperExchange, makerAsset, takerAsset are in line with expectations. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Redundant aggregator parameter",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report.pdf",
        "body": "In the RebalanceAdapter contract, the _validateData function is used to check the conversion parameters, but the aggregator parameter it receives is not used. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Incorrect approval operation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report.pdf",
        "body": "In the RebalanceAdapter contract, the Manager role can adjust the position of the ETF through the rebalance function. If token1 has not been bound in bPool, it will be approved rst. However, the subsidy of this contract was wrongly approved to bPool, which will cause bPool to be unable to transfer tokens from CRP in the future. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report.pdf",
        "body": "There is an execute function in the CRP and bPool contracts so that the Manager can manage the ETF. In bFactory, the Blabs role can arbitrarily register modules to gain control over CRP. The registered modules can use the execute function in CRP to call the execute function in bPool to perform any operations. This would pose a huge risk to users' funds. And the Manager can approve the tokens in the bPool through the approve function of the RebalanceAdapter contract, which will also bring huge risks to the user's funds. The above problems lead to the risk of excessive permissions of the Blabs role and the Manager role. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Authority Control Vulnerability Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Enforce strict permission controls",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report.pdf",
        "body": "In the LiquidityPool contract, any user can call the joinPool, exitPool, and gulp functions to add/remove liquidity/record token balances, which will make it impossible to charge various fees to users in CRP. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Index conict issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm_Phase6_en-us.pdf",
        "body": "In the MIM strategy of ENF_V3, the getPID function is used to obtain the pool id of the specied LP token in ConvexBooster. Returns the current index if the match is successful, otherwise returns the 0 index. However, there is a corresponding LP (Curve. cDAI/cUSDC) conguration for the 0 index in ConvexBooster, which will make it impossible for the caller to determine whether the return of the 0 index is due to a matching failure or LP tokens in the 0 pool of ConvexBooster. ",
        "labels": [
            "SlowMist",
            "Earning.Farm_Phase6",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Visibility issue with getPID function",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm_Phase6_en-us.pdf",
        "body": "There is a getPID function with public visibility in the MIM strategy of ENF_V3, but this function is not called by other functions in this contract, so using public visibility will consume more gas than external visibility. ",
        "labels": [
            "SlowMist",
            "Earning.Farm_Phase6",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Read-only reentrancy checks subject to rounding errors",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm_Phase6_en-us.pdf",
        "body": "In the StETH contract in ENF_ETH_Lowrisk, the remove_liquidity_one_coin function will be called during the deposit and withdraw operations to avoid virtual price manipulation. However, the remove_liquidity_one_coin operation does not always succeed due to rounding errors in the calculation of _get_y_D . ",
        "labels": [
            "SlowMist",
            "Earning.Farm_Phase6",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Slippage check issue when Vault gets totalAssets",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm_Phase6_en-us.pdf",
        "body": "In the Vault contract of ENF_ETH_Lowrisk, the totalAssets function is used to obtain the total assets held by the protocol, which will be counted by calling the totalAssets function of each SS contract. In the FrxETH strategy, in order to ensure that the amount of totalAssets obtained has not been manipulated, a slippage check will be performed according to the fetch ag. Fetch is passed as true in the Vault contract, which will ignore the slippage check. ",
        "labels": [
            "SlowMist",
            "Earning.Farm_Phase6",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Logic optimization",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm_Phase6_en-us.pdf",
        "body": "In the FrxETH contract of ENF_ETH_Lowrisk, there are some functions to convert between share and asset through the totalSupply and totalAssets values of sFrx. However, these interfaces have been provided in the sFrx contract, and the calculated decimal is more accurate. Here is some alternative logic: The frxBal calculation in _totalAssets function can be done by ISfrx(sFrx).convertToAssets(sFrxBal) The lastEarnPrice calculation in _deposit function can be done by ISfrx(sFrx).pricePerShare() The currentPrice calculation in harvest function can be done by ISfrx(sFrx).pricePerShare() ",
        "labels": [
            "SlowMist",
            "Earning.Farm_Phase6",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Swap optimization from ETH to FrxETH",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm_Phase6_en-us.pdf",
        "body": "In the FrxETH contract of ENF_ETH_Lowrisk, the _deposit function will select the optimal exchange path according to the price of CurvePool. When the amount exchanged by CurvePool is greater than or equal to _amount (curveExpect >= _amount), it will exchange tokens through CurvePool . If curveExpect == _amount , converting through CurvePool may consume more gas than minting through frxMinter. ",
        "labels": [
            "SlowMist",
            "Earning.Farm_Phase6",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Redundant code",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Yield V1.0.0_en-us.pdf",
        "body": "Ether is not accepted by default, which is a redundant code. cross-send/contracts/CrossSend.sol#L41-L47 initial-hotcross-oering/contracts/BaseIHO.sol#L67-L73 fallback () external payable { revert(\"cannot directly accept currency transfers\"); } receive () external payable { revert(\"cannot directly receive currency transfers\"); 15 }",
        "labels": [
            "SlowMist",
            "Cross Yield V1.0.0",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Gas optimization",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Yield V1.0.0_en-us.pdf",
        "body": "If one of the batch transfers fails, the transaction that was previously transferred normally will be reverted, but Gas has been consumed. It is a gas optimization issue here. cross-send/contracts/CrossSend.sol#L175-L210 function sendToken( IERC20 token, address[] memory recipients, uint256[] memory amounts ) private returns(uint256) { uint256 total = 0; for (uint256 i = 0; i < recipients.length ; i++) { require(_msgSender() != recipients[i], \"sender != recipient\"); token.safeTransferFrom(_msgSender(), recipients[i], amounts[i]); total += amounts[i]; } return total; } function sendNative( address[] memory recipients, uint256[] memory amounts ) private returns(uint256) { uint256 total = 0; 16 for (uint256 i = 0; i < recipients.length ; i++) { total += amounts[i]; (bool success, ) = payable(recipients[i]).call{value: amounts[i]}(\"\"); require(success, \"native transfer failed\"); } return total; }",
        "labels": [
            "SlowMist",
            "Cross Yield V1.0.0",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of allowance amount abuse",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Yield V1.0.0_en-us.pdf",
        "body": "There have an allowance amount in the contract, but the distributeTokenFee function does not limit the caller, and there is an issue of being called arbitrarily, but it can only transfer the balance of the sender to the feeCollector. cross-send/contracts/fee-managers/RecipientCountFee.sol#L65-L83 function distributeTokenFee( uint256 txRecipientCount, uint256, uint256, uint256, uint256, address sender ) public override { uint256 payableFee = txRecipientCount * tokenFeePerRecipient; 17 if(payableFee < minTokenFee) { payableFee = minTokenFee; } else if (payableFee > maxTokenFee) { payableFee = maxTokenFee; } token.safeTransferFrom(sender, feeCollector, payableFee); }",
        "labels": [
            "SlowMist",
            "Cross Yield V1.0.0",
            "Type: Authority Control Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Price manipulation issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Yield V1.0.0_en-us.pdf",
        "body": "The IOUPrice is calculated using totalFarmingTokenBalance. Attackers can control totalFarmingTokenBalance to manipulate IOUPrice. The current code does not nd the location where IOUPrice is used. Referencehttps://slowmist.medium.com/cream-hacked-analysis-us-130-million-hacked-95c9410320ca cross-yield/contracts/core/CrossYield.sol#L95-L101 function IOUPrice() public view returns (uint256) { uint256 IOUSupply = totalSupply(); return IOUSupply == 0 ? 1e18 : (totalFarmingTokenBalance() * 1e18) / IOUSupply; } 18 cross-yield/contracts/core/CrossYield.sol#L65-L67 function totalFarmingTokenBalance() public view returns (uint256) { return farmingToken().balanceOf(address(this)) + strategy.balanceOf(); }",
        "labels": [
            "SlowMist",
            "Cross Yield V1.0.0",
            "Type: Others",
            "Severity: Medium"
        ]
    },
    {
        "title": "Sandwich attacks issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Yield V1.0.0_en-us.pdf",
        "body": "There is no slippage check during swap, and there is a risk of sandwich attack. IPancakeRouter02(pcsRouter).swapExactTokensForTokens(cakeBalance, 0,cakeToBaseRoute, address(this), block.timestamp); IPancakeRouter02(pcsRouter) .swapExactTokensForTokens(toSwap, 0, route, address(this), block.timestamp); Reference https://medium.com/coinmonks/demystify-the-dark-forest-on-ethereum-sandwich-attacks-5a3aec9fa33e cross-yield/contracts/libs/OptimalSwap.sol#L14-L63 function prepareLiquidity( address cake, address[2] memory lpTokens, 19 address wbnb, address busd, address farmingToken, address pcsRouter, uint256 fee ) external { uint256 cakeBalance = IERC20(cake).balanceOf(address(this)); bool isCakeInLp = lpTokens[0] == cake || lpTokens[1] == cake; bool isWbnbBased = lpTokens[0] == wbnb || lpTokens[1] == wbnb; address baseToken = isWbnbBased ? wbnb : busd; // if cake is not part of the lp token, swap all cake for the base token if (!isCakeInLp) { address[] memory cakeToBaseRoute = new address[](2); cakeToBaseRoute[0] = cake; cakeToBaseRoute[1] = baseToken; IPancakeRouter02(pcsRouter) .swapExactTokensForTokens(cakeBalance, 0, cakeToBaseRoute, address(this), block.timestamp); } (uint256 reserve0, uint256 reserve1,) = IPancakePair(farmingToken).getReserves(); address[] memory route = new address[](2); uint256 lp0Bal = IERC20(lpTokens[0]).balanceOf(address(this)); uint256 lp1Bal = IERC20(lpTokens[1]).balanceOf(address(this)); uint256 toSwap; // The possible cases here are: // - Cake was not part of the LP token, so we swap for baseToken which could either be lpToken0 or lpToken // - Cake was part of the LP token, so it can either be lpTokens[0] or lpTokens[1] // So, depending on which token we have the highest balance for, we swap for the other one. if (lp0Bal > lp1Bal) { toSwap = SwapAmount.getSwapAmount(lp0Bal, reserve0, fee); route[0] = lpTokens[0]; route[1] = lpTokens[1]; } else { toSwap = SwapAmount.getSwapAmount(lp1Bal, reserve1, fee); route[0] = lpTokens[1]; route[1] = lpTokens[0]; 20 } // Perform the swap IPancakeRouter02(pcsRouter) .swapExactTokensForTokens(toSwap, 0, route, address(this), block.timestamp); } IPancakeRouter02(pcsRouter).swapExactTokensForTokens(toWbnb, 0, cakeToWbnbRoute, address(this), block.timestamp); cross-yield/contracts/strategies/StrategyCake.sol#L131 function collectFees() internal { // a percentant of the cake we get from the masterchef will be used to buy BNB and transfer to this address // this is the total fees that will be shared amongst the protocol, stategy dev and the harvester uint256 toWbnb = feeManager.calculateTotalFee(IERC20(farmingToken).balanceOf(address(this))); IPancakeRouter02(pcsRouter).swapExactTokensForTokens(toWbnb, 0, cakeToWbnbRoute, address(this), block.timestamp); uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this)); // distribute hervester fee uint256 harvesterFeeAmount = feeManager.calculateHarvestFee(wbnbBal); // collectFees is called indirectly from the CrossYield contract via the beforeDeposit hook. // This means that _msgSender() is the CrossYield contract and not the actuall EOA account // that send the transaction IERC20(wbnb).safeTransfer(tx.origin, harvesterFeeAmount); // distribute protocol fee uint256 protocolFeeAmount = feeManager.calculateProtocolFee(wbnbBal); // IERC20(wbnb).safeTransfer(protocolFeeRecipient, protocolFeeAmount); feeProcessor.process(protocolFeeAmount); // distribute strategy dev fee uint256 strategyDevFeeAmount = feeManager.calculateStrategyDevFee(wbnbBal); IERC20(wbnb).safeTransfer(feeManager.strategyDev(), strategyDevFeeAmount); emit FeeCollected( toWbnb, 21 harvesterFeeAmount, protocolFeeAmount, strategyDevFeeAmount, _msgSender() ); } cross-yield/contracts/strategies/StrategyCakeLP.sol#L174 function collectFees() internal { // a percentant of the cake we get from the masterchef will be used to buy BNB and transfer to this address // this is the total fees that will be shared amongst the protocol, stategy dev and the harvester uint256 toWbnb = feeManager.calculateTotalFee(IERC20(cake).balanceOf(address(this))); IPancakeRouter02(pcsRouter).swapExactTokensForTokens(toWbnb, 0, cakeToWbnbRoute, address(this), block.timestamp); uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this)); // distribute hervester fee uint256 harvesterFeeAmount = feeManager.calculateHarvestFee(wbnbBal); IERC20(wbnb).safeTransfer(_msgSender(), harvesterFeeAmount); // distribute protocol fee uint256 protocolFeeAmount = feeManager.calculateProtocolFee(wbnbBal); feeProcessor.process(protocolFeeAmount); // distribute strategy dev fee uint256 strategyDevFeeAmount = feeManager.calculateStrategyDevFee(wbnbBal); IERC20(wbnb).safeTransfer(feeManager.strategyDev(), strategyDevFeeAmount); emit FeeCollected( toWbnb, harvesterFeeAmount, protocolFeeAmount, strategyDevFeeAmount, _msgSender() ); } cross-yield/contracts/strategies/StrategyCake.sol 22 function harvest() public override whenNotPaused { // claim rewards IMasterChef(masterchef).leaveStaking(0); // because harvest can automatically be called after each user deposit // we might end up having multiple deposits in the same block and only one // would return rewards from masterchef so the rest will have 0 cake so // we don't need to waste gas to collect fees and call deposit uint256 farmingTokenBalance = balanceOfFarmingToken(); if(farmingTokenBalance > 0) { collectFees(); deposit(); emit HarvestTriggered(_msgSender(), farmingTokenBalance); } } cross-yield/contracts/strategies/StrategyCakeLP.sol#l137-L148 function harvest() external override whenNotPaused { // claim rewards IMasterChef(masterchef).deposit(poolId, 0); uint256 harvestedAmount = IERC20(cake).balanceOf(address(this)); collectFees(); addLiquidity(); deposit(); emit HarvestTriggered(_msgSender(), harvestedAmount); }",
        "labels": [
            "SlowMist",
            "Cross Yield V1.0.0",
            "Type: Reordering Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Missing slippage check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Yield V1.0.0_en-us.pdf",
        "body": "The addLiquidity function without slippage check, it doesn't have an impermanent loss check. cross-yield/contracts/strategies/StrategyCakeLP.sol#L218 function addLiquidity() internal { OptimalSwap.prepareLiquidity( cake, [lpToken0, lpToken1], wbnb, busd, farmingToken, pcsRouter, swapFee ); // add liquidity to AMM on PCS uint256 lp0Bal = IERC20(lpToken0).balanceOf(address(this)); uint256 lp1Bal = IERC20(lpToken1).balanceOf(address(this)); IPancakeRouter02(pcsRouter) .addLiquidity(lpToken0, lpToken1, lp0Bal, lp1Bal, 0, 0, address(this), block.timestamp); emit LiquidityAdded(lpToken0, lpToken1, lp0Bal, lp1Bal, _msgSender()); }",
        "labels": [
            "SlowMist",
            "Cross Yield V1.0.0",
            "Type: Reordering Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Permission check Missing",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Yield V1.0.0_en-us.pdf",
        "body": "There is no permission check for deposit function. The function is called by the CrossYieid contract. cross-yield/contracts/strategies/StrategyCakeLP.sol#L225-L231 function deposit() public override whenNotPaused { uint256 farmingTokenBalance = balanceOfFarmingToken(); if (farmingTokenBalance > 0) { IMasterChef(masterchef).deposit(poolId, farmingTokenBalance); } } cross-yield/contracts/strategies/StrategyCake.sol#L169-L175 function deposit() public override whenNotPaused { uint256 farmingTokenBalance = balanceOfFarmingToken(); if (farmingTokenBalance > 0) { IMasterChef(masterchef).enterStaking(farmingTokenBalance); } }",
        "labels": [
            "SlowMist",
            "Cross Yield V1.0.0",
            "Type: Authority Control Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Excessive authority issue 25",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Yield V1.0.0_en-us.pdf",
        "body": "Owner can modify the address of the strategy. The new strategy may have security risks if it is not audited, which will aect the user's funds. If the private key is leaked, it will aect the user's funds. cross-yield/contracts/core/CrossYield.sol#L224-L236 function upgradeStrategy() public onlyOwner { require(stratCandidate.strategy != address(0), \"No proposal exists\"); require(block.number > stratCandidate.proposedBlock + stratUpgradableAfter, \"Strategy cannot be replaced yet\"); emit NewStrategy(stratCandidate.strategy); strategy.retireStrategy(); strategy = IStrategy(stratCandidate.strategy); stratCandidate.strategy = address(0); stratCandidate.proposedBlock = 0; putFundsToWork(); } cross-yield/contracts/core/CrossYield.sol#L211-L220 function proposeStrategy(address _strategy) public onlyOwner { require(address(this) == IStrategy(_strategy).vault(), \"Invalid new strategy\"); stratCandidate = StrategyCandidate({ strategy: _strategy, proposedBlock: block.number }); emit NewStratCandidate(_strategy); }",
        "labels": [
            "SlowMist",
            "Cross Yield V1.0.0",
            "Type: Authority Control Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Repeatable claims issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Yield V1.0.0_en-us.pdf",
        "body": "After the claim, lottery.status is not set as claimed, and it is also necessary to check whether lotteryId has been claimed when the claim is executed. hotdrop/contracts/HotDrop.sol#L261-L274 function claim(uint256 lotteryId) external nonReentrant { Lottery storage lottery = lotteries[lotteryId]; require(lottery.status == Status.WinnerDrawn, \"winner not drawn\"); // if there is no winner transfer the total amount to the treasury if(tickets[lotteryId][lottery.winningNumber] == address(0)) { lottery.purchaseToken.safeTransfer(treasury, lottery.purchaseToken.balanceOf(address(this))); } else if(tickets[lotteryId][lottery.winningNumber] == _msgSender()) { // if the ticket is the winning ticket and belongs to the user then split the pot uint256 treasuryAmount = (lottery.totalRaised * lottery.treasuryFee) / FEE_BASE; lottery.purchaseToken.safeTransfer(treasury, treasuryAmount); lottery.purchaseToken.safeTransfer(_msgSender(), lottery.totalRaised - treasuryAmount); } }",
        "labels": [
            "SlowMist",
            "Cross Yield V1.0.0",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Round plan security reminder",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Yield V1.0.0_en-us.pdf",
        "body": "And the new round of lottery can only be opened when the last round of lottery is in WinnerDrawn, otherwise randomGenerator.latestLotteryId will be updated, which will cause the old lottery round to fail to execute drawWinner function due to this check. require(lotteryId == randomGenerator.latestLotteryId(), \"numbers not drawn\"); hotdrop/contracts/HotDrop.sol#L44-L256 function drawWinner(uint256 lotteryId) external nonReentrant { Lottery storage lottery = lotteries[lotteryId]; require(lottery.status == Status.Close, \"lottery still active\"); require(lotteryId == randomGenerator.latestLotteryId(), \"numbers not drawn\"); // get the winning number based on the randomResult generated by ChainLink's fallback uint256 winningNumber = randomGenerator.randomResult(); lottery.winningNumber = winningNumber; lottery.status = Status.WinnerDrawn; emit LotteryNumberDrawn(lotteryId, winningNumber); }",
        "labels": [
            "SlowMist",
            "Cross Yield V1.0.0",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Re-initialize issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cook Distribution and Reward_en-us.pdf",
        "body": "In RewardVesting contract, the Governance role can re-initialize the the contract through initialize function Location function initialize(IERC20 _cookReward) external onlyGovernance { cookReward = _cookReward; }",
        "labels": [
            "SlowMist",
            "Cook Distribution and Reward",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing authority check 7",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cook Distribution and Reward_en-us.pdf",
        "body": "The addEarning function exists in the RewardVesting contract. When the claim operation is performed in the StakingPool contract, if the corresponding reward needs to be time locked, the addEarning function of the RewardVesting contract will be called to perform the locking operation. However, the visibility of this function is external, which will cause any user to perform the addEarning operation.  function addEarning(address user, uint256 amount, uint256 durationInSecs) external { _addPendingEarning(user, amount, durationInSecs); cookReward.safeTransferFrom(msg.sender, address(this), amount); }",
        "labels": [
            "SlowMist",
            "Cook Distribution and Reward",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Code x situation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Penpie Contracts Exploit Fixes - SlowMist Audit Report_en-us.pdf",
        "body": "In the x, the project team used OpenZeppelin's ReentrancyGuard library to modify the harvestMarketReward and batchHarvestMarketRewards functions in the PendleStaking contract to address the issue of reentering depositMarket. Additionally, they restricted the registerPool function in the PendleStaking contract to be callable only by the owner role to ensure that newly registered pools are reviewed. ",
        "labels": [
            "SlowMist",
            "Penpie Contracts Exploit Fixes - SlowMist Audit Report",
            "Type: Others",
            "Severity: Information"
        ]
    },
    {
        "title": "4.3.1.1 Risk of repeated contract initialization",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SmoothyV1_en-us.pdf",
        "body": "In the SmoothyMasterV1 contract, the owner can initialize the contract through the initialize function to set the address of key parameters such as SMTYToken, startTime, and communityAddr. However, there is no restriction on the initialize function to prevent repeated initialization calls, which will cause the owner role to repeatedly initialize the contract through the initialize function. The same goes for VotingEscrow and SmoothyV1 contracts. Fix suggestion: It is suggested to restrict the initialization function that does not allow repeated calls. ",
        "labels": [
            "SlowMist",
            "SmoothyV1",
            "Severity: High"
        ]
    },
    {
        "title": "4.3.2.1 Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SmoothyV1_en-us.pdf",
        "body": "In the SMTYToken contract, the minter role can mint tokens arbitrarily through the mint function. The owner role can arbitrarily modify the minter role address through the changeMinter function, which 10 will lead to the risk of excessive owner authority. Fix suggestion: It is suggested to transfer the owner authority to community governance. ",
        "labels": [
            "SlowMist",
            "SmoothyV1",
            "Severity: Medium"
        ]
    },
    {
        "title": "4.3.2.2 Denial of Service Risk",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SmoothyV1_en-us.pdf",
        "body": "In the SmoothyMasterV1 contract, the user can update all pools through the massUpdatePools function, but it uses the for loop to update cyclically. If the number of pools exceeds too much, it will cause a DoS risk. Fix suggestion: It is suggested to limit the number of pools to avoid this problem. function massUpdatePools() public { uint256 length = poolInfo.length; for (uint256 pid = 0; pid < length; ++pid) { updatePool(pid); } } Fix status: No Fixed. 11",
        "labels": [
            "SlowMist",
            "SmoothyV1",
            "Severity: Medium"
        ]
    },
    {
        "title": "4.3.3.1 The lockDuration does not match the lockEnd",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SmoothyV1_en-us.pdf",
        "body": "In the SmoothyMasterV1 contract, the user can extend the mortgage lock period through the extendLock function. When reconfirming the lockDuration, take the new lock duration and the smaller value of MAX_TIME, but in the end, when determining the lockEnd, the _end parameter is still directly passed in. Assigned to lockEnd, if the new lock duration is greater than MAX_TIME, this will cause the lockDuration to not match the lockEnd. Fix suggestion: It is suggested to recalculate lockEnd based on lockDuration. ",
        "labels": [
            "SlowMist",
            "SmoothyV1",
            "Severity: Low"
        ]
    },
    {
        "title": "4.3.3.1 Inaccurate calculation of LP amount",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SmoothyV1_en-us.pdf",
        "body": "In the SmoothyV1 contract, in order to save gas in mint, redeem, and swap operations, the 12 calculation using getMintAmount uses cached data for calculation, which will cause the final calculation result to be inconsistent with expectations. Fix suggestion: Due to project design requirements, it is suggested that the project party manually invoke the update when the update is not performed to avoid this issue. ",
        "labels": [
            "SlowMist",
            "SmoothyV1",
            "Severity: Low"
        ]
    },
    {
        "title": "4.3.4.1 The change of LP pool weights affects users' income",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SmoothyV1_en-us.pdf",
        "body": "In the SmoothyMasterV1 contract, when the Owner calls the add function and the set function to add a new pool or reset the pool weight, all LP pool weights will change accordingly. The Owner can update all pools before adjusting the weight by passing in the _withUpdate parameter with a value of true to ensure that the user's income before the pool weight is changed will not be affected by the adjustment of the pool weight, but if the value of the _withUpdate parameter is false, then All pools will not be updated before the pool weight is adjusted, which will cause the user's income to be affected before the pool weight is changed. Fix suggestion: It is suggested to force all LP pools to be updated before the weights of LP pools are adjusted to avoid the impact of user income. ",
        "labels": [
            "SlowMist",
            "SmoothyV1",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.3.4.2 Loss of precision issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SmoothyV1_en-us.pdf",
        "body": "In the SmoothyMasterV1 contract, when using the _updateWorkingAmount function to calculate the number of workingAmount users participate in mining, divide first and then multiply, which will result in loss of accuracy. Fix suggestion: It is suggested to multiply and then divide to avoid this issue ",
        "labels": [
            "SlowMist",
            "SmoothyV1",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.3.4.3 Unrecoverable issue of pool imbalance",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SmoothyV1_en-us.pdf",
        "body": "In the SmoothyV1 contract, when the user performs operations such as recharge, redemption, and exchange, the penalty mechanism will be triggered when the weight of the coin exceeds the soft cap, but the contract does not have an incentive mechanism to perform exchange operations to reduce the proportion of the token pool. If the token pool is maliciously manipulated to exceed the soft cap, it may be difficult for the token pool to return to normal due to no incentive mechanism, which will affect normal business use. 17 Fix suggestion: It is suggested to add an incentive mechanism in an unbalanced state to avoid this problem. ",
        "labels": [
            "SlowMist",
            "SmoothyV1",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.3.4.4 Risk of Potential Token Transfer Failure",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SmoothyV1_en-us.pdf",
        "body": "In the SmoothyV1 contract, when the user deposits the token, the safeTransferFrom function is used to transfer the corresponding token, and the safeTransfer function is used to transfer the token when withdrawToken. The safeTransferFrom function and safeTransfer function will check the returned success and data , If the connected token defines the return value, but does not return according to the EIP20 specification, the user will not be able to pass the check here, resulting in the tokens being unable to be transferred in or out. Fix suggestion: It is suggested that when docking new tokens, the project party should check whether its writing complies with EIP20 specifications. ",
        "labels": [
            "SlowMist",
            "SmoothyV1",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.3.4.5 Token compatibility issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SmoothyV1_en-us.pdf",
        "body": "In the SmoothyV1 contract, under the condition that each pool is stable, the exchange operation will be performed in a 1:1 manner. However, if the project is connected to a stable rebase algorithm, the number of tokens in the pool will be changed when it undergoes deflation, resulting in an unexpected 18 number of users during the exchange. Fix suggestion: It is suggested to strictly evaluate the algorithm model of stablecoins to avoid this risk when accessing stablecoins. ",
        "labels": [
            "SlowMist",
            "SmoothyV1",
            "Severity: Informational"
        ]
    },
    {
        "title": "Excessive authority issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ROTL_en-us.pdf",
        "body": "In the ROTL contract, the DEFAULT_ADMIN_ROLE can set the minter role, the minter role can mint ERC721A tokens arbitrarily and the minter role is entitled to free mint without going through each rounds. 11 ",
        "labels": [
            "SlowMist",
            "ROTL",
            "Type: Authority Control Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Pausable is not implemented",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ROTL_en-us.pdf",
        "body": "In the ROLTMint contract, it heritates the Pausable contract, but there is no pause and unpause function implemented. That means the value ot the _paused is false and can not be changed. Which will impact the __isEnable function and whenNotPaused modier. ",
        "labels": [
            "SlowMist",
            "ROTL",
            "Type: Others",
            "Severity: Low"
        ]
    },
    {
        "title": "Missing event record",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ROTL_en-us.pdf",
        "body": "1.In the ROTLMint contract, the owner role can set the _nft, _merkleRoot, _currentRound, price, maxCount, onceMaxCount, addressMaxCount, and startBlock values through the setAddress, setMerkleRoot, setRound, and setRoundInfo functions. But there are no no events logging performed. ",
        "labels": [
            "SlowMist",
            "ROTL",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Dev address setting enhancement suggestion 14",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ROTL_en-us.pdf",
        "body": "In the ROTLMint contract, the owner role can withdraw the native token through the withdraw function. If the owner is an EOA address, in a scenario where the private key is leaked, the teams revenue will be stolen. ",
        "labels": [
            "SlowMist",
            "ROTL",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Variable not used",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ROTL_en-us.pdf",
        "body": "In the ROLT contract, the contract dened the _mintContractAddress and _revealIndex value. But these two values are not assigned and can not be set. ",
        "labels": [
            "SlowMist",
            "ROTL",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Potential risks of approving denial of service",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn - Restaking - SlowMist Audit Report.pdf",
        "body": "In the invest function, when the user passes in a rawToken that is neither NATIVE_TOKEN nor _WST_ETH token, the contract will call the user-provided depositor to execute custom user data. Prior to this, the contract approves the user's transferred funds to the depositor using the safeApprove function. It is important to note that the safeApprove function requires either the current approved amount to be 0 or the current allowance of the contract to the depositor to be 0 in order to safely approve; otherwise, it will revert. If a malicious user intentionally does not use up all the allowance during the depositor call, when the protocol attempts to execute safeApprove for this rawToken again, it will revert. This will cause a denial of service for some of the contract's functionality. ",
        "labels": [
            "SlowMist",
            "DeSyn - Restaking - SlowMist Audit Report",
            "Type: Denial of Service Vulnerability",
            "Severity: High"
        ]
    },
    {
        "title": "Accidentally transferred funds that can be stolen",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn - Restaking - SlowMist Audit Report.pdf",
        "body": "In the invest function, when the user-specied rawToken is neither NATIVE_TOKEN nor _WST_ETH, the contract directly calls the depositor contract to execute user-specied data. When other users accidentally transfer rawTokens into the Restaking contract and the Restaking contract still has a remaining allowance for the depositor, these other users can deposit the accidentally transferred tokens into the depositor as their own prot. It is obvious that the project team can also transfer out the erroneously transferred assets in the contract by approving a specic depositor. ",
        "labels": [
            "SlowMist",
            "DeSyn - Restaking - SlowMist Audit Report",
            "Type: Others",
            "Severity: Information"
        ]
    },
    {
        "title": "Risk of user assets being stolen due to arbitrary execution of data",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn - Restaking - SlowMist Audit Report.pdf",
        "body": "In the invest function, when the user-specied rawToken is neither NATIVE_TOKEN nor _WST_ETH, the contract directly calls the depositor contract to execute user-specied data. It is important to note that in some restaking protocols (such as stETH and pufETH), the deposit, borrowing, and token transfer interfaces are in the same contract. Taking pufETH as an example, users can call the pufETH contract to make deposits and obtain pufETH tokens, and they can also call the pufETH contract to transfer pufETH tokens. Therefore, although the legality of the depositor is checked in the invest function, the restakingParams.data passed in by the user is not checked. This allows users to call the transferFrom function of the LST/LRT contract via restakingParams.depositor.functionCallWithValue to transfer tokens of any user who has already approved this contract. ",
        "labels": [
            "SlowMist",
            "DeSyn - Restaking - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Decimal problems in share calculation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn - Restaking - SlowMist Audit Report.pdf",
        "body": "In the invest function, when a user completes a restaking operation, the contract deposits the restaking tokens into the user-specied ETF and transfers the ETF LP to the user. Prior to this, the contract calculates the amount of ETF LP the user can obtain when joining the pool through _calculateShare . It is important to note that if the user's deposit amount is relatively small, due to decimal errors during calculation, the amount of LP obtained during the joinPool operation may be 1 wei more than the amount calculated by _calculateShare . However, this does not aect the normal business logic of the protocol. ",
        "labels": [
            "SlowMist",
            "DeSyn - Restaking - SlowMist Audit Report",
            "Type: Arithmetic Accuracy Deviation Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Issues where issueFee maybe 0",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn - Restaking - SlowMist Audit Report.pdf",
        "body": "In the _calculateShare function, it calculates the amount of LP that can be obtained based on the amount of tokens that need to be deposited into the ETF. In this process, it considers the minting fee charged when depositing into the ETF. However, it is important to note that if the user-specied ETF is closed-ended and the current isCompletedCollect state is false, the ETF will waive the minting fee for the depositor. This will cause the share calculated by the _calculateShare function to be smaller than expected, ultimately resulting in some funds remaining in the Restaking contract and not being deposited into the ETF. ",
        "labels": [
            "SlowMist",
            "DeSyn - Restaking - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Wrong slippage check issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cook Index_en-us.pdf",
        "body": "In the IssuanceModule contract, the _createTradeInfo function is used to create a structure containing trade data. Among them, it will obtain the thresholdAmounts parameter oset by slippage through the getMinAmountsOut function and the getMaxAmountsIn function. After the trade data is created, the trade operation will be executed 8 through the _executeTrade function, which will use the thresholdAmounts parameter as the minimum amounts to receive for trading on uniswap. However, since slippage check and trade execution are carried out in the same transaction, the thresholdAmounts parameter will still be aected by the last swap transaction of uniswap. Therefore, the slippage check cannot play a protective role. ",
        "labels": [
            "SlowMist",
            "Cook Index",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Logical redundancy issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cook Index_en-us.pdf",
        "body": "In the VesperWrapAdapter contract, getSpenderAddress is used to obtain the source token address of the wrap token, but the actual function logic directly returns the passed _wrappedToken parameter. This seems to be dierent from what the function comments indicate. ",
        "labels": [
            "SlowMist",
            "Cook Index",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of external calls 11",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cook Index_en-us.pdf",
        "body": "There are a large number of external calls in the IssuanceModule contract, but the external call part is not within the scope of this audit. It is necessary to pay attention to the unknown risks of external calls.",
        "labels": [
            "SlowMist",
            "Cook Index",
            "Type: Unsafe External Call Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Random can be predicted issue 15",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DODO-MiningV3 and NFT_en-us.pdf",
        "body": "The random number is uncertain when buying a ticket. However, there is no separate operation of using the redeeming tickets and determining the random number when redeeming tickets, and there is an issue that the random number can be predicted. https://github.com/DODOEX/contractV2/blob/453e323af6/contracts/DODODrops/DODODropsV2/DODODro ps.sol#L114 function buyTickets(address ticketTo, uint256 ticketAmount) payable external preventReentrant { (uint256 curPrice, uint256 sellAmount, uint256 index) = getSellingInfo(); require(curPrice > 0 && sellAmount > 0, \"CAN_NOT_BUY\"); require(ticketAmount <= sellAmount, \"TICKETS_NOT_ENOUGH\"); (uint256 payAmount, uint256 feeAmount) = IDropsFeeModel(_FEE_MODEL_).getPayAmount(address(this), ticketTo, curPrice, ticketAmount); require(payAmount > 0, \"UnQualified\"); uint256 baseBalance = IERC20(_BUY_TOKEN_).universalBalanceOf(address(this)); uint256 buyInput = baseBalance.sub(_BUY_TOKEN_RESERVE_); require(payAmount <= buyInput, \"PAY_AMOUNT_NOT_ENOUGH\"); _SELLING_AMOUNT_SET_[index] = sellAmount.sub(ticketAmount); _BUY_TOKEN_RESERVE_ = baseBalance.sub(feeAmount); IERC20(_BUY_TOKEN_).universalTransfer(_MAINTAINER_,feeAmount); _mint(ticketTo, ticketAmount); emit BuyTicket(ticketTo, payAmount, feeAmount, ticketAmount); } The owner determines the value of _REVEAL_RN_ by calling the setRevealRn function. The value of _REVEAL_RN_ will affect the result of the random number. https://github.com/DODOEX/contractV2/blob/453e323af6/contracts/DODODrops/DODODropsV2/DODODro ps.sol#L229 function setRevealRn() external onlyOwner { require(_REVEAL_RN_ == 0, \"ALREADY_SET\"); 16 _REVEAL_RN_ = uint256(keccak256(abi.encodePacked(blockhash(block.number - 1)))); emit SetReveal(); } The value of random is related to _REVEAL_RN_ , msg.sender , balanceOf(msg.sender) and curNo in REVEAL_MODE mode when users use wallets for transactions. Attackers can generate addresses and balances values to control the random number. In non-REVEAL_MODE mode, the value of random is related to _RNG_ , block.number , and gasleft . The attackers can sort transactions through pre-execution or in cooperation with miners. In this way, they can manipulate block.number and gasleft to control random numbers. https://github.com/DODOEX/contractV2/blob/453e323af6/contracts/DODODrops/DODODropsV2/DODODro ps.sol#L154-L159 function _redeemSinglePrize(address to, uint256 curNo, address referer) internal { require(block.timestamp >= _REDEEM_ALLOWED_TIME_ && _REDEEM_ALLOWED_TIME_ != 0, \"REDEEM_CLOSE\"); uint256 range; if(_IS_PROB_MODE_) { range = _PROB_INTERVAL_[_PROB_INTERVAL_.length - 1]; }else { range = _TOKEN_ID_LIST_.length; } uint256 random; if(_IS_REVEAL_MODE_) { require(_REVEAL_RN_ != 0, \"REVEAL_NOT_SET\"); random = uint256(keccak256(abi.encodePacked(_REVEAL_RN_, msg.sender, balanceOf(msg.sender).add(curNo + 1)))) % range; }else { random = IRandomGenerator(_RNG_).random(gasleft() + block.number) % range; } uint256 tokenId; if(_IS_PROB_MODE_) { uint256 i; for (i = 0; i < _PROB_INTERVAL_.length; i++) { if (random <= _PROB_INTERVAL_[i]) { break; } } require(_TOKEN_ID_MAP_[i].length > 0, \"EMPTY_TOKEN_ID_MAP\"); 17 tokenId = _TOKEN_ID_MAP_[i][random % _TOKEN_ID_MAP_[i].length]; IDropsNft(_NFT_TOKEN_).mint(to, tokenId, 1, \"\"); } else { tokenId = _TOKEN_ID_LIST_[random]; if(random != range - 1) { _TOKEN_ID_LIST_[random] = _TOKEN_ID_LIST_[range - 1]; } _TOKEN_ID_LIST_.pop(); IDropsNft(_NFT_TOKEN_).mint(to, tokenId); } emit RedeemPrize(to, tokenId, referer); }",
        "labels": [
            "SlowMist",
            "DODO-MiningV3 and NFT",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "isContract can be bypassed",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DODO-MiningV3 and NFT_en-us.pdf",
        "body": "When redeeming tickets isContract is used to determine whether the caller msg.sender is a contract. The contract is not allowed to be called, but the implementation of this check has flaws and can be bypassed. https://github.com/DODOEX/contractV2/blob/453e323af6/contracts/DODODrops/DODODropsV2/DODODro ps.sol#L135 18 function redeemTicket(uint256 ticketNum, address referer) external { require(!address(msg.sender).isContract(), \"ONLY_ALLOW_EOA\"); require(ticketNum >= 1 && ticketNum <= balanceOf(msg.sender), \"TICKET_NUM_INVALID\"); _burn(msg.sender,ticketNum); for (uint256 i = 0; i < ticketNum; i++) { _redeemSinglePrize(msg.sender, i, referer); } } https://github.com/DODOEX/contractV2/blob/453e323af6/contracts/external/utils/Address.sol#L27 function isContract(address account) internal view returns (bool) { // This method relies on extcodesize, which returns 0 for contracts in // construction, since the code is only stored at the end of the // constructor execution. uint256 size; // solhint-disable-next-line no-inline-assembly assembly { size := extcodesize(account) } return size > 0; }",
        "labels": [
            "SlowMist",
            "DODO-MiningV3 and NFT",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Excessive authority issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DODO-MiningV3 and NFT_en-us.pdf",
        "body": "The owner can control the source of the seed of the random number. The seed of the random number will affect the value of the random number and affect the probability of redeeming the ticket. 19 https://github.com/DODOEX/contractV2/blob/453e323af6/contracts/DODODrops/DODODropsV2/DODODro ps.sol#L227 function setRevealRn() external onlyOwner { require(_REVEAL_RN_ == 0, \"ALREADY_SET\"); _REVEAL_RN_ = uint256(keccak256(abi.encodePacked(blockhash(block.number - 1)))); emit SetReveal(); } The owner can change the value of _RNG_ , which will affect the random number of the redemption ticket if it is not REVEAL_MODE. https://github.com/DODOEX/contractV2/blob/453e323af6/contracts/DODODrops/DODODropsV2/DODODro ps.sol#L259 function updateRNG(address newRNG) external onlyOwner { require(newRNG != address(0)); _RNG_ = newRNG; emit ChangeRNG(newRNG); } The owner can transfer _REWARD_TOKEN_ to any address. The current design framework Owner address will be sent to the address of the Mine contract. https://github.com/DODOEX/contractV2/blob/c7202eeae7/contracts/DODOToken/DODOMineV3/RewardVau lt.sol#L38-L49 function reward(address to, uint256 amount) external onlyOwner { require(_REWARD_RESERVE_ >= amount, \"VAULT_NOT_ENOUGH\"); _REWARD_RESERVE_ = _REWARD_RESERVE_.sub(amount); IERC20(_REWARD_TOKEN_).safeTransfer(to, amount); } function withdrawLeftOver(address to,uint256 amount) external onlyOwner { require(_REWARD_RESERVE_ >= amount, \"VAULT_NOT_ENOUGH\"); 20 _REWARD_RESERVE_ = _REWARD_RESERVE_.sub(amount); IERC20(_REWARD_TOKEN_).safeTransfer(to, amount); } The owner can mint tokens for any user and burn any user's tokens. https://github.com/DODOEX/contractV2/blob/c7202eeae7/contracts/external/ERC20/CustomERC20.sol#L12 3-L138 function mint(address user, uint256 value) external onlyOwner { require(isMintable, \"NOT_MINTABEL_TOKEN\"); balances[user] = balances[user].add(value); totalSupply = totalSupply.add(value); emit Mint(user, value); emit Transfer(address(0), user, value); } function burn(address user, uint256 value) external onlyOwner { require(isMintable, \"NOT_MINTABEL_TOKEN\"); balances[user] = balances[user].sub(value); totalSupply = totalSupply.sub(value); emit Burn(user, value); emit Transfer(user, address(0), value); } The owner can update the template contract. If an unaudited template contract is updated, this will affect the assets of the new user in the newly created contract. https://github.com/DODOEX/contractV2/blob/c7202eeae7/contracts/SmartRoute/proxies/DODOMineV3Prox y.sol#L128 function updateMineV2Template(address _newMineV3Template) external onlyOwner { _MINEV3_TEMPLATE_ = _newMineV3Template; } https://github.com/DODOEX/contractV2/blob/7e629d0e58/contracts/Factory/ERC20V2Factory.sol 21 function updateStdTemplate(address newStdTemplate) external onlyOwner { _ERC20_TEMPLATE_ = newStdTemplate; emit ChangeStdTemplate(newStdTemplate); } function updateCustomTemplate(address newCustomTemplate) external onlyOwner { _CUSTOM_ERC20_TEMPLATE_ = newCustomTemplate; emit ChangeCustomTemplate(newCustomTemplate); }",
        "labels": [
            "SlowMist",
            "DODO-MiningV3 and NFT",
            "Type: Authority Control Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "The DoS risk",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DODO-MiningV3 and NFT_en-us.pdf",
        "body": "Use a for loop to traverse the array. If the number of loops is large, it will cause an out of gas. After communication and feedback, the project team will ensure that the number of rewardTokenInfos will not be too much. 22 https://github.com/DODOEX/contractV2/blob/c7202eeae7/contracts/DODOToken/DODOMineV3/BaseMine.s ol#L258 function _updateAllReward(address user) internal { uint256 len = rewardTokenInfos.length; for (uint256 i = 0; i < len; i++) { _updateReward(user, i); } }",
        "labels": [
            "SlowMist",
            "DODO-MiningV3 and NFT",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Event log missing",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DODO-MiningV3 and NFT_en-us.pdf",
        "body": "The owner can arbitrarily set an external contract address as a template contract. When a user creates a new contract, it will be created based on the template contract. After creation, the asset needs to be recharged to the new contract. There is no event record, which is unfavorable for review by community users. https://github.com/DODOEX/contractV2/blob/c7202eeae7/contracts/SmartRoute/proxies/DODOMineV3Prox y.sol#L128 function updateMineV2Template(address _newMineV3Template) external onlyOwner { _MINEV3_TEMPLATE_ = _newMineV3Template; } The owner can modify the configuration of the contract, but there is no event record, which is unfavorable for review by community users. 23 https://github.com/DODOEX/contractV2/blob/c7202eeae7/contracts/Factory/Registries/DODOMineV3Registr y.sol#L87-L101 function addAdminList (address contractAddr) external onlyOwner { isAdminListed[contractAddr] = true; } function removeAdminList (address contractAddr) external onlyOwner { isAdminListed[contractAddr] = false; } function addSingleTokenList(address token) external onlyOwner { singleTokenList[token] = true; } function removeSingleTokenList(address token) external onlyOwner { singleTokenList[token] = false; }",
        "labels": [
            "SlowMist",
            "DODO-MiningV3 and NFT",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Check enhancement of isLpToken",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DODO-MiningV3 and NFT_en-us.pdf",
        "body": "Admin can add non-LPtoken assets but isLpToken is True, or belong to LPtoken assets but isLpToken is False Pool, which will affect the actual business logic. This part of the inspection is not implemented in the contract. https://github.com/DODOEX/contractV2/blob/c7202eeae7/contracts/Factory/Registries/DODOMineV3Registr y.sol#L44 function addMineV3( address mine, 24 bool isLpToken, address stakeToken ) override external { require(isAdminListed[msg.sender], \"ACCESS_DENIED\"); _MINE_REGISTRY_[mine] = stakeToken; if(isLpToken) { _LP_REGISTRY_[stakeToken] = mine; }else { require(_SINGLE_REGISTRY_[stakeToken].length == 0 || singleTokenList[stakeToken], \"ALREADY_EXSIT_POOL\"); _SINGLE_REGISTRY_[stakeToken].push(mine); } emit NewMineV3(mine, stakeToken, isLpToken); }",
        "labels": [
            "SlowMist",
            "DODO-MiningV3 and NFT",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Security reminder on architecture design",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DODO-MiningV3 and NFT_en-us.pdf",
        "body": "createStdERC20 and createMintableERC20 are open-ended calls. The user creates a contract using the createStdERC20 function to record the created information in _USER_STD_REGISTRY_ , and then can get the information through getTokenByUser. Because it is an open call, it is not recommended to use the data obtained by getTokenByUser. As input for other businesses, after communication and feedback, the project party will not rely on the data obtained by getTokenByUser in the business logic of the project. https://github.com/DODOEX/contractV2/blob/c7202eeae7/contracts/Factory/ERC20V2Factory.sol#L72-L123 function createStdERC20( uint256 totalSupply, string memory name, 25 string memory symbol, uint256 decimals ) external returns (address newERC20) { newERC20 = ICloneFactory(_CLONE_FACTORY_).clone(_ERC20_TEMPLATE_); IStdERC20(newERC20).init(msg.sender, totalSupply, name, symbol, decimals); _USER_STD_REGISTRY_[msg.sender].push(newERC20); emit NewERC20(newERC20, msg.sender, 0); } function createCustomERC20( uint256 initSupply, string memory name, string memory symbol, uint256 decimals, uint256 tradeBurnRatio, uint256 tradeFeeRatio, address teamAccount, bool isMintable ) external returns (address newCustomERC20) { newCustomERC20 = ICloneFactory(_CLONE_FACTORY_).clone(_CUSTOM_ERC20_TEMPLATE_); ICustomERC20(newCustomERC20).init( msg.sender, initSupply, name, symbol, decimals, tradeBurnRatio, tradeFeeRatio, teamAccount, isMintable ); _USER_CUSTOM_REGISTRY_[msg.sender].push(newCustomERC20); if(isMintable) emit NewERC20(newCustomERC20, msg.sender, 2); else emit NewERC20(newCustomERC20, msg.sender, 1); } // ============ View ============ function getTokenByUser(address user) external 26 view returns (address[] memory stds,address[] memory customs) { return (_USER_STD_REGISTRY_[user], _USER_CUSTOM_REGISTRY_[user]); }",
        "labels": [
            "SlowMist",
            "DODO-MiningV3 and NFT",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Pages calculation issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SubDao_en-us.pdf",
        "body": "In the DaoFactory contract, calculatePages is used to calculate the start index and end index of a page. The size, start index and end index are checked in the function size <= 0 || start >= total || start < end , but in fact, size should not be less than 0, and start should not be greater than total. ",
        "labels": [
            "SlowMist",
            "SubDao",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Missing event records",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SubDao_en-us.pdf",
        "body": "In the DaoTemplate contract, the user can modify the actionCong parameter through the setActionCong function, but no event recording is performed. The same is true for the setActionCong function in the VentureTemplate contract. The same is true for the setCanFreeAddMember, transferOwner and updateOwnership functions in the OrgManager contract. ",
        "labels": [
            "SlowMist",
            "SubDao",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Owner update issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SubDao_en-us.pdf",
        "body": "In the DaoTemplate contract, the owner can update the owner of all components through the updateOwnership function. But it calls the updateOwnership interface of the templateCong contract by mistake. The same is true for the updateOwnership function in the VentureTemplate contract. ",
        "labels": [
            "SlowMist",
            "SubDao",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "State Coverage Risk",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SubDao_en-us.pdf",
        "body": "In the GrantMethodManager contract, DaoTemplate can operate the applyOp and setUserOpByOwner functions through the action contract. Since the parameters it receives are all passed in from the outside, if the incoming data is repeated, the encoded key will be repeated, which will cause the existing data to be overwritten. ",
        "labels": [
            "SlowMist",
            "SubDao",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "TODO label issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SubDao_en-us.pdf",
        "body": "There is still a TODO label in the spendTokenInLimit function of the GrantMethodManager contract. Is there still a function not perfect? The same is true for the _unsafeCancelVote function in the VoteManager contract. ",
        "labels": [
            "SlowMist",
            "SubDao",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Length check issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SubDao_en-us.pdf",
        "body": "The initialize function exists in the VenturesStockManager , VenturesManager and GovTokenManager contracts to initialize the contract according to the incoming parameters. It checks the byte length of the incoming parameter, but because some parameters are variable-length data, forcing an equals check will lead to unsuccessful initialization. ",
        "labels": [
            "SlowMist",
            "SubDao",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Vote check issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SubDao_en-us.pdf",
        "body": "In the VoteManager contract, the _canExecute function is used to check whether the proposal can be executed, but it does not check whether the number of yes votes is greater than the number of negative votes. ",
        "labels": [
            "SlowMist",
            "SubDao",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Cancel voting issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SubDao_en-us.pdf",
        "body": "29 In the VoteManager contract, the _canCancel function user checks whether the current vote can be cancelled. If the voting period for a proposal has passed, but the execution conditions are still not met, the proposal cannot be executed or cancelled. ",
        "labels": [
            "SlowMist",
            "SubDao",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Risk of Governance Attacks",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SubDao_en-us.pdf",
        "body": "DAO members can create new proposals through ActionVoteNew , ActionGrantMethodRegister , ActionVoteTransferPeriodRegister and other contracts. However, the proposal does not contain the data that needs to be executed. After the proposal is passed, the community members will pass in the specic execution data for execution. If malicious data is passed in, there is a risk that the protocol will be maliciously broken during proposal execution.",
        "labels": [
            "SlowMist",
            "SubDao",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Potential Fund Theft Risk",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SubDao_en-us.pdf",
        "body": "As mentioned in N12, when a DAO member creates an Operation through ActionGrantMethodRegister, the user's specic execution data is not recorded in the newVote operation. Although registerOp records the extra data passed in by the user, it is not used op_.extra in actual execution. Therefore, the user can pass in valid execution data when performing the registerOp operation. And malicious data is passed in during the ActionVaultUniswapV2Router02Swap operation. This will result in funds managed by the DAO being approved for malicious router contracts, or swapping through extremely illiquid pools, allowing malicious users to easily arbitrage. This would create huge risks for DAOs. The same is true in the ActionVaultUniswapV2SwapToken contract. ",
        "labels": [
            "SlowMist",
            "SubDao",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Lack of access control",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SubDao_en-us.pdf",
        "body": "In the VenturesManager contract, the gpRaiseMoney and lpRaiseMoney functions are not restricted to be called by the owner. ",
        "labels": [
            "SlowMist",
            "SubDao",
            "Type: Authority Control Vulnerability",
            "Severity: High"
        ]
    },
    {
        "title": "Period transfer issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - SubDao_en-us.pdf",
        "body": "In the ActionVoteTransferPeriodApply contract, when performing a period transfer, the period will be obtained through the transferPeriodStates function of the VoteExecutionManager contract, and then the period will be transferred through the transferVenturePeriod function of the VenturesManager contract. But in the current action, period is directly transferred to SettlementPeriod. ",
        "labels": [
            "SlowMist",
            "SubDao",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - X2Y2 - NFT Lending_en-us.pdf",
        "body": "1.In the Cong contract, the owner role can add manager role and can update the adminShare, and the manager role can set or remove the ERC20 and ERC721 tokens through the setERC20Permits and setERC721Permits functions. If the ERC20 and ERC721 on the loan list, the manager sets these permit as false may cause the risk of excessive authority. ",
        "labels": [
            "SlowMist",
            "X2Y2 - NFT Lending",
            "Type: Authority Control Vulnerability",
            "Severity: High"
        ]
    },
    {
        "title": "Token compatibility issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - X2Y2 - NFT Lending_en-us.pdf",
        "body": "In the XY3 contract, the lender will transfer the ERC20 token to the borrower in the borrow function also to the lender and adminFeeReceiver in the repay function. And this transfer is used the SafeER20 safeTransferFrom function and transfer the exact amount of the borrowAmount, payoAmount and adminFee. If the borrowAsset ERC20 tokens are the deationary tokens (or other tokens that require a transfer fee) which will cause the call failed. ",
        "labels": [
            "SlowMist",
            "X2Y2 - NFT Lending",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Dev address setting enhancement suggestions",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - X2Y2 - NFT Lending_en-us.pdf",
        "body": "In the Cong contract, the manager role can update the adminFeeReceiver in the updateAdminFeeReceiver function to receive the adminFee. If the adminFeeReceiver address is an EOA address, in a scenario where the private key is leaked, the teams revenue will be stolen. ",
        "labels": [
            "SlowMist",
            "X2Y2 - NFT Lending",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "The deationary token docking issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - CakeVault_en-us.pdf",
        "body": "Users can transfer the cake token into the vault contract through the deposit function. Under normal circumstances, the number of staking tokens transferred by the user is the same as the _amount parameter passed in. But if the staking token is a deationary token, the number of tokens transferred by the user may be dierent from the number of tokens actually received in the contract. ",
        "labels": [
            "SlowMist",
            "CakeVault",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "CakeAtLastUserAction parameter record error issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - CakeVault_en-us.pdf",
        "body": "In the Vault contract, the user can withdraw the funds staked by the user through the withdraw function. If the user does not withdraw all funds (user.shares> 0), this function will recalculate the user's cakeAtLastUserAction value. In the calculation process, the number of cake tokens obtained by the balanceOf function is used to participate in the calculation. But at the end of this function, a certain amount of cake tokens will be transferred to the user through the safeTransfer function, so the number of cake tokens obtained by the balanceOf function used in the calculation of cakeAtLastUserAction is relatively large. ",
        "labels": [
            "SlowMist",
            "CakeVault",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing event records",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - CakeVault_en-us.pdf",
        "body": "In the contract, the owner role can set the addresses of the admin role and the treasure role through the setAdmin function and the setTreasury function, respectively, but no event recording is performed. In the contract, the admin role can change the sensitive parameters of the contract through the setPerformanceFee, setCallFee, setWithdrawFee, and setWithdrawFeePeriod functions, but no event recording is performed. ",
        "labels": [
            "SlowMist",
            "CakeVault",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Emergency withdrawal issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - CakeVault_en-us.pdf",
        "body": "In the Vault contract, the admin role can make emergency withdrawals of cake tokens from the MasterChef contract to the Vault contract via the emergencyWithdraw function. However, it should be noted that any user can obtain 0.25% of the cake token reward in the Vault contract through the harvest function, and re-stake the remaining cake tokens into the MasterChef contract. So if the emergencyWithdraw operation is performed while the contract is not suspended it may cause unintended results. 10 ",
        "labels": [
            "SlowMist",
            "CakeVault",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Partial logic not implemented",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Das Contract Reverse_en-us.pdf",
        "body": "In the setReverseName function of the ReverseLogic contract, after the previous check, the specic check logic when the owner is still 0 address is not implemented. ",
        "labels": [
            "SlowMist",
            "Das Contract Reverse",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Potential risk of arbitrarily setting reverse name",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Das Contract Reverse_en-us.pdf",
        "body": "In the ReverseLogic contract, the user can set the reverse name through the setReverseName function, which allows the contract to set itself. However, some contracts have the feature of arbitrary external calls, which will allow any user to set the reverse name of the contract. ",
        "labels": [
            "SlowMist",
            "Das Contract Reverse",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "4.2.1.1 The settleHolderInterest is not used to update user interest before Withdraw",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - dFuture_en-us.pdf",
        "body": "The code uses payOffInterest to process the user's interest when processing the user's withdraw, but it did not use settleHolderInterest to update the user's interest situation before, resulting in a deviation in the interest payment. ",
        "labels": [
            "SlowMist",
            "dFuture",
            "Severity: Low"
        ]
    },
    {
        "title": "4.2.1.2 The global status is not updated when using the getMarginRatioOf function",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - dFuture_en-us.pdf",
        "body": "to calculate the user's position When using the getMarginRationOf function to calculate the user's position, the global state is not updated with updateGlobalInterestRate first, which may cause calculation errors. ",
        "labels": [
            "SlowMist",
            "dFuture",
            "Severity: Low"
        ]
    },
    {
        "title": "4.2.1.3 When calculating the user's position,",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - dFuture_en-us.pdf",
        "body": "the user's intereset <0 is not considered When using the getMarginRationOf function to calculate the user's position, the case of rate <0 is not 22 processed. ",
        "labels": [
            "SlowMist",
            "dFuture",
            "Severity: Low"
        ]
    },
    {
        "title": "4.2.2.1 did not consider the issue of system compensation, and did not limit the",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - dFuture_en-us.pdf",
        "body": "maximum benefits of users The system code does not consider whether the system can pay for this when processing the user's position closing. When this happens, it will cause an unknown error. ",
        "labels": [
            "SlowMist",
            "dFuture",
            "Severity: Low"
        ]
    },
    {
        "title": "Missing Checking",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap_en-us.pdf",
        "body": "In PancakeSwapRouter contract, the removeLiquidity / removeLiquidityETH / removeLiquidityWithPermit function does not check whether a pair is exist, which will leads to gas wasting when a pair does not exist. eg. removeLiquidity function function removeLiquidity( address tokenA, address tokenB, uint liquidity, uint amountAMin, uint amountBMin, address to, uint deadline ) public virtual override ensure(deadline) returns (uint amountA, uint amountB) { 13 address pair = PancakeLibrary.pairFor(factory, tokenA, tokenB); IPancakePair(pair).transferFrom(msg.sender, pair, liquidity); // send liquidity to pair (uint amount0, uint amount1) = IPancakePair(pair).burn(to); (address token0,) = PancakeLibrary.sortTokens(tokenA, tokenB); (amountA, amountB) = tokenA == token0 ? (amount0, amount1) : (amount1, amount0); require(amountA >= amountAMin, 'PancakeRouter: INSUFFICIENT_A_AMOUNT'); require(amountB >= amountBMin, 'PancakeRouter: INSUFFICIENT_B_AMOUNT'); }",
        "labels": [
            "SlowMist",
            "PancakeSwap",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Open Social - Abstract Account_en-us.pdf",
        "body": "1.In the VerifyingSingletonPaymaster contract, the DEFAULT_ADMIN_ROLE can arbitrarily set the unaccountedEPGasOverhead parameters. If this parameter is set too high, paymasterIdBalances may be consumed maliciously. ",
        "labels": [
            "SlowMist",
            "Open Social - Abstract Account",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Ordinary users with permitCalls may use the owner privilege through arbitrary contract calls",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Open Social - Abstract Account_en-us.pdf",
        "body": "The execute and executeBatch functions allow ordinary users to call the contracts which in the permitCalls with arbitrary calldata, can control their native token or ERC20 token assets by these functions. However, this functionality can be abused and users calling the contract itself (OspAccount) through the EntryPoint contract will then be able to call functions like setOwner, setRecoveryAddress, setPermitCall, and revokeSessionKey functions, thus overstepping their authority. ",
        "labels": [
            "SlowMist",
            "Open Social - Abstract Account",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing the event records",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Open Social - Abstract Account_en-us.pdf",
        "body": "In the WhitelistOperationVerifyingPaymaster and the OspAccountFactory contracts, the ADMIN and DEFAULT_ADMIN_ROLE can arbitrarily modify OperationInPut , enableWhitelistOperation , and accountImplementation parameters, but there are no event logs in these functions. ",
        "labels": [
            "SlowMist",
            "Open Social - Abstract Account",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing zero address validation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Open Social - Abstract Account_en-us.pdf",
        "body": "In the OspAccount and the OspAccountFactory contracts, it lacks a zero-check when setting addresses. ",
        "labels": [
            "SlowMist",
            "Open Social - Abstract Account",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "ERC777 reentrancy risk reminder",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Open Social - Abstract Account_en-us.pdf",
        "body": "ERC777 tokens are vulnerable to reentrancy attacks due to a design aw. In the TokenCallbackHandler contract, the deprecated ERC777 standard tokensReceived has been introduced into the contract. If there is any need to deal with ERC77 tokens in the project, strict attention needs to be paid to whether there is reentrancy risk. ",
        "labels": [
            "SlowMist",
            "Open Social - Abstract Account",
            "Type: Unsafe External Call Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing event log",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Arowana_en-us.pdf",
        "body": "The owner role can call the addToken and removeToken functions to add and remove the specied token address into the _addresses and _indexes . If there is no event record, it is not conducive to the review of community users. ",
        "labels": [
            "SlowMist",
            "Arowana",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing event log",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Arowana_en-us.pdf",
        "body": "7 The owner role can call the setValut function to set the source of reward token distribution. If there is no event record, it is not conducive to the review of community users. ",
        "labels": [
            "SlowMist",
            "Arowana",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing balance change",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Arowana_en-us.pdf",
        "body": "When the user calls the withdraw function for withdrawal ( block.timestap >= pool.end ), the balance of pool is not changed here. ",
        "labels": [
            "SlowMist",
            "Arowana",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Missing balance check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Arowana_en-us.pdf",
        "body": "When the user calls the withdraw function for withdrawal ( block.timestap >= pool.end ), there is a lack of judgment on the balance of valut. If the token balance of valut is not enough to pay the user's reward, the transaction will be rolled back and the user's principal and reward cannot be withdrawn. ",
        "labels": [
            "SlowMist",
            "Arowana",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Lack of access control issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning Farm - ETH Leverage_en-us.pdf",
        "body": "In the BalancerReceiver contract, the SS contract can initiate WETH ash loans through the ashLoan function, but the ashLoan function allows any user to call. Although the loanFallback function of the SS contract checks curState, it is undoubtedly more expected that the ashLoan function can only be called by the SS contract. 10 ",
        "labels": [
            "SlowMist",
            "Earning Farm - ETH Leverage",
            "Type: Authority Control Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Gas optimization",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning Farm - ETH Leverage_en-us.pdf",
        "body": "In the ETHLeverage contract, the _harvest function is used to collect fees, which will only be charged when lastEarnBlock and block.number are used. But the function does not check whether the dierence between lastEarnBlock and block.number is 0. If multiple users in the same block trigger the _harvest function, it will cause unnecessary gas consumption. ",
        "labels": [
            "SlowMist",
            "Earning Farm - ETH Leverage",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Redundant logic issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning Farm - ETH Leverage_en-us.pdf",
        "body": "In the Controller contract, the owner can set the exchange and harvestFee parameters respectively through the setExchange and setHarvestFee functions. But in this contract the exchange and harvestFee parameters are not used. ",
        "labels": [
            "SlowMist",
            "Earning Farm - ETH Leverage",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "The problem of checking the number of swaps",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning Farm - ETH Leverage_en-us.pdf",
        "body": "In the ETHLeverExchange contract, the swapExactETH function is used to exchange stETH to ETH during emergency withdrawal. It will get the amount of ETH that can be exchanged through the get_dy function and check if the swap amount is larger than the expected required amount. But in theory it is acceptable for the number of swaps to be equal to what is expected to be required. ",
        "labels": [
            "SlowMist",
            "Earning Farm - ETH Leverage",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning Farm - ETH Leverage_en-us.pdf",
        "body": "In the protocol, the owner role has many permissions, such as: the owner can set sensitive parameters, can suspend the contract, can make emergency withdrawals, can migrate the funds of the SS contract, etc. It is obviously inappropriate to give all the permissions of the protocol to the owner, which will greatly increase the single point of 13 risk.",
        "labels": [
            "SlowMist",
            "Earning Farm - ETH Leverage",
            "Type: Authority Control Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Risk of exchange slippage",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning Farm - ETH Leverage_en-us.pdf",
        "body": "When users make withdrawals in the protocol, they need to exchange stETH tokens for ETH tokens through CurvePool. However, the exchange slippage is not limited in the ETHLeverExchange contract, which will make users vulnerable to sandwich attacks when withdrawing. ",
        "labels": [
            "SlowMist",
            "Earning Farm - ETH Leverage",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Medium Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Ultiverse - Chips Contract_en-us.pdf",
        "body": "1.In the GoldChip contract, the owner role can modify key sensitive parameters such as the burnable status, the _baseTokenURI , and granting or revoking roles, which will lead to the risk of over-privilege of the owner role. ",
        "labels": [
            "SlowMist",
            "Ultiverse - Chips Contract",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Low-level call reminder",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Ultiverse - Chips Contract_en-us.pdf",
        "body": "In the ChipStakingPool contract, the contract uses low-level calls and does not limit the amount of gas used to transfer native tokens to users. ",
        "labels": [
            "SlowMist",
            "Ultiverse - Chips Contract",
            "Type: Others",
            "Severity: Information"
        ]
    },
    {
        "title": "Potential overow risks caused by type conversion",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Ultiverse - Chips Contract_en-us.pdf",
        "body": "In the ChipStakingPool contract, users can deposit the native tokens to gain the Lots. The deposit function uses a type conversion to convert the uint256 type values such as quantity, availableGoldLots, and availableSilverLots to the uint64 type. If the user passes in a quantity greater than uint64, this will cause the overow when converting the data to uint256. ",
        "labels": [
            "SlowMist",
            "Ultiverse - Chips Contract",
            "Type: Arithmetic Accuracy Deviation Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Refund lock reminder",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Ultiverse - Chips Contract_en-us.pdf",
        "body": "In the ChipStakingPool contract, users can deposit native tokens to get Lots and claim refunds to get the native back. When calling these two functions, these two functions will check the MerkleProof signed by the central. The claimRefund function will also check whether the user claimed before by checking the userRefundCount[_msgSender()] is larger than 0. If the signed MerkleProof quantity is not the same as the users deposit. There will be a situation where the user will not be able to call the claimRefund function again to withdraw native tokens after claiming refunds once. ",
        "labels": [
            "SlowMist",
            "Ultiverse - Chips Contract",
            "Type: Design Logic Audit",
            "Severity: Information"
        ]
    },
    {
        "title": "Transaction reordering issues",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - wault.finance(WUSD)_en-us.pdf",
        "body": "(1) In commit: 91c541c2f1c0ac781ddcfb2be6a62555a5e1e8d1, the swapExactTokensForTokensSupportingFeeOnTransferTokens in the stake function is not checked for slippage. https://github.com/WaultFinance/WUSD/blob/91c541c2f/WUSDMaster.sol#L716-L722 function stake(uint256 amount) external nonReentrant { require(amount > 0, 'amount cant be zero'); require(wusdClaimAmount[msg.sender] == 0, 'you have to claim first'); require(amount <= maxStakeAmount, 'amount too high'); usdt.safeTransferFrom(msg.sender, address(this), amount); if(feePermille > 0) { uint256 feeAmount = amount * feePermille / 1000; usdt.safeTransfer(treasury, feeAmount); amount = amount - feeAmount; } uint256 wexAmount = amount * wexPermille / 1000; usdt.approve(address(wswapRouter), wexAmount); wswapRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens( wexAmount, 0, swapPath, address(this), block.timestamp ); wusdClaimAmount[msg.sender] = amount; wusdClaimBlock[msg.sender] = block.number; emit Stake(msg.sender, amount); } 9 (2) In commit: de61d93cd7a35213484827cf32533919c34e732e amountOutMin is the parameter that limits the slippage, but it is entered by the user, the maxStakeAmount is added, but this limit can still be bypassed by sorting multiple transactions. https://github.com/WaultFinance/WUSD/blob/de61d93cd7a35213484827cf32533919c34e732e/WUSDMas ter.sol#L808-L834 function stake(uint256 amount, uint256 amountOutMin) external nonReentrant whenNotPaused { require(amount > 0, 'amount cant be zero'); require(wusdClaimAmount[msg.sender] == 0, 'you have to claim first'); require(amount <= maxStakeAmount, 'amount too high'); usdt.safeTransferFrom(msg.sender, address(this), amount); if(feePermille > 0) { uint256 feeAmount = amount * feePermille / 1000; usdt.safeTransfer(treasury, feeAmount); amount = amount - feeAmount; } wusd.mint(address(this), amount); uint256 wexAmount = amount * wexPermille / 1000; usdt.approve(address(wswapRouter), wexAmount); wswapRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens( wexAmount, amountOutMin, swapPath, address(this), block.timestamp ); wusdClaimAmount[msg.sender] = amount; wusdClaimBlock[msg.sender] = block.number; emit Stake(msg.sender, amount); } (3) In commit: 5f50a2c77828c70299e8a9217cfbb926b8c1, the maxStakePerBlock is added, but this limit can still be bypassed by sorting multiple transactions in multiple blocks. 10 https://github.com/WaultFinance/WUSD/blob/5f50a2c77828c70299e8a9217cfbb926b8c1/WUSDMaster. sol#L819-L851 function stake(uint256 amount, uint256 amountOutMin) external nonReentrant whenNotPaused { require(amount > 0, 'amount cant be zero'); require(wusdClaimAmount[msg.sender] == 0, 'you have to claim first'); require(amount <= maxStakeAmount, 'amount too high'); if(lastBlock != block.number) { lastBlockUsdtStaked = 0; lastBlock = block.number; } lastBlockUsdtStaked += amount; require(lastBlockUsdtStaked <= maxStakePerBlock, 'maximum stake per block exceeded'); usdt.safeTransferFrom(msg.sender, address(this), amount); if(feePermille > 0) { uint256 feeAmount = amount * feePermille / 1000; usdt.safeTransfer(treasury, feeAmount); amount = amount - feeAmount; } wusd.mint(address(this), amount); uint256 wexAmount = amount * wexPermille / 1000; usdt.approve(address(wswapRouter), wexAmount); wswapRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens( wexAmount, amountOutMin, swapPath, address(this), block.timestamp ); wusdClaimAmount[msg.sender] = amount; wusdClaimBlock[msg.sender] = block.number; emit Stake(msg.sender, amount); }",
        "labels": [
            "SlowMist",
            "wault.finance(WUSD)",
            "Type: Reordering Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Helio Money_en-us.pdf",
        "body": "Owner or special administrator accounts can operate the key functions. - auth auth auth auth auth auth auth auth - - auth auth auth - auth auth CeToken burn CeToken mint CeToken changeVault hBNB hBNB hBNB burn mint changeMinter HelioProvider liquidation HelioProvider daoBurn HelioProvider daoMint HelioProvider changeDao HelioProvider changeCeToken HelioProvider changeProxy HelioProvider changeCollateralToken HelioProvider changeOperator CerosRouter changeVault CerosRouter changeDex CerosRouter changePool CerosRouter changeProvider OwnableUpgradeable renounceOwnership OwnableUpgradeable transferOwnership CeVaultV2 updateStorage MasterVault _updateCerosStrategyDebt MasterVault depositAllToStrategy MasterVault depositToStrategy MasterVault withdrawFromStrategy MasterVault withdrawAllFromStrategy MasterVault setStrategy MasterVault retireStrat MasterVault migrateStrategy MasterVault withdrawFee MasterVault setDepositFee MasterVault setWithdrawalFee MasterVault addManager MasterVault removeManager MasterVault changeProvider MasterVault changeFeeReceiver MasterVault changeStrategyAllocation WaitingPool addToQueue WaitingPool tryRemove WaitingPool setCapLimit SlidingWindowOracle _authorizeUpgrade UUPSUpgradeable upgradeTo UUPSUpgradeable upgradeToAndCall PriceOracleTestnet _authorizeUpgrade PriceOracle _authorizeUpgrade BaseStrategy setStrategist BaseStrategy setRewards BnbxYieldConverterStrategy changeStakeManager CerosYieldConverterStrategy changeBinancePool CerosYieldConverterStrategy changeCeRouter EmergencyShutdown setMultiSig Ownable renounceOwnership Ownable transferOwnership Interaction addToWhitelist Interaction removeFromWhitelist Jar Jar Jar replenish setSpread setExitDelay",
        "labels": [
            "SlowMist",
            "Helio Money",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Sandwich attacks can aect slippage scope",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Helio Money_en-us.pdf",
        "body": "contracts/ceros/CerosRouter.sol function deposit() external payable override nonReentrant returns (uint256 value) { //...snip code...// uint256[] memory outAmounts = _dex.getAmountsOut(amount, path); //...snip code...// uint256[] memory amounts = _dex.swapExactETHForTokens{ value: amount }(dexABNBcAmount, path, address(this), block.timestamp + 300); realAmount = amounts[1]; //...snip code...// } function withdrawWithSlippage( address recipient, uint256 amount, uint256 outAmount ) external override nonReentrant returns (uint256 realAmount) { //...snip code...// uint256[] memory amounts = _dex.swapExactTokensForETH( realAmount, outAmount, path, recipient, block.timestamp + 300 ); //...snip code...// } Sandwich attacks, also known as MEV attacks, refer to attackers using the transaction order and execution results on the blockchain to gain additional value. This type of attack is usually carried out by miners or transaction order executors, who can gain additional value by reordering transactions or selectively including or excluding them.",
        "labels": [
            "SlowMist",
            "Helio Money",
            "Type: Reordering Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Ratio arbitrage attack vulnerability",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Helio Money_en-us.pdf",
        "body": "contracts/ceros/CeVault.sol contracts/ceros/upgrades/CeVaultV2.sol function _deposit(address account, uint256 amount) private returns (uint256) { uint256 ratio = _aBNBc.ratio(); _aBNBc.transferFrom(msg.sender, address(this), amount); uint256 toMint = (amount * 1e18) / ratio; //SlowMist// _depositors[account] += amount; // aBNBc _ceTokenBalances[account] += toMint; // mint ceToken to recipient ICertToken(_ceToken).mint(account, toMint); emit Deposited(msg.sender, account, toMint); return toMint; } function _withdraw( address owner, address recipient, uint256 amount ) private returns (uint256) { uint256 ratio = _aBNBc.ratio(); uint256 realAmount = (amount * ratio) / 1e18;//SlowMist// require( _aBNBc.balanceOf(address(this)) >= realAmount, \"not such amount in the vault\" ); uint256 balance = _ceTokenBalances[owner]; require(balance >= amount, \"insufficient balance\"); _ceTokenBalances[owner] -= amount; // BNB // burn ceToken from owner ICertToken(_ceToken).burn(owner, amount); _depositors[owner] -= realAmount; // aBNBc _aBNBc.transfer(recipient, realAmount); emit Withdrawn(owner, recipient, realAmount); return realAmount; } Here we can see that the amount of deposit and withdraw is related to the ratio. We can query the implementation of the ratio from the call chain: _aBNBc: function ratio() public view returns (uint256) { return IBondToken(_bondToken).ratio(); } _bondToken: function ratio() public view override returns (uint256) { return _ratio; } function repairRatio(uint256 newRatio) external onlyOwner { _ratio = newRatio; emit RatioUpdated(_ratio); } function updateRatio(uint256 totalRewards) external onlyOperator { uint256 totalShares = totalSharesSupply(); uint256 denominator = _totalStaked + totalRewards - _totalUnbondedBonds; _ratio = multiplyAndDivideFloor(totalShares, 1e18, denominator); // (totalShares * 1e18) / denominator; if (historicalRatios.length == 0) { historicalRatios = new uint256[](8); } if (block.timestamp - _lastUpdate > 1 days - 1 minutes) { uint256 _latestOffset = latestOffset; historicalRatios[((_latestOffset + 1) % 8)] = _ratio; latestOffset = _latestOffset + 1; _lastUpdate = block.timestamp; } emit RatioUpdated(_ratio); } The value of the ratio can be modied by Owner or through other mechanisms. We may trust the operations of the Owner, but changes in the ratio can cause serious arbitrage attacks that can be implemented without the Owner's permission. The main idea is to use MEV attacks by monitoring the transaction memory pool on the blockchain. When a transaction that increases the ratio is found, one transaction deposits the CeVault contract, and another transaction calls the withdraw function of CeVault. By adjusting the form of the transaction fees, these two transactions are placed before and after the ratio change transaction, allowing direct get aBNBc in CeVault. Asset changes like this: Tx1: deposit: 100 aBNBc Tx2: repairRatio: 1-->1.2 Tx3: withdraw: 120 aBNBc",
        "labels": [
            "SlowMist",
            "Helio Money",
            "Type: Unsafe External Call Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Missing check return value",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Helio Money_en-us.pdf",
        "body": "Code location: _aBNBc.transferFrom(msg.sender,address(this),amount) (CeVault.sol#70) _aBNBc.transfer(recipient,availableYields) (CeVault.sol#105) _aBNBc.transfer(recipient,realAmount) (CeVault.sol#143) _certToken.transferFrom(owner,address(this),amount) (CerosRouter.sol#125) _certToken.transfer(recipient,profit) (CerosRouter.sol#165) IERC20(wBnbToken).approve(dexAddress,type()(uint256).max) (CerosRouter.sol#59) IERC20(certToken).approve(dexAddress,type()(uint256).max) (CerosRouter.sol#60) IERC20(certToken).approve(bondToken,type()(uint256).max) (CerosRouter.sol#61) IERC20(certToken).approve(pool,type()(uint256).max) (CerosRouter.sol#62) IERC20(certToken).approve(vault,type()(uint256).max) (CerosRouter.sol#63) _certToken.approve(address(_vault),0) (CerosRouter.sol#250) _certToken.approve(address(_vault),type()(uint256).max) (CerosRouter.sol#252) IERC20(_wBnbAddress).approve(address(_dex),0) (CerosRouter.sol#256) _certToken.approve(address(_dex),0) (CerosRouter.sol#257) IERC20(_wBnbAddress).approve(address(_dex),type()(uint256).max) (CerosRouter.sol#260) _certToken.approve(address(_dex),type()(uint256).max) (CerosRouter.sol#261) _certToken.approve(address(_pool),0) (CerosRouter.sol#266) _certToken.approve(address(_pool),type()(uint256).max) (CerosRouter.sol#268) IERC20(_ceToken).approve(daoAddress,type()(uint256).max) (HelioProvider.sol#67) _ceRouter.withdrawABNBc(recipient,amount) (HelioProvider.sol#155) _dao.deposit(account,address(_ceToken),amount) (HelioProvider.sol#174) _dao.withdraw(account,address(_ceToken),amount) (HelioProvider.sol#178) IERC20(_ceToken).approve(address(_dao),0) (HelioProvider.sol#194) IERC20(_ceToken).approve(address(_dao),type()(uint256).max) (HelioProvider.sol#196) IERC20(_ceToken).approve(address(_dao),0) (HelioProvider.sol#200) IERC20(_ceToken).approve(address(_dao),type()(uint256).max) (HelioProvider.sol#202) IERC20Upgradeable(_rewardsToken).approve(address(target),reward) (mediator/ElipsisMediator.sol#59) _bnbxToken.approve(destination,type()(uint256).max) (strategy/BnbxYieldConverterStrategy.sol#58) _bnbxToken.approve(address(_stakeManager),0) (strategy/BnbxYieldConverterStrategy.sol#313) _bnbxToken.approve(address(_stakeManager),type()(uint256).max) (strategy/BnbxYieldConverterStrategy.sol#315) _certToken.approve(binancePool,type()(uint256).max) (strategy/CerosYieldConverterStrategy.sol#40) _certToken.approve(address(_binancePool),0) (strategy/CerosYieldConverterStrategy.sol#146) _certToken.approve(address(_binancePool),type()(uint256).max) (strategy/CerosYieldConverterStrategy.sol#148) _snBnbToken.approve(destination,type()(uint256).max) (strategy/SnBnbYieldConverterStrategy.sol#57) _snBnbToken.approve(address(_stakeManager),0) (strategy/SnBnbYieldConverterStrategy.sol#309) _snBnbToken.approve(address(_stakeManager),type()(uint256).max) (strategy/SnBnbYieldConverterStrategy.sol#311) hay.transferFrom(address(receiver), address(this), total)(contracts/flash.sol#110) hay.transfer(keeper,hayBal) (libraries/AuctionProxy.sol#39) hay.transfer(keeper,hayBal) (libraries/AuctionProxy.sol#62) hay.transferFrom(msg.sender,address(this),hayMaxAmount) (libraries/AuctionProxy.sol#83) hay.transfer(receiverAddress,hayBal) (libraries/AuctionProxy.sol#99) hay.approve(hayJoin_,type()(uint256).max) (Interaction.sol#103) hay.approve(address(hayJoin),0) (Interaction.sol#109) hay.approve(hayJoin_,type()(uint256).max) (Interaction.sol#118) hay.approve(address(hayJoin),type()(uint256).max) (Interaction.sol#122) IERC20Upgradeable(hay).transferFrom(msg.sender,address(this),wad) (vow.sol#99) Not verifying the return value may lead to logical errors.",
        "labels": [
            "SlowMist",
            "Helio Money",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Missing zero address validation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Helio Money_en-us.pdf",
        "body": "Code locations: CeToken.changeVault(address).vault (CeToken.sol#47) CeVault.changeRouter(address).router (CeVault.sol#194) CerosRouter.changeProvider(address).provider (CerosRouter.sol#271) hBNB.changeMinter(address).minter (hBNB.sol#42) HelioProvider.initialize(address,address,address,address,address,address).certToken (HelioProvider.sol#51) HelioProvider.initialize(address,address,address,address,address,address).ceToken (HelioProvider.sol#52) HelioProvider.changeCeToken(address).ceToken (HelioProvider.sol#199) HelioProvider.changeProxy(address).auctionProxy (HelioProvider.sol#205) HelioProvider.changeOperator(address).operator (HelioProvider.sol#213) MasterVault.initialize(uint256,uint256,uint8,address,address).ceToken (masterVault/MasterVault.sol#86) MasterVault.withdrawETH(address,uint256).account (masterVault/MasterVault.sol#126) PriceOracle.initialize(address,IMovingWindowOracle,bool,address,address)._tokenIn (oracle/PriceOracle.sol#22) PriceOracle.initialize(address,IMovingWindowOracle,bool,address,address)._wbnb (oracle/PriceOracle.sol#25) PriceOracle.initialize(address,IMovingWindowOracle,bool,address,address)._usd (oracle/PriceOracle.sol#26) PriceOracleTestnet.initialize(address,IMovingWindowOracle,bool)._tokenIn (oracle/PriceOracleTestnet.sol#31) SlidingWindowOracle.initialize(address,uint256,uint8).factory_ (oracle/SlidingWindowOracle.sol#46) BnbxYieldConverterStrategy.distributeManual(address).recipient (strategy/BnbxYieldConverterStrategy.sol#253) SnBnbYieldConverterStrategy.distributeManual(address).recipient (strategy/SnBnbYieldConverterStrategy.sol#253) StkBnbStrategy.distributeManual(address).recipient (strategy/StkBnbStrategy.sol#280) Interaction.setWhitelistOperator(address).usr (Interaction.sol#59) Interaction.initialize(address,address,address,address,address,address,address).dog_ (Interaction.sol#86) Jar.initialize(string,string,address,uint256,uint256,uint256)._hayToken (jar.sol#88) Clipper.file(bytes32,address).data (clip.sol#166) Dog.file(bytes32,address).data (dog.sol#133) EmergencyShutdown.constructor(address,address)._vat (es.sol#19) EmergencyShutdown.constructor(address,address)._multisig (es.sol#19) EmergencyShutdown.setMultiSig(address)._multisig (es.sol#28) Vow.initialize(address,address,address)._hayJoin (vow.sol#59) Vow.initialize(address,address,address).multisig_ (vow.sol#59) Vow.file(bytes32,address).data (vow.sol#78)",
        "labels": [
            "SlowMist",
            "Helio Money",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Performs a multiplication on the result of a division",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Helio Money_en-us.pdf",
        "body": "- price = oneTokenOut / amountOut * 10 ** 18 (oracle/PriceOracleTestnet.sol#55) - d /= pow2 (oracle/libraries/FullMath.sol#23) - r *= 2 - d * r (oracle/libraries/FullMath.sol#27) - d /= pow2 (oracle/libraries/FullMath.sol#23) - r *= 2 - d * r (oracle/libraries/FullMath.sol#28) - d /= pow2 (oracle/libraries/FullMath.sol#23) - r *= 2 - d * r (oracle/libraries/FullMath.sol#29) - d /= pow2 (oracle/libraries/FullMath.sol#23) - r *= 2 - d * r (oracle/libraries/FullMath.sol#30) - d /= pow2 (oracle/libraries/FullMath.sol#23) - r *= 2 - d * r (oracle/libraries/FullMath.sol#31) - d /= pow2 (oracle/libraries/FullMath.sol#23) - r *= 2 - d * r (oracle/libraries/FullMath.sol#32) - d /= pow2 (oracle/libraries/FullMath.sol#23) - r *= 2 - d * r (oracle/libraries/FullMath.sol#33) - d /= pow2 (oracle/libraries/FullMath.sol#23) - r *= 2 - d * r (oracle/libraries/FullMath.sol#34) - l /= pow2 (oracle/libraries/FullMath.sol#24) - l * r (oracle/libraries/FullMath.sol#35) - poolTokens = (poolTokensToBurn * 1e11) / (1e11 - stakePool.config().fee.withdraw) (strategy/StkBnbStrategy.sol#188) - poolTokensFee = (poolTokens * stakePool.config().fee.withdraw) / 1e11 (strategy/StkBnbStrategy.sol#198) - x = xxRound_rpow_asm_0 / b (hMath.sol#19) - zx_rpow_asm_0 = z * x (hMath.sol#21) - d /= pow2 (oracle/libraries/FullMath.sol#23) - r *= 2 - d * r (oracle/libraries/FullMath.sol#27) - d /= pow2 (oracle/libraries/FullMath.sol#23) - r *= 2 - d * r (oracle/libraries/FullMath.sol#28) - d /= pow2 (oracle/libraries/FullMath.sol#23) - r *= 2 - d * r (oracle/libraries/FullMath.sol#29) - d /= pow2 (oracle/libraries/FullMath.sol#23) - r *= 2 - d * r (oracle/libraries/FullMath.sol#30) - d /= pow2 (oracle/libraries/FullMath.sol#23) - r *= 2 - d * r (oracle/libraries/FullMath.sol#31) - d /= pow2 (oracle/libraries/FullMath.sol#23) - r *= 2 - d * r (oracle/libraries/FullMath.sol#32) - d /= pow2 (oracle/libraries/FullMath.sol#23) - r *= 2 - d * r (oracle/libraries/FullMath.sol#33) - d /= pow2 (oracle/libraries/FullMath.sol#23) - r *= 2 - d * r (oracle/libraries/FullMath.sol#34) - l /= pow2 (oracle/libraries/FullMath.sol#24) - l * r (oracle/libraries/FullMath.sol#35) - x = xxRound_rpow_asm_0 / b (abaci.sol#159) - zx_rpow_asm_0 = z * x (abaci.sol#161) - x = xxRound_rpow_asm_0 / b (abaci.sol#249) - zx_rpow_asm_0 = z * x (abaci.sol#251) - rate = wad / timeline (jar.sol#141) - leftover = remaining * rate (jar.sol#144) - x = xxRound_rpow_asm_0 / b (hMath.sol#19) - zx_rpow_asm_0 = z * x (hMath.sol#21) Solidity's integer division truncates. Thus, performing division before multiplication can lead to precision loss.",
        "labels": [
            "SlowMist",
            "Helio Money",
            "Type: Arithmetic Accuracy Deviation Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Anyone can call initialize on the logic contract",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Helio Money_en-us.pdf",
        "body": "contracts/ceros/upgrades/CeVaultV2.sol 33,5: function initialize( contracts/ceros/upgrades/HelioProviderV2.sol 43,5: function initialize( contracts/ceros/CerosRouter.sol 41,5: function initialize( contracts/ceros/CeToken.sol 31,5: function initialize(string calldata _name, string calldata _symbol) contracts/ceros/CeVault.sol 33,5: function initialize( contracts/ceros/hBNB.sol 29,5: function initialize() external initializer { contracts/ceros/HelioProvider.sol 49,5: function initialize( contracts/masterVault/MasterVault.sol 82,5: function initialize( contracts/masterVault/WaitingPool.sol 28,5: function initialize(address _masterVault, uint256 _capLimit) external initializer { contracts/mediator/ElipsisMediator.sol 43,5: function initialize(address targetContract) public initializer { contracts/oracle/interfaces/IUniswapV2Pair.sol 96,3: function initialize(address, address) external; contracts/oracle/BnbOracle.sol 11,5: function initialize(address aggregatorAddress) external initializer { contracts/oracle/BusdOracle.sol 11,5: function initialize(address aggregatorAddress) external initializer { contracts/oracle/HelioOracle.sol 17,5: function initialize(uint256 initialPrice) public initializer { contracts/oracle/PriceOracle.sol 21,3: function initialize( contracts/oracle/PriceOracleTestnet.sol 30,3: function initialize( contracts/oracle/SlidingWindowOracle.sol 45,3: function initialize( contracts/strategy/BnbxYieldConverterStrategy.sol 46,5: function initialize( contracts/strategy/CerosYieldConverterStrategy.sol 27,5: function initialize( contracts/strategy/SnBnbYieldConverterStrategy.sol 45,5: function initialize( contracts/strategy/StkBnbStrategy.sol 58,5: function initialize( contracts/abaci.sol 52,5: function initialize() external initializer { 123,5: function initialize() external initializer { 214,5: function initialize() external initializer { contracts/clip.sol 127,5: function initialize(address vat_, address spotter_, address dog_, bytes32 ilk_) external initializer { contracts/dog.sol 103,5: function initialize(address vat_) external initializer { contracts/flash.sol 58,5: function initialize(address _vat, address _hay, address _hayJoin, address _vow) external initializer { contracts/hay.sol 59,5: function initialize(uint256 chainId_, string memory symbol_, uint256 supplyCap_) external initializer { contracts/HelioRewards.sol 65,5: function initialize(address vat_, uint256 poolLimit_ ) public initializer { contracts/HelioToken.sol 28,5: function initialize(uint256 rewardsSupply_, address rewards_) public initializer { contracts/Interaction.sol 80,5: function initialize( contracts/jar.sol 88,5: function initialize(string memory _name, string memory _symbol, address _hayToken, uint _spread, uint _exitDelay, uint _flashLoanDelay) external initializer { contracts/join.sol 89,5: function initialize(address vat_, bytes32 ilk_, address gem_) external initializer { 149,5: function initialize(address vat_, address hay_) external initializer { contracts/jug.sol 54,5: function initialize(address vat_) external initializer { contracts/lock.sol 64,5: function initialize() external initializer { contracts/spot.sol 56,5: function initialize(address vat_) external initializer { contracts/vat.sol 74,5: function initialize() public initializer { contracts/vow.sol 59,5: function initialize(address vat_, address _hayJoin, address multisig_) external initializer { Anyone can call initialize on the logic contract.",
        "labels": [
            "SlowMist",
            "Helio Money",
            "Type: Race Conditions Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "vaultToken burned may exceed the actual number needed",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Helio Money_en-us.pdf",
        "body": "contracts/masterVault/MasterVault.sol function withdrawETH(address account, uint256 amount) external override nonReentrant whenNotPaused onlyProvider returns (uint256 shares) { address src = msg.sender; ICertToken(vaultToken).burn(src, amount); uint256 ethBalance = totalAssetInVault(); shares = _assessFee(amount, withdrawalFee); if(ethBalance < shares) { payable(account).transfer(ethBalance); uint256 withdrawn = withdrawFromActiveStrategies(account, shares - ethBalance); shares = ethBalance + withdrawn; } else { payable(account).transfer(shares); } emit Withdraw(src, src, src, amount, shares); return amount; } When Strategy balance is not enough, the actual withdrawn amount return by withdrawFromActiveStrategies will lower than shares - ethBalance passed, it means the provider burn amount but do not get enough native token.",
        "labels": [
            "SlowMist",
            "Helio Money",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Missing check BnbOracle status",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Helio Money_en-us.pdf",
        "body": "contracts/oracle/BnbOracle.sol function peek() public view returns (bytes32, bool) { ( /*uint80 roundID*/, int price, /*uint startedAt*/, /*uint timeStamp*/, /*uint80 answeredInRound*/ ) = priceFeed.latestRoundData(); if (price < 0) { return (0, false); } return (bytes32(uint(price) * (10**10)), true); } In order to get a correct price, we need to check key values returned by priceFeed.",
        "labels": [
            "SlowMist",
            "Helio Money",
            "Type: Unsafe External Call Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Upgrading contracts may introduce new risks",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Helio Money_en-us.pdf",
        "body": "contracts/oracle/HelioOracle.sol contracts/oracle/PriceOracle.sol contracts/oracle/SlidingWindowOracle.sol The Proxy can upgrade the contract by calling upgradeTo/upgradeToAndCall , and upgrading the contract may introduce new risks.",
        "labels": [
            "SlowMist",
            "Helio Money",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "HelioOracle owner is never initialized",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Helio Money_en-us.pdf",
        "body": "contracts/oracle/HelioOracle.sol function changePriceToken(uint256 price_) external { require(msg.sender == _owner, \"HelioOracle/forbidden\"); price = price_; emit PriceChanged(price); } _owner is never initialized, changePriceToken call will fail in any condition.",
        "labels": [
            "SlowMist",
            "Helio Money",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "HelioOracle price oracle is not rigorous",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Helio Money_en-us.pdf",
        "body": "contracts/oracle/HelioOracle.sol function changePriceToken(uint256 price_) external { require(msg.sender == _owner, \"HelioOracle/forbidden\"); price = price_; emit PriceChanged(price); } This oracle price is too simple, there is not parameters for determining the validity of prices, such as timestamp.",
        "labels": [
            "SlowMist",
            "Helio Money",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Oracle price should not return 0",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Helio Money_en-us.pdf",
        "body": "contracts/HelioRewards.sol function helioPrice() public view returns(uint256) { // 1 HAY is helioPrice() helios (bytes32 price, bool has) = oracle.peek(); if (has) { return uint256(price); } else { return 0; } } contracts/Interaction.sol function collateralPrice(address token) public view returns (uint256) { CollateralType memory collateralType = collaterals[token]; _checkIsLive(collateralType.live); (PipLike pip,) = spotter.ilks(collateralType.ilk); (bytes32 price, bool has) = pip.peek(); if (has) { return uint256(price); } else { return 0; } } Price oracle should break the operation when peek an error, instead of return 0.",
        "labels": [
            "SlowMist",
            "Helio Money",
            "Type: Unsafe External Call Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "ERC777 reentrancy risks",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Helio Money_en-us.pdf",
        "body": "contracts/strategy/StkBnbStrategy.sol function _withdraw(address recipient, uint256 amount) internal returns (uint256) { //... stkBNB.send(address(stakePool), poolTokens, \"\"); // save it so that we can later dispatch the amount to the recipient on claim withdrawReqs[_endIndex++] = WithdrawRequest(recipient, value); // keep track of _netDeposits in StakePool _bnbDepositsInStakePool -= value; return value + ethBalance; } stkBNB is a ERC777 token , ERC777 tokens are vulnerable to reentrancy attacks due to a design aw.",
        "labels": [
            "SlowMist",
            "Helio Money",
            "Type: Reentrancy Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Missing events access control",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Helio Money_en-us.pdf",
        "body": "MasterVault._updateCerosStrategyDebt() MasterVault.withdrawFee() BnbxYieldConverterStrategy._deposit() BnbxYieldConverterStrategy._withdraw() BnbxYieldConverterStrategy._distributeFund() BnbxYieldConverterStrategy._harvestTo() CerosYieldConverterStrategy._deposit() CerosYieldConverterStrategy._withdraw() CerosYieldConverterStrategy._harvestTo() SnBnbYieldConverterStrategy._deposit() SnBnbYieldConverterStrategy.withdrawInToken() SnBnbYieldConverterStrategy._withdraw() SnBnbYieldConverterStrategy._distributeFund() SnBnbYieldConverterStrategy._harvestTo() StkBnbStrategy._deposit() StkBnbStrategy.withdrawInToken() StkBnbStrategy._withdraw() StkBnbStrategy.harvest()",
        "labels": [
            "SlowMist",
            "Helio Money",
            "Type: Malicious Event Log Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Reentry prevention best practices",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Helio Money_en-us.pdf",
        "body": "contracts/HelioRewards.sol function claim(uint256 amount) external { //... } contracts/Interaction.sol function deposit( address participant, address token, uint256 dink ) external whitelisted(participant) returns (uint256) { } function borrow(address token, uint256 hayAmount) external returns (uint256) { //... } function payback(address token, uint256 hayAmount) external returns (int256) { //... } Not apply check-eects-interactions pattern when making external calls in these functions.",
        "labels": [
            "SlowMist",
            "Helio Money",
            "Type: Reentrancy Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing check return value",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Helio Money_en-us.pdf",
        "body": "Code location: jug.drip(collateralType.ilk) (Interaction.sol#145) jug.drip(collateralType.ilk) (Interaction.sol#309) _deactivateStrategy(strategy)(contracts/masterVault/MasterVault.sol#315) _depositToStrategy(strategies[i], depositAmount) (contracts/masterVault/MasterVault.sol#342) Not verifying the return value may lead to logical errors.",
        "labels": [
            "SlowMist",
            "Helio Money",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - wBETH_en-us.pdf",
        "body": "1.In the UnwrapTokenV1 contract, the owner role can set the operatorAddress, the rechargeAddress, the ethBackAddress, the ethStaked address, and the lockTime. Wrong conguration and sudden modication will aect the user's normal withdrawal request and claim. ",
        "labels": [
            "SlowMist",
            "wBETH",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "call() should be used instead of transfer()",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - wBETH_en-us.pdf",
        "body": "The transfer() and send() functions forward a xed amount of 2300 gas. Historically, it has often been recommended to use these functions for value transfers to guard against reentrancy attacks. However, the gas cost of EVM instructions may change signicantly during hard forks which may break already deployed contract systems that make xed assumptions about gas costs. For example. EIP 1884 broke several existing smart contracts due to a cost increase in the SLOAD instruction. ",
        "labels": [
            "SlowMist",
            "wBETH",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Preemptive Initialization",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - wBETH_en-us.pdf",
        "body": "By calling the initialize and deploy functions to initialize the contracts, there is a potential issue that malicious attackers preemptively call the initialize function to initialize. ",
        "labels": [
            "SlowMist",
            "wBETH",
            "Type: Race Conditions Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Possible calculation truncation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - wBETH_en-us.pdf",
        "body": "In the RateLimit contract, the amountToReplenish is calculated by the division (secondsSinceAllowanceSet * maxAllowances[caller]) / intervals[caller]; . If the value of the numerator is less than intervals[caller], this division can truncate towards 0. Since the result of the division is returned by the _getReplenishAmount function and is used in the _replenishAllowance function to update the callers allowance, this truncation can lead to a failure in updating the callers allowance. ",
        "labels": [
            "SlowMist",
            "wBETH",
            "Type: Arithmetic Accuracy Deviation Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Multiple Solidity versions in use",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - wBETH_en-us.pdf",
        "body": "Throughout the code base there are dierent versions of Solidity being used. Token contracts are specically using version 0.6.12 while other contracts allow compiling with version 0.8.6.",
        "labels": [
            "SlowMist",
            "wBETH",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Dev address setting enhancement suggestions",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - wBETH_en-us.pdf",
        "body": "In the can set the StakedTokenV1 and StakedTokenV2 contracts, the owner role can set the ethReceiver address to move the eth. If the address is an EOA address, in a scenario where the private keys are leaked, the teams revenue will be stolen. ",
        "labels": [
            "SlowMist",
            "wBETH",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Inability to claim due to insucient availableAllocateAmount",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - wBETH_en-us.pdf",
        "body": "In the WrapTokenV2ETH and WrapTokenV2BSC contract, users can call the requestWithdrawEth function to burn their wbeth to withdraw their unwrap_ETH tokens. In this function, the withdraw operation is executed by the UnwrapTokenV1 requestWithdraw function. And in the requestWithdraw function, the _currentIndex value will be increased by the nextIndex++ self-increment. Once the availableAllocateAmount is less than the _ethAmount or the startAllocatedEthIndex is not equal to the currentIndex , the if judgment will pass to execute the else part only, and the startAllocatedEthIndex will not self-increment. This can lead to the allocation failing that users can not call the claimWithdraw function to withdraw their eth. Only in the UnwrapTokenV1 contract, the operator role can call the allocate function to allocate availableAllocateAmount of ethAmount to make the startAllocatedEthIndex++ self-increment to match the if judgment and the claimWithdraws allocated value will be set to true. ",
        "labels": [
            "SlowMist",
            "wBETH",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Potential error in the calculation of the withdrawal amount",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist_Audit_Report_StakeStone_NativeLendingETHStrategy&Symbi_en-us.pdf",
        "body": "In the NativeLendingETHStrategy contract, the owner role can call the withdrawFromNativeByAmount function and the withdrawFromNativeByShare function to redeem the AquaLpToken for ETH. The nal calculated withdrawal amount is simply the dierence between the current ETH balance of the contract and the ETH balance before the redemption operation. However, the redemption operation rst converts the AquaLpToken back to WETH tokens, and then uses the WETH tokens to obtain ETH. If there are surplus WETH tokens in the contract before the redemption (for example, if other users have mistakenly transferred them in), then this excess WETH amount will also be included in the calculated withdrawal amount. Code Location: contracts/strategies/NativeLendingETHStrategy.sol#L44-66 function withdrawFromNativeByAmount( uint256 _amount ) external onlyOwner returns (uint256 withdrawAmount) { uint256 beforeBalance = address(this).balance; IAquaLpToken(LPTOKEN).redeemUnderlying(_amount); WETH.withdraw(WETH.balanceOf(address(this))); withdrawAmount = address(this).balance - beforeBalance; } function withdrawFromNativeByShare( uint256 _share ) external onlyOwner returns (uint256 withdrawAmount) { uint256 beforeBalance = address(this).balance; IAquaLpToken(LPTOKEN).redeem(_share); WETH.withdraw(WETH.balanceOf(address(this))); withdrawAmount = address(this).balance - beforeBalance; }",
        "labels": [
            "SlowMist",
            "SlowMist_Audit_Report_StakeStone_NativeLendingETHStrategy&Symbi",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Missing event records",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist_Audit_Report_StakeStone_NativeLendingETHStrategy&Symbi_en-us.pdf",
        "body": "In the NativeLendingETHStrategy contract, the owner role can use the ETH in the contract to mint AquaLpToken, and then use the AquaLpToken to redeem for ETH, but there is no event record. Code Location: contracts/strategies/NativeLendingETHStrategy.sol#L28-66 function depositIntoNative( uint256 _amount ) external onlyOwner returns (uint256 mintAmount) { ... } function withdrawFromNativeByAmount( uint256 _amount ) external onlyOwner returns (uint256 withdrawAmount) { ... } function withdrawFromNativeByShare( uint256 _share ) external onlyOwner returns (uint256 withdrawAmount) { ... }",
        "labels": [
            "SlowMist",
            "SlowMist_Audit_Report_StakeStone_NativeLendingETHStrategy&Symbi",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing zero value check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist_Audit_Report_StakeStone_NativeLendingETHStrategy&Symbi_en-us.pdf",
        "body": "In the NativeLendingETHStrategy contract, The owner role does not check whether the input amount for minting and redeeming AquaLpToken tokens is 0 or not. If the input value is 0, the operation can still be executed successfully, but it will consume gas. Code Location: contracts/strategies/NativeLendingETHStrategy.sol#L28-66 function depositIntoNative( uint256 _amount ) external onlyOwner returns (uint256 mintAmount) { ... } function withdrawFromNativeByAmount( uint256 _amount ) external onlyOwner returns (uint256 withdrawAmount) { ... } function withdrawFromNativeByShare( uint256 _share ) external onlyOwner returns (uint256 withdrawAmount) { ... }",
        "labels": [
            "SlowMist",
            "SlowMist_Audit_Report_StakeStone_NativeLendingETHStrategy&Symbi",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Lack of external interest rate ination vulnerability check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist_Audit_Report_StakeStone_NativeLendingETHStrategy&Symbi_en-us.pdf",
        "body": "In the NativeLendingETHStrategy and SymbioticDepositWstETHStrategy contracts, the owner role can separately call the depositIntoNative function and the depositIntoSymbiotic function to deposit the funds in the strategy contract into a third-party protocol, and mint the corresponding deposit certicates. However, the functions do not check whether the minted deposit shares are zero in quantity. Since the code of the third-party protocol is not within the scope of this audit, if there is an interest rate ination vulnerability in the code of the third-party protocol, the funds in the contract may be damaged due to malicious users front-running. For details on the interest rate ination vulnerability, please refer to the following link: https://blog.openzeppelin.com/a-novel-defense-against-erc4626-ination-attacks Code Location: contracts/strategies/NativeLendingETHStrategy.sol#L28-42 function depositIntoNative( uint256 _amount ) external onlyOwner returns (uint256 mintAmount) { ... IAquaLpToken(LPTOKEN).mint(_amount); mintAmount = IAquaLpToken(LPTOKEN).balanceOf(address(this)) - beforeLPBalance; } contracts/strategies/SymbioticDepositWstETHStrategy.sol#L151-169 function depositIntoSymbiotic( uint256 _wstETHAmount ) external onlyOwner returns (uint256 shares) { ... shares = ICollateral(collateralAddr).deposit( address(this), _wstETHAmount ); emit DepositIntoSymbiotic( collateralAddr, address(this), _wstETHAmount, shares ); }",
        "labels": [
            "SlowMist",
            "SlowMist_Audit_Report_StakeStone_NativeLendingETHStrategy&Symbi",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Potentially unclaimed rewards",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the SingleTokenStaking contract, the calculation of staking rewards mainly depends on the rewardSpeed variable. The contract calculates the global reward accumulation accuedReward based on rewardSpeed and the block interval. When a user settles rewards, the dierence between the current global accuedReward and the user's last settled accuedReward is multiplied by the user's deposit amount to determine the user's claimable rewards. It is important to note that the contract does not limit users' minimum deposit amount. This means that when a user deposits an extremely small amount and rewardSpeed is set relatively low (for example, if the user deposits 1 wei and rewardSpeed is less than 1e18), the user's small rewards may be truncated due to decimal rounding during the reward settlement process. This may result in the user's rewards being left unclaimed in the contract. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Arithmetic Accuracy Deviation Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Optimizable refreshGlobalState",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the SingleTokenStaking contract, the refreshGlobalState function is used to update the global reward state accuedReward and update the accumulated rewards and the current block to the corresponding global variables. It is important to note that there may be a large number of users performing operations such as depositing, withdrawing, and claiming rewards within the same block, which will result in frequent calls to the refreshGlobalState function. This means that although accuedReward will not be accumulated within the same block, users still need to pay some gas to update gDeposits.accuedReward and gDeposits.accuedBlock , which is unnecessary within the same block. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Compatibility issues with deationary tokens",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the SingleTokenStaking contract, users can deposit supported tokens into the contract using the deposit function, and the addDeposit function directly records the amount of deposit tokens passed in by the user. If the token supported by the contract is deationary, the contract will actually receive fewer tokens than the deposit amount passed in by the user. This will cause the contract to record a higher user deposit than the actual amount of tokens received. When the user withdraws, it will result in a bad debt for the protocol. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Optimizable RFG token distribution method",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the RFGToken contract, the token distribution rules are hardcoded. 30% of the token supply will be allocated to liquidity, 10% will be allocated to airdrops, and the remaining tokens will be minted by the minter role. The contract uses three separate functions to mint tokens for these three dierent allocation purposes. However, it should be noted that in the claimAirdrop and claimLiquidity functions, although the tokens are minted for airdrop and liquidity purposes, the receiving addresses are not specied. The owner role can mint these tokens to any address. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Admin who has not set the Boss role",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "During the initialization of the Auction contract, the specied boss address is granted the BossRole. However, it should be noted that the BossRole is not assigned the AdminRole. This means that if the boss address experiences issues such as private key leakage, the protocol will not be able to handle the boss address through revokeRole/grantRole . ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Not checking the reasonableness of time when updating auctions",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the Auction contract, the admin role can update existing auction congurations through the updateAuction function. When updating, it checks whether the new startPrice is greater than 0, but it does not check whether the new endTime is greater than startTime. It should be noted that the admin can update an auction that has already ended to reopen it. This means that users who have already placed bids or claimed items can participate in the auction again. However, this will cause the restarted auction to conict with the previous claim/refund data. For example, if a user who successfully claimed an NFT in the previous auction wins the auction again, they will not be able to claim the new NFT successfully a second time. This does not align with the expected design. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Smart contracts cannot participate in the auction",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the Auction contract, users can participate in the auction through the bidAuction function. However, the function checks whether msg.sender is equal to tx.origin , which prevents smart contracts (including EIP4337 wallets) from participating in the auction. It should be noted that in the future, if the EIP3074 standard is approved, it may break this check. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Design Logic Audit",
            "Severity: Information"
        ]
    },
    {
        "title": "Time check when closing auction is awed",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the Auction contract, the operator can end the auction through the nishAuction function after the endTime. When performing the nishAuction operation, the endTime is checked using block.timestamp >= auction.endTime , while when performing the bidAuction operation, the endTime is checked using block.timestamp <= auction.endTime . This means that when the operator performs the nishAuction operation to set result.price exactly at the endTime, users can still perform the bidAuction operation to participate in the auction. This may not align with the intended design. It may also cause confusion for users, as they can place a bid higher than result.price at the endTime but are not included in the nal Merkle tree. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Not checking if the user's bid is as expected",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the Auction contract, users who successfully win the auction can obtain the NFT through the claimNft function. The operator sets the Merkle proof to verify the validity of the claiming user. When the user's bid price is higher than auctionResult.price , the contract processes a refund for them. However, the contract does not check whether the user's bid price is necessarily greater than or equal to auctionResult.price . If the Merkle tree erroneously includes users with bid prices lower than auctionResult.price , it may result in insucient funds in the contract for the boss role to withdraw. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Not checking if the user's bid is refundable",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the Auction contract, users who meet the refund conditions can use the operator's signature to request a refund. Theoretically, if a user is eligible to claim the NFT, the operator will not sign for them to avoid giving up their eligibility for a refund. However, the refund function does not strictly check whether the bid prices of all refunding users are less than auctionResult.price . If the operator erroneously signs a refund for a user who is eligible to claim the NFT, it will prevent the boss from withdrawing the remaining auction proceeds. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Risk of pseudo-randomness",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the Auction contract, when a user claims an NFT, the fakeRandomToken function is used to calculate the tokenId for the user. The fakeRandomToken function uses block.prevrandao , block.number , and the user-provided seed for calculation. Unfortunately, these parameters can be controlled or are already known. This allows malicious users to ensure that the tokenIds of the NFTs they obtain at specic blocks are all of high value. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Block data Dependence Vulnerability",
            "Severity: Critical"
        ]
    },
    {
        "title": "Redundant return value of adjustRandomtoken function",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the Auction contract, the adjustRandomtoken function is used to select a matching id for the user based on the current tokenId inventory. When all the inventory has been claimed, the function directly throws an error using require(false) . This makes the nal return 0 redundant because the function will never execute this return statement. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "The tokenId obtained by the user is related to the NFT inventory",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the Auction contract, the adjustRandomtoken function is used to adjust the nal tokenId based on the inventory of each tokenId's NFTs. If a user obtains the highest-value NFT but there is no inventory for this NFT, they may be assigned the lowest-value NFT instead, and vice versa. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Design Logic Audit",
            "Severity: Information"
        ]
    },
    {
        "title": "Unchecked boost bound parameters during initialization",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the initialize function of the RFGDeposit contract, when the proxy contract is initialized, parameters such as lowerBound and upperBound are passed in. However, the function does not check whether the passed-in lowerBound is less than upperBound. Incorrectly passing the corresponding values may cause the protocol to be unusable. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Rewards not settled as expected",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the RFGDeposit contract, users can make xed-term deposits through the xedDeposit function. When a user's autoRedeposit status is false, even if the user's deposit time is several times longer than the duration, only one cycle of rewards will be settled for the user. Unfortunately, the xedDeposit function does not handle the case where autoRedeposit is false. This allows users with autoRedeposit set to false to make a small deposit to the same xId after a long deposit period and still receive the full rewards, not just for one duration. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Incorrect whitelist pool check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the Pool contract, the assertCallerIsPool function is used to check whether the passed-in sender is a pool created in the stakingManager. The assertCallerIsPool function receives the msg.sender from SinglePool and CouplePool as a possible pool address, calls the poolID interface of msg.sender to obtain the pool id, and nally checks whether this pool id is valid in the stakingManager. Unfortunately, this check method is not eective. Malicious contracts can also implement the poolID interface and return a valid pool id (1~7) when called. Since the assertCallerIsPool function only checks whether the id is valid through the stakingManager contract, malicious contracts can easily bypass this check to perform malicious custodial staking and eventually exhaust the protocol's assets. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Unsafe External Call Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Unexpected rewards when staking in pairs",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the CouplePool contract, the stakingManager can stake a user's NFT through the socialStake function. When the staking has not been paired yet, CouplePool will custody the user's NFT to SinglePool to obtain SinglePool staking rewards. Once the pairing is complete, it will withdraw from SinglePool and stake in CouplePool. Theoretically, during the process of pairing, users should only receive rewards from SinglePool and not from CouplePool. Unfortunately, when SinglePool custody is performed, the user's ssInfo.stakeInfo.amount value in the CouplePool contract will be updated to the staked amount. This allows users to claim CouplePool staking rewards through the claimSocialReward function of the stakingManager contract even before the pairing is completed. Worse still, the user's ssInfo.stakeInfo.claimedToAccued has not been set at this point, so when settling rewards, calculateStakeReward will distribute large unexpected rewards to the user. Malicious users can exploit this issue to exhaust all reward tokens. Similarly, this issue also exists in the GroupPool contract. Users can still claim large rewards from GroupPool even before the three-party pairing is completed. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Manipulate boost to inuence the token id obtained in the auction",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the Auction contract, when a user claims the auctioned NFT, the token id of the NFT depends not only on the random number seed but also on the amount of the user's deposit in the RFGDeposit contract. The larger the user's deposit amount, the greater the user's boost, and the higher the probability of obtaining a high-value NFT. Unfortunately, the calculation of the boost only depends on the user's deposit amount. Users can increase their RFG deposit before claiming the NFT to improve the probability. When multiple addresses of a user have obtained NFTs, they only need to withdraw the staked RFG tokens from other addresses and transfer them to the address that needs to claim the NFT for staking before claiming the NFT, in order to increase the probability. In other words, users only need a high amount of staking and can continuously stake/unstake/transfer RFG tokens to increase the probability of obtaining high-value NFTs at a lower cost. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Redundant PoolMax enum",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the NftID library, PoolID lists an enumeration of all the pools supported by the protocol, but PoolMax is not used anywhere in the protocol, which is redundant. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Reward calculation for two stakers in GroupPool being the same user",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the GroupPool contract, when a user performs a socialUnstake/forceSocialUnstake operation, a portion of the bailed rewards of the initiator of the unstaking operation will be deducted and distributed to other users in the same group. However, it should be noted that one of the users in the same group may also be the initiator because the protocol allows the same user to provide two dierent NFTs for GroupPool staking. This means that a portion of the initiator's penalized rewards still belong to the initiator themselves. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Design Logic Audit",
            "Severity: Information"
        ]
    },
    {
        "title": "Potentially incorrect social staking reward information in GroupPool",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "As previously mentioned, GroupPool allows the same user to provide two NFTs for staking. However, during reward settlement, stakerShareReward and bailed are calculated based on three dierent staking users. Therefore, in the viewSocialStakeRewardInfo function, when obtaining the user's pendingRewards, it only considers the scenario where the three stakers are dierent users, while overlooking the possibility that two of the stakers might be the same user. This may cause the reward amount returned by the viewSocialStakeRewardInfo function to be lower than expected. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Potential Denial of Service Risk",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In Pool, users can freely choose dierent pools for staking. Theoretically, users can stake their owned NFTs in pools of dierent types or in dierent matchCodes within the same pool. The pool uses OpenZeppelin's EnumerableSet library to record the pools or matchCodes that users have joined, and retrieves all the pools or matchCodes joined by users through the values interface of EnumerableSet when claiming rewards. It is important to note that the values operation copies the entire storage space to memory. If the user participates in a large number of pools or matchCodes, the values operation will generate signicant gas costs, potentially exceeding the block's gasLimit and ultimately leading to DoS risks. Despite this, if a DoS issue arises, users can still avoid their rewards being locked by claiming rewards individually. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Denial of Service Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "The validity of the pid was not checked when creating the pool",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the StakingManager contract, operators can create pools using the createPool function, but the validity of the passed-in pid value is not checked. Theoretically, the pid of a pool should only be between 1 and 7. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "When creating a matchCode, it does not check whether the pool has been created.",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the StakingManager contract, users can create matchCodes for social staking using the createMatch2Code and createMatch3Code functions. However, when creating a matchCode, there is no check to verify if the pool corresponding to the pid has already been created. If the pool has not been created, users will be unable to successfully create a matchCode, and no error message will be thrown, which may cause confusion for users. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "There is an upper limit on the matchCodes available in the pool",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the StakingManager contract, when a user creates a matchCode for social staking, the protocol assigns a matchCode to this staking. The matchCode is obtained through the nextMatchCode function of the pool, which is calculated using poolID * 10 ** 8 + matchCodeNonce . It is important to note that if the value of matchCodeNonce exceeds 1e8, it will aect the matchCode of the next pool. In reality, it is highly unlikely for a pool to have 1e8 matchCodes, but the project team should still remain attentive to this matter. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Checks-Eects-Interactions are not followed when transferring out NFT",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the StakingManager contract, the returnNftsBackAndClaimReward function is used to transfer users' staked NFTs from the contract back to the users and claim social staking rewards for users through the claimSocialReward function. The practice of transferring assets before modifying the contract state does not comply with the Checks- Eects-Interactions pattern. Although it does not lead to reentrancy risks in the current business scenario, it cannot be guaranteed that new exploitable business scenarios will not be introduced in the future. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Optimizable reward information update",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the updateRewardInfo function of the GroupPool contract, the currently claimable social staking rewards are calculated through the calculateStakeReward function, and the rewards are distributed to the stakers. It is important to note that when users exit staking through the StakingManager contract, multiple calls to the updateRewardInfo function may be involved in a single transaction. The pendingReward for reward settlement is only greater than 0 during the rst call, and when pendingReward is 0, the updateRewardInfo function still performs reward distribution operations, which will consume a lot of unnecessary gas. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risks of excessive privilege",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the StakingManager contract, the admin role can upgrade any pool through the upgradePool function. Moreover, in the protocol, except for the InviteReward, Airdrop, RFGToken, and NftCard contracts, all other contracts use an upgradable model, where the admin of the proxy contract can arbitrarily upgrade these contracts. This leads to the risk of excessive privileges. In the Auction contract, after the auction is completed, the project team will calculate o-chain the users who can obtain NFTs and the nal auction price, and establish a Merkle proof for users to claim. This also increases the centralization risk to a certain extent. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Protocol Missing Emergency Operations Role",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "The protocol has planned for multiple roles to manage dierent contracts, but it is important to note that the protocol lacks an emergency pause functionality and a role to manage this function. When an emergency occurs in the protocol, the emergency operation role can close the protocol through the pause function to minimize losses as much as possible.",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing event records",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Match_en-us.pdf",
        "body": "In the NftCard contract, the owner can modify the URI of the NFT through the setUri function, but no event is recorded. ",
        "labels": [
            "SlowMist",
            "Match",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "4.2.1.1 Sandwich attacks issues",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - autofarm_en-us.pdf",
        "body": "The earn(), buyBack(), convertDustToEarned(), _convertMDXToEarned functions no limit slippage, there is a sandwich attacks issues. It is recommended to add a slippage limit, and the slippage parameter can only be modified by the Owner.  AutofarmV2_CrossChain/StratVLEV2.sol function earn() external whenNotPaused { if (onlyGov) { require(msg.sender == govAddress, \"!gov\"); } 6 IVenusDistribution(venusDistributionAddress).claimVenus(address(this)); uint256 earnedAmt = IERC20(venusAddress).balanceOf(address(this)); earnedAmt = distributeFees(earnedAmt); earnedAmt = buyBack(earnedAmt); if (venusAddress != wantAddress) { IPancakeRouter02(uniRouterAddress).swapExactTokensForTokens( earnedAmt, 0, venusToWantPath, address(this), now.add(600) ); } lastEarnBlock = block.number; _farm(false); //SupplywantTokenwithoutleverage,tocaterfornet-veinterestrates. }  AutofarmV2_CrossChain/StratVLEV2.sol function buyBack(uint256 _earnedAmt) internal returns (uint256) { if (buyBackRate <= 0) { return _earnedAmt; } uint256 buyBackAmt = _earnedAmt.mul(buyBackRate).div(buyBackRateMax); IPancakeRouter02(uniRouterAddress).swapExactTokensForTokens( buyBackAmt, 0, earnedToAUTOPath, buyBackAddress, now + 600 ); return _earnedAmt.sub(buyBackAmt); 7 }  AutofarmV2_CrossChain/StratX2_MDEX.sol function convertDustToEarned() public whenNotPaused { require(isAutoComp, \"!isAutoComp\"); require(!isCAKEStaking, \"isCAKEStaking\"); //Convertsdusttokensintoearnedtokens,whichwillbereinvestedonthenextearn(). //Convertstoken0dust(ifany)toearnedtokens uint256 token0Amt = IERC20(token0Address).balanceOf(address(this)); if (token0Address != earnedAddress && token0Amt > 0) { IERC20(token0Address).safeIncreaseAllowance( uniRouterAddress, token0Amt ); //Swapalldusttokenstoearnedtokens IPancakeRouter02(uniRouterAddress) .swapExactTokensForTokensSupportingFeeOnTransferTokens( token0Amt, 0, token0ToEarnedPath, address(this), now + 600 ); } //Convertstoken1dust(ifany)toearnedtokens uint256 token1Amt = IERC20(token1Address).balanceOf(address(this)); if (token1Address != earnedAddress && token1Amt > 0) { IERC20(token1Address).safeIncreaseAllowance( uniRouterAddress, token1Amt ); //Swapalldusttokenstoearnedtokens IPancakeRouter02(uniRouterAddress) .swapExactTokensForTokensSupportingFeeOnTransferTokens( 8 token1Amt, 0, token1ToEarnedPath, address(this), now + 600 ); } }  AutofarmV2_CrossChain/StratX2_MDEX.sol function _convertMDXToEarned() internal { //ConvertsMDX(ifany)toearnedtokens uint256 MDXAmt = IERC20(MDXAddress).balanceOf(address(this)); if (MDXAddress != earnedAddress && MDXAmt > 0) { IERC20(MDXAddress).safeIncreaseAllowance(uniRouterAddress, MDXAmt); //Swapalldusttokenstoearnedtokens IPancakeRouter02(uniRouterAddress) .swapExactTokensForTokensSupportingFeeOnTransferTokens( MDXAmt, 0, MDXToEarnedPath, address(this), now + 60 ); } }  AutofarmV2_CrossChain/StratX2_MDEX.sol function buyBack(uint256 _earnedAmt) internal returns (uint256) { if (buyBackRate <= 0) { return _earnedAmt; } uint256 buyBackAmt = _earnedAmt.mul(buyBackRate).div(buyBackRateMax); if (earnedAddress == AUTOAddress) { IERC20(earnedAddress).safeTransfer(buyBackAddress, buyBackAmt); } else { IERC20(earnedAddress).safeIncreaseAllowance( uniRouterAddress, 9 buyBackAmt ); IPancakeRouter02(uniRouterAddress) .swapExactTokensForTokensSupportingFeeOnTransferTokens( buyBackAmt, 0, earnedToAUTOPath, buyBackAddress, now + 600 ); } return _earnedAmt.sub(buyBackAmt); }  AutofarmV2_CrossChain/StratVLEV2.sol function earn() external whenNotPaused { if (onlyGov) { require(msg.sender == govAddress, \"!gov\"); } IVenusDistribution(venusDistributionAddress).claimVenus(address(this)); uint256 earnedAmt = IERC20(venusAddress).balanceOf(address(this)); earnedAmt = distributeFees(earnedAmt); earnedAmt = buyBack(earnedAmt); if (venusAddress != wantAddress) { IPancakeRouter02(uniRouterAddress).swapExactTokensForTokens( earnedAmt, 0, venusToWantPath, address(this), now.add(600) ); } lastEarnBlock = block.number; 10 _farm(false); //SupplywantTokenwithoutleverage,tocaterfornet-veinterestrates. } Fix Status: The issue has been fixed in this commit: b27f2cafcf51667726bd70220420707c89b75975",
        "labels": [
            "SlowMist",
            "autofarm",
            "Severity: High"
        ]
    },
    {
        "title": "4.2.2.1 Excessive authority issues",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - autofarm_en-us.pdf",
        "body": "The add function has excessive authority issues, Owner can add mining pool arbitrarily, there is a risk of stealing mining by himself, and _strat is the destination address of the final sending of funds, the owner can set this address arbitrarily, pay attention to compatibility issues with external contracts, it is recommended to set the ownership to the timelock contract, and add events to record in the add function.  AutofarmV2_CrossChain/AutoFarmV2_CrossChain.sol function add( uint256 _allocPoint, IERC20 _want, bool _withUpdate, address _strat ) public onlyOwner { if (_withUpdate) { massUpdatePools(); } totalAllocPoint = totalAllocPoint.add(_allocPoint); poolInfo.push( PoolInfo({ want: _want, allocPoint: _allocPoint, lastRewardBlock: 0, accAUTOPerShare: 0, 11 strat: _strat }) ); } Fix Status: The ownership has been transfer to timelock contract. Reference https://hecoinfo.com/tx/0xbe90b5dba8315b30a010ea957e9631154857b93d84cdb344c11b339b 5f3e5421 The authority of the Gov role is large, and the address of the external contract can be set arbitrarily. Malicious and wrong external contracts will cause the user's funds to be lost, and there is a issues of excessive authorityit is recommended to set the gov to the timelock contract.  AutofarmV2_CrossChain/StratX2.sol function setEntranceFeeFactor(uint256 _entranceFeeFactor) public { require(msg.sender == govAddress, \"!gov\"); require(_entranceFeeFactor >= entranceFeeFactorLL, \"!safe - too low\"); require(_entranceFeeFactor <= entranceFeeFactorMax, \"!safe - too high\"); entranceFeeFactor = _entranceFeeFactor; } function setWithdrawFeeFactor(uint256 _withdrawFeeFactor) public { require(msg.sender == govAddress, \"!gov\"); require(_withdrawFeeFactor >= withdrawFeeFactorLL, \"!safe - too low\"); require(_withdrawFeeFactor <= withdrawFeeFactorMax, \"!safe - too high\"); withdrawFeeFactor = _withdrawFeeFactor; } function setControllerFee(uint256 _controllerFee) public { require(msg.sender == govAddress, \"!gov\"); require(_controllerFee <= controllerFeeUL, \"too high\"); controllerFee = _controllerFee; } function setbuyBackRate(uint256 _buyBackRate) public { require(msg.sender == govAddress, \"!gov\"); 12 require(buyBackRate <= buyBackRateUL, \"too high\"); buyBackRate = _buyBackRate; } function setGov(address _govAddress) public { require(msg.sender == govAddress, \"!gov\"); govAddress = _govAddress; } function setOnlyGov(bool _onlyGov) public { require(msg.sender == govAddress, \"!gov\"); onlyGov = _onlyGov; } function setUniRouterAddress(address _uniRouterAddress) public { require(msg.sender == govAddress, \"!gov\"); uniRouterAddress = _uniRouterAddress; } function setBuyBackAddress(address _buyBackAddress) public { require(msg.sender == govAddress, \"!gov\"); buyBackAddress = _buyBackAddress; } function setRewardsAddress(address _rewardsAddress) public { require(msg.sender == govAddress, \"!gov\"); rewardsAddress = _rewardsAddress; } Fix Status: The Gov has been transfer to timelock contract. Reference https://hecoinfo.com/tx/0xfdf183915b5659473f9e8e3438c295cb859e022faa073a0a8f12c38e0a 4c257d",
        "labels": [
            "SlowMist",
            "autofarm",
            "Severity: Medium"
        ]
    },
    {
        "title": "4.2.2.2 DoS issues",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - autofarm_en-us.pdf",
        "body": "In the massUpdatePools function, if the length of poolInfo is too large, there is a risk of DoS. It is 13 recommended to limit poolInfo.length to avoid DoS caused by too large length.  AutofarmV2_CrossChain/AutoFarmV2_CrossChain.sol function massUpdatePools() public { uint256 length = poolInfo.length; for (uint256 pid = 0; pid < length; ++pid) { updatePool(pid); } } Fix Status: The issue has been fixed in this commit: b27f2cafcf51667726bd70220420707c89b75975",
        "labels": [
            "SlowMist",
            "autofarm",
            "Severity: Medium"
        ]
    },
    {
        "title": "4.2.3.1 Missing event log",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - autofarm_en-us.pdf",
        "body": "\"setEntranceFeeFactor\" function, \"setWithdrawFeeFactor\" function, \"setControllerFee\" function, \"setbuyBackRate\" function, \"setGov\" function, \"setOnlyGov\" function, \"setUniRouterAddress\" function, \"setBuyBackAddress\" function, \"setRewardsAddress\" function, no events are added to record. It is recommended to add events for recording.  AutofarmV2_CrossChain/StratX2_MDEX.sol  AutofarmV2_CrossChain/StratVLEV2.sol function setEntranceFeeFactor(uint256 _entranceFeeFactor) public { require(msg.sender == govAddress, \"!gov\"); require(_entranceFeeFactor >= entranceFeeFactorLL, \"!safe - too low\"); require(_entranceFeeFactor <= entranceFeeFactorMax, \"!safe - too high\"); entranceFeeFactor = _entranceFeeFactor; } function setWithdrawFeeFactor(uint256 _withdrawFeeFactor) public { require(msg.sender == govAddress, \"!gov\"); require(_withdrawFeeFactor >= withdrawFeeFactorLL, \"!safe - too low\"); 14 require(_withdrawFeeFactor <= withdrawFeeFactorMax, \"!safe - too high\"); withdrawFeeFactor = _withdrawFeeFactor; } function setControllerFee(uint256 _controllerFee) public { require(msg.sender == govAddress, \"!gov\"); require(_controllerFee <= controllerFeeUL, \"too high\"); controllerFee = _controllerFee; } function setbuyBackRate(uint256 _buyBackRate) public { require(msg.sender == govAddress, \"!gov\"); require(buyBackRate <= buyBackRateUL, \"too high\"); buyBackRate = _buyBackRate; } function setGov(address _govAddress) public { require(msg.sender == govAddress, \"!gov\"); govAddress = _govAddress; } function setOnlyGov(bool _onlyGov) public { require(msg.sender == govAddress, \"!gov\"); onlyGov = _onlyGov; } function setUniRouterAddress(address _uniRouterAddress) public { require(msg.sender == govAddress, \"!gov\"); uniRouterAddress = _uniRouterAddress; } function setBuyBackAddress(address _buyBackAddress) public { require(msg.sender == govAddress, \"!gov\"); buyBackAddress = _buyBackAddress; } function setRewardsAddress(address _rewardsAddress) public { require(msg.sender == govAddress, \"!gov\"); rewardsAddress = _rewardsAddress; } Fix Status: 15 The issue has been fixed in this commit: b27f2cafcf51667726bd70220420707c89b75975",
        "labels": [
            "SlowMist",
            "autofarm",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.2.3.2 Missing nonReentrant modifier",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - autofarm_en-us.pdf",
        "body": "The deposit function missing the nonReentrant modifier, it is recommended to add the nonReentrant modifier.  AutofarmV2_CrossChain/StratX2_MDEX.sol function deposit(address _userAddress, uint256 _wantAmt) public onlyOwner whenNotPaused returns (uint256) IERC20(wantAddress).safeTransferFrom( address(msg.sender), address(this), _wantAmt ); uint256 sharesAdded = _wantAmt; if (wantLockedTotal > 0 && sharesTotal > 0) { sharesAdded = _wantAmt .mul(sharesTotal) .mul(entranceFeeFactor) .div(wantLockedTotal) .div(entranceFeeFactorMax); } sharesTotal = sharesTotal.add(sharesAdded); if (isAutoComp) { _farm(); } else { wantLockedTotal = wantLockedTotal.add(_wantAmt); } return sharesAdded; 16 { } Fix Status: The issue has been fixed in this commit: b27f2cafcf51667726bd70220420707c89b75975 5.",
        "labels": [
            "SlowMist",
            "autofarm",
            "Severity: Informational"
        ]
    },
    {
        "title": "Overow issues",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - WombatExchange_en-us.pdf",
        "body": "The data type of priceStruct.expo is int32, and the return result is negative, so uint256(int256(priceStruct.expo)) will get a large value, and 10 ** uint256(int256(priceStruct.expo) will overflow. Because the compiler version used is pragma solidity ^0.8.5;`. ",
        "labels": [
            "SlowMist",
            "WombatExchange",
            "Type: Integer Overow and Underow Vulnerability",
            "Severity: Critical"
        ]
    },
    {
        "title": "Missing event record",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - WombatExchange_en-us.pdf",
        "body": "The owner has the ability to modify the values of the maxPriceAge, shouldCapEquilCovRatio, startCovRatio, endCovRatio parameters, etc. which are global variables, but any modications made to them are not recorded with events. ",
        "labels": [
            "SlowMist",
            "WombatExchange",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Excessive authority issues",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - WombatExchange_en-us.pdf",
        "body": "The Owner can modify priceIDs[_token], priceFeed, fallbackPriceFeed. This will aect the price at which the project gets oracle. The wrong price will lead to a fatal vulnerability in the project. ",
        "labels": [
            "SlowMist",
            "WombatExchange",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Redundant judgment",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - WombatExchange_en-us.pdf",
        "body": "If fromAmount is 0, the code will revert, so if (fromAmount >= 0) should be changed to if (fromAmount > 0). ",
        "labels": [
            "SlowMist",
            "WombatExchange",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "fee management suggestions",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - WombatExchange_en-us.pdf",
        "body": "If the receiving address of fee is an EOA address, there will be a single point risk of private key management. ",
        "labels": [
            "SlowMist",
            "WombatExchange",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "conditional competition issues",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - WombatExchange_en-us.pdf",
        "body": "The llPool function and the transferTipBucket function are controlled by the two roles of dev and owner respectively. When the opinions of the dev and owner are inconsistent, there will be conditional competition issues. ",
        "labels": [
            "SlowMist",
            "WombatExchange",
            "Type: Race Conditions Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Suggestions for variable type conversion",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - WombatExchange_en-us.pdf",
        "body": "The following functions when using uint256 to convert int256, it is not judged whether the variable to be converted is less than type(int256).max, and when using int256 to convert uint256, it is not judged whether the variable is greater than 0. CoreV3.quoteDepositLiquidity CoreV3.quoteWithdrawAmount CoreV3.quoteWithdrawAmountFromOtherAsset CoreV3.quoteSwap CoreV3.quoteSwapTokensForCredit CoreV3.quoteSwapCreditForTokens PoolV3._globalInvariantFunc PoolV3.globalEquilCovRatioWithCredit DynamicPoolV3._globalInvariantFunc PythPriceFeed.getLatestPrice",
        "labels": [
            "SlowMist",
            "WombatExchange",
            "Type: Others",
            "Severity: Low"
        ]
    },
    {
        "title": "Business logic is unclear",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - WombatExchange_en-us.pdf",
        "body": "The _quoteFactor function returns a xed value of 1e18, but the function receives parameters, and the parameters do not need to be used. ",
        "labels": [
            "SlowMist",
            "WombatExchange",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Token compatibility issues",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - WombatExchange_en-us.pdf",
        "body": "When the project is transferred to the token, it does not judge the balance change before and after the transfer of the target address receiving the token, so it is incompatible with reective tokens (deation/ination type tokens), which will cause the balance of the transfer to be inconsistent with the balance actually received, which will lead to calculation errors. ",
        "labels": [
            "SlowMist",
            "WombatExchange",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Redundant type conversion code",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - WombatExchange_en-us.pdf",
        "body": "The _quoteFrom function is using uint256 nalToAssetCovRatio = (toAssetCash + uint256(actualToAmount)).wdiv(toAssetLiability); to convert uint256(actualToAmount), But actualToAmount is of the type uint256, it is no need to convert. ",
        "labels": [
            "SlowMist",
            "WombatExchange",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Authorization limit issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - TransitSwap v4 Core_en-us.pdf",
        "body": "There are two roles Owner and Executor in the contract, and the permissions of the two roles are not clearly divided.",
        "labels": [
            "SlowMist",
            "TransitSwap v4 Core",
            "Type: Authority Control Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Security suggestion",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - TransitSwap v4 Core_en-us.pdf",
        "body": "Since the TransitSwapRouter contract will retain the user's authorization limit, it is recommended to allow the user to allocate on demand during the front-end authorization, and do not authorize the maximum value at one time to prevent the user's funds from being stolen. 11",
        "labels": [
            "SlowMist",
            "TransitSwap v4 Core",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing zero address check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - TransitSwap v4 Core_en-us.pdf",
        "body": "When modifying important addresses in the contract, it is not checked whether the incoming address is a zero address. ",
        "labels": [
            "SlowMist",
            "TransitSwap v4 Core",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - TransitSwap v4 Core_en-us.pdf",
        "body": "The Owner has the risk of over-authorization, and this role can withdraw the tokens in the contract to any address. ",
        "labels": [
            "SlowMist",
            "TransitSwap v4 Core",
            "Type: Authority Control Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Authority control issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - TransitSwap v4 Core_en-us.pdf",
        "body": "The contract adopts a completely open calling logic. There is an operation to authorize the approveAddress address in the _beforeSwap function. The calling path of this function is TransitSwapRouter.swap() -> TransitSwap.swap() -> TransitSwap._beforeSwap(). The calldata parameter is also passed in when calling the top-level function TransitSwapRouter.swap(). The code does not check whether the approveAddress is legal. If a malicious approveAddress is passed in, the contract will be incorrectly authorized and the tokens in the contract will be lost. ",
        "labels": [
            "SlowMist",
            "TransitSwap v4 Core",
            "Type: Authority Control Vulnerability",
            "Severity: High"
        ]
    },
    {
        "title": "Uninitialized parameter",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - TransitSwap v4 Core_en-us.pdf",
        "body": "The swapAmount parameter is declared in the contract but not initialized. ",
        "labels": [
            "SlowMist",
            "TransitSwap v4 Core",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Unsafe external call",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - TransitSwap v4 Core_en-us.pdf",
        "body": "The path and pair parameters in the supportingFeeOn function are controllable. If an attacker passes in malicious path and pair parameters, it may cause unexpected errors. ",
        "labels": [
            "SlowMist",
            "TransitSwap v4 Core",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing Approve amount reset",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - TransitSwap v4 Core_en-us.pdf",
        "body": "The _beforeSwap function in the TransitSwap contract will set the authorization limit to the maximum value when accessing the token for the rst time, but the function to remake the authorization is not found in the contract. When the authorization limit is used up, it will not be able to remake and the token cannot be used.",
        "labels": [
            "SlowMist",
            "TransitSwap v4 Core",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "4.2.1.1 __Guard_init function was not call when initialize",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Hot Cross BSC Bridge V1.0.0_en-us.pdf",
        "body": "ForeignProcessor contract and HomeRequest contract are inherit the Guard contract but dost not call the __Gurad_init function function __ForeignProcessor_init( IERC20 token, ValidatorRegistry validatorRegistry_ ) internal initializer { //SlowMist// Missing call of __Guard_init function require( address(token) != address(0) && Misc.isContract(address(token)), \"ForeignProcessor:Invalid erc20 address provided\" 10 ); require( address(validatorRegistry_) != address(0) && Misc.isContract(address(validatorRegistry_)), \"ForeignProcessor:Invalid validator registry address\" ); erc20 = token; validatorRegistry = validatorRegistry_; } function __HomeRequest_init( BEP20 token, ValidatorRegistry validatorRegistry_ ) internal initializer { //SlowMist// Missing call of __Guard_init function require( address(token) != address(0) && Misc.isContract(address(token)), \"HomeRequest:Invalid BEP20 address\" ); require( address(validatorRegistry_) != address(0) && Misc.isContract(address(validatorRegistry_)), \"HomeRequest:Invalid validator registry address\" ); bep20 = token; validatorRegistry = validatorRegistry_; } Fix status: fixed. 11 5.",
        "labels": [
            "SlowMist",
            "Hot Cross BSC Bridge V1.0.0",
            "Severity: Informational"
        ]
    },
    {
        "title": "Tokens Obtained from Emergency Withdrawal Partly Locked",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist_Audit_Report_StakeStone_MellowDepositWstETHStrategy_en-us.pdf",
        "body": "In the MellowDepositWstETHStrategy contract, the owner role can execute an emergency withdrawal operation from the mellowVault contract by calling the emergencyWithdrawFromMellow function. In the mellowVault contract, during an emergency withdrawal operation, the specied amount of LP tokens from previous withdrawal requests are burned, and two types of tokens, wstETH and DC_wstETH, are transferred to the address indicated in the withdrawal request. The amounts transferred are calculated based on the burned LP tokens and the current balance of these two tokens in the pool. However, in the MellowDepositWstETHStrategy contract, there is no implementation for redeeming DC_wstETH tokens back into wstETH, which results in these DC_wstETH tokens being locked within the contract. Furthermore, when calculating the total invested value of the contract using the getInvestedValue function, it fails to account for the value of the held DC_wstETH tokens. Code Location: contracts/strategies/MellowDepositWstETHStrategy.sol function getInvestedValue() public override returns (uint256 value) { uint256 etherValue = address(this).balance; uint256 stETHValue = IERC20(stETHAddr).balanceOf(address(this)); (, uint256 claimableValue, uint256 pendingValue) = checkPendingAssets(); uint256 mellowPending = getPendingValueFromMellow(); value = etherValue + stETHValue + claimableValue + pendingValue + getWstETHValue() + getDepositedValue() + mellowPending; } ... function emergencyWithdrawFromMellow( uint256[] memory _minAmounts, uint256 _deadline ) external onlyOwner returns (uint256 wstETHAmount) { IMellowVault(mellowVaultAddr).emergencyWithdraw(_minAmounts, _deadline); }",
        "labels": [
            "SlowMist",
            "SlowMist_Audit_Report_StakeStone_MellowDepositWstETHStrategy",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "The Potential Risk of Fixed Array Lengths",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist_Audit_Report_StakeStone_MellowDepositWstETHStrategy_en-us.pdf",
        "body": "In the MellowDepositWstETHStrategy contract, the owner role can call the depositIntoMellow function to deposit wstETH tokens from the contract into the MellowVault, where the length of the passed amounts array is xed at 1. Within the deposit function of the MellowVault contract, a check is performed to ensure that the lengths of the contract's _underlyingTokens array and the passed amounts array are equal. Currently, as the _underlyingTokens array in the MellowVault contract also contains only 1 element, this check passes successfully. However, the MellowVault contract features a function (addToken) that allows for adding new token data to the _underlyingTokens array. If, in the future, the _underlyingTokens array expands due to the addition of new tokens, the depositIntoMellow function may fail this length check and consequently be unable to execute properly. The same issues also apply when making a withdrawal request. Code Location: contracts/strategies/MellowDepositWstETHStrategy.sol#L177&L200 function depositIntoMellow( uint256 _wstETHAmount, uint256 _minLpAmount ) external onlyOwner returns (uint256 lpAmount) { require(_wstETHAmount != 0, \"zero\"); TransferHelper.safeApprove(wstETHAddr, mellowVaultAddr, _wstETHAmount); uint256[] memory amounts = new uint256[](1); amounts[0] = _wstETHAmount; (, lpAmount) = IMellowVault(mellowVaultAddr).deposit( address(this), amounts, _minLpAmount, block.timestamp ); emit DepositIntoMellow( mellowVaultAddr, address(this), _wstETHAmount, lpAmount ); } function requestWithdrawFromMellow( uint256 _share, uint256 _minAmount ) external onlyOwner { require(_share != 0, \"zero\"); uint256[] memory amounts = new uint256[](1); amounts[0] = _minAmount; IMellowVault(mellowVaultAddr).registerWithdrawal( address(this), _share, amounts, block.timestamp, type(uint256).max, true ); emit WithdrawFromMellow(mellowVaultAddr, address(this), _share); }",
        "labels": [
            "SlowMist",
            "SlowMist_Audit_Report_StakeStone_MellowDepositWstETHStrategy",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Conict in withdrawal requests",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist_Audit_Report_StakeStone_MellowDepositWstETHStrategy_en-us.pdf",
        "body": "In the MellowDepositWstETHStrategy contract, The owner role can initiate a withdrawal request for wstETH by calling the requestWithdrawFromMellow function, with the closePrevious parameter set to true by default. This implies that if a previous withdrawal request has been submitted and is still pending, it will rst be canceled before replacing it with the newly submitted withdrawal request. Code Location: contracts/strategies/MellowDepositWstETHStrategy.sol#L208 function requestWithdrawFromMellow( uint256 _share, uint256 _minAmount ) external onlyOwner { require(_share != 0, \"zero\"); uint256[] memory amounts = new uint256[](1); amounts[0] = _minAmount; IMellowVault(mellowVaultAddr).registerWithdrawal( address(this), _share, amounts, block.timestamp, type(uint256).max, true ); emit WithdrawFromMellow(mellowVaultAddr, address(this), _share); }",
        "labels": [
            "SlowMist",
            "SlowMist_Audit_Report_StakeStone_MellowDepositWstETHStrategy",
            "Type: Design Logic Audit",
            "Severity: Information"
        ]
    },
    {
        "title": "Redundant code",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Owlto Depositor_en-us.pdf",
        "body": "There are useless codes in the le and codes that are not used in actual business. Code Location: Depositor.sol#L225-227 contract Depositor { ... error NotOwnerError(); error LengthError(); error ZeroAddressError(); ... }",
        "labels": [
            "SlowMist",
            "Owlto Depositor",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Spelling mistake",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Owlto Depositor_en-us.pdf",
        "body": "Spelling mistake was identied within the code. Code Location: Depositor.sol function isContractt(address account) internal view returns (bool) { // This method relies on extcodesize, which returns 0 for contracts in // construction, since the code is only stored at the end of the // constructor execution. uint256 size; // solhint-disable-next-line no-inline-assembly assembly { size := extcodesize(account) } return size > 0; } ... function callOptionalReturn(IERC20 token, bytes memory data) private { ... require(address(token).isContractt(), \"SafeERC20: call to non-contract\"); ... }",
        "labels": [
            "SlowMist",
            "Owlto Depositor",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "4.2.1.1 Excessive auditing authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - MoonSwap_en-us.pdf",
        "body": "The owner in MasterStar contract can add a new lpToken through the add function, but if there is a black swan event, such as the addition of a malicious lpToken, there will be useless lpToken to recharge to get rewards. It is suggested that the owner can be handed over to the governance contract or time lock contract for management. function add(uint256 _allocPoint, IERC20 _lpToken, bool _withUpdate) public onlyOwner { if (_withUpdate) { massUpdatePools(); } require(poolIndexs[address(_lpToken)] < 1, \"LpToken exists\"); uint256 lastRewardBlock = block.number > startBlock ? block.number : startBlock; totalAllocPoint = totalAllocPoint.add(_allocPoint); poolInfo.push(PoolInfo({ lpToken: _lpToken, allocPoint: _allocPoint, lastRewardBlock: lastRewardBlock, tokenPerBlock: currentTokenPerBlock, accTokenPerShare: 0, finishMigrate: false, lockCrosschainAmount:0, crosschain_enable: false })); poolIndexs[address(_lpToken)] = poolInfo.length; } Owner can set migrator , It is suggested that the owner can be handed over to the governance contract or time lock contract for management. function setMigrator(IMigratorStar _migrator) public onlyOwner { migrator = _migrator; 7 } //Migratelptokentoanotherlpcontract.Canbecalledbyanyone.Wetrustthatmigratorcontractisgood. function migrate(uint256 _pid) public { require(address(migrator) != address(0), \"migrate: no migrator\"); PoolInfo storage pool = poolInfo[_pid]; IERC20 lpToken = pool.lpToken; uint256 bal = lpToken.balanceOf(address(this)); lpToken.safeApprove(address(migrator), bal); IERC20 newLpToken = migrator.migrate(lpToken); require(bal == newLpToken.balanceOf(address(this)), \"migrate: bad\"); pool.lpToken = newLpToken; pool.finishMigrate = true; } Fixed: The owner authority has been transferred to the timelock contract. Reference: https://etherscan.io/tx/0x3e8be2489c824906c7fe1abe376ccea198e3cd28cb225dee91d4f9c3e9 62a889",
        "labels": [
            "SlowMist",
            "MoonSwap",
            "Severity: Low"
        ]
    },
    {
        "title": "4.2.2.1 Compiler version is inconsistent",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - MoonSwap_en-us.pdf",
        "body": "The compiler version used by the imported contract is inconsistent. It is recommended to use a unified fixed compiler version when deploying. pragma solidity ^0.6.0; pragma solidity ^0.6.2; pragma solidity 0.6.12;",
        "labels": [
            "SlowMist",
            "MoonSwap",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.2.2.2 Better handling of ownership transfers",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - MoonSwap_en-us.pdf",
        "body": "When using the transferOwnership function to change the owner, it is recommended to add a 8 confirmation method that newOwner accepts the owner. The real authority transfer is performed after the new address is signed and confirmed to avoid the loss of authority. function transferOwnership(address newOwner) public virtual onlyOwner { require(newOwner != address(0), \"Ownable: new owner is the zero address\"); emit OwnershipTransferred(_owner, newOwner); _owner = newOwner; }",
        "labels": [
            "SlowMist",
            "MoonSwap",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.2.2.3 Enhancement point of delegateBySig function",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - MoonSwap_en-us.pdf",
        "body": "The nonce in the delegateBySig function is input by the user. When the user input a larger nonce, the current transaction cannot be success but the relevant signature data will still remain on the chain, causing this signature to be available for some time in the future. It is recommended to fix it according to EIP-2612. Reference: https://github.com/ethereum/EIPs/blob/master/EIPS/eip-2612.md#implementation. function delegateBySig( address delegatee, uint nonce, uint expiry, uint8 v, bytes32 r, bytes32 s external ) { bytes32 domainSeparator = keccak256( abi.encode( DOMAIN_TYPEHASH, keccak256(bytes(name())), getChainId(), address(this) ) ); 9 bytes32 structHash = keccak256( abi.encode( DELEGATION_TYPEHASH, delegatee, nonce, expiry ) ); bytes32 digest = keccak256( abi.encodePacked( \"\\x19\\x01\", domainSeparator, structHash ) ); address signatory = ecrecover(digest, v, r, s); require(signatory != address(0), \"MOON::delegateBySig: invalid signature\"); require(nonce == nonces[signatory]++, \"MOON::delegateBySig: invalid nonce\"); require(now <= expiry, \"MOON::delegateBySig: signature expired\"); return _delegate(signatory, delegatee); }",
        "labels": [
            "SlowMist",
            "MoonSwap",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.2.2.4 Mint issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - MoonSwap_en-us.pdf",
        "body": "The owner can mint tokens unlimitedly through mint function, but the owner's authority of the token contract is changed to MasterStar contract for the first time. function mint(address _to, uint256 _amount) public onlyOwner { _mint(_to, _amount); _moveDelegates(address(0), _delegates[_to], _amount); } Fixed: The owner authority has actually been transferred to the MasterStar contract. Reference: 10 https://etherscan.io/tx/0x0303672ee5045cd01102fdb50787541d11bddc3e1bfc446d4f6b46db85 e65bff",
        "labels": [
            "SlowMist",
            "MoonSwap",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.2.2.5 Using now globally available variables that will be deprecated",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - MoonSwap_en-us.pdf",
        "body": "The now globally available variables is used, which has been deprecated in compiler solidity 0.7.0. require(signatory != address(0), \"MOON::delegateBySig: invalid signature\"); require(nonce == nonces[signatory]++, \"MOON::delegateBySig: invalid nonce\"); require(now <= expiry, \"MOON::delegateBySig: signature expired\");",
        "labels": [
            "SlowMist",
            "MoonSwap",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.2.2.6 0 value is not checked",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - MoonSwap_en-us.pdf",
        "body": "The withdraw function suggests adding a check of _amount> 0, which can optimize the gas consumption when _amount is 0. function withdraw(uint256 _pid, uint256 _amount) public { PoolInfo storage pool = poolInfo[_pid]; require(!pool.finishMigrate, \"migrate not withdraw\"); UserInfo storage user = userInfo[_pid][msg.sender]; require(user.amount >= _amount, \"withdraw: not good\"); updatePool(_pid); uint256 pending = user.amount.mul(pool.accTokenPerShare).div(1e12).sub(user.rewardDebt); safeTokenTransfer(msg.sender, pending); user.amount = user.amount.sub(_amount); user.rewardDebt = user.amount.mul(pool.accTokenPerShare).div(1e12); pool.lpToken.safeTransfer(address(msg.sender), _amount); emit Withdraw(msg.sender, _pid, _amount); }",
        "labels": [
            "SlowMist",
            "MoonSwap",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.2.2.7 Prompt Error",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - MoonSwap_en-us.pdf",
        "body": "The prompt of setCrosschain function require has an error \"migrate not deposit\", it is recommended to modify the prompt to \"migrate not setCrosschain\". 11 function setCrosschain(uint256 _pid, bool isOk, address cmoonAddr) public onlyOwner { PoolInfo storage pool = poolInfo[_pid]; require(pool.finishMigrate, \"migrate not deposit\"); pool.crosschain_enable = isOk; require(cmoonAddr != address(0), \"address invalid\"); migratePoolAddrs[_pid] = cmoonAddr; } Fixed: The issue has been fixed by this commit: ef19afe4b6bfd624dd79903c36ea335be6a7b283.",
        "labels": [
            "SlowMist",
            "MoonSwap",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.2.2.8 Better handling of devaddr transfers",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - MoonSwap_en-us.pdf",
        "body": "When changing devaddr in the dev function, it is recommended to add newDevaddr to accept the replacement confirmation method. After the new address is signed and confirmed, the real change to devaddr can be made to avoid setting errors and the income cannot be normally obtained. function dev(address _devaddr) public { require(msg.sender == devaddr, \"dev: wut?\"); devaddr = _devaddr; }",
        "labels": [
            "SlowMist",
            "MoonSwap",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.2.2.9 Coding Standards",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - MoonSwap_en-us.pdf",
        "body": "The coding style of emergencyWithdraw function is to make an external call first, and then change the value of the contract variable. This way of writing, because lpToken is considered safe, there is no reentrancy problem, but it is recommended to use the correct coding standard: The variable is changed, and then an external call is made. A lock modifier for reentrancy prevention can also be added. function emergencyWithdraw(uint256 _pid) public { PoolInfo storage pool = poolInfo[_pid]; require(!pool.finishMigrate, \"migrate not withdraw\"); UserInfo storage user = userInfo[_pid][msg.sender]; pool.lpToken.safeTransfer(address(msg.sender), user.amount); 12 emit EmergencyWithdraw(msg.sender, _pid, user.amount); user.amount = 0; user.rewardDebt = 0; } Fixed: The issue has been fixed by this commit: ef19afe4b6bfd624dd79903c36ea335be6a7b283 5.",
        "labels": [
            "SlowMist",
            "MoonSwap",
            "Severity: Informational"
        ]
    },
    {
        "title": "Lack of previous pool status check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Stake Mask_en-us.pdf",
        "body": "In the StakeManager contract, the user can deposit funds into the contract by calling the depositAndLock function and withdraw funds by calling the withdraw function. However, when a new pool is added and currentPoolId is updated to the id of the new pool, the user calls depositAndLock function again to make a deposit without checking the unlocked state of the pool that the user deposited in before. So the poolId in the user's information will be directly overwritten with the new currentPoolId, even if the pool state at the time of the previous deposit was a locked state. If the state of the new pool is unlocked, the withdraw function can be called directly to withdraw all of the user's deposits, even if the pool where the rst deposit was made was in a locked state. Code Location: src/StakeManager.sol function depositAndLock(uint256 _amount) public nonReentrant { Pool storage pool = pools[currentPoolId]; require(pool.stakingEnabled, \"Staking is disabled for this pool\"); require(maskToken.transferFrom(msg.sender, address(this), _amount), \"Transfer failed\"); userInfos[msg.sender].stakedAmount += _amount; // depositAndLock will always stake to currentPoolId // it will init userInfos[msg.sender].poolId for the first time // it will change userInfos[msg.sender].poolId to currntPoolId(which means new pool) when // user deposit after prev pool unlocked userInfos[msg.sender].poolId = currentPoolId; emit Staked(msg.sender, currentPoolId, _amount); } function withdraw(uint256 _amount) public nonReentrant { Pool storage pool = pools[userInfos[msg.sender].poolId]; require(pool.unlocked, \"Pool is locked\"); require(userInfos[msg.sender].stakedAmount >= _amount, \"Insufficient balance\"); userInfos[msg.sender].stakedAmount -= _amount; require(maskToken.transfer(msg.sender, _amount), \"Transfer failed\"); emit unstaked(msg.sender, userInfos[msg.sender].poolId, _amount); }",
        "labels": [
            "SlowMist",
            "Stake Mask",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Dierence check when changing pools",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Stake Mask_en-us.pdf",
        "body": "In the StakeManager contract, the user can update the poolId in the user information to the latest currentPoolId by calling the changePool function. However, there is no check to see if the currentPoolId matches the poolId in the user information. Code Location: src/StakeManager.sol function changePool() public nonReentrant { uint8 fromPoolId = userInfos[msg.sender].poolId; Pool storage fromPool = pools[userInfos[msg.sender].poolId]; Pool storage toPool = pools[currentPoolId]; require(toPool.stakingEnabled, \"Staking is disabled for this pool\"); require(fromPool.unlocked, \"From pool is locked\"); require(userInfos[msg.sender].stakedAmount > 0, \"No staked amount\"); userInfos[msg.sender].poolId = currentPoolId; emit StakeChanged(msg.sender, fromPoolId, currentPoolId); }",
        "labels": [
            "SlowMist",
            "Stake Mask",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing return value check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Stake Mask_en-us.pdf",
        "body": "In the Reward contract, the owner can call the emergencyWithdraw function to transfer any tokens in the contract. But it does not check the return value. If external tokens do not adopt the EIP20 standard, it may lead to false top-up issues. ",
        "labels": [
            "SlowMist",
            "Stake Mask",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Stake Mask_en-us.pdf",
        "body": "In the Reward contract, the owner can call the emergencyWithdraw function to transfer any tokens in the contract. If the privilege is lost or misused, there may be an impact on the user's funds. ",
        "labels": [
            "SlowMist",
            "Stake Mask",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "4.3.1.2 Risk of loss of user funds",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DODOV2_en-us.pdf",
        "body": "In the LockTokenVault contract, when transferring the user's locked token, it did not check whether the _to address is msg.sender itself, which caused the user to abuse the transfer and cause a loss of funds. function transferLockedToken(address to) external { originBalances[to] = originBalances[to].add(originBalances[msg.sender]); claimedBalances[to] = claimedBalances[to].add(claimedBalances[msg.sender]); originBalances[msg.sender] = 0; claimedBalances[msg.sender] = 0; } Fix status: fixed, repair commit: main-08a06609604779c31db493bc0d755efa1c3f0a61.",
        "labels": [
            "SlowMist",
            "DODOV2",
            "Severity: Low"
        ]
    },
    {
        "title": "4.2.2.1 Missing events",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DODOV2_en-us.pdf",
        "body": "Contract  DODOApproveProxy  Function list  init / unlockAddProxy / addDODOProxy / LockAddProxy / removeDODOProxy ContractDODOApproveFunction listinit / unlockSetProxy / setDODOProxy / LockSetProxy ContractDODV2Proxy02Function listaddWhiteList / removeWhiteList / updateGasReturn ContractDVMFactorFunction listupdateDvmTemplate ContractDPPAdvanceFunction listtunePrice ContractDPPAdvance Function listsetOperator / setFreezeTimestamp ContractDPPVaultFunction listratioSync / retrieve 6 ContractDVMVault Function list_setReserve_sync The above functions does not have an event declaration, it is recommended to add the corresponding event declaration Fix status: After communicating with the project party, it is confirmed that the above event statement is not currently used in business and will be fixed in subsequent iterations.",
        "labels": [
            "SlowMist",
            "DODOV2",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.2.2.2 The contract balance was not verified when the reward was distributed",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DODOV2_en-us.pdf",
        "body": "In the RewardVault contract, the contract balance is not verified when the reward is distributed, which may cause the contract balance to fail to be distributed function reward(address to, uint256 amount) external onlyOwner { //SlowMist// Not verify if contract balance is larger than the transfer amount IERC20(dodoToken).safeTransfer(to, amount); } Fix situation: After confirming with the project party, they ignore this problem.",
        "labels": [
            "SlowMist",
            "DODOV2",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.2.2.3 Unchecked array length",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DODOV2_en-us.pdf",
        "body": "a. The getPendingReward function in the BaseMine contract did not verify whether the value of i passed in was less than the length of the array when obtaining the reward of the pool, which resulted in the failure to obtain the reward. function getPendingReward(address user, uint256 i) public view returns (uint256) { //SlowMist// Not verify the array length RewardTokenInfo storage rt = rewardTokenInfos[i]; uint256 accRewardPerShare = rt.accRewardPerShare; if (rt.lastRewardBlock != block.number) { accRewardPerShare = _getAccRewardPerShare(i); } return 7 DecimalMath.mulFloor( balanceOf(user), accRewardPerShare.sub(rt.userRewardPerSharePaid[user]) ).add(rt.userRewards[user]); } Fix status: fixed, repair commit: feature/mineV2AndDSP- 5917c95439cac06241f108038043d2 2348c863e6. b. The claimReward function in the BaseMine contract does not verify whether the value of i passed in is less than the length of the array, resulting in failure to obtain rewards function claimReward(uint256 i) public { require(i<rewardTokenInfos.length, \"DODOMineV2: REWARD_ID_NOT_FOUND\"); _updateReward(msg.sender, i); RewardTokenInfo storage rt = rewardTokenInfos[i]; uint256 reward = rt.userRewards[msg.sender]; if (reward > 0) { rt.userRewards[msg.sender] = 0; IRewardVault(rt.rewardVault).reward(msg.sender, reward); emit Claim(i, msg.sender, reward); } } Fix status: fixed, repair commit: feature/mineV2AndDSP- 5917c95439cac06241f108038043d2 2348c863e6.",
        "labels": [
            "SlowMist",
            "DODOV2",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.2.2.4 Compatibility risk of rebasing tokens",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DODOV2_en-us.pdf",
        "body": "The deposit function of the ERC20Mine contract does not verify the incoming amount. When it is compatible with rebasing tokens, it will cause an error to obtain the transfer amount. function claimReward(uint256 i) public { require(i<rewardTokenInfos.length, \"DODOMineV2: REWARD_ID_NOT_FOUND\"); _updateReward(msg.sender, i); 8 RewardTokenInfo storage rt = rewardTokenInfos[i]; uint256 reward = rt.userRewards[msg.sender]; if (reward > 0) { rt.userRewards[msg.sender] = 0; IRewardVault(rt.rewardVault).reward(msg.sender, reward); emit Claim(i, msg.sender, reward); } } Fix status: fixed, fix commit: main-d26b21bd814d4bfcc702521d52f6cb3af4f86e5c. 5.",
        "labels": [
            "SlowMist",
            "DODOV2",
            "Severity: Informational"
        ]
    },
    {
        "title": "Potential Unable to Borrow Issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn LeverageStaking - SlowMist Audit Report.pdf",
        "body": "In the LeverageStake contract, the batchDecreaseLever function reduces the leverage ratio of the ETF by withdrawing/repaying in AAVE, and may completely repay the debt in AAVE in the process. In this case, when the operator fully withdraws stETH from AAVE, the state of usingAsCollateral of the ETF in AAVE will be set to false. Theoretically, the aToken in the ETF will be 0 at this time, and usingAsCollateral will be automatically set to true when the ETF deposits in AAVE next time. But in fact, AAVE may still have 1wei of aToken left in the ETF due to arithmetic precision errors when calculating the number of aTokens that need to be burned by withdrawing the amount. Therefore, when the ETF deposits in AAVE next time, usingAsCollateral will not be set to true, and since there is no interface for calling the setUserUseReserveAsCollateral function in LeverageStake, this may cause the ETF to no longer be able to perform borrow operations. ",
        "labels": [
            "SlowMist",
            "DeSyn LeverageStaking - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Library function visibility issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn LeverageStaking - SlowMist Audit Report.pdf",
        "body": "In the protocol, the LeverageStake contract operates ETF through the interface of the AaveCall library, so the AaveCall library is stateless, and there is no need to set the visibility of the function to external/public. ",
        "labels": [
            "SlowMist",
            "DeSyn LeverageStaking - SlowMist Audit Report",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Function multiple logic mixes",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn LeverageStaking - SlowMist Audit Report.pdf",
        "body": "In the getLeverageInfo function comment of the LeverageStake contract, it is explained that this function is used to obtain the fund status of the ETF in AAVE. But it not only gets it through the getUserAccountData function but also rebinds the ETF. These are two completely unrelated functions but used in the same function. And due to the openness of the getLeverageInfo function, any user can perform rebind operations through this function, which may be contrary to the design philosophy of ETF. ",
        "labels": [
            "SlowMist",
            "DeSyn LeverageStaking - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Potential Malicious Liquidation ETF Issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn LeverageStaking - SlowMist Audit Report.pdf",
        "body": "In the LeverageStake contract, the operator can increase the leverage ratio of the ETF in AAVE through the borrow function. Since there is no maximum leverage limit, when the leverage ratio is too high and stETH is close to the liquidation line, the ETF may be liquidated due to the accumulation of loan interest. If the operator acts maliciously subjectively, the funds of users in the ETF will be at risk. ",
        "labels": [
            "SlowMist",
            "DeSyn LeverageStaking - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "min_dy without slippage and exchange fees",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn LeverageStaking - SlowMist Audit Report.pdf",
        "body": "In the LeverageStake contract, the increaseLever and convertToAstEth functions all have the function of exchanging stETH and ETH tokens through the exchange function. However, the min_dy parameter passed in is consistent with the dx parameter. Due to the existence of slippage and exchange fees, a certain amount of stETH cannot be exchanged for exactly the same amount of ETH tokens. Therefore, the exchange function in these functions cannot be executed normally. ",
        "labels": [
            "SlowMist",
            "DeSyn LeverageStaking - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Potential Operator Arbitrage Risk",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn LeverageStaking - SlowMist Audit Report.pdf",
        "body": "In the LeverageStake contract, the operator can exchange stETH and ETH tokens through the exchange function, but its min_dy parameter is also set by the operator. Therefore, if the caller does not pass in min_dy, the exchange operation of the ETF in the Curve Pool may suer from a sandwich attack, resulting in the loss of ETF assets. ",
        "labels": [
            "SlowMist",
            "DeSyn LeverageStaking - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Unreasonable defaultSlippage",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn LeverageStaking - SlowMist Audit Report.pdf",
        "body": "There is a defaultSlippage variable in the LeverageStake contract, which is used in the decreaseLever and convertToWeth functions to exchange the minimum received amount between stETH and ETH tokens. It defaults to 1 and cannot be modied, which will cause min_dy to be 1% of dx during the exchange operation, making the token exchange process vulnerable to sandwich attacks. ",
        "labels": [
            "SlowMist",
            "DeSyn LeverageStaking - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Redundant receive function",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn LeverageStaking - SlowMist Audit Report.pdf",
        "body": "There is a receive function in the LeverageStake contract to enable the contract to receive native tokens. However, in actual business, the contract does not need to receive native tokens, so the receive function is redundant, which may also cause users to mistakenly transfer native tokens to this contract and then fail to withdraw them. ",
        "labels": [
            "SlowMist",
            "DeSyn LeverageStaking - SlowMist Audit Report",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Issues with not updating bound tokens",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn LeverageStaking - SlowMist Audit Report.pdf",
        "body": "In the LeverageStake contract, the deposit, borrow, withdraw, and repayBorrow functions are used to operate the ETF to deposit, borrow, withdraw, and repay to AAVE, respectively. However, the _records of the bound tokens in the ETF are not updated in the above operations. This will cause the token _records in the ETF to be skewed after the operator operates through the above function. ",
        "labels": [
            "SlowMist",
            "DeSyn LeverageStaking - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Partial rebind issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn LeverageStaking - SlowMist Audit Report.pdf",
        "body": "In the LeverageStake contract, the increaseLever and decreaseLever functions respectively increase/decrease the leverage ratio of the ETF in AAVE, and at the same time rebind the astETH tokens in the ETF, but do not update the _records status of ETH and stETH in the ETF, which will cause The _records state does not match the actual token balance in the ETF. ",
        "labels": [
            "SlowMist",
            "DeSyn LeverageStaking - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Potential denial of service risk due to gulp operations",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase5 - SlowMist Audit Report_en-us.pdf",
        "body": "In the Actions contract, when the user performs the autoJoinSmartPool operation, the number of shares the user can obtain will be calculated through the _calculateShare function, and minPoolAmountOut will be checked at the end. The _calculateShare function obtains the number of tokens recorded in the pool through bPool's getBalance when calculating the share, but unfortunately any user can update this parameter through bPool's gulp function. Therefore, when an ordinary user performs an autoJoinSmartPool operation, a malicious user directly transfers funds to bPool and calls the gulp function to update the token balance recorded in the pool. At this time, ordinary users will not be able to successfully add liquidity due to the minPoolAmountOut check. If the minPoolAmountOut value passed in by an ordinary user is 0, it may cause an interest rate ination attack. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase5 - SlowMist Audit Report",
            "Type: Denial of Service Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Incorrect event logging",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase5 - SlowMist Audit Report_en-us.pdf",
        "body": "In the CRP contract, the createPool function adds the creator parameter as the real creator of the pool. However, the corresponding events were not modied accordingly. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase5 - SlowMist Audit Report",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Incorrect WETH address",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase5 - SlowMist Audit Report_en-us.pdf",
        "body": "The WETH address constant is hard-coded in the Actions contract, but this address is an EOA address on the Ethereum mainnet and is not the correct WETH address. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase5 - SlowMist Audit Report",
            "Type: Others",
            "Severity: High"
        ]
    },
    {
        "title": "Incorrect poolTokens check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase5 - SlowMist Audit Report_en-us.pdf",
        "body": "In the autoJoinSmartPool function of the Actions contract, it checks the tokens deposited by the user through poolTokens[i] == handleToken , but handleToken has been replaced by the issueToken parameter during the native token checking phase. Therefore, the poolTokens[i] == handleToken check is not accurate. If handleToken is WETH, it will cause an error in the _makeSwap operation. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase5 - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Redundant STBT token check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase5 - SlowMist Audit Report_en-us.pdf",
        "body": "In the autoJoinSmartPool and _exit functions of the Actions contract, when making a token transfer, it will be checked whether the transferred token is an STBT token. But in fact, the protocol does not allow deposits of STBT tokens, and STBT tokens will also be converted into stablecoins after the ETF expires. Therefore, theoretically, there will be no STBT tokens in the contract, so the STBT token check is redundant. . ",
        "labels": [
            "SlowMist",
            "DeSyn Phase5 - SlowMist Audit Report",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Potential risk of slot conict",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase5 - SlowMist Audit Report_en-us.pdf",
        "body": "In this protocol iteration, both SmartPoolManager and Actions contracts have changed their storage structures. If these contracts use an upgradeable model, and upgrading the contract directly on the original basis may lead to contract storage slot conicts. In fact, the Actions contract is an upgradeable contract, so special attention should be paid to such risks.",
        "labels": [
            "SlowMist",
            "DeSyn Phase5 - SlowMist Audit Report",
            "Type: Variable Coverage Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of event forgery",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase5 - SlowMist Audit Report_en-us.pdf",
        "body": "In the CRP contract, the exitPool function adds a user parameter to record the real caller when the user exits through the Actions contract. However, users can also exit by calling the exitPool function of the CRP contract. They can pass in any user parameter to make the LogExit event record an incorrect value. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase5 - SlowMist Audit Report",
            "Type: Malicious Event Log Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Potential risk of denial of service due to large CRPFactory array",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase5 - SlowMist Audit Report_en-us.pdf",
        "body": "In the CRPFactory contract, when the Blabs role performs addCRPFactory and removeCRPFactory operations, it will use a for loop to traverse the entire CRPFactorys array. If the array length is too large, it will lead to DoS risks. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase5 - SlowMist Audit Report",
            "Type: Denial of Service Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Potential risk of endless loop",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase5 - SlowMist Audit Report_en-us.pdf",
        "body": "In the CRPFactory contract, the isCrp function is used to check whether the address passed by the user is a CRP contract. If not, the CRPFactorys array will be circulated and the isCrp function of other CRPFactory will be called to check. However, it should be noted that if the Blabs role adds this contract address to the CRPFactorys array, the user will fall into an innite loop error when querying a CRP address that is not recorded in this contract through the isCrp function. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase5 - SlowMist Audit Report",
            "Type: Denial of Service Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Unchecked asset type in inputEth function allows potential asset mismatch",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Doubler Lite.pdf",
        "body": "The input function lacks a crucial check to verify if the _asset parameter corresponds to an ETH pool. This oversight creates a potential vulnerability. In a scenario where both ETH and BTC pools exist, a user could potentially input ETH but have it processed as BTC. This mismatch between the intended and actual asset type could lead to unexpected behavior and potential exploitation of the system. contracts/Doubler.sol function inputEth( address _asset, uint256 _qAmount, address _to ) external payable nonReentrant onlyOncePerBlock onlyAsset(_asset) { if (msg.value != _qAmount) revert E_Balance(); _input(_asset, _qAmount, _to, true); }",
        "labels": [
            "SlowMist",
            "Doubler Lite",
            "Type: Others",
            "Severity: Low"
        ]
    },
    {
        "title": "Issue with fee allocation in the _limitMint function",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Doubler Lite.pdf",
        "body": "In the _limitMint function, the distribution of minting fees should be based on the length of _srvFeeAddr . Currently, the number of _srvFeeAddr entries called from the Doubler contract is only 2. However, if other contracts call this function with a dierent length of _srvFeeAddr in the future, it will result in allocating more fees than intended. contracts/RBToken.sol function _limitMint( address _recipient, uint256 _tokenAmount, uint256 _poolTotalLimit, address[] memory _srvFeeAddr, uint16 _srvFeeRatio ) internal returns (uint256 recipientTokenAmount) { ... _totalShare = _totalShare + newShares; uint256 recipientNewShare = newShares; recipientTokenAmount = _tokenAmount; if (_srvFeeRatio > 0) { uint256 srvFee = (newShares * _srvFeeRatio) / _perMil; recipientTokenAmount = recipientTokenAmount - (_tokenAmount * _srvFeeRatio) / _perMil; for (uint8 i = 0; i < _srvFeeAddr.length; i++) { _shares[_srvFeeAddr[i]] = _shares[_srvFeeAddr[i]] + srvFee / 2; recipientNewShare = recipientNewShare - srvFee / 2; _emitTransferEvents(address(0x0), _recipient, (_tokenAmount * _srvFeeRatio) / _perMil, srvFee); } } _shares[_recipient] = _shares[_recipient] + recipientNewShare; _emitTransferEvents(address(0x0), _recipient, recipientTokenAmount, recipientNewShare); }",
        "labels": [
            "SlowMist",
            "Doubler Lite",
            "Type: Others",
            "Severity: Low"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Doubler Lite.pdf",
        "body": "The owner can modify the fees and fee recipients in the pool, which can cause damage to the project's funds if the private key is compromised. contracts/Doubler.sol owner can initializeDoubler owner can updateLowerOfInputMaximum owner can newPool owner can updatePool ADMIN can set the upper and lower price limits of the prediction machine, which will aect the functionality of the contract if ADMIN's private key is compromised. contracts/FastPriceFeed.sol ADMIN can setAssetPriceLimit ADMIN can setPriceFeedTimeLimit ADMIN can newAsset ADMIN can switchPriceFeed The owner can set the address where the fee will be charged, and if the private key is leaked, it will result in the loss of the project's funds. contracts/DoublerFactory.sol contracts/DoublerFactory.sol owner can updateEcoAddr owner can newPool",
        "labels": [
            "SlowMist",
            "Doubler Lite",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Potential bypass Issue with onlyOncePerBlock",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Doubler Lite.pdf",
        "body": "In the design logic of doubler lite, atoken, btoken, and ctoken are all transferable. The onlyOncePerBlock mechanism is intended to restrict a user to a single function operation within one block. However, this restriction only applies to msg.sender, allowing users to bypass the limitation by making calls through multiple contracts. contracts/Doubler.sol modifier onlyOncePerBlock() { if (_lastBlockCalled[msg.sender] >= block.number) revert E_BlockOnce(); _; _lastBlockCalled[msg.sender] = block.number; }",
        "labels": [
            "SlowMist",
            "Doubler Lite",
            "Type: Others",
            "Severity: Medium"
        ]
    },
    {
        "title": "Abnormal implementation logic in getPooledByShares",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Doubler Lite.pdf",
        "body": "In the getPooledByShares function, it should retrieve the corresponding token amount based on sharesAmount. However, the actual interface called retrieves sharesAmount based on the token amount. contracts/RBToken.sol function getPooledByShares(uint256 _sharesAmount) public view returns (uint256) { return _getSharesByPooledToken(_sharesAmount); }",
        "labels": [
            "SlowMist",
            "Doubler Lite",
            "Type: Others",
            "Severity: Low"
        ]
    },
    {
        "title": "Potential risk due to the unique nature of 10xBToken",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Doubler Lite.pdf",
        "body": "Since 10xBToken is a special type of token where users hold shares instead of actual quantities, there may be an extreme risk when users add liquidity providers. In an extreme scenario, subsequent investors can obtain a large number of shares, causing the price of BToken in the pool to rise sharply (because the actual token quantity obtainable by the pools shares decreases). This could result in liquidity providers incurring losses as a small amount of tokens might be used to exchange for a large amount of corresponding assets. Status Acknowledged",
        "labels": [
            "SlowMist",
            "Doubler Lite",
            "Type: Others",
            "Severity: Information"
        ]
    },
    {
        "title": "Impact of inationary or deationary tokens on the doubler lite economic model",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Doubler Lite.pdf",
        "body": "In the economic model of Doubler Lite, the use of inationary (e.g., stETH) or deationary tokens does not aect the overall economic model. This is because all calculations are based on shares, and the ination or deation impacts only the temporary average price of the tokens, which aligns with the design expectations. Status Acknowledged",
        "labels": [
            "SlowMist",
            "Doubler Lite",
            "Type: Others",
            "Severity: Information"
        ]
    },
    {
        "title": "Recommendations for parameter checking",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Doubler Lite.pdf",
        "body": "contracts/Doubler.sol Suggest checking startTime, endTime to make sure startTime is less than endTime, and checking creator to make sure creator is not address(0). function _checkPoolParam(Pool memory _pl) internal pure { if (_pl.inputFee > 20) revert E_FeeLimit(); if (_pl.withdrawFee > 20) revert E_FeeLimit(); }",
        "labels": [
            "SlowMist",
            "Doubler Lite",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Redundant code",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Send V1.0.1_en-us.pdf",
        "body": "Ether is not accepted by default, which is a redundant code. cross-send/contracts/CrossSend.sol#L41-L47 initial-hotcross-oering/contracts/BaseIHO.sol#L67-L73 fallback () external payable { revert(\"cannot directly accept currency transfers\"); } receive () external payable { revert(\"cannot directly receive currency transfers\"); 15 }",
        "labels": [
            "SlowMist",
            "Cross Send V1.0.1",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Gas optimization",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Send V1.0.1_en-us.pdf",
        "body": "If one of the batch transfers fails, the transaction that was previously transferred normally will be reverted, but Gas has been consumed. It is a gas optimization issue here. cross-send/contracts/CrossSend.sol#L175-L210 function sendToken( IERC20 token, address[] memory recipients, uint256[] memory amounts ) private returns(uint256) { uint256 total = 0; for (uint256 i = 0; i < recipients.length ; i++) { require(_msgSender() != recipients[i], \"sender != recipient\"); token.safeTransferFrom(_msgSender(), recipients[i], amounts[i]); total += amounts[i]; } return total; } function sendNative( address[] memory recipients, uint256[] memory amounts ) private returns(uint256) { uint256 total = 0; 16 for (uint256 i = 0; i < recipients.length ; i++) { total += amounts[i]; (bool success, ) = payable(recipients[i]).call{value: amounts[i]}(\"\"); require(success, \"native transfer failed\"); } return total; }",
        "labels": [
            "SlowMist",
            "Cross Send V1.0.1",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of allowance amount abuse",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Send V1.0.1_en-us.pdf",
        "body": "There have an allowance amount in the contract, but the distributeTokenFee function does not limit the caller, and there is an issue of being called arbitrarily, but it can only transfer the balance of the sender to the feeCollector. cross-send/contracts/fee-managers/RecipientCountFee.sol#L65-L83 function distributeTokenFee( uint256 txRecipientCount, uint256, uint256, uint256, uint256, address sender ) public override { uint256 payableFee = txRecipientCount * tokenFeePerRecipient; 17 if(payableFee < minTokenFee) { payableFee = minTokenFee; } else if (payableFee > maxTokenFee) { payableFee = maxTokenFee; } token.safeTransferFrom(sender, feeCollector, payableFee); }",
        "labels": [
            "SlowMist",
            "Cross Send V1.0.1",
            "Type: Authority Control Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Price manipulation issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Send V1.0.1_en-us.pdf",
        "body": "The IOUPrice is calculated using totalFarmingTokenBalance. Attackers can control totalFarmingTokenBalance to manipulate IOUPrice. The current code does not nd the location where IOUPrice is used. Referencehttps://slowmist.medium.com/cream-hacked-analysis-us-130-million-hacked-95c9410320ca cross-yield/contracts/core/CrossYield.sol#L95-L101 function IOUPrice() public view returns (uint256) { uint256 IOUSupply = totalSupply(); return IOUSupply == 0 ? 1e18 : (totalFarmingTokenBalance() * 1e18) / IOUSupply; } 18 cross-yield/contracts/core/CrossYield.sol#L65-L67 function totalFarmingTokenBalance() public view returns (uint256) { return farmingToken().balanceOf(address(this)) + strategy.balanceOf(); }",
        "labels": [
            "SlowMist",
            "Cross Send V1.0.1",
            "Type: Others",
            "Severity: Medium"
        ]
    },
    {
        "title": "Sandwich attacks issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Send V1.0.1_en-us.pdf",
        "body": "There is no slippage check during swap, and there is a risk of sandwich attack. IPancakeRouter02(pcsRouter).swapExactTokensForTokens(cakeBalance, 0,cakeToBaseRoute, address(this), block.timestamp); IPancakeRouter02(pcsRouter) .swapExactTokensForTokens(toSwap, 0, route, address(this), block.timestamp); Reference https://medium.com/coinmonks/demystify-the-dark-forest-on-ethereum-sandwich-attacks-5a3aec9fa33e cross-yield/contracts/libs/OptimalSwap.sol#L14-L63 function prepareLiquidity( address cake, address[2] memory lpTokens, 19 address wbnb, address busd, address farmingToken, address pcsRouter, uint256 fee ) external { uint256 cakeBalance = IERC20(cake).balanceOf(address(this)); bool isCakeInLp = lpTokens[0] == cake || lpTokens[1] == cake; bool isWbnbBased = lpTokens[0] == wbnb || lpTokens[1] == wbnb; address baseToken = isWbnbBased ? wbnb : busd; // if cake is not part of the lp token, swap all cake for the base token if (!isCakeInLp) { address[] memory cakeToBaseRoute = new address[](2); cakeToBaseRoute[0] = cake; cakeToBaseRoute[1] = baseToken; IPancakeRouter02(pcsRouter) .swapExactTokensForTokens(cakeBalance, 0, cakeToBaseRoute, address(this), block.timestamp); } (uint256 reserve0, uint256 reserve1,) = IPancakePair(farmingToken).getReserves(); address[] memory route = new address[](2); uint256 lp0Bal = IERC20(lpTokens[0]).balanceOf(address(this)); uint256 lp1Bal = IERC20(lpTokens[1]).balanceOf(address(this)); uint256 toSwap; // The possible cases here are: // - Cake was not part of the LP token, so we swap for baseToken which could either be lpToken0 or lpToken // - Cake was part of the LP token, so it can either be lpTokens[0] or lpTokens[1] // So, depending on which token we have the highest balance for, we swap for the other one. if (lp0Bal > lp1Bal) { toSwap = SwapAmount.getSwapAmount(lp0Bal, reserve0, fee); route[0] = lpTokens[0]; route[1] = lpTokens[1]; } else { toSwap = SwapAmount.getSwapAmount(lp1Bal, reserve1, fee); route[0] = lpTokens[1]; route[1] = lpTokens[0]; 20 } // Perform the swap IPancakeRouter02(pcsRouter) .swapExactTokensForTokens(toSwap, 0, route, address(this), block.timestamp); } IPancakeRouter02(pcsRouter).swapExactTokensForTokens(toWbnb, 0, cakeToWbnbRoute, address(this), block.timestamp); cross-yield/contracts/strategies/StrategyCake.sol#L131 function collectFees() internal { // a percentant of the cake we get from the masterchef will be used to buy BNB and transfer to this address // this is the total fees that will be shared amongst the protocol, stategy dev and the harvester uint256 toWbnb = feeManager.calculateTotalFee(IERC20(farmingToken).balanceOf(address(this))); IPancakeRouter02(pcsRouter).swapExactTokensForTokens(toWbnb, 0, cakeToWbnbRoute, address(this), block.timestamp); uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this)); // distribute hervester fee uint256 harvesterFeeAmount = feeManager.calculateHarvestFee(wbnbBal); // collectFees is called indirectly from the CrossYield contract via the beforeDeposit hook. // This means that _msgSender() is the CrossYield contract and not the actuall EOA account // that send the transaction IERC20(wbnb).safeTransfer(tx.origin, harvesterFeeAmount); // distribute protocol fee uint256 protocolFeeAmount = feeManager.calculateProtocolFee(wbnbBal); // IERC20(wbnb).safeTransfer(protocolFeeRecipient, protocolFeeAmount); feeProcessor.process(protocolFeeAmount); // distribute strategy dev fee uint256 strategyDevFeeAmount = feeManager.calculateStrategyDevFee(wbnbBal); IERC20(wbnb).safeTransfer(feeManager.strategyDev(), strategyDevFeeAmount); emit FeeCollected( toWbnb, 21 harvesterFeeAmount, protocolFeeAmount, strategyDevFeeAmount, _msgSender() ); } cross-yield/contracts/strategies/StrategyCakeLP.sol#L174 function collectFees() internal { // a percentant of the cake we get from the masterchef will be used to buy BNB and transfer to this address // this is the total fees that will be shared amongst the protocol, stategy dev and the harvester uint256 toWbnb = feeManager.calculateTotalFee(IERC20(cake).balanceOf(address(this))); IPancakeRouter02(pcsRouter).swapExactTokensForTokens(toWbnb, 0, cakeToWbnbRoute, address(this), block.timestamp); uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this)); // distribute hervester fee uint256 harvesterFeeAmount = feeManager.calculateHarvestFee(wbnbBal); IERC20(wbnb).safeTransfer(_msgSender(), harvesterFeeAmount); // distribute protocol fee uint256 protocolFeeAmount = feeManager.calculateProtocolFee(wbnbBal); feeProcessor.process(protocolFeeAmount); // distribute strategy dev fee uint256 strategyDevFeeAmount = feeManager.calculateStrategyDevFee(wbnbBal); IERC20(wbnb).safeTransfer(feeManager.strategyDev(), strategyDevFeeAmount); emit FeeCollected( toWbnb, harvesterFeeAmount, protocolFeeAmount, strategyDevFeeAmount, _msgSender() ); } cross-yield/contracts/strategies/StrategyCake.sol 22 function harvest() public override whenNotPaused { // claim rewards IMasterChef(masterchef).leaveStaking(0); // because harvest can automatically be called after each user deposit // we might end up having multiple deposits in the same block and only one // would return rewards from masterchef so the rest will have 0 cake so // we don't need to waste gas to collect fees and call deposit uint256 farmingTokenBalance = balanceOfFarmingToken(); if(farmingTokenBalance > 0) { collectFees(); deposit(); emit HarvestTriggered(_msgSender(), farmingTokenBalance); } } cross-yield/contracts/strategies/StrategyCakeLP.sol#l137-L148 function harvest() external override whenNotPaused { // claim rewards IMasterChef(masterchef).deposit(poolId, 0); uint256 harvestedAmount = IERC20(cake).balanceOf(address(this)); collectFees(); addLiquidity(); deposit(); emit HarvestTriggered(_msgSender(), harvestedAmount); }",
        "labels": [
            "SlowMist",
            "Cross Send V1.0.1",
            "Type: Reordering Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Missing slippage check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Send V1.0.1_en-us.pdf",
        "body": "The addLiquidity function without slippage check, it doesn't have an impermanent loss check. cross-yield/contracts/strategies/StrategyCakeLP.sol#L218 function addLiquidity() internal { OptimalSwap.prepareLiquidity( cake, [lpToken0, lpToken1], wbnb, busd, farmingToken, pcsRouter, swapFee ); // add liquidity to AMM on PCS uint256 lp0Bal = IERC20(lpToken0).balanceOf(address(this)); uint256 lp1Bal = IERC20(lpToken1).balanceOf(address(this)); IPancakeRouter02(pcsRouter) .addLiquidity(lpToken0, lpToken1, lp0Bal, lp1Bal, 0, 0, address(this), block.timestamp); emit LiquidityAdded(lpToken0, lpToken1, lp0Bal, lp1Bal, _msgSender()); }",
        "labels": [
            "SlowMist",
            "Cross Send V1.0.1",
            "Type: Reordering Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Permission check Missing",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Send V1.0.1_en-us.pdf",
        "body": "There is no permission check for deposit function. The function is called by the CrossYieid contract. cross-yield/contracts/strategies/StrategyCakeLP.sol#L225-L231 function deposit() public override whenNotPaused { uint256 farmingTokenBalance = balanceOfFarmingToken(); if (farmingTokenBalance > 0) { IMasterChef(masterchef).deposit(poolId, farmingTokenBalance); } } cross-yield/contracts/strategies/StrategyCake.sol#L169-L175 function deposit() public override whenNotPaused { uint256 farmingTokenBalance = balanceOfFarmingToken(); if (farmingTokenBalance > 0) { IMasterChef(masterchef).enterStaking(farmingTokenBalance); } }",
        "labels": [
            "SlowMist",
            "Cross Send V1.0.1",
            "Type: Authority Control Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Excessive authority issue 25",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Send V1.0.1_en-us.pdf",
        "body": "Owner can modify the address of the strategy. The new strategy may have security risks if it is not audited, which will aect the user's funds. If the private key is leaked, it will aect the user's funds. cross-yield/contracts/core/CrossYield.sol#L224-L236 function upgradeStrategy() public onlyOwner { require(stratCandidate.strategy != address(0), \"No proposal exists\"); require(block.number > stratCandidate.proposedBlock + stratUpgradableAfter, \"Strategy cannot be replaced yet\"); emit NewStrategy(stratCandidate.strategy); strategy.retireStrategy(); strategy = IStrategy(stratCandidate.strategy); stratCandidate.strategy = address(0); stratCandidate.proposedBlock = 0; putFundsToWork(); } cross-yield/contracts/core/CrossYield.sol#L211-L220 function proposeStrategy(address _strategy) public onlyOwner { require(address(this) == IStrategy(_strategy).vault(), \"Invalid new strategy\"); stratCandidate = StrategyCandidate({ strategy: _strategy, proposedBlock: block.number }); emit NewStratCandidate(_strategy); }",
        "labels": [
            "SlowMist",
            "Cross Send V1.0.1",
            "Type: Authority Control Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Repeatable claims issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Send V1.0.1_en-us.pdf",
        "body": "After the claim, lottery.status is not set as claimed, and it is also necessary to check whether lotteryId has been claimed when the claim is executed. hotdrop/contracts/HotDrop.sol#L261-L274 function claim(uint256 lotteryId) external nonReentrant { Lottery storage lottery = lotteries[lotteryId]; require(lottery.status == Status.WinnerDrawn, \"winner not drawn\"); // if there is no winner transfer the total amount to the treasury if(tickets[lotteryId][lottery.winningNumber] == address(0)) { lottery.purchaseToken.safeTransfer(treasury, lottery.purchaseToken.balanceOf(address(this))); } else if(tickets[lotteryId][lottery.winningNumber] == _msgSender()) { // if the ticket is the winning ticket and belongs to the user then split the pot uint256 treasuryAmount = (lottery.totalRaised * lottery.treasuryFee) / FEE_BASE; lottery.purchaseToken.safeTransfer(treasury, treasuryAmount); lottery.purchaseToken.safeTransfer(_msgSender(), lottery.totalRaised - treasuryAmount); } }",
        "labels": [
            "SlowMist",
            "Cross Send V1.0.1",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Round plan security reminder",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cross Send V1.0.1_en-us.pdf",
        "body": "And the new round of lottery can only be opened when the last round of lottery is in WinnerDrawn, otherwise randomGenerator.latestLotteryId will be updated, which will cause the old lottery round to fail to execute drawWinner function due to this check. require(lotteryId == randomGenerator.latestLotteryId(), \"numbers not drawn\"); hotdrop/contracts/HotDrop.sol#L44-L256 function drawWinner(uint256 lotteryId) external nonReentrant { Lottery storage lottery = lotteries[lotteryId]; require(lottery.status == Status.Close, \"lottery still active\"); require(lotteryId == randomGenerator.latestLotteryId(), \"numbers not drawn\"); // get the winning number based on the randomResult generated by ChainLink's fallback uint256 winningNumber = randomGenerator.randomResult(); lottery.winningNumber = winningNumber; lottery.status = Status.WinnerDrawn; emit LotteryNumberDrawn(lotteryId, winningNumber); }",
        "labels": [
            "SlowMist",
            "Cross Send V1.0.1",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Trustin_en_us.pdf",
        "body": "In the Comptroller, CToken, SimplePriceOracle, and Unitroller contracts, the admin role can modify key sensitive parameters such as the manager roles, the rate model, the market, the pause status, the whitelist, the price of the underlying asset, and the admin role, which will lead to the risk of over-privilege of the admin role. ",
        "labels": [
            "SlowMist",
            "Trustin_en_us",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Decimal loss with an empty marke",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Trustin_en_us.pdf",
        "body": "If there are two markets, one of which was used by the UI, one of which was empty. Someone can mint collateral tokens in an empty market and redeem most minted tokens, then donate redeemed asset tokens to inate the exchange rate through the getAccountSnapshot function. Next, borrow a dierent asset with the manipulated exchange rate, and redeem collateral to recover donation. However, the redeemUnderlying function may wrongly be rounded down on the tokens to remove from a malicious caller, which causes the redemption of many tokens only to require little underlying assets. The last, liquidation borrower contract position with borrowed funds and redeem collateral tokens to reset the empty market. Reference: https://www.comp.xyz/t/hundred-nance-exploit-and-compound-v2/4266 ",
        "labels": [
            "SlowMist",
            "Trustin_en_us",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Receive can lock users native tokens",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Trustin_en_us.pdf",
        "body": "There is a receive function in the CErc20Delegator, Timelock, and Unitroller contracts so that the contracts can receive native tokens. However, the receive function can lock users native tokens when users transfer the native token in these contracts by mistake and there is no token processing logic. ",
        "labels": [
            "SlowMist",
            "Trustin_en_us",
            "Type: Others",
            "Severity: Low"
        ]
    },
    {
        "title": "Missing the event record",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Trustin_en_us.pdf",
        "body": "The admin role can modify the compAddress parameter, but there are no event logs in these functions. ",
        "labels": [
            "SlowMist",
            "Trustin_en_us",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "External call reminder",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Trustin_en_us.pdf",
        "body": "In the Comptroller contract, users can call the claimZnt to claim the comp in markets, but the implementation address is seting by the admin and the import Zenith is not in the audit scope. ",
        "labels": [
            "SlowMist",
            "Trustin_en_us",
            "Type: Unsafe External Call Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing event record",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cell Core_en-us.pdf",
        "body": "The following functions do not log events. contracts/Cell.sol updateStageRecordMaxCount updateStageRecordCostPoint updateStageRecordIncPoint updateStageRecordValid addSigner removeSigner setProxyer contracts/Nucleus.sol setOracleAddress contracts/Oracle.sol addOracleAddress removeOracleAddress setTokenNameAddress setRates setRatePeriod setFixedPrice revokeFixedPrice contracts/Proxy.sol setOracleAddress setCellAddress setMintPrice",
        "labels": [
            "SlowMist",
            "Cell Core",
            "Type: Malicious Event Log Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Safe transfer issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cell Core_en-us.pdf",
        "body": "contracts/Nucleus.sol Use transferFrom in the claim function to transfer the token. If the token in the operation does not meet the eip20 standard, the transaction may fail. contracts/Proxy.sol Use transferFrom in the mint function to transfer the token. If the token in the operation does not meet the eip20 standard, the transaction may fail.",
        "labels": [
            "SlowMist",
            "Cell Core",
            "Type: Others",
            "Severity: Low"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Cell Core_en-us.pdf",
        "body": "contracts/Cell.sol The owner has too much authority, and if the owner's private key is leaked, the attacker can control the casting of NFT. contracts/Oracle.sol The owner has too much authority. If the owner's private key is leaked, the attacker can manipulate the price by setting setRates and setFixedPrice . contracts/Proxy.sol The owner's authority is too large. If the owner's private key is leaked, the attacker can withdraw the revenue in the contract. You can also set a malicious Oracle contract through setOracleAddress to control the price. contracts/Nucleus.sol The owner has too much authority. If the owner's private key is leaked, the attacker can set a malicious Oracle contract through setOracleAddress to control the price.",
        "labels": [
            "SlowMist",
            "Cell Core",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Preemptive Initialization",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Doubler - 20240117.pdf",
        "body": "contracts/FRNFT.sol This function has the problem of being preempted. function initialize(address doublerPool) external { require(_initialized == false, \"initialized err\"); _initialized = true; _doublerPool = doublerPool; _grantRole(DOUBLER_ROLE, doublerPool); } contracts/Doubler.sol This function has the problem of being preempted. function initialize( address _initTeam, address _initEco, address _initFastPriceFeed, address _initDoublerNFT, address _initDbrTokenAddress, address _initMultiSigWallet, uint16 _initProtectBlock ) external { if (_initialized == true) revert E_Initialized(); _initialized = true; _team = _initTeam; _eco = _initEco; _fastPriceFeed = _initFastPriceFeed; _FRNFT = _initDoublerNFT; _ecoFeeRatio = 2000; // 20% * 100 _feeRatio = 20; // 0.2% * 100 _protectBlock = _initProtectBlock; _grantRole(DEFAULT_ADMIN_ROLE, _initMultiSigWallet); emit Initialize(_initTeam, _initFastPriceFeed, _initDoublerNFT, _initDbrTokenAddress, _initMultiSigWallet); }",
        "labels": [
            "SlowMist",
            "Doubler - 20240117",
            "Type: Race Conditions Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Doubler - 20240117.pdf",
        "body": "contracts/FastPriceFeed.sol The admin role can be set to price related, if the private key leakage will cause the price anomaly caused by the pool function is impaired. admin can newAsset admin can updatePriceAggregator admin can upgradePlan admin can setTwapInterval",
        "labels": [
            "SlowMist",
            "Doubler - 20240117",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Pool depth and TWAP interval in uniswap V3 price queries",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Doubler - 20240117.pdf",
        "body": "contracts/FastPriceFeed.sol When getting the price of the token, you should pay attention to the depth of the corresponding pool, if the depth of the pool is too shallow and the price range is set too low, there is still a possibility of price manipulation. function getPriceFromDex(address _asset) internal view returns (uint256 price) { require(_isSupported[_asset], 'UniV3: oracle in mainnet not initialized yet!'); address uniswapV3Pool = _assetFeedMap[_asset]; uint32 twapInterval = _twapIntervals[_asset]; IUniswapV3Pool pool = IUniswapV3Pool(uniswapV3Pool); IUniswapV3Pool.Slot0 memory slot0; IUniswapV3Pool.Observation memory obs; slot0 = pool.slot0(); obs = pool.observations((slot0.observationIndex + 1) % slot0.observationCardinality); require(obs.initialized, \"UNIV3: Pair did't initialized\"); uint32 delta = uint32(block.timestamp) - obs.blockTimestamp; require(delta >= twapInterval, 'UniV3: token pool does not have enough transaction history in mainnet'); uint32[] memory secondsAgos = new uint32[](2); secondsAgos[0] = twapInterval; secondsAgos[1] = 0; (int56[] memory tickCumulatives, ) = pool.observe(secondsAgos); uint160 sqrtPriceX96 = TickMath.getSqrtRatioAtTick( int24((tickCumulatives[1] - tickCumulatives[0]) / int56(uint56(twapInterval))) ); (uint256 price0, uint256 price1) = mockDexPrice(pool, sqrtPriceX96); return pool.token0() == _asset ? price0 : price1; }",
        "labels": [
            "SlowMist",
            "Doubler - 20240117",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Recommendations on the conditions of winner",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Doubler - 20240117.pdf",
        "body": "contracts/Doubler.sol In some extreme cases, it may be possible to control the nal winner.",
        "labels": [
            "SlowMist",
            "Doubler - 20240117",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Suggestions for setTwapInterval",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Doubler - 20240117.pdf",
        "body": "contracts/FastPriceFeed.sol It should be a supported token to set the interval. function setTwapInterval(address _asset, uint32 _twapInterval) external onlyRole(DEFAULT_ADMIN_ROLE) { require(!_isSupported[_asset], 'Oracle: do not support this token'); require(_plans[_asset] == Plan.DEX, \"setTwapInterval: Only dex _asset\"); require( MAX_INTERVA >= _twapIntervals[_asset] && _twapIntervals[_asset] >= MIN_INTERVA, 'setTwapInterval: Invalid twapInterval' ); emit SetTwapInterval(_asset, _twapIntervals[_asset], _twapInterval); _twapIntervals[_asset] = _twapInterval; }",
        "labels": [
            "SlowMist",
            "Doubler - 20240117",
            "Type: Others",
            "Severity: Low"
        ]
    },
    {
        "title": "Redundant code",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Doubler - 20240117.pdf",
        "body": "contracts/Doubler.sol The hot in the structure is not used. struct Pool { address asset; address creator; address terminator; uint16 fallRatio; uint16 profitRatio; uint16 rewardRatio; uint16 winnerRatio; uint32 double; uint32 lastLayer; uint256 tokenId; uint256 unitSize; uint256 maxRewardUnits; uint256 winnerOffset; uint256 endPrice; uint256 hot; //SLOWMIST// unused uint256 lastOpenPrice; uint256 tvl; uint256 amount; uint256 margin; uint256 joins; uint256 lastInputBlockNo; uint256 kTotal; }",
        "labels": [
            "SlowMist",
            "Doubler - 20240117",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Function permission control issues",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Doubler - 20240117.pdf",
        "body": "contracts/FRNFT.sol The roles used by these functions are not set and cannot be executed subsequently. setTokenRoyalty resetTokenRoyalty setDefaultRoyaltyInfo deleteDefaultRoyalty",
        "labels": [
            "SlowMist",
            "Doubler - 20240117",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Overlooking purchase price relative to target prot in pool ending logic",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Doubler - 20240117.pdf",
        "body": "contracts/Doubler.sol The scenario where the purchase price is less than or equal to the target prot price has not been considered. When the price at the time of purchase is less than or equal to the target prot price, the purchase should not be allowed. Otherwise, users can manipulate the ending of the pool after purchasing to position themselves as the winner. function _input(AddInput memory _addInput, uint8 _decimals) internal returns (uint256 tokenId) { Pool memory pool = _poolMap[_addInput.poolId]; if (_addInput.margin == 0 || _addInput.margin > _addInput.amount || _addInput.margin.mod(pool.unitSize) != 0) revert E_Margin(); if (IERC20(pool.asset).allowance(_msgSender(), address(this)) < _addInput.margin) revert E_Approve(); if (IERC20(pool.asset).balanceOf(_msgSender()) < _addInput.margin) revert E_Balance(); if (_addInput.multiple < 1 || _addInput.margin.mul(_addInput.multiple) != _addInput.amount) revert E_Multiple(); if (_addInput.multiple > 1 && _addInput.multiple > _getMaxMultiple(pool, _addInput.curPrice, _decimals)) revert E_MultipleLimit(); _addInput.layer = _getLastLayer(_addInput.poolId, _addInput.curPrice, _addInput.amount); LayerData memory layer = _layerDataMap[_addInput.poolId][_addInput.layer]; if (layer.amount >= layer.cap) revert E_LayerCap(); if (layer.cap.sub(layer.amount) < _addInput.margin) { _addInput.margin = _addInput.amount = layer.cap.sub(layer.amount); } else { _addInput.amount = layer.cap.sub(layer.amount) < _addInput.amount ? layer.cap.sub(layer.amount) : _addInput.amount; } IERC20(pool.asset).safeTransferFrom(_msgSender(), address(this), _addInput.margin); uint256 layerAmount = _addTvl(_addInput); uint256 layerRanking = layerAmount.div(pool.unitSize); tokenId = IFRNFT(_FRNFT).mint( _msgSender(), _addInput.poolId, _addInput.layer, _addInput.margin, _addInput.amount, _addInput.curPrice, layerRanking ); emit NewInput( tokenId, _addInput.poolId, _msgSender(), _addInput.layer, _addInput.margin, _addInput.amount, _addInput.curPrice ); }",
        "labels": [
            "SlowMist",
            "Doubler - 20240117",
            "Type: Others",
            "Severity: High"
        ]
    },
    {
        "title": "Excessive Authority Issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - wault.finance(WEXPolyMaster)_en-us.pdf",
        "body": "The owner can set the value of wexPerBlock arbitrarily, which will affect the profit of wexReward, and there is no limit on the value range of wexPerBlock, and there is a issue of excessive authority. https://polygonscan.com/address/0xC8Bd86E5a132Ac0bf10134e270De06A8Ba317BFe#code function setWexPerBlock(uint256 _wexPerBlock) public onlyOwner { require(_wexPerBlock > 0, \"!wexPerBlock-0\"); wexPerBlock = _wexPerBlock; } Owner can add pool, can set the allocPoint of pool, there is a issue of selfish mining. function add( uint256 _allocPoint, IERC20 _lpToken, bool _withUpdate ) public onlyOwner { if (_withUpdate) { massUpdatePools(); } uint256 lastRewardBlock = block.number > startBlock ? block.number : startBlock; totalAllocPoint = totalAllocPoint.add(_allocPoint); poolInfo.push( 6 PoolInfo({ lpToken: _lpToken, allocPoint: _allocPoint, lastRewardBlock: lastRewardBlock, accWexPerShare: 0 }) ); function set( uint256 _pid, uint256 _allocPoint, bool _withUpdate ) public onlyOwner { if (_withUpdate) { massUpdatePools(); } totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add( _allocPoint ); poolInfo[_pid].allocPoint = _allocPoint; }",
        "labels": [
            "SlowMist",
            "wault.finance(WEXPolyMaster)",
            "Type: Others",
            "Severity: Low"
        ]
    },
    {
        "title": "Event log missing",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - earning.farm_en-us.pdf",
        "body": "12 contracts/core/EFLeverVault.sol Modifying important variables in the contract requires corresponding event records. function initAddresses(address[7] memory addr) public onlyOwner{ aave = addr[0]; balancer = addr[1]; balancer_fee = addr[2]; lido = addr[3]; asteth = addr[4]; curve_pool = addr[5]; weth = addr[6]; } contracts/core/EFCRVVault.sol Modifying important variables in the contract requires corresponding event records. function initAddresses(address[11] memory addr) public onlyOwner{ crv = addr[0]; usdc = addr[1]; eth_usdc_router = addr[2]; weth = addr[3]; cvxcrv = addr[4]; eth_crv_router = addr[5]; crv_cvxcrv_router = addr[6]; eth_usdt_router = addr[7]; usdt = addr[8]; oracle = addr[9]; staker = addr[10]; }",
        "labels": [
            "SlowMist",
            "earning.farm",
            "Type: Malicious Event Log Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - earning.farm_en-us.pdf",
        "body": "contracts/core/EFLeverVault.sol The owner's authority is too large. If the private key is lost, the attacker can use the pause function to transfer the funds in the contract through callWithData ,or directly transfer astheth. function callWithData(address payable to, bytes memory data, uint256 amount)public payable onlyOwner{ (bool status, ) = to.call.value(amount)(data); require(status, \"call failed\"); } function delegateCallWithData(address payable to, bytes memory data)public payable onlyOwner{ (bool status, ) = to.delegatecall(data); require(status, \"call failed\"); }",
        "labels": [
            "SlowMist",
            "earning.farm",
            "Type: Authority Control Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Potential Sandwich Attack Risk",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - earning.farm_en-us.pdf",
        "body": "contracts/core/EFCRVVault.sol 14 it will perform the token swap operation through the swapExactTokensForTokens function. But the incoming minAmountOut is 0 , which will not do slippage checking,There is a risk of being attacked by sandwiches. function depositStable(uint256 _amount) public payable nonReentrant{ require(!is_paused, \"paused\"); require(IERC20(usdc).allowance(msg.sender, address(this)) >= _amount, \"CFVault: not enough allowance\"); IERC20(usdc).safeTransferFrom(msg.sender, address(this), _amount); if (IERC20(usdc).allowance(address(this), eth_usdc_router) != 0){ IERC20(usdc).approve(eth_usdc_router, 0); } IERC20(usdc).approve(eth_usdc_router, _amount); uint256 weth_before = IERC20(weth).balanceOf(address(this)); address[] memory t = new address[](2); t[0] = usdc; t[1] = weth; UniswapV3Interface(eth_usdc_router).swapExactTokensForTokens(_amount, 0, t, address(this)); uint256 weth_amount = IERC20(weth).balanceOf(address(this)).safeSub(weth_before); if (IERC20(weth).allowance(address(this), eth_crv_router) != 0){ IERC20(weth).approve(eth_crv_router, 0); } IERC20(weth).approve(eth_crv_router, weth_amount); uint256 tt_before = IERC20(crv).balanceOf(address(this)); CurveInterface256(eth_crv_router).exchange(0, 1, weth_amount, 0); uint256 tt_amount = IERC20(crv).balanceOf(address(this)).safeSub(tt_before); _deposit(_amount, tt_amount); }",
        "labels": [
            "SlowMist",
            "earning.farm",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Potential Sandwich Attack Risk",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - earning.farm_en-us.pdf",
        "body": "contracts/core/EFCRVVault.sol it will perform the token swap operation through the swapExactTokensForTokens function. But the incoming minAmountOut is 0 , which will not do slippage checking,There is a risk of being attacked by sandwiches. function withdraw(uint256 _amount, bool _use_stable) public nonReentrant{ require(!is_paused, \"paused\"); { uint256 total_balance = IERC20(ef_token).balanceOf(msg.sender); require(total_balance >= _amount, \"not enough LP tokens\"); } uint256 target_amount; { //if (IERC20(ef_token).totalSupply() == 0) require(false, \"000\"); uint256 lp_amount = _amount.safeMul(lp_balance).safeDiv(IERC20(ef_token).totalSupply()); uint256 target_before = IERC20(crv).balanceOf(address(this)); _withdraw(lp_amount); target_amount = IERC20(crv).balanceOf(address(this)).safeSub(target_before); } uint256 f = 0; if(withdraw_fee_ratio != 0 && fee_pool != address(0x0)){ f = target_amount.safeMul(withdraw_fee_ratio).safeDiv(ratio_base); target_amount = target_amount.safeSub(f); IERC20(crv).transfer(fee_pool, f); TokenInterfaceERC20(ef_token).destroyTokens(msg.sender, _amount); }else{ TokenInterfaceERC20(ef_token).destroyTokens(msg.sender, _amount); } if (!_use_stable){ IERC20(crv).transfer(msg.sender, target_amount); emit CFFWithdraw(msg.sender, target_amount, target_amount.safeMul(uint256(ChainlinkInterface(oracle).latestAnswer())).safeDiv(1e2 16 0), _amount, f, getVirtualPrice()); } else{ if (IERC20(crv).allowance(address(this), eth_crv_router) != 0){ IERC20(crv).approve(eth_crv_router, 0); } IERC20(crv).approve(eth_crv_router, target_amount); uint256 weth_amount; { uint256 weth_before = IERC20(weth).balanceOf(address(this)); CurveInterface256(eth_crv_router).exchange(1, 0, target_amount, 0); weth_amount = IERC20(weth).balanceOf(address(this)).safeSub(weth_before); } if (IERC20(weth).allowance(address(this), eth_usdc_router) != 0){ IERC20(weth).approve(eth_usdc_router, 0); } IERC20(weth).approve(eth_usdc_router, weth_amount); uint256 usdc_amount; { address[] memory t = new address[](2); t[0] = weth; t[1] = usdc; uint256 usdc_before = IERC20(usdc).balanceOf(address(this)); UniswapV3Interface(eth_usdc_router).swapExactTokensForTokens(weth_amount, 0, t, address(this)); usdc_amount = IERC20(usdc).balanceOf(address(this)).safeSub(usdc_before); } IERC20(usdc).transfer(msg.sender, usdc_amount); emit CFFWithdraw(msg.sender, target_amount, usdc_amount, _amount, f, getVirtualPrice()); } }",
        "labels": [
            "SlowMist",
            "earning.farm",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Redundant code",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - earning.farm_en-us.pdf",
        "body": "contracts/erc20/ERC20Impl.sol onTransferDone function not being called function onTransferDone(address _from, address _to, uint256 _amount) internal { for(uint i = 0; i < transferListeners.length; i++){ TransferEventCallBack t = TransferEventCallBack(transferListeners[i]); t.onTransfer(_from, _to, _amount); } }",
        "labels": [
            "SlowMist",
            "earning.farm",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Redundant code",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - earning.farm_en-us.pdf",
        "body": "contracts/core/EFLeverVault.sol IERC20(weth).balanceOf(address(this)) return result unused. function raiseActualLTV(uint256 lt) public onlyOwner{//take lt = 7500 uint256 e = getDebt(); uint256 st = getCollecteral(); require(e.safeMul(10000) < st.safeMul(mlr), \"no need to raise\"); uint256 x = st.safeMul(mlr).safeSub(e.safeMul(10000)).safeDiv(uint256(10000).safeSub(mlr));//x = 18 (mST-E)/(1-m) uint256 y = st.safeMul(lt).safeDiv(10000).safeSub(e).safeSub(1); if (x > y) {x = y;} IAAVE(aave).borrow(weth, x, 2, 0, address(this)); IWETH(weth).withdraw(IERC20(weth).balanceOf(address(this))); ILido(lido).submit.value(address(this).balance)(address(this)); IERC20(weth).balanceOf(address(this));//SlowMist//return result unused if (IERC20(lido).allowance(address(this), aave) != 0) {IERC20(lido).safeApprove(aave, 0);} IERC20(lido).safeApprove(aave, IERC20(lido).balanceOf(address(this))); IAAVE(aave).deposit(lido, IERC20(lido).balanceOf(address(this)), address(this), 0); emit ActualLTVChanged(e, st, getDebt(), getCollecteral()); }",
        "labels": [
            "SlowMist",
            "earning.farm",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - earning.farm_en-us.pdf",
        "body": "contracts/core/EFLeverVault.sol If the owner permission is lost, the attacker can achieve free recharge by changing the address of the token, thereby taking away the funds in the contract. function initAddresses(address[7] memory addr) public onlyOwner{ aave = addr[0]; balancer = addr[1]; balancer_fee = addr[2]; lido = addr[3]; 19 asteth = addr[4]; curve_pool = addr[5]; weth = addr[6]; emit CFFNewAddress(addr); } contracts/core/EFCRVVault.sol function initAddresses(address[11] memory addr) public onlyOwner{ crv = addr[0]; usdc = addr[1]; eth_usdc_router = addr[2]; weth = addr[3]; cvxcrv = addr[4]; eth_crv_router = addr[5]; crv_cvxcrv_router = addr[6]; eth_usdt_router = addr[7]; usdt = addr[8]; oracle = addr[9]; staker = addr[10]; emit CFFNewAddress(addr); }",
        "labels": [
            "SlowMist",
            "earning.farm",
            "Type: Authority Control Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - earning.farm_en-us.pdf",
        "body": "contracts/core/EFCRVVault.sol 20 delegateCallWithData is an arbitrary external call, if the private key is lost the attacker can unstake and transfer the funds And for users who have previously authorized the current contract, the attacker can transfer funds that are not operated by the user himself by constructing a malicious contract. function delegateCallWithData(address payable to, bytes memory data)public payable onlyOwner{ (bool status, ) = to.delegatecall(data); require(status, \"call failed\"); }",
        "labels": [
            "SlowMist",
            "earning.farm",
            "Type: Authority Control Vulnerability",
            "Severity: Critical"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Bitlayer Bridge.pdf",
        "body": "1.The BitlayerBridge contracts are implemented using the OpenZeppelin upgradeable model, allowing the AdminRole role to perform contract upgrades. However, this design introduces an excessive privilege risk. 2.In the BitlayerBridge contract, the UnlockRole role can call the unlock function to unlock the ETH locked in the contract; the LiquidityRole role can call the removeLiquidityTo function to remove the liquidity of any address. BitlayerBridge.sol#L125-L134,L148-L163 function removeLiquidityTo(address to, uint256 amount) external onlyRole(LiquidityRole) whenNotPaused { ``` } function unlock(string memory _txHash, address to, uint256 amount) external onlyRole(UnlockRole) whenNotPaused { ``` } } 3.In the BitlayerBridge contract, AdminRole role can set important parameters of the contract. BitlayerBridge.sol function setFeeAddress function setLockFee function setMinLockAmount function setMaxLockAmount",
        "labels": [
            "SlowMist",
            "Bitlayer Bridge",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Missing zero address check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Bitlayer Bridge.pdf",
        "body": "In the BitlayerBridge contract, the zero address check is missing in the initialize function and unlock function. BitlayerBridge.sol#L36-L75,L148-L163 function initialize(  ) public initializer {  feeAddress = _feeAddress;  } function unlock(string memory _txHash, address to, uint256 amount) external onlyRole(UnlockRole) whenNotPaused {  (bool success, bytes memory returndata) = payable(to).call{value: amount} (\"\");  }",
        "labels": [
            "SlowMist",
            "Bitlayer Bridge",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Return value not checked",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Bitlayer Bridge.pdf",
        "body": "In the BitlayerBridge contract, the return value is not checked when the initialize function calls the _grantRole function. BitlayerBridge.sol#L36-L75 function initialize( ``` ) public initializer { _grantRole(AdminRole, admin); ``` }",
        "labels": [
            "SlowMist",
            "Bitlayer Bridge",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Parameter Validation Missing in unlock Function",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Bitlayer Bridge.pdf",
        "body": "In the BitlayerBridge contract, the unlock function does not verify the validity of the parameters passed in. The UnlockRole role can enter any _txHash (not recorded by txUnlocked mapping) and amount to unlock the ETH in the contract and transfer it to the specied address. BitlayerBridge.sol#L148-L163 function unlock(string memory _txHash, address to, uint256 amount) external onlyRole(UnlockRole) whenNotPaused { bytes32 txHash = keccak256(abi.encode(_txHash)); require(!txUnlocked[txHash], \"txHash already unlocked\"); txUnlocked[txHash] = true; (bool success, bytes memory returndata) = payable(to).call{value: amount} (\"\"); require(success, string(returndata)); totalUnlocked += amount; emit NativeUnlocked(_txHash, to, amount); }",
        "labels": [
            "SlowMist",
            "Bitlayer Bridge",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Min lock amount not checked against max",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Bitlayer Bridge.pdf",
        "body": "In the BitlayerBridge contract, whether the variable minLockAmount is less than the variable maxLockAmount is not checked in the initialize function, setMinLockAmount function, and setMaxLockAmount function. If the variable minLockAmount is greater than the variable maxLockAmount , the lock function cannot be used. BitlayerBridge.sol#L41-L85,L113-L118,L120-L125 function initialize( ``` ) public initializer { ``` minLockAmount = _minLockAmount; maxLockAmount = _maxLockAmount; } function setMinLockAmount(uint256 min) external onlyRole(AdminRole) { uint256 oldMin = minLockAmount; minLockAmount = min; emit MinLockAmountSet(oldMin, min); } function setMaxLockAmount(uint256 max) external onlyRole(AdminRole) { uint256 oldMax = maxLockAmount; maxLockAmount = max; emit MaxLockAmountSet(oldMax, max); }",
        "labels": [
            "SlowMist",
            "Bitlayer Bridge",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Reentrancy risks",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DappOS Contracts Core.pdf",
        "body": "In the PayDB contract, the executeDstOrderETH , executeDstOrderETH , tryExecuteDstOrderETH , cancelOrderETH , _executeIsolateOrder , and _createSrcOrder functions do not add anti-reentrancy locks, and there is a risk of reentrancy attacks when calling the safeTransferETH function. contracts/core/PayDB.sol#L75-L153,L162-L249,L287-L335,L337-L383,L385-L475 function executeDstOrderETH( address orderOwner, address receiver, address wallet, ExePayOrderParam[] calldata eparams, IVWManager.VWExecuteParam calldata vwExeParam ) external payable override{ ```` if (eparams[i].tokenOut == address(0)) { TransferHelper.safeTransferETH( _realReceiver, eparams[i].amountOut ); totalETH += eparams[i].amountOut; } else { TransferHelper.safeTransferFrom( eparams[i].tokenOut, msg.sender, _realReceiver, eparams[i].amountOut ); } ```` } function tryExecuteDstOrderETH( address orderOwner, address receiver, address wallet, ExePayOrderParam[] calldata eparams, IVWManager.VWExecuteParam calldata vwExeParam ) external payable override { ```` if (eparams[i].tokenOut == address(0)) { TransferHelper.safeTransferETH( _realReceiver, eparams[i].amountOut ); totalETH += eparams[i].amountOut; } else { TransferHelper.safeTransferFrom( eparams[i].tokenOut, msg.sender, _realReceiver, eparams[i].amountOut ); } ```` } function cancelOrderETH( address sender, address receiver, CreatePayOrderParam[] calldata cparams, bytes32[] calldata workFlowHashs ) external payable override { ```` require(msg.value == totalETH,\"E18\"); if(totalETH > 0){ TransferHelper.safeTransferETH(sender, msg.value); } ```` } function _executeIsolateOrder( address receiver, address wallet, ExePayOrderParam[] calldata eparams, IVWManager.VWExecuteParam calldata vwExeParam ) internal { ```` if (eparams[i].tokenOut == address(0)) { TransferHelper.safeTransferETH( receiver, eparams[i].amountOut ); totalETH += eparams[i].amountOut; } else { TransferHelper.safeTransferFrom( eparams[i].tokenOut, msg.sender, receiver, eparams[i].amountOut ); } ```` } function _createSrcOrder( address _orderOwner, address wallet, address receiver, CreatePayOrderParam[] calldata cparams, VwOrderDetail calldata vwDetail, CallParam calldata callParam ) internal { ```` if (cparams[i].tokenIn == address(0)) { // Transfer ETH to node TransferHelper.safeTransferETH( cparams[i].node, cparams[i].amountIn ); totalEth += cparams[i].amountIn; } else { // Transfer ERC20 to node TransferHelper.safeTransferFrom( cparams[i].tokenIn, msg.sender, cparams[i].node, cparams[i].amountIn ); } ```` }",
        "labels": [
            "SlowMist",
            "DappOS Contracts Core",
            "Type: Reentrancy Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Unauthorized information status modication",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DappOS Contracts Core.pdf",
        "body": "In the storeInfo function of the VWManager contract, we found the following issues 1. Any user can set the willDelete parameter of information stored by other users to false, thereby deleting infoSender[infoHash] so that it cannot be deleted. 2. Key Parameter Settings Unrecorded Events. 3. The function may be subject to MEV attacks, causing the user to store infoSender[infoHash] = msg.sender as the attacker's address when storing information. contracts/core/vwmanager/VWManager.sol#L295-L311 function storeInfo( bytes calldata info, bool willDelete ) external { if(info.length > 0){ bytes32 infoHash = keccak256(info); if(eip1271Info[infoHash].length == 0){ eip1271Info[infoHash] = info; emit InfoStored(infoHash, info); if(willDelete){ infoSender[infoHash] = msg.sender; } } else if(!willDelete) { delete infoSender[infoHash]; } } }",
        "labels": [
            "SlowMist",
            "DappOS Contracts Core",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Unveried feeReceiver parameter",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DappOS Contracts Core.pdf",
        "body": "The cancelTx , changeOwner , approveResetter , and resetOwner functions of the VWManagerService contract, the feeReceiver parameter is not veried. It may be subject to MEV attack risk. The attacker replaces the feeReceiver parameters, causing losses. contracts/core/vwmanager/VWManagerService.sol#L53-L92,L123-L161,L177-L217,L227-L256 function cancelTx( uint256 code, address wallet, uint256 codeToCancel, FeeParam calldata fParam, bytes calldata signature ) external {  bytes32 dataHash = keccak256( abi.encode( CANCEL_TYPEHASH, code, codeToCancel, fParam.gasToken, fParam.gasTokenPrice, fParam.priorityFee, fParam.gasLimit ) ); result[walletOwner[wallet]][codeToCancel] = uint256(CodeStatus.CANCELED); result[walletOwner[wallet]][code] = uint256(CodeStatus.SUCCEED); emit TxCanceled(codeToCancel); verifyOperation( walletOwner[wallet], domainSeparator[srcChain], dataHash, signature, CANCEL_TYPEHASH ); _walletPayFee(wallet, preGas, fParam); } function changeOwner( uint256 code, address wallet, address newOwner, FeeParam calldata fParam, bytes calldata signature ) external {  bytes32 dataHash = keccak256( abi.encode( CHANGE_OWNER_TX_TYPEHASH, code, newOwner, fParam.gasToken, fParam.gasTokenPrice, fParam.priorityFee, fParam.gasLimit ) ); address previousOwner = _resetOwner(wallet, newOwner); result[walletOwner[wallet]][code] = uint256(CodeStatus.SUCCEED); verifyOperation( previousOwner, domainSeparator[srcChain], dataHash, signature, CHANGE_OWNER_TX_TYPEHASH ); _walletPayFee(wallet, preGas, fParam); } function approveResetter( uint256 code, address wallet, address resetter, bool approved, FeeParam calldata fParam, bytes calldata signature ) external returns (bytes32 dataHash) {  dataHash = keccak256( abi.encode( RESETTER_APPROVE_TYPEHASH, code, resetter, approved, fParam.gasToken, fParam.gasTokenPrice, fParam.priorityFee, fParam.gasLimit ) ); approvedResetter[wallet] = approved ? resetter : address(0); emit ResetterChanged(approvedResetter[wallet]); result[walletOwner[wallet]][code] = uint256(CodeStatus.SUCCEED); verifyOperation( walletOwner[wallet], domainSeparator[srcChain], dataHash, signature, RESETTER_APPROVE_TYPEHASH ); _walletPayFee(wallet, preGas, fParam); } function resetOwner( uint256 code, address wallet, address newOwner, FeeParam calldata fParam, bytes calldata data ) external nonReentrant{  require ( IVWResetter(approvedResetter[wallet]).verify( wallet, newOwner, data, fParam.gasToken, fParam.gasTokenPrice, fParam.priorityFee, fParam.gasLimit ), \"E5\"); _resetOwner(wallet, newOwner); result[walletOwner[wallet]][code] = uint256(CodeStatus.SUCCEED); _walletPayFee(wallet, preGas, fParam); }",
        "labels": [
            "SlowMist",
            "DappOS Contracts Core",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Reentrancy risks",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DappOS Contracts Core.pdf",
        "body": "In the PayLock contract, the deposit function does not add an anti-reentrancy lock, and there is a risk of reentrancy attacks when calling the safeTransferFrom function. contracts/core/PayLock.sol#L73-L78 function deposit(address token, uint amount, address node) external { uint256 beforeTransfer = IERC20(token).balanceOf(address(this)); TransferHelper.safeTransferFrom(token, msg.sender, address(this), amount); uint256 afterTransfer = IERC20(token).balanceOf(address(this)); _deposit(token, afterTransfer - beforeTransfer, node); }",
        "labels": [
            "SlowMist",
            "DappOS Contracts Core",
            "Type: Reentrancy Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DappOS Contracts Core.pdf",
        "body": "Owner accounts can operate the key functions. PayLock punish PayLock configToken PayLock configWithdrawPendingTime VWManager configFee VWManager VWManager requestConfigSrcChain configSrcChain",
        "labels": [
            "SlowMist",
            "DappOS Contracts Core",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Unveried manager and feeReceiver parameter",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DappOS Contracts Core.pdf",
        "body": "In the verifyProof function of the VWManager contract, only the 8 parameters in vweParam were veried, and the manager and feeReceiver parameters were not veried. contracts/core/vwmanager/VWManager.sol#L113-L145 function verifyProof(uint resCode, address wallet, VWExecuteParam calldata vweParam) internal { address vwOwner = walletOwner[wallet]; result[vwOwner][vweParam.code] = resCode; (uint256 dstChainId, uint256 srcChain, uint256 expTime) = VWCode.chainidsAndExpTime(vweParam.code); require(dstChainId == block.chainid, 'E3'); require(block.timestamp <= expTime, 'E6'); require(domainSeparator[srcChain] != bytes32(0), 'E31'); bytes32 rootHash = keccak256( abi.encode( APPROVE_SERVICE_TX_TYPEHASH, vweParam.code, keccak256(vweParam.data), vweParam.service, vweParam.gasToken, vweParam.gasTokenPrice, vweParam.priorityFee, vweParam.gasLimit, vweParam.isGateway ) ); if (vweParam.proof.length > 0) { rootHash = MerkleProof.processProof(vweParam.proof, rootHash); rootHash = keccak256(abi.encode(APPROVE_SERVICE_PROOF_TX_TYPEHASH, rootHash)); } // srcChain is the chain where user sign the rootHash if (Address.isContract(vwOwner)) { require(IWalletOwner(vwOwner).verifyVWParam(rootHash, domainSeparator[srcChain], vweParam), 'E1'); } else { SignLibrary.verify(vwOwner, domainSeparator[srcChain], rootHash, vweParam.serviceSignature); } emit TxExecuted(wallet, vwOwner, vweParam.code, rootHash, resCode); }",
        "labels": [
            "SlowMist",
            "DappOS Contracts Core",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Redundant code",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DappOS Contracts Core.pdf",
        "body": "The functions implemented in library OrderId are the same as those in library VWCode. contracts/libraries/OrderId.sol#L7-L17 function genCode( uint128 nonce, uint32 time, uint32 srcChainId, uint32 dstChainId, uint16 oType, uint16 flag ) internal pure returns (uint code){ code = (uint(nonce) << 128) + (uint(time) << 96) + (uint(srcChainId) << 64) + (uint(dstChainId) << 32) + (uint(oType) << 16) + uint(flag); } function chainidsAndExpTime(uint code) internal pure returns (uint dstChainId, uint srcChainId, uint time){ dstChainId = (code >> 32) & ((1 << 32) - 1); srcChainId = (code >> 64) & ((1 << 32) - 1); time = (code >> 96) & ((1 << 32) - 1); }",
        "labels": [
            "SlowMist",
            "DappOS Contracts Core",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Reentrancy risks",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DappOS Contracts Core.pdf",
        "body": "In the PayLock contract punish function, the punishes mapping is not used correctly, resulting in the risk of reentrancy. contracts/governance/PayLock.sol#L131-L159 function punish( uint orderId, address node, address to, address[] calldata tokens, uint[] calldata amounts ) external onlyOwner { require(tokens.length > 0 && tokens.length == amounts.length, \"Invalid length\"); for (uint i = 0; i < tokens.length; i++) { require(validTokens[tokens[i]], \"INVALID_TOKEN\"); TokenBalance storage bal = nodeTokenBalance[node][tokens[i]]; uint256 realAmount = amounts[i]; if (amounts[i] > bal.numOnWithdraw) { if (bal.numTotal <= amounts[i].sub(uint(bal.numOnWithdraw))) { realAmount = uint(bal.numTotal + bal.numOnWithdraw); (bal.numTotal, bal.numOnWithdraw) = (0, 0); } else { bal.numTotal -= (amounts[i] - uint(bal.numOnWithdraw)).toUint128(); bal.numOnWithdraw = 0; } } else { bal.numOnWithdraw = (uint(bal.numOnWithdraw).sub(amounts[i])).toUint128(); } TransferHelper.safeTransfer2(tokens[i], to, realAmount); } punishes[node]++; emit NodePunished(orderId, amounts, tokens, node, to); }",
        "labels": [
            "SlowMist",
            "DappOS Contracts Core",
            "Type: Reentrancy Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Insucient WithdrawPendingTime error",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DappOS Contracts Core.pdf",
        "body": "In the PayLock contract congWithdrawPendingTime function, the withdrawPendingTime parameter should be set to greater than or equal to 7 days. Since congWithdrawPendingTime is associated with the order's term, congWithdrawPendingTime should be greater than the order's term. contracts/governance/PayLock.sol#L168-L172 function configWithdrawPendingTime(uint period) external onlyOwner { require(period <= 7 days, \"E27\"); withdrawPendingTime = period; emit WithdrawPendingTime(period); }",
        "labels": [
            "SlowMist",
            "DappOS Contracts Core",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Unveried Node Mortgage Requirement",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DappOS Contracts Core.pdf",
        "body": "In the PayDB contract, when the user creates an order through the createSrcOrder function or createSrcOrderETH function, it is not veried whether the node's mortgage assets meet the mortgage requirements required for the created order.",
        "labels": [
            "SlowMist",
            "DappOS Contracts Core",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Service nodes are at risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DappOS Contracts Core.pdf",
        "body": "In the PayDB contract, when the user creates an order through the createSrcOrder function or createSrcOrderETH function, he transfer assets to the cparams[i].node , and these nodes are at risk of rug-pull ,or private key leak.",
        "labels": [
            "SlowMist",
            "DappOS Contracts Core",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Redundant collectEndTime check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase3_en-us.pdf",
        "body": "In the CongurableRightsPool contract, users can redeem underlying assets through the exitPool function. When the pool is a closed ETF, it will check isCompletedCollect and collectEndTime to decide whether to perform _claimManagerFee operation. But when isCompletedCollect is true, the collectEndTime check will be performed in snapshotEndAssets, and when isCompletedCollect is false, the collectEndTime check will be performed in exitPoolHandleB. Hence the collectEndTime check before the _claimManagerFee operation is redundant. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase3",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Redundant closureEndTime check on exitPool",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase3_en-us.pdf",
        "body": "In the CongurableRightsPool contract, users can redeem underlying assets through the exitPool function. When the pool is a closed ETF and isCloseEtfCollectEndWithFailure is false, it will check that the current time must be greater than closureEndTime + 5 minutes before allowing the user to exit. However, it should be noted that the snapshotEndAssets operation will be performed before this. The snapshotEndAssets function will also check whether the current time is greater than closureEndTime + 5 minutes . Only the admin and owner can execute snapshotEndAssets within 5 minutes after the closure period ends. Otherwise, the transaction will be reverted. Therefore, the closureEndTime check in the exitPool function is redundant. When snapshotEndAssets cannot be performed, the entire transaction will be reverted, and subsequent closureEndTime checks will not be performed. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase3",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Redundant performance fee calculation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase3_en-us.pdf",
        "body": "In the exitPool function of the CongurableRightsPool contract, redeemAndPerformanceFeeReceived, nalAmountOut and redeemFeeReceived are calculated through exitPoolHandleA. However, since the performance fee will be calculated uniformly in the snapshotEndAssets operation, there is no need to process the performance fee in the exitPool function. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase3",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "The time allowed for snapshots is too short",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase3_en-us.pdf",
        "body": "In the CongurableRightsPool contract when the closed ETF completes collect and the collection period has ended, the current total value of the ETF can be recorded through the snapshotBeginAssets function. However, users can only call the snapshotBeginAssets function within 15 minutes after the end of the collection period. If there is congestion on the chain, it may not be possible to call the snapshot in time within 15 minutes. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase3",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Duplicate decimal processing issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase3_en-us.pdf",
        "body": "In the DesynChainlinkOracle contract, the getPrice function is used to obtain the corresponding token price from prices, getChainlinkPrice, and getUniswapPrice, and perform decimal processing. However, decimal has been processed in getChainlinkPrice and getUniswapPrice, and theoretically, the returned decimal will be 1e18. Therefore, processing decimals through decimalDelta will cause decimals to be enlarged. Note that the amountIn passed in for the consult in the getUniswapPrice function is 1e18, which needs to be ensured that the token decimal in twapOracle matches it in practice ",
        "labels": [
            "SlowMist",
            "DeSyn Phase3",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Decimal processing issue in AllPrice calculation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase3_en-us.pdf",
        "body": "In the DesynChainlinkOracle contract, the getAllPrice function is used to calculate the total value of the specied amount of tokens. It is calculated by badd(fundAll, bmul(getPrice(t), tokenAmountOut)) , theoretically the decimal returned by getPrice is 1e18, and the decimal of tokenAmountOut is consistent with the decimal of the token itself. Therefore, multiplying these two values will result in a very large decimal in the nal result. The getNormalizedWeight function is also aected by this, but this is not harmful to normal business. Note: ",
        "labels": [
            "SlowMist",
            "DeSyn Phase3",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Redundant code issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase3_en-us.pdf",
        "body": "In the SmartPoolManager library, the exitPoolHandle function has been deprecated since closed ETF prots are calculated in snapshotEndAssets. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase3",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Token list conict in recordTokenInfo",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase3_en-us.pdf",
        "body": "When the user performs createPool and joinPool, if the Pool is a closed ETF and the current time is within the collection period, the KOL invitation amount will be recorded through UserVault's recordTokenInfo interface. But unfortunately, the tokens in the Pool can be Bind/unBind at any time, which will cause the list of tokens supported by the Pool to change. If the recordTokenInfo operation is performed when the Pool token list changes, the amount recorded by variables such as poolInviteTotal, kolTotalAmountList, and kolUserInfo may be disturbed. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase3",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "couldManagerClaim not checked when managerClaim",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase3_en-us.pdf",
        "body": "In the UserVault contract, the Manager role can claim management fees through the managerClaim function, but it does not check whether the couldManagerClaim parameter is true. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase3",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Some redundant invoke functions",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase3_en-us.pdf",
        "body": "In the Invoke library, the strictInvokeTransfer, invokeUnwrapWETH, invokeWrapWETH, and invokeMint functions are not used. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase3",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of ETF falsication",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase3_en-us.pdf",
        "body": "In the RebalanceAdapter contract, the Manager role can adjust the position of the pool through the rebalance function. But the address of the ETF is obtained from the rebalanceInfo passed in by the user. If a malicious user passes in a fake ETF, the check in the onlyManager decorator will be bypassed, and the _verifyWhiteToken check of token1 and the isCompletedCollect and collectEndTime checks will be useless. Malicious users can steal bPool funds through _makeSwap and bind malicious tokens. The approve function also has this risk, but it doesn't break the protocol too much ",
        "labels": [
            "SlowMist",
            "DeSyn Phase3",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Risk of the Manager role potentially disrupting the protocol",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase3_en-us.pdf",
        "body": "In the RebalanceAdapter contract, the Manager role can adjust the position of the ETF through the rebalance function. It will use the _makeSwap function to call Uniswap, 1inch and other DEXs for token swaps to adjust token positions. But unfortunately, the swap path of the token is not checked during the token swap process, which will cause the Manager role to pass in a carefully constructed malicious swap path to steal the middle token0 of the ETF. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase3",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Double slippage check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase3_en-us.pdf",
        "body": "In the RebalanceAdapter contract, the Manager role can adjust the position of the ETF through the rebalance function. It will use the _makeSwap function to call Uniswap, 1inch and other DEXs for token swaps to adjust token positions. During the swap process, the slippage will be checked by passing minReturn to the external DEXs, but the implementation of the slippage check of the external DEXs is uncontrollable. If the slippage protection of the external DEXs fails, it will aect the funds of users in the protocol. (1inch users encountered invalid slippage check before) ",
        "labels": [
            "SlowMist",
            "DeSyn Phase3",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Does not follow the Checks-Eects-Interactions specication",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase3_en-us.pdf",
        "body": "In the RebalanceAdapter contract, the _makeSwap function is used for token swap. When the swap type is not UNISWAPV3 and UNISWAPV2, the parameters passed in by the user will be checked through _validateData . However, the execute operation is performed rst, and the _validateData operation is performed after the token exchange is completed. This is not in line with the follow the Checks-Effects-Interactions principle. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase3",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Perform strict parameter checking",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase3_en-us.pdf",
        "body": "In the RebalanceAdapter contract, the _validateData function is used to check the exchange parameters, but it only parses the recipient and amountIn for checking, but does not check whether other key parameters such as srcToken, dstToken, clipperExchange, makerAsset, takerAsset are in line with expectations. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase3",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Redundant aggregator parameter",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase3_en-us.pdf",
        "body": "In the RebalanceAdapter contract, the _validateData function is used to check the conversion parameters, but the aggregator parameter it receives is not used. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase3",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Incorrect approval operation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase3_en-us.pdf",
        "body": "In the RebalanceAdapter contract, the Manager role can adjust the position of the ETF through the rebalance function. If token1 has not been bound in bPool, it will be approved rst. However, the subsidy of this contract was wrongly approved to bPool, which will cause bPool to be unable to transfer tokens from CRP in the future. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase3",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase3_en-us.pdf",
        "body": "There is an execute function in the CRP and bPool contracts so that the Manager can manage the ETF. In bFactory, the Blabs role can arbitrarily register modules to gain control over CRP. The registered modules can use the execute function in CRP to call the execute function in bPool to perform any operations. This would pose a huge risk to users' funds. And the Manager can approve the tokens in the bPool through the approve function of the RebalanceAdapter contract, which will also bring huge risks to the user's funds. The above problems lead to the risk of excessive permissions of the Blabs role and the Manager role. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase3",
            "Type: Authority Control Vulnerability Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Enforce strict permission controls",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - DeSyn Phase3_en-us.pdf",
        "body": "In the LiquidityPool contract, any user can call the joinPool, exitPool, and gulp functions to add/remove liquidity/record token balances, which will make it impossible to charge various fees to users in CRP. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase3",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Function visibility issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Alpaca Finance Oracle_en-us.pdf",
        "body": "In the OracleMedianizer contract, the user can get the price of the pair token through the getPrice function. The getPrice function will call the _getPrice function to get the price, but the visibility of the _getPrice function is public. ",
        "labels": [
            "SlowMist",
            "Alpaca Finance Oracle",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "The Token Pair Check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Alpaca Finance Oracle_en-us.pdf",
        "body": "There is a _setPriceFeed function in the ChainLinkPriceOracle contract, which is used to set the source of the token pair. In the function, check whether priceFeeds[token1][token0] already exists, but then set the source for priceFeeds[token0][token1] . ",
        "labels": [
            "SlowMist",
            "Alpaca Finance Oracle",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Redundant parameter issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ENF_WBTC_Borrow_ETH_en-us.pdf",
        "body": "In the PriceOracle contract, the getAssetPrice function is used to obtain the relative price of WBTC and ETH. But the _asset parameter it receives is not used. ",
        "labels": [
            "SlowMist",
            "ENF_WBTC_Borrow_ETH",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Token swap defect when withdrawing",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ENF_WBTC_Borrow_ETH_en-us.pdf",
        "body": "In the WBTCBorrowETH contract, the withdraw function is used to withdraw WBTC tokens. When the repayable amount of the contract is less than the required loan amount (ethWithdrawn < ethDebt), the contract will withdraw wbtcToSwap amount of WBTC from AAVE to swap it into WETH, and use the wbtcAmt value as the amountInMaximum in the Swap exchange. However, since the wbtcAmt value is indirectly calculated through the ChainLink price, there may be a deviation from the price in Uniswap v3, so using the wbtcAmt value as the amountInMaximum parameter may not be successfully swapped due to the price deviation. ",
        "labels": [
            "SlowMist",
            "ENF_WBTC_Borrow_ETH",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Swap balance has not been processed",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ENF_WBTC_Borrow_ETH_en-us.pdf",
        "body": "In the _withdraw function of the WBTCBorrowETH contract, when ethWithdrawn < ethDebt , the contract will withdraw WBTC tokens from AAVE and swap them into ETH to repay the loan. If the amount of ETH is greater than the amount of debt required to be repaid (ethBal > ethDebt), the contract will swap the excess part into WBTC, but these excess WBTC tokens have not been sent to the user, nor have they been re-staked into AAVE. It was left in the SS contract. When the next user deposit, it will be billed as part of the user's deposit. And when ethWithdrawn >= ethDebt , the contract will convert the excess ETH to WBTC, but the contract has not yet processed these WBTC. ",
        "labels": [
            "SlowMist",
            "ENF_WBTC_Borrow_ETH",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Defects in LTV operation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ENF_WBTC_Borrow_ETH_en-us.pdf",
        "body": "In the reduceLTV operation, the contract will rst extract x amount of WBTC from AAVE and exchange it into WETH 12 for repayment. In this operation, although the liabilities of the contract are reduced, the amount of collateral of the contract is also reduced. At the same time, due to the impact of the slippage of the swap operation, the reduceLTV operation may not be able to eectively control the risk as expected. ",
        "labels": [
            "SlowMist",
            "ENF_WBTC_Borrow_ETH",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Reduced availability for LTV operations 13",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ENF_WBTC_Borrow_ETH_en-us.pdf",
        "body": "In the protocol, the raiseLTV and reduceLTV functions are important means to improve capital utilization and prevent bad debts, but in these two functions, the token exchange is performed through the _swapExactInput function. The _swapExactInput function does not check for slippage, which will reduce the availability of raiseLTV and reduceLTV for the protocol. ",
        "labels": [
            "SlowMist",
            "ENF_WBTC_Borrow_ETH",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "The withdraw function will not work when the market is extreme",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ENF_WBTC_Borrow_ETH_en-us.pdf",
        "body": "In the protocol, when extreme market conditions occur (such as a sharp unilateral drop of BTC) and the owner has no time to adjust the protocol LTV through the reduceLTV function, the protocols WBTC position will be liquidated. If 14 the protocol's liabilities are fully liquidated (getDebt will become 0), ethDebt will be 0. This will cause the _withdraw function to fail to perform the repay operation, and the emergencyWithdraw operation will also not work. Users' funds will be locked in the protocol. In the repay operation of AAVE, if the repayment amount is 0, it will fail the validateRepay check.",
        "labels": [
            "SlowMist",
            "ENF_WBTC_Borrow_ETH",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Risk of multiple leverages in unilateral market conditions",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ENF_WBTC_Borrow_ETH_en-us.pdf",
        "body": "The protocol deposits WBTC tokens deposited by users into AAVE and lends ETH, and then deposits the loaned ETH into the ENF_ETH_Leverage protocol. The ENF_ETH_Leverage protocol also creates positions in AAVE via ETH/stETH. This makes the ENF_WBTC_Borrow_ETH protocol have multiple leverages, which means it is extremely sensitive to market stability. Once the agreement does not manage LTV properly, it will lead to risks such as bad debts of the agreement. ",
        "labels": [
            "SlowMist",
            "ENF_WBTC_Borrow_ETH",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of excessive authority 16",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ENF_WBTC_Borrow_ETH_en-us.pdf",
        "body": "In the protocol, the owner role has many permissions, such as the owner can set sensitive parameters, can suspend the contract, can make emergency withdrawals, etc. It is obviously inappropriate to give all the permissions of the protocol to the owner, which will greatly increase the single point of risk.",
        "labels": [
            "SlowMist",
            "ENF_WBTC_Borrow_ETH",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Swap Path Issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Oddz Finance_en-us.pdf",
        "body": "In the PancakeSwapForUnderlyingAsset contract, the owner can swap fromToken to toToken through the 11 swapTokensForUA function. The path set is [fromToken, toToken] . If fromToken and toToken in PancakeSwap do not have a directly related token pair, then using this path will not be able to successfully swap. contracts/Integrations/Dex/PancakeSwap/PancakeSwapForUnderlyingAsset.sol#L29-L44 function swapTokensForUA( address _fromToken, address _toToken, address _account, uint256 _amountIn, uint256 _amountOutMin, uint256 _deadline ) public override onlyOwner returns (uint256[] memory result) { address[] memory path = new address[](2); path[0] = _fromToken; path[1] = _toToken; ERC20(_fromToken).safeApprove(address(pancakeSwap), _amountIn); result = pancakeSwap.swapExactTokensForTokens(_amountIn, _amountOutMin, path, address(this), _deadline); // converting address to address payable ERC20(address(uint160(_toToken))).safeTransfer(_account, result[1]); }",
        "labels": [
            "SlowMist",
            "Oddz Finance",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Missing event records",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Oddz Finance_en-us.pdf",
        "body": "12 In the ChainlinkIVOracle contract, the owner can set allowedPeriods, minVolatilityBound, maxVolatilityBound and other parameters at will, but no event recording is performed. contracts/Integrations/VolatilityOracle/Chainlink/ChainlinkIVOracle.sol function addAllowedPeriods(uint8 _ivAgg) public onlyOwner(msg.sender) { allowedPeriods[_ivAgg] = true; } function setMinVolatilityBound(uint256 _minVolatility) public onlyOwner(msg.sender) { minVolatilityBound = _minVolatility; } function setMaxVolatilityBound(uint256 _maxVolatility) public onlyOwner(msg.sender) { maxVolatilityBound = _maxVolatility; } function setDelay(uint256 _delay) public onlyOwner(msg.sender) { delayInSeconds = _delay; } function setVolatilityPrecision(uint8 _precision) public onlyOwner(msg.sender) { volatilityPrecision = _precision; }",
        "labels": [
            "SlowMist",
            "Oddz Finance",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "The deationary token docking issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Oddz Finance_en-us.pdf",
        "body": "13 Users can transfer the staking token into the staking contract through the deposit function. Under normal circumstances, the number of staking tokens transferred by the user is the same as the _amount parameter passed in. But if the staking token is a deationary token, the number of tokens transferred by the user may be dierent from the number of tokens actually received in the contract. contracts/Staking/OddzStakingManager.sol, OddzTokenStaking.sol, OUsdTokenStaking function stake(IERC20 _token, uint256 _amount) external override validToken(_token) { require(_amount > 0, \"Staking: invalid amount\"); tokens[_token]._stakingContract.stake(msg.sender, _amount); emit Stake(msg.sender, address(_token), _amount); } function stake(address _staker, uint256 _amount) external override onlyOwner { _stake(_staker, _amount); _mint(_staker, _amount); IERC20(token).safeTransferFrom(_staker, address(this), _amount); }",
        "labels": [
            "SlowMist",
            "Oddz Finance",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Token active status change issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Oddz Finance_en-us.pdf",
        "body": "In the OddzStakingManager contract, the owner can set the active state of the token to true through the activateToken function, and the timelock contract can set the active state to false through the deactivateToken 14 function. But after the state change, the txnFeeReward, settlementFeeReward, and allotedReward parameters of each valid token did not change accordingly, so the totalTxnFee, totalSettlementFee, and totalAllotedFee parameters are not equal to 100. contracts/Staking/OddzStakingManager.sol function deactivateToken(IERC20 _token) external onlyTimeLocker(msg.sender) validToken(_token) { tokens[_token]._active = false; emit TokenDeactivate(address(_token)); } function activateToken(IERC20 _token) external onlyOwner(msg.sender) inactiveToken(_token) { tokens[_token]._active = true; emit TokenActivate(address(_token)); }",
        "labels": [
            "SlowMist",
            "Oddz Finance",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Redundant code",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Oddz Finance_en-us.pdf",
        "body": "There is _transferRewards function in the OddzStakingManager contract, which checks whether the staker's collateral time is greater than rewardsLockupDuration, while the actual _transferRewards function is only called by the withdraw function and the claimRewards function. But in both withdraw and claimRewards functions, there is a check to see if the staker's collateral time is greater than 15 rewardsLockupDuration. So the _transferRewards function does not need to check again if the staker's collateral time is greater than the rewardsLockupDuration. contracts/Staking/OddzStakingManager.sol function _transferRewards( address _staker, IERC20 _token, uint256 _date ) private returns (uint256 reward) { if (_date - tokens[_token]._stakingContract.getLastStakedAt(_staker) >= tokens[_token]._rewardsLockupDuration) { reward = tokens[_token]._stakingContract.withdrawRewards(_staker); oddzToken.safeTransfer(_staker, reward); emit TransferReward(_staker, address(_token), reward); } }",
        "labels": [
            "SlowMist",
            "Oddz Finance",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Unsafe External Call",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Oddz Finance_en-us.pdf",
        "body": "_pool is entered by the user. When the user enters a malicious contract address and returns the malicious premium through the malicious contract, the tokens in the OddzLiquidityPoolManager contract can be transferred to a malicious address. 16 contracts/Pool/OddzLiquidityPoolManager.sol#L300 function withdrawProfits(IOddzLiquidityPool _pool) external { uint256 premium = _pool.collectPremium(msg.sender, premiumLockupDuration); require(premium > 0, \"LP Error: No premium allocated\"); token.safeTransfer(msg.sender, premium); } The getSortedEligiblePools function does not check the input _liquidityParams and does not ensure that allPools is in the whitelist. When other functions depend on the data of getSortedEligiblePools, the same issues may occur. contracts/Pool/OddzLiquidityPoolManager.sol#L341 function getSortedEligiblePools(LiquidityParams memory _liquidityParams) public view returns (address[] memory pools, uint256[] memory poolBalance) { // if _expiration is 86401 i.e. 1 day 1 second, then max 1 day expiration pool will not be eligible IOddzLiquidityPool[] memory allPools = poolMapper[ keccak256( abi.encode( _liquidityParams._pair, _liquidityParams._type, _liquidityParams._model, periodMapper[getActiveDayTimestamp(_liquidityParams._expiration) / 1 days] ) ) ]; uint256 count = 0; for (uint8 i = 0; i < allPools.length; i++) { if (allPools[i].availableBalance() > 0) { count++; } } poolBalance = new uint256[](count); pools = new address[](count); uint256 j = 0; 17 uint256 balance = 0; for (uint256 i = 0; i < allPools.length; i++) { if (allPools[i].availableBalance() > 0) { pools[j] = address(allPools[i]); poolBalance[j] = allPools[i].availableBalance(); balance += poolBalance[j]; j++; } } (poolBalance, pools) = _sort(poolBalance, pools); require(balance > _liquidityParams._amount, \"LP Error: Amount is too large\"); }",
        "labels": [
            "SlowMist",
            "Oddz Finance",
            "Type: Unsafe External Call Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Race conditions issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Oddz Finance_en-us.pdf",
        "body": "The enableOptionTransfer function can be called repeatedly, When the attacker calls enableOptionTransfer to set a small value of _minAmount.The user does not need to enter minAmount to check when calling the optionTransfer function.Therefore, the attacker can call enableOptionTransfer again with a higher gas price to set a new minAmount, so that if the allowance is greater than the minAmount + transferFee , the user can normally execute optionTransfer calls and trade with a larger amount, and the attacker can prot. contracts/Option/OddzOptionManager.sol function enableOptionTransfer(uint256 _optionId, uint256 _minAmount) external { Option storage option = options[_optionId]; require( option.expiration > (block.timestamp + 18 assetManager.getMinPeriod(option.pair)), \"Option not eligble for transfer\" ); require(option.holder == msg.sender, \"Invalid Caller\"); require(option.state == State.Active, \"Invalid state\"); require(_minAmount >= minimumPremium, \"amount is lower than minimum premium\"); optionTransferMap[_optionId] = _minAmount; emit OptionTransferEnabled(_optionId, _minAmount); } function optionTransfer(uint256 _optionId) external { Option storage option = options[_optionId]; require( option.expiration > (block.timestamp + assetManager.getMinPeriod(option.pair)), \"Option not eligble for transfer\" ); uint256 minAmount = optionTransferMap[_optionId]; require(minAmount > 0, \"Option not enabled for transfer\"); require(option.state == State.Active, \"Invalid state\"); require(option.holder != msg.sender, \"Self option transfer is not allowed\"); // once transfer initiated update option tranfer map delete optionTransferMap[_optionId]; uint256 transferFee = _getTransactionFee(minAmount, msg.sender); txnFeeAggregate += transferFee; _validateOptionAmount(token.allowance(msg.sender, address(this)), minAmount + transferFee); token.safeTransferFrom(msg.sender, option.holder, minAmount); token.safeTransferFrom(msg.sender, address(this), transferFee); address oldHolder = option.holder; option.holder = msg.sender; emit OptionTransfer(_optionId, oldHolder, msg.sender, minAmount, transferFee); } 19",
        "labels": [
            "SlowMist",
            "Oddz Finance",
            "Type: Reordering Vulnerability",
            "Severity: Critical"
        ]
    },
    {
        "title": "Excessive authority issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Oddz Finance_en-us.pdf",
        "body": "(1) The owner of the OddzIVOracleManager and OddzPriceOracleManager contracts can change the conguration of the contract and does not use timelock for management, there is a risk of excessive authority. The oracle aects the price of the asset. When the oracle contract is maliciously manipulated, it will cause the user's asset to be damaged. (2) After the contracts are deployed, it is necessary to check whether TimeLocker is set correctly.",
        "labels": [
            "SlowMist",
            "Oddz Finance",
            "Type: Authority Control Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - EarningFarm v3 Iterative_en-us.pdf",
        "body": "In the Exchange contract, the owner role can set swapCaller and router through the setSwapCaller and listRouter functions. If it is set to a malicious address, funds will be lost. In the CDai contract, the owner role can set sensitive parameters through the setSwapPath function. This will lead to the risk of excessive owner permissions. ",
        "labels": [
            "SlowMist",
            "EarningFarm v3 Iterative",
            "Type: Authority Control Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Variable storage issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - EarningFarm v3 Iterative_en-us.pdf",
        "body": "In the Curve3Pool contract, the swap function is used for token exchange. When fetching pools[_index], it uses storage to store the curve variable, but in this function there is no need to modify pools[_index], so this will consume more gas. ",
        "labels": [
            "SlowMist",
            "EarningFarm v3 Iterative",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Slippage issue 9",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - EarningFarm v3 Iterative_en-us.pdf",
        "body": "In the Curve3Pool contract, the swap function is used to exchange tokens in 3pool, but the _min_received passed in during the exchange is 0, which will cause the exchange process to be subject to a sandwich attack. ",
        "labels": [
            "SlowMist",
            "EarningFarm v3 Iterative",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "get_dy index issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - EarningFarm v3 Iterative_en-us.pdf",
        "body": "In the CDai contract, the _totalAssets function converts DAI to USDC as total assets via CurvePool's get_dy. But Calculate withdraw amout of usdc - from Dai (j) to USDC(i) is stated in the comments, while according to the get_dy function description (https://curve.readthedocs.io/factory-pools.html#StableSwap.get_dy ), the i index should be DAI, and the j index should be USDC. ",
        "labels": [
            "SlowMist",
            "EarningFarm v3 Iterative",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of breaching contract integrity",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - EarningFarm v3 Iterative_en-us.pdf",
        "body": "When the user makes a withdrawal, the protocol will withdraw from the SS contract through the controller contract, and then burn the user's share. 11 In the withdraw function of the SS contract, it will rst calculate the number of LPs that the user can withdraw (lpAmt), then extract the LP tokens from the convex, and then use balanceOf(address(this)) to obtain the LP balance of this contract as lpWithdrawn. TotalLP will then subtract lpWithdrawn and remove liquidity from CurvePool. The amount to remove liquidity is also lpWithdrawn. Then transfer all USDC tokens in the SS contract to the controller. Finally, the controller contract transfers the USDC token to the user. In the withdraw function of the vault contract, after the controller completes the withdrawal, the number of burned shares is calculated based on the assets passed in by the user. This will lead to the destruction of the totalLP value if a malicious user transfers a large amount of LP tokens to the SS contract and withdraws them after depositing. ",
        "labels": [
            "SlowMist",
            "EarningFarm v3 Iterative",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Risk of slippage checks being bypassed",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - EarningFarm v3 Iterative_en-us.pdf",
        "body": "In the CDai contract, the totalAssets function calculates the total collateral amount of the SS contract in the strategy through the get_dy function of CurvePool. When the user withdraws, the contract will participate in the calculation of 12 the nDAI value to be withdrawn through totalAssets. Unfortunately, a malicious user can manipulate the CurvePool with large sums of money so that the value obtained by the get_dy function is much smaller than expected, which will cause the nDAI value to be much larger than expected when withdrawing. Malicious users can deplete the liquidity in CDai by stealing collateral that does not belong to them. ",
        "labels": [
            "SlowMist",
            "EarningFarm v3 Iterative",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Arbitrary permission initialization of lend/oracle contract",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Larix Obsolete_en-us.pdf",
        "body": "Anyone can initialize the lend/oracle contract, which may lead to the illegal use of the contract, and malicious users may use the ocially deployed Program to conduct fraudulent activities.",
        "labels": [
            "SlowMist",
            "Larix Obsolete",
            "Type: Authority Control Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Flash loan repayment detection bypass",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Larix Obsolete_en-us.pdf",
        "body": "After the attacker calls process_flash_loan to borrow, he uses the borrowed funds to recharge to the contract. In this way, the ash loan will detect that the funds have been returned during the repayment check, which leads to the success of the ash loan, but the funds are not actually returned. Instead, the attacker get a deposit position is established, and the attacker can withdraw this fund at any time, thereby stealing all the funds in the fund pool.",
        "labels": [
            "SlowMist",
            "Larix Obsolete",
            "Type: Reentrancy Vulnerability",
            "Severity: Critical"
        ]
    },
    {
        "title": "Process_ash_loan forged account risk 7",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Larix Obsolete_en-us.pdf",
        "body": "Code location: larix-lending/src/processor.rs fn process_flash_loan( program_id: &Pubkey, liquidity_amount: u64, accounts: &[AccountInfo], ) If the owner or key of the reserve_info account is not veried, the attacker may attack the contract by maliciously constructing the data stored in the account.",
        "labels": [
            "SlowMist",
            "Larix Obsolete",
            "Type: Forged account attack",
            "Severity: Critical"
        ]
    },
    {
        "title": "Process_reserve forged account risk",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Larix Obsolete_en-us.pdf",
        "body": "Code location: larix-lending/src/cong/cong_process.rs fn process_reserve(program_id: & Pubkey, accounts: & [AccountInfo],reserve_type:ConfigReserveType) If the owner or key of the reserve_info account is not veried, the attacker may attack the contract by maliciously constructing the data stored in the account.",
        "labels": [
            "SlowMist",
            "Larix Obsolete",
            "Type: Forged account attack",
            "Severity: Critical"
        ]
    },
    {
        "title": "process_borrow_obligation_liquidity host_fee transfer target is not veried",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Larix Obsolete_en-us.pdf",
        "body": "Code location: larix-lending/src/processor.rs if let Ok(host_fee_receiver_info) = next_account_info(account_info_iter) { if host_fee > 0 { owner_fee = owner_fee .checked_sub(host_fee) .ok_or(LendingError::MathOverflow)?; spl_token_transfer(TokenTransferParams { source: source_liquidity_info.clone(), destination: host_fee_receiver_info.clone(), amount: host_fee, authority: lending_market_authority_info.clone(), authority_signer_seeds, token_program: token_program_id.clone(), })?; } } The owner or key of the host_fee_receiver_info account is not veried, and the user can steal host_fee by specifying host_fee_receiver_info .",
        "labels": [
            "SlowMist",
            "Larix Obsolete",
            "Type: Forged account attack",
            "Severity: Critical"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap_v3_Phase2_en-us.pdf",
        "body": "1.The owner role can change the external part contract FARM_BOOSTER through the updateFarmBoostContract function and the external part contract can aect the boostMultiplier . ",
        "labels": [
            "SlowMist",
            "PancakeSwap_v3_Phase2",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "LP token locking issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap_v3_Phase2_en-us.pdf",
        "body": "In the MasterChefV3 contract, users will transfer their ERC721 LP tokens for staking to get the CAKE as reward. Users can only call the safeTransferFrom function to transfer their ERC721 LP token in the MasterChefV3 contract to trigger the _checkOnERC721Received hook to let the NonfungiblePositionManager contract call back the onERC721Received function. After this, the positionInfo can be recorded and make the staking eective. If users miss transferring the LP token by using the transferFrom function, the LP tokens will be locked in this contract. ",
        "labels": [
            "SlowMist",
            "PancakeSwap_v3_Phase2",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Cast truncation issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap_v3_Phase2_en-us.pdf",
        "body": "In the PancakeV3LmPool contract, the Pool or MasterChef will calculate the reward through the accumulateReward function. The uint256 endTime is assigned by getLatestPeriodInfo in the MasterChef contract and the endTime is assigned by an uint256 value latestPeriodEndTime , then the endTime will cast to an uint32 to endTimestamp . If the latestPeriodEndTime is larger than type(uin32).max , there will be a cast truncation issue. And PancakeV3LmPool contract imports the SafeCast contract but doesnt use it for the uin32 cast. ",
        "labels": [
            "SlowMist",
            "PancakeSwap_v3_Phase2",
            "Type: Arithmetic Accuracy Deviation Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Potential risks of arbitrary transfer of ETF funds",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase7 - SlowMist Audit Report.pdf",
        "body": "In the MoveFunds contract, the admin role can transfer funds from the ETF to a specied receiver address through the makeTransfer function during the ETF's closed period. Additionally, the owner can arbitrarily modify the receiver address through the setReceiver function. For the ETF, this may pose an excessive privilege risk, and participants should be aware of this. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase7 - SlowMist Audit Report",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Information"
        ]
    },
    {
        "title": "Redundant logic issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - MasterChef v2_en-us.pdf",
        "body": "In the add function, the owner can add new pools. It will rst check whether the number of newly added lpTokens in the contract is greater than or equal to 0. But in fact, the number of lpTokens in the contract will be greater than or equal to 0 in any case, so this check is redundant. ",
        "labels": [
            "SlowMist",
            "MasterChef v2",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Permission control issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - MasterChef v2_en-us.pdf",
        "body": "If any user holds the dummy token, the user can stake the dummy token to the MasterChef v1 contract through the init function, which will cause the lastBurnedBlock parameter to be updated unexpectedly, and nally lead to an error in the calculation of the number of CAKE tokens waiting to be burned. ",
        "labels": [
            "SlowMist",
            "MasterChef v2",
            "Type: Authority Control Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "The number of pendingCakeToBurn is not checked",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - MasterChef v2_en-us.pdf",
        "body": "In the burnCake function, if the number of CAKE tokens in the contract is less than pendingCakeToBurn, it will harvest CAKE tokens from MasterChef v1 via the harvestFromMasterChef function. But it does not check if the balance of CAKE tokens in the contract after harvesting is greater than or equal to pendingCakeToBurn. ",
        "labels": [
            "SlowMist",
            "MasterChef v2",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Repeatable initialization issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap_MOVE_en-us.pdf",
        "body": "In the swap module RESOURCE_ACCOUNT can initialize SwapInfo through the init_storage function, but the function does not check for repeated initialization. ",
        "labels": [
            "SlowMist",
            "PancakeSwap_MOVE",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Gas optimization",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap_MOVE_en-us.pdf",
        "body": "In the swap module, the add_liquidity function is used to add liquidity and return the remaining tokens to the user. But without checking whether the token value to be returned is greater than 0, the coin::deposit function is called. If the returned token value is 0, this will cause unnecessary gas consumption. ",
        "labels": [
            "SlowMist",
            "PancakeSwap_MOVE",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Architecture optimization",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap_MOVE_en-us.pdf",
        "body": "The storage of LP tokens is realized through storage.move in the protocol. But the creation of Pair is realized through the create_pair of the swap module and the resource storage is carried out by TokenPairMetadata and TokenPairReserve. So LPToken can be implemented directly in swap module without having to implement it in storage.move separately. ",
        "labels": [
            "SlowMist",
            "PancakeSwap_MOVE",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Assertion aw issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap_MOVE_en-us.pdf",
        "body": "In the swap module, the mint function is used to mint LP tokens when liquidity is added. When adding liquidity for the rst time, the liquidity amount needs to meet MINIMUM_LIQUIDITY. If the MINIMUM_LIQUIDITY is not met, the 12 transaction will be revet. In this case the protocol will throw an overow error instead of ERROR_INSUFFICIENT_LIQUIDITY_MINTED. ",
        "labels": [
            "SlowMist",
            "PancakeSwap_MOVE",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Not checked if pair has been created",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap_MOVE_en-us.pdf",
        "body": "In the router module contract, users can remove liquidity and exchange tokens through the functions remove_liquidity, swap_exact_input, swap_exact_output, swap_exact_input_doublehop, 13 swap_exact_output_doublehop, swap_exact_input_triplehop and swap_exact_output_triplehop respectively, but do not check whether a pair is created rst. ",
        "labels": [
            "SlowMist",
            "PancakeSwap_MOVE",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Redundant code",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap_MOVE_en-us.pdf",
        "body": "In the Swap module, the quote_x_to_y_after_fees, quote_y_to_x_after_fees, transfer_x and transfer_y functions are all internal functions, but no other public functions call them. ",
        "labels": [
            "SlowMist",
            "PancakeSwap_MOVE",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "k value check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap_MOVE_en-us.pdf",
        "body": "During the swap process, it is necessary to check whether the multiplication of the token balance of the pair after the swap is strictly greater than or equal to the k value. However, due to the fee charged during the swap process, in theory, the multiplication of the token balance of the pair after swap must be strictly greater than the k value. While using u256 avoids close rounding errors it is still not necessary to check if it is equal to the k value. ",
        "labels": [
            "SlowMist",
            "PancakeSwap_MOVE",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap_MOVE_en-us.pdf",
        "body": "In the swap module contract, the admin role can call the upgrade_swap function to upgrade the entire contract. If administrator privileges are stolen, it may have an impact on the normal operation of the contract. ",
        "labels": [
            "SlowMist",
            "PancakeSwap_MOVE",
            "Type: Excessive Authority Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "The validity of the token contract address is not checked",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Bitlayer Bridge Phase 2.pdf",
        "body": "In the BitlayerBridgeV2 contract, the crossoutBurn function does not check the validity of the token address. An attacker can pass in the token contract address created by himself, and then transfer and burn the tokens created by the attacker through the crossoutBurn function to trigger the CrossoutBurned event. contracts/BitlayerBridgeV2.sol#L278-L307 function crossoutBurn( address token, uint256 value, string memory btcReceiver ) external payable { require(token != address(0), \"invalid token address\"); require(value != 0, \"invalid value\"); require(bytes(btcReceiver).length != 0, \"invalid btcReceiver\"); uint256 crossoutFeeAmount = tokenConfigs[token].crossoutFee; require(crossoutFeeAmount == 0 || msg.value >= crossoutFeeAmount, \"not enough fee paied\"); SafeERC20.safeTransferFrom(IERC20(token), msg.sender, address(this), value); IPegToken(token).burn(address(this), value); if (crossoutFeeAmount > 0) { (bool success, bytes memory returndata) = feeAddress.call{value: crossoutFeeAmount}(\"\"); require(success, string(returndata)); } uint256 unusedFee = msg.value - crossoutFeeAmount; if (unusedFee > 0) { (bool success, bytes memory returndata) = msg.sender.call{value: unusedFee}(\"\"); require(success, string(returndata)); } emit CrossoutBurned(msg.sender, btcReceiver, token, value); }",
        "labels": [
            "SlowMist",
            "Bitlayer Bridge Phase 2",
            "Type: Design Logic Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Unlimited huge amount minting",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Bitlayer Bridge Phase 2.pdf",
        "body": "In the BitlayerBridgeV2 contract, when huge amounts are minted through the proposeMint function and executeMint function, the minted amount is not limited by periodLimit , nor is it recorded in periodMinted , and the period will not be updated. contracts/BitlayerBridgeV2.sol#L235-L255,L258-L275 function proposeMint( MintInfo memory mInfo ) external onlyRole(ProposerRole) { bytes32 blExecHash = keccak256(abi.encodePacked(mInfo.btcTxHash)); require(!executedBtcHash[blExecHash], \"already executed\"); require(mInfo.receiver != address(0), \"receiver is null\"); require(proposedMint[blExecHash].receiver == address(0), \"already proposed\"); require(mInfo.value >= tokenConfigs[mInfo.token].mintSplitLine, \"mint value is less than configed\"); require( !IPegToken(mInfo.token).isBlacklist(mInfo.receiver), \"receiver is blacklisted\" ); proposedMint[blExecHash] = mInfo; emit MintProposed(mInfo.btcTxHash, blExecHash, mInfo.receiver, mInfo.token, mInfo.value); } function executeMint( bytes32 blExecHash ) external onlyRole(ExecutorRole) { MintInfo memory mInfo = proposedMint[blExecHash]; require(!executedBtcHash[blExecHash], \"already executed\"); require(mInfo.receiver != address(0), \"not proposed\"); executedBtcHash[blExecHash] = true; delete proposedMint[blExecHash]; IPegToken(mInfo.token).mint(mInfo.receiver, mInfo.value); emit MintExecuted(mInfo.btcTxHash, blExecHash, mInfo.receiver, mInfo.token, mInfo.value); }",
        "labels": [
            "SlowMist",
            "Bitlayer Bridge Phase 2",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "The returned leftQuota value is inaccurate",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Bitlayer Bridge Phase 2.pdf",
        "body": "In the BitlayerBridgeV2 contract, the getPeriodInfo function is inaccurate when returning the leftQuota of the specied token. If block.number has reached the next period and tokenConfigs[token] has not been updated, the value of leftQuota should be config.periodLimit . contracts/BitlayerBridgeV2.sol#L309-L319 function getPeriodInfo(address token) external view returns(uint256 periodLimit, uint256 leftQuota, uint256 leftBlocksToNextPeriod) { TokenConfig memory config = tokenConfigs[token]; periodLimit = config.periodLimit; leftQuota = config.periodLimit - config.periodMinted; leftBlocksToNextPeriod = config.periodInterval - (block.number - config.lastBlockNumber) % config.periodInterval; }",
        "labels": [
            "SlowMist",
            "Bitlayer Bridge Phase 2",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Missing zero address check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Bitlayer Bridge Phase 2.pdf",
        "body": "1.In the BitlayerBridgeV2 contract, the initToken function does not perform a zero address check on the token address. contracts/BitlayerBridgeV2.sol#L99-L119 function initToken( address token, ``` ) external onlyRole(AdminRole) { TokenConfig storage config = tokenConfigs[token]; ``` } 2.In the BitlayerBridgeV2 contract, the directMint function does not perform a zero address check on the mInfo.token address. contracts/BitlayerBridgeV2.sol#L198-L233 function directMint( MintInfo memory mInfo ) external onlyRole(MinterRole) { ``` IPegToken(mInfo.token).mint(mInfo.receiver, mInfo.value); ``` } 3.In the BitlayerBridgeV2 contract, the proposeMint function does not perform a zero address check on the mInfo.token address. BitlayerBridgeV2.sol#L235-L255 function proposeMint( MintInfo memory mInfo ) external onlyRole(ProposerRole) { ``` require( !IPegToken(mInfo.token).isBlacklist(mInfo.receiver), \"receiver is blacklisted\" ); ``` }",
        "labels": [
            "SlowMist",
            "Bitlayer Bridge Phase 2",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Unchecked parameter value is not 0",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Bitlayer Bridge Phase 2.pdf",
        "body": "1.In the BitlayerBridgeV2 contract, the initToken function does not check whether the values of periodInterval and mintSplitLine are not 0. contracts/BitlayerBridgeV2.sol#L99-L119 function initToken( address token, uint256 periodLimit, uint256 periodInterval, uint256 mintSplitLine, uint256 crossoutFee ) external onlyRole(AdminRole) { TokenConfig storage config = tokenConfigs[token]; require(config.lastBlockNumber == 0, \"already inited\"); config.lastBlockNumber = block.number; config.periodLimit = periodLimit; config.periodInterval = periodInterval; config.mintSplitLine = mintSplitLine; config.crossoutFee = crossoutFee; emit TokenInited(token, periodLimit, periodInterval, mintSplitLine, crossoutFee); } 2.In the BitlayerBridgeV2 contract, the setMintSplitLine function does not check whether the value of limit is not 0. contracts/BitlayerBridgeV2.sol#L137-L149 function setMintSplitLine( address token, uint256 limit ) public onlyRole(AdminRole) { require(token != address(0), \"invalid token address\"); tokenConfigs[token].mintSplitLine = limit; emit MintSplitLineSet(token, limit); } 3.In the BitlayerBridgeV2 contract, the directMint function does not check whether the value of mInfo.value is not 0. BitlayerBridgeV2.sol#L198-L233 function directMint( MintInfo memory mInfo ) external onlyRole(MinterRole) { ``` require( mInfo.value < config.mintSplitLine, \"mint value is greater than configed\" ); ``` }",
        "labels": [
            "SlowMist",
            "Bitlayer Bridge Phase 2",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Redundant code",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Bitlayer Bridge Phase 2.pdf",
        "body": "In the BitlayerBridgeV2 contract, the directMint function repeatedly performs a zero address check on the mInfo.receiver address because the zero address check has already been performed on this address in the mint function of the token contract. contracts/BitlayerBridgeV2.sol#L198-L233 function directMint( MintInfo memory mInfo ) external onlyRole(MinterRole) { ``` require(mInfo.receiver != address(0), \"receiver is null\"); ``` }",
        "labels": [
            "SlowMist",
            "Bitlayer Bridge Phase 2",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Bitlayer Bridge Phase 2.pdf",
        "body": "1.In the BitlayerBridgeV2 contract, the AdminRole role can set important parameters in the contract through the following functions. contracts/BitlayerBridgeV2.sol function setRoles function initToken function setPeriodMintLimit function setMintSplitLine function setCrossoutFee function setPeriodInterval function startNewPeriod 2.The BitlayerBridge contracts are implemented using the OpenZeppelin upgradeable model, allowing the AdminRole role to perform contract upgrades.Since the BitlayerBridgeV2 contract inherits the BitlayerBridge contract, it is also an upgradeable contract. However, this design introduces an excessive privilege risk. contracts/BitlayerBridge.sol#L4 import \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\"; 3.In the BitlayerBridge contract, AdminRole role can set important parameters of the contract.And the BitlayerBridgeV2 contract also inherits these privileged functions. contracts/BitlayerBridge.sol function setFeeAddress function setLockFee function setMinLockAmount function setMaxLockAmount 4.In the BitlayerBridge contract, the LiquidityRole role can call the removeLiquidityTo function to remove the liquidity of any address.And the BitlayerBridgeV2 contract also inherits this privileged functions. contracts/BitlayerBridge.sol#L159-L162 function removeLiquidity(uint256 amount) external whenNotPaused { require(amount > 0, \"invalid amount\"); doRemoveLiquidity(msg.sender, amount); } 5.In the BitlayerBridge contract, UnlockRole can pass in any _txHash through the unlock function to unlock any amount of native tokens. In the BitlayerBridgeV2 contract, MinterRole , ProposerRole and ExecutorRole can mint any amount of PegToken by passing in any btcTxHash parameter through their respective functions ( directMint , proposeMint and executeMint ). These vulnerabilities stem from the contract's inability to verify Bitcoin networks transaction hash at the EVM level, instead leaving verication to a centralized validator. contracts/BitlayerBridge.sol function unlock contracts/BitlayerBridgeV2.sol function directMint function proposeMint function executeMint",
        "labels": [
            "SlowMist",
            "Bitlayer Bridge Phase 2",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Missing event record",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap_Pottery_en-us.pdf",
        "body": "When the sensitive parameters of the contract are modied, the corresponding events are not recorded, which is not conducive to the supervision of the community and users. ",
        "labels": [
            "SlowMist",
            "PancakeSwap_Pottery",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Business logic problem",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap_Pottery_en-us.pdf",
        "body": "The contract does not check whether the incoming address and ID exist. If the wrong data is passed in in the actual operation, it will lead to waste of resources. ",
        "labels": [
            "SlowMist",
            "PancakeSwap_Pottery",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap_Pottery_en-us.pdf",
        "body": "The Owner has the right to modify the address of the contract to any address. ",
        "labels": [
            "SlowMist",
            "PancakeSwap_Pottery",
            "Type: Authority Control Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Defects in the defaultDepositSS check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ENF_ETH_Lowrisk_en-us.pdf",
        "body": "In the harvest function of the Controller contract, before re-depositing the protocol income into the strategy, it will check whether the default SS exists through subStrategies.length > defaultDepositSS . But actually, defaultDepositSS will be 0 when the default SS does not exist, so the subStrategies.length > defaultDepositSS check will always pass. Eventually the protocol will fail to re-deposit. ",
        "labels": [
            "SlowMist",
            "ENF_ETH_Lowrisk",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "ownerDeposit remaining deposit issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ENF_ETH_Lowrisk_en-us.pdf",
        "body": "In the ownerDeposit function of the StETH contract, the owner role will directly deposit ETH into the strategy. It checks that msg.value must be greater than or equal to the amount to be deposited through _amount <= msg.value . But when the owner's msg.value is greater than _amount , the ownerDeposit function does not implement the refund of excess ETH. This will result in funds being locked. The same is true for the ownerDeposit function of the CEth contract. ",
        "labels": [
            "SlowMist",
            "ENF_ETH_Lowrisk",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Redundant variable",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ENF_ETH_Lowrisk_en-us.pdf",
        "body": "There is a weth global variable in the CEth contract, but this variable is not used in the contract. ",
        "labels": [
            "SlowMist",
            "ENF_ETH_Lowrisk",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ENF_ETH_Lowrisk_en-us.pdf",
        "body": "10 In the protocol, the owner role has many permissions, such as: the owner can set sensitive parameters, can suspend the contract, can make emergency withdrawals, can migrate the funds of the SS contract, etc. It is obviously inappropriate to give all the permissions of the protocol to the owner, which will greatly increase the single point of risk.",
        "labels": [
            "SlowMist",
            "ENF_ETH_Lowrisk",
            "Type: Authority Control Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Compound interest slippage check issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - ENF_ETH_Lowrisk_en-us.pdf",
        "body": "In the router contract, no slippage check is performed during the swap operation. If there are more funds with compound interest, there will be a risk of being attacked by sandwiches. ",
        "labels": [
            "SlowMist",
            "ENF_ETH_Lowrisk",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Redundant collectEndTime check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report_en-us.pdf",
        "body": "In the CongurableRightsPool contract, users can redeem underlying assets through the exitPool function. When the pool is a closed ETF, it will check isCompletedCollect and collectEndTime to decide whether to perform _claimManagerFee operation. But when isCompletedCollect is true, the collectEndTime check will be performed in snapshotEndAssets, and when isCompletedCollect is false, the collectEndTime check will be performed in exitPoolHandleB. Hence the collectEndTime check before the _claimManagerFee operation is redundant. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Redundant closureEndTime check on exitPool",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report_en-us.pdf",
        "body": "In the CongurableRightsPool contract, users can redeem underlying assets through the exitPool function. When the pool is a closed ETF and isCloseEtfCollectEndWithFailure is false, it will check that the current time must be greater than closureEndTime + 5 minutes before allowing the user to exit. However, it should be noted that the snapshotEndAssets operation will be performed before this. The snapshotEndAssets function will also check whether the current time is greater than closureEndTime + 5 minutes . Only the admin and owner can execute snapshotEndAssets within 5 minutes after the closure period ends. Otherwise, the transaction will be reverted. Therefore, the closureEndTime check in the exitPool function is redundant. When snapshotEndAssets cannot be performed, the entire transaction will be reverted, and subsequent closureEndTime checks will not be performed. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Redundant performance fee calculation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report_en-us.pdf",
        "body": "In the exitPool function of the CongurableRightsPool contract, redeemAndPerformanceFeeReceived, nalAmountOut and redeemFeeReceived are calculated through exitPoolHandleA. However, since the performance fee will be calculated uniformly in the snapshotEndAssets operation, there is no need to process the performance fee in the exitPool function. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "The time allowed for snapshots is too short",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report_en-us.pdf",
        "body": "In the CongurableRightsPool contract when the closed ETF completes collect and the collection period has ended, the current total value of the ETF can be recorded through the snapshotBeginAssets function. However, users can only call the snapshotBeginAssets function within 15 minutes after the end of the collection period. If there is congestion on the chain, it may not be possible to call the snapshot in time within 15 minutes. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Duplicate decimal processing issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report_en-us.pdf",
        "body": "In the DesynChainlinkOracle contract, the getPrice function is used to obtain the corresponding token price from prices, getChainlinkPrice, and getUniswapPrice, and perform decimal processing. However, decimal has been processed in getChainlinkPrice and getUniswapPrice, and theoretically, the returned decimal will be 1e18. Therefore, processing decimals through decimalDelta will cause decimals to be enlarged. Note that the amountIn passed in for the consult in the getUniswapPrice function is 1e18, which needs to be ensured that the token decimal in twapOracle matches it in practice ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Decimal processing issue in AllPrice calculation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report_en-us.pdf",
        "body": "In the DesynChainlinkOracle contract, the getAllPrice function is used to calculate the total value of the specied amount of tokens. It is calculated by badd(fundAll, bmul(getPrice(t), tokenAmountOut)) , theoretically the decimal returned by getPrice is 1e18, and the decimal of tokenAmountOut is consistent with the decimal of the token itself. Therefore, multiplying these two values will result in a very large decimal in the nal result. The getNormalizedWeight function is also aected by this, but this is not harmful to normal business. Note: ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Redundant code issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report_en-us.pdf",
        "body": "In the SmartPoolManager library, the exitPoolHandle function has been deprecated since closed ETF prots are calculated in snapshotEndAssets. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Token list conict in recordTokenInfo",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report_en-us.pdf",
        "body": "When the user performs createPool and joinPool, if the Pool is a closed ETF and the current time is within the collection period, the KOL invitation amount will be recorded through UserVault's recordTokenInfo interface. But unfortunately, the tokens in the Pool can be Bind/unBind at any time, which will cause the list of tokens supported by the Pool to change. If the recordTokenInfo operation is performed when the Pool token list changes, the amount recorded by variables such as poolInviteTotal, kolTotalAmountList, and kolUserInfo may be disturbed. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "couldManagerClaim not checked when managerClaim",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report_en-us.pdf",
        "body": "In the UserVault contract, the Manager role can claim management fees through the managerClaim function, but it does not check whether the couldManagerClaim parameter is true. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Some redundant invoke functions",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report_en-us.pdf",
        "body": "In the Invoke library, the strictInvokeTransfer, invokeUnwrapWETH, invokeWrapWETH, and invokeMint functions are not used. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of ETF falsication",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report_en-us.pdf",
        "body": "In the RebalanceAdapter contract, the Manager role can adjust the position of the pool through the rebalance function. But the address of the ETF is obtained from the rebalanceInfo passed in by the user. If a malicious user passes in a fake ETF, the check in the onlyManager decorator will be bypassed, and the _verifyWhiteToken check of token1 and the isCompletedCollect and collectEndTime checks will be useless. Malicious users can steal bPool funds through _makeSwap and bind malicious tokens. The approve function also has this risk, but it doesn't break the protocol too much ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Risk of the Manager role potentially disrupting the protocol",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report_en-us.pdf",
        "body": "In the RebalanceAdapter contract, the Manager role can adjust the position of the ETF through the rebalance function. It will use the _makeSwap function to call Uniswap, 1inch and other DEXs for token swaps to adjust token positions. But unfortunately, the swap path of the token is not checked during the token swap process, which will cause the Manager role to pass in a carefully constructed malicious swap path to steal the middle token0 of the ETF. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Double slippage check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report_en-us.pdf",
        "body": "In the RebalanceAdapter contract, the Manager role can adjust the position of the ETF through the rebalance function. It will use the _makeSwap function to call Uniswap, 1inch and other DEXs for token swaps to adjust token positions. During the swap process, the slippage will be checked by passing minReturn to the external DEXs, but the implementation of the slippage check of the external DEXs is uncontrollable. If the slippage protection of the external DEXs fails, it will aect the funds of users in the protocol. (1inch users encountered invalid slippage check before) ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Does not follow the Checks-Eects-Interactions specication",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report_en-us.pdf",
        "body": "In the RebalanceAdapter contract, the _makeSwap function is used for token swap. When the swap type is not UNISWAPV3 and UNISWAPV2, the parameters passed in by the user will be checked through _validateData . However, the execute operation is performed rst, and the _validateData operation is performed after the token exchange is completed. This is not in line with the follow the Checks-Effects-Interactions principle. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Perform strict parameter checking",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report_en-us.pdf",
        "body": "In the RebalanceAdapter contract, the _validateData function is used to check the exchange parameters, but it only parses the recipient and amountIn for checking, but does not check whether other key parameters such as srcToken, dstToken, clipperExchange, makerAsset, takerAsset are in line with expectations. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Redundant aggregator parameter",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report_en-us.pdf",
        "body": "In the RebalanceAdapter contract, the _validateData function is used to check the conversion parameters, but the aggregator parameter it receives is not used. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Incorrect approval operation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report_en-us.pdf",
        "body": "In the RebalanceAdapter contract, the Manager role can adjust the position of the ETF through the rebalance function. If token1 has not been bound in bPool, it will be approved rst. However, the subsidy of this contract was wrongly approved to bPool, which will cause bPool to be unable to transfer tokens from CRP in the future. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report_en-us.pdf",
        "body": "There is an execute function in the CRP and bPool contracts so that the Manager can manage the ETF. In bFactory, the Blabs role can arbitrarily register modules to gain control over CRP. The registered modules can use the execute function in CRP to call the execute function in bPool to perform any operations. This would pose a huge risk to users' funds. And the Manager can approve the tokens in the bPool through the approve function of the RebalanceAdapter contract, which will also bring huge risks to the user's funds. The above problems lead to the risk of excessive permissions of the Blabs role and the Manager role. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Authority Control Vulnerability Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Enforce strict permission controls",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/Desyn Phase3 - SlowMist Audit Report_en-us.pdf",
        "body": "In the LiquidityPool contract, any user can call the joinPool, exitPool, and gulp functions to add/remove liquidity/record token balances, which will make it impossible to charge various fees to users in CRP. ",
        "labels": [
            "SlowMist",
            "Desyn Phase3 - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Business logic issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Unemeta_en-us.pdf",
        "body": "1.In the UnemetaMarket contract, the matchSellerOrdersWETH and matchSellerOrders use the strategy to match orders, but the canExecuteTakerBid function is not in the StrategyFixedPrice contract. ",
        "labels": [
            "SlowMist",
            "Unemeta",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Unemeta_en-us.pdf",
        "body": "The owner role of the RoyaltyFeeRegistry and RoyaltyFeeSetter contract can update the royaltyFeeLimit and the FeeInfo of the NFT collection. ",
        "labels": [
            "SlowMist",
            "Unemeta",
            "Type: Authority Control Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Risk of replay attack",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Unemeta_en-us.pdf",
        "body": "13 The chainid is dened when the contract is initialized, but it is not reimplemented when DOMAIN(domainSeparator) is used in the verify function. So the domainSeparator contains the chainId and is dened at contract deployment instead of reconstructed for every signature, there is a risk of possible replay attacks between chains in the event of a future chain split. ",
        "labels": [
            "SlowMist",
            "Unemeta",
            "Type: Replay Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing event records",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - PancakeSwap Stable Swap_en-us.pdf",
        "body": "In the PancakeStableSwap contract, the owner can set the is_killed, balances and admin_actions_deadline parameters respectively through the kill_me, unkill_me, donate_admin_fees and revert_new_parameters functions, but no event recording is performed. ",
        "labels": [
            "SlowMist",
            "PancakeSwap Stable Swap",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Ring Protocol_en-us.pdf",
        "body": "1.In the FewWrappedToken contract, the burner role can burn any users Wrapped tokens through the burnFrom function without users approval. All role settings are completed in the core contract, which is not within the scope of this audit. ",
        "labels": [
            "SlowMist",
            "Ring Protocol",
            "Type: Authority Control Vulnerability Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Token compatibility reminder",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Ring Protocol_en-us.pdf",
        "body": "In the FixedStakingRewards contract, users can stake, stakeWithPermit, and withdraw the stakeingTokens by safetransferFrom and safetransfer functions to the staking contract and the amount will be directly recorded in the totalSupply. If the stakingTokens are deationary tokens, the actual amount of tokens received by the FixedStakingRewards contract will be less than the amount recorded by the amount parameter. ",
        "labels": [
            "SlowMist",
            "Ring Protocol",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Potential token decimal compatibility reminder",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Ring Protocol_en-us.pdf",
        "body": "In the FixedStakingRewards contract, users can stake the tokens through the stake and stakeWithPermit functions. It will update each totalSupply and balances parameters according to the amount of user deposits. These parameters will not distinguish dierent stakingTokens, if the stakingTokens deposit with dierent decimals will may lead to errors in the calculation of rewards in the protocol.",
        "labels": [
            "SlowMist",
            "Ring Protocol",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing the event records",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Ring Protocol_en-us.pdf",
        "body": "In the FixedStakingRewards contract, the rewardSetter can arbitrarily modify every rewardPerTokenPerSecond , periodFinish , and rewardSetter parameters in each StakingInfo, but there are no event logs. ",
        "labels": [
            "SlowMist",
            "Ring Protocol",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing the 0 address check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Ring Protocol_en-us.pdf",
        "body": "In the FixedStakingRewards and CoreRef contract, the Governor role can modify the _core address and the rewardSetter can modify the rewardSetter address, but there are no 0 address checks. ",
        "labels": [
            "SlowMist",
            "Ring Protocol",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Malleable attack risk",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Ring Protocol_en-us.pdf",
        "body": "In the permit function of the FewWrappedToken contract, it restores the address of the signer through the ecrecover function, but does not check the value of v and s. Since EIP2 still allows the malleability for ecrecover, this will lead to the risk of transaction malleability attacks. ",
        "labels": [
            "SlowMist",
            "Ring Protocol",
            "Type: Replay Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of replay attack",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Ring Protocol_en-us.pdf",
        "body": "DOMAIN_SEPARATOR is dened when the contract is initialized, but it is not reimplemented when DOMAIN_SEPARATOR is used in the permit function. So the DOMAIN_SEPARATOR contains the chainId and is dened at contract deployment instead of reconstructed for every signature, there is a risk of possible replay attacks between chains in the event of a future chain split. ",
        "labels": [
            "SlowMist",
            "Ring Protocol",
            "Type: Replay Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Preemptive Initialization",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Ring Protocol_en-us.pdf",
        "body": "By calling the initialize and deploy functions to initialize the contracts, there is a potential issue that malicious attackers preemptively call the initialize function to initialize. ",
        "labels": [
            "SlowMist",
            "Ring Protocol",
            "Type: Race Conditions Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - getBTC.pdf",
        "body": "1.In the TokenExchange contract, the owner role can set vaults mapping through the setVaults function. TokenExchange.sol#L74-L77 function setVaults(address valut, bool status) external onlyOwner { vaults[valut] = status; emit SetVaults(valut, status); } 2.In the TokenExchange contract, the owner role can set the Operator role address through the setOperator function; the owner's ownership can be transferred through the transferOwnership function. TokenExchange.sol#L90-L94,L95-L99 function transferOwnership(address newOwner) external onlyOwner { require(newOwner != address(0),\"Owner_Should_Not_Zero_Address\"); owner = newOwner; emit TransferOwnership(newOwner); } function setOperator(address newOp) external onlyOwner { operator = newOp; emit SetOperator(newOp); } 3.In the TokenExchange contract, the owner role can withdraw the ERC20 token in the contract through the withdrawERC20 function; the Native token in the contract can be withdrawn through the withdrawBTC function. TokenExchange.sol#L78-L82,L82-L88 function withdrawERC20(address tokenAddress, address receiver, uint256 amount) external onlyOwner { require(amount <= IERC20(tokenAddress).balanceOf(address(this)),\"Token_Not_Enough\"); SafeERC20.safeTransfer(IERC20(tokenAddress), receiver, amount); emit Withdrawn(tokenAddress, receiver, amount); } function withdrawBTC(address payable receiver, uint256 amount) external onlyOwner { require(amount <= address(this).balance,\"BTC_Not_Enough\"); (bool success, bytes memory returnData) = receiver.call{value: amount}(\"\"); require(success, string(returnData)); emit Withdrawn(address(0), receiver, amount); }",
        "labels": [
            "SlowMist",
            "getBTC",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Missing zero address check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - getBTC.pdf",
        "body": "In the TokenExchange contract, the withdrawBTC function and setOperator function lack zero address check. TokenExchange.sol#L83-L88,L95-L98 function withdrawBTC(address payable receiver, uint256 amount) external onlyOwner { require(amount <= address(this).balance,\"BTC_Not_Enough\"); (bool success, bytes memory returnData) = receiver.call{value: amount}(\"\"); require(success, string(returnData)); emit Withdrawn(address(0), receiver, amount); } function setOperator(address newOp) external onlyOwner { operator = newOp; emit SetOperator(newOp); }",
        "labels": [
            "SlowMist",
            "getBTC",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Variable names are the same",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - getBTC.pdf",
        "body": "The private string variable _name dened in the TokenExchange contract has the same name as the private immutable string _name inherited from the EIP712 contract. TokenExchange.sol#L19 string private _name; EIP712.sol#L49 ShortString private immutable _name;",
        "labels": [
            "SlowMist",
            "getBTC",
            "Type: Others",
            "Severity: Information"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - peg-Token.pdf",
        "body": "1.The PegToken contracts and the TokenManager contract are implemented using the OpenZeppelin upgradeable model, allowing the AdminRole role to perform contract upgrades. In the TokenManager contract, the Operator role can upgrade the specied PegToken contract through the upgradeToken function.However, this design introduces an excessive privilege risk. TokenManager.sol#L123-L131 function upgradeToken(string memory symbol, address newImpl, bytes memory callData) external onlyRole(Operator) { require(newImpl != address(0), \"invalid new impl\"); PegToken peg = getDeployedTokenOrRevert(symbol); peg.upgradeToAndCall(newImpl, callData); } 2.In the TokenManager contract, the Operator role can call the setBlacklist function of the specied PegToken contract through the setBlackList function to add a blacklist address. TokenManager.sol#L79-L87 function setBlackList(string memory symbol, address account, bool toBlacklist) external onlyRole(Operator) { require(account != address(0), \"invalid account\"); PegToken peg = getDeployedTokenOrRevert(symbol); peg.setBlacklist(account, toBlacklist); } PegToken.sol#L86-L92 function setBlacklist(address account, bool toBlacklist) external onlyManager { isBlacklist[account] = toBlacklist; emit BlacklistAdded(account, toBlacklist); } 3.In the TokenManager contract, the Operator role can add the Minter role by calling the setMinter function of the specied PegToken contract through the setMinter function. TokenManager.sol#L89-L97 function setMinter(string memory symbol, address account, bool asMinter) external onlyRole(Operator) { require(account != address(0), \"invalid account\"); PegToken peg = getDeployedTokenOrRevert(symbol); peg.setMinter(account, asMinter); } PegToken.sol#L94-L100 function setMinter(address account, bool asMinter) external onlyManager { minters[account] = asMinter; emit MinterSet(account, asMinter); } 4.In the PegToken contract, the Minter role can mint any number of tokens by calling the mint function through the mint function. PegToken.sol#L112-L118 function mint(address to, uint256 amount) external onlyMinter notBlacklisted(to) { _mint(to, amount); } 5.In the TokenManager contract, the FreezeRole role can perform transfer operations by calling the recall function of the specied PegToken contract through the recall function. TokenManager.sol#L159-L165 function recall(string memory symbol, address from, address to, uint256 value) external onlyRole(FreezeRole) { PegToken peg = getDeployedTokenOrRevert(symbol); peg.recall(from, to, value); } PegToken.sol#L120-L126 function recall(address from, address to, uint256 value) external onlyManager { _transfer(from, to, value); emit TokenRecalled(from, to, value); } 6.In the TokenManager contract, the FreezeRole role can freeze the specied token at the specied address by calling the freeze function of the specied PegToken contract through the freezeToken function. TokenManager.sol#L143-L149 function freezeToken(string memory symbol, address account, uint256 value) external onlyRole(FreezeRole) { PegToken peg = getDeployedTokenOrRevert(symbol); peg.freeze(account, value); } PegToken.sol#L128-L136 function freeze(address account, uint256 value) external onlyManager { _transfer(account, address(this), value); freezedToken[account] += value; emit TokenFreezed(account, value); }",
        "labels": [
            "SlowMist",
            "peg-Token",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "DoS issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Flurry Bridge_en-us.pdf",
        "body": "The getVoteCount function uses a for loop to count members votes. When the number of members is large, it will cause DoS due to the increased number of for loops. bridge/contracts/contracts/Federation.sol#L242-L249 function getVoteCount(bytes32 processId) public view override returns(uint) { uint count = 0; for (uint i = 0; i < members.length; i++) { if (votes[processId][members[i]]) count += 1; } return count; }",
        "labels": [
            "SlowMist",
            "Flurry Bridge",
            "Type: Denial of Service Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Safety Reminders",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Flurry Bridge_en-us.pdf",
        "body": "To capture events in the cross-chain bridge, the implementation of subscribing to the events of the specied contract should be adopted to avoid the attacks of fake contract events.",
        "labels": [
            "SlowMist",
            "Flurry Bridge",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Limit of value range",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Flurry Bridge_en-us.pdf",
        "body": "Owner can set fee arbitrarily, and there is no restriction on the value range. and the fee variable is not used in the contract code. bridge/contracts/contracts/Registry.sol#L87-L91 function setFee(address localaddr_, uint256 fee_) external override onlyOwner { require(fee_ > 0, \"Registry: Fee Should be> 0\"); fee[localaddr_] = fee_; emit FeeChanged(localaddr_, fee_); } 8",
        "labels": [
            "SlowMist",
            "Flurry Bridge",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Useless code",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Flurry Bridge_en-us.pdf",
        "body": "There are a lot of comment codes in the contract. It is necessary to conrm whether the comment codes are redundant codes. bridge/contracts/contracts/Registry.sol#L43-L85 // function registerCall( // uint256 alienChainId_, // address alienChainContractAddr_, // address localChainContractAddr_, // bytes4 callSig_ // ) external onlyOwner { // bytes32 callRegistryID = Utils.getCallRegistryId( // alienChainId_, // alienChainContractAddr_, // localChainContractAddr_, // callSig_ // ); // require(!callRegistry[callRegistryID], \"Registry: Call already exists in callRegistry\"); // callRegistry[callRegistryID] = true; // emit CallRegistered( // alienChainId_, // alienChainContractAddr_, // localChainContractAddr_, // callSig_ // ); // } // function unregisterCall( 9 // uint256 alienChainId_, // address alienChainContractAddr_, // address localChainContractAddr_, // bytes4 callSig_ // ) external onlyOwner { // bytes32 callRegistryID = Utils.getCallRegistryId( // alienChainId_, // alienChainContractAddr_, // localChainContractAddr_, // callSig_ // ); // require(callRegistry[callRegistryID], \"Registry: Call not registered\"); // delete callRegistry[callRegistryID]; // emit CallUnregistered( // alienChainId_, // alienChainContractAddr_, // localChainContractAddr_, // callSig_ // ); // } bridge/contracts/contracts/Federation.sol#L159-L240 // function voteCall( // uint256 srcChainID_, // address srcChainContractAddress_, // address dstChainContractAddress_, // bytes32 transactionHash_, // uint32 logIndex_, // bytes calldata payload // ) external override onlyMember { // if (bridge.isCallProcessed( // srcChainID_, // srcChainContractAddress_, // dstChainContractAddress_, // transactionHash_, // logIndex_, // payload // )) { // return; // } // bytes32 callId = Utils.getCallId( 10 // srcChainID_, // srcChainContractAddress_, // dstChainContractAddress_, // transactionHash_, // logIndex_, // payload // ); // if (votes[callId][_msgSender()]) // return; // votes[callId][_msgSender()] = true; // emit VotedCall( // srcChainID_, // srcChainContractAddress_, // dstChainContractAddress_, // transactionHash_, // logIndex_, // _msgSender(), // callId, // payload // ); // uint voteCount = getVoteCount(callId); // if ((voteCount >= required) && (voteCount >= members.length / 2 + 1)) { // bridge.acceptCall( // srcChainID_, // srcChainContractAddress_, // dstChainContractAddress_, // transactionHash_, // logIndex_, // payload // ); // emit ExecutedCall(callId); // } // } // function hasVotedCall( // uint256 srcChainID_, // address srcChainContractAddress_, // address dstChainContractAddress_, // bytes32 transactionHash_, // uint32 logIndex_, // bytes calldata payload // ) external view override returns(bool) { // bytes32 callId = Utils.getCallId( 11 // srcChainID_, // srcChainContractAddress_, // dstChainContractAddress_, // transactionHash_, // logIndex_, // payload // ); // return votes[callId][_msgSender()]; // } // function isCallProcessed( // uint256 srcChainID_, // address srcChainContractAddress_, // address dstChainContractAddress_, // bytes32 transactionHash_, // uint32 logIndex_, // bytes calldata payload // ) external view override returns(bool) { // return bridge.isCallProcessed(srcChainID_, srcChainContractAddress_, dstChainContractAddress_, transactionHash_, logIndex_, payload); // } bridge/contracts/contracts/Bridge.sol#L114-L154 // function acceptCall( // uint256 srcChainID_, // address srcChainTokenAddress_, // address dstChainTokenAddress_, // bytes32 transactionHash_, // uint32 logIndex_, // bytes calldata payload // ) external override onlyFederation nonReentrant { // require(dstChainTokenAddress_ != address(0), \"Bridge: destination chain token address is null\"); // require(srcChainTokenAddress_ != address(0), \"Bridge: src chain token address is null\"); // require(transactionHash_ != bytes32(0), \"Bridge: Transaction is null\"); // require(srcChainTokenAddress_ != address(0), \"src token address is null\"); // bytes4 sig = // payload[0] | // (bytes4(payload[1]) >> 8) | // (bytes4(payload[2]) >> 16) | // (bytes4(payload[3]) >> 24); 12 // bytes32 callRegistryID = Utils.getCallRegistryId( // srcChainID_, // srcChainTokenAddress_, // dstChainTokenAddress_, // sig // ); // require(tokenRegistry.callRegistry(callRegistryID), \"Call Not Registered\"); // bytes32 callId = Utils.getCallId( // srcChainID_, // srcChainTokenAddress_, // dstChainTokenAddress_, // transactionHash_, // logIndex_, // payload // ); // require(processed[callId] == 0, \"Bridge: Already processed\"); // processed[callId] = block.number; // // call the function // (bool success, ) = dstChainTokenAddress_.call(payload); // require(success, \"call fail\"); // } bridge/contracts/libraries/Utils.sol#L6-L18 // function getCallRegistryId( // uint256 alienChainId_, // address alienChainContractAddr_, // address localChainContractAddr_, // bytes4 callSig_ // ) internal pure returns(bytes32) { // return keccak256(abi.encodePacked( // alienChainId_, // alienChainContractAddr_, // localChainContractAddr_, // callSig_ // )); // } 13 bridge/contracts/libraries/Utils.sol#L50-L67 // function getCallId( // uint256 srcChainID_, // address srcChainTokenAddress_, // address dstChainTokenAddress_, // bytes32 transactionHash_, // uint32 logIndex_, // bytes calldata payload // ) internal pure returns (bytes32) { // return keccak256(abi.encodePacked( // \"Call\", // srcChainID_, // srcChainTokenAddress_, // dstChainTokenAddress_, // transactionHash_, // logIndex_, // payload // )); // }",
        "labels": [
            "SlowMist",
            "Flurry Bridge",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Redundant Code Usage",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm_Phase5_en-us.pdf",
        "body": "In the Vault contract of ENFv3/ENF_lowrisk_farm/ENF_lowrisk_ETH_farm, the user will rst calculate the share when performing the withdraw operation. But it is calculated in the same way as the convertToShares function, so it is not necessary to use duplicate code for the calculation without using the convertToShares function. ",
        "labels": [
            "SlowMist",
            "Earning.Farm_Phase5",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Potential Precision Calculation Issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm_Phase5_en-us.pdf",
        "body": "In the Vault contract of ENFv3/ENF_lowrisk_farm/ENF_lowrisk_ETH_farm, users can burn shares through the redeem function to get back staked assets. It uses (shares * assetsPerShare()) / 1e24 to calculate the number of assets corresponding to the share, and the assetsPerShare function will multiply (assetDecimal * 1e18) when performing calculations. If assetDecimal is not equal to 6, dividing 1e24 when performing assets calculation will cause the decimal of the result to deviate. ",
        "labels": [
            "SlowMist",
            "Earning.Farm_Phase5",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Business logic aws in reward distribution",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm_Phase5_en-us.pdf",
        "body": "In the Vault contract of ENF_lowrisk_farm/ENF_lowrisk_ETH_farm, users can obtain shares through deposits, and receive harvest dividends according to the amount of shares held. The key to reward calculation is the accRewardPerTokens and prevBalace parameters. The owner role will increase the accRewardPerTokens parameter every time the harvest operation is performed, and prevBalace represents the user's share balance before reward settlement. But there will be a way to collect rewards by front-run deposits to improve the eciency of capital utilization: When the owner role performs the harvest operation, the user deposits at a higher gas fee. At this point the accRewardPerShares of the protocol has not been updated, and the user will get a portion of the shares. Then the owner performs the harvest operation, and the accRewardPerShares of the protocol will increase. Finally the user makes withdrawal and gets reward. Malicious users can use this method to obtain rewards in the blocks before and after the harvest operation, or even in the same block, without worrying about the problem of liquidity being locked in the protocol, which improves the utilization rate of funds. ",
        "labels": [
            "SlowMist",
            "Earning.Farm_Phase5",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Token Transfer Missing Rewards Update",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm_Phase5_en-us.pdf",
        "body": "In the Vault contract of ENF_lowrisk_farm/ENF_lowrisk_ETH_farm, the _updateUserData function is used to update the user's reward, but it is not updated when the user's share is transferred. This will result in accounting errors during share token transfers. Users can steal rewards by continuously transferring share tokens to new addresses. ",
        "labels": [
            "SlowMist",
            "Earning.Farm_Phase5",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Issue with checking on fromToken",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm_Phase5_en-us.pdf",
        "body": "In the vault contract of ENF_lowrisk_farm/ENF_lowrisk_ETH_farm, the _swap function is used to exchange reward tokens for the specied toToken. It will check whether fromToken is WETH, if the check is true, it will be exchanged through the swapExactETHInput function, if the check is false, it will be exchanged through swapExactTokenInput. However, when fromToken is address(0), the token exchange will also be performed through the swapExactTokenInput function, which may cause the _swap function to fail to perform as expected. ",
        "labels": [
            "SlowMist",
            "Earning.Farm_Phase5",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Incorrect reward receiving address",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm_Phase5_en-us.pdf",
        "body": "In the Vault contract of ENF_lowrisk_farm/ENF_lowrisk_ETH_farm, users can claim rewards through the claim function and specify the receiving address of the rewards. When toAsset is false, the protocol will issue the reward directly to the user, but the destination address of the reward is not the receiver address specied by the user but msg.sender. This is not as expected. ",
        "labels": [
            "SlowMist",
            "Earning.Farm_Phase5",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Direct distribution of rewards is not available",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm_Phase5_en-us.pdf",
        "body": "In the Vault contract of ENF_lowrisk_farm/ENF_lowrisk_ETH_farm, users can claim rewards through the claim function. When toAsset is false, the protocol will directly issue rewards to users. The safeTransferFrom function is used to transfer tokens when issuing rewards, but the contract has not been approved before. This will cause the contract to be unable to successfully execute the safeTransferFrom operation due to insucient allowances, and ultimately result in failure to issue rewards. ",
        "labels": [
            "SlowMist",
            "Earning.Farm_Phase5",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of price manipulation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm_Phase5_en-us.pdf",
        "body": "In the stETH contract of ENF_lowrisk_ETH_farm, the slippage check of SS depends on the virtual price (get_virtual_price) of Curve Pool, which will be aected by the reentrancy vulnerability of ETH/stETH Pool (please check to Ref[1][2]). Failure to check for slippage will result in malicious theft of funds from the strategy. Ref: [1] https://chainsecurity.com/curve-lp-oracle-manipulation-post-mortem/ [2] https://chainsecurity.com/heartbreaks-curve-lp-oracles/",
        "labels": [
            "SlowMist",
            "Earning.Farm_Phase5",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "4.2.1.1 __Guard_init function was not call when initialize",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Hot Cross BSC Bridge V1.0.1_en-us.pdf",
        "body": "ForeignProcessor contract and HomeRequest contract are inherit the Guard contract but dost not call the __Gurad_init function function __ForeignProcessor_init( IERC20 token, ValidatorRegistry validatorRegistry_ ) internal initializer { //SlowMist// Missing call of __Guard_init function require( address(token) != address(0) && Misc.isContract(address(token)), \"ForeignProcessor:Invalid erc20 address provided\" 10 ); require( address(validatorRegistry_) != address(0) && Misc.isContract(address(validatorRegistry_)), \"ForeignProcessor:Invalid validator registry address\" ); erc20 = token; validatorRegistry = validatorRegistry_; } function __HomeRequest_init( BEP20 token, ValidatorRegistry validatorRegistry_ ) internal initializer { //SlowMist// Missing call of __Guard_init function require( address(token) != address(0) && Misc.isContract(address(token)), \"HomeRequest:Invalid BEP20 address\" ); require( address(validatorRegistry_) != address(0) && Misc.isContract(address(validatorRegistry_)), \"HomeRequest:Invalid validator registry address\" ); bep20 = token; validatorRegistry = validatorRegistry_; } Fix status: fixed. 11 5.",
        "labels": [
            "SlowMist",
            "Hot Cross BSC Bridge V1.0.1",
            "Severity: Informational"
        ]
    },
    {
        "title": "Access control issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - CheersUp_alpha8_en-us.pdf",
        "body": "The Owner role has the right to call the giveaway function to airdrop any number of blind boxes to any address at any time. function giveaway(address address_, uint64 numberOfTokens_) external onlyOwner nonReentrant { require(address_ != address(0), \"zero address\"); require(numberOfTokens_ > 0, \"invalid number of tokens\"); require(totalMinted() + numberOfTokens_ <= MAX_TOKEN, \"max supply exceeded\"); _safeMint(address_, numberOfTokens_); } The Owner role has the right to modify the cucpContractAddress contract address through the setCUCPContractAddress function, and unauthorized modication will result in the user's blind box being unable to be opened or arbitrarily modifying the blind box. function setCUCPContractAddress(address address_) public onlyOwner { cucpContractAddress = address_; } The Owner role has the right to modify the price of the blind box purchased by the user through the setWhitelistSaleCong function and the setPublicSaleCong function at any time. If the price of the blind box is modied after the sale starts, the user's transaction will fail. function setWhitelistSaleConfig(WhitelistSaleConfig calldata config_) external onlyOwner { require(config_.price > 0, \"sale price must greater than zero\"); whitelistSaleConfig = config_; } 9 function setPublicSaleConfig(PublicSaleConfig calldata config_) external onlyOwner { require(config_.price > 0, \"sale price must greater than zero\"); publicSaleConfig = config_; } The Owner has the right to modify the revealCong parameter through the setRevealCong function, which includes the address of the contract that opens the blind box, and the time and closing time of the blind box sale. function setRevealConfig(RevealConfig calldata config_) external onlyOwner { revealConfig = config_; }",
        "labels": [
            "SlowMist",
            "CheersUp_alpha8",
            "Type: Authority Control Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Random number problem",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - CheersUp_alpha8_en-us.pdf",
        "body": "The tokenId in the contract is related to the properties of the NFT. The tokenId is randomly generated through the random number on the chain, which will cause the random number to be predicted. function mint(address address_, uint256 cucpTokenId_) public returns(uint256) { require(_msgSender() == cucpContractAddress, \"not authorized\"); 10 require(_numberMinted + 1 <= MAX_TOKEN, \"mint would exceed max supply\"); uint256 tokenId = randomToken(address_); _safeMint(address_, tokenId); unchecked { _numberMinted += 1; } emit CheersUpRevealed(cucpTokenId_, tokenId); return tokenId; } function getRandomTokenId() internal returns (uint256) { unchecked { uint256 remain = MAX_TOKEN - _numberMinted; uint256 pos = unsafeRandom() % remain; uint256 val = _randIndices[pos] == 0 ? pos : _randIndices[pos]; _randIndices[pos] = _randIndices[remain - 1] == 0 ? remain - 1 : _randIndices[remain - 1]; return val; } } /** * @notice unsafeRandom is used to generate a random number by on-chain randomness. * Please note that on-chain random is potentially manipulated by miners, and most scenarios suggest using VRF. * @return randomly generated number. */ function unsafeRandom() internal view returns (uint256) { unchecked { return uint256(keccak256(abi.encodePacked( blockhash(block.number-1), block.difficulty, block.timestamp, _numberMinted, tx.origin ))); } }",
        "labels": [
            "SlowMist",
            "CheersUp_alpha8",
            "Type: Others",
            "Severity: Low"
        ]
    },
    {
        "title": "4.3.1.1 Risk of Oracle Manipulation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Shield_en-us.pdf",
        "body": "In DDSContracts, the price is obtained from Uniswap's getAmountsIn through the getPriceByWBTCDAI function, but this interface obtains the real-time price of the WBTC/DAI pool, and there is a risk of malicious manipulation. 6 Fix suggestion: It is recommended to use Uniswap's delayed price feed oracle for acquisition. ",
        "labels": [
            "SlowMist",
            "Shield",
            "Severity: Critical"
        ]
    },
    {
        "title": "4.3.1.2 Price acquisition issue when opening and closing positions",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Shield_en-us.pdf",
        "body": "In the DDSContracts contract, the price used when opening and closing a position is passed in from the outside, which will cause the user to pass in any price when opening and closing a position. After communicating with the project party, this is the test code, and the oracle will be used to feed the price during the formal deployment. Fix suggestion: It is recommended to use Uniswap's delayed price feed oracle for acquisition. ",
        "labels": [
            "SlowMist",
            "Shield",
            "Severity: Critical"
        ]
    },
    {
        "title": "4.3.2.1 The available funds were not processed when the riskControl",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Shield_en-us.pdf",
        "body": "closed the position In the Pool contract, when riskClose is triggered when the risk control liquidation is triggered, if the margin is insufficient and the pool order transfer fails, risk funds will be used to make up for the insufficient part, and all available funds of the user will be deducted. However, the user's available funds are not actually set to 0. Fix suggestion: It is recommended that the available funds should be emptied after the transfer of insurance funds. ",
        "labels": [
            "SlowMist",
            "Shield",
            "Severity: High"
        ]
    },
    {
        "title": "4.3.3.1 Insecure random number",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Shield_en-us.pdf",
        "body": "In the Pool contract, the getMatchLp2Object function uses block difficulty and block time now as the random number seed to participate in the calculation of random numbers. But block difficulty and time can be predicted or manipulated. Fix suggestion: It is recommended to use the random number provided by chainlink that cannot be manipulated. ",
        "labels": [
            "SlowMist",
            "Shield",
            "Severity: Low"
        ]
    },
    {
        "title": "4.3.4.1 Event missing",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Shield_en-us.pdf",
        "body": "In the DDSContracts contract, the owner can set the key parameters of the contract through the setExchageAddress, setPoolTokenAddr, setPrivatePool, setPublicPool, setFormular, and setrepayFudAddr functions, but no event recording is performed. Fix suggestion: In order to facilitate follow-up records and community viewing, it is recommended to record events for sensitive parameter modifications. ",
        "labels": [
            "SlowMist",
            "Shield",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.3.4.2 Does not follow the `Checks-effects-interactions` model",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Shield_en-us.pdf",
        "body": "In Contracts and Pool2 contracts, when deposit and provide functions are used to recharge, the state is changed first, and then the corresponding tokens are transferred to the contract. Fix suggestion: It is recommended to follow the Checks-effects-interactions model, first transfer the corresponding tokens and then change the state. 10 ",
        "labels": [
            "SlowMist",
            "Shield",
            "Severity: Informational"
        ]
    },
    {
        "title": "4.3.4.3 Redundant code",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Shield_en-us.pdf",
        "body": "Provide price feed interfaces such as updateImpliedVolrate and updatePriceByOwner in the DDSFormular contract to update the price. However, these interfaces are not used by the Contracts contract, and these price-feeding interfaces have no permission control and can be called by any user. 11 Fix suggestion: If this interface is a test interface, it is recommended to remove it during formal deployment. If it will use the suggestions in subsequent iterations for permission control. ",
        "labels": [
            "SlowMist",
            "Shield",
            "Severity: Informational"
        ]
    },
    {
        "title": "Potential denial of service risk due to gulp operations",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase5 - SlowMist Audit Report.pdf",
        "body": "- - - - - - - - - - - - - - - - - In the Actions contract, when the user performs the autoJoinSmartPool operation, the number of shares the user can obtain will be calculated through the _calculateShare function, and minPoolAmountOut will be checked at the end. The _calculateShare function obtains the number of tokens recorded in the pool through bPool's getBalance when calculating the share, but unfortunately any user can update this parameter through bPool's gulp function. Therefore, when an ordinary user performs an autoJoinSmartPool operation, a malicious user directly transfers funds to bPool and calls the gulp function to update the token balance recorded in the pool. At this time, ordinary users will not be able to successfully add liquidity due to the minPoolAmountOut check. If the minPoolAmountOut value passed in by an ordinary user is 0, it may cause an interest rate ination attack. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase5 - SlowMist Audit Report",
            "Type: Denial of Service Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Incorrect event logging",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase5 - SlowMist Audit Report.pdf",
        "body": "In the CRP contract, the createPool function adds the creator parameter as the real creator of the pool. However, the corresponding events were not modied accordingly. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase5 - SlowMist Audit Report",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Incorrect WETH address",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase5 - SlowMist Audit Report.pdf",
        "body": "The WETH address constant is hard-coded in the Actions contract, but this address is an EOA address on the Ethereum mainnet and is not the correct WETH address. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase5 - SlowMist Audit Report",
            "Type: Others",
            "Severity: High"
        ]
    },
    {
        "title": "Incorrect poolTokens check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase5 - SlowMist Audit Report.pdf",
        "body": "In the autoJoinSmartPool function of the Actions contract, it checks the tokens deposited by the user through poolTokens[i] == handleToken , but handleToken has been replaced by the issueToken parameter during the native token checking phase. Therefore, the poolTokens[i] == handleToken check is not accurate. If handleToken is WETH, it will cause an error in the _makeSwap operation. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase5 - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Redundant STBT token check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase5 - SlowMist Audit Report.pdf",
        "body": "In the autoJoinSmartPool and _exit functions of the Actions contract, when making a token transfer, it will be checked whether the transferred token is an STBT token. But in fact, the protocol does not allow deposits of STBT tokens, and STBT tokens will also be converted into stablecoins after the ETF expires. Therefore, theoretically, there will be no STBT tokens in the contract, so the STBT token check is redundant. . ",
        "labels": [
            "SlowMist",
            "DeSyn Phase5 - SlowMist Audit Report",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Potential risk of slot conict",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase5 - SlowMist Audit Report.pdf",
        "body": "In this protocol iteration, both SmartPoolManager and Actions contracts have changed their storage structures. If these contracts use an upgradeable model, and upgrading the contract directly on the original basis may lead to contract storage slot conicts. In fact, the Actions contract is an upgradeable contract, so special attention should be paid to such risks.",
        "labels": [
            "SlowMist",
            "DeSyn Phase5 - SlowMist Audit Report",
            "Type: Variable Coverage Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of event forgery",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase5 - SlowMist Audit Report.pdf",
        "body": "In the CRP contract, the exitPool function adds a user parameter to record the real caller when the user exits through the Actions contract. However, users can also exit by calling the exitPool function of the CRP contract. They can pass in any user parameter to make the LogExit event record an incorrect value. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase5 - SlowMist Audit Report",
            "Type: Malicious Event Log Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Potential risk of denial of service due to large CRPFactory array",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase5 - SlowMist Audit Report.pdf",
        "body": "In the CRPFactory contract, when the Blabs role performs addCRPFactory and removeCRPFactory operations, it will use a for loop to traverse the entire CRPFactorys array. If the array length is too large, it will lead to DoS risks. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase5 - SlowMist Audit Report",
            "Type: Denial of Service Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Potential risk of endless loop",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn Phase5 - SlowMist Audit Report.pdf",
        "body": "In the CRPFactory contract, the isCrp function is used to check whether the address passed by the user is a CRP contract. If not, the CRPFactorys array will be circulated and the isCrp function of other CRPFactory will be called to check. However, it should be noted that if the Blabs role adds this contract address to the CRPFactorys array, the user will fall into an innite loop error when querying a CRP address that is not recorded in this contract through the isCrp function. ",
        "labels": [
            "SlowMist",
            "DeSyn Phase5 - SlowMist Audit Report",
            "Type: Denial of Service Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Potential Token Compatibility Issues",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/STONE BTC - SlowMist Audit Report_en-us.pdf",
        "body": "In the StoneBTCVault contract, users can deposit funds through the deposit/depositMultiple functions. The contract directly transfers the user-specied amount of wrapped BTC tokens using the safeTransferFrom function. It is important to note that the contract is not compatible with fee-on-transfer wrapped BTC tokens. Similarly, when users make deposits or withdrawals, the contract performs decimal conversion using 18- tokenDecimals[_token] . This renders the contract incompatible with any wrapped BTC tokens that have a decimal greater than 18. ",
        "labels": [
            "SlowMist",
            "STONE BTC - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Potential risk of not being able to collect fees",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/STONE BTC - SlowMist Audit Report_en-us.pdf",
        "body": "In the StoneBTCVault contract, users are charged a certain fee when making deposits or withdrawals. The fee amount is determined by amount * feeRate / FEE_BASE . Due to Solidity's division operation truncating the decimal part, if the user's deposit or withdrawal amount is relatively small, the calculated fee will be 0. This prevents the contract from collecting deposit/withdrawal fees. ",
        "labels": [
            "SlowMist",
            "STONE BTC - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Unnecessary unchecked",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/STONE BTC - SlowMist Audit Report_en-us.pdf",
        "body": "In the StoneBTCVault contract, all the for loop functionalities use unchecked for incrementing i to reduce gas consumption. However, the contract's Solidity compilation uses ^0.8.26 , and Solidity introduced the unchecked loop increments feature in version 0.8.22, making the use of unchecked unnecessary. ",
        "labels": [
            "SlowMist",
            "STONE BTC - SlowMist Audit Report",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of DoS when removing supported tokens",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/STONE BTC - SlowMist Audit Report_en-us.pdf",
        "body": "In the StoneBTCVault contract, privileged roles can add/remove supported wrapped BTC tokens through the addSupportedTokens/removeSupportedTokens functions. When performing the removeSupportedTokens operation, the contract checks that the balance of the token being removed must be zero. This can be easily exploited, as users can donate a small amount of tokens to prevent the removeSupportedTokens function from working properly. It is also important to note that when users withdraw, the contract converts the decimal to the decimal of the token being withdrawn. When the decimal of this token is smaller than the decimal of STONE BTC, there will always be a small amount of dust tokens left in the vault. This indirectly prevents the removeSupportedTokens function from working correctly. ",
        "labels": [
            "SlowMist",
            "STONE BTC - SlowMist Audit Report",
            "Type: Denial of Service Vulnerability",
            "Severity: High"
        ]
    },
    {
        "title": "The actual deposit amount may dier from the contract balance",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/STONE BTC - SlowMist Audit Report_en-us.pdf",
        "body": "In the StoneBTCVault contract, the _checkDepositAllowed function checks the depositCapacity based on the balance of wrapped BTC tokens in the contract. Similarly, the getDepositAmounts function retrieves token balances to determine the deposit amounts. These values may dier from the actual deposit amounts made by users. Users might accidentally transfer supported tokens into the vault, or some users might send small donations to the vault. Both scenarios will cause the above two functions to obtain amounts that are greater than the users' actual deposit amounts. ",
        "labels": [
            "SlowMist",
            "STONE BTC - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Not checking if withAmount is greater than 0 when retrieving all tokens",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/STONE BTC - SlowMist Audit Report_en-us.pdf",
        "body": "In the Proposal contract, users can retrieve all their STONE tokens used for voting through the retrieveAllToken function. It uses a temporary variable withAmount to record the amount of STONE tokens that can be withdrawn. However, it does not check if withAmount is greater than 0 before initiating the transfer, which may result in the contract sending a 0 transfer and wasting gas. ",
        "labels": [
            "SlowMist",
            "STONE BTC - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risks of excessive privilege",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/STONE BTC - SlowMist Audit Report_en-us.pdf",
        "body": "In the StoneBTC contract, the contract deployer is set as the DEFAULT_ADMIN_ROLE. The admin role can arbitrarily change the MINTER_ROLE/BURNER_ROLE roles, which are involved in minting and burning STONE BTC. This leads to the risk of excessive privileges. Similarly, in the StoneBTCVault and Proposal contracts, the initial DEFAULT_ADMIN_ROLE is also the deployer. Assigning sensitive permissions to an EOA address not only creates the risk of excessive privileges but also introduces a single point of failure. ",
        "labels": [
            "SlowMist",
            "STONE BTC - SlowMist Audit Report",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Low-level call issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - CFFv2_en-us.pdf",
        "body": "In the CRVExchangeV2 contract, the handleExtraToken function is used to perform the token transfer operation after the token swap. Low-level calls are used when transferring native tokens, but the amount of gas usage is not limited, which may lead to unknown security risks. ",
        "labels": [
            "SlowMist",
            "CFFv2",
            "Type: Others",
            "Severity: Low"
        ]
    },
    {
        "title": "Contract variable usage issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - CFFv2_en-us.pdf",
        "body": "In the IWbtcPoolBase contract, when the Controller role calls the deposit function, the deposit_wbtc_amount parameter will increase, but when the Controller role calls the withdraw function, the deposit_wbtc_amount parameter does not decrease accordingly. And the withdraw_wbtc_amount parameter in the contract is not used. 16 The deposit_eth_amount and withdraw_eth_amount parameters in the IETHPoolBase contract are the same. The deposit_usdc_amount and withdraw_usdc_amount parameters in the IUSDCPoolBase contract are the same. ",
        "labels": [
            "SlowMist",
            "CFFv2",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing event record",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - CFFv2_en-us.pdf",
        "body": "In the IWbtcPoolBase contract, the owner can modify the controller and vault addresses through the setController function, but no event recording is performed. ",
        "labels": [
            "SlowMist",
            "CFFv2",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Logical redundancy issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - CFFv2_en-us.pdf",
        "body": "In the AavePool contract, the withdraw_from_curve function will rst authorize the lp_token_addr token to the pool_deposit contract and then call the remove_liquidity_one_coin function of the pool_deposit contract to remove liquidity. However, since the minter role of the lp_token_addr contract is the pool_deposit contract, there is no need to perform an approve operation. ",
        "labels": [
            "SlowMist",
            "CFFv2",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Reentrancy risk 20",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - CFFv2_en-us.pdf",
        "body": "In the CFVaultV2 contract, the user can withdraw assets through the withdraw function, but in the withdraw function, it will rst transfer the assets to the user and then destroy the user's credentials through the destroyTokens function. If the transfer is native tokens, this will lead to a risk of reentrancy. ",
        "labels": [
            "SlowMist",
            "CFFv2",
            "Type: Reentrancy Vulnerability",
            "Severity: Critical"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - CFFv2_en-us.pdf",
        "body": "In the IWbtcPoolBase, IETHPoolBase and IUSDCPoolBase contracts, the owner can call any data through the callWithData function. Since these strategies contracts indirectly keep the user's assets, any data call will cause the risk of excessive owner authority. ",
        "labels": [
            "SlowMist",
            "CFFv2",
            "Type: Authority Control Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - TaprootChain - BTCLayer2Bridge_en-us.pdf",
        "body": "1.In the BTCLayer2Bridge contract, the superAdmin role is initialized in the initialize function and can be modied in the setSuperAdminAddress function. The superAdmin can also set the normalAdmin role through the setNormalAdminAddress function. ",
        "labels": [
            "SlowMist",
            "TaprootChain - BTCLayer2Bridge",
            "Type: Authority Control Vulnerability Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Receive can lock users native tokens",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - TaprootChain - BTCLayer2Bridge_en-us.pdf",
        "body": "There is a receive function in the BTCLayer2Bridge contract so that the contracts can receive native tokens. However, the receive function can lock users native tokens when users transfer the native token in these contracts by mistake. And the payable modier can help these functions which need to call with the native tokens. ",
        "labels": [
            "SlowMist",
            "TaprootChain - BTCLayer2Bridge",
            "Type: Others",
            "Severity: Low"
        ]
    },
    {
        "title": "Parameter _symbol is not case checked",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - TaprootChain - BTCLayer2Bridge_en-us.pdf",
        "body": "The _symbol eld of ERC20 tokens and ERC721 tokens on the Ethereum chain is case-sensitive, but for BRC20 Tick is not case-sensitive. In the BTCLayer2Bridge contract, the addERC20TokenWrapped function and the addERC721TokenWrapped function do not standardize the case format of the _symbol parameter passed in. ",
        "labels": [
            "SlowMist",
            "TaprootChain - BTCLayer2Bridge",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Delete the address without popping up the list",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - TaprootChain - BTCLayer2Bridge_en-us.pdf",
        "body": "In the addUnlockTokenAdminAddress function, the superAdmin and normalAdmin roles can add user address into the unlockTokenAdminAddressList and set the unlockTokenAdminAddressSupported to true. But in the delUnlockTokenAdminAddress function, the superAdmin and normalAdmin roles remove the unlockTokenAdminAddress just by setting the unlockTokenAdminAddressSupported to false without popping up from the unlockTokenAdminAddressList . Once called the delUnlockTokenAdminAddress function deletes the address, the superAdmin and normalAdmin roles can call the addUnlockTokenAdminAddress function to add the same address added before into the unlockTokenAdminAddressList and the length of the unlockTokenAdminAddressList will increase. ",
        "labels": [
            "SlowMist",
            "TaprootChain - BTCLayer2Bridge",
            "Type: Design Logic Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "SuperAdmin Transfer Recommendations",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - TaprootChain - BTCLayer2Bridge_en-us.pdf",
        "body": "In the BTCLayer2Bridge contract, superAdmin directly overwrites the previous address with the new address during transfer. If superAdmin calls the setSuperAdminAddress function with the wrong address when the operation is wrong, this will result in the loss of the superAdmin role permissions. ",
        "labels": [
            "SlowMist",
            "TaprootChain - BTCLayer2Bridge",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Low-level call reminder",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - TaprootChain - BTCLayer2Bridge_en-us.pdf",
        "body": "In the BTCLayer2Bridge contract, the burnERC20Token, batchBurnERC721Token, lockNativeToken, and unlockNativeToken use low-level calls to transfer native tokens to the feeAddress and to address from the unlockNativeToken function. But do not limit the amount of gas used to transfer native tokens to the user. ",
        "labels": [
            "SlowMist",
            "TaprootChain - BTCLayer2Bridge",
            "Type: Reentrancy Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Preemptive Initialization",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - TaprootChain - BTCLayer2Bridge_en-us.pdf",
        "body": "By calling the initialize and deploy functions to initialize the contracts, there is a potential issue that malicious attackers preemptively call the initialize function to initialize. ",
        "labels": [
            "SlowMist",
            "TaprootChain - BTCLayer2Bridge",
            "Type: Race Conditions Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Dev address setting enhancement suggestions",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - TaprootChain - BTCLayer2Bridge_en-us.pdf",
        "body": "In the contract, the superAdmin role can set the feeAddress to receive the fee. If the addfeeAddress is an EOA address, in a scenario where the private keys are leaked, the teams revenue will be stolen. ",
        "labels": [
            "SlowMist",
            "TaprootChain - BTCLayer2Bridge",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "External call reminder",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - TaprootChain - BTCLayer2Bridge_en-us.pdf",
        "body": "In the contract, the core functions mintERC20Token , burnERC20Token , batchMintERC721Token , batchBurnERC721Token , unlockNativeToken , and lockNativeToken , which are mainly used for fund interaction by unlockTokenAdminAddressSupported users, are all completed by external calls to bridgeERC20Address and bridgeERC721Address. The current contract also does complete verication of the incoming parameters txHash , _symbol , _baseURI , destBtcAddr , inscriptionNumbers , inscriptionIds , etc., and these verications may be completed by a centralized system or these external call contracts. This audit does not include centralized systems or external call contracts. Users need to pay attention to these external risks when calling these functions.",
        "labels": [
            "SlowMist",
            "TaprootChain - BTCLayer2Bridge",
            "Type: Unsafe External Call Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Excessive Authority Issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - wault.finance(WSwap)_en-us.pdf",
        "body": "The owner can set the value of wexPerBlock arbitrarily, which will affect the profit of wexReward, and there is no limit on the value range of wexPerBlock, and there is a issue of excessive authority. https://bscscan.com/address/0x22fB2663C7ca71Adc2cc99481C77Aaf21E152e2D function setWexPerBlock(uint256 _wexPerBlock) public onlyOwner { require(_wexPerBlock > 0, \"!wexPerBlock-0\"); wexPerBlock = _wexPerBlock; } Owner can add pool, can set the allocPoint of pool, there is a issue of selfish mining. function add( uint256 _allocPoint, IERC20 _lpToken, bool _withUpdate ) public onlyOwner { if (_withUpdate) { massUpdatePools(); } uint256 lastRewardBlock = block.number > startBlock ? block.number : startBlock; totalAllocPoint = totalAllocPoint.add(_allocPoint); poolInfo.push( PoolInfo({ lpToken: _lpToken, allocPoint: _allocPoint, lastRewardBlock: lastRewardBlock, accWexPerShare: 0 }) ); 12 function set( uint256 _pid, uint256 _allocPoint, bool _withUpdate ) public onlyOwner { if (_withUpdate) { massUpdatePools(); } totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add( _allocPoint ); poolInfo[_pid].allocPoint = _allocPoint; }",
        "labels": [
            "SlowMist",
            "wault.finance(WSwap)",
            "Type: Others",
            "Severity: Low"
        ]
    },
    {
        "title": "Ignoring the Return Value",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist_Audit_Report_StakeStone_SymbioticDepositWBETHStrategy_en-us.pdf",
        "body": "In the SymbioticDepositWBETHStrategy contract, the owner can extract the claimable ETH by calling the claimPendingAssets function. This function will call the claimWithdraw function of the UnwrapTokenV1ETH contract to claim the corresponding ETH by passing in a specic index. The claimWithDraw function returns a value (_ethAmount) after each call to represent the number of ETH claimed. Code Location: contracts/strategies/SymbioticDepositWBETHStrategy.sol#L176 function claimPendingAssets(uint256 _index) external onlyOwner { IUnwrapTokenV1ETH(unwrapTokenV1ETHAddr).claimWithdraw(_index); }",
        "labels": [
            "SlowMist",
            "SlowMist_Audit_Report_StakeStone_SymbioticDepositWBETHStrategy",
            "Type: Others",
            "Severity: Information"
        ]
    },
    {
        "title": "Unable to perform uniswapV3FlashCallback operation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn ETH Flashloan Leverage Staking - SlowMist Audit Report.pdf",
        "body": "In LeverageStake contracts, the uniswapV3FlashCallback function is called by the Uniswap v3 Pool ash function. It will call the repayBorrow/withdraw/deposit function within the LeverageStake contract to interact with the AAVE. However, the repayBorrow/withdraw/deposit function uses _checkTx for permission checking and can only be called by the admin role. This will result in the Uniswap v3 Pool not being able to call back to the uniswapV3FlashCallback function properly. ",
        "labels": [
            "SlowMist",
            "DeSyn ETH Flashloan Leverage Staking - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Potential liquidation risk caused by unrestricted ash loan leverage",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn ETH Flashloan Leverage Staking - SlowMist Audit Report.pdf",
        "body": "In LeverageStake contracts, the user can ashloan from the Uniswap v3 Pool with the function createLeverByFlashloan in order to make deposits in AAVE for higher prots. Unfortunately the increaseLeverByFlashloan function does not check the amount of leverage on the current bPool debt. This allows a malicious caller to increase the leverage of the bPool with the increaseLeverByFlashloan function to bring the user's funds closer to the liquidation line. This puts the user's funds at risk of liquidation when the stETH price uctuates. ",
        "labels": [
            "SlowMist",
            "DeSyn ETH Flashloan Leverage Staking - SlowMist Audit Report",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Flashloan function missing privilege control",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn ETH Flashloan Leverage Staking - SlowMist Audit Report.pdf",
        "body": "In the LeverageStake contract, any user can call the increaseLeverByFlashloan/decreaseLeverByFlashloan function. Malicious users can consume bPool funds through frequent calls, for example: exchange slippage leads to capital damage, frequent entry/exit of the AAVE pool leads to losses in fees, and frequent ash loans lead to losses in ash loan fees. Although this consumes gas for the malicious caller, it can reduce losses or even make a prot by arbitraging in the Curve Pool or providing liquidity in the Uniswap Pool. ",
        "labels": [
            "SlowMist",
            "DeSyn ETH Flashloan Leverage Staking - SlowMist Audit Report",
            "Type: Authority Control Vulnerability Audit",
            "Severity: High"
        ]
    },
    {
        "title": "Allowing the free choice of isTrade leads to a potential risk of arbitrage",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn ETH Flashloan Leverage Staking - SlowMist Audit Report.pdf",
        "body": "The increaseLever/increaseLeverByFlashloan/convertToAstEth functions of the LeverageStake contract allow the user to freely choose whether or not to exchange ETH-stETH through the Curve Pool by passing in the isTrade parameter. Even though the contract has a slippage check via the defaultSlippage parameter, the user still has an arbitrage prot. ",
        "labels": [
            "SlowMist",
            "DeSyn ETH Flashloan Leverage Staking - SlowMist Audit Report",
            "Type: Reordering Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Allow any type of ETF to interact with AAVE",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/DeSyn ETH Flashloan Leverage Staking - SlowMist Audit Report.pdf",
        "body": "In the _checkTx function of the LeverageStake contract, it uses if conditions to check the status of the ETF, which means that both open and closed ETFs can interact with AAVE. And for closed ETFs, it will no longer check whether the closed period of the pool has ended. This is dierent from the previous version's implementation. ",
        "labels": [
            "SlowMist",
            "DeSyn ETH Flashloan Leverage Staking - SlowMist Audit Report",
            "Type: Others",
            "Severity: Information"
        ]
    },
    {
        "title": "Risk of unintended claim operations",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - pufETH_en-us.pdf",
        "body": "In the PuerVault contract, Users can collect ETH tokens to be claimed in the lido withdrawal process by calling the claimWithdrawalsFromLido function. The normal expectation of this function is that the incoming requestIds parameter should be created by the initiateETHWithdrawalsFromLido function, and only then the lidoLockedETH variable will be deducted correctly. However, a malicious user can directly call requestWithdrawals function in lido to generate requestIds, and then call claimWithdrawalsFromLido function, lidoLockedETH will be deducted additionally, resulting in a normal claim operation failing due to insucient lidoLockedETH. The following scenarios can be used as a reference: 1. The contract has a total of 10 ETH total deposited in Lido, at which point a normal user calls the initiateETHWithdrawalsFromLido function to submit a request to withdraw 10 ETH($.lidoLockedETH = 10). 2. A malicious user calls requestWithdrawals function directly on Lido to generate a withdrawal request to withdraw 1 ETH(need to specify WithdrawalRequest._owner as puerVault). 3. The malicious user calls the claimWithdrawalsFromLido function and passes in the requestIds generated in step 2, the value of $.lidoLockedETH is equal to 9. 4. A normal user calls the claimWithdrawalsFromLido function and passes in the requestIds generated in the rst step, at which point the amount of ETH to be fetched is 10, while the value of $.lidoLockedETH is 9, which causes $.lidoLockedETH -= msg.value to overow and the entire transaction fails. 5. So the nal result is that 10 ETH cannot be successfully withdrawn through the puerVault contract. And this security risk also exists when withdrawing ETH from EigenLayer(Specify withdrawer as the puerVault address to achieve the same eect). ",
        "labels": [
            "SlowMist",
            "pufETH",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Authority transfer enhancement",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - pufETH_en-us.pdf",
        "body": "The pauserMultisig role does not adopt the pending and access processes. If the pauserMultisig is incorrectly set, the owner permission will be lost. ",
        "labels": [
            "SlowMist",
            "pufETH",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Gas optimization",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Laqira NFT marketplace_en-us.pdf",
        "body": "Using assert will consume the remaining gas when the transaction fails to execute. ",
        "labels": [
            "SlowMist",
            "Laqira NFT marketplace",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Unused return",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Laqira NFT marketplace_en-us.pdf",
        "body": "There is a return value in the setRoyalties function in the RoyaltiesProvider contract, and the function is called here without checking its return value. Laqira-Collectibles-and-NFT-Marketplace/contracts/LaqiraNFT.sol #L58-L76 function mint(string memory _tokenURI, address[] memory royaltyOwners, uint96[] memory values) public virtual payable { uint256 transferredAmount = msg.value; require(transferredAmount >= mintingFee, 'Insufficient paid amount'); (bool success, ) = feeAddress.call{value: transferredAmount}(new bytes(0)); 14 require(success, 'Transfer failed'); _tokenIds.increment(); uint256 newTokenId = _tokenIds.current(); pendingRequests.push(newTokenId); _pendingIds[newTokenId].owner = _msgSender(); _pendingIds[newTokenId].tokenURI = _tokenURI; _userPendingIds[_msgSender()].push(newTokenId); IRoyaltiesProvider(royaltiesProviderAddress).setRoyalties(newTokenId, royaltyOwners, values); }",
        "labels": [
            "SlowMist",
            "Laqira NFT marketplace",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing event record",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Laqira NFT marketplace_en-us.pdf",
        "body": "Modifying sensitive parameters in the contract does not log an event. Laqira-Collectibles-and-NFT-Marketplace/contracts/LaqiraNFT.sol #L123-L133 function setMintingFeeAmount(uint256 _amount) public virtual onlyOwner { mintingFee = _amount; } function setAsOperator(address _operator) public virtual onlyOwner { operators[_operator] = true; } function removeOperator(address _operator) public virtual onlyOwner { operators[_operator] = false; } 15 ",
        "labels": [
            "SlowMist",
            "Laqira NFT marketplace",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Missing zero address validation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Laqira NFT marketplace_en-us.pdf",
        "body": "Missing zero address validation when setting the address in the function. ",
        "labels": [
            "SlowMist",
            "Laqira NFT marketplace",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Redundant code",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - IHO V1.0.0_en-us.pdf",
        "body": "Ether is not accepted by default, which is a redundant code. cross-send/contracts/CrossSend.sol#L41-L47 initial-hotcross-oering/contracts/BaseIHO.sol#L67-L73 fallback () external payable { revert(\"cannot directly accept currency transfers\"); } receive () external payable { revert(\"cannot directly receive currency transfers\"); 15 }",
        "labels": [
            "SlowMist",
            "IHO V1.0.0",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Gas optimization",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - IHO V1.0.0_en-us.pdf",
        "body": "If one of the batch transfers fails, the transaction that was previously transferred normally will be reverted, but Gas has been consumed. It is a gas optimization issue here. cross-send/contracts/CrossSend.sol#L175-L210 function sendToken( IERC20 token, address[] memory recipients, uint256[] memory amounts ) private returns(uint256) { uint256 total = 0; for (uint256 i = 0; i < recipients.length ; i++) { require(_msgSender() != recipients[i], \"sender != recipient\"); token.safeTransferFrom(_msgSender(), recipients[i], amounts[i]); total += amounts[i]; } return total; } function sendNative( address[] memory recipients, uint256[] memory amounts ) private returns(uint256) { uint256 total = 0; 16 for (uint256 i = 0; i < recipients.length ; i++) { total += amounts[i]; (bool success, ) = payable(recipients[i]).call{value: amounts[i]}(\"\"); require(success, \"native transfer failed\"); } return total; }",
        "labels": [
            "SlowMist",
            "IHO V1.0.0",
            "Type: Gas Optimization Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of allowance amount abuse",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - IHO V1.0.0_en-us.pdf",
        "body": "There have an allowance amount in the contract, but the distributeTokenFee function does not limit the caller, and there is an issue of being called arbitrarily, but it can only transfer the balance of the sender to the feeCollector. cross-send/contracts/fee-managers/RecipientCountFee.sol#L65-L83 function distributeTokenFee( uint256 txRecipientCount, uint256, uint256, uint256, uint256, address sender ) public override { uint256 payableFee = txRecipientCount * tokenFeePerRecipient; 17 if(payableFee < minTokenFee) { payableFee = minTokenFee; } else if (payableFee > maxTokenFee) { payableFee = maxTokenFee; } token.safeTransferFrom(sender, feeCollector, payableFee); }",
        "labels": [
            "SlowMist",
            "IHO V1.0.0",
            "Type: Authority Control Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Price manipulation issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - IHO V1.0.0_en-us.pdf",
        "body": "The IOUPrice is calculated using totalFarmingTokenBalance. Attackers can control totalFarmingTokenBalance to manipulate IOUPrice. The current code does not nd the location where IOUPrice is used. Referencehttps://slowmist.medium.com/cream-hacked-analysis-us-130-million-hacked-95c9410320ca cross-yield/contracts/core/CrossYield.sol#L95-L101 function IOUPrice() public view returns (uint256) { uint256 IOUSupply = totalSupply(); return IOUSupply == 0 ? 1e18 : (totalFarmingTokenBalance() * 1e18) / IOUSupply; } 18 cross-yield/contracts/core/CrossYield.sol#L65-L67 function totalFarmingTokenBalance() public view returns (uint256) { return farmingToken().balanceOf(address(this)) + strategy.balanceOf(); }",
        "labels": [
            "SlowMist",
            "IHO V1.0.0",
            "Type: Others",
            "Severity: Medium"
        ]
    },
    {
        "title": "Sandwich attacks issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - IHO V1.0.0_en-us.pdf",
        "body": "There is no slippage check during swap, and there is a risk of sandwich attack. IPancakeRouter02(pcsRouter).swapExactTokensForTokens(cakeBalance, 0,cakeToBaseRoute, address(this), block.timestamp); IPancakeRouter02(pcsRouter) .swapExactTokensForTokens(toSwap, 0, route, address(this), block.timestamp); Reference https://medium.com/coinmonks/demystify-the-dark-forest-on-ethereum-sandwich-attacks-5a3aec9fa33e cross-yield/contracts/libs/OptimalSwap.sol#L14-L63 function prepareLiquidity( address cake, address[2] memory lpTokens, 19 address wbnb, address busd, address farmingToken, address pcsRouter, uint256 fee ) external { uint256 cakeBalance = IERC20(cake).balanceOf(address(this)); bool isCakeInLp = lpTokens[0] == cake || lpTokens[1] == cake; bool isWbnbBased = lpTokens[0] == wbnb || lpTokens[1] == wbnb; address baseToken = isWbnbBased ? wbnb : busd; // if cake is not part of the lp token, swap all cake for the base token if (!isCakeInLp) { address[] memory cakeToBaseRoute = new address[](2); cakeToBaseRoute[0] = cake; cakeToBaseRoute[1] = baseToken; IPancakeRouter02(pcsRouter) .swapExactTokensForTokens(cakeBalance, 0, cakeToBaseRoute, address(this), block.timestamp); } (uint256 reserve0, uint256 reserve1,) = IPancakePair(farmingToken).getReserves(); address[] memory route = new address[](2); uint256 lp0Bal = IERC20(lpTokens[0]).balanceOf(address(this)); uint256 lp1Bal = IERC20(lpTokens[1]).balanceOf(address(this)); uint256 toSwap; // The possible cases here are: // - Cake was not part of the LP token, so we swap for baseToken which could either be lpToken0 or lpToken // - Cake was part of the LP token, so it can either be lpTokens[0] or lpTokens[1] // So, depending on which token we have the highest balance for, we swap for the other one. if (lp0Bal > lp1Bal) { toSwap = SwapAmount.getSwapAmount(lp0Bal, reserve0, fee); route[0] = lpTokens[0]; route[1] = lpTokens[1]; } else { toSwap = SwapAmount.getSwapAmount(lp1Bal, reserve1, fee); route[0] = lpTokens[1]; route[1] = lpTokens[0]; 20 } // Perform the swap IPancakeRouter02(pcsRouter) .swapExactTokensForTokens(toSwap, 0, route, address(this), block.timestamp); } IPancakeRouter02(pcsRouter).swapExactTokensForTokens(toWbnb, 0, cakeToWbnbRoute, address(this), block.timestamp); cross-yield/contracts/strategies/StrategyCake.sol#L131 function collectFees() internal { // a percentant of the cake we get from the masterchef will be used to buy BNB and transfer to this address // this is the total fees that will be shared amongst the protocol, stategy dev and the harvester uint256 toWbnb = feeManager.calculateTotalFee(IERC20(farmingToken).balanceOf(address(this))); IPancakeRouter02(pcsRouter).swapExactTokensForTokens(toWbnb, 0, cakeToWbnbRoute, address(this), block.timestamp); uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this)); // distribute hervester fee uint256 harvesterFeeAmount = feeManager.calculateHarvestFee(wbnbBal); // collectFees is called indirectly from the CrossYield contract via the beforeDeposit hook. // This means that _msgSender() is the CrossYield contract and not the actuall EOA account // that send the transaction IERC20(wbnb).safeTransfer(tx.origin, harvesterFeeAmount); // distribute protocol fee uint256 protocolFeeAmount = feeManager.calculateProtocolFee(wbnbBal); // IERC20(wbnb).safeTransfer(protocolFeeRecipient, protocolFeeAmount); feeProcessor.process(protocolFeeAmount); // distribute strategy dev fee uint256 strategyDevFeeAmount = feeManager.calculateStrategyDevFee(wbnbBal); IERC20(wbnb).safeTransfer(feeManager.strategyDev(), strategyDevFeeAmount); emit FeeCollected( toWbnb, 21 harvesterFeeAmount, protocolFeeAmount, strategyDevFeeAmount, _msgSender() ); } cross-yield/contracts/strategies/StrategyCakeLP.sol#L174 function collectFees() internal { // a percentant of the cake we get from the masterchef will be used to buy BNB and transfer to this address // this is the total fees that will be shared amongst the protocol, stategy dev and the harvester uint256 toWbnb = feeManager.calculateTotalFee(IERC20(cake).balanceOf(address(this))); IPancakeRouter02(pcsRouter).swapExactTokensForTokens(toWbnb, 0, cakeToWbnbRoute, address(this), block.timestamp); uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this)); // distribute hervester fee uint256 harvesterFeeAmount = feeManager.calculateHarvestFee(wbnbBal); IERC20(wbnb).safeTransfer(_msgSender(), harvesterFeeAmount); // distribute protocol fee uint256 protocolFeeAmount = feeManager.calculateProtocolFee(wbnbBal); feeProcessor.process(protocolFeeAmount); // distribute strategy dev fee uint256 strategyDevFeeAmount = feeManager.calculateStrategyDevFee(wbnbBal); IERC20(wbnb).safeTransfer(feeManager.strategyDev(), strategyDevFeeAmount); emit FeeCollected( toWbnb, harvesterFeeAmount, protocolFeeAmount, strategyDevFeeAmount, _msgSender() ); } cross-yield/contracts/strategies/StrategyCake.sol 22 function harvest() public override whenNotPaused { // claim rewards IMasterChef(masterchef).leaveStaking(0); // because harvest can automatically be called after each user deposit // we might end up having multiple deposits in the same block and only one // would return rewards from masterchef so the rest will have 0 cake so // we don't need to waste gas to collect fees and call deposit uint256 farmingTokenBalance = balanceOfFarmingToken(); if(farmingTokenBalance > 0) { collectFees(); deposit(); emit HarvestTriggered(_msgSender(), farmingTokenBalance); } } cross-yield/contracts/strategies/StrategyCakeLP.sol#l137-L148 function harvest() external override whenNotPaused { // claim rewards IMasterChef(masterchef).deposit(poolId, 0); uint256 harvestedAmount = IERC20(cake).balanceOf(address(this)); collectFees(); addLiquidity(); deposit(); emit HarvestTriggered(_msgSender(), harvestedAmount); }",
        "labels": [
            "SlowMist",
            "IHO V1.0.0",
            "Type: Reordering Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Missing slippage check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - IHO V1.0.0_en-us.pdf",
        "body": "The addLiquidity function without slippage check, it doesn't have an impermanent loss check. cross-yield/contracts/strategies/StrategyCakeLP.sol#L218 function addLiquidity() internal { OptimalSwap.prepareLiquidity( cake, [lpToken0, lpToken1], wbnb, busd, farmingToken, pcsRouter, swapFee ); // add liquidity to AMM on PCS uint256 lp0Bal = IERC20(lpToken0).balanceOf(address(this)); uint256 lp1Bal = IERC20(lpToken1).balanceOf(address(this)); IPancakeRouter02(pcsRouter) .addLiquidity(lpToken0, lpToken1, lp0Bal, lp1Bal, 0, 0, address(this), block.timestamp); emit LiquidityAdded(lpToken0, lpToken1, lp0Bal, lp1Bal, _msgSender()); }",
        "labels": [
            "SlowMist",
            "IHO V1.0.0",
            "Type: Reordering Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Permission check Missing",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - IHO V1.0.0_en-us.pdf",
        "body": "There is no permission check for deposit function. The function is called by the CrossYieid contract. cross-yield/contracts/strategies/StrategyCakeLP.sol#L225-L231 function deposit() public override whenNotPaused { uint256 farmingTokenBalance = balanceOfFarmingToken(); if (farmingTokenBalance > 0) { IMasterChef(masterchef).deposit(poolId, farmingTokenBalance); } } cross-yield/contracts/strategies/StrategyCake.sol#L169-L175 function deposit() public override whenNotPaused { uint256 farmingTokenBalance = balanceOfFarmingToken(); if (farmingTokenBalance > 0) { IMasterChef(masterchef).enterStaking(farmingTokenBalance); } }",
        "labels": [
            "SlowMist",
            "IHO V1.0.0",
            "Type: Authority Control Vulnerability",
            "Severity: Low"
        ]
    },
    {
        "title": "Excessive authority issue 25",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - IHO V1.0.0_en-us.pdf",
        "body": "Owner can modify the address of the strategy. The new strategy may have security risks if it is not audited, which will aect the user's funds. If the private key is leaked, it will aect the user's funds. cross-yield/contracts/core/CrossYield.sol#L224-L236 function upgradeStrategy() public onlyOwner { require(stratCandidate.strategy != address(0), \"No proposal exists\"); require(block.number > stratCandidate.proposedBlock + stratUpgradableAfter, \"Strategy cannot be replaced yet\"); emit NewStrategy(stratCandidate.strategy); strategy.retireStrategy(); strategy = IStrategy(stratCandidate.strategy); stratCandidate.strategy = address(0); stratCandidate.proposedBlock = 0; putFundsToWork(); } cross-yield/contracts/core/CrossYield.sol#L211-L220 function proposeStrategy(address _strategy) public onlyOwner { require(address(this) == IStrategy(_strategy).vault(), \"Invalid new strategy\"); stratCandidate = StrategyCandidate({ strategy: _strategy, proposedBlock: block.number }); emit NewStratCandidate(_strategy); }",
        "labels": [
            "SlowMist",
            "IHO V1.0.0",
            "Type: Authority Control Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Repeatable claims issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - IHO V1.0.0_en-us.pdf",
        "body": "After the claim, lottery.status is not set as claimed, and it is also necessary to check whether lotteryId has been claimed when the claim is executed. hotdrop/contracts/HotDrop.sol#L261-L274 function claim(uint256 lotteryId) external nonReentrant { Lottery storage lottery = lotteries[lotteryId]; require(lottery.status == Status.WinnerDrawn, \"winner not drawn\"); // if there is no winner transfer the total amount to the treasury if(tickets[lotteryId][lottery.winningNumber] == address(0)) { lottery.purchaseToken.safeTransfer(treasury, lottery.purchaseToken.balanceOf(address(this))); } else if(tickets[lotteryId][lottery.winningNumber] == _msgSender()) { // if the ticket is the winning ticket and belongs to the user then split the pot uint256 treasuryAmount = (lottery.totalRaised * lottery.treasuryFee) / FEE_BASE; lottery.purchaseToken.safeTransfer(treasury, treasuryAmount); lottery.purchaseToken.safeTransfer(_msgSender(), lottery.totalRaised - treasuryAmount); } }",
        "labels": [
            "SlowMist",
            "IHO V1.0.0",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Round plan security reminder",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - IHO V1.0.0_en-us.pdf",
        "body": "And the new round of lottery can only be opened when the last round of lottery is in WinnerDrawn, otherwise randomGenerator.latestLotteryId will be updated, which will cause the old lottery round to fail to execute drawWinner function due to this check. require(lotteryId == randomGenerator.latestLotteryId(), \"numbers not drawn\"); hotdrop/contracts/HotDrop.sol#L44-L256 function drawWinner(uint256 lotteryId) external nonReentrant { Lottery storage lottery = lotteries[lotteryId]; require(lottery.status == Status.Close, \"lottery still active\"); require(lotteryId == randomGenerator.latestLotteryId(), \"numbers not drawn\"); // get the winning number based on the randomResult generated by ChainLink's fallback uint256 winningNumber = randomGenerator.randomResult(); lottery.winningNumber = winningNumber; lottery.status = Status.WinnerDrawn; emit LotteryNumberDrawn(lotteryId, winningNumber); }",
        "labels": [
            "SlowMist",
            "IHO V1.0.0",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Deposit defect issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "In the EFVault contract, it is not restricted to call the deposit function only by the DepositApprover contract. If the user transfers funds to the EFVault contract by mistake, any user can call the deposit function to deposit for himself. 19 ",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Incorrect withdrawal amount check",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "In the vault contract, users can withdraw funds through the withdraw function. It will check if the funds withdrawn by the user is less than the user's total deposit, but this will prevent the user from withdrawing all of their total deposit. ",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Risk of overburning shares",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "In the vault contract, users can burn their shares to withdraw funds through the withdraw function. However, when calculating the required burning share, it incorrectly divides the user's total deposit. This will cause the number of shares to be burned to be much larger than expected. ",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Small deposit issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "When a user makes a deposit, the vault contract will deposit the user's funds into the strategy pool and then mint the 21 corresponding share to the user. If the total deposit of the contract is very large at this time, when the user deposits a small amount of funds, the nal result of the division operation will be 0 when the amount is too small when withdrawing. Causes the problem that small assets cannot be withdrawn.",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "The deationary token issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "In the DepositApprover contract, the amount of the deposit is the amount passed in by the user. If the tokens supported by the protocol become deationary tokens in the future (for example, USDT enables the transfer fee function), this will cause the actual number of tokens received by the protocol to be inconsistent with the number of dedicated incoming tokens. The same is true for Controller and SS contracts. ",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Risk of share manipulation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "When the user deposits in the agreement, the contract will mint the corresponding share to the user, and when the user withdraws, the corresponding share will be burned. The totalAssets function is used to participate in the calculation when calculating the share, and in the SS contract of the convex, the totalAssets are obtained through the calc_withdraw_one_coin function of the Curve Pool. However, the calc_withdraw_one_coin function is vulnerable to the balance in the Curve Pool, so malicious users can manipulate the calc_withdraw_one_coin function to aect the number of shares minted by the contract. ",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Missing event records 23",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "In the vault contract, the owner can modify the maxDeposit, maxWithdraw, controller and depositApprover parameters through the setMaxDeposit, setMaxWithdraw, setController and setDepositApprover functions respectively. But event logging is not used. In the Controller contract, the owner can modify the vault, apySort, treasury, exchange, withdrawFee, defaultDepositSS and isDefault parameters through the setVault, setAPYSort, setTreasury, setExchange, setWithdrawFee, setDefaultDepositSS and setDefaultOption functions. But event logging is not used. In the contracts under the exchanges folder, the owner can set the exchange contract address through the setExchange function. But event logging is not used. In the contracts under the subStrategies/convex folder, the owner can modify the controller, depositSlippage, pId, lpToken, curvePool, harvestGap, maxDeposit, rewardTokens parameters through the setController, setDepositSlippage, setWithdrawSlippage, setPoolId, setLPToken, setCurvePool, setHarvestGap, setMaxDeposit, addRewardToken and removeRewardToken functions. But event logging is not used. In the cusdc contract, the owner can modify the controller, depositSlippage, withdrawSlippage, harvestGap and maxDeposit parameters through the setController, setDepositSlippage, setWithdrawSlippage, setHarvestGap and setMaxDeposit functions. But event logging is not used. ",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "AllocPoint deposit issue 28",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "In the Controller contract, deposits are made according to the allocPoint of each SS, which calculates the number of tokens transferred to each SS through the following algorithm amountForSS = (_amount * subStrategies[i].allocPoint) / totalAllocPoint; However, due to the loss of precision in the division calculation, a small amount of funds cannot be transferred into SS. ",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "check withdrawal amount issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "After the Controller contract withdraws from SS, it will check whether withdrawAmt is greater than 0. But since the protocol will havest periodically, theoretically withdrawAmt should be greater than or equal to the _amount parameter passed in by the user. ",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Risks of fake routers",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "In the Controller contract, the owner role can compound interest through the harvest function. However, it is not checked whether the router list passed in by owner is as expected. If an unexpected router is passed in, it may lead to failure to harvest normally or loss of funds. ",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Loss of computational precision",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "In the vault contract, the convertToAssets function is used to convert shares to corresponding asset amounts. 31 However, it performs the calculation by performing the division operation rst and then the multiplication operation, which will result in loss of calculation accuracy. ",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Risks of strict equality checks",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "In Convex's SS contract, when the user makes a withdrawal, it is checked whether the LP balance of the current contract is strictly equal to the LP amount required by the user. If a malicious user intentionally transfers any amount of LP tokens to the current contract, this will cause the SS contract to become unusable. ",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Design Logic Audit",
            "Severity: Critical"
        ]
    },
    {
        "title": "Negative number check issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "In the Cusdc contract, the _totalAssets function is used to obtain the total collateralized assets. It is calculated by multiplying the number of nTokens held by the protocol by the price of nTokens and dividing the total supply of nTokens. The price of nToken is obtained through the getPresentValueUnderlyingDenominated function, but the return value of the getPresentValueUnderlyingDenominated function is int256, while the return value of the INusdc interface is dened as uint256. If it returns a negative number, it will overow. ",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "In the Controller contract, the owner can set allocation point of a sub strategy, register the substrategies to the controller contract and withdraw the assets from one SS and deposit to other SS. This will have an impact on the user's deposit and withdrawal operations. ",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Authority Control Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Code redundancy issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "In the vault contract, the convertToShares function is dened, but it is not actually used in the contract. ",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Invalid minimum output calculation",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "In the SS contract, the calc_token_amount function will be used to calculate the minimum amount of LP tokens received during the deposit operation; the minimum amount of staking tokens received will be calculated through the calc_withdraw_one_coin function during the withdrawal operation. However, the calc_token_amount function and the calc_withdraw_one_coin function are easily aected by the last transaction of CurvePool, so they cannot play the role of slippage protection. Lusd and Tri contracts also have slippage issue, but the slippage check is annotated in the deposit function. ",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Risk of pid acquisition",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "In the Alusd contract, the getPID function user obtains the corresponding LP pool address in the ConvexBooster contract. It will return 0 if LpToken does not exist, but pid0 has a value in the ConvexBooster contract. So when getPID returns 0, it will be hard to tell if pid exists. 37 ",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Design Logic Audit",
            "Severity: Low"
        ]
    },
    {
        "title": "Redundant approval issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "In the swapExactTokenInput function of the Exchange contract, it will rst transfer the tokens that need to be swapped from the controller contract to the router contract. But the swapExactTokenInput function approves the router contract again, which is unnecessary. ",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Others",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Incorrect storage of temporary variables",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "In the router contract, the removePath function is used to remove the swap path recorded in the contract. It will rst store the balancerBatchAssets variable through storage, then delete it, and then use this variable for event recording after deletion. ",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Compound interest slippage check issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "In the router contract, no slippage check is performed during the swap operation. If there are more funds with compound interest, there will be a risk of being attacked by sandwiches. ",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Design Logic Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Lack of access control",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Earning.Farm v3_en-us.pdf",
        "body": "The swap function in the UniswapV3 contract is not subject to permission control, which will allow any user to call it. ",
        "labels": [
            "SlowMist",
            "Earning.Farm v3",
            "Type: Authority Control Vulnerability",
            "Severity: Medium"
        ]
    },
    {
        "title": "Analyzing inaccuracies in reward calculation due to time span misalignment",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Lumiterra Community Contracts_en-us.pdf",
        "body": "contracts/UtilityStake.sol In the _calcClaimableAmount function, if di (the time elapsed since the last reward claim) exceeds timeoutClaimPeriod , then the result of the modulo operation diff % timeoutClaimPeriod , which yields claimD , will be less than the actual time span that should be considered. This leads to an inaccurate calculation of the reward amount. function _calcClaimableAmount( address staker ) internal view returns (uint256) { StakeInfo memory stakeInfo = stakeInfoByStaker[staker]; if (stakeInfo.stakedAmount == 0) { return 0; } if (stakeInfo.latestClaimedAt == 0) { return 0; } if (stakeInfo.latestClaimedAt > block.timestamp) { return 0; } if (totalStakeAmount == 0) { return 0; } if (rate == 0) { return 0; } uint256 diff = block.timestamp - stakeInfo.latestClaimedAt; uint256 claimD = diff % timeoutClaimPeriod; // Avoid delayed on-chain submissions resulting in zero rewards 0 if (diff == timeoutClaimPeriod) { claimD = timeoutClaimPeriod; } uint256 claimableAmount = Math.mulDiv( stakeInfo.stakedAmount * claimD, rate, totalStakeAmount, Math.Rounding.Zero ); return claimableAmount; }",
        "labels": [
            "SlowMist",
            "Lumiterra Community Contracts",
            "Type: Others",
            "Severity: Medium"
        ]
    },
    {
        "title": "Handling reward calculation issues and function restrictions in reward cycles",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Lumiterra Community Contracts_en-us.pdf",
        "body": "contracts/UtilityStake.sol Users will still be able to use the old rate to calculate rewards and collect them when the next cycle has not yet been set up. This also causes a problem. When there are not enough reward tokens in the pool, users can't use the unstake and stake functions. function _calcClaimableAmount( address staker ) internal view returns (uint256) { StakeInfo memory stakeInfo = stakeInfoByStaker[staker]; if (stakeInfo.stakedAmount == 0) { return 0; } if (stakeInfo.latestClaimedAt == 0) { return 0; } if (stakeInfo.latestClaimedAt > block.timestamp) { return 0; } if (totalStakeAmount == 0) { return 0; } if (rate == 0) { return 0; } uint256 diff = block.timestamp - stakeInfo.latestClaimedAt; uint256 claimD = diff % timeoutClaimPeriod; // Avoid delayed on-chain submissions resulting in zero rewards 0 if (diff == timeoutClaimPeriod) { claimD = timeoutClaimPeriod; } uint256 claimableAmount = Math.mulDiv( stakeInfo.stakedAmount * claimD, rate, totalStakeAmount, Math.Rounding.Zero ); return claimableAmount; }",
        "labels": [
            "SlowMist",
            "Lumiterra Community Contracts",
            "Type: Others",
            "Severity: High"
        ]
    },
    {
        "title": "Addressing overpayment risk in reward distribution due to rate update delays",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Lumiterra Community Contracts_en-us.pdf",
        "body": "contracts/UtilityStake.sol In the current reward mechanism, a signicant issue arises if users claim their rewards after an update to the reward rate. Specically, if a user claims rewards accrued before the rate update, the calculation will be based on the new, potentially higher rate, leading to an overestimation of their rightful reward. This overpayment can deplete the reward pool more rapidly than anticipated, potentially leaving insucient funds for later users. Consequently, this could impede the normal operation of unstake and stake functions, as the reward pool might not sustain the demands. function depositRewardToken(address token, uint256 amount) external { IUtilityToken rewardToken = config.getPRToken(); require(token == address(rewardToken), \"UtilityStake: invalid token\"); rewardToken.transferFrom(msg.sender, address(this), amount); if (block.timestamp >= periodFinish) { rate = amount / periodDuration; } else { uint256 remaining = periodFinish - block.timestamp; uint256 leftover = remaining * rate; rate = (amount + leftover) / periodDuration; } periodFinish = block.timestamp + periodDuration; emit DepositRewardToken(amount); }",
        "labels": [
            "SlowMist",
            "Lumiterra Community Contracts",
            "Type: Others",
            "Severity: Critical"
        ]
    },
    {
        "title": "Inaccuracies in reward calculation due to misuse of total supply in liquidity pool",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Lumiterra Community Contracts_en-us.pdf",
        "body": "contracts/LiquidityStake.sol In the _checkpoint function, the use of _sc2crvPool().totalSupply() for calculating rewards may lead to inaccuracies. This is because it utilizes the total supply of the entire liquidity pool, rather than the quantity of LP tokens controlled by the contract itself. Indeed, this approach can result in the calculation of rewards being less than what is rightfully due, consequently leading to users receiving fewer rewards than they are actually entitled to. function _checkpoint(address staker) internal { _metaGauge().claim_rewards(); StakeInfo memory stakeInfo = stakeInfoByStaker[staker]; uint256 totalSupplay = _sc2crvPool().totalSupply(); if (totalSupplay == 0) { return; } for (uint256 i = 0; i < MAX_REWARDS; i++) { address tokenAddress = _metaGauge().reward_tokens(i); if (tokenAddress == address(0)) { break; } uint256 dI = 0; uint256 tokenBalance = IERC20Metadata(tokenAddress).balanceOf( address(this) ); dI = (10 ** 18 * (tokenBalance - rewardBalances[tokenAddress])) / totalSupplay; rewardBalances[tokenAddress] = tokenBalance; // integral: uint256 = self.reward_integral[token] + dI uint256 integral = rewardIntegral[tokenAddress] + dI; if (dI != 0) { rewardIntegral[tokenAddress] = integral; } uint256 integralFor = rewardIntegralFor[tokenAddress][staker]; uint256 newClaimable = 0; if (integralFor < integral) { rewardIntegralFor[tokenAddress][staker] = integral; (stakeInfo.totalSC2CRVLP * ((integral - integralFor))) / PRICE_PRECISION; } uint256 claimData = claimDataByStaker[staker][tokenAddress]; uint256 totalClaimable = (claimData >> 128) + newClaimable; if (totalClaimable > 0) { uint256 totalClaimed = claimData % 2 ** 128; claimDataByStaker[staker][tokenAddress] = totalClaimed + (totalClaimable << 128); } } } }",
        "labels": [
            "SlowMist",
            "Lumiterra Community Contracts",
            "Type: Others",
            "Severity: Critical"
        ]
    },
    {
        "title": "Redundant logic in _setFloorPrice function of smart contract",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Lumiterra Community Contracts_en-us.pdf",
        "body": "contracts/PriceField.sol The else if (_floorPrice == 0) conditional branch in this function will not actually be executed. This is because _floorPrice is set to the new floorPrice_ before any conditional judgment is entered, and floorPrice_ cannot be zero, as veried at the beginning of the function. function _setFloorPrice(uint256 floorPrice_) internal { require(floorPrice_ >= PRICE_PRECISION / 2, \"floor price too low\"); require(floorPrice_ > _floorPrice, \"floor price too low\"); uint256 previousFloorPrice = _floorPrice; uint256 x3 = _config.getUtilityToken().totalSupply(); _floorPrice = floorPrice_; if (x3 > c()) { uint256 maxFloorPrice = (Math.mulDiv( x3 - c(), _slope, PRECENT_DENOMINATOR, Math.Rounding.Zero ) + PRICE_PRECISION) / 2; if (maxFloorPrice > floorPrice_) { _floorPrice = floorPrice_; } } else if (_floorPrice == 0) { //SLOWMIST//will not be implemented _floorPrice = floorPrice_; } else if (x3 > x1(floorPrice_) + _exerciseAmount) { _floorPrice = floorPrice_; } else if (x3 == 0) { _floorPrice = floorPrice_; } require(_floorPrice > previousFloorPrice, \"floor price too low\"); emit UpdateFloorPrice(_floorPrice); }",
        "labels": [
            "SlowMist",
            "Lumiterra Community Contracts",
            "Type: Others",
            "Severity: Low"
        ]
    },
    {
        "title": "Potential reentrancy risk in VAMM's _mintByPRToken function",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Lumiterra Community Contracts_en-us.pdf",
        "body": "contracts/VAMM.sol The payToken can be passed in arbitrarily from the outside, and if the payToken is a token that implements a callback function, then this call may trigger malicious code.An attacker can exploit this by calling the _mintByPRToken function again during the callback. Since the _mintByPRToken function calls payToken.transferFrom before updating _floorPrice and minting new tokens, a reentry attack could allow an attacker to mint tokens multiple times at the old, more favorable price, rather than at the updated price. This could lead to improper minting of assets. function _mintByPRToken( address payTokenAddress, uint256 mintAmount, uint256 maxPayAmount, address recipient ) internal { IERC20Metadata payToken = IERC20Metadata(payTokenAddress); IUtilityToken _utilityToken = _config.getUtilityToken(); IUtilityToken _prToken = _config.getPRToken(); require(_prToken.balanceOf(msg.sender) >= mintAmount, \"VAMM:mp0\"); require( _prToken.allowance(msg.sender, address(this)) >= mintAmount, \"VAMM:mp1\" ); (uint256 toLiquidityPrice, uint256 fees) = _priceField.getUseFPBuyPrice( mintAmount ); require(toLiquidityPrice + fees <= maxPayAmount, \"VAMM:mp2\"); // Include slippage as fee income fees = maxPayAmount - toLiquidityPrice; //SLOWMIST// uint256 maxPayAmountInPayToken = _convertPrice( maxPayAmount, payToken, true ); _priceField.increaseSupplyWithNoPriceImpact(mintAmount); require( payToken.transferFrom( msg.sender, address(this), maxPayAmountInPayToken ), \"VAMM:mp3\" );//The paytoken is an arbitrary token, so any worthless token can be used as the key to transfer money to the contract. // burn pr token _prToken.burnFrom(msg.sender, mintAmount); _collectFees(fees); /// mint token _totalLiquidity += toLiquidityPrice; _utilityToken.mint(recipient, mintAmount); _deposit(payTokenAddress); _autoUpFP(); emit Mint(recipient, mintAmount, toLiquidityPrice, fees); }",
        "labels": [
            "SlowMist",
            "Lumiterra Community Contracts",
            "Type: Others",
            "Severity: High"
        ]
    },
    {
        "title": "Exploitation risk with arbitrary payToken in VAMM's _mintByPRToken function",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Lumiterra Community Contracts_en-us.pdf",
        "body": "contracts/VAMM.sol The payToken can be any token, so it can be used to construct a malicious token to make a payment. function _mintByPRToken( address payTokenAddress, uint256 mintAmount, uint256 maxPayAmount, address recipient ) internal { IERC20Metadata payToken = IERC20Metadata(payTokenAddress); IUtilityToken _utilityToken = _config.getUtilityToken(); IUtilityToken _prToken = _config.getPRToken(); require(_prToken.balanceOf(msg.sender) >= mintAmount, \"VAMM:mp0\"); require( _prToken.allowance(msg.sender, address(this)) >= mintAmount, \"VAMM:mp1\" ); (uint256 toLiquidityPrice, uint256 fees) = _priceField.getUseFPBuyPrice( mintAmount ); require(toLiquidityPrice + fees <= maxPayAmount, \"VAMM:mp2\"); // Include slippage as fee income fees = maxPayAmount - toLiquidityPrice; //SLOWMIST// uint256 maxPayAmountInPayToken = _convertPrice( maxPayAmount, payToken, true ); _priceField.increaseSupplyWithNoPriceImpact(mintAmount); require( payToken.transferFrom( msg.sender, address(this), maxPayAmountInPayToken ), \"VAMM:mp3\" );//The paytoken is an arbitrary token, so any worthless token can be used as the key to transfer money to the contract. // burn pr token _prToken.burnFrom(msg.sender, mintAmount); _collectFees(fees); /// mint token _totalLiquidity += toLiquidityPrice; _utilityToken.mint(recipient, mintAmount); _deposit(payTokenAddress); _autoUpFP(); emit Mint(recipient, mintAmount, toLiquidityPrice, fees); }",
        "labels": [
            "SlowMist",
            "Lumiterra Community Contracts",
            "Type: Others",
            "Severity: High"
        ]
    },
    {
        "title": "Preemptive Initialization",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Lumiterra Community Contracts_en-us.pdf",
        "body": "contracts/LiquidityStake.sol function initialize(IConfig config_) public initializer { __Ownable_init(); __UUPSUpgradeable_init(); _transferOwnership(tx.origin); config = config_; } contracts/UtilityStake.sol function initialize(IConfig config_) public initializer { __Ownable_init(); __UUPSUpgradeable_init(); _transferOwnership(tx.origin); config = config_; unstakeFee = 300000000; periodDuration = 1 weeks; timeoutClaimPeriod = 2 days; } contracts/VAMM.sol function initialize( IConfig config_, PriceField priceField_, uint256 t_, uint256 x_, uint256 c_ ) public initializer { __Ownable_init(); __UUPSUpgradeable_init(); _transferOwnership(tx.origin); _config = config_; _priceField = priceField_; tForMFR = t_; maxTForMFR = 5000000000; minTForMFR = t_; cForMFR = c_; // ethereum block time 13s reduceTBlocks = 6600; xForMFR = x_; }",
        "labels": [
            "SlowMist",
            "Lumiterra Community Contracts",
            "Type: Race Conditions Vulnerability",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Lacking event logging in critical contract functions alters state without transparency issue",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Lumiterra Community Contracts_en-us.pdf",
        "body": "contracts/LiquidityStake.sol function setHook(LiquidityStakeHook hook_) external onlyOwner { hook = hook_; } contracts/UtilityStake.sol function setHook(UtilityStakeHook hook_) external onlyOwner { hook = hook_; } contracts/PriceField.sol function increaseSupplyWithNoPriceImpact(uint256 amount) external onlyVamm { _exerciseAmount += amount; } contracts/VAMM.sol function setPriceField(PriceField priceField_) external onlyOwner { _priceField = priceField_; }",
        "labels": [
            "SlowMist",
            "Lumiterra Community Contracts",
            "Type: Malicious Event Log Audit",
            "Severity: Suggestion"
        ]
    },
    {
        "title": "Redundant functions",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Lumiterra Community Contracts_en-us.pdf",
        "body": "contracts/VAMM.sol Redundant function code, which can be deleted if it is not useful. function liquidityTesting() external { }",
        "labels": [
            "SlowMist",
            "Lumiterra Community Contracts",
            "Type: Others",
            "Severity: Information"
        ]
    },
    {
        "title": "Missing check return value",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Lumiterra Community Contracts_en-us.pdf",
        "body": "It is recommended to check the return value of transferFrom, as there may be problems if a non-ERC20 standard token is subsequently used. contracts/UtilityStake.sol line 142: utilityToken.transferFrom(staker, address(this), amount); line 196: stablecoin.transferFrom(staker, address(this), fees); line 287: rewardToken.transferFrom(msg.sender, address(this), amount); contracts/LiquidityStake.sol line 154: stablecoin.transferFrom(staker, address(this), _amount); contracts/VAMM.sol line 504: token.transferFrom(msg.sender, address(this), _repayAmount);",
        "labels": [
            "SlowMist",
            "Lumiterra Community Contracts",
            "Type: Others",
            "Severity: Low"
        ]
    },
    {
        "title": "Risk of excessive authority",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Lumiterra Community Contracts_en-us.pdf",
        "body": "contracts/VAMM.sol The owner can set the key parameters, if the private key is lost, the price will be out of control. owner can setPriceField operator can updateMFR contracts/UtilityToken.sol The owner can mint the token, if the private key is lost it will cause the token to be incremented. owner can mint owner can transferOwnership Other contracts have key roles and key parameters that are mostly controlled by external config contracts.",
        "labels": [
            "SlowMist",
            "Lumiterra Community Contracts",
            "Type: Authority Control Vulnerability Audit",
            "Severity: Medium"
        ]
    },
    {
        "title": "Recommendation to Implement reentrancy",
        "html_url": "https://github.com/slowmist/Knowledge-Base/tree/master/open-report-V2/smart-contract/SlowMist Audit Report - Lumiterra Community Contracts_en-us.pdf",
        "body": "contracts/VAMM.sol In _mint , _burn , there is no utilization scenario at the moment, but it is recommended to add reentrant locks.",
        "labels": [
            "SlowMist",
            "Lumiterra Community Contracts",
            "Type: Reentrancy Vulnerability",
            "Severity: Suggestion"
        ]
    }
]