[{"title": "9. Total number of subscriptions increments on cancellation undo", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Suberra/2022-03-17 Audit Report - Suberra v1.0.pdf", "body": "When a cancelled subscription is undone through the execute_subscribe function, contracts/sub1-fixed-recurring-subscriptions/src/contract.rs:389, the function create_subscription is called. This function increments the total number of In the case of an undone cancellation, this leads to the number of subscriptions by 1. subscriptions being incremented unnecessarily.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "12. Oracle migration from v04 to v05 skips deprecated pre-votes and votes", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Terra/Terra Columbus-5 - Audit Report.pdf", "body": "x/oracle/legacy/v05/migrate.go:26 elds In ExchangeRatePrevotes and ExchangeRateVotes from v04 are skipped and not added as entries to the v05 genesis elds AggregateExchangeRatePrevotes and AggregateExchangeRateVotes. That implies that existing valid (albeit deprecated) votes are lost in the migration. deprecated the", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "10. Wrong validation before setting Ethereum public key in conguration", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Persistence/2022-01-20 Audit Report - Persistence Bridge - v1.0.pdf", "body": "In application/configuration/configuration.go:115, a validation check for non-emptiness of caspTMPublicKey is performed, but then the caspEthPublicKey conguration value is assigned.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "1. PeriodicVesting is unintendedly releasing tokens to users", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-10-28 Audit Report - Comdex Locking and Vesting Contracts v1.0.pdf", "body": "In vesting:src/msg.rs:117-138, the vested amount of tokens that is ready to be redeemed by the user is calculated using a PeriodicVesting schedule. It is supposed to calculate the current number of elapsed intervals since start_time in order to compute the total amount of vested tokens. As demonstrated in the test case in Appendix 1, the code is not calculating the correct vested tokens though, which leads to the following problems:  At start_time, the user can already redeem the rst tranche of tokens, even if no interval has elapsed.  The user gets a token tranche more than expected at the end of the vesting period.", "labels": ["Oak Security", "Severity: High"]}, {"title": "2. LOCKINGADDRESS is never populated which will block rebasing functionality", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-10-28 Audit Report - Comdex Locking and Vesting Contracts v1.0.pdf", "body": "The handle_lock_nft function in locking:src/contract.rs:256-266 does not store the locking address to LOCKINGADDRESS. The function creates a mutable vector of addresses from LOCKINGADDRESS where it pushes the senders address but the address is never saved to LOCKINGADDRESS. This results in the map never being populated, which will highly impact other functionality in the contract such as the calculate_rebase_reward function that performs a rebase.", "labels": ["Oak Security", "Severity: High"]}, {"title": "3. Multiple rounding issues may cause zero rewards being distributed", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-10-28 Audit Report - Comdex Locking and Vesting Contracts v1.0.pdf", "body": "functions of Several the locking contract are aected by rounding issues since their mathematical operations use U128 integers for divisions where the numerator is smaller than the denominator. This causes the result to be truncated to zero instead of the desired ratio before it is multiplied, causing the whole operation to be zero. Therefore, reward distribution will result in a zero tokens distribution. In particular in the The aected operations can be found on rewards related features. calculate_bribe_reward, and calculate_surplus_reward functions. The aected instances can be found at and locking:src/contract.rs:770, locking:src/query.rs:322. calculate_rebase_reward 870, 888, 904, 919,", "labels": ["Oak Security", "Severity: High"]}, {"title": "4. Unbounded iterations may cause calculate_rebase_reward to run out of gas", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Comdex/2022-10-28 Audit Report - Comdex Locking and Vesting Contracts v1.0.pdf", "body": "The calculate_rebase_reward function in locking:src/contract.rs:798 performs an unbounded iteration over all entries in LOCKINGADDRESS, and then for each address in LOCKINGADDRESS it will iterate through all vtokens for the gov_token_denom. Both VTOKENS and LOCKINGADDRESS are unbounded and have the potential to grow large with time and normal use. In addition, as mentioned in the nding LOCKINGADDRESS entries are never removed which may introduce state bloat, LOCKINGADDRESS can never be reduced, exacerbating this issue. The impact of this issue is that the rebasing functionality of the contract could become blocked for a specic app_id.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "1. Reward collection for an address will eventually fail due to block gas limit", "html_url": "https://github.com/oak-security/audit-reports/tree/master/pNetwork/20200915_pNetwork DAO staking+reward audit.pdf", "body": "Function collectRewardsFor() loops over a an ever-growing array of rewards. This means that the transaction will eventually hit the block gas limit when the array grows too large. From this point, rewards the rewards, and any future rewards for an address will be stuck. The reason for this behavior is that the array can only grow, making the loop more gas-intensive every time.", "labels": ["Oak Security", "Severity: High"]}, {"title": "2. Staking operation does not check for allowance", "html_url": "https://github.com/oak-security/audit-reports/tree/master/pNetwork/20200915_pNetwork DAO staking+reward audit.pdf", "body": "stake() in the StakingManager contract uses safeTransferFrom() to The function msg.sender to the vault. However, whilst the senders balance is transfer tokens form checked for sufficient funds, no check is performed whether the contract has been authorized to transfer sufficient funds on behalf of the user. This means that the transfer might fail with an unspecific error message.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "3. Gas-intensive loops over unbounded arrays in staking manager", "html_url": "https://github.com/oak-security/audit-reports/tree/master/pNetwork/20200915_pNetwork DAO staking+reward audit.pdf", "body": "Lock data structures, The staking manager stores information in user stakes in arrays of maxLocks variable, which can be set by an authorized caller. These arrays are limited by the searched using for loops during insertion and removal (staking and unstaking). It is generally considered dangerous to loop over unbounded or variable-sized arrays since it results in unpredictable gas consumption. In the extreme case, this can lead to the block gas limit being exceeded and certain transactions never completing. In this particular case, this may lead to unstake() fails due to the array becoming too large. This may occur if stuck funds if maxLocks is accidentally set too large. Note, that this issue has been classified as minor because maxLocks can only be set by a trusted account. However, accidental misconfiguration can still lead to stuck funds.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "1. Sequence is not reset when establishing a new channel", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Polytone/2023-06-05 Audit Report - Polytone v1.0.pdf", "body": "packages/polytone/src/callback.rs:90-117, In request_callback function reads the latest value stored in the SEQ storage and saves it as the callback for the incoming packet sequence. However, the SEQ storage does not reset the sequence back to 1 when the old channel is closed via ibc_channel_close. the Suppose the old channel is closed and a new channel is established. The packet sequence will start as 1. Since the SEQ storage records the old channel's sequence value, the CALLBACKS storage will save the pending callback with an incorrect seq value. As a result, pending callbacks will never be executed properly by the intended receiver, causing CALLBACKS not to be handled and LOCAL_TO_REMOTE_ACCOUNT not to save the request initializer's remote proxy contract address.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "2. Controllers could instantiate proxies and execute messages on the receiver chain on behalf of other users without their consent", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Polytone/2023-06-05 Audit Report - Polytone v1.0.pdf", "body": "on_behalf_of The contracts/note/src/msg.rs:61 allows messages on the receiver chain on behalf of other users. attribute the of Execute struct controlled note contracts dened in to execute However, this is possible without the targeted user's consent allowing the controller account to impersonate unaware users on the controlled chains. While this cannot directly aect targeted users and their funds, controller compromise their reputation. it could allow a malicious to perform phishing and fraud campaigns or impersonate users in order to", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "3. Encoding extensions are not enforced during handshake", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Polytone/2023-06-05 Audit Report - Polytone v1.0.pdf", "body": "The Polytone protocol denes encoding extensions in order to ensure that connected chains exchange data with an agreed format. To do so, in packages/polytone/src/handshake/note.rs:35, the protocol requires that the voice contracts extensions are a subset of the note contracts. However, encodings, contracts/note/src/ibc.rs:26 and 41. the implementation, the exchanges instead of exchanging the underlying chain-supported in hardcoded JSON-CosmosMsg dened string This would cause the mentioned validation check during the handshake to succeed without actually enforcing the extensions subset requirement.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "4. The proxy contract does not return the correct index of an errored message", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Polytone/2023-06-05 Audit Report - Polytone v1.0.pdf", "body": "In contracts/proxy/src/contract.rs:78, returns an error containing the index of the errored message. the proxy contracts reply handler However, it returns the cardinality of submitted messages instead of the actual index. This would cause the propagation of an error with incorrect information leading to potentially wrong actions in the callback.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "5. PROXY_CODE_ID and BLOCK_MAX_GAS are not validated", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Polytone/2023-06-05 Audit Report - Polytone v1.0.pdf", "body": "When instantiating the note and voice contracts, no validations are performed to validate the PROXY_CODE_ID and BLOCK_MAX_GAS values. This is problematic because misconguring the PROXY_CODE_ID to zero would cause the proxy instantiation to fail in contracts/voice/src/contract.rs:93. As for BLOCK_MAX_GAS value, it should be validated to be higher than ACK_GAS_NEEDED and ERR_GAS_NEEDED to prevent underows in contracts/voice/src/ibc.rs:102 and contracts/note/src/ibc.rs:102 and 123. classify We MigrateMsg::WithUpdate message to recover from these situations. as minor because the contract issue this admin can use the", "labels": ["Oak Security", "Severity: Low"]}, {"title": "6. The note contract cannot handle more than 2^64-1 messages", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Polytone/2023-06-05 Audit Report - Polytone v1.0.pdf", "body": "In packages/polytone/src/callback.rs:97, incremented and saved. the message sequence SEQ is However, since it is stored as a u64, the increment will overow, and panic because of the overflow-check in place in the Cargo.toml, after the execution of 2^64-1 messages. This would prevent users from interacting with the contract and consequently lose access to their proxy accounts in the controlled chain.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "1. Proposals tally returns wrong vote results", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Neutron/2022-12-07 Audit Report - Neutron v1.0.pdf", "body": "In neutron:x/gov/keeper/tally.go:79-81, when calculating the result of a governance proposal, the execution is not accounting for NoWithVeto votes. The current implementation returns a failed proposal result if the following inequation is true:     .   It is evident that NoWithVeto votes are not counted and treated as Yes votes in the example in Appendix 1. This implies that proposals that should fail will be unintendedly successful.", "labels": ["Oak Security", "Severity: High"]}, {"title": "2. An error triggered during the handling of an Ack IBC message will make the channel unusable and spam the network", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Neutron/2022-12-07 Audit Report - Neutron v1.0.pdf", "body": "Neutron uses ORDERED channels, which means that there is a sequencer that keeps track of the currently waiting Ack message. is in handled in This message https://github.com/cosmos/ibc-go/blob/77c10be63204a52ec53b1e8ef91a76bae140d5ed/mod ules/core/keeper/msg_server.go#L588-L647 that incrementing the responsible for the IBCModules HandleAcknowledgement method NextSequenceAck and call dened in neutron:x/interchaintxs/keeper/ibc_handlers.go:16-47. Acknowledgement function dened the is it returns an error, If incremented. This could happen for various reasons: the execution will revert and NextSequenceAck will not be  Sudo handlers in the smart contract return an error because of a bug or an invalid input data  Sudo handlers are not dened in the smart contract This implies that the channel will be unusable and that the relayer will continue sending the same failing Ack message. Also, an attacker could use a signicant amount of deployed smart contracts and transactions with failing Sudo handlers in order to let relayers spam the network with Ack messages and trigger the BroadcastTxCommit timeout and the NewTxTimeoutHeightDecorator dened in the AnteHandler. This can prevent that node from processing further ABCI messages such that it has to pause and contact peers to get the latest correct blocks. If a signicant number of them hit the timeout and halt simultaneously, block production may slow down or even stop.", "labels": ["Oak Security", "Severity: High"]}, {"title": "3. IBC events loop in Sudo handler could drain relayers funds", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Neutron/2022-12-07 Audit Report - Neutron v1.0.pdf", "body": "A malicious hacker could develop a CosmWasm smart contract that implements an IBC events loop in the Sudo handler. For example a contract that in the Response Sudo handler, executes another transaction that will trigger the same Response handler and so on. Since there is not an aggregate gas counter for all the dierent transactions of the IBC events ow that could break the loop with an out of gas error, the execution can run until all the relayers funds are drained. Also, this behavior could be used to congest and slow down the chain.", "labels": ["Oak Security", "Severity: High"]}, {"title": "4. Attackers are able to spam the network with IBC messages using the ibc-transfer module", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Neutron/2022-12-07 Audit Report - Neutron v1.0.pdf", "body": "In  neutron:internal/sudo/sudo.go:100-103,  neutron:internal/sudo/sudo.go:132-135, and  neutron:internal/sudo/sudo.go:166-169, the execution is checking that the received Acknowledgement or Timeout Packet is related to an IBC transaction originated from an existing CosmWasm smart contract address and returning an error otherwise. Since it is possible to send an ibc-transfer modules transfer transaction also from a non contract address, for example using the neutrond CLI, with the following command: neutrond tx ibc-transfer transfer an attacker could send a big number of small value transfer messages in order to spam the network with Acknowledgement packets and let them fail in the guard implemented in the mentioned lines. A huge number of such messages could congest nodes and make them unable to process blocks before the BroadcastTxCommit timeout. Also, the NewTxTimeoutHeightDecorator will discard all messages with an elapsed heightTimeout, which could be used in a particular event in order to manipulate it. This can prevent that node from processing further ABCI messages such that it has to pause and contact peers to get the latest correct blocks. If a signicant number of them hit the timeout and halt simultaneously, block production may slow down or even stop.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "5. Unbounded iteration in ValidateBasic may cause node timeout", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Neutron/2022-12-07 Audit Report - Neutron v1.0.pdf", "body": "ValidateBasic The in x/interchainqueries/types/tx.go:73-100 includes an unbounded iteration that may be exploited to cause a node timeout. MsgRegisterInterchainQuery function for The function loops over TransactionsFilter, a caller-supplied slice that is not checked for duplicate entries and does not have a dened size upper-bound. It is best practice to keep ValidateBasic logic simple as gas is not charged when it is executed. It should only perform all necessary stateless checks to enable middleware operations (for example, parsing the required signer accounts to validate a signature by a middleware) without impacting performance in the CheckTx phase. Other validation operations must be performed when handling a message in a modules MsgServer.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "6. Unbounded iteration in PerformSubmitTx could be used by an attacker to slow down or halt the chain", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Neutron/2022-12-07 Audit Report - Neutron v1.0.pdf", "body": "In neutron:wasmbinding/message_plugin.go:204, SubmitTx is performing an unbounded iteration over submitTx.Msgs. An attacker could craft a message with a signicant number of Msgs with the intention of spamming the the block production time triggering the BroadcastTxCommit timeout and the NewTxTimeoutHeightDecorator dened in the AnteHandler. and impact network This can prevent the node from processing further ABCI messages such that it has to pause and contact peers to get the latest correct blocks. If a signicant number of them hit the timeout and halt simultaneously, block production may slow down or even stop.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "7. Unbounded iteration in EndBlocker when calculating vote power could be used by an attacker to slow down or halt the chain", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Neutron/2022-12-07 Audit Report - Neutron v1.0.pdf", "body": "In neutron:x/gov/keeper/voting.go:40-51, in order to calculate voting powers, the EndBlocker is running an unbounded iteration over a slice containing all voting user votes. An attacker could use a signicant number of addresses with a small amount of tokens in order to grow the slice length and impact the block production time, eventually triggering the BroadcastTxCommit timeout and the NewTxTimeoutHeightDecorator dened in the AnteHandler. This can prevent the node from processing further ABCI messages such that it has to pause and contact peers to get the latest correct blocks. If a signicant number of them hit the timeout and halt simultaneously, block production may slow down or even stop.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "8. Attackers could steal funds from the ibc-transfer contract", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Neutron/2022-12-07 Audit Report - Neutron v1.0.pdf", "body": "neutron-contracts:contracts/ibc_transfer/src/contract.rs:43, In execute_send is called in order to complete an IBC-20 transaction from source chain to sink chain, but this function does not verify that there are sucient funds in the contract to support an IBC transfer. Because the execute_send function lacks an authorization check, an attacker can frontrun the legit user and steal funds by sending them from the contract to its own address on the sink chain. We classify this issue as major instead of critical since the ibc-transfer contract is meant to be an example.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "9. Fee struct could be simplied to avoid manipulations", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Neutron/2022-12-07 Audit Report - Neutron v1.0.pdf", "body": "In neutron:proto/feerefunder/fee.proto:17, Fees denition includes Coins as an attribute in order to track users and relayers payments. The checkFees function dened in neutron:x/feerefunder/keeper/keeper.go:169 ensures that the user pays the right amount, checking that coins are over a threshold. However, theres no validation for the denom. This can be abused, and only one coin with almost no value could be used to pass the validation checks.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "10. Unbounded messages loop could run out of gas", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Neutron/2022-12-07 Audit Report - Neutron v1.0.pdf", "body": "In neutron-contracts:contracts/neutron_interchain_queries/src/contrac t.rs:312, tx_body.messages to lter out the required transaction. the recipient_deposits_from_tx_body function iterates over the However, because the number of messages is unknown, this could lead to an unbounded loop execution, which could cause an out-of-gas error. This implies that the smart contract may never be able to consume the supplied dataset corresponding to the query. Even though this is a major issue, we classify it as minor since the aected contract is only an example contract.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "11. Contracts are not compliant with CW2 migration specication", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Neutron/2022-12-07 Audit Report - Neutron v1.0.pdf", "body": "The following contracts do not adhere to the CW2 migration specication:  neutron-contracts:contracts/reflect,  neutron-contracts:contracts/neutron_interchain_txs,  neutron-contracts:contracts/neutron_interchain_queries, and  neutron-contracts:contracts/ibc-transfer. This may lead to unexpected problems during contract migration and code version handling.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "1. Use of dependencies with know security vulnerabilities", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dock/Audit Report - Dock Wallet.pdf", "body": "An analysis of the dependency tree shows 117 known vulnerabilities in the dependency tree. Of these vulnerabilities, 2 are considered of critical severity and 35 are considered of high severity.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "10. Manually unpausing the hub contract after migration might lead to inconsistent state", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lido Finance/2021-11-23 Audit Report - Lido Finance stLuna v1.2.pdf", "body": "The migration process described below has been implemented after the frozen commit for this audit. A change to the migration logic of the hub contract was necessary since a migration within one transaction ran out of gas. An audit of the updated migration logic has been performed on commit e04eb1313c481bdeae084a1dab064afdab5ddbae. the hub contract, During migration of to true in contracts/anchor_basset_hub/src/contract.rs:755, which leads to a rejection of all messages except updates of params and the migration of old unbond waitlist entries in line 137. a paused param is set In the current implementation, the contract must be explicitly unpaused by the owner when the migration is done. There is no validation that the migration has actually been fully performed though. If unpaused before the migration has been nished, partially migrated unbonding waitlist entries might be processed, which could cause missed waitlist entries without a way to recover. Additionally, the paused ag can be used at any time by the owner to pause/unpause the hub contract. If the owner key is ever compromised, ownership could be transferred and the contract paused, leaving any funds inaccessible. We classify this issue as minor since it can only be caused by the owner.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "1. Deposited funds remain locked in custom bond contract for perpetuity custom_bond", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Olympus Pro/2022-03-21 Audit Report - Olympus Pro v1.0.pdf", "body": "The at contracts/custom_bond/src/execute.rs:169 does not include any functionality to transfer the deposited principal token funds into the custom_treasury contract. Because of this, any deposited principal token funds will remain locked in the deposit contract for perpetuity. deposit contracts function", "labels": ["Oak Security", "Severity: High"]}, {"title": "2. Fees sent to the incorrect treasury leads to loss of Olympus treasury income", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Olympus Pro/2022-03-21 Audit Report - Olympus Pro v1.0.pdf", "body": "During the bond creation using create_bond_from_temp and create_bond at contracts/factory/src/contract.rs:231 and 282, the factory contract is using the incorrect value of custom_treasury as olympus_treasury instead of config.treasury. The config.treasury treasury address provided during the initialization at contracts/factory/src/contract.rs:36 is currently unused. The issue can be xed through governance because the olympus_treasury address can be changed through the update_olympus_treasury function. But the collected fees would not be sent to the olympus_treasury until the address is correctly set, they would be transferred to the custom_treasury contract which Olympus does not own.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "3. Additional deposits will reset the vesting term of existing bonds", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Olympus Pro/2022-03-21 Audit Report - Olympus Pro v1.0.pdf", "body": "Depositing additional funds to an existing bond will cause the vesting term of these existing deposits to be reset in contracts/custom_bond/src/execute.rs:261. That implies that funds that are not yet redeemed by the bonder will have an extended vesting period. i.e on January 6. Suppose that after 4 days, For example, if Alice deposits 100 token A (principal token) on January 1, the vesting term is 5 days and the bond price is 25, then she would get 4 payout tokens after the completion of 5 days, i.e. on January 5 Alice deposits an additional 100 token A and Alice did not redeem during those 4 days, then her new vesting term will be again 5 days as per line 261. If she wants to redeem after 1 day, i.e. on January 6, she will only be able to redeem 8 * 1 / 5 = 1.6 token B, even though the previous 4 tokens should have already been vested.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "4. Missing support for upgrades of bond and treasury contracts", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Olympus Pro/2022-03-21 Audit Report - Olympus Pro v1.0.pdf", "body": "the bond and treasury contracts sets the factory contract as the admin in Creation of contracts/factory/contract.rs:197, 226, and 277. This means only the factory contract can upgrade the bond and treasury contracts, but there is no function in the factory contract to execute updates. The contracts also lack versioning information that can be handy in the future during upgrades of the contract.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "5. Centralization risk in withdrawal of treasury funds", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Olympus Pro/2022-03-21 Audit Report - Olympus Pro v1.0.pdf", "body": "Currently, contracts/custom_treasury/src/contract.rs:118 withdraw is access the to function controlled by in the assert_policy_privilege function which ensures that the info.sender equals the config.policy address. The withdraw function allows the policy account to issue an arbitrary withdrawal from the treasury to any recipient. In the event of the policy account being compromised, an attacker would have the ability to completely drain the treasury. We classify this nding as minor because while the impact would be major, the likelihood of this event occurring is low if strong key management practices are used on the policy account.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "6. Usage of dierent versions of cw20 crate", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Olympus Pro/2022-03-21 Audit Report - Olympus Pro v1.0.pdf", "body": "Within the project's Cargo.toml les, dierent versions are used for the cw20 crate:  Version 0.10.3 in contracts/custom_treasury/Cargo.toml:28  Version 0.8.0 in contracts/custom_bond/Cargo.toml:29  Version 0.8.0 in contracts/olympus_pro/Cargo.toml:20", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. Slashing distribution may create a tragedy of the commons where slashing is never applied and new users are disincentivized to enter the protocol", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lido Finance/2022-05-16 Audit Report - Lido Finance stATOM on Cosmos Hub v1.0.pdf", "body": "function calculate_new_withdraw_rate time (minus an unbonding_period delta time). in The lido_cosmos_hub/src/unbond.rs:129 updates the historical withdraw_rate of a given batch to account for slashing events that happened between the unbond epoch and the current In line 140 of a each calculate_new_withdraw_rate, batch_slashing_weight, which is the proportion of the unbonded ATOM amount of a given last unbonded ATOM of execute_withdraw_unbonded execution. That implies, that no matter when the slashing occurred, slashing will aect all users that have unbonded but have not yet withdrawn. all batches assigned batch batch since total gets the the to This mechanic can create a tragedy of the commons situation, as waiting unstakers are incentivized to not withdraw, since their slashing amount will be reduced the more other users unbond in subsequent batches. Worst case, this can result in a deadlock where no one is incentivized to withdraw. Moreover, new stakers coming in when there are pending slashes will participate in those not yet applied slashes, disincentivizing new users to stake funds. Due to the condition in contracts/lido_cosmos_hub/src/unbond.rs:59, external intervene to resolve the problem by triggering a new withdraw_rate users cannot calculation, since withdrawing is restricted to users that have pending withdrawals.", "labels": ["Oak Security", "Severity: High"]}, {"title": "2. Unbounded unbond history entries may cause all deposited funds stuck in the hub contract", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lido Finance/2022-05-16 Audit Report - Lido Finance stATOM on Cosmos Hub v1.0.pdf", "body": "running out of gas causing stuck irrecoverable funds in the hub contract. The execute_withdraw_unbonded function contains unbounded loops which have the In risk of the lido_cosmos_hub/src/contract.rs:102, calculate_newly_added_unbonded_amount function, there is an unbounded loop that in line 203, iterates over the unprocessed UnbondHistory entries. In a similar manner, inside within the process_withdraw_rate function, another unbounded loop iterates over the same UnbondHistory entries that haven been just processed. If there are no withdrawals for a long enough timeframe, or if the epoch_period is very short, there may be too many entries so this cannot be processed as it would run out of gas, leaving all funds stuck forever in the contract. We do not classify this issue as critical since any user withdrawing unbonded funds will move the last_processed_batch forward, iterations the next withdrawing user needs to process. reducing the number of", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "3. Unbounded unbond wait entities may cause user funds to be stuck in hub contract", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lido Finance/2022-05-16 Audit Report - Lido Finance stATOM on Cosmos Hub v1.0.pdf", "body": "an unbounded loop starting in The get_finished_amount function contains lido_cosmos_hub/src/state.rs:113 that iterates over each UnbondWaitEntity of a user. Removal of deprecated batches in the   remove_unbond_wait_list function in line 67 is also unbounded. If there are no withdrawals for a long enough timeframe, or if the epoch_period is short, there may be too many entries so this iteration would run out of gas, leaving the funds of the given user stuck in the contract. issue same could The in lido_cosmos_hub/src/contract.rs:483 and the query_get_finished_amount function in contracts/lido_cosmos_hub/src/state.rs:137 to run out of gas, making the WithdrawableUnbonded and UnbondRequests query unusable. query_unbond_requests function cause the We do not consider this issue to be critical, since the probability of a user experiencing this issue is fairly small. However, its theoretically possible and may happen when using bots and/or automated bonding/unbonding strategies.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "4. Missing validation of Lido fee rate may cause reward dispatch to fail", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lido Finance/2022-05-16 Audit Report - Lido Finance stATOM on Cosmos Hub v1.0.pdf", "body": "The lido_fee_rate parameter in the Cosmos Reward Dispatcher contract determines the fee Lido applies to bonded Atom rewards. However, there is no validation that this value is smaller instantiation the (lido_cosmos_rewards_dispatcher/src/contract.rs:39) execute_update_config function (line 113). If the fee parameter is bigger than one, dispatch of rewards will fail due to an underow in line 147. Decimal::one() contract than or at in", "labels": ["Oak Security", "Severity: Low"]}, {"title": "5. Missing validation for stored validator and guardian addresses", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lido Finance/2022-05-16 Audit Report - Lido Finance stATOM on Cosmos Hub v1.0.pdf", "body": "of list addresses The in lido_cosmos_validators_registry/src/contract.rs:46 is not validated as Addr type. Likewise, addresses are not validated in the add_validator function in line 116. REGISTRY validators stored of in issue is present in lido_cosmos_hub/src/contract.rs:142 in the A similar execute_add_guardians function, where the new GUARDIANS addresses stored are not validated as Addr.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "6. Unbounded guardians query may run out of gas", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lido Finance/2022-05-16 Audit Report - Lido Finance stATOM on Cosmos Hub v1.0.pdf", "body": "contracts/lido_cosmos_hub/src/contract.rs:409, In query_guardians iterates over all guardians in storage. Since there can be an unlimited amount of guardians in storage, this iteration can run out of gas. We mark this issue as minor since guardians can only be added by the owner.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "7. Slashing is not accounted for in queries which may give wrong results and cause unexpected behavior", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lido Finance/2022-05-16 Audit Report - Lido Finance stATOM on Cosmos Hub v1.0.pdf", "body": "lido_cosmos_hub/src/contract.rs:451 In function query_withdrawable_unbonded returns the withdrawable amount for a given address. However, the latest withdraw_rate is not taken into account which is discounting any slashing events that may have occurred. Hence, this query may return incorrect results which may cause unexpected behavior on 3rd party applications integrated with Lido. the", "labels": ["Oak Security", "Severity: Low"]}, {"title": "8. Negative unbonded amounts are not being handled when calculating the withdraw rate", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lido Finance/2022-05-16 Audit Report - Lido Finance stATOM on Cosmos Hub v1.0.pdf", "body": "In contracts/lido_cosmos_hub/src/unbond.rs:163, when calculating the new withdraw_rate, there is a signed subtraction that might return a negative value. If that were to happen, tokens would be sent to the users that the user should not receive. This could occur if the full amount were slashed, or if nearly the full amount is slashed due to rounding/truncation. Even though this scenario is unlikely, it is theoretically possible as the Cosmos SDK allows a slashing fraction of 100%.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "9. Missing denomination check may become problematic in the future", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lido Finance/2022-05-16 Audit Report - Lido Finance stATOM on Cosmos Hub v1.0.pdf", "body": "only which contracts Lido Cosmos Hub the Currently, the underlying_coin_denom, In contracts/lido_cosmos_hub/src/contract.rs:341 there is a check to add the delegation amount of the underlying_coin_denom. However, other denominations that are delegated at the same time will be ignored. This could cause issues if the protocol were to add new staking tokens in the future. A similar missing denomination check is also present in contracts/lido_cosmos_validators_registry/src/contract.rs:160 and 223. staking updated. support be cannot in", "labels": ["Oak Security", "Severity: Low"]}, {"title": "10. Users might lose unbonded funds to users that unbond in the next batch if the unbonding period of the hub contract is shorter than the one of the underlying blockchain", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lido Finance/2022-05-16 Audit Report - Lido Finance stATOM on Cosmos Hub v1.0.pdf", "body": "expected undonded amount with Within the execute_withdraw_unbonded function, slashing is applied to an undelegation batch by adjusting the statom_withdraw_rate of that badge. This is done by comparing the The actual_unbonded_amount is calculated by subtracting the stored prev_hub_balance in hubs from contracts/lido_cosmos_hub/src/unbond.rs:193. expected undbonded amount is then computed in the calculate_newly_added_unbonded_amount function by iterating over all unbonding history entries from the last processed/released one to the one thats older than unbonding_period param. unbonded amount. balance current ATOM actual The the the This works well if the unbonding_period param is equal to or greater than the underlying blockchains unbonding period. If the unbonding_period param is too short though, the expected unbonded amount may be bigger than the actual unbonded amount, even if no slashing happens. the statom_withdraw_rate will be too low, and unbonding users lose funds to users in the next unbonding batch. In that case, Despite the severe implications of a too short unbonding_period param, we classify this issue as minor, since governance can ensure equality of the periods by carefully making required changes.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "11. Users are subject to slashing between unbonding and undelegation batch execution, which is currently not documented", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lido Finance/2022-05-16 Audit Report - Lido Finance stATOM on Cosmos Hub v1.0.pdf", "body": "The current implementation of Lido nance does undelegations in batches for eciency reasons. Undelegations happen at most every epoch_period through the logic in the execute_unbond_statom function at lido_cosmos_hub/src/unbond.rs:289. That implies that users that have sent unbond messages to the hub contract will still be subject to slashing until the delegation batch is executed. This behavior is dierent from Cosmos SDKs slashing module, which only slashes delegators that were active when the slashing event occurred. This dierence is currently not documented.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "12. Ability to pause hub contract increases risks associated with compromised owner key", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lido Finance/2022-05-16 Audit Report - Lido Finance stATOM on Cosmos Hub v1.0.pdf", "body": "The hub contains a paused param, which can be set/unset at any time by the owner to pause/unpause in contracts/lido_cosmos_hub/src/contract.rs:177 and 196. If the owner key is ever compromised or lost, funds may be left inaccessible forever in the contract. contracts the We classify this issue as informational since a compromised owner key has other severe implications and proper key management is an underlying assumption of the protocol in any case.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "13. Exchange rate is not updated after bonding rewards and may exhibit small variations due to rounding/truncation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lido Finance/2022-05-16 Audit Report - Lido Finance stATOM on Cosmos Hub v1.0.pdf", "body": "In contracts/lido_cosmos_hub/src/bond.rs:94, when the BondType is StAtom, the exchange rate is not updated. Since the new stATOM is minted in proportion to the exchange rate, it should remain identical. However, due to rounding/truncation, the exchange rate may be subject to small variations and these are not accounted for.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "14. Storing exchange rate and total stATOM issued in hubs state is inecient and complicates the codebase", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lido Finance/2022-05-16 Audit Report - Lido Finance stATOM on Cosmos Hub v1.0.pdf", "body": "a hub eld State contains contracts statom_exchange_rate The in packages/basset/src/hub.rs:28, which is updated in several places throughout the codebase, for example whenever rewards are accumulated. Since rewards are accruing on on an ongoing basis, the stored exchange rate will be almost instantly outdated. To use the correct value, the current implementation updates the stored exchange rate before every usage, including before a query of the State. Consequently, there is little point in storing the statom_exchange_rate in the State in the rst place. Storing unnecessary data is inecient and makes the codebase more complicated. Similarly, the State contains a eld total_statom_issued in line 26. However, this is inecient as it should be equivalent to the supply of stATOM, which is queried within the function call in contracts/lido_cosmos_hub/src/bond.rs:71.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "15. Outdated references to Terra implementation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lido Finance/2022-05-16 Audit Report - Lido Finance stATOM on Cosmos Hub v1.0.pdf", "body": "The documentation states that any logic related to the Terra implementation should be marked as an issue. In this informational issue, we list comments and code that references the Terra implementation. - All contracts and packages use version 0.16.0 of cosmwasm-std, which is a legacy version only used on Terra. - Comment in lido_cosmos_validators_registry/src/contrac.rs:156 referencing Terra Core. - Outdated documentation title in contracts/lido_cosmos_hub/README.md:1.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "16. Duplicate check slashing message is inecient", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lido Finance/2022-05-16 Audit Report - Lido Finance stATOM on Cosmos Hub v1.0.pdf", "body": "the in In contracts/lido_cosmos_token_statom/src/handler.rs:51-62, a duplicated slashing message in case the burn sender is not the hub_contract. The second CheckSlashing message does not have any new eect on the state, so it seems unnecessary. message Burn there is", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "17. Inaccurate logic conditions in delegation calculation can undermine the eciency of the contracts", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lido Finance/2022-05-16 Audit Report - Lido Finance stATOM on Cosmos Hub v1.0.pdf", "body": "the in In lido_cosmos_validators_registry/src/common.rs:38, if coins_per_validator + extra_coin is equal to validator.total_delegated, an unnecessary iteration over the loop will be made when bonding or removing a validator. calculate_delegations function", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "18. Name and version of stATOM contract are incorrectly set up", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lido Finance/2022-05-16 Audit Report - Lido Finance stATOM on Cosmos Hub v1.0.pdf", "body": "inherits its instantiate function from cw20-base, The stATOM cw20-compliant contract in calling cw20_init incorrectly lido_cosmos_token_statom/src/contract.rs:41. This function will store the CONTRACT_NAME to crates.io:cw20-base and CONTRACT_VERSION to 0.8.0, instead of crates.io:lido_cosmos_token_statom and 1.0.0 respectively. function the", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "19. Remove unused code to improve contract size and readability", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lido Finance/2022-05-16 Audit Report - Lido Finance stATOM on Cosmos Hub v1.0.pdf", "body": "such code Unused in lido_cosmos_hub/src/state.rs:35 increases contract bloat without providing any in functionality. package/basset/src/contract_error.rs:5. MAX_DEFAULT_RANGE_LIMIT ContractError example Another const enum the as is", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "20. Marking paused parameter in the Hub as an Option adds unnecessary complexity", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lido Finance/2022-05-16 Audit Report - Lido Finance stATOM on Cosmos Hub v1.0.pdf", "body": "hub contract The in paused packages/basset/src/hub.rs:141, that guardians and the contract owner can use in critical situations to disable most interactions with the contracts. However, the type of paused is Option<bool> instead of just bool, which adds extra unnecessary complexity. parameter dened switch, has a", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "21. Incorrect query function name may negatively aect user and developer experience", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Lido Finance/2022-05-16 Audit Report - Lido Finance stATOM on Cosmos Hub v1.0.pdf", "body": "function in The contracts/lido_cosmos_hub/src/contract.rs:489 is referencing a dierent storage map UNBOND_HISTORY_MAP which may confuse users and may cause further issues if 3rd party developers query this function. query_unbond_requests_limitation", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. Contract creators can update the gas price into invalid integer value in order to disable the wasmxs BeginBlocker execution", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Injective/2023-01-20 Audit Report - Injective v1.0.pdf", "body": "cw-injective:contracts/registry/src/contract.rs:149, In creator can update the gas price to an invalid string. the contract Since gas prices are supposed to be denominated in integer values, this would cause the in ToContractExecutionParams injective-core:injective-chain/modules/wasmx/types/exec_msgs.go:12 7 due to an invalid gas price. message fail to Consequently, the ExecuteContracts functionality in BeginBlocker will always fail due in to the FetchRegisteredContractExecutionList function returning an error injective-core:injective-chain/modules/wasmx/keeper/wasm.go:50. A malicious user can use this behavior to inhibit the BeginBlocker execution of the wasmx module.", "labels": ["Oak Security", "Severity: High"]}, {"title": "2. Valid positions may be rejected prior the application of PnL", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Injective/2023-01-20 Audit Report - Injective v1.0.pdf", "body": "the During injective-core:injective-chain/modules/exchange/keeper/wasm_privil eged_action.go, the initial margin requirements of positions are veried twice: It is veried before and after the application of PnL in lines 128 and 139, respectively. synthetic handling trades of in Consequently, if a position does not fulll the initial margin requirement before the application it afterwards, an error is thrown. This implies that valid of position delta but does fulll positions can be rejected.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "3. Governance is not able to eectively remove a contract from registry", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Injective/2023-01-20 Audit Report - Injective v1.0.pdf", "body": "In injective-core:injective-chain/modules/wasmx/proposal_handler.go:1 3-24 no proposal is dened that allows removal of a contract from the registry. The wasmx module can disable a contract, but the contracts creator could simply re-activate it by interacting with that contract. This implies that a compromised contract, a contract that has been migrated to a malicious code, or one that has lost its reputation, cannot be removed from the registry.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "4. registry contract and wasmx module are not aware of registered contract migrations", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Injective/2023-01-20 Audit Report - Injective v1.0.pdf", "body": "The ContractRegistrationRequestProposal proposal species a contract address that should be added in the registry. The contract address identies the contract instance, but not its deployed wasm code. In fact, a malicious contract creator could migrate a registered contract to a new wasm binary in order to steal user funds or to execute malicious logic that can impact the entire chain, for example, a high resource computation in the begin_blocker handler.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "5. Integer gas price type allows negative values", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Injective/2023-01-20 Audit Report - Injective v1.0.pdf", "body": "The Int type is used to represent the gas price in the ContractRegistrationRequest struct in injective-core:injective-chain/modules/wasmx/types/wasmx.pb.go. dened As an integer type can hold both positive and negative numbers, a negative gas price would trigger an error during the execution of a wasmxs registered contract.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "6. Max contract gas limit can be set lower than minimum execution gas limit, causing contract registration to fail", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Injective/2023-01-20 Audit Report - Injective v1.0.pdf", "body": "In injective-core:injective-chain/modules/wasmx/types/params.go:111-1 there is no validation to ensure the MaxContractGasLimit value is higher than 21, keeper.MinExecutionGasLimit, which represents the minimum gas limit (90396 in injective-core:injective-chain/modules/wasmx/keeper/wasm.go:17). As a result, a misconguration of the maximum contract gas limit to be lower than 90396 would in the injective-core:injective-chain/modules/wasmx/proposal_handler.go:3 0 to always fail, aecting the handleContractRegistration functionality. validation cause", "labels": ["Oak Security", "Severity: Low"]}, {"title": "7. Too many contracts registered would cause GetContracts and GetActiveContracts query messages to fail", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Injective/2023-01-20 Audit Report - Injective v1.0.pdf", "body": "In cw-injective:contracts/registry/src/contract.rs:220 and 237, both to fetch all query_contracts and query_active_contracts messages attempt contracts registered in the storage and return them to the caller. This is problematic because the query could run out of gas in an execution context if too many contracts are stored.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "8. Custom calls between Cosmos SDK modules and CosmWasm contracts require third-party developers to implement their own authorization logic", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Injective/2023-01-20 Audit Report - Injective v1.0.pdf", "body": "The wasmx and exchange modules are performing authorized calls to particular CosmWasm contract handlers using custom logic. In order to do so, Cosmos SDK modules are performing Execute functions from wasm module impersonating the receiver contract. From the CosmWasm side, it is as if the message comes from the contract itself. This means that on the CosmWasm contract, contract developers need to implement custom authorization logic in order to restrict the access of a particular entrypoint only to Injective Cosmos SDK modules. Delegating the authorization of the interaction between modules and smart contracts to third-party developers is risky since they could not implement it in the right way or not implement it at all. Additionally, the workaround to use the receiver contract address to call modules reserved handlers has the side eect that the contract can execute calls that should be reserved to wasmx and exchange modules by itself.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "9. Name validation can be bypassed with whitespace", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Injective/2023-01-20 Audit Report - Injective v1.0.pdf", "body": "In injective-core:injective-chain/modules/exchange/types/msgs.go:1288, the execution will revert if the data name provided is an empty string. This validation can be bypassed by providing whitespace. Ideally, whitespaces should be prohibited since they are also invalid names.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "10. Consider deduping batch contract addresses in ValidateBasic", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Injective/2023-01-20 Audit Report - Injective v1.0.pdf", "body": "In injective-core:injective-chain/modules/wasmx/types/proposal.go:83, the ValidateBasic function does not lter duplicate contract addresses contained in the ContractRegistrationRequests array. Such duplicate contract addresses would cause in each the injective-core:injective-chain/modules/wasmx/proposal_handler.go:6 0 since the contract is already registered. duplicated execution contract address fail for to", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "11. Outstanding TODO comments present in the codebase", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Injective/2023-01-20 Audit Report - Injective v1.0.pdf", "body": "TODO comments were found in the following code lines:  injective-core:injective-chain/modules/wasmx/keeper/wasm.go:1  injective-core:injective-chain/modules/wasmx/keeper/wasm.go:2  injective-core:injective-chain/modules/wasmx/keeper/wasm.go:2  cw-injective:packages/injective-cosmwasm/src/subaccount.rs:12", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "12. A dev-dependency is vulnerable to two CVEs", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Injective/2023-01-20 Audit Report - Injective v1.0.pdf", "body": "plotters The in cw-injective:packages/injective-math/Cargo.toml:27 is vulnerable to two CVEs: dev-dependency dened crate as a  RUSTSEC-2020-0159: chrono  RUSTSEC-2020-0071 - Potential segfault in the time crate", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. Claiming allocation will cause proposed receivers previous allocation to be overwritten, leaving funds inaccessible in the contract", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-03-15 Audit Report - Astroport Governance v1.0.pdf", "body": "contracts/builder_unlock/src/contract.rs:305-311 the In astroport-governance repository, the proposed receivers allocation is overwritten via PARAMS.save and STATUS.save without they have existing AllocationParams and AllocationStatus. If the proposed receiver decides to claim a new allocation while having an existing allocation, their existing allocations ASTRO token will be stuck in the contract. verifying whether of", "labels": ["Oak Security", "Severity: High"]}, {"title": "2. Original receivers that transferred allocation will not be able to receive new allocations", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-03-15 Audit Report - Astroport Governance v1.0.pdf", "body": "contracts/builder_unlock/src/contract.rs:303-311 In the astroport-governance repository, if the original receiver had transferred their ownership of allocation to a new receiver, their AllocationParams is removed via PARAMS.remove in line 308. However, their AllocationStatus is not removed via STATUS.remove, which means that the original receiver will have an outdated AllocationStatus but no associated AllocationParams with it. of This is problematic since the original receiver will be unable to receive new allocations due to lines 153-158.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "3. Leftover amount after providing liquidity is not refunded", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-03-15 Audit Report - Astroport Governance v1.0.pdf", "body": "the astrozap repository, In contracts/astrozap/src/contract.rs:84 of offer_asset is calculated by using Newton's method. Since the method does not have 100% accuracy (in the referenced white paper, the specic example shows a 0.04% error), it will cause a remainder of tokens to be left in the contract. Moreover, Newtons method does (see not contracts/astrozap/src/math.rs:74). for offer_asset. MAX_ITERATIONS within It convergence can output erroneous guarantee values", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "4. Miscongured schedule duration could cause division by zero error, leaving funds inaccessible", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-03-15 Audit Report - Astroport Governance v1.0.pdf", "body": "contracts/builder_unlock/src/contract.rs:427 In the astroport-governance repository, schedule.duration is used as a denominator to calculate the amount of tokens that can be unlocked between start time and end time. If the value is zero, a division by zero error would occur and will cause the specic allocation to be locked in the contract. of We consider this to be a minor issue since it can only be caused by the owner.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "5. UnlockedTokens query message does not include cliff period during calculation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-03-15 Audit Report - Astroport Governance v1.0.pdf", "body": "contracts/builder_unlock/src/contract.rs:362-372 In astroport-governance repository, query_tokens_unlocked of the uses tokens that are unlocked compute_unlocked_amount to compute the number of according to the current timestamp. The function does not include the schedules cli period when calculating the withdrawable token amount, this would cause an incorrect amount returned to the caller. An example calculation that includes a cli period can be found in contracts/builder_unlock/src/contract.rs:442-445.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "6. Extra funds sent to AstroZap contract are lost", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-03-15 Audit Report - Astroport Governance v1.0.pdf", "body": "In contracts/astrozap/src/contract.rs:74-79 of the astroport-governance repository, users sent funds are being used in handle_deposits to verify that the funds user claimed to have deposited are actually deposited to the contract. The current implementation does not return an error though if additional native tokens are sent to the contract, leaving them stuck in the contract. We consider this to be a minor issue, since it is caused by a user error.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "7. Duplicate accounts creation in xAstro token instantiation would cause inated xAstro total supply", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-03-15 Audit Report - Astroport Governance v1.0.pdf", "body": "In contracts/xastro_token/src/contract.rs:104-108 of the astroport-core repository, duplicate accounts are not veried when creating initial accounts during the contract is passed twice in create_accounts, the accounts balance would be overwritten via BALANCES.save but total_supply would still record the balance amount of both. As a result, xAstro tokens total supply would be inated. the same account address instantiation phase. If We consider this to be a minor issue since it can only be caused by the owner.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "1. Unbounded loops in the nitro package can lead to a DoS", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-19 Audit Report - Sei Chain and CosmWasm v1.0.pdf", "body": "In x/nitro/keeper/msg_server.go:75 and x/nitro/keeper/prover.go:24, the user-provided elds msg.EndSlot and proof.Hash may lead to an unbounded loop or an arbitrarily computationally expensive transaction which can lead to a DoS. This is problematic since the Validate function in x/nitro/keeper/prover.go:24 does not charge gas to the sender of the transaction, making the attack free of charge. It is important to note that both these code paths are called by the SubmitFraudChallenge method in x/nitro/keeper/msg_server.go:56, which is currently not registered on the Router in x/nitro/module.go:107.", "labels": ["Oak Security", "Severity: High"]}, {"title": "2. Not registered message types prevent users from sending transactions", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-19 Audit Report - Sei Chain and CosmWasm v1.0.pdf", "body": "MsgContractDepositRent and MsgUnregisterContract are not registered in RegisterInterfaces and RegisterCodec in x/dex/types/codec.go. Hence, the module will not route the messages to an appropriate message server. Thus, users will not be able to send transactions with the aforementioned message types.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "3. MsgContractDepositRent should set a minimum amount to avoid potential spamming", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-19 Audit Report - Sei Chain and CosmWasm v1.0.pdf", "body": "In x/dex/keeper/msgserver/msg_server_contract_deposit_rent.go:12, there is no minimum limit to the amount that can be sent, and there is no gas charged for the operation, by default. This can be a cost-eective attack vector for the protocol, in which multiple transactions are sent with negligible amounts to consume CPU cycles with minimal cost. This may be used to slow down block production or even halt the chain.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "4. Tick sizes are wrongly updated when a newly registered pair already exists", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-19 Audit Report - Sei Chain and CosmWasm v1.0.pdf", "body": "In x/dex/keeper/msgserver/msg_server_register_pairs.go:36, any errors returned from the k.AddRegisteredPair function are silently ignored. This implies that the execution will continue even if the creator of a contract is trying to register a pair that already exists. This unhandled error has the unintended consequence that SetPriceTickSizeForPair and SetQuantityTickSizeForPair are called in lines 37-38, updating the current tick sizes of an already existing pair. Since events for that pair are not emitted, this could break any integrations with o-chain components and third-party applications relying on those events.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "5. Processing of MsgPlaceOrders and MsgSend messages in EndBlocker may be exploited to halt the chain if mispriced", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-19 Audit Report - Sei Chain and CosmWasm v1.0.pdf", "body": "Due to the processing of MsgPlaceOrders and MsgSend messages in the EndBlocker, a user can send transactions with multiple MsgPlaceOrders and MsgSend messages that are successfully included in a block, but then fail during the EndBlocker execution. An attacker may exploit this feature if the computation needed in the EndBlocker is not properly priced in the transaction. If a network has zero or low fees, an attacker could send hundreds of thousands of MsgPlaceOrders and MsgSend messages at comparatively low cost for the computation required which can slow down block production up to the point where the blockchain halts.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "6. Contract claiming is not possible due to a logic error", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-19 Audit Report - Sei Chain and CosmWasm v1.0.pdf", "body": "if In the ContractDepositRent function, a new owner can claim a contract 0. However, contract.RentBalance x/dex/keeper/msgserver/ msg_server_contract_deposit_rent.go:28, the SendCoins operation is executed from the old creatorAddr, not from msg.Sender. Thus, this function will always fail when called by any address which is not the current owner, rendering the claim functionality unusable. == in", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "7. Past minting emissions would never happen if the chain is down on the required release date", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-19 Audit Report - Sei Chain and CosmWasm v1.0.pdf", "body": "In validates if x/mint/types/minter.go:56, function the date of the block is equal to the scheduledReleaseDate, and gets GetScheduledTokenRelease the executed in the BeginBlock of the epoch module. If the date matches, new mint emissions of the chain token will be performed. However, the function does not consider if the date scheduledReleaseDate is in the past, but the emission of the given epoch has not happened yet. Therefore, in case the Sei chain is down for more than 24 hours, the release of tokens is skipped, altering the emission plan.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "8. Amino codec must be registered to support end users with hardware devices like Ledger", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-19 Audit Report - Sei Chain and CosmWasm v1.0.pdf", "body": "In x/dex/types/codec.go:50, Amino should be used to register all interfaces and concrete types for the dex module. This is necessary for JSON serialization to support hardware devices like Ledger since these devices do not support proto transaction signing.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "9. Insucient validation of addresses", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-19 Audit Report - Sei Chain and CosmWasm v1.0.pdf", "body": "The address of the creator, as well as the address of the contract in validateCancels the function in x/dex/keeper/msgserver/msg_server_cancel_orders.go are only checked against zero-length and not for validity of the address.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "10. GetContract parse error not handled explicitly", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-19 Audit Report - Sei Chain and CosmWasm v1.0.pdf", "body": "In x/dex/keeper/contract.go:37, the method GetContract returns an error either when the contract is not present in the storage, or when the contract is found but cannot be parsed in x/dex/keeper/msgserver/msg_server_register_contract.go:95, 107, and 193 assume that the contract does not exist upon either error and does not handle parsing errors. However, properly. contexts calling the", "labels": ["Oak Security", "Severity: Low"]}, {"title": "11. Fund transfer in EndBlocker goes against best practices", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-19 Audit Report - Sei Chain and CosmWasm v1.0.pdf", "body": "function sends a transaction using the MsgPlaceOrders message, the When a user in transferFunds x/dex/keeper/msgserver/msg_server_place_orders.go:15 is called to create a DepositInfoEntry with the users fund amount in MemState. The amount is not actually moved from the senders account until the GetDepositSudoMsg function is called in the If a user EndBlock function in x/dex/keeper/abci/end_block_deposit.go:33. sends a transaction with multiple messages of MsgPlaceOrders and MsgSend, the transaction would be successfully included in a block but the deposit might fail during the EndBlocker execution since insucient time. Such asynchronously failing messages can negatively impact the user experience. It is best practice to fail fast by directly transferring funds from a senders account during message execution. After that, the deposit can still be handled in the EndBlock function. funds may be available at that", "labels": ["Oak Security", "Severity: Low"]}, {"title": "12. Events are not emitted consistently across the application, which may impact the ability of third-party applications to be integrated", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-19 Audit Report - Sei Chain and CosmWasm v1.0.pdf", "body": "Cosmos events are emitted by applications to notify third-party applications such as block explorers about events that occur on the chain. Not emitting events consistently across the application may impact the ability of these applications to parse the activity that happens in Sei, impacting user and developer experience. The following instances of messages and functionality lack emission of events:  x/epoch/module.go:188  x/dex/keeper/msgserver/msg_server_unregister_contract.go:12", "labels": ["Oak Security", "Severity: Low"]}, {"title": "13. ChangeAdmin does not validate that the new admin is dierent from the current one, which may cause errors in contracts and applications relying on this logic", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-19 Audit Report - Sei Chain and CosmWasm v1.0.pdf", "body": "function ChangeAdmin The in x/tokenfactory/keeper/ msg_server.go:135 permits the admin of a token denom to change its address to a new one. However, there is no check that NewAdmin is dierent from the current one. An event of a change of admin is emitted nonetheless, which may cause unexpected behavior in applications relying on this information. tokenfactory module the in", "labels": ["Oak Security", "Severity: Low"]}, {"title": "14. Ination rate is set to 0%, while the documentation indicates an intended default ination rate of 13%", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-19 Audit Report - Sei Chain and CosmWasm v1.0.pdf", "body": "In x/mint/types/minter.go:26, it is stated that the intended default initial ination rate should be 13%. However, in line 21, the initial ination rate is set to sdk.NewDec(0).", "labels": ["Oak Security", "Severity: Low"]}, {"title": "15. UnregisterContract should remove associated pairs after the contract is removed to avoid consuming unnecessary disk space on validators", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-19 Audit Report - Sei Chain and CosmWasm v1.0.pdf", "body": "is the contract removed in Once in x/dex/keeper/msgserver/msg_server_unregister_contract.go:12, its associated states are not deleted. An attacker can exploit storage by registering contracts, and then unregistering them multiple times. The cost of such an attack is comparatively low as rent is refunded to the contract owner after unregistration. UnregisterContract function the", "labels": ["Oak Security", "Severity: Low"]}, {"title": "16. Inecient implementation of UpdateQuantityTickSize and UpdatePriceTickSize", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-19 Audit Report - Sei Chain and CosmWasm v1.0.pdf", "body": "implementation The x/dex/keeper/msgserver/msg_server_update_quantity_tick_size.go:11 iterates through the tick size list, performing validation and then iteration through the same list happens again in SetQuantityTickSizeForPair. A similar implementation is performed to update price tick size. UpdateQuantityTickSize of in", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "17. Strict parsing of boolean CLI arguments may degrade user experience", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-19 Audit Report - Sei Chain and CosmWasm v1.0.pdf", "body": "In x/dex/client/cli/tx/tx_register_contract.go, the arguments [need the string true, which hook] and [need order matching] only check against degrades the user experience. For example, if a user capitalizes the word, the ag is going to be set to false.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "18. Inecient implementation of CancelOrders", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-19 Audit Report - Sei Chain and CosmWasm v1.0.pdf", "body": "The implementation of CancelOrders in x/dex/exchange/cancel_order.go iterates through orderbook.Longs) and cancelOrder(cancel, cancelOrder(cancel, orderbook.Shorts) for each one. This is inecient, since an order is always just in either the long or short orderbook. orders, calling all", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "19. Inecient implementation of PlaceOrders", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-19 Audit Report - Sei Chain and CosmWasm v1.0.pdf", "body": "The implementation of transferFunds within the PlaceOrders function is inecient. In x/dex/keeper/msgserver/msg_server_place_orders.go:25-29, there is a loop validating that the fund amounts are dierent from Nil. However, this iteration is redundant as the same validation is performed in line 38.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. Vesting contract allows unlimited allocation by malicious CW20 contracts", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Levana/2022-05-02 Audit Report - Levana Stage 2 v1.0.pdf", "body": "The CW20 receive hook of the vesting contract currently accepts any CW20 token. Therefore, through contracts/levana-vesting/src/contract.rs:74-95, it is possible for an attacker to create unlimited allocations using a malicious CW20 token contract that sets cw20_msg.sender to the protocols admin address. The attacker could subsequently withdraw Levana tokens once the vesting period has expired.", "labels": ["Oak Security", "Severity: High"]}, {"title": "1. Ethereum events are not correctly conrmed", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Anoma/2023-03-28 Audit Report - Namada Ethereum Bridge v1.0.pdf", "body": "Events emitted by the Ethereum smart contracts must reach a certain amount of block conrmations before validators vote to include them on Namada. An event is conrmed if the dierence between the heights of the current block and the block containing the event is greater than or equal to the required amount of conrmations. the PendingEvent::is_confirmed However, in apps/src/lib/node/ledger/ethereum_node/events.rs:206 considers a block conrmed if the required amount of confirmations is greater than or equal to the block height dierence. Thus, there are more block conrmations, the block is considered unconrmed and discarded from further processing. This leads to frozen funds in case of the TransferToNamada event. function if", "labels": ["Oak Security", "Severity: High"]}, {"title": "2. Missing replay protection for signatures", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Anoma/2023-03-28 Audit Report - Namada Ethereum Bridge v1.0.pdf", "body": "in the current validators function set are provided in the execution of the Signatures of contracts/contract/Governance.sol:42, upgradeContract upgradeBridgeContract function in contracts/contract/Governance.sol:60 and addContract function in contracts/contract/Governance.sol:77. In all three functions, messageHash gets calculated to validate the given signatures. There is no replay protection for these functions though, which implies that an attacker can use previously provided signatures to again upgrade/update the state of the contract given that the validator set during the signature creation time is the same as the attack time. For example, an attacker may replay a previous upgrade and then execute a message, which may lead to irrecoverable state inconsistencies in the contract.", "labels": ["Oak Security", "Severity: High"]}, {"title": "3. Bridging tokens from Ethereum to Namada with an invalid amount of receiver addresses will freeze escrowed funds", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Anoma/2023-03-28 Audit Report - Namada Ethereum Bridge v1.0.pdf", "body": "ERC-20 tokens are transferred from Ethereum to Namada using the transferToNamada function in contracts/Bridge.sol. The appropriate Namada receiver addresses are provided with the function parameter address[] calldata _tos. After transferring the specied tokens to the Bridge contract for escrow, an event TransferToNamada is emitted and processed by Namada validators. However, if the amount of _tos receiver addresses does not match the length of the other parameters _froms and _amounts, the event is discarded. Escrowed ERC-20 tokens for this specic token transfer transaction are locked and the user can not withdraw funds.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "4. Oracle uses an unbounded queue which might lead to out-of-memory issues", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Anoma/2023-03-28 Audit Report - Namada Ethereum Bridge v1.0.pdf", "body": "In apps/src/lib/node/ledger/ethereum_node/oracle.rs:33 in the Oracle struct the sender attribute is of type UnboundedSender. Its unbounded nature might cause an out-of-memory termination of the process in case the reader side of the channel cannot consume events as fast as the producer creates them. There might be a possibility of an attack in which a large number of events on the Ethereum side are crafted with the intention of exhausting the memory of the node.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "5. Incorrect accounting of voting power for Ethereum events", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Anoma/2023-03-28 Audit Report - Namada Ethereum Bridge v1.0.pdf", "body": "In apps/src/lib/node/ledger/shell/vote_extensions/ethereum_events.rs: 186, the voting power for events gets accounted for cumulatively rather than per event to check whether sucient votes are provided for Ethereum events by Namada validators. This allows malicious validators to successfully add invalid events. For example, an event crafted without actually locking funds in the Ethereum smart contract could be used to mint new funds on the Namada chain.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "6. The minimum number of block conrmations required to bridge ERC20 tokens from Ethereum to Namada is not enforced", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Anoma/2023-03-28 Audit Report - Namada Ethereum Bridge v1.0.pdf", "body": "Transferring ERC20 tokens to Namada by using the transferToERC function in the contracts/Bridge.sol contract emits the TransferToNamada event. This event includes the number of block conrmations that must be reached on the Ethereum chain before validators vote to include them on Namada. This number is provided by the function parameter uint256 confirmations and must be at least the protocol-specied minimum initially set to 100. However, this aforementioned invariant is not number of conrmations, enforced in the apps/src/lib/node/ledger/ethereum_node/events.rs:288. As a result, a user can circumvent the protocol-specied minimum number of conrmations, which might be exploited to double-spend funds. RawTransfersToNamada::decode function in", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "7. Slashable oense for voting on an unconrmed event is not accounted as misbehavior", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Anoma/2023-03-28 Audit Report - Namada Ethereum Bridge v1.0.pdf", "body": "slashing applying When in apps/src/lib/node/ledger/shell/mod.rs:525, EvidenceType gets matched with the SlashType. Voting on unconrmed events is considered a slashable oense according to the provided documentation, but it is not accounted for as one of the variants of EvidenceType. This allows validators to vote on unconrmed events. This issue may be abused by malicious validators to double-spend funds. validators", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "8. Validator set update protocol transactions are not validated in the process proposal phase", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Anoma/2023-03-28 Audit Report - Namada Ethereum Bridge v1.0.pdf", "body": "Transactions in newly proposed blocks are validated by all validator nodes in the in Shell::process_proposal valid apps/src/lib/node/ledger/shell/process_proposal.rs type transactions. However, contrary to properly validating protocol ProtocolTxType::EthereumEvents, type ProtocolTxType::ValidatorSetUpdate are not currently validated. transactions of transactions ensure to of", "labels": ["Oak Security", "Severity: Low"]}, {"title": "9. Unsafe use of selfdestruct", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Anoma/2023-03-28 Audit Report - Namada Ethereum Bridge v1.0.pdf", "body": "Using selfdestruct in contracts/contract/Bridge.sol:160 is not safe because ERC20 funds would be lost those funds were not withdrawn before executing the selfdestruct function. There is no inherent protection that makes sure all funds are withdrawn from the contract before selfdestruct so there is a risk of human error of misplacing an ERC20 token address within the _tokens param of withdraw function. if", "labels": ["Oak Security", "Severity: Low"]}, {"title": "10. The total size in bytes of the transactions in a block proposal can exceed the block byte size limit", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Anoma/2023-03-28 Audit Report - Namada Ethereum Bridge v1.0.pdf", "body": "Tendermint expects the application to check whether the size of all transactions exceeds the byte limit RequestPrepareProposal.max_tx_bytes, which by default to 1048576 bytes. If so, the application must remove transactions at the end of the list until the implementation of total byte size is at or below the limit. However, in Shell::prepare_proposal not apps/src/lib/node/ledger/shell/prepare_proposal.rs:48-57 enforce this limit. Therefore, if the transaction byte size limit surpasses the limit, Tendermint will reject the block. the current is set does For more details, see requirement number 2 in Tendermints' formal requirements.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "11. Smart contract hub can upgrade contracts to an already used contract address", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Anoma/2023-03-28 Audit Report - Namada Ethereum Bridge v1.0.pdf", "body": "The contracts/Hub.sol contract holds references to the addresses of the latest contract version. Contracts are upgraded to a newer address with the upgradeContract function. However, the current implementation does not verify if the Hub contract already uses the new contract address. Even though there is no immediate security implication, upgrading to an already used contract address should be prevented, similar to how it is implemented in the addContract function.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "12. The minimum number of conrmations needed to trust an Ethereum branch should be set to 100", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Anoma/2023-03-28 Audit Report - Namada Ethereum Bridge v1.0.pdf", "body": "According to the specs, TransferToNamada events may include a custom minimum number of conrmations, which must be at least the protocol-specied minimum number of conrmations to 100. However, MIN_CONFIRMATIONS in apps/src/lib/node/ledger/ethereum_node/oracle.rs:19 is currently set to 50, deviating from the specs. initially but set is", "labels": ["Oak Security", "Severity: Low"]}, {"title": "13. Less than half of the available wrapped transactions from the mempool are potentially included in a proposal", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Anoma/2023-03-28 Audit Report - Namada Ethereum Bridge v1.0.pdf", "body": "A block proposer anticipates including half of the available wrapped transactions from the mempool in a new block proposal. However, the Shell::build_mempool_txs function in takes apps/src/lib/node/ledger/shell/prepare_proposal.rs:136-148 rst half of the transactions in txs: Vec<Vec<u8>> and then lters the transactions to only include TxType::Wrapper transactions. In case there are non-wrapper transactions in this batch of taken transactions, the block will include less than half of the anticipated wrapped transactions from the mempool.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "14. Include a check to ensure that a transfer is sent only if the slashed_amount is greater than 0", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Anoma/2023-03-28 Audit Report - Namada Ethereum Bridge v1.0.pdf", "body": "In apps/proof_of_stake/src/lib.rs:881 the transfer method is regardless of the amount being slashed. called", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "15. Instance of potential integer overow on arithmetic operations", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Anoma/2023-03-28 Audit Report - Namada Ethereum Bridge v1.0.pdf", "body": "the calculating When apps/src/lib/node/ledger/shell/vote_extensions/ethereum_events.rs: 186 there is no check for arithmetic overow. In the event of an overow, events that should be part of ethereum_events::VextDigest will otherwise be ignored. However, this event seems unlikely to ever happen, since the total voting power is greater than the sum of the validator voting powers. validator_voting_power in", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "16. Typographical error", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Anoma/2023-03-28 Audit Report - Namada Ethereum Bridge v1.0.pdf", "body": "In TransactionGasExceedededError has a spelling mistake. shared/src/ledger/gas.rs:13, the enum variant", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. Late depositors would get the same amount of dividend as early depositors, causing an unfair dividend allocation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Kinetic/2022-04-07 Audit Report - Kinetic v1.0.pdf", "body": "In contracts/core/phaser/src/contract.rs:211, new users that stake their kUST tokens will have their last_dividend_points set to 0. This is problematic since the value of last_dividend_points is used to determine the amount of dividends a user is entitled to claim as seen in contracts/core/phaser/src/util.rs:72-78. This would cause late depositors to claim the same dividend allocation as early depositors, resulting in unfair dividend allocation and possibly insucient funds in the contract. is also issue present in This of contracts/core/vault/src/contract.rs:262. last_accumulated_yield_weight is used to calculate the yield users are entitled to earn in contracts/core/vault/src/cdp.rs:40-53. As above, late depositors would be able to claim more yield than intended. contract value vault Here, the the in", "labels": ["Oak Security", "Severity: High"]}, {"title": "2. Malicious users can trick the system into receiving more yield than entitled", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Kinetic/2022-04-07 Audit Report - Kinetic v1.0.pdf", "body": "In contracts/core/vault/src/contract.rs:252-256, existing depositors will have their cdp.total_deposited value increased based on the amount they deposited without allocating the yield beforehand. This is problematic because the yield earned is based on the user's deposited amount as seen in contracts/core/vault/src/cdp.rs:50. Consequently, a malicious user can deposit funds repeatedly into the vault contract and withdraw them after some time to claim more yield than they should have received.", "labels": ["Oak Security", "Severity: High"]}, {"title": "3. Users are unable to withdraw all funds from vault contract", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Kinetic/2022-04-07 Audit Report - Kinetic v1.0.pdf", "body": "Users are able to call the Redeem message in order to withdraw UST or aUST from the vault contract. Before that, the users collateral debt position (CDP) is checked to verify the user's position is not undercollateralized. However, users will be unable to withdraw the max available amount of funds since the is_cdp_healthy_after_withdraw function veries that using Decimal256::from_ratio as seen in contracts/core/vault/src/cdp.rs:21. If the user attempts to withdraw all available funds, the value passed would become 0 and eventually cause a division by 0 panic. collateralization users CDP lower than limit the the by is", "labels": ["Oak Security", "Severity: High"]}, {"title": "4. Updating users collateral debt position causes loss of yield", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Kinetic/2022-04-07 Audit Report - Kinetic v1.0.pdf", "body": "In contracts/core/vault/src/cdp.rs:29, users cdp.total_credit value is updated when the earned yield is higher than users debt. If the user has an existing cdp.total_credit balance, it would be overwritten due to the latest value being directly set instead of increased along with the existing balance. This would cause a portion of the users earned yield to be stuck in the contract.", "labels": ["Oak Security", "Severity: High"]}, {"title": "5. Users are unable to withdraw funds once phaser is started", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Kinetic/2022-04-07 Audit Report - Kinetic v1.0.pdf", "body": "the update_account function In contracts/core/phaser/src/util.rs:63, attempts to deduct users entitled dividend from cfg.unclaimed_div value. This value can only be increased when theres an increase in UST allocations as seen in line 54. However, the increased amount comes from cfg.total_div which means the amount will never be enough to deduct users entitled dividend, which will cause an underow error. To illustrate the scenario: 1. Alice stakes user.deposited_synth_tokens cfg.total_deposited_synth_tokens to be 100. kUST via ReceiveMsg::Stake, this would cause and 2. 200 UST is sent via Distribute message which causes cfg.total_deposited_base_tokens and cfg.buffer to be 200. 3. Bob decides to stake 50 kUST which would cause run_phaser to execute. Assuming cfg.phase_period has passed, the contract will enter line 53-54 with cfg.total_div and cfg.unclaimed_div value as 2 (200/100 = 2). 4. At this point, theres a high possibility that no one can withdraw their funds since the phaser is executed. update_account. 5. Alice decides to withdraw her tokens by calling ExecuteMsg::Unstake which will call from dividends_owing function would be 200 (100*2 = 200, see lines 73-75). Since the value of cfg.unclaimed_div is 2 while the owing value is 200, this would cause an underow error in line 63. returned amount owing result, the In This issue also aects other entry points that call update_account function, which are Phase, Stake, and Unstake.", "labels": ["Oak Security", "Severity: High"]}, {"title": "6. More synthetic tokens are burned than intended", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Kinetic/2022-04-07 Audit Report - Kinetic v1.0.pdf", "body": "In contracts/core/phaser/src/contract.rs:376, the amount of synthetic tokens burned depends on the balance of user.realized_tokens and not on the currently phased amount. This would cause more synthetic tokens being burned than the intended amount, which opens the possibility that there are not enough synthetic tokens in the phaser contract. As a result, this would cause a loss of funds for the protocol.", "labels": ["Oak Security", "Severity: High"]}, {"title": "7. Claim message in phaser contract withdraws more UST than the user should own, leading to a loss of funds for other users", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Kinetic/2022-04-07 Audit Report - Kinetic v1.0.pdf", "body": "In contracts/core/phaser/src/contract.rs:309-313, when a user decides to claim their phased UST, the contract withdraws the amount in aUST without calculating the exchange rate. Due to the fact that aUST usually trades above UST, this may lead to a withdrawal of a greater amount of UST from the adapter than the user should be able to claim. This causes a loss of funds for the whole protocol.", "labels": ["Oak Security", "Severity: High"]}, {"title": "8. Anchor exchange rate used might be out of date due to missing block height argument", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Kinetic/2022-04-07 Audit Report - Kinetic v1.0.pdf", "body": "The Anchor exchange rate is queried from the Anchor contracts, through the utility function epoch_state, in contracts/core/adapters/anchor/src/msg.rs:102-114. However, no block height argument the block height argument, Anchor returns a raw exchange rate from stored values without accruing interest since the last update, which means an outdated exchange rate is returned. Using this value could lead to slightly incorrect calculations. is supplied. Without dened", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "1. Decimal places inconsistency between deposit and withdrawals", "html_url": "https://github.com/oak-security/audit-reports/tree/master/BrainTrust/Audit Report - BrainTrust Application.pdf", "body": "Amounts are interpreted dierently in deposit and withdrawal operations. The underlying token contract uses 18 decimal places. However, deposit and withdrawal requests use 0 and 18 decimal places for the amounts specied. This may lead to confusion for integrators which may cause bugs. In addition, the total amount is limited to 50 digits, whilst the underlying token contract technically allows for 78 digit numbers (in decimal representation). This is unlikely to cause any issue in practice since such large numbers will not occur.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "2. Number of blocks required for deposits to be conrmed is relatively small", "html_url": "https://github.com/oak-security/audit-reports/tree/master/BrainTrust/Audit Report - BrainTrust Application.pdf", "body": "The smart contract integration conrms events through event ltering transfer events. The constant REQUIRED_NUMBER_OF_BLOCK_CONFIRMATIONS is used to congure a limit of block conrmations that need to have occurred before such a deposit is considered conrmed. By default this is set to 6 block conrmations, This number is relatively small and corresponds to the number of conrmations usually used in Bitcoin. In Ethereum higher numbers are usually recommended, due to the lower block time. Major exchanges require 20 or even 50 blocks.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "3. Ethereum address elds can be longer than required", "html_url": "https://github.com/oak-security/audit-reports/tree/master/BrainTrust/Audit Report - BrainTrust Application.pdf", "body": "The character limit specied for Ethereum addresses in ethereum/models is 200 characters. However, an Ethereum address expressed as a string in its standard format is 42 characters long (including leading 0x). Whilst this is not a security list, allowing the API to store and receive longer addresses could cause confusion or make the system more error-prone by allowing extra data to be received.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "4. Leaked API keys in source code", "html_url": "https://github.com/oak-security/audit-reports/tree/master/BrainTrust/Audit Report - BrainTrust Application.pdf", "body": "Several les are found to contain API keys and secrets, namely: - - - - .gitlab/gitlab_runner/runner1-cong/cong-template.toml avbox/app/routes.py backend/cong/settings/common.py backend/cong/settings/dev.py Depending on the API key usage and validity, a malicious user can abuse a leaked API key to cause damage to the overall project.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "5. Websocket connection can be initiated by anyone", "html_url": "https://github.com/oak-security/audit-reports/tree/master/BrainTrust/Audit Report - BrainTrust Application.pdf", "body": "When initiating a WebSocket connection, there is no CSRF protection implemented. A malicious user can start a WebSocket connection and send arbitrary WebSocket messages as the victim. The impact of this issue depends on the implementation of the WebSocket itself. This is unlikely to be exploited since the SameSite Cookies which are set to Lax are preventing it. However, theres still a risk for users that use outdated browsers.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "6. backend/apps/common/zoom/client.py: Meeting duration always calculated as zero", "html_url": "https://github.com/oak-security/audit-reports/tree/master/BrainTrust/Audit Report - BrainTrust Application.pdf", "body": "In line 61 the following expression is used to calculate a meeting duration: duration = event.time_slot.end_time - event.time_slot.end_time This will always result in zero.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "7. backend/apps/pages/views.py: context key INVOICE_STATUS set twice", "html_url": "https://github.com/oak-security/audit-reports/tree/master/BrainTrust/Audit Report - BrainTrust Application.pdf", "body": "The eld is set twice (line 157 and line 188).", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. Using non-prexed addresses in storage keys can lead to key collisions, allowing exploits to overwrite data", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Interchain Foundation/2022-07-20 Audit Report - Liquidity Staking Cosmos SDK Modules v1.0.pdf", "body": "The key returned by the GetTokenizeShareRecordIdByOwnerAndIdKey function in x/staking/types/keys.go contains an address that length prexed. Since addresses could have variable lengths, key collisions are possible if the storage key contains a non-prexed address followed by another component. This could lead to accidental collisions and could be exploited by an attacker to deliberately overwrite existing data at a target storage location. is not", "labels": ["Oak Security", "Severity: High"]}, {"title": "2. Tokenization of a delegation and selling the shares allows evasion of slashes", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Interchain Foundation/2022-07-20 Audit Report - Liquidity Staking Cosmos SDK Modules v1.0.pdf", "body": "a is the in no delegation in When tokenized x/staking/keeper/msg_server.go, or Redelegation entry is created, but the current delegation is immediately unbonded and a new delegation the from the module TokenizeShareRecord. This implies that the previous delegator will not be subject to slashing for infractions that happened before the tokenization. Instead, slashes are now applied to the module address associated with the TokenizeShareRecord. UnbondingDelegationEntry TokenizeShares associated with function address created is Since Cosmos SDK applies slashes for past infractions to all currently bonded tokens, this is not an issue, as long as the previous delegator owns the created share tokens. The previous delegator might have an incentive though to sell share tokens quickly if they are aware of a pending slashing event. If there is information asymmetry between the share token holder and a potential buyer, a delegator can use this mechanism to evade slashing. An example of this could be a validator that equivocated but has not published the double-signed block. Rational buyers would therefore not buy any token shares before the UnbondingTime passed but not all buyers can be assumed to be rational. We consider this issue to be major, because it can be used to circumvent one of the fundamental features of proof of stake blockchains.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "3. Withdrawal of tokenized share record rewards is unbounded, owner can be grieved by an attacker", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Interchain Foundation/2022-07-20 Audit Report - Liquidity Staking Cosmos SDK Modules v1.0.pdf", "body": "WithdrawTokenizeShareRecordReward The in x/distribution/keeper/keeper.go contains an unbounded iteration over all TokenizeShareRecord of an owner, which may run out of gas if too many entries exist. This may happen unintentionally. function Even worse, since it is possible to transfer ownership of a record to any other address, an attacker can create many low-value TokenizeShareRecords and transfer ownership of them to relevant the TokenizeShareRecords to another account to resolve this issue, it allows the attacker to grieve the owner. owner. While transfer owner target target can a The same issue exists in the TokenizeShareRecordReward query function in x/distribution/keeper/grpc_query.go.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "4. Several errors are not checked", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Interchain Foundation/2022-07-20 Audit Report - Liquidity Staking Cosmos SDK Modules v1.0.pdf", "body": "In several places in the codebase, errors are not checked, and execution continues even if operations failed. This may cause an inconsistent state  a message handler may succeed and write changes to storage even though some operations failed. Instances of not checked errors are in: a) x/distribution/module.go:73: Error return value types.RegisterQueryHandlerClient is not checked b) x/distribution/module.go:146: Error return value cfg.RegisterMigration is not checked c) x/distribution/types/msg.go:183: sdk.AccAddressFromBech32 is not checked Error return value d) x/staking/genesis.go:43: Error return value keeper.SetValidatorByConsAddr is not checked e) x/staking/module.go:79: return types.RegisterQueryHandlerClient is not checked Error value of of of of of f) x/staking/module.go:143: Error return value of cfg.RegisterMigration is not checked g) x/distribution/types/msg.go:183: Error return value sdk.AccAddressFromBech32 is not checked h) x/staking/keeper/msg_server.go:100: k.SetValidatorByConsAddr is not checked i) x/staking/keeper/msg_server.go:457: k.ValidateUnbondAmount is not checked j) x/staking/keeper/msg_server.go:477: k.AddTokenizeShareRecord is not checked k) x/staking/keeper/msg_server.go:550: k.DeleteTokenizeShareRecord is not checked m) x/staking/types/msg.go:380: l) x/staking/keeper/msg_server.go:598: sdk.AccAddressFromBech32 is not checked Error sdk.AccAddressFromBech32 is not checked Error sdk.AccAddressFromBech32 is not checked n) x/staking/types/msg.go:414: Error return value Error return value Error return value Error return value Error return value return value return value of of of of of of of of o) x/staking/types/msg.go:442: Error sdk.AccAddressFromBech32 is not checked return value of p) x/slashing/genesis.go:19: Error return value of keeper.AddPubkey is not checked q) x/slashing/module.go:81: Error return value of types.RegisterQueryHandlerClient is not checked r) x/slashing/module.go:144: Error return value of cfg.RegisterMigration is not checked s) x/slashing/keeper/hooks.go:35: Error return value of k.AddPubkey is not checked t) x/slashing/keeper/hooks.go:69: Error return value of h.k.AfterValidatorCreated is not checked", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "5. Tokenize share record reward query does not include automatically withdrawn rewards", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Interchain Foundation/2022-07-20 Audit Report - Liquidity Staking Cosmos SDK Modules v1.0.pdf", "body": "TokenizeShareRecordReward The x/distribution/keeper/grpc_query.go does withdrawn rewards that have been sent to the TokenizeShareRecords module account. in automatically query not function account for", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "6. Share token denoms may be all lower- or all upper-cased, depending on user input", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Interchain Foundation/2022-07-20 Audit Report - Liquidity Staking Cosmos SDK Modules v1.0.pdf", "body": "The getShareTokenDenom function in x/staking/keeper/msg_server.go creates the denom for new share tokens through concatenation of the user-supplied validator address and a unique ID. The validator address is taken without transformations from the users input. Since Bech32 addresses are valid in either all upper or all lower case, there can be two valid denoms for the same share tokens. While this has not been found to cause any security issues in the current implementation, it may create problems for applications integrating with this module or lead to issues when further logic is added in the future.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "7. Usage of panics for control ow is bad practice", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Interchain Foundation/2022-07-20 Audit Report - Liquidity Staking Cosmos SDK Modules v1.0.pdf", "body": "In several places in the codebase, panics are used for control ow. While this is no security issue since transactions recover from panics in Cosmos SDK, this may lead to problems in the future. For example, a caller of keeper functions may try to handle errors, while the function panics instead. Instances of panic usage for control ow can be found in: a) x/distribution/keeper/allocation.go:33 b) x/distribution/keeper/delegation.go:35, 40, 48 and 127 c) x/distribution/keeper/hooks.go:50 and 97 d) x/distribution/keeper/invariants.go:87 e) x/distribution/keeper/keeper.go:38 f) x/distribution/keeper/store.go:51 and 70 g) x/distribution/keeper/validator.go:70, 80 and 92 h) x/distribution/types/keys.go:65, 79, 94, 108, 122 and 136 i) x/distribution/types/msg.go:35, 72, 107 and 146 j) x/slashing/keeper/infractions.go:19 and 25 k) x/slashing/keeper/signing_info.go:109, 121 and 125 l) x/slashing/types/msg.go:28 m) x/staking/keeper/alias_functions.go:68 n) x/staking/keeper/delegation.go:96, 108, 202, 208, 219, 225, 400, 407, 411, 459, 464, 468, 574, 582, 593, 614 and 717 o) x/staking/keeper/invariants.go:63 and 106 p) x/staking/keeper/keeper.go:42, 46 and 67 q) x/staking/keeper/pool.go:23 and 31 r) x/staking/keeper/querier.go:493, 497 and 502 s) x/staking/keeper/query_utils.go:26, 47, 112 and 116 t) x/staking/keeper/slash.go:29, 54, 70, 128, 132, 135, 208, 251, 256, 259, 271, 276, 287, 292 and 296 u) x/staking/keeper/val_state_change.go:30, 41, 45, 67, 71, 75, 139, 165, 233, 241, 249, 258, 267, 278 and 319 v) x/staking/keeper/validator.go:29, 50, 158, 162, 167, 316, 414, 427, 431 and 435 w) x/staking/types/authz.go:44 x) x/staking/types/delegation.go:51, 66, 73, 151 and 246 y) x/staking/types/historical_info.go:33 z) x/staking/types/keys.go:96 aa) x/staking/types/msg.go:75, 80, 179, 236, 290 and 345 bb) cc) x/staking/types/validator.go:154, 262, 276, 381, 396, 400, 426 and 466 x/staking/types/params.go:94", "labels": ["Oak Security", "Severity: Low"]}, {"title": "8. Addresses are not properly validated, which may cause panics and unexpected behavior", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Interchain Foundation/2022-07-20 Audit Report - Liquidity Staking Cosmos SDK Modules v1.0.pdf", "body": "This validation. The ValidateBasic method, in x/distribution/types/msg.go:47, includes basic address the DelegatorAddress or the WithdrawAddress provided is empty, but does not validate whether if msg.DelegatorAddress=' ', this check would not return an error, producing further panics and expected behavior. is a correctly formatted Bech32 string. As an example, validation only and raises the input checks error an if", "labels": ["Oak Security", "Severity: Low"]}, {"title": "9. Dierent tokens for share records of the same validator can have dierent exchange rates after slashing", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Interchain Foundation/2022-07-20 Audit Report - Liquidity Staking Cosmos SDK Modules v1.0.pdf", "body": "The staking module creates distinct TokenizeShareRecords whenever a user tokenizes a delegation. These share records have all unique denoms, and their tokens are not fungible with each other, even if the validator is the same. While this simplies the architecture of the module, it implies that the exchange rate between such records starts to diverge over time, specically when tokens are minted after slashing occured. The reason for this is that during the TokenizeShares function in x/staking/keeper/msg_server.go:454, shares are minted without considering the current exchange rate of previous share records. As an example, suppose 1000 ATOM are delegated, of which 500 ATOM are tokenized in record 1. There exist now 500 val...1 tokens. Now suppose a 10% slash happens, such that there are only 900 ATOM in the delegation, and the 500 val...1 tokens are only worth 450 ATOM. If now another 200 ATOM of the same delegation are tokenized in record 2, there will be 200 val...2 tokens. As a result: - - val...1 tokens have an exchange rate of 0.9 ATOM/val...1, while val...2 tokens have an exchange rate of 1 ATOM/val...2. This is not a direct security concern, but may confuse users and lead to problems if protocols built on top of the Liquidity Staking Cosmos SDK module do not consider these dierences properly.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "10. Staking rewards are decoupled from share token holders", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Interchain Foundation/2022-07-20 Audit Report - Liquidity Staking Cosmos SDK Modules v1.0.pdf", "body": "The current architecture separates holders of a tokenized delegation and the recipient of rewards for that delegation. A holder of share record tokens is not eligible for any rewards, instead these rewards accumulate in one single account per tokenized share record. The reward recipient is specied as the TokenizedShareOwner in the TokenizeShares function. It can be transferred using the TransferTokenizeShareRecord function. While this is not a security concern, it may be unexpected that share record tokens do not contain eligibility for rewards.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "11. Lack of event emission is bad practice", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Interchain Foundation/2022-07-20 Audit Report - Liquidity Staking Cosmos SDK Modules v1.0.pdf", "body": "TokenizeShares, The TransferTokenizeShareRecord message handlers in x/staking/keeper/msg_server.go do currently not emit any events. The Unjail message handler in x/slashing/keeper/msg_server.go does emit an event, but does not include information about the action (unjailing). RedeemTokens and Emitting events is a best practice, since it allows o-chain subscribers/indexers to track events.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "12. Tokenized share record related transactions and queries are only available via CLI, not REST", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Interchain Foundation/2022-07-20 Audit Report - Liquidity Staking Cosmos SDK Modules v1.0.pdf", "body": "Transaction and query functionality for tokenized share records have been added to the CLI in x/distribution/client/cli/tx.go, x/distribution/client/cli/query.go, x/staking/client/cli/tx.go and x/staking/client/cli/query.go, but not to the x/distribution/client/rest/tx.go, x/distribution/client/rest/query.go, x/staking/client/rest/tx.go and x/staking/client/rest/query.go. interfaces REST in", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "13. Storing the Id in TokenizeShareRecord is inecient", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Interchain Foundation/2022-07-20 Audit Report - Liquidity Staking Cosmos SDK Modules v1.0.pdf", "body": "The TokenizeShareRecord contains the Id of the record. That is unnecessary since every lookup of the record implies that the ID is known, since its part of the key.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "14. Storing the ShareTokenDenom in TokenizeShareRecord is inecient", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Interchain Foundation/2022-07-20 Audit Report - Liquidity Staking Cosmos SDK Modules v1.0.pdf", "body": "The TokenizeShareRecord contains the ShareTokenDenom of is unnecessary, since the ShareTokenDenom can be derived from the stored Validator and Id. the record. That", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "15. Specication is outdated", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Interchain Foundation/2022-07-20 Audit Report - Liquidity Staking Cosmos SDK Modules v1.0.pdf", "body": "The specication is outdated in several ways: a) x/staking/spec/01_state.md is missing an entry for 0x64 for LastTokenizeShareRecordIdKey. b) x/staking/spec/* still describes queues, which have been removeg from the module.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "16. Unused code negatively impacts maintainability", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Interchain Foundation/2022-07-20 Audit Report - Liquidity Staking Cosmos SDK Modules v1.0.pdf", "body": "The code base contains unused code. Unused code increases the code size and hence inhibits maintainability. Instances of unused code are: a) The NewStakeAuthorization function in x/staking/types/authz.go. b) The AllInvariants function in x/distribution/keeper/invariants.go. c) The AllInvariants function in x/staking/keeper/invariants.go. d) The ValidatePowerReduction function in x/staking/types/params.go.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. parser.go: Incorrect prex comparison in function EthereumEventToEthBridgeClaim()", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sifchain/Audit Report - Sifchain [20210706].pdf", "body": "On line 56, contains defaultEthereumPrefix, but does not actually verify that it starts with it. function EthereumEventToEthBridgeClaim() only checks that symbol", "labels": ["Oak Security", "Severity: Low"]}, {"title": "2. x/clp/keeper/Calculations.go: Token decimal adjustment is always executed", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sifchain/Audit Report - Sifchain [20210706].pdf", "body": "In functions calcLiquidityFee() and calcSwapResult(), there are checks to see if the number of decimals of external tokens needs to be normalized. However, the actual adjustment code is executed in either case, due to the following incorrect if statement: if adjustExternalToken { if toRowan { X = X.Mul(sdk.NewUintFromBigInt(normalizationFactor.RoundInt().BigInt())) x = x.Mul(sdk.NewUintFromBigInt(normalizationFactor.RoundInt().BigInt())) } else { Y = Y.Mul(sdk.NewUintFromBigInt(normalizationFactor.RoundInt().BigInt())) } } else { if toRowan { X = X.Mul(sdk.NewUintFromBigInt(normalizationFactor.RoundInt().BigInt())) x = x.Mul(sdk.NewUintFromBigInt(normalizationFactor.RoundInt().BigInt())) Y = Y.Mul(sdk.NewUintFromBigInt(normalizationFactor.RoundInt().BigInt())) } else { } }", "labels": ["Oak Security", "Severity: Low"]}, {"title": "3. Outdated indirect dependency with multiple known security vulnerabilities", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sifchain/Audit Report - Sifchain [20210706].pdf", "body": "The codebase uses an outdated version of the ecdt library (versions 3.3.13). This version includes a number of known vulnerabilities, including TLS authentication issues, TCP proxy discovery issues, and missing password length verications.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "4. Consider using a mock address for ETH", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sifchain/Audit Report - Sifchain [20210706].pdf", "body": "In the contracts, for referencing an ETH value transfer the token address is set to 0x0, however, this is already the default value mappings. While there's no security implication as is, a better option would be to choose a mock address for ETH, like 0xeeeee.... to avoid any possible confusion with uninitialized addresses.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "5. Node package inclusion in Solidity les breaks build system", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sifchain/Audit Report - Sifchain [20210706].pdf", "body": "The smart contract course les include OpenZeppelin dependencies imported as npm packages with relative path names. For example: import \"../../node_modules/openzeppelin-solidity/contracts/math/SafeMath.sol\"; This breaks the functionality of most up-to-date development frameworks, including True used in the project, leading to the project not currently building on a clean installation.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "6. Provide formal documentation on why the number 30 Ethereum blocks were chosen as safe enough nality for Sifchain", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sifchain/Audit Report - Sifchain [20210706].pdf", "body": "Provide more explicit documentation of the security assumptions that made Sifchain arrive at the fact that 30 blocks are safe nality for the purposes of the Sifchain application", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "7. Missing default case in switch statement", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sifchain/Audit Report - Sifchain [20210706].pdf", "body": "switch The data cmd/ebrelayer/relayer/ethereum.go:158-168 is lacking a default case. always recommended to add default cases for clarity and dealing with unexpected data. processing statement Ethereum event for in is It", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. Unbounded dictionary records might cause denial of service", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Celer/2022-05-14 Audit Report - Celer cBridge Flow v1.0.pdf", "body": "In contracts/PegBridge.cdc:86, the records dictionary is used to record existing minting and burning hash identiers as seen in lines 223 and 263. While recording the identiers on-chain are required to prevent replay attacks, this would cause the accounts If the account doesnt hold enough Flow tokens storage capacity to increase limitlessly. proportional to the increased storage capacity, this would cause new transactions to fail as it would put the account over its storage capacity. This issue is also found in contracts/SafeBox.cdc in lines 149 and 185 where it holds the deposit and withdrawal hash identiers.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "2. Adding delay transfer should not be allowed when the contract is paused", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Celer/2022-05-14 Audit Report - Celer cBridge Flow v1.0.pdf", "body": "In contracts/DelayedTransfer.cdc:73, through the executeDelayXfer function is allowed even if the contract is paused. If a catastrophic adding delay transfers event happens, users may continuously get exploited since new delay transfers can still be added while most other functionalities in the contract are inaccessible.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "3. Public keys are not validated when updating or resetting signers", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Celer/2022-05-14 Audit Report - Celer cBridge Flow v1.0.pdf", "body": "In contracts/cBridge.cdc:36, the passed signers public keys are directly set without verifying whether the public keys are valid and conform to the hardcoded signature algorithm which is ECDSA_secp256k1. If an invalid public key or a public key with a dierent signature algorithm is passed, the public key construction in lines 61 to 64 would fail, potentially in the causing the whole cBridge contract updateSigners function in lines 157-172. to be unusable. This issue is also present We consider this to be a minor issue since it can only be caused by the admin or existing signers.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "4. Duplicate public keys are not removed", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Celer/2022-05-14 Audit Report - Celer cBridge Flow v1.0.pdf", "body": "In contracts/cBridge.cdc:36, the passed signers public keys are directly set without verifying whether they are duplicates or not. If a public key is twice in the signers dictionary, the signature validation can be replayed and potentially allow the signer to hold more signing power than intended. This issue is also present in the updateSigners function from in lines 157-172. We consider this to be a minor issue since it can only be caused by the admin or existing signers.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "5. Missing logic validations during struct initialization might cause temporary denial of service", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Celer/2022-05-14 Audit Report - Celer cBridge Flow v1.0.pdf", "body": "In contracts/PegBridge.cdc:52-53, the TokenCfg structs minBurn and maxBurn values are not validated. Specically, the minimum burn amount should be validated to be lower than the maximum burn amount while the maximum burn amount should be validated to be higher than the minimum burn amount if the value is not 0. If the values are initialized incorrectly, the burn function would fail in lines 255-258. This issue is also found present in contracts/SafeBox.cdc from lines 49-50. We consider this to be a minor issue since it can only be caused by the admin.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "6. Sensitive resources can easily be shared and not revoked", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Celer/2022-05-14 Audit Report - Celer cBridge Flow v1.0.pdf", "body": "Throughout the codebase, every admin resource has a createXAdmin method (where X is a placeholder for the resource) that allows the existing resource to create a new admin resource in contracts/SafeBox.cdc:114-116). Due to this, admin resource ownership can be provided to multiple accounts, which increases the attack surface. Admin permissions cannot be revoked in the current implementation, which exacerbates the issue. assigned account another (e.g. that can be to", "labels": ["Oak Security", "Severity: Low"]}, {"title": "7. Misconguration of chain identier values might lead to replay attack possibility", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Celer/2022-05-14 Audit Report - Celer cBridge Flow v1.0.pdf", "body": "In contracts/PegBridge.cdc:190 and contracts/SafeBox.cdc:122, the chain identier values use the chID argument, which is supplied by the contract instantiator. That argument is concatenated with the contracts address and name in the next line. Since the chain identier is solely based on what value the contract instantiator provides, this will open up a replay attack possibility if the same chain identier is used across multiple deployments, for example on mainnet and testnet. As a result, this would cause the domainPrefix value to be the same across the mainnet and testnet contracts (assuming the same contract address and name), potentially allowing an attacker to replay mint and withdrawal operations in contracts/PegBridge.cdc:213-214 and contracts/SafeBox.cdc:172-173. We consider this issue to be minor since it would only occur if the contract instantiator instantiated the chain identiers incorrectly.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "8. Token receiving capability may not exist, which leads to failure of deposits", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Celer/2022-05-14 Audit Report - Celer cBridge Flow v1.0.pdf", "body": "In contracts/SafeBox.cdc:151, the capability for receiving funds gets accessed. There is no validation though to ensure self.account has the public capability stored at tokenCfg.vaultPub. As a result, the deposit operation would fail every time for the specic whitelisted token.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "9. Delay threshold check should use greater than or equal symbol", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Celer/2022-05-14 Audit Report - Celer cBridge Flow v1.0.pdf", "body": "In contracts/PegBridge.cdc:229 and contracts/SafeBox.cdc:191, the if statement check uses the greater than symbol > to determine whether the mint or withdrawal amount is required to be delayed. As any amount that reaches the delay threshold should be delayed, the check should include equality of the amounts.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. MsgInstantiateOracle is not registered", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stride/2023-08-20 Audit Report - Stride ICA Oracle v1.0.pdf", "body": "In stride:x/icaoracle/types/codec.go:18, MsgInstantiateOracle is not registered as a concrete implementation of the sdk.Msg interface. While there are no issues when executing a MsgInstantiate transaction message without the registration, an error will occur if a transaction message contains code that involves marshaling or unmarshalling an unregistered message.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "2. Amino codec must be registered to support end users with hardware devices like Ledger", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stride/2023-08-20 Audit Report - Stride ICA Oracle v1.0.pdf", "body": "In stride:x/icaoracle/types/codec.go:33, Amino should be used to register all interfaces and concrete types for the icaoracle module. This is necessary for legacy binary and JSON serialization to support hardware devices like Ledger since these devices do not support proto transaction signing.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "3. Missing GenesisState validation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stride/2023-08-20 Audit Report - Stride ICA Oracle v1.0.pdf", "body": "In stride:x/icaoracle/keeper/genesis.go:11, InitGenesis is missing genesis state validation. Without validation, miscongurations may go unnoticed and might eventually be dicult to correct.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "4. Governance can activate invalid oracles", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stride/2023-08-20 Audit Report - Stride ICA Oracle v1.0.pdf", "body": "In stride:x/icaoracle/keeper/gov/gov.go:11-13, the ToggleOracle function can be called by governance to enable or disable any oracles. However, no validation ensures that the oracle already has a contract instantiated on the host chain and the channel is still active. Enabling such invalid oracles is inecient.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "5. Removing oracles does not remove associated metrics", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stride/2023-08-20 Audit Report - Stride ICA Oracle v1.0.pdf", "body": "In stride:x/icaoracle/keeper/gov/gov.go:16-24, the RemoveOracle function can be called by governance to remove any oracle as long as it exists in the storage. However, no validation ensures that the metrics associated with the oracles are removed too. If a channel times out and governance removes the oracle, the pending metrics will remain forever in the storage in an IN_PROGRESS state.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "6. Oracles cannot be added again if they have an active channel and are removed through governance", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stride/2023-08-20 Audit Report - Stride ICA Oracle v1.0.pdf", "body": "In stride:x/icaoracle/keeper/gov/gov.go:16-24, the RemoveOracle function can be called by governance to remove any oracle as long as it exists in storage. However, if governance removed OracleChainId while the channel is still active, the chain identier cannot be added back through the AddOracle function. This is due the error occurring in stride:x/icaoracle/keeper/msg_server.go:85 because the channel would still be active. Since interchain account channels cannot be closed manually by users, the oracle for the specic chain id cannot be added back anymore.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "7. RestoreOracleICA does not ensure that channel is closed", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stride/2023-08-20 Audit Report - Stride ICA Oracle v1.0.pdf", "body": "RestoreOracleICA The in stride:x/icaoracle/keeper/msg_server.go:150 does not explicitly check to ensure that the channel for the requested oracle is closed. If the channel is closed an error should be returned. this function is called for an open channel RegisterInterchainAccount will fail later in the functions execution, but will not return an error that clearly communicates its cause. In the case that function", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "8. Duplicated ValidateBasic invocation in CLI", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stride/2023-08-20 Audit Report - Stride ICA Oracle v1.0.pdf", "body": "CLI commands transaction All stride:x/icaoracle/client/cli/tx.go:19 stride:x/icaoracle/client/cli/gov.go:55 function before calling GenerateOrBroadcastTxCLI. registered in the GetTxCmd function in and msg.ValidateBasic call the As msg.ValidateBasic is already called inside the GenerateOrBroadcastTxCLI function this is a duplicated invocation, which is inecient.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "9. Incorrect usage message for GetCmdQueryOracle command", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stride/2023-08-20 Audit Report - Stride ICA Oracle v1.0.pdf", "body": "usage message in The stride:x/icaoracle/client/cli/query.go:47 is incorrect. The command expects to receive exactly one argument holding the chain id, but the usage message is not describing this. GetCmdQueryOracle command for", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "10. Unused code", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stride/2023-08-20 Audit Report - Stride ICA Oracle v1.0.pdf", "body": "Across the codebase, locations. Unused code decreases the maintainability of the codebase. instances of unused errors and functions exist in the following  ErrMarshalFailure in stride:x/icaoracle/types/error.rs:18  ErrUnmarshalFailure in stride:x/icaoracle/types/error.rs:19  CWTemplateContract in cw-ica-oracle:src/helpers.rs:10-27", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "11. Events are not always emitted", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stride/2023-08-20 Audit Report - Stride ICA Oracle v1.0.pdf", "body": "There are multiple functions within the scope of this audit that do not emit events or attributes. It is best practice to emit events and attributes to improve the usability of the contracts and to support o-chain event listeners and blockchain indexers. The following functions do not emit events or attributes:  In cw-ica-oracle:src/contract.rs:15, the instantiate function should emit an event containing the admin_address value.  In cw-ica-oracle:src/execute.rs:19, the post_metric function should emit events containing the new_metric and new_price values.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "12. Misleading comments in the codebase", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stride/2023-08-20 Audit Report - Stride ICA Oracle v1.0.pdf", "body": "In cw-ica-oracle:src/state.rs:127, the add function for the History storage state mentions that Old items are removed from the back of the deque when capacity is reached. However, this is incorrect because the old items are actually removed from the front of the deque when the capability is reached, as seen in line 137. in cw-ica-oracle:src/execute.rs:46, Additionally, the comment species that duplicated metrics will not be added to the store while in the current implementation duplicate new metrics silently overwrite existing metrics.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. Attacker can extract all Sigma tokens from the factory contract", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sigma/2022-05-03 Audit Report - Sigma v1.0.pdf", "body": "claim_deposit The in contracts/sigma_factory/src/contract.rs:363 allows an attacker to extract all Sigma tokens from the factory contract. Currently, any address with an unlocked deposit can perform this attack. There is no step in the function where entries are removed from CREATOR_TO_UNLOCK and the deposit redemption is not recorded anywhere. function The following is a potential attack scenario: 1. The attacker creates an option", "labels": ["Oak Security", "Severity: High"]}, {"title": "3. The attacker can repeatedly call claim_deposit and will continue to receive config.deposit_amount each transaction until the factory contract has no Sigma tokens left. Recommendation We recommend removing the CREATOR_TO_UNLOCK map entries after they are utilized in claim_deposit. In addition, we recommend storing the amount the user deposited and only returning it rather than returning config.deposit_amount. This amount can be decremented or set to zero after the user has claimed their deposit. Status: Resolved 2. Logic error prevents the redemption of aUST", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sigma/2022-05-03 Audit Report - Sigma v1.0.pdf", "body": "3. The attacker can repeatedly call claim_deposit and will continue to receive config.deposit_amount each transaction until the factory contract has no Sigma tokens left. Recommendation We recommend removing the CREATOR_TO_UNLOCK map entries after they are utilized in claim_deposit. In addition, we recommend storing the amount the user deposited and only returning it rather than returning config.deposit_amount. This amount can be decremented or set to zero after the user has claimed their deposit. Status: Resolved 2. Logic error prevents the redemption of aUST", "labels": ["Oak Security", "Severity: High"]}, {"title": "4. Settlement of stage 4 might run out of gas if too many depositing addresses exist", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sigma/2022-05-03 Audit Report - Sigma v1.0.pdf", "body": "In contracts/sigma_vault/src/contract.rs:996-1017, the deposits may run out of gas if the vector has many entries. Many entries might occur if an attacker would create many addresses to prevent the settlement of puts. This would result in the vault no longer being able to settle puts. There is currently no way to recover from this issue. iterations over", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "5. Depositors may receive dierent amount than original deposit", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sigma/2022-05-03 Audit Report - Sigma v1.0.pdf", "body": "claim_deposit The in contracts/sigma_factory/src/contract.rs:383 allows the depositor to claim their deposit after it has reached its unlock_timestamp. The deposit is sent back in a CW20 transfer message in lines 379-386. This message amount sends the current config.deposit_amount (an updatable value) to the depositor. This is problematic if the deposit_amount at from the deposit_amount at the time of the claim. the option was created is dierent the time that function The value of deposit_amount is updatable in line 323 by the gov contract or the owner. If this value is changed in the period of time after the option has been created but before the deposit is claimed it will cause the user to receive a dierent amount than they originally deposited when they created the option.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "6. Updatable option conguration parameters may impact the exercisability of options that are in the money", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sigma/2022-05-03 Audit Report - Sigma v1.0.pdf", "body": "The update_config function in contracts/sigma_option/src/contract.rs:122 allows config.owner to update the options parameters. There is currently no safeguard to ensure that these parameters cannot be updated on live options. Allowing for these parameters to be updated is very problematic. For example, if the owner were to change config.call_or_put, it would aect the exercisability of previously minted shares. This could be done accidentally or intentionally. In a situation where the owner is compromised, the attacker could change parameters to ensure that no users can exercise their options. There does not appear to be a reason why the option parameters would need to be updated once they are initially set, and removing this functionality completely would eliminate this possibility completely. The following parameters should not be updatable after they have been originally set:  underlying_asset  denomination  call_or_put  american_or_european  strike_price  expiration_time  exercisable_token  obligation_token", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "7. Excess funds sent while exercising via vault contract will be lost", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sigma/2022-05-03 Audit Report - Sigma v1.0.pdf", "body": "In both contracts/sigma_vault/src/contract.rs:570 and 582, if the user sends more funds than the exercisable units balance of the vault then they will eectively remain in the contract and not be returned back to the sender. This may result in the caller receiving less value than they have sent to the vault contract. In lines 570 and 582 there are validations to ensure that the units_sent or funds_sent are less than exercisable_units, and it will return an error if the funds are insucient. This check does not account for a situation where the caller sends funds in excess of the amount of exercisable_units. After this step, the function uses exercisable_units directly in all of the remaining messages and calculations and disregards the actual amount sent by the caller. This will result in the excess funds remaining in the vault contract and the caller will receive less value than they sent.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "8. Missing tax deductions", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sigma/2022-05-03 Audit Report - Sigma v1.0.pdf", "body": "While Terras tax rate has been set to zero, the tax mechanism is still implemented and the rate might be increased again in the future. It is still best practice to include functionality to deduct taxes. A non-zero rate could be reinstated via a governance proposal due to circumstances where the expected income from the tax rewards increases signicantly. In this situation, stablecoin transactions on Terra would expand to a state where a meaningful portion of the staking rewards income is derived from tax rewards rather than the vast majority coming from swap fees. We consider this to only be a minor issue since the contract owner can recover from tax mismatches by simply sending funds back to the contract. Additionally, the likelihood of the Terra team to increase taxes again is low. See https://agora.terra.money/t/proposal-to-reduce-the-terra-tax-rate-to-zero/3524 for more detail around the tax rate discussion.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "9. treasury_take, percent and fee should be validated to ensure they fall within an expected range of values", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sigma/2022-05-03 Audit Report - Sigma v1.0.pdf", "body": "In multiple occurrences values are set or updated without validations to ensure that they fall within an expected range. These are: 1. config.treasury_take in the update_config function and the instantiate function in contracts/sigma_collector/src/contract.rs:155. 2. percent in the ExecuteMsg::Convert handling in contracts/sigma_collector/src/contract.rs:84. 3. config.fee in the update_config function and the instantiate function in contracts/sigma_factory/src/contract.rs:338 and contracts/sigma_factory/src/contract.rs:49, a misconguration could cause an error in contracts/sigma_option/src/contract.rs:574.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "10. Miscongured distribution schedule cong can cause panics in LP staking contract", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sigma/2022-05-03 Audit Report - Sigma v1.0.pdf", "body": "a In contracts/sigma_lp_staking/src/contract.rs:35 distribution_schedule may be stored with a start time that is greater than the end time. This would cause contracts/sigma_lp_staking/src/contract.rs:331 to panic. For informational purposes, we also highlight that it is possible to supply a schedule with gaps and overlaps. Such gaps and overlaps do not cause errors, but might not be intended.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "11. Subtraction may cause wrap around underow", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sigma/2022-05-03 Audit Report - Sigma v1.0.pdf", "body": "are multiple There in instances contracts/sigma_xsig_reward/src/xsig.rs that may cause an underow if not handled properly. It is best practice to perform checked subtraction to return None or to use saturating subtraction to keep the result at the numeric bounds, rather than wrapping around during an underow. subtractions of This is important because Rust behaves dierently in debug mode and release mode. In debug mode, Rust adds built-in checks for overow/underow and panics when an overow/underow occurs at runtime. However, in release or optimization mode, Rust silently ignores this behavior by default and computes twos complement wrapping. The following are occurrences of unchecked subtraction:  contracts/sigma_xsig_reward/src/xsig.rs:30  contracts/sigma_xsig_reward/src/xsig.rs:31  contracts/sigma_xsig_reward/src/xsig.rs:32  contracts/sigma_xsig_reward/src/xsig.rs:68  contracts/sigma_xsig_reward/src/xsig.rs:69", "labels": ["Oak Security", "Severity: Low"]}, {"title": "12. Extra funds sent may be lost", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sigma/2022-05-03 Audit Report - Sigma v1.0.pdf", "body": "There are multiple instances in the contracts where native funds are improperly handled which may lead to a loss of funds. The current implementation does not account for a situation where the caller sends multiple funds. info.funds is a vector of Coin, but the current implementation only accounts for the specic denom used by the contract. It is best practice to provide an error if funds are sent that the contract does not handle. The following are instances of where funds are handled in this manner:  contracts/sigma_option/src/contract.rs:319  contracts/sigma_option/src/contract.rs:358  contracts/sigma_vault/src/contract.rs:563  contracts/sigma_vault/src/contract.rs:576  contracts/sigma_vault/src/contract.rs:1309  contracts/sigma_vault/src/contract.rs:1379  contracts/sigma_vault/src/contract.rs:1386", "labels": ["Oak Security", "Severity: Low"]}, {"title": "13. distribute function allows collector to send any asset", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sigma/2022-05-03 Audit Report - Sigma v1.0.pdf", "body": "The distribute function in contracts/sigma_collector/src/contract.rs:205 allows the caller to specify any asset while this function appears to be intended to only handle Sig distributions. This can be problematic if the caller species an asset that is not Sig.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "14. CREATOR_TO_UNLOCK may cause an out of gas error", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sigma/2022-05-03 Audit Report - Sigma v1.0.pdf", "body": "The CREATOR_TO_UNLOCK maps elements are never removed in the factory contract. This may cause an out of gas error in query_deposits. It is best practice to delete map entries once they have been used and are no longer necessary and also to limit the maximum number of entries to a map.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "15. Iterations over several maps may cause out of gas errors", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sigma/2022-05-03 Audit Report - Sigma v1.0.pdf", "body": "Iterations over several maps that are used in the factory contract might run out of gas and cause errors. These are: 1. tickers_by_option_info in contracts/sigma_factory/src/contract.rs:447 2. expiries_by_option_info in contracts/sigma_factory/src/contract.rs:465 3. strikes_by_option_info in contracts/sigma_factory/src/contract.rs:484 Out of gas errors can happen because those maps are unbounded. Since the initial amount of options is limited by the maximum expiry of three years it will not happen at launch and therefore this is only a minor issue. However, as options accumulate over the years this might become a serious problem for the protocol.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "16. Oracles for low liquidity assets might be prone to manipulation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sigma/2022-05-03 Audit Report - Sigma v1.0.pdf", "body": "Traditional options with physical delivery do not require to be in the money to be exercised. In some cases, settling an option out of the money or near the money can be economically benecial  e.g. if an equivalent order would have a large price impact on the markets. The use of oracles makes sure that options are not executed at a loss. However, if the oracle price is manipulated the oracle can stop users from executing options in the money.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "17. Canonical address transformations are inecient", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sigma/2022-05-03 Audit Report - Sigma v1.0.pdf", "body": "Usage of canonical addresses for storage is no longer recommended as a best practice. The reason is that canonical addresses are no longer stored in a canonical format, so the transformation just adds overhead without much benet. Additionally, the codebase is more complicated with address transformations.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "18. Unnecessary use of less than or equal to", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sigma/2022-05-03 Audit Report - Sigma v1.0.pdf", "body": "receive_cw20 in The contracts/sigma_xsig_reward/src/contract.rs:126 checks if the amount sent is less than or equal to zero. This can be changed to check only if the amount is equal to zero before returning the error. function", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. Non-deterministic iterations can cause consensus failures", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stride/2022-09-26 Audit Report - Stride v1.0.pdf", "body": "In several instances of the codebase, iterations are done over maps. Since Go map iterations are non-deterministic, this would cause each validator to produce a dierent app hash, causing a consensus failure and potentially leading to a chain halt. Aected code lines:  x/stakeibc/keeper/unbonding_records.go:101-109 and 147-152  x/stakeibc/keeper/msg_server_rebalance_validators.go:61-63  app/app.go:762 and 849  cmd/strided/root.go:349 This issue has independently been detected by the client during the audit, but it is still present in the commit hash that was used for the audit.", "labels": ["Oak Security", "Severity: High"]}, {"title": "2. GetHostZoneFromHostDenom incorrectly uppercases user input, which can be used to mint invalid assets", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stride/2022-09-26 Audit Report - Stride v1.0.pdf", "body": "x/stakeibc/keeper/host_zone.go:57, In the GetHostZoneFromHostDenom keeper function automatically uppercases the denom argument in line 59 and compares it against the zones denom which is also uppercased in line 61. As the denom argument is mostly supplied by the user, this would cause an unintended validation bypass. the users input msg.HostDenom is passed as the denom argument to For example, in GetHostZoneFromHostDenom x/stakeibc/keeper/msg_server_liquid_stake.go:22 when the user wants to liquid stake. A user can provide a mixed case argument such as \"aToM\" which will be validated as \"ATOM\" due to the automatic uppercase handling. As a result, the user can mint invalid stAssets such as \"staToM, which is incorrect and not accepted when redeeming the staked assets via RedeemStake.", "labels": ["Oak Security", "Severity: High"]}, {"title": "3. Computationally heavy operations in BeginBlocker may slow down or stop block production", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stride/2022-09-26 Audit Report - Stride v1.0.pdf", "body": "BeginBlocker and EndBlocker are a way for module developers to add automatic execution of logic to their module. This is a powerful tool that should be used carefully, as complex automatic functions can slow down or even halt the chain. There are two modules within the scope of this audit where the BeginBlocker or EndBlocker contains unbounded loops that can slow or even halt the chain. Both the interchainquery and epochs modules BeginBlocker or EndBlocker functions: contain resource intensive  x/interchainquery/keeper/abci.go:18  x/epochs/keeper/abci.go:14", "labels": ["Oak Security", "Severity: High"]}, {"title": "4. RegisterHostZone does not validate Bech32Prefix which will lead to staked funds being unredeemable if miscongured", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stride/2022-09-26 Audit Report - Stride v1.0.pdf", "body": "function RegisterHostZone in The lacking x/stakeibc/keeper/msg_server_register_host_zone.go:15 validations to ensure the msg.Bech32Prefix is valid and not empty. This functionality is the ValidateBasic function for neither performed in RegisterHostZone nor the eld is empty MsgRegisterHostZone. This MsgRedeemStake will error and block all that specic zone since AccAddressFromBech32 will return an error if hostZone.Bech32Prefix is empty. There is no way to update this eld or a hostzone so any funds that get staked to a hostzone will not be redeemable. is a critical check because if redemptions for is We classify this issue as major instead of critical, since only the admins can cause it. Still, it leads to permanently locked funds, that would require a chain upgrade to be resolved. This issue has independently been detected by the client during the audit, but it is still present in the commit hash that was used for the audit.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "5. RegisterHostZone does not ensure that HostDenom and IbcDenom are unique which may introduce conicts when returning a hostzone from these values", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stride/2022-09-26 Audit Report - Stride v1.0.pdf", "body": "function RegisterHostZone in The lacking x/stakeibc/keeper/msg_server_register_host_zone.go:15 validations to ensure the hostzone being registered does not contain duplicate elds with existing hostzones. For example, if msg.HostDenom is the same as an existing hostzone it will eectively invalidate any guarantee that GetHostZoneFromHostDenom provides. GetHostZoneFromHostDenom is used in multiple locations to derive the hostzone from a denom passed in so msg.HostDenom should be unique throughout all hostzones. This is the same case with msg.IbcDenom and GetHostZoneFromIBCDenom. is We classify this issue as major instead of critical, since only the admins can cause it. Still, it leads to permanently locked funds, that would require a chain upgrade to be resolved.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "6. Hard-coded admins increase the potential of unauthorized privileged activity", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stride/2022-09-26 Audit Report - Stride v1.0.pdf", "body": "In utils/utils.go:17-21, a hardcoded slice ADMINS is dened to represent the addresses that may perform a privileged activity. This is problematic because it creates a the admins is situation where it compromised. For example, one of the addresses is labeled as a testnet address which likely has private keys that have been shared amongst the development team. If this address were to remain in ADMINS it would present a serious risk to Stride as the address could perform multiple privileged actions. to control access and respond if one of is dicult", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "7. OnTimeoutPacket method not implemented", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stride/2022-09-26 Audit Report - Stride v1.0.pdf", "body": "In x/stakeibc/module_ibc.go:143, OnTimeoutPacket is not implemented and will panic on any timeout. Operations involving token transfers and burns could potentially lead to a state in which a chain updates the state as based on a successful transfer, but ignores the timeout. This can cause balances that arent synchronized between chains, which can ultimately lead to users not being able to redeem their tokens successfully, or even being able to redeem more than what they should.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "8. Misconguring CurrentEpoch and CurrentEpochStartHeight during genesis initialization would cause overow issues", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stride/2022-09-26 Audit Report - Stride v1.0.pdf", "body": "In x/epochs/types/genesis.go:51, the genesis initialization parameters are validated via the Validate function to prevent incorrect congurations. There are no validations that verify the value of CurrentEpoch and CurrentEpochStartHeight to not be negative values though. it would cause unintended consequences when converting them into unsigned values using the uint64 function. For example, the epoch number in x/stakeibc/keeper/hooks.go:36 would underow and become a tremendously large value, which is incorrect. they are congured as negative values, If", "labels": ["Oak Security", "Severity: Low"]}, {"title": "9. Participation rewards congured can be negative", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stride/2022-09-26 Audit Report - Stride v1.0.pdf", "body": "In x/mint/types/params.go:177-191, there is no validation that makes sure the participation rewards decimal value is not a negative value. The participation rewards value is used in x/mint/keeper/keeper.go:163 when distributing the minted coins via the DistributeMintedCoin keeper function. A miscongured participation rewards value would cause the execution to panic in x/mint/keeper/keeper.go:135 due to a negative coin amount. As a result, hooks that should be executed after an epoch ends (see x/mint/keeper/hooks.go:16) would keep failing.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "1. Lack of deadline parameter exposes user to risk of price volatility", "html_url": "https://github.com/oak-security/audit-reports/tree/master/BrainTrust/Audit Report -  Braintrust Uniswap Integration.pdf", "body": "The deadline parameter for the ExactInputSingleParams call to the Uniswap router is set to block.timestamp. This means that no deadline is set, implying that depending on gas provided by the frontend and network congestion, a long time might pass before the swap is executed, exposing the user to the risk of price changes. This is mitigated by carefully choosing the amountOutMinimum. However, for the given use case of the contract acting as a simple wrapper for o-chain code, passing on a front-end dened deadline value can help to protect users from misconguring this value.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "2. Version pragma allows for versions with security vulnerabilities", "html_url": "https://github.com/oak-security/audit-reports/tree/master/BrainTrust/Audit Report -  Braintrust Uniswap Integration.pdf", "body": "The codebase allows any Solidity compiler version from 0.8 to less than 0.9. A number of important compiler bugs have recently been xed. In particular, version 0.8.4 xed important security issues.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "3. Outdated comment", "html_url": "https://github.com/oak-security/audit-reports/tree/master/BrainTrust/Audit Report -  Braintrust Uniswap Integration.pdf", "body": "The comment in line 26 and 27 does not correspond to the current implementation.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "4. Contract does not implement slippage control", "html_url": "https://github.com/oak-security/audit-reports/tree/master/BrainTrust/Audit Report -  Braintrust Uniswap Integration.pdf", "body": "The contract is designed to accept an amountOutMin parameter that may be calculated o-chain and passed to the contract. While not a security concern, this architecture puts the responsibility of correct parameter choices on the frontend/user.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. Pending TODO comment indicates that a function is not needed", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2023-04-27 Audit Report - Astroport LP Token Balance Tracking v1.0.pdf", "body": "The decimal2decimal256 function was moved out of into packages/astroport/src/lib.rs:72-78, where a TODO comment was included the function was no longer necessary. Keeping unused code reduces stating that maintainability. the pair contract", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "2. Inconsistent usage of query_pools function", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2023-04-27 Audit Report - Astroport LP Token Balance Tracking v1.0.pdf", "body": "instances of the pair contract, the In several lines query_pools contracts/pair/src/contract.rs:334 and 633 use &env.contract.address, while lines 778, 940, and 989 use &config.pair_info.contract_addr. the contract_addr argument example, inconsistently. function used For for is", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "3. Factory address cannot be queried", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2023-04-27 Audit Report - Astroport LP Token Balance Tracking v1.0.pdf", "body": "the query_config function In contracts/pair/src/contract.rs:1064-1073, does not include config.factory_addr in the ConfigResponse struct. Consequently, users cannot query the factory address from the pair contracts queries.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "4. Misleading owner during cong query", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2023-04-27 Audit Report - Astroport LP Token Balance Tracking v1.0.pdf", "body": "The owner value is set to None in contracts/pair/src/contract.rs:1071. Users may interpret this as the contract not being subject to any updates, as no contract owner exists. call XYKPoolUpdateParams::EnableAssetBalancesTracking, which enables asset tracking in the pool. misleading though, factory owner This can the as is", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. Randomness precompile does not charge gas for external call processing", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Filecoin Foundation/2023-03-09 Audit Report - Filecoin EVM (FEVM) v1.1.pdf", "body": "get_randomness The in builtin_actors/actors/evm/src/interpreter/precompiles.rs:346, which is callable from the FEVM, does not account for gas for the entire process. precompile dened In ref_fvm/fvm/src/gas/price_list.rs:684, gas is only charged for hashing and the precompile call but not for the random value generation process. Since this function can be invoked by any contract in FEVM, an attacker is able to create a contract that intensively calls this precompile in order to use computational resources without being charged appropriate gas. This could lead to overloading nodes in the network, up to the point where block production slows down or even stops due to timeouts being reached.", "labels": ["Oak Security", "Severity: High"]}, {"title": "2. Actor installation is not charging gas on wasm preload error", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Filecoin Foundation/2023-03-09 Audit Report - Filecoin EVM (FEVM) v1.1.pdf", "body": "In ref-fvm/fvm/src/kernel/default.rs:906, charging gas after the engine preload operations. the install_actor function is This implies that if the engine fails to set up the wasm engine and bytecode, it will return an error interrupting the execution without calling the on_install_actor function, which is responsible for charging gas. An attacker could take advantage of this by loading an invalid serialized wasm le that consumes computational resources and then returns an error in the preload operations paying no additional gas.", "labels": ["Oak Security", "Severity: High"]}, {"title": "3. No gas is charged for event emission and storage", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Filecoin Foundation/2023-03-09 Audit Report - Filecoin EVM (FEVM) v1.1.pdf", "body": "In fvm/src/gas/price_list.rs:274-281, the gas cost for event-related operations is zero. This implies that no additional gas cost is charged to actors that emit events, including FEVM. Additionally, during the execute_message function, the commit_events function, dened in fvm/src/machine/default.rs, performs an unbounded loop through all the provided StampedEvents in order to store them one by one in an Array Mapped Trie without accounting for gas. Since no gas is charged for event emission and storage, an attacker could leverage this behavior in order to consume computational resources without paying additional gas. This can be exploited to slow down block production or even halt the chain.", "labels": ["Oak Security", "Severity: High"]}, {"title": "4. difficulty opcode is not following the EVM specication", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Filecoin Foundation/2023-03-09 Audit Report - Filecoin EVM (FEVM) v1.1.pdf", "body": "As per the legacy EVM specication, the DIFFICULTY opcode returns the current block diculty. After the introduction of EIP-4399, this opcode behavior changed slightly in order to return an RNG beacon following the RANDAO specication. The current FEVM implementation of the DIFFICULTY opcode always returns zero. This implies that smart contracts using this functionality could suer unexpected behaviors.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "5. Storage opcodes do not follow EIP-2929", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Filecoin Foundation/2023-03-09 Audit Report - Filecoin EVM (FEVM) v1.1.pdf", "body": "In the EVM Berlin fork, EIP-2929 got introduced, which is not implemented in current storage opcodes in the FEVM. Because of that, the FEVM implementation diverts from the gas handling of the EVM.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "6. Maximum stack size can be exceeded", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Filecoin Foundation/2023-03-09 Audit Report - Filecoin EVM (FEVM) v1.1.pdf", "body": "Prior to executing an opcode, the stack size is checked by calling the Stack::ensure function in builtin-actors/actors/evm/src/interpreter/stack.rs. the current stack size is insucient, the stack size is doubled, possibly increasing the stack size beyond STACK_SIZE. If If the Stack::ensure function is called again as part of executing the next opcode, and the required size is less or equal to the current stack size, it will consider the stack size sucient without checking the size limit. This leads to the stack size being increased beyond the intended limit of 1024 to a maximum stack size of 2048.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "7. Deviating from the EVM, retrieving the code for non-existing accounts reverts the transaction", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Filecoin Foundation/2023-03-09 Audit Report - Filecoin EVM (FEVM) v1.1.pdf", "body": "the The opcodes EXTCODESIZE, EXTCODECOPY, and EXTCODEHASH retrieve the bytecode by calling in get_evm_bytecode_cid builtin-actors/actors/evm/src/interpreter/instructions/ext.rs. However, non-existent account, leading to the transaction being reverted. this function returns an unhandled error in case the address belongs to a function On the contrary, the EVM returns 0 for EXTCODESIZE, and the keccak256 hash of empty data (0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470) for EXTCODEHASH if the target address is a non-existent account.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "8. Opcode gas accounting deviating from the Ethereum EVM specication could lead to unexpected behavior", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Filecoin Foundation/2023-03-09 Audit Report - Filecoin EVM (FEVM) v1.1.pdf", "body": "Due to the dierent gas accounting, contracts developed for the EVM might experience compatibility and portability issues when deployed to the FEVM. Commonly, code is optimized regarding gas cost, but since the FEVMs gas accounting is dierent, the same contract executing on the EVM might run out of gas on FEVM or vice versa. Please nd below a few concrete examples of issues caused by the diverging gas accounting: 1. In the following example, the store function is executable on Ethereum and Binance Smart Chain with num = 50_000, while not executable on the FEVM. It runs out of gas if num >= 45_000. uint256 number; function store(uint256 num) public { for(uint256 i = 0; i<num; i++){ number = i; } } 2. If a contract contains a call instruction with an explicitly provided gas limit via {gas:value}, it may not be portable from the EVM to the FEVM. The optionally dened gas limit for the call instruction has to account for all the internal FVM operations (e.g., system.send handling), making it complex for developers to guess the correct amount of gas limit to provide. An example is provided in Appendix 1. 3. Ethereum smart contract developers usually optimize the code and the build process to minimize gas costs for the user. enables that solc https://docs.soliditylang.org/en/v0.8.17/internals/optimizer.html. optimizations dierent types of rely on opcodes Using the --optimize-runs compiler ag optimizes the gas cost of contracts designed to be deployed once and executed multiple times or if they are children of a factory contract. Also, some common patterns exist to optimize the code to use cheaper opcodes. For example, using SSTORE to store zeros in the EVM is cheaper than other numbers. All of these types of optimizations are not eective in the FEVM and could lead to portability issues. An example of how optimizations aect gas usage in FEVM is provided in Appendix 2.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "9. assert instruction does not consume all the remaining gas as dened in the EVM specication", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Filecoin Foundation/2023-03-09 Audit Report - Filecoin EVM (FEVM) v1.1.pdf", "body": "As per the EVM specication, the assert instruction should consume all the remaining available gas by executing the 0xFE INVALID opcode. However, the FEVM implementation returns error code 33 without charging the remaining gas.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "10. The bitwise SAR opcode returns 1 instead of 0 if shift is greater than or equal to 256", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Filecoin Foundation/2023-03-09 Audit Report - Filecoin EVM (FEVM) v1.1.pdf", "body": "to 256 for The EVM specication states that the SAR opcode should return 0 if shift is greater than or the FEVM implementation in equal builtin-actors/actors/evm/src/interpreter/instructions/bitwise.rs: 43 for the SAR opcode returns U256::ONE (i.e. 1) instead of 0 in this case. This can lead to incorrect results for the SAR opcode. 0. However, a value >=", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "11. LOG opcodes do not revert in case of a STATICCALL", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Filecoin Foundation/2023-03-09 Audit Report - Filecoin EVM (FEVM) v1.1.pdf", "body": "According to the EVM specication, executing LOG opcodes is not allowed in a read-only STATICCALL and should revert in this case. However, the FEVM log function implementing the in does builtin-actors/actors/evm/src/interpreter/instructions/log.rs not check if the current call is a staticcall. opcodes LOG", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "12. block.coinbase is not following the EVM specication", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Filecoin Foundation/2023-03-09 Audit Report - Filecoin EVM (FEVM) v1.1.pdf", "body": "According to the EVM specication, the block.coinbase instruction should return the miner of the current block. In contrast, in the FEVM, a zero value is returned. This implies that all the smart contracts that use this information, for example, as a source of entropy, will not work as intended. Examples of usages of this instruction on open source projects can be found with this GitHub query, resulting in around 24K results.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "13. FEVM gas consumption could saturate the available gas in a block and slow down the processing of core Filecoin operations", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Filecoin Foundation/2023-03-09 Audit Report - Filecoin EVM (FEVM) v1.1.pdf", "body": "The FEVM gas consumption is generally higher than that of other core Filecoin network transactions. For example, a FIL transfer performed through FEVM costs 1.651.058 gas, while the same operation costs 489.268 with a base Send transaction. Since FEVM-related gas fees are on a dierent numeric magnitude than base operations, this could lead to a situation where FEVM transactions could saturate the block, leaving little room for core Filecoin operations.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "14. The CREATE2 opcode smart contract generation is not supported by FEVM", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Filecoin Foundation/2023-03-09 Audit Report - Filecoin EVM (FEVM) v1.1.pdf", "body": "The FEVM does not support smart contract creation using the CREATE2 opcode, while the EVM does. This behavior breaks the compatibility of smart contracts expected to work in the FEVM. A sample smart contract used for testing is available in Appendix 3. The functions create2NewToken and deploy in the provided smart contract revert when executed with the following error: { \"code\": 1, \"message\": \"message execution failed: exit 33, reason: message failed   with backtrace:\\n00: f01306 (method 2) -- contract reverted (33)\\n01: f010 (method 3) -- Serialization error for Cbor protocol: Mismatch { expect_major: 2, byte: 152 } (21)\\n (RetCode=33)\" } As a reference, the same smart contract can be successfully deployed with the CREATE2 opcode on the Goerli network: https://goerli.etherscan.io/tx/0x60150e92677fc2738571222de5a0c107780c131a38f87a493f2 58a56444f93", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "15. FEVM allows funds to be sent to a contract without the need for a receive or fallback method", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Filecoin Foundation/2023-03-09 Audit Report - Filecoin EVM (FEVM) v1.1.pdf", "body": "Using the send and transfer functions on the FEVM, a contract can receive funds even without having a fallback or receive function. In contrast, the EVM specication requires that a smart contract cannot receive payments if it lacks a receive or fallback function. Breaking this assumption may result in unexpected behavior, including potentially lost funds. A sample smart contract used for testing is available in Appendix 4.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "16. After SELFDESTRUCT, FEVM does not follow the EVM specication", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Filecoin Foundation/2023-03-09 Audit Report - Filecoin EVM (FEVM) v1.1.pdf", "body": "In the EVM, when a smart contract executes the SELFDESTRUCT opcode, it thereafter operates as an EOA, which means that its code is erased while it continues to receive payments. However, the funds are no longer available since smart contracts do not have explicit private keys. the FEVM, after executing SELFDESTRUCT on a smart contract, payments can no longer be received, and the error actor doesn't exist is returned. implementation of In the present This behavior of FEVM deviates from the EVM, which may cause problems when migrating EVM-based smart contracts directly to FEVM. A sample smart contract used for testing is available in Appendix 5.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "17. DELEGATECALL does not propagate msg.value to the implementation contract", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Filecoin Foundation/2023-03-09 Audit Report - Filecoin EVM (FEVM) v1.1.pdf", "body": "As per the specication of the DELEGATECALL opcode, the execution context should be the same as the caller contract, which implies that the msg.value and msg.sender values should be the same in the implementation contract, and the implementation contract can utilize those values during execution. However, the FEVM implementation of DELEGATECALL does not propagate the msg.value of the caller context during the delegatecall, since in msg.value builtin-actors/actors/evm/src/interpreter/instructions/call.rs:148. This reduces the portability of EVM contracts to the FEVM and may even lead to unexpected these behavior with potentially catastrophic consequences if divergences in behavior. teams are unaware of U256::zero() passed as is A sample smart contract used for testing is available in Appendix 6.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "18. Diverging behavior of gas refunds during SELFDESTRUCT between EVM and FEVM", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Filecoin Foundation/2023-03-09 Audit Report - Filecoin EVM (FEVM) v1.1.pdf", "body": "According to the EVM specication, the SELFDESTRUCT opcode refunds 24000 gas units. The accumulated refund can not exceed half of the gas used for the current context, while a gas refund is provided only once at the end of the transaction's execution. In contrast, the FEVM refunds gas upon SELFDESTRUCT during the the transaction in ref-fvm/fvm/src/kernel/default.rs:180. That implies that the execution can use refunded gas, which may lead to unexpected behavior when porting smart contracts from the EVM to the FEVM. execution of", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "19. Retrieving the code of precompile addresses reverts, which diverges from the EVM specication", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Filecoin Foundation/2023-03-09 Audit Report - Filecoin EVM (FEVM) v1.1.pdf", "body": "In the FEVM, the opcodes EXTCODESIZE, EXTCODECOPY, and EXTCODEHASH revert if the target address is a precompile. Given that the FEVM considers all addresses in the range between 0x0 and 0xffff as precompiles, the aforementioned opcodes revert for those addresses See builtin-actors/actors/evm/src/interpreter/instructions/ext.rs:59. precompiles. even they are not if On the contrary, the EVM returns 0 for EXTCODESIZE and the keccak256 hash of empty data (0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470) for EXTCODEHASH if the target address is a precompile.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "1. Deactivated market assets would cause forced liquidation on borrowers", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-02-17 Audit Report - Mars v1.0.pdf", "body": "In mars-red-bank/src/account.rs:61, the function get_user_position is used internally to calculate the borrowers debt, average liquidation threshold and most importantly the health factor which determines whether the borrower can be liquidated. The function iterates over all assets in that the borrower has a position, without accounting in the markets active state. If a market is deactivated, borrowers will be unable to perform any actions on it including repaying their loans. the market asset This would cause problems if the borrower is borrowing had been deactivated by the contract owner. The debt of the inactive market would still be included when calculating the overall health factor for the borrower. Although the deactivated market asset prevents liquidation attempts, a liquidator can still bypass it by liquidating other active collateral assets. Hence, the borrower would be subjected to forced liquidation due to the inability to repay their loans.", "labels": ["Oak Security", "Severity: High"]}, {"title": "2. Staking xMars rewards can be sandwiched by an attacker, skimming its value before accruing to stakers", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-02-17 Audit Report - Mars v1.0.pdf", "body": "Protocol rewards can be swapped and transferred by anyone to the Staking contract. A combination of public messages executed in one transaction can be leveraged by an attacker to skim the rewards of xMars stakers as shown below: 1. Withdraw Mars rewards (or ma_mars) using mars-protocol-rewards-collector/src/contract.rs:187. execute_withdraw_from_red_bank from the Red Bank to the Protocol Collector in 2. Sell assets if you have Mars/maMars inventory", "labels": ["Oak Security", "Severity: High"]}, {"title": "7. Sell MARS bought in step 4. This can be also exploited with rewards denominated in assets other than Mars, but the severity of this performed on Mars rewards is greater due to steps 6 and 7. Recommendation We recommend either rate-limiting/restricting the access of these public functions, or allowing the Protocol Rewards Collector to send rewards directly in the denomination they are withdrawn from the Red Bank, and swapping them back to Mars on the Staking contract without the intermediate swap to UST. Status: Acknowledged The Mars team is working on ideas to solve this on future versions of the protocol that the community could adopt. In the meantime, the community would have to evaluate the risk of adding Mars as a borrowable asset to the money market. At rst most fees will be collected in uusd which would only be swapped to Mars in the case of staking which would make the window for this attack small. 3. Malicious smart contracts can avoid liquidation attempts", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-02-17 Audit Report - Mars v1.0.pdf", "body": "7. Sell MARS bought in step 4. This can be also exploited with rewards denominated in assets other than Mars, but the severity of this performed on Mars rewards is greater due to steps 6 and 7. Recommendation We recommend either rate-limiting/restricting the access of these public functions, or allowing the Protocol Rewards Collector to send rewards directly in the denomination they are withdrawn from the Red Bank, and swapping them back to Mars on the Staking contract without the intermediate swap to UST. Status: Acknowledged The Mars team is working on ideas to solve this on future versions of the protocol that the community could adopt. In the meantime, the community would have to evaluate the risk of adding Mars as a borrowable asset to the money market. At rst most fees will be collected in uusd which would only be swapped to Mars in the case of staking which would make the window for this attack small. 3. Malicious smart contracts can avoid liquidation attempts", "labels": ["Oak Security", "Severity: High"]}, {"title": "8. Initializing vesting contract wrongly would cause inconsistent state", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-02-17 Audit Report - Mars v1.0.pdf", "body": "In the Vesting contract, congurations such as unlock_start_time, unlock_cliff and unlock_duration are congured during contract initialization. There are no validations in place to verify submitted values are correct, eg. unlock_start_time must be a timestamp in the future instead of the past.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "9. Duplicate accounts creation would cause inconsistent total supply", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-02-17 Audit Report - Mars v1.0.pdf", "body": "In the xMars token contract, accounts are created via create_accounts during contract initialization. As shown in contracts/mars-xmars-token/src/contract.rs:53-62, the function loops through a set of accounts without verifying possible duplications. If the accounts contain any repeated address, the previous balance would be overwritten but the total_supply would increase, creating a discrepancy between the two.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "10. Sent tokens other than denoms are lost", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-02-17 Audit Report - Mars v1.0.pdf", "body": "are then In the Red Bank contract, users can deposit native assets via DepositNative message. The coins called get_denom_amount_from_coins. The function does not limit user sent funds to exactly one type of funds. If the user sent two types of funds (eg. LUNA and UST), the other assets which are not denom would be lost in the contract. function internal parsed which from an is", "labels": ["Oak Security", "Severity: Low"]}, {"title": "11. Expiration can be set to past timestamp and block height", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Mars/2022-02-17 Audit Report - Mars v1.0.pdf", "body": "In the Ma-token contract, IncreaseAllowance and DecreaseAllowance allow specifying an Expiration via block height or block timestamp. The specication does not verify whether the supplied Expiration value is higher than the current timestamp or block height. Users may set the expiration value to a past timestamp or block height, which causes the approval to fail.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "1. Saving an invalid LastResultsHash and AppHash when performing a hard rollback", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-15 Audit Report - Sei Tendermint v1.0.pdf", "body": "Hard rollback deletes the block and the app states to recover an incorrect application state In internal/state/rollback.go:117, when removeBlock is true, the transition. in the block latest internal/state/rollback.go:110-111, latestBlock is used to store both LastResultsHash and AppHash in rolledBackState where it should use rollbackBlock when performing a hard rollback. However, removed store. block from is", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "2. Missing error handling for setProposal might cause unwanted state to be ushed to disk and invalid proposals to be included in a block", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-15 Audit Report - Sei Tendermint v1.0.pdf", "body": "In internal/consensus/state.go:1037.go, there is a call to method setProposal which returns an error. However, this error is not immediately handled, which might cause the proposal to be ushed to disk and created even when an error occurred. One of the reasons why setProposal may return a non-nil error upon an invalid proposal signature as depicted in internal/consensus/state.go:2333. In that case, a proposal that has been signed by a wrong signature gets added to a block, even though it should have been discarded.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "3. Remove unused les and code", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-15 Audit Report - Sei Tendermint v1.0.pdf", "body": "Across the codebase, various instances of unused les and code have been found.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "4. Use of deprecated function", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-15 Audit Report - Sei Tendermint v1.0.pdf", "body": "The abci/client/grpc_client.go:60. deprecated function grpc.WithInsecure is used in", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "5. Redundant use of span closing statements is inecient", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-15 Audit Report - Sei Tendermint v1.0.pdf", "body": "In the finalizeCommit method in internal/consensus/state.go:2148, the storeBlockSpan is closed. However, this operation is redundant as in line 2141 there is a deferred statement already closing the same span. Redundant code can make the code more complex or inecient.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "6. Missing validation might lead to dangling pointer", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-15 Audit Report - Sei Tendermint v1.0.pdf", "body": "In the OnStart method in internal/mempool/reactor.go:98, the channel eld from the Reactor type is not checked against the nil value. This can cause a dangling pointer, and the main thread to crash. This is not a security concern in the current implementation, since upon node creation in node/node.go:274 the mempool reactor is initialized and the channel is created by passing a callback SetChannel to method AddChDescToBeAdded. Nevertheless, the fact that the mempool constructor initializes the channel as nil, and there is no further validation could potentially cause an issue in the future.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. Attackers can drain funds from contract", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Fuzion/2023-02-24 Audit Report - Fuzion Plasma OTC v1.1.pdf", "body": "In src/commands.rs:245, the execute_set_recipient function sets the escrow status to EscrowStatus::Active even if the escrow is already completed and its funds were transferred. This allows an attacker to reactivate completed escrows to drain funds from the contract by executing SetRecipient and Approve messages repeatedly. Additionally, since in src/commands.rs:610 the function send_tokens returns an empty vector when the balance is empty, even if the receiver did not deposit funds, the sender can still perform the attack draining funds from the contract. Please see the steal_funds test case to reproduce the issue.", "labels": ["Oak Security", "Severity: High"]}, {"title": "2. Malicious arbiters can steal funds by overwriting the recipient address", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Fuzion/2023-02-24 Audit Report - Fuzion Plasma OTC v1.1.pdf", "body": "In src/commands.rs:408-415, an arbiter needs to approve the escrow before processing the trade. A malicious arbiter can execute the SetRecipient message to overwrite the recipient address to another one under its control and then call the Approve message to steal the original recipients funds. Please see the arbiter_steal_funds test case to reproduce the issue.", "labels": ["Oak Security", "Severity: High"]}, {"title": "3. Funds are locked if the recipient has deposited and the arbiter does not approve the escrow before the deadline", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Fuzion/2023-02-24 Audit Report - Fuzion Plasma OTC v1.1.pdf", "body": "In src/commands.rs:408-415, the arbiter is required to approve the escrow to process the trade if it is created providing an arbiter and recipient. If the arbiter does not approve the escrow before the deadline, funds will be stuck in the contract. In fact, both Approve and Refund messages will revert respectively with Expired and RecipientAlreadyDeposited contract errors. Due to the impossibility of the arbiter rejecting an escrow and refunding both parties, this issue is likely to happen when the arbiter opposes the trade. Please see the funds_stuck_arbiter_after_deadline test case to reproduce the issue.", "labels": ["Oak Security", "Severity: High"]}, {"title": "4. Escrows can be completed without recipients interaction", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Fuzion/2023-02-24 Audit Report - Fuzion Plasma OTC v1.1.pdf", "body": "In src/commands.rs:255, the execute_approve function does not verify the recipients balance is not empty when processing the trade, allowing the trade to be completed without any deposits from the recipient. This is problematic because the recipient could collude with the arbiter to approve the escrow and steal the creators funds. Consequently, the creators funds will be sent to the recipient, while the creator receives nothing in return. Please see the approve_without_deposit test case to reproduce this issue.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "5. Escrow and vesting end times should be enforced to be in the future", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Fuzion/2023-02-24 Audit Report - Fuzion Plasma OTC v1.1.pdf", "body": "During the execution of Create messages, in both src/commands.rs:126-129 and src/commands.rs:196, the vesting_end_time and end_time timestamps are not validated to be in the future. This could lead to scenarios where the newly created escrow is already expired, or the vested tokens are immediately redeemable.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "6. Division by zero error if creator or receiver fee percentage is set to zero", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Fuzion/2023-02-24 Audit Report - Fuzion Plasma OTC v1.1.pdf", "body": "During contract instantiation, zero percentage fees for creator or receiver are accepted. However, since this value is used as a denominator in the calc_minimum_balance function in src/commands:696 during the handling of Create messages, a zero value will lead to a division by zero error. if any the Additionally, transfer_tokens_messages function will fail because the contract will try to send zero amount of fees, which will be prevented by Cosmos SDK. fee collectors are miscongured to receive zero fees,", "labels": ["Oak Security", "Severity: Low"]}, {"title": "7. Missing address validation during contract instantiation and conguration update", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Fuzion/2023-02-24 Audit Report - Fuzion Plasma OTC v1.1.pdf", "body": "During contract UpdateConfig messages in src/commands.rs:16-51, admins addresses are not validated. instantiation in src/contract.rs:28-54 as well as execution of the fee_collectors and Storing invalid addresses could lead to unexpected behavior like errors when completing escrows because of the failure of Bank messages directed to an invalid fee collector address.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "8. Fee collectors' percentage sum should not exceed 100", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Fuzion/2023-02-24 Audit Report - Fuzion Plasma OTC v1.1.pdf", "body": "both In fee_collectors vector provided by the admin is set in the CONFIG struct. src/contract.rs:40-42 src/commands.rs:35-40, and the Since this vector represents a weighted list of addresses that should receive fees, the sum of the percentages of all the vectors elements should not exceed 100 to avoid charging more fees than expected. Additionally, duplicate addresses are allowed in the vector, potentially leading to higher fees than intended. We classify this issue as minor since only the contract admin can cause it.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "9. Contract-dened admins can lock user funds", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Fuzion/2023-02-24 Audit Report - Fuzion Plasma OTC v1.1.pdf", "body": "In src/commands.rs:655-691, the calc_fees function iterates over all fee collectors for each balance coin in order to send fees through Bank messages. limit Since no upper for fee_collectors is enforced, admins could store a large fee_collectors vector in order to let the contract run out of gas during the calc_fees function execution. Consequently, all the messages that involve the sending of funds will fail, leading to the lock of user funds in the contract. We classify this issue as minor since it can only be caused by admins who are community-trusted entities.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "10. OTC_ACTIVE_PAIRS_COUNT is not decrement when public OTC is modied into private", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Fuzion/2023-02-24 Audit Report - Fuzion Plasma OTC v1.1.pdf", "body": "In src/commands.rs:230, the execute_set_recipient function does not decrease the active OTC pairs when a public OTC trade becomes private. Consequently, incorrect values. this causes the MarketEscrowActivePairsCount query to return Please see the public_to_private_does_not_decrease_active_otc test case to reproduce the issue.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "11. Missing validation to ensure that creator_balance is not equal to asking_price", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Fuzion/2023-02-24 Audit Report - Fuzion Plasma OTC v1.1.pdf", "body": "In src/commands.rs:96, creator_balance is equal to the asking_price. the function execute_create is not checking if the If an escrow with the same provided and asked coins denom and amount is created, this could generate a potentially unwanted arbitrage opportunity and make the creator lose funds on the trade.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "12. Admin can update fee_collectors to an empty vector", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Fuzion/2023-02-24 Audit Report - Fuzion Plasma OTC v1.1.pdf", "body": "src/commands.rs:35-40, fee_collectors, In assert_has_fee_collectors is not called to ensure the fee collectors vector is not empty. update during an of This is inconsistent with the contract instantiation phase in src/contract.rs:36.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "13. Redundant partial ll validation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Fuzion/2023-02-24 Audit Report - Fuzion Plasma OTC v1.1.pdf", "body": "In src/commands.rs:461-463, the if statement ensures the escrow allows partial lls in the execute_receiver_partial_deposit function. This check can be removed as the same validation is performed in src/commands.rs:333.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "14. Incorrect comment for vesting_end_time", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Fuzion/2023-02-24 Audit Report - Fuzion Plasma OTC v1.1.pdf", "body": "In src/commands.rs:90, the comment documents that vesting_end_time represents the vesting start time. This is incorrect, as the variable represents the vestings end time.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "15. Loss of escrow information after the execution of Refund messages", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Fuzion/2023-02-24 Audit Report - Fuzion Plasma OTC v1.1.pdf", "body": "During the handling of Refund messages, the execute_refund function removes the selected escrow data from the storage. While this is not a security issue, it could degrade the user experience since escrow information is not queriable anymore, and all the involved parties have no more reference to their operations. Additionally, in the case of partially lled escrows, the removal of the original escrow could lead to the impossibility of retrieving data from its partial_fill_of_id.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "16. Custom access controls implementation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Fuzion/2023-02-24 Audit Report - Fuzion Plasma OTC v1.1.pdf", "body": "The contract implements custom access controls. Although no instances of broken controls or bypasses have been found, using a battle-tested implementation reduces potential risks and the complexity of the codebase. Also, the access control negatively impacts the code's readability and maintainability. logic is duplicated across the handlers of each function, which", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. Password still in memory after logout", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nym/Audit Report - Nym Wallet.pdf", "body": "Unlike the mnemonic, the password (which can be used to retrieve the mnemonic) is still visible in memory after the user is logged out. For instance, the following memory dump was taken after logging out on a Windows machine: $ strings nym-wallet.DMP | grep \"AAAa1\" AAAa1234!@ The password of the user was AAAa1234+@ and this string is still in memory after logging out.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "2. Mnemonic kept in memory after account creation within the wallet", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nym/Audit Report - Nym Wallet.pdf", "body": "To ensure that the mnemonic is not kept in memory, it is overwritten with a fresh mnemonic in the zeroize implementation (within account_data.rs). This works well and we ensured that the mnemonic cannot be retrieved from a memory dump after the user is logged out. However, this is not the case when a new account is created within the wallet (clicking on the account symbol and then selecting Create account). Then, the mnemonic is still kept in memory, even after the user is logged out. This can be seen in the following screenshot, where a memory dump on Windows was taken after the user was logged out. Previously, an account with the mnemonic frequent husband lecture orphan position surround pumpkin twin write express axis employ guard outside defense swim impulse spot hair punch load today tragic because\" was added within the app:", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "3. Limited range of password special characters", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nym/Audit Report - Nym Wallet.pdf", "body": "PasswordStrength The in nym-wallet/src/pages/auth/components/password-strength.tsx uses regex patterns to validate the strength of a password. However, the regex pattern for a \"strong\" password enforces a strict set of symbols, disallowing certain characters such as \"}\" from being used. This restriction limits the range of possible passwords and makes it easier for an attacker to successfully guess a password through brute-force methods. component React", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "4. User is forced to copy the mnemonic phrase to the clipboard", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nym/Audit Report - Nym Wallet.pdf", "body": "During account creation, the user is presented with the mnemonic phrase and is required to click the \"Copy mnemonic\" button, which copies the phrase to the clipboard. This practice poses a security risk as the mnemonic phrase may be accessed by other applications.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "5. No conrmation of mnemonic when account is added in the wallet", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nym/Audit Report - Nym Wallet.pdf", "body": "When a new account is created on the start screen using Create account, there is no conrmation ow ensure that the user backed up/noted down the mnemonic. Instead, only the password is required to continue.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "6. Mix node description requested via HTTP", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nym/Audit Report - Nym Wallet.pdf", "body": "The function get_mix_node_description (within bond.rs) requests the description of a mix node via unencrypted HTTP. While this information is only used for display purposes (limiting the impact of a MITM attack on the connection), it is still recommended to use encrypted connections for all external requests.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "7. Known vulnerabilities in dependencies", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nym/Audit Report - Nym Wallet.pdf", "body": "There are known vulnerabilities in two dependencies (crate chrono and time): chrono 0.4.19 Potential segfault in `localtime_r` invocations 2020-11-10 RUSTSEC-2020-0159 https://rustsec.org/advisories/RUSTSEC-2020-0159 Crate: Version: Title: Date: ID: URL: Solution: Upgrade to >=0.4.20 Dependency tree:  vesting-contract 1.1.0  nym_wallet 1.1.1  nym-wallet-types 1.0.0   nym-types 1.0.0 chrono 0.4.19  vergen 5.1.17             nym_wallet 1.1.1  validator-client 0.1.0        nym_wallet 1.1.1  nym-wallet-types 1.0.0  nym-types 1.0.0  nym_wallet 1.1.1  nym_wallet 1.1.1  nym-wallet-types 1.0.0 time 0.1.43 Potential segfault in the time crate 2020-11-18 RUSTSEC-2020-0071 https://rustsec.org/advisories/RUSTSEC-2020-0071 Crate: Version: Title: Date: ID: URL: Solution: Upgrade to >=0.2.23 Dependency tree: time 0.1.43  chrono 0.4.19  vesting-contract 1.1.0  nym_wallet 1.1.1  nym-wallet-types 1.0.0   nym-types 1.0.0  vergen 5.1.17             nym_wallet 1.1.1  validator-client 0.1.0        nym_wallet 1.1.1  nym-wallet-types 1.0.0  nym-types 1.0.0  nym_wallet 1.1.1  nym_wallet 1.1.1  nym-wallet-types 1.0.0 Similarly, there are NPM packages with known vulnerabilities (which are shown when running yarn audit). The output of running yarn audit indicates that 63 vulnerabilities were found in the audited packages. Of these vulnerabilities, 2 are rated as moderate, 46 are rated as high, and 15 are rated as critical.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "8. Inadequate password strength validation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nym/Audit Report - Nym Wallet.pdf", "body": "React PasswordStrength in The validates nym-wallet/src/pages/auth/components/password-strength.tsx the strength of a password on a scale of \"insucient\", \"medium,\" and \"strong\". The password strength calculation is based on the length of the password and the occurrence of a set of predened characters. However, this calculation is inadequate and may classify low entropy passwords, such as abc1234! or passw0rd! as \"strong\" passwords. This could lead to a complete loss of funds if an attacker can obtain an encrypted wallet le and successfully guesses the password, for example by using common password lists. component", "labels": ["Oak Security", "Severity: Low"]}, {"title": "9. Unhandled errors thrown by asynchronous functions in React hooks", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nym/Audit Report - Nym Wallet.pdf", "body": "If errors thrown by asynchronous functions within React hooks are not caught and handled properly, they will be silently ignored and the React error boundary will not be triggered. The user will not be notied of the error and the application may end up in an inconsistent state. The following but incomplete list of hooks is aected: - - - nym-wallet/src/context/main.tsx:109 nym-wallet/src/context/main.tsx:147 nym-wallet/src/context/main.tsx:160", "labels": ["Oak Security", "Severity: Low"]}, {"title": "1. Missing validation of the bridged_denom format", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Hadron Labs/2023-07-29 Audit Report - Hadron Labs Lido Satellite v1.0.pdf", "body": "In contracts/lido-satellite/src/msg.rs:16-21, not validate the format of the bridged_denom variable. the validate function does This is problematic since the contract is designed to hold only funds denominated in bridged denoms. Specically, the provided denom should adhere to the required format of ibc/{denom} before proceeding with any subsequent processing steps.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "2. Additional funds sent by the user besides config.bridged_denom are locked", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Hadron Labs/2023-07-29 Audit Report - Hadron Labs Lido Satellite v1.0.pdf", "body": "In contracts/lido-satellite/src/execute.rs:15 and 39, the find_denom function checks for the existence of a Coin with the config.bridged_denom among the funds sent with the message. This validation does not ensure however that no other native tokens have been sent, and any such additional native tokens are not returned to the user, so they will be stuck in the contract forever. While blockchains generally do not protect users from sending funds to wrong accounts, reverting extra funds increases the user experience.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "3. Missing check that the contract has enough funds to cover the creator_fee", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Hadron Labs/2023-07-29 Audit Report - Hadron Labs Lido Satellite v1.0.pdf", "body": "In contracts/lido-satellite/src/contract.rs:31, before creating a new denom, no check is performed to ensure that the contract has sucient funds to cover the creator_fee. the tokenfactory module Since in https://github.com/neutron-org/neutron/blob/v1.0.2/x/tokenfactory/keeper/createdenom.go#L1 5, if the contract does not hold enough funds, an error will be raised. denom creation imposes fee for a This behavior could complicate the contract deployment process and lead to ineciencies.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "4. Overow checks not enabled for release prole", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Hadron Labs/2023-07-29 Audit Report - Hadron Labs Lido Satellite v1.0.pdf", "body": "The lido-satellite contract does not enable overflow-checks for the release prole. While enabled implicitly through the workspace manifest, future refactoring might break this assumption.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "6. Weights for most calls do not account for computation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dock/Dock PoS - Audit Report [20210706].pdf", "body": "The weights for calls cover storage reads and writes in all cases, but most weights do not account for time spent running the calls. There is a risk of some calls being overly cheap, which opens the possibility for an attacker to ood the network with transactions. When that happens, normal transactions might no longer be able to be processed.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "1. Unhandled zero-amount transfers in marketplace contract", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stargaze/2023-06-20 Audit Report - Stargaze Reserve Auctions v1.0.pdf", "body": "In several occurrences when performing BankMsg::Send, there is no validation to ensure the amount to transact is greater than zero. Consequently, the transaction will fail and revert. 1. 2. 3. 4. contracts/marketplace/src/execute.rs:1209-1216 the contracts/reserve-auction/src/helpers.rs:143-146, In settle_auction function will fail if the remaining amount is zero after deducting the protocol and royalty fees. In packages/common/src/lib.rs:78-82, the royalty_payout function will fail if the royaltys share is zero. In 1223-1230, deducting the royalty, network, and nder fees. lines In and 1074-1081, the value of execute_remove_stale_collection_bid functions will params.bid_removal_reward_percent is set to zero or to the maximum bps value. lines if the remaining amount is zero after execute_remove_stale_bid if contracts/marketplace/src/execute.rs:1023-1030 the payout function will fail and and the fail", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "4. Validate that the amount is not zero before sending funds to the bidder and operator. Status: Resolved 2. Protocol does not enforce minimum reserve price to be in STARS denom", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stargaze/2023-06-20 Audit Report - Stargaze Reserve Auctions v1.0.pdf", "body": "In contracts/reserve-auction/src/helpers.rs:131, the fair_burn function is called to burn a portion of the bid amounts, expecting the bid denom to be STARS. This is problematic because there is no validation ensuring that config.min_reserve_price is in the STARS denom. Additionally, when settling the auction in lines 143-146, the settle_auction function distributes the config.min_reserve_price is denominated in a dierent denom, incorrect funds will be distributed instead. Consequently, denom. STARS funds with the if", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "5. MAX_FIXED_PRICE_ASK_AMOUNT is not enforced during ask price update", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stargaze/2023-06-20 Audit Report - Stargaze Reserve Auctions v1.0.pdf", "body": "In the contracts/marketplace/src/execute.rs:412, execute_update_ask_price function does not validate the price.amount does not exceed MAX_FIXED_PRICE_ASK_AMOUNT. This invariant is enforced in line 308 during the execute_set_ask function, but it is not enforced when updating the asking price.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "6. TODO comment in the codebase", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stargaze/2023-06-20 Audit Report - Stargaze Reserve Auctions v1.0.pdf", "body": "In packages/common/src/lib.rs:65, a TODO comment is in the codebase. TODOs in production code are a deviation from best practices.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "7. Duplicate nder fee validation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stargaze/2023-06-20 Audit Report - Stargaze Reserve Auctions v1.0.pdf", "body": "contracts/marketplace/src/execute.rs:474-478 In duplicate validations of finders_fee_bps are performed. and 484-488, In fact, the only dierence lines between these two checks are variable names (fee vs finders_fee_bps), but validations are identical. the", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "8. Reserve prices can be updated for expired auctions", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Stargaze/2023-06-20 Audit Report - Stargaze Reserve Auctions v1.0.pdf", "body": "the contracts/reserve-auction/src/execute.rs:158, In execute_update_reserve_price function does not validate whether the auction is expired. An expired auction should not be modiable.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. Potential integer over-/underflows, division by zero", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dock/Audit Report - Dock Token Migration.pdf", "body": "In multiple places in the pallet, over-/underflows of integers are not checked and in one instance, a division by zero could occur: 1. bonus.total_locked_bonus += amount; in the add_swap_bonus function pallets/token_migration/src/lib.rs#L406", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "9. bonus.total_locked_bonus -= bonus_to_unlock; in the unlock_vesting_bonus Recommendation function ( pallets/token_migration/src/lib.rs#L531 ) We recommend checking for over-/underflow and division by zero manually or using checked_add , checked_sub , checked_mul checked_div or . Status: Resolved 2. Migrators have free autonomy to spend/transfer funds", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dock/Audit Report - Dock Token Migration.pdf", "body": "9. bonus.total_locked_bonus -= bonus_to_unlock; in the unlock_vesting_bonus Recommendation function ( pallets/token_migration/src/lib.rs#L531 ) We recommend checking for over-/underflow and division by zero manually or using checked_add , checked_sub , checked_mul checked_div or . Status: Resolved 2. Migrators have free autonomy to spend/transfer funds", "labels": ["Oak Security", "Severity: Low"]}, {"title": "1. Undelegations will fail when redelegating to a new validator", "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-03-22 Audit Report - DAO DAO Vesting and Payroll Factory v1.0.pdf", "body": "contracts/external/cw-vesting/src/stake_tracker.rs:71-74, In cardinality is not undelegations will fail in line 100 as the cardinality tries to decrement a zero-value. the increased when redelegating to a new validator. Consequently, Although the vesting recipient can prevent this issue by redelegating back to the source validator, it is irrecoverable if the vesting is canceled. In that case, the owner can no longer withdraw the delegated funds. Please see the test_redelegate_should_increase_cardinality test case to reproduce the issue.", "labels": ["Oak Security", "Severity: High"]}, {"title": "2. Misconguring the total vested amount to be lower than the sent CW20 amount would cause a loss of funds", "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-03-22 Audit Report - DAO DAO Vesting and Payroll Factory v1.0.pdf", "body": "In contracts/external/cw-vesting/src/contract.rs:38, the total amount of tokens to be vested depends on the PayrollInstantiateMsg.total amount (see the total contracts/external/cw-payroll-factory/src/contract.rs:87). amount to vest is lower than the sent CW20 amount, the excess tokens will be left in the cw-payroll-factory contract. If can Suppose a scenario where the cw-payroll-factory does not have any owner. An calling attacker higher ReceiveMsg::InstantiatePayrollContract PayrollInstantiateMsg.total amount, causing the cw-payroll-factory contract to send the excess funds to the newly instantiated cw-vesting contract. tokens with by a excess steal the Please see the test_inconsistent_cw20_amount test case to reproduce the issue.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "3. Misconguring start time to be in the past might cause undesired payouts", "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-03-22 Audit Report - DAO DAO Vesting and Payroll Factory v1.0.pdf", "body": "In contracts/external/cw-vesting/src/contract.rs:34, the start_time of the vesting can be set to a past value, which might lead to undesired payouts. We classify this issue as minor since only the owner can cause it.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "4. Vesting duration parameter is not validated", "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-03-22 Audit Report - DAO DAO Vesting and Payroll Factory v1.0.pdf", "body": "In cw-vesting/src/contract.rs:41, the duration_seconds parameter is initialized with a non-validated value. This results in the possibility of instant vesting, releasing funds immediately upon reaching start_time, which may not be intended. The value of duration_seconds is handled using the SaturatingLinear variant of the Schedule type. Using it with a start_time in the future and duration_seconds equal to 0 renders it equivalent to the PiecewiseLinear schedule consisting of a single step releasing the whole amount. We classify this issue as minor since only the contract instantiator can cause it.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "5. Undelegation does not emit custom events", "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-03-22 Audit Report - DAO DAO Vesting and Payroll Factory v1.0.pdf", "body": "undelegation in During contracts/external/cw-vesting/src/contract.rs:366, no events or attributes are emitted upon successful execution. This is inconsistent with execute_delegate and execute_redelegate, where attributes are emitted in lines 259 and 324, respectively. execute_undelegate function the in", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "6. Values held in StakeTracker cannot be queried", "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-03-22 Audit Report - DAO DAO Vesting and Payroll Factory v1.0.pdf", "body": "There is a certain amount of code implementing tracking of delegations in the cw-vesting smart contract. The structure StakeTracker, dened in stake_tracker.rs, contains the elds total_staked, validators, and cardinality. They all reect the chronology of staked funds by the validator and account unbonding times. However, call graph analysis reveals that only total_staked aects the outcome of transaction processing. In contrast, validators and cardinality are never read outside tests in stake_tracker_tests.rs. StakeTracker does, however, update them, e.g. in the on_bonded_slash function in stake_tracker.rs:113 with a clever technique of reconstructing proper delegated amounts after slashing events. The concern is that elds validators and cardinality require computation and on-chain space while not being utilized in any way except testing.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "7. Potential misleading error in ReceiveMsg::Fund", "html_url": "https://github.com/oak-security/audit-reports/tree/master/DAO DAO/2023-03-22 Audit Report - DAO DAO Vesting and Payroll Factory v1.0.pdf", "body": "In cw-vesting/src/contract.rs:153, the error ContractError::Funded is thrown if the status of the vesting is not Unfunded. However, the contract also can be in the Canceled state.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "2. Instantiator may introduce misconguration by providing non-compliant proxy code_id", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Public Awesome/2023-01-27 Audit Report - ICS721 v1.0.pdf", "body": "function instantiate in The contracts/cw-ics721-bridge/src/contract.rs:26 does not check to ensure that the proxy code_id specied is a compliant cw721-proxy contract. The functionality for the INSTANTIATE_PROXY_REPLY_ID reply is generic contract instantiation logic which does not conrm that the contract is compliant. While it is unlikely that the instantiator of the contract would unknowingly introduce a misconguration by providing an invalid proxy, the impact of this would be that NFTs could be sent from other chains to this bridge and debt vouchers could be minted, but they would be unredeemable if the proxy contract did not support the correct interface to allow for NFTs to be sent back to their origin chain. This could be corrected by a migration to a compliant proxy contract.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "1. No matter whether the user supplies one or more entries with the duplicated denom in the asset_amounts array of either the try_mint or the try_receive_burn function, only the rst entry will be used, all others will be ignored. In the case of a duplicate native token, a user could send just one entry in the asset_amounts argument to the try_mint function, but there will be a duplicate in subtraction contracts/nebula-cluster/src/contract/handle.rs:478. When that calculated happens, in contract from contracts/nebula-penalty/src/contract.rs:134 will stay the same (since the imbalance just shifts to the right). The denominator in line 137 will get smaller though, which will lead to a higher minted token amount for the attacker. If the attacker immediately burns the cluster tokens, they can drain assets from the cluster. inventory amount penalty reward token from the the the the of assert_sent_native_token_balance in The not contracts/nebula-cluster/src/contract/handle.rs:464 prevent this issue since it checks the amount in every iteration, and not the sum of the amounts across all tokens with the same denom. does We classify this issue as minor since it is caused by a wrong parameterization which can only be changed during initialization, by governance or the composition oracle. Recommendation We recommend checking the assets argument in the init and try_reset_target functions for duplicates and returning an error if any duplicates are found. Status: Resolved 5. No validation of initial cluster target weight sum to equal 100", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Nebula/Nebula - Audit Report.pdf", "body": "1. No matter whether the user supplies one or more entries with the duplicated denom in the asset_amounts array of either the try_mint or the try_receive_burn function, only the rst entry will be used, all others will be ignored. In the case of a duplicate native token, a user could send just one entry in the asset_amounts argument to the try_mint function, but there will be a duplicate in subtraction contracts/nebula-cluster/src/contract/handle.rs:478. When that calculated happens, in contract from contracts/nebula-penalty/src/contract.rs:134 will stay the same (since the imbalance just shifts to the right). The denominator in line 137 will get smaller though, which will lead to a higher minted token amount for the attacker. If the attacker immediately burns the cluster tokens, they can drain assets from the cluster. inventory amount penalty reward token from the the the the of assert_sent_native_token_balance in The not contracts/nebula-cluster/src/contract/handle.rs:464 prevent this issue since it checks the amount in every iteration, and not the sum of the amounts across all tokens with the same denom. does We classify this issue as minor since it is caused by a wrong parameterization which can only be changed during initialization, by governance or the composition oracle. Recommendation We recommend checking the assets argument in the init and try_reset_target functions for duplicates and returning an error if any duplicates are found. Status: Resolved 5. No validation of initial cluster target weight sum to equal 100", "labels": ["Oak Security", "Severity: Low"]}, {"title": "1. Non-deterministic iteration in BuildDependencyDag may break consensus", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-15 Audit Report - Sei Cosmos v1.0.pdf", "body": "In x/accesscontrol/keeper/keeper.go:333, nodes iterate over anteDepSet. Due to the non-deterministic behavior of iteration over maps in Go, there could be two dierent types of errors from ValidateAccessOp. This could lead to consensus failure.", "labels": ["Oak Security", "Severity: High"]}, {"title": "2. RegisterWasmDependency allows anyone to register contract dependency mappings that can increase gas consumption", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-15 Audit Report - Sei Cosmos v1.0.pdf", "body": "function RegisterWasmDependency in The x/accesscontrol/keeper/msg_server.go:22 allows anyone to register contract dependency mappings. It does not validate if the transaction sender is the contract owner. the Sei Chain where the These contract dependency mappings are used by in GetWasmDependencyMapping x/accesscontrol/keeper/keeper:126 gets a contracts dependency mapping information. This may create opportunities for attackers to exploit applications on top of Sei Chain. For instance, an exploiter can make the getMessageMultiplierDenominator function return WasmCorrectDependencyDiscountDenominator. This will lead to an increase of the the DispatchMsg function in gas consumption for wasmbinding/message_plugin.go:118 of Sei Chain does not validate message dependencies if a contracts WasmDependencyMapping is disabled. app/antedecorators/gas.go:34 that particular contract. Moreover, function dened Chain Sei of in", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "3. Several errors are not handled and may cause an inconsistent state", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-15 Audit Report - Sei Cosmos v1.0.pdf", "body": "there are unhandled errors that allow execution to In several places of continue even when operations have failed. This may produce inconsistent states and unexpected panics. the codebase, Instances of unhandled errors can be found in:  x/bank/keeper/keeper.go:47  x/bank/keeper/keeper.go:456  x/bank/keeper/keeper.go:434  x/bank/keeper/keeper.go:378  x/accesscontrol/handler.go:14  baseapp/abci.go:31 As an example, the UpsertDeferredSends function may return an error, which is not checked. The calling function, DeferredSendCoinsFromAccountToModule, should propagate the Error upstream, but since the Error is not handled this will not happen. Since the execution would continue, it may leave the network in an inconsistent state or cause an unexpected panic.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "4. Missing LegacyAmino codec registration", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-15 Audit Report - Sei Cosmos v1.0.pdf", "body": "In x/accesscontrol/module.go:45, the RegisterLegacyAminoCodec function does not register the modules LegacyAmino codec. This is necessary for JSON serialization to support hardware devices like Ledger since these devices do not support proto transaction signing.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "5. Use of deprecated function", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-15 Audit Report - Sei Cosmos v1.0.pdf", "body": "x/accesscontrol/client/utils/utils.go:15 and In x/accesscontrol/client/utils/utils.go:28, the ReadFile function is called from the ioutil package, yet that package is deprecated as of Go 1.16. The function should be used from the os package instead.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "6. Resolve TODOs before release", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-15 Audit Report - Sei Cosmos v1.0.pdf", "body": "There are multiple TODOs in the codebase that may refer to sensitive or important logic. Instances are:  baseapp/abci.go:170  baseapp/baseapp.go:717  x/accesscontrol/keeper/keeper.go:406  types/module/module.go:289", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "7. Unnecessary lock acquisition might negatively impact performance", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-15 Audit Report - Sei Cosmos v1.0.pdf", "body": "In types/context_cache.go:68, there is a check to circuit break in case the amount is not valid. However, before that check, a lock is acquired which is not needed for this specic validation.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "8. MintCoins does not perform a nil pointer validation in case the module name is passed incorrectly", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-15 Audit Report - Sei Cosmos v1.0.pdf", "body": "In x/bank/kepper/keeper.go:561, the module account is retrieved to add coins to it through the createCoins function in line 565. However, if the moduleName does not exist, it would return a nil pointer from the GetModuleAccountAndPermissions function. Currently, the only place that the function is called is in x/mint/keeper/keeper.go:103, and the module name is a constant. Therefore, unless that specic module name does not exist, there is no attack vector with the current design.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "9. Unused assignment in GetSigners", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-15 Audit Report - Sei Cosmos v1.0.pdf", "body": "In types/tx/types.go:125, there is an assignment to the variable seen which is never used thereafter.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "10. Commented code in encryptPrivKey", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-15 Audit Report - Sei Cosmos v1.0.pdf", "body": "In encryptPrivKey in crypto/armor.go:149, there is an assignment that has been commented out.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "11. Missing usage description for transaction and query CLI commands", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-15 Audit Report - Sei Cosmos v1.0.pdf", "body": "transaction in The commands and and x/accesscontrol/client/cli/tx.go:18 x/accesscontrol/client/cli/query.go:13 are missing a long message to describe their usage, which could be helpful for users and external developers. accesscontrol module query the of", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "12. Miscellaneous comments", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Sei/2023-05-15 Audit Report - Sei Cosmos v1.0.pdf", "body": "Across the codebase, various instances of unused code and misleading comments have been found.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. Cache hit counters can be used to crash nodes and halt a chain", "html_url": "https://github.com/oak-security/audit-reports/tree/master/CosmWasm/2023-03-27 Audit Report - CosmWasm v1.0.pdf", "body": "The VM implementation contains a cache to eciently load smart contract instances that are pinned or used repeatedly. For analytical purposes, that cache increments the hit counters hits_pinned_memory_cache, in packages/vm/src/cache.rs whenever an instance is read from it. These hit counters are incremented using integer addition, which can cause panics in the case of integer overows. hits_memory_cache, hits_fs_cache and An attacker can exploit this issue to crash a node and possibly even halt the chain, for example by repeatedly querying an instance from a CosmWasm smart contract. The hit counters currently use the u32 type. To cause an overow, almost 4.3 billion cash hits are required. While this is a huge number, the counters are only reset upon node restart, so there is a real possibility for long-running nodes to suer from such an overow panic. Moreover, an attacker does not need to cause almost 4.3 billion cache hits within one transaction  such an attack can be executed across many blocks. Query nodes are even easier to target, since they can be queried repeatedly with little resource cost by the attacker.", "labels": ["Oak Security", "Severity: High"]}, {"title": "2. Gas counting in vm backend does not correctly add externally used gas", "html_url": "https://github.com/oak-security/audit-reports/tree/master/CosmWasm/2023-03-27 Audit Report - CosmWasm v1.0.pdf", "body": "The packages/vm/src/backend.rs:56: GasInfos add_assign method incorrectly sets in externally_used: self.externally_used + other.cost This implies that the externally_used gas of other is not accounted for. An attacker could call external them, potentially blocking block production. functions without paying gas for We classify this issue as minor since the add_assign method is currently only used in test code.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "3. Overow in gas counting might halt block production", "html_url": "https://github.com/oak-security/audit-reports/tree/master/CosmWasm/2023-03-27 Audit Report - CosmWasm v1.0.pdf", "body": "and add_asign process_gas_info The in packages/vm/src/backend.rs:55, 56, packages/vm/src/environment.rs:341 and 352, which could potentially allow an attacker to halt block production of the underlying blockchain if the CosmWasm vm is compiled without overflow-checks enabled for the release prole. functions overow might", "labels": ["Oak Security", "Severity: Low"]}, {"title": "4. Ed25519 batch verication is not benchmarked, might run out of memory and halt block production", "html_url": "https://github.com/oak-security/audit-reports/tree/master/CosmWasm/2023-03-27 Audit Report - CosmWasm v1.0.pdf", "body": "The do_ed25519_batch_verify function imposes limits to the number of messages, signatures, and public keys per batch in packages/vm/src/imports.rs:291-305, but there currently exists no benchmarking code in the codebase that veries that these limits are reasonable. production of the underlying blockchain might halt. If the limits are too high, validators might run out of memory, and block", "labels": ["Oak Security", "Severity: Low"]}, {"title": "5. Unlimited WASM table size may be exploited to crash the node", "html_url": "https://github.com/oak-security/audit-reports/tree/master/CosmWasm/2023-03-27 Audit Report - CosmWasm v1.0.pdf", "body": "of the states memory While in packages/vm/src/wasm_backend/store.rs:82, tables are not. The WebAssembly (see spec https://webassembly.github.io/spec/core/syntax/types.html#table-types). If such a growth of a table can be triggered from smart contracts, it may exhaust the resources of the underlying node, potentially crashing it and stopping block production. can grow indenitely instances are not limited, limited tables they that is if We tried to write a WASM module using WAT that adds new elements in a loop, but apparently, elem sections need to be at the module top level, so adding more entries to the table would linearly increase the WASM blob size. While we have not been able to exploit this issue by adding elements to the table, there may be other ways to make the table size grow indenitely.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "6. Unbounded iteration over WASM imports may slow down block production or stop the chain", "html_url": "https://github.com/oak-security/audit-reports/tree/master/CosmWasm/2023-03-27 Audit Report - CosmWasm v1.0.pdf", "body": "The check_wasm_imports function collects all into a BTreeSet in packages/vm/src/compatibility.rs:152, which uses an unbounded iteration over the imports. This may be exploited to slow down block production, possibly even stopping the chain. the wasm contract imports of We classify this issue as minor since there is an implicit limit to the number of imports through the WASM size limit.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "7. Compilation of wasm code does not specify memory limit and might halt block production", "html_url": "https://github.com/oak-security/audit-reports/tree/master/CosmWasm/2023-03-27 Audit Report - CosmWasm v1.0.pdf", "body": "The save_wasm function calls compile in packages/vm/src/cache.rs:154 without setting a memory limit. This could cause the node to run out of memory, potentially halting block production of the underlying blockchain if no mechanism for recovery is implemented. We only consider this to be an informational issue since the underlying blockchain should reject wasm code that is too big, and the singlepass compiler used will execute in linear time, preventing JIT-bombs.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "8. Attribute keys starting with underscores lead to panics, causing smart contract runtime errors in debug mode", "html_url": "https://github.com/oak-security/audit-reports/tree/master/CosmWasm/2023-03-27 Audit Report - CosmWasm v1.0.pdf", "body": "for attributes constructor The in packages/std/src/results/events.rs:71 if an attribute key starts with an underscore _. This will lead to runtime errors for smart contract projects that have code paths that were not extensively tested. An example could be a DeFi protocol that adds an attribute with an underscore under certain conditions, for example an emergency withdrawal. The panic would prevent the emergency withdrawal, putting user funds at risk. debug panics mode in The check in the constructor does also not guarantee that a key does not start with an underscore, since library users could simply manually push attributes with any key. We classify this issue as informational since it only aects code compiled with debug assertions.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "9. Overows could occur if library users do not enable overow-checks, panics abort execution", "html_url": "https://github.com/oak-security/audit-reports/tree/master/CosmWasm/2023-03-27 Audit Report - CosmWasm v1.0.pdf", "body": "In several places in the codebase, overows are not handled explicitly. This is not a security concern as long as overow-checks are enabled for the release prole, but there is a risk that a library user does not enable overow-checks. Additionally, overow-checks cause overows to panic, which is less user friendly than an overow error message that allows unwinding the operation. A panic in WebAssembly always aborts the execution and does not unwind. Instances of potential overows are: - - - - The nextval function in packages/storage/src/sequence.rs:19. The plus_seconds, plus_nanos, minus_seconds, and minus_nanos methods in packages/std/src/timestamp.rs:37-57. The isqrt method in packages/std/src/math/isqrt.rs:28. The sqrt_with_precision method in packages/std/src/math/decimal.rs:181 and in packages/std/src/math/decimal256.rs:194.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "10. Math method types are inconsistent and not exhaustive", "html_url": "https://github.com/oak-security/audit-reports/tree/master/CosmWasm/2023-03-27 Audit Report - CosmWasm v1.0.pdf", "body": "In packages/std/src/math, several math types are implemented, such as Decimal, Decimal256, Uint64, Uint128, or Uint256. The API of those math types contains several inconsistencies and functionality diverges or is partially not implemented, even between similar types such as Uint64 and Uint128. These dierences can lead to a decrease in the development experience when using math types of the std package. Examples of these discrepancies are: - - - - - - - - - - - - - - - - Sub and Mul are implemented for Uint128, Uint256 and Uint512, but missing for Uint64. SubAssign and MulAssign are implemented for Uint128, Uint256 and Uint512, but missing for Uint64. wrapping_add, wrapping_sub, wrapping_mul, and wrapping_pow are implemented for Uint64 and Uint128, but missing for Uint256 and Uint512. Mul is implemented for Decimal and Decimal256, but Div is not implemented for them. For Decimal and Decimal256, Div returns a Decimal, while DivAssign returns a Uint128 multily_ratio and full_mul is implemented for Uint64, Uint128 and Uint256 but missing for Uint512. pow is implemented for Uint256 but missing for Uint64, Uint128 and Uint512. checked_pow is implemented for Uint128 and Uint256 but missing for Uint64 and Uint512. saturating_pow is implemented for Uint128, but missing for Uint256 and Uint512. check_div_euclid is implemented for Uint64 and Uint128, but missing for Uint256 and Uint512. Shl is implemented for Uint256, but missing for Uint64, Uint128 and Uint512. ShrAssign is implemented for Uint64, Uint128, Uint256 and Uint512, but ShlAssign is missing for all unsigned integers. checked_shl is implemented for Uint256, but missing for Uint64, Uint128 and Uint512. Inconsistent with other methods, TryFrom<Uint128> for Uint64 is dened in packages/std/src/math/uint128.rs, and not in packages/std/src/math/uint64.rs. Inconsistent with other methods, TryFrom<Uint512> for Uint128 is dened in packages/std/src/math/uint512.rs, and not in packages/std/src/math/uint128.rs. The from_str function results in an error on an empty string in packages/std/src/math/uint256.rs, but not in packages/std/src/math/uint128.rs and packages/std/src/math/uint512.rs, which is inconsistent. - - - - - - - - Inconsistent with other methods, TryFrom<Uint256> for Uint128 is dened in packages/std/src/math/uint256.rs, and not in packages/std/src/math/uint128.rs. In packages/std/src/math/uint128.rs:215, StdError::generic_err is used for parsing errors instead of StdError::parse_err. The new function in packages/std/src/math/uint512.rs is not marked as const, which it is in packages/std/src/math/uint256.rs. Some methods return StdError::generic_err(\"Error parsing whole\") while others return an ParseErr. Some methods return StdError::generic_err(format!(\"Serializing QueryRequest: {}\", serialize_err)) instead of StdError::serialize_err. The wasmer::SerializeError and wasmer::DeserializeError is wrongly transformed into a VmError::cache_err instead of a VmError::serialize_err in packages/vm/src/errors/vm_error.rs:325 and 331. The VmError::cache_err in packages/vm/src/checksum.rs:47 should be a VmError::conversion_err. Some methods use expect, while others use unwrap, which results in panics without messages explaining what went wrong.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "11. Several dependencies are outdated", "html_url": "https://github.com/oak-security/audit-reports/tree/master/CosmWasm/2023-03-27 Audit Report - CosmWasm v1.0.pdf", "body": "There are several dependencies that are not used in their latest version. Some of them contain security vulnerabilities. A subset that might introduce vulnerabilities is: - - - - chrono contains a potential segfault, currently used in version 0.4.19, no safe upgrade available. time contains a potential segfault, currently used in version 0.1.43, upgrade to >= 0.2.23 instead. ed25519-zebra is currently used in version 2.2.0, available in 3.0.0 rand_core is currently used in version 0.5.1 in package cosmwasm-crypto, available in 0.6.3", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "12. Unaudited cryptography library", "html_url": "https://github.com/oak-security/audit-reports/tree/master/CosmWasm/2023-03-27 Audit Report - CosmWasm v1.0.pdf", "body": "The library implementation of ECDSA in crate k256 is unaudited and comes with the following warning in its documentation: Security Warning The elliptic curve arithmetic contained in this crate has never been independently audited! crate This has been designed with the goal of ensuring that secret-dependent operations are performed in constant time (using the subtle crate and constant-time formulas). However, it has not been thoroughly assessed to ensure that generated assembly is constant time on common CPU architectures. USE AT YOUR OWN RISK!", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "13. Ed25519 batch verication succeeds for empty data, which may not be obvious to library users", "html_url": "https://github.com/oak-security/audit-reports/tree/master/CosmWasm/2023-03-27 Audit Report - CosmWasm v1.0.pdf", "body": "The ed25519_batch_verify function in packages/crypto/src/ed25519.rs:65 succeeds if provided with an empty collection of messages, signatures, and public keys. This behavior is correctly documented in line 64. Still, an unsuspecting library user might not be aware of this implementation, which could lead to bugs in dependent codebases.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "14. Consuming gas after performing Ed25519 batch verication is inecient", "html_url": "https://github.com/oak-security/audit-reports/tree/master/CosmWasm/2023-03-27 Audit Report - CosmWasm v1.0.pdf", "body": "do_ed25519_batch_verify The in packages/vm/src/imports.rs:312-318 after executing the batch verication in line 311. This is inecient since the verication can be skipped if the gas limit is hit. consumes currently function gas", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "15. Missing overow checks", "html_url": "https://github.com/oak-security/audit-reports/tree/master/CosmWasm/2023-03-27 Audit Report - CosmWasm v1.0.pdf", "body": "The workspace manifest Cargo.toml as well as the following packages do not enable overflow-checks for the release prole: packages/profiler/Cargo.toml - packages/crypto/Cargo.toml - packages/derive/Cargo.toml - - packages/schema/Cargo.toml - packages/std/Cargo.toml - packages/storage/Cargo.toml - packages/vm/Cargo.toml", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. Overow checks are not enabled for the release prole, which can lead to a loss of funds", "html_url": "https://github.com/oak-security/audit-reports/tree/master/CW20 Blocklist/2022-05-25 Audit Report - CW20 Blocklist v1.0.pdf", "body": "In contracts/cw20-blocklist/Cargo.toml, overflow-checks are not enabled for the release prole. Since there are arithmetic calculations that do not use checked increasing an calculations to prevent overow issues in the cw20-base contract accounts balance), an overow in production would be silently ignored. (e.g.", "labels": ["Oak Security", "Severity: High"]}, {"title": "2. Users can evade having blocked funds destroyed by using uppercase addresses", "html_url": "https://github.com/oak-security/audit-reports/tree/master/CW20 Blocklist/2022-05-25 Audit Report - CW20 Blocklist v1.0.pdf", "body": "The cw20-blocklist contract does maintain the blocklist with lowercase addresses, and it performs lowercasing of an address before checking whether it is on the blocklist. The underlying cw20-base contract, on the other hand, does not lowercase addresses. This discrepancy allows users to evade having blocked funds destroyed, by having their balance sent to an uppercase address, rather than a lowercase one. If a user sends the the Transfer message to a previously unused and not blocked uppercase address, execute_transfer function of the cw20-base contract will update BALANCES with the uppercase address as the key. Blocklisting that address works as expected, since all blocklist see checks If the minter contracts/cw20-blocklist/src/contract.rs:195, 211, and 254. now wants the address DestroyBlockedFunds message, the destroy_blocked_funds function is trying to reduce BALANCES using the lowercased address as a key in lines 160-168. This will fail, since the balance was stored under an uppercase address as the key. associated with transforming lowercase, performed address funds using burn after that are the the to to", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "3. Missing validations during contract instantiation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/CW20 Blocklist/2022-05-25 Audit Report - CW20 Blocklist v1.0.pdf", "body": "In contracts/cw20-blocklist/src/contract.rs:36-38, msg.name, msg.symbol, and msg.decimals are not validated. the passed arguments Without validation of name and symbol, the minter is able to pass invalid or non-printable characters that could aect front-end rendering, allow script injection, or passing strings very long strings which may inhibit usability of the token. Without validation of decimals, the minter is able to pass any supported u8 value (from 0 to 255). An uncommonly large decimal point might cause issues for protocols that build on top of this contract.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "4. One-step minter update increase risk of lost minter permissions", "html_url": "https://github.com/oak-security/audit-reports/tree/master/CW20 Blocklist/2022-05-25 Audit Report - CW20 Blocklist v1.0.pdf", "body": "The cw20-blocklist contract allows the current minter to update the minter address in one single step. While this is common practice, it presents a risk for the minting permission to become lost if the new address is incorrect. A two-step minter update will allow the current minter to propose a new minter address, and then the account that is proposed as the new minter may call a separate function that will allow them to claim the minting permission and actually execute the cong update.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "5. Consider using time locks to automatically unblock addresses in the event of a lost/compromised minter private key", "html_url": "https://github.com/oak-security/audit-reports/tree/master/CW20 Blocklist/2022-05-25 Audit Report - CW20 Blocklist v1.0.pdf", "body": "Throughout the codebase, the minter can perform various privileged actions such as adding and removing addresses to/from the blocklist. A blocked address will remain blacklisted until the minter decides to unblock them. In the event that the private key is lost or compromised and the minter updated, the blacklisted address may never be unblocked.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "6. Blocked addresses can receive tokens", "html_url": "https://github.com/oak-security/audit-reports/tree/master/CW20 Blocklist/2022-05-25 Audit Report - CW20 Blocklist v1.0.pdf", "body": "In the codebase, there are no restrictions that prevent blocked addresses from receiving tokens. Since the minter can destroy funds held by a blocked address using the DestroyBlockedFunds message, we recommend disallowing funds to be sent to a blocked address.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "7. Removal of Burn and BurnFrom may impact contract composability", "html_url": "https://github.com/oak-security/audit-reports/tree/master/CW20 Blocklist/2022-05-25 Audit Report - CW20 Blocklist v1.0.pdf", "body": "The cw20-blocklist contract does not include the Burn and BurnFrom messages that the cw20-base contract provides. This may impact composability of the cw20-blocklist contract with other smart contracts, In the current implementation, a Redeem message exists, that only allows the minter to burn tokens. that may rely on burning of funds.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "8. Duplicate code impacts maintainability", "html_url": "https://github.com/oak-security/audit-reports/tree/master/CW20 Blocklist/2022-05-25 Audit Report - CW20 Blocklist v1.0.pdf", "body": "Throughout the codebase, privileged execution messages such as AddToBlockedList, RemoveFromBlockedList, UpdateMinter, Redeem, and DestroyBlockedFunds messages are all restricted to minter access. The logic that veries whether info.sender is the minter is duplicated across the handlers for these functions, which negatively impacts the code's maintainability and readability and may lead to future errors.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "9. cw20-blocklist modies cw20-base interface, which negatively impacts composability and is not documented correctly", "html_url": "https://github.com/oak-security/audit-reports/tree/master/CW20 Blocklist/2022-05-25 Audit Report - CW20 Blocklist v1.0.pdf", "body": "Compared with the cw20-base contract, following modications: the cw20-blocklist contract exhibits the Initial balances cannot be provided during instantiation 1. Minter is always set to the instantiator 2. Minting cap cannot be set 3. 4. Marketing info cannot be set or queried 5. Burn and BurnFrom messages have been removed 6. Minter, AllAllowances, AllAccounts, MarketingInfo, and DownloadLogo queries have been removed This reduces the composability of the cw20-blocklist contract, since it may not be possible for some projects to swap a cw20-base contract with a cw20-blocklist It also aects frontends and implementation without aggregation layers that may rely on some of the removed queries. Lastly, the documentation in contracts/cw20-blocklist/README.md:3 describes that the cw20-blocklist further modication of their code. contract extends the cw20-base to add blocklist functionality, which is misleading.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "10. Testing wallet seed phrase and private keys are exposed", "html_url": "https://github.com/oak-security/audit-reports/tree/master/CW20 Blocklist/2022-05-25 Audit Report - CW20 Blocklist v1.0.pdf", "body": "In keys.terrain.js, the testing wallets mnemonic and private keys are hardcoded and visible to the public. Although these secrets are intended to be used purely for testing purposes, it is a violation of best practice to commit wallet seed phrases or private keys into a repository. These accounts may accidentally be used by developers on mainnet, in which case funds may be lost or permissions be exploited.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "11. Outdated dependencies", "html_url": "https://github.com/oak-security/audit-reports/tree/master/CW20 Blocklist/2022-05-25 Audit Report - CW20 Blocklist v1.0.pdf", "body": "The cw20-blocklist contract contains outdated dependencies, see Appendix 1.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. Attacker can drain funds by refusing completed oers", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Illiquid Labs/2023-01-10 Audit Report - Illiquid Labs v1.0.pdf", "body": "In contracts/nft-loans-non-custodial/src/execute.rs:336, a borrower can refuse an oer even if the oer had been accepted. Suppose a borrower calls RefuseOffer for an accepted loan  that allows the lender to call WithdrawRefusedOffer in order to withdraw the deposited funds. This is problematic because the lender already had their principal in back interest contracts/nft-loans-non-custodial/src/execute.rs:546-549, resulting in the contract losing funds. repaid and An attacker can exploit this issue by completing and refusing a loan to withdraw excess funds as the lender. This can be exploited repeatedly to drain all funds from the contract. Please see the test_steal_funds test case to reproduce the issue.", "labels": ["Oak Security", "Severity: High"]}, {"title": "2. Borrowers are forced to default on loans with zero fees or interest", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Illiquid Labs/2023-01-10 Audit Report - Illiquid Labs v1.0.pdf", "body": "In the contracts/nft-loans-non-custodial/src/execute.rs:557-567, contract tries to send fees to the treasury without validating that the amount is greater than zero. Suppose a lender accepted a loan with the loan terms interest as 0. The calculated fee amount would be zero (see line 531), causing the contract to send 0 funds to the fee contract. Since Cosmos SDK does not allow 0 amount transfers, borrowers would not be able to repay in time, causing their loans to default. A lender can exploit this issue by providing zero-interest loans, forcing the borrower to default on their loans so the lender can have the NFT in return. Additionally, this issue will also occur if the admin sets the fee rate to the maximum value, preventing all borrowers from repaying their loans successfully.", "labels": ["Oak Security", "Severity: High"]}, {"title": "3. Attackers can steal NFTs with approvals on contract", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Illiquid Labs/2023-01-10 Audit Report - Illiquid Labs v1.0.pdf", "body": "and In contracts/nft-loans-non-custodial/src/execute.rs:433-440 contracts/raffles/src/execute.rs:64-71, the CW721 NFT is transferred to the contract using the TransferNft message without verifying the caller is the owner of the NFT. Since the transferred NFT is stored under the callers rae or loan, the caller can withdraw the NFT after it ends, causing the real owner to lose their NFT. The possibility of this could happen when the user approves their NFT in the rst transaction but fails to create a successful rae or loan in the second transaction (e. g. due to invalid arguments). An attacker can then exploit the vulnerability If the approval is not revoked and does not expire in the next block. We classify this as a major issue because the attack requires pre-approval on the contract for successful exploitation.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "4. Malicious rae owner can replay CancelRaffle message to steal NFTs in contract", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Illiquid Labs/2023-01-10 Audit Report - Illiquid Labs v1.0.pdf", "body": "In contracts/raffles/src/execute.rs:172, the get_raffle_owner_messages function is called to refund the owner their NFT when the owner cancels a rae. The execute_cancel_raffle function does not prevent replay attacks, allowing the owner to cancel a rae as long as there are no tickets bought. An attacker can exploit this issue by creating a rae and immediately canceling it, resulting in the contract storing a valid RAFFLE_INFO for the specic rae identier value. After that, the attacker sells the NFT in a marketplace to a victim. Once the victim creates a rae and deposits the NFT into the contract, the attacker executes CancelRaffle and steals the NFT. We classify this as a major issue due to the high exploit diculty.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "5. Incorrect implementation of CW20 Receive message", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Illiquid Labs/2023-01-10 Audit Report - Illiquid Labs v1.0.pdf", "body": "In contracts/raffles/src/contract.rs:113, users can deposit CW20 tokens into the contract through a receive callback function. However, the callback message does not follow the CW20 specication. Consequently, users are unable to deposit CW20 into the rae contract directly. We consider this a minor issue as users can still deposit CW20 tokens using the allowance functionality.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "6. Consider validating fee distribution address and fee rate", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Illiquid Labs/2023-01-10 Audit Report - Illiquid Labs v1.0.pdf", "body": "contracts/nft-loans-non-custodial/src/contract.rs:45 and In contracts/nft-loans-non-custodial/src/admin.rs:40, the contract owner instantiates and updates the fee distributor address. However, in each case, the address is not validated, which could lead to the contract being unable to execute as transfers may be made to an invalid address. the owner contract in Similarly, and contracts/nft-loans-non-custodial/src/contract.rs:46 contracts/nft-loans-non-custodial/src/admin.rs:61. A miscongured fee rate would prevent users from repaying borrowed funds due to overows occurring in contracts/nft-loans-non-custodial/src/execute.rs:527. instantiates updates rate and the fee We classify this as a minor issue since only the owner can cause it.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "1. Schedule cli shifts the unlock start date rather than leads to unlocked tokens that cannot be claimed yet", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-12-07 Audit Report - Astroport Builder Unlock Contract v1.0.pdf", "body": "a and When dening an allocation of ASTRO for a user, the contract owner species a start date, a calculating the unlocked_amount in cli, duration. However, when time and cli are contracts/builder_unlock/src/contract.rs:939, the added, eectively just shifting the start date. The consequence of unlock_amount does not increase linearly from the start time, but from the sum of start date and cli instead. this is that the start contradicts in This packages/astroport-governance/src/builder_unlock.rs:35 which states Time after the cliff during which the remaining tokens linearly unlock. comment the", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "2. Recipient transfer does not transfer unlocked amount checkpoint", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-12-07 Audit Report - Astroport Builder Unlock Contract v1.0.pdf", "body": "the in During execute_claim_receiver contracts/builder_unlock/src/contract.rs:650, only the astro_withdrawn eld of the allocation status STATUS is transferred to the new receiver, but not any amount that was previously unlocked in unlocked_amount_checkpoint. function This implies that the new receiver may have to wait longer for funds to unlock in the case where the previous recipient had an allocation decrease and the unlocked funds were stored in unlocked_amount_checkpoint.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "3. Increasing the cli may result in unlocked tokens becoming locked again", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-12-07 Audit Report - Astroport Builder Unlock Contract v1.0.pdf", "body": "In the increase_cliffs function, the contract owner can set a new cli for an allocation in in already contracts/builder_unlock/src/contract.rs:721. This may result unlocked tokens no longer being unlocked. Apart from this, an increasing cli in the current implementation may lead to an underow causing a panic in line 970 if a user already withdrew a bigger amount than the new unlocked amount. Note that this has no security implication, but a panic leads to a bad user experience.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "4. Inconsistency in validation during recipient transfer may lead to a loss of funds", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-12-07 Audit Report - Astroport Builder Unlock Contract v1.0.pdf", "body": "the execute_propose_new_receiver returned in In contracts/builder_unlock/src/contract.rs:389 if the receiver has allocation parameters PARAMS with a non-zero amount. In the execute_claim_receiver function, however, an error is returned in contracts/builder_unlock/src/contract.rs:630 if a PARAMS entry exists for the receiver, even if the amount is zero. function, error an is This inconsistency allows a recipient with PARAMS but a zero amount to be proposed as the receiver, but that new recipient can never claim that allocation. This might lead to a loss of funds for the new receiver if the previous receiver of the allocation does not cooperate to resolve the issue. We classify this issue as minor since rstly, the creation of PARAMS allocations with a zero amount does not make much sense and may never exist, and secondly, the previous and new recipients are likely controlled by the same entity, in which case they can resolve the issue.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "5. Maximum allocation amount can be set lower than total deposits", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-12-07 Audit Report - Astroport Builder Unlock Contract v1.0.pdf", "body": "the update_config a In in new_max_allocations_amount contract/builder_unlock/src/contract.rs:689. There is currently no validation, however, that the new value is bigger than total_astro_deposited. contract function owner able the set to is This max_allocations_amount and implies that no new allocations can be created. total_astro_deposited assumption breaks that the <= We classify this issue as minor since only the owner can cause it, and since it can be resolved by the owner.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "6. Transfer of unallocated tokens leads to wrong token accounting", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-12-07 Audit Report - Astroport Builder Unlock Contract v1.0.pdf", "body": "During the execute_transfer_unallocated function, the total_astro_deposited the state the execute_increase_allocation in total_astro_deposited is which inconsistent decreased. increases function, variable amount This with not is contracts/builder_unlock/src/contract.rs:519. total_astro_deposited amount hence includes unallocated tokens. The Consequently, the total_astro_deposited state variable will be bigger than actual deposits after a transfer of unallocated funds. This implies that the condition checking total_astro_deposited against max_allocations_amount in line 523 will lead to an surpass the max_allocations_amount. deposited amount actual does even error not if We classify this issue as minor since it can be worked around by the owner by increasing max_allocations_amount.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "7. Lack of validation when creating an allocation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-12-07 Audit Report - Astroport Builder Unlock Contract v1.0.pdf", "body": "In the execute_create_allocations function, the passed AllocationParams are stored in contracts/builder_unlock/src/contract.rs:295. This implies that allocations can be created with a start_time in the past, a zero duration, zero amount or an invalid proposed_receiver address.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "8. Unnecessary lowercasing of addresses is inecient", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-12-07 Audit Report - Astroport Builder Unlock Contract v1.0.pdf", "body": "the both codebase, Throughout custom addr_validate_to_lower function are used to convert String to Addr types and validate their correctness. As the version of cosmwasm-std dened in the Cargo.toml is it is no longer necessary to convert strings to lowercase. Using a custom function is 1.1, inecient and unnecessarily increases the codebase. deps.api.validate and the the", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "9. Unnecessary load of PARAMS during creation of an allocation is inecient", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-12-07 Audit Report - Astroport Builder Unlock Contract v1.0.pdf", "body": "During the creation of an allocation, the contract veries that a user does not have an existing in allocation contracts/builder_unlock/src/contract.rs:287. Loading the value is inecient though, since it is not used. PARAMS loading value from the by", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "10. Unnecessary validation of STATUS during creation of an allocation is inecient", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-12-07 Audit Report - Astroport Builder Unlock Contract v1.0.pdf", "body": "by During the creation of an allocation, the contract veries that a user does not have an existing allocation in contracts/builder_unlock/src/contract.rs:299. However, there is already a check for PARAMS in line 287. Since both STATUS and PARAMS are created for new allocations, non-existence of an entry in PARAMS implies non-existence of that entry in STATUS, which makes the STATUS check unnecessary. checking STATUS the", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "11. Unnecessary loading of STATUS during claim of new receiver is inecient", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-12-07 Audit Report - Astroport Builder Unlock Contract v1.0.pdf", "body": "In the execute_claim_receiver function, the STATUS of the new receiver is loaded in contracts/builder_unlock/src/contract.rs:649. However, an error is returned before in line 630 if that new receiver has stored PARAMS. Since PARAMS and STATUS for a receiver always exist both or neither, the code block in lines 649-653 has no eect.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "12. Misleading function name compute_withdraw_amount may negatively impact maintainability", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-12-07 Audit Report - Astroport Builder Unlock Contract v1.0.pdf", "body": "The compute_withdraw_amount function calculates the amount of Astro a user may withdraw in contracts/builder_unlock/src/contract.rs:956. the function also updates the users STATUS, which contradicts the function name, which only indicates a computation. This might mislead In addition,", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "13. Inecient validation of prev_receiver", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-12-07 Audit Report - Astroport Builder Unlock Contract v1.0.pdf", "body": "When a user accepts a claim of a token allocation, the function loads the PARAMS and in STATUS contracts/builder_unlock/src/contract.rs:625 and subsequently removes both the PARAMS and STATUS of said previous receiver. previous receiver the of During each of these four interactions, the function validates the prev_receiver address. This is unnecessary and wastes computational resources.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "14. Lack of error message for query of non-existent allocation may confuse users", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-12-07 Audit Report - Astroport Builder Unlock Contract v1.0.pdf", "body": "When an allocation does not exist for a queried user through the QueryMsg::Allocation the query_allocation function returns an allocation with empty values in query, contracts/builder_unlock/src/contract.rs:760 and 763, rather than an error message that the allocation does not exist. This may be confusing to users.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. Excess liquidity pool tokens are never refunded to the user", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dexter/2023-03-15 Audit Report - Dexter v1.0.pdf", "body": "In contracts/vault/src/contract.rs:1084, excess liquidity pool tokens are refunded to the caller. However, the recipient should be cw20_msg.sender instead of info.sender, which represents the liquidity pool token itself instead of the original sender. Consequently, excess tokens will be transferred to the liquidity token itself, causing a loss of funds for the sender.", "labels": ["Oak Security", "Severity: High"]}, {"title": "2. Malicious users can prevent stakers from withdrawing LP tokens and rewards", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dexter/2023-03-15 Audit Report - Dexter v1.0.pdf", "body": "add_reward_schedule The in contracts/multi_staking/src/contract.rs:183 allows any user to add a rewards schedule with any asset. This is problematic because a user may add a malicious token contract that returns an error when its Transfer message is invoked, eectively blocking users from being able to withdraw their funds. function In addition, this function also presents the opportunity for anyone to increase the size of LP_GLOBAL_STATE and REWARD_SCHEDULES to the point where they will return out-of-gas errors. For example, an attacker can create many CW20 tokens and send them as reward assets, causing iterations to fail due to the execution limit. Iterations that will fail can be found in the following locations:  contracts/multi_staking/src/contract.rs:295  contracts/multi_staking/src/contract.rs:357  contracts/multi_staking/src/contract.rs:403  contracts/multi_staking/src/contract.rs:570  contracts/multi_staking/src/contract.rs:615 We classify this issue as critical because both attacks would prevent users from withdrawing their liquidity pool tokens and rewards.", "labels": ["Oak Security", "Severity: High"]}, {"title": "3. Numerical non-convergence might lead to erroneous computations", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dexter/2023-03-15 Audit Report - Dexter v1.0.pdf", "body": "the non-convergence in of The contracts/stable_5pool/src/math.rs:45-70 is not handled. A loop carries out up to 32 iterations over an approximating function, and after the iterations, the computations are carried out with the last approximating value. Consequently, the value might not be at the desired precision, which might cause erroneous computations. Furthermore, this computation is a sub-computation of another solver (calc_y in line 83), which might also lead to a situation where two approximated values of a proposed d lead to the same value in y and an erroneous convergence of calc_y. solver", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "4. AfterJoinResponse does not return fee value", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dexter/2023-03-15 Audit Report - Dexter v1.0.pdf", "body": "The in contracts/vault/src/contract.rs:749-775 includes logic to handle a fee returned execute_join_pool function in the AfterJoinResponse. Each of the current pools returns None for this value during OnJoinPool, so currently, the logic is unused. This will result in the collected fees not being sent to the protocol fee collector or the developer fee collector.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "5. Funds in the keeper contract cannot be withdrawn", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dexter/2023-03-15 Audit Report - Dexter v1.0.pdf", "body": "In contracts/keeper/src/contract.rs:70-81, there is no functionality for the vault owner to withdraw funds from the keeper contract. Funds will be sent to the keeper contract as part of the protocol fees. This means that the vault owner cannot withdraw collected protocol fees.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "6. Owner address is not validated", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dexter/2023-03-15 Audit Report - Dexter v1.0.pdf", "body": "In contracts/keeper/src/contract.rs:45, msg.owner is not validated before it is saved. If the address is incorrectly set and that goes unnoticed, it could result in a loss of funds once the keeper contract begins to receive funds.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "7. Duplicate scaling factors cause ineective updates", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dexter/2023-03-15 Audit Report - Dexter v1.0.pdf", "body": "In contracts/pools/stable_pool/src/contract.rs:74-88, the provided scaling factors are validated to ensure the asset information exists in the pool. However, no validation is performed to ensure duplicate assets are not provided. This is problematic because the update_scaling_factor function can only update the rst index, as seen in line 287. In contrast, the scaling_factors function returns the last value (see a is the old scaling contracts/pools/stable_pool/src/state.rs:57). As a result, factor the used StablePoolUpdateParams::UpdateScalingFactor message. duplicated updated despite being asset there still will via be if Please see the test_ineffective_scaling_factor_update test case to reproduce the issue. We classify this issue as major since it prevents the scaling factor manager from updating the congurations correctly.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "8. Consider validating burn shares are greater than zero", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dexter/2023-03-15 Audit Report - Dexter v1.0.pdf", "body": "In contracts/stable_5pool/src/contract.rs:603-621, errors that occur inside the imbalanced_withdraw function are silenced, causing the shares to burn to become the a message zero. imbalanced_withdraw functionality to withdraw funds from the pool without burning the required tokens. attacker causes inside errors send that can An Due to the fact that no validation exists to ensure that the burn amount is not zero, attackers cannot exploit this like the previous issue due to the inability to burn 0 liquidity pool tokens in contracts/vault/src/contract.rs:1073. However, a code refactor might change this, such as adding an if statement only to burn shares if its higher than zero. Please see the burn_funds_free_asset test case in the appendix to reproduce this issue.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "9. Users may receive unexpected mint amounts because the lp_to_mint parameter is unused", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dexter/2023-03-15 Audit Report - Dexter v1.0.pdf", "body": "The execute_join_pool function in contracts/vault/src/contract.rs:694 provides the optional parameter of lp_to_mint, which allows the caller to specify the amount of LP tokens they want to get against their provided assets. This value is silently the weighted pool's ignored types. for in query_on_join_pool contracts/weighted_pool/src/contract.rs:381 ignores the _mint_amount parameter entirely and performs no checks to validate that it is met. existing pool example, function For the all This issue is found in all of the following pool types:  stable5 - query_on_join_pool - contracts/stable_5pool/src/contract.rs:392  weighted - query_on_join_pool - contracts/weighted_pool/src/contract.rs:381 The lp_to_mint is currently an unused parameter that should either be removed or enforced. The current implementation can result in the user receiving an amount of LP tokens that were not expected.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "10. Consider verifying the developers address to be valid", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dexter/2023-03-15 Audit Report - Dexter v1.0.pdf", "body": "In contracts/vault/src/contract.rs:81-82, the developers address inside the fee info is not checked to be a valid address. This is problematic because the developers address is used to update the pools conguration in line 329. Other than that, executions that send the fee to the developer would fail due to an invalid address specied. We classify this issue as minor since only the admin can cause it.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "11. Users can send more liquidity pool tokens than specied", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dexter/2023-03-15 Audit Report - Dexter v1.0.pdf", "body": "In contracts/vault/src:228, the second condition veries that the specied burn amount must be higher than the actual amount transferred. This is problematic because if a user sent extra liquidity pool tokens, the tokens would be stuck in the contract. For example, Alice can send 500 tokens but may only specify the burn amount as 300. As a result, 200 tokens are not refunded back to Alice due to the refund amount being determined by the burn_amount. We classify this as a minor issue since it can only be caused by user misconguration.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "12. Users can miscongure weighted pool conguration", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dexter/2023-03-15 Audit Report - Dexter v1.0.pdf", "body": "During the contract initialization process for the weighted pool, no validation ensures the provided WeightedParams in contracts/weighted_pool/src/contract.rs:66 is valid with the asset information. The current implementation allows users to congure duplicate weighted assets, which causes incorrect nal weights. Other than that, the contract accepts a zero weight amount, causing a division by zero panic in contracts/weighted_pool/src/utils.rs:196.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "13. Excess native funds sent are lost", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dexter/2023-03-15 Audit Report - Dexter v1.0.pdf", "body": "The execute_join_pool function in contracts/vault/src/contract.rs:820 calls the find_sent_native_token_balance function to get the amount of a specied denom if the pool being joined includes native funds. This check ensures that info.funds contains the specied denom, but the execute_join_pool function should also ensure that info.funds does not contain any unexpected denoms. Otherwise those excess funds would be lost.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "14. Owner address validation is not performed", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dexter/2023-03-15 Audit Report - Dexter v1.0.pdf", "body": "The instantiate function in contracts/multi_staking/src/contract.rs:43 does not validate msg.owner. An address validation should occur before an address value is stored in the contracts cong. If this eld were improperly set to an invalid address, then the contract would lose all of its owner functionality. Similarly, in is contracts/multi_staking/src/contract.rs:255 before the value is passed to the bond function. beneficiary validated not", "labels": ["Oak Security", "Severity: Low"]}, {"title": "15. Multihop swap lacking multiswap_request validation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dexter/2023-03-15 Audit Report - Dexter v1.0.pdf", "body": "execute_multihop_swap in The contracts/router/src/contract.rs:117 does not perform any validation or pre-processing on the user-supplied vector of HopSwapRequest. The user-supplied least minimal validation before the swapping callback multiswap routes should have at sequence is initiated. function", "labels": ["Oak Security", "Severity: Low"]}, {"title": "16. Ended reward schedules consume unnecessary computation power", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dexter/2023-03-15 Audit Report - Dexter v1.0.pdf", "body": "In contracts/multi_staking/src/contract.rs:295-301, the compute_reward function takes all reward schedules and skips the ones that have ended. This causes unnecessary gas consumption as ended reward schedules do not need to be processed. Suppose a scenario where the number of nished reward schedules grows too large such that an out-of-gas error would occur in the compute_reward function, preventing users from withdrawing liquidity pool tokens and rewards.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "17. UnclaimedRewards query returns incorrect value", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dexter/2023-03-15 Audit Report - Dexter v1.0.pdf", "body": "the last_distributed In contracts/multi_staking/src/contract.rs:628, value defaults to the supplied block_time value if the ASSET_LP_REWARD_STATE does not exist. This is incorrect because the update_staking_rewards function defaults the value to zero, as seen in contracts/multi_staking/src/contract.rs:467. Consequently, the UnclaimedRewards query will return a lower unclaimed rewards value than it should. Please see the test_incorrect_query_unclaimed_rewards test case in the appendix to reproduce this issue. We classify this issue as minor since it only aects the UnclaimedRewards query return value.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "18. Removing and adding LP tokens might run out of gas if too many tokens are registered", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dexter/2023-03-15 Audit Report - Dexter v1.0.pdf", "body": "In contracts/multi_staking/src/contract.rs:144-180, the allow_lp_token and remove_lp_token_from_allowed_list functions might run out of gas if too many LP tokens are registered. As a consequence, removing and adding LP tokens will become impossible. Only a migration of the contract allows recovery from this issue. We classify this issue as minor since it can only be caused by an admin.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "19. Unlocking liquidity pool tokens too frequently will prevent users from claiming them", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Dexter/2023-03-15 Audit Report - Dexter v1.0.pdf", "body": "In contracts/multi_staking/src/contract.rs:499-515, the unlock function iterates over all users unlocking positions and lters them. If a user requests to unbond their liquidity pool tokens too many times, the USER_LP_TOKEN_LOCKS for the specic user will grow too large to be processed, causing an out-of-gas error eventually. We classify this issue as minor because it is unlikely that users will unbond their liquidity pool tokens to an amount high enough to cause computation limit issues.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "1. A website viewed with the wallets' web browser can place arbitrary information in browser and wallet activity history", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cypher Wallet/2023-05-19 Audit Report - Cypher Wallet v1.2.pdf", "body": "The in-app browser allows a web page to send messages back to the application. A web-page can set any host, title url, and origin values which are later displayed in the browser and wallet activities histories. Moreover, a web page can set any arbitrary URL for its own entry in the browser history. This functionality opens possibilities for phishing attacks  a user might unknowingly navigate to a malicious URL by clicking on entries in the browser history. Additionally, the arbitrary URL set by a web page will be displayed in the wallet activities history if the web page has initiated web3 wallet transactions.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "2. The browser shows secure green lock icon next to URL even when the actual protocol is clear-text HTTP", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cypher Wallet/2023-05-19 Audit Report - Cypher Wallet v1.2.pdf", "body": "The in-app Browser always shows a green lock icon next to the URL being visited even if the is insecure HTTP. This can mislead users into thinking that a connection is used protocol encrypted, although it this issue for example through man-in-the-middle attacks or redirects to unencrypted versions of the site without the user noticing. is not. Attackers can exploit", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "3. It is possible to delete the wallet without providing a correct PIN", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cypher Wallet/2023-05-19 Audit Report - Cypher Wallet v1.2.pdf", "body": "If an incorrect PIN is entered ten times, the application provides an option to delete the old wallet and create a new one. Since the wallet application does not require that access to a mobile device is secured by a PIN or biometric measures, a malicious actor can simply delete the wallet on a device.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "4. Sensitive data may be logged", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cypher Wallet/2023-05-19 Audit Report - Cypher Wallet v1.2.pdf", "body": "The app uses Sentry for error tracking without any ltering of sensitive information. Because of that, sensitive data may be sent to external servers. If an attacker manages to get access to such a server (e.g., by compromising team members or vulnerabilities in the server), they may be able to access this data. Such attacks have happened in the past. In Cypher Wallets codebase, this could for instance happen to API tokens (in src/core/card.ts:15) or keystore information (in src/core/Keychain.tsx:107) which is included in a captured exception.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "5. Insucient ENS name validation enables social engineering attacks", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cypher Wallet/2023-05-19 Audit Report - Cypher Wallet v1.2.pdf", "body": "Generally, it is a good idea to only allow ASCII-characters for ENS names because the same human-readable name may have multiple valid UTF-8 encodings. Attackers can abuse this to trick users into sending funds to unintended ENS names that they have registered. The following regex pattern is used in src/core/util.tsx to validate ENS names: /[-a-zA-Z0-9@:%._\\+~#=]{1,256 }\\.[a-zA-Z0-9()]{1,6}\\b([-a-zA-Z0-9()@:%_\\+.~#?&//=]*)?/ig This pattern matches on partial strings in the middle and does not require that the whole checked string adheres to it. isValidEns will therefore return true if the string contains some non-ASCII characters in the beginning, as long as there is at least one ASCII character before the dot.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "6. Sign-in requires signing an arbitrary message", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cypher Wallet/2023-05-19 Audit Report - Cypher Wallet v1.2.pdf", "body": "When using the Cypher Wallet the rst time, a sign-in to the CypherD API server is performed in the background. This sign-in requires signing a message fetched from the CypherD API server in src/core/globalContext.tsx:153. This is a security measure to ensure that the current user controls the wallet's public address. However, signing arbitrary messages can be harmful. For example, they can be used to steal funds from the user or perform malicious actions in the event of a compromised server. This issue is also observed in the following locations: - - src/containers/DebitCard/aptoCard.tsx:59 src/containers/InfoScreen/legalAgreement.tsx:44", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "7. Outdated use of Facebook Conceal as the default secure storage option on Android", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cypher Wallet/2023-05-19 Audit Report - Cypher Wallet v1.2.pdf", "body": "The _setInternetCredentialsOptions function in src/core/Keychain.tsx:92 uses Facebook Conceal as the storage for the cipher. However, for Android API level 23+, the Android Keystore is the recommended storage option. Moreover, Shared Preferences together with the plain-text decryption key. in the case of Android before API level 23, an encrypted ciphertext is stored in", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "8. Injected JavaScript is not veried", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cypher Wallet/2023-05-19 Audit Report - Cypher Wallet v1.2.pdf", "body": "The WebView that is used in src/components/WebScreen.tsx injects the content of a JavaScript le that is loaded from the server public.cypherd.io before loading the content. However, this code is not veried in any way. An attacker that manages to control the server that is responsible for public.cypherd.io can therefore distribute malicious JavaScript that is executed before every page load.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "9. Known vulnerabilities in dependencies", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cypher Wallet/2023-05-19 Audit Report - Cypher Wallet v1.2.pdf", "body": "There are NPM packages with known vulnerabilities (which are shown when running npm audit). The output of npm audit indicates that 56 vulnerabilities were found in the audited packages. Of these vulnerabilities, 1 is rated as low, 14 are rated as moderate, 33 are rated as high, and 8 are rated as critical.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "10. The browser leaks wallet addresses to visited websites", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cypher Wallet/2023-05-19 Audit Report - Cypher Wallet v1.2.pdf", "body": "The in-app browser allows a web page to send messages back to the application. A web page can request user wallet addresses and this information will be provided to the web page automatically without user consent.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "11. Users cannot set a PIN if biometrics are enabled", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cypher Wallet/2023-05-19 Audit Report - Cypher Wallet v1.2.pdf", "body": "The app only requires a PIN if logging in with biometric data is not activated on the device. This may be insucient for some use cases. For instance, a user that regularly shares their device may still want to set a PIN, even if they authenticate with their ngerprint or face scan.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "12. The Ethereum address of a user is sent to external platforms", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cypher Wallet/2023-05-19 Audit Report - Cypher Wallet v1.2.pdf", "body": "The Ethereum address of a user is passed as the user ID to Intercom through the Intercom.registerIdentifiedUser function. While this may make the handling of support requests easier, a user might not want to be associated with their Ethereum address, as this can result in a loss of anonymity.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "13. Hard-coded Cosmos gas prices", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cypher Wallet/2023-05-19 Audit Report - Cypher Wallet v1.2.pdf", "body": "the gas price for every supported chain is In src/constants/cosmosConfig.ts, hard-coded. This can lead to too high or too low gas prices. In the rst case, a user unnecessarily pays too much for a transaction. With too low gas prices, the transaction can be delayed and may fail.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "14. No pagination is used when querying APIs with a limit", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cypher Wallet/2023-05-19 Audit Report - Cypher Wallet v1.2.pdf", "body": "a of limit with The conguration in the le src/core/globalContext.tsx contains multiple API endpoints is initialGlobalState.rpcEndpoints.COSMOS.otherUrls.balance. Besides the balances key, this endpoint contains a key pagination that contains the next URL to query if the result is larger than the limit. However, this key is ignored and only the key balances is used in src/core/cosmosStaking.tsx. In rare edge cases where the queried address has a non-zero balance for over 1,000 coins, it can happen that the desired balance is not found because only the rst 1,000 results are considered. endpoint 1,000. such One", "labels": ["Oak Security", "Severity: Low"]}, {"title": "15. The seed phrase is shared insecurely between view navigations", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cypher Wallet/2023-05-19 Audit Report - Cypher Wallet v1.2.pdf", "body": "src/containers/Options/SecurityPrivacy.tsx:58 and In src/containers/OnBoarding/confirmSeedPhrase.tsx:16, the loaded recovery seed phrase is passed as a navigation parameter to the next screen view via the navigate function. This imposes a potential security issue, as the seed phrase is passed unencrypted to the next screen view and could be logged by an integrated tracking plugin (e.g., Sentry or Intercom).", "labels": ["Oak Security", "Severity: Low"]}, {"title": "16. PIN code length is limited to 4 digits", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cypher Wallet/2023-05-19 Audit Report - Cypher Wallet v1.2.pdf", "body": "A PIN code is used to protect the wallet from unauthorized access on Android devices and as a fallback on iOS devices in case biometric authentication is unavailable. Setting a PIN code is implemented in src/containers/PinAuthetication/setPin.tsx:34. However, the PIN code length is limited to four digits, which is considered weak.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "17. Small entered token fractions are incorrectly parsed", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cypher Wallet/2023-05-19 Audit Report - Cypher Wallet v1.2.pdf", "body": "Entering token fractions with a very small USD value leads to displaying an inated USD value due to the internal representation in scientic notation. For example, entering 0.00000001 MATIC tokens with a USD value of 1.2313863e-7 USD in the send token view incorrectly shows a USD value of 1.23 USD.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "18. Number formatting is not using the users locale", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cypher Wallet/2023-05-19 Audit Report - Cypher Wallet v1.2.pdf", "body": "The Cypher Wallet does not use the decimal separator of the users current locale when entering numbers. This currently prevents entering numbers with a decimal separator other than a dot (e.g., German users may enter 1,5 instead of 1.5) and may lead to confusion. Besides misleading display issues, mobile device keyboards may have a xed decimal separator, and users might not be able to type the required decimal separator.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "19. Static retry delay of 100ms for failed API HTTP requests", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Cypher Wallet/2023-05-19 Audit Report - Cypher Wallet v1.2.pdf", "body": "In src/core/Http.tsx, the axios library is congured with the axios-retry plugin to retry failed HTTP requests with a static delay of 100 milliseconds and a maximum of 5 retries. If the request fails, this could lead to a large number of requests in a short period of time, as well as insucient time for the server to recover.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "2. Protocol mint fees locked in factory contract for perpetuity", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Edge/2022-04-23 Audit Report - Edge Protocol v1.0.pdf", "body": "The Edge pool contract mints eTokens to the factory contract when computing the interest accrued in contracts/edge-pool/src/borrow.rs:532. However, there is no function in the factory contract that allows the factory owner to redeem these eToken funds. The eTokens accrued during interest computations are thus locked in perpetuity.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "1. Permissionless trade execution allows for price manipulation and arbitrage opportunities", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Phase/2023-04-13 Audit Report - Phase v1.0.pdf", "body": "In contracts/pf-dca/src/execute.rs:66-81, the try_perform_dca function is permissionless, introducing a number of risks. While the execution of a single transaction might pose a small risk, i.e. a loss of funds for users due to arbitrage opportunities for another users, a coordinated attack that uses a larger amount of scheduled transactions might have a severe impact by extending (or even creating) such arbitrage opportunities to a degree that they could become market manipulations and enable the attacker to buy/sell funds at large discounts/premia. First, an attacker could use a set of scheduled transactions to manipulate oracle spot prices or TWAPs by triggering them simultaneously in a low liquidity environment. Second, an attacker can always arbitrage the slippage of the scheduled transactions by placing an order in front and behind the target transaction  a so-called sandwich attack. As the attacker can send the PerformDca message themself, this gives them the ability to write scripts that optimize for such an attack, for example reverting in the case of an unforeseen event. Third, an attacker can combine the rst two attacks for an inverted sandwich attack: The attacker could use one set of transactions to manipulate some oracle price to sell their own asset at a higher price and use a second set of transactions to provide enough liquidity to sell at the manipulated price, irrespective of the slippage limit. In addition to arbitrage, the owner might be forced to execute additional DCAs that are ready for execution when planning to cash out by having their CancelDca transaction front-run. However, this scenario will cause a minor inconvenience to the user compared to the above. The potential impact of this issue could be considered critical. We classify it as major though since the likelihood of exploitation is low as it requires a subset of the following market conditions: High slippage tolerances or large amounts of scheduled transactions within a short period of time and/or an oracle to be manipulated.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "2. Lack of validation of conguration parameters upon instantiation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Phase/2023-04-13 Audit Report - Phase v1.0.pdf", "body": "The pf-dca contract does not perform any validation on the conguration parameters set upon potentially causing issues that could render the contract unusable. in contracts/pf-dca/src/contract.rs:53-64, instantiation  destination_wallet address is not validated. An invalid address could cause any swap to fail as the message in line 138 will have an invalid recipient. In addition, the current implementation does not follow the documentation that states the destination wallet should default to the senders address.  source_denom is not validated. A wrong letter case of a denom or a denom that does in contracts/pf-dca/src/execute.rs:104-108 to fail, potentially leaving the amount to be swapped sitting idle in the contract. swap message exist will dened related cause not the  The destinations vector can be empty or the denoms not sanitized. This will lead to either no swaps happening at all or swaps failing.  max_slippage can be any Decimal number, even outside of the 0-100 range leading to potential inconsistencies. In addition, a high slippage is not recommended as it will allow for arbitrage opportunities as the ones described at Permissionless trade execution allows for price manipulation and arbitrage opportunities.  router_contract address is not validated, which would cause all swaps to fail if an invalid address is provided.  swap_interval can be set to zero, eectively allowing users to trigger all the swaps at once. We classify this issue as major given that none of the above parameters can be updated once the contract is deployed, which means that any of these errors require a new deployment.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "3. DCA end not enforced", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Phase/2023-04-13 Audit Report - Phase v1.0.pdf", "body": "The pf-dca contract does not enforce the congurations num_trades limit on the number of trades performed in contracts/pf-dca/src/execute.rs:66-121. This allows users to keep using the PerformDca message for as long as the contract has enough funds to perform additional swaps. Although not implying a security risk per se, the actual implementation diers from the implied behavior and STATE.num_trades_executed, which are not used otherwise. DcaConfig.num_trades existence the by of", "labels": ["Oak Security", "Severity: Low"]}, {"title": "4. DCA execution might run out of gas if too many destinations are congured", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Phase/2023-04-13 Audit Report - Phase v1.0.pdf", "body": "the iterations performed over In contracts/pf-dca/src/execute.rs:83-86, destinations might run out of gas if too many destinations are congured. As a consequence, trade execution might fail permanently. In that case, the only way to recover the assets in the contract is the cancellation of the whole DCA.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "5. Rounding issues on swap message creation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Phase/2023-04-13 Audit Report - Phase v1.0.pdf", "body": "The pf-dca contract allows swapping into multiple destination denoms, distributing the total amount using their assigned weight. The calculation of the nal amount to be traded to each denom is done in contracts/pf-dca/src/execute.rs:92-100. The division by total_weight is an integer division, leaving any remainder to stay idle in the contract until the user decides to cancel the DCA. This corresponds to rounding down/using the oor function. A proof of concept unit test can be found in the Appendix: Rounding issues on swap message creation.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "6. Users assets can get stuck in the DCA contract until cancelation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Phase/2023-04-13 Audit Report - Phase v1.0.pdf", "body": "pf-dca are The contracts/pf-dca/src/contract.rs:45 to satisfy that all trades contract enough checks assets only if sent   in along can be funded with the correct amount should satisfy   =   *   per trade. The documentation states that the total amount     such that it is required that the user submits the correct amount of funds. However, the code allows initializing contract with      *  , creating a possibility for  users to lock up excessive amounts of funds accidentally. The only way for the user to receive those funds back is to cancel the whole strategy, which would then require them to re-instantiate to resume the strategy with the correct amount of assets. In addition, when the swaps for a given asset fail, the remaining not swapped assets are left in the contract with no way for the user to either claim them or retry the swap. This may lead to frozen funds accumulating in the contract, unusable by the user until cancellation of the strategy.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "7. Coarse-grained authorization", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Phase/2023-04-13 Audit Report - Phase v1.0.pdf", "body": "pf-dca in The contracts/pf-dca/src/helpers.rs:7 does not follow best practices for authorization since it combines two separate entities into one layer of privileges by giving access to privileged functionality to both owner and destination_wallet. verify_sender contracts function For example, if the owner tries to pause the contract in order to stop the money ow into the destination_wallet, the destination_wallet can revert this action by unpausing the contract. The only way for the owner to prevent this is to cancel the DCA. In the future, when further functionality is added, this may lead to an overly privileged party with unintended consequences.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "8. Commented code", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Phase/2023-04-13 Audit Report - Phase v1.0.pdf", "body": "The contracts within the scope of this audit include commented code. Although not a security issue, commented code indicates that the codebase may not yet be ready for release and may negatively aect readability and maintainability. The following instances were found:  contracts/pf-dca/src/state.rs:5-29  packages/phase-finance/src/msg.rs:45-50 In addition, language potentially harmful contracts/pf-dca/src/tests.rs:135 packages/phase-finance/src/constant.rs:1. to the clients reputation was found in and", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "9. Ineective resume and pause operations allowed", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Phase/2023-04-13 Audit Report - Phase v1.0.pdf", "body": "pf-dca in The contracts/pf-dca/src/execute.rs:34 and 46 do not check if the contract is actually paused or not. resume_dca pause_dca contracts functions and Although not a security issue, pausing or unpausing a contract that is not already in that state will just spend gas without actually changing the contracts state.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "10. Overow checks not enabled for release prole", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Phase/2023-04-13 Audit Report - Phase v1.0.pdf", "body": "The following contract and package do not enable overflow-checks for the release prole:  contracts/pf-dca/Cargo.toml  packages/phase-finance/Cargo.toml While enabled implicitly through the workspace manifest, a future refactoring might break this assumption.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "11. Unnecessary panics negatively aect usability", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Phase/2023-04-13 Audit Report - Phase v1.0.pdf", "body": "In contracts/pf-dca/src/helpers.rs, the conversion from string to Uint128 is assuming valid data due to the ltering of anything dierent than numbers. There are two cases that are unhandled though:  Empty strings (when token_string is not starting with number)  Numbers that are too big to parse Those cases cause the function to panic, negatively aecting the user experience compared to error messages.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. Locked funds will be inaccessible if lockdrop incentives have not been set by the end of the withdrawal window", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2021-12-23 Audit Report - Astroport Periphery v1.0.pdf", "body": "is and DelegateAstroToAuction that can be executed after During ClaimRewardsAndOptionallyUnlock message handlers the withdrawal window, a users in total_astro_rewards contracts/lockdrop/src/contract.rs:827 and 910. That calculation is done in the update_user_lockup_positions_and_calc_rewards function, which contains an assertion that config.lockdrop_incentives is set and will panic otherwise in 1735. Lockdrop incentives can only be set by sending the IncreaseAstroIncentives message, which will fail after the end of the withdrawal window though. By the time this panic occurs, there is no way to recover from it, which would render any locked funds inaccessible in the lockdrop contract. calculated The same issue exists in the query_lockup_info function in line 1592. in been minted contracts/auction/src/contract.rs:618. Likewise, the auction contract contains the same mechanism  during the ClaimRewards message handler, a users auction_incentive_amount is calculated after LP shares The have update_user_incentives_and_lp_share function that performs the calculation contains an assertion that the astro_incentive_amount is set and will return an error otherwise the by fail after the LP shares have been IncreaseAstroIncentives message, which will minted. By the time this panic occurs, there is no way to recover from it, which implies that any contributed Astro and UST tokens are locked inaccessible in the contract. incentives sending These 717. only can set be in We only classify this issue as major since it can only be caused by oversight of the contract owner.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "2. Unlocking funds may fail if a user has too many lockup positions", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2021-12-23 Audit Report - Astroport Periphery v1.0.pdf", "body": "all over lockup iterations update_user_lockup_positions_and_calc_rewards contains The unbounded in contracts/lockdrop/src/contract.rs:1703 and 1707. These iterations could run out of gas if a user submits many lockups for dierent pools and durations. Since the update_user_lockup_positions_and_calc_rewards function will be called when a user sends a DelegateAstroToAuction or ClaimRewardsAndOptionallyUnlock message, the user will be unable to unlock funds. There is currently no way to recover from this issue. function a positions user by The same issue exists in the query_user_info handler in lines 1453 and 1457. We only classify this issue as major since it is unlikely that users submit enough lockup positions to cause out of gas issues.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "3. In the event of a compromised or lost owner key funds will be locked in the contracts forever", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2021-12-23 Audit Report - Astroport Periphery v1.0.pdf", "body": "The only way to retrieve delegated funds from the auction contract after the withdrawal window is closed is through an InitPool message sent from the contract owner. In the event that the owner key is compromised or control over it is lost, delegated funds will be stuck in the auction contract forever. If an attacker gains access to the key, they could extort compensation for releasing the funds. the auction contracts InitPool message also sends the EnableClaims Likewise, in message to the lockdrop contract. That message enables claims by users contracts/lockdrop/src/contract.rs:436-442. As before, a compromised or lost owner key implies that funds will be locked in the lockdrop contract forever. same mechanism in claims The contracts/airdrop/src/contract.rs:197. The issue is less problematic here, since only airdropped funds are in the contract, but still, claims will be impossible if the owner key is compromised or lost contract, enables airdrop the in Even though a compromised owner account could have other severe consequences, this issue has been added due to the high value that will probably be locked in these contracts. We still classify this issue only as minor since proper management of the owner account is assumed. The operational security of Astroport, which includes proper key management, has not been in scope of this audit though.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "4. Liquidity migration might be prevented by target contracts", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2021-12-23 Audit Report - Astroport Periphery v1.0.pdf", "body": "The MigrateLiquidity message of the lockdrop contract triggers a withdrawal of funds from TerraSwap in contracts/lockdrop/src/contract.rs:505. In theory, the target contracts message handler could be upgraded such that the call would always revert. In that case, funds would be stuck in the lockdrop contract, with no way for liquidity migration and no way for users to withdraw their funds.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "5. Issues in generator or downstream reward contracts may lead to users being unable to unlock LP tokens", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2021-12-23 Audit Report - Astroport Periphery v1.0.pdf", "body": "In the lockdrop contracts ClaimRewardsAndOptionallyUnlock message handler in contracts/lockdrop/src/contract.rs:948-954 the generator contract is queried to check pending token/reward balances. Any misconguration/issue with the generator or proxy rewards contracts (which could be caused by a downstream issue in another protocol such as Anchor or Mirror) might make this query fail, which would prevent a user from ever unlocking their LP tokens. We classify this issue as minor since a misconguration is unlikely.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "6. Auction contract may enable claims while withdrawal window of lockdrop contract is still open which could lead to an incorrect state", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2021-12-23 Audit Report - Astroport Periphery v1.0.pdf", "body": "The auction contract can enable claims by sending the EnableClaims message at any time, is still open, a user calling the even before the withdrawal window is closed. to will handle_claim_rewards_and_unlock_for_lockup total_astro_rewards being set at contracts/lockdrop/src/contract.rs:910, which might not use nal values. The owner could still update a pool, which might impact the state.total_incentives_share total_astro_rewards calculation. function change would result lead and the of If it", "labels": ["Oak Security", "Severity: Low"]}, {"title": "7. Staked Astroport LP will become unclaimable if generator contract is updated", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2021-12-23 Audit Report - Astroport Periphery v1.0.pdf", "body": "lockdrop contracts The in contracts/lockdrop/src/contract.rs:270-273, currently enables the generator contract address to be updated. Changing the generator contract address would make any staked Astroport LP at the time unclaimable after the change. This would eectively reduce all users balances. handle_update_config function The same issue exists in the auction contracts handle_update_config function in contracts/auction/src/contract.rs:200-204.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "8. Lack of validation on incentives share value can lead to locked funds becoming inaccessible", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2021-12-23 Audit Report - Astroport Periphery v1.0.pdf", "body": "are rewards When users try to delegate Astro rewards or claim rewards and optionally unlock funds, their Astro the calculated function update_user_lockup_positions_and_calc_rewards internally calls calculate_astro_incentives_for_lockup, which will panic in contracts/lockdrop/src/contract.rs:1666 if total_incentives_share is zero. This cannot be recovered from, since pools can neither be added nor updated after the withdrawal window is closed. Consequently, any funds in the lockdrop contract will become inaccessible. function. That in We only classify this issue as minor since it is caused by a misconguration by the owner.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "9. Updating the Astro token address may lead to an inconsistent state", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2021-12-23 Audit Report - Astroport Periphery v1.0.pdf", "body": "The lockdrops handle_update_config function currently enables the Astro token address in to contracts/lockdrop/src/contract.rs:253-256. Changing the Astro token address after users have called DelegateAstroToAuction may lead to an inconsistent astro_token updated be state between the stored values in the lockdrop contract and the balances in the Astro token contract.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "1. Users existing balance will be inaccessible if UpdateAccounts is called with a new denom", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Atlo/2022-05-09 Audit Report - Atlo v1.0.pdf", "body": "In contracts/account/src/commands.rs:694-703, a users existing balance will be overwritten when the denom in the BatchUpdateRequest is not found in previously stored balances. This is caused by not including the existing balance when adding a new balance in line 721. Consequently, balances with denoms that were sent previously will be stuck in the contract. A test case demonstrating the above scenario can be found in appendix 2.", "labels": ["Oak Security", "Severity: High"]}, {"title": "2. Fee denom deposited by user will be inaccessible if excluded from conguration", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Atlo/2022-05-09 Audit Report - Atlo v1.0.pdf", "body": "In contracts/account/src/commands.rs:332-347, platform funds sent by the user will not be included as deposited funds. This is problematic since there is no validation that platform funds must be included in the allowed funds vector. As a result, users that deposit platform funds would not have their account balance updated, leading to a loss of funds. A test case demonstrating the above scenario can be found in appendix 1.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "3. Migration might fail due to out of gas error", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Atlo/2022-05-09 Audit Report - Atlo v1.0.pdf", "body": "In contracts/account/src/contract.rs:183-187, the for loop tries to process all launchers stored inside the contract. Since launchers are unbounded and cannot be removed, sooner or later the launchers' storage might grow too big to process. Consequently, this might cause the migration transaction to fail due to an out of gas error. We classify this issue as minor since it can only be caused by the owner.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "4. Incorrect deposit history will be logged when users deposit into a prefund", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Atlo/2022-05-09 Audit Report - Atlo v1.0.pdf", "body": "In contracts/account/src/commands.rs:364-373, the deposit history of users that deposited into a prefund will be incorrect. Firstly, the launcher_id value is hardcoded to None in the FundingHistory although the user deposits to a prefund in line 246. Secondly, history will be empty because it is ignored, see lines 332 to 347. if config.fee_denom is not included in config.denoms vector, the deposit Thirdly, the deposit history will record the user's deposit to be lower than intended due to double platform fee deduction if the config.fee_denom is included in config.denoms vector (see lines 295-300 and 332-336). In result, deposit_history value as seen in contracts/account/src/queries.rs:72. this would cause the Investor query message to return an incorrect The above scenarios can be demonstrated with test cases which can be found in appendix 3.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "5. Guaranteed allocation size might be incorrectly overwritten when updating congurations", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Atlo/2022-05-09 Audit Report - Atlo v1.0.pdf", "body": "to the contracts/prefund/src/commands.rs:80-94, In of state.guaranteed_allocation_size is forcefully updated even if there's no valid update If guaranteed_allocation_size is instantiated to contain a valid Some value and one of the admins decides to update congurations that aren't related to it (e.g. the name or description), the value of guaranteed_allocation_size will be overwritten to None in line 93. As a result, return an incorrect value in contracts/prefund/src/queries.rs:46. the State query message will max_participants corresponding value. value the A test case demonstrating the above scenario can be found in appendix 4. that leads possible scenario the Another when guaranteed_allocation_size the updated_config.total_tokens_for_sale case, has updated_config.max_particpants state.guranteed_allocation_size is set to None whilst its value should get updated to the new value of total_tokens_for_sale. is a None value while has a incorrect value. Some value that an to of In", "labels": ["Oak Security", "Severity: Low"]}, {"title": "6. Missing logical validations might cause unexpected outcomes", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Atlo/2022-05-09 Audit Report - Atlo v1.0.pdf", "body": "In the prefund contract, there are several cong values that are currently not validated. For example, the value of msg.end_date should be greater than msg.start_date and the value of msg.max_prefund should be greater than msg.min_prefund. If any of these values are congured incorrectly, it would cause the contract to be unusable. For example, try_allocate in function the contracts/prefund/src/commands.rs:123-129 if msg.start_date is greater than msg.end_date. would fail", "labels": ["Oak Security", "Severity: Low"]}, {"title": "7. Missing address validations might lead to failures of execution handlers", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Atlo/2022-05-09 Audit Report - Atlo v1.0.pdf", "body": "In the prefund contract, there are addresses in cong values that are not validated before storing. Incorrect addresses would lead to issues when executing functions such as the prefund whitelist_contract. This issue exists during both the instantiation of contract in contracts/prefund/src/contract.rs:46-69 and updates to the cong in contracts/prefund/src/commands.rs:43-78.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "8. Missing tax deductions", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Atlo/2022-05-09 Audit Report - Atlo v1.0.pdf", "body": "While Terras tax rate has been set to zero, the tax mechanism is still implemented and the rate might be increased again in the future. It is still best practice to include functionality to deduct taxes. A non-zero tax rate could be reinstated via a governance proposal due to circumstances where the expected income from the tax rewards increases signicantly. In this situation, stablecoin transactions on Terra would expand to a state where a meaningful portion of the staking rewards income is derived from tax rewards rather than the vast majority coming from swap fees. We consider this to only be a minor issue since the contract owner can recover from tax mismatches by simply sending funds back to the contract. Additionally, the likelihood of the Terra team to increase taxes again is low. See this discussion for more details about the tax rate changes on Terra.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "9. try_update_accounts allows arbitrary balance updates", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Atlo/2022-05-09 Audit Report - Atlo v1.0.pdf", "body": "In contracts/account/src/commands.rs:666, the admins are able to increase any existing investors balance without any restriction limit. The team states that the amount of allocation is determined by their own Atlo rating which is calculated via an o-chain script. Since theres no validation in place (e.g. verifying the investor did invest into the prefund or making sure the refund amount lower than the deposited amount), a miscalculation in the script might cause the investor to get more/less tokens than intended. is equal to or", "labels": ["Oak Security", "Severity: Low"]}, {"title": "10. Lowercasing denoms will cause issues with IBC tokens", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Atlo/2022-05-09 Audit Report - Atlo v1.0.pdf", "body": "In contracts/account/src/commands.rs, there are several instances where token denoms are converted to lowercase via to_lowercase. Since token denoms are case sensitive, the contract will be unable to support IBC tokens.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "11. Prefund deposit amount needs to be greater than intended", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Atlo/2022-05-09 Audit Report - Atlo v1.0.pdf", "body": "In contracts/account/src/commands.rs:333-316, users deposited funds are deducted twice even though they have already been deducted in lines 295 to 300. This causes an unnecessary requirement that the prefund deposit amount must be greater by twice the value of platform fees. There might be a possibility that the users deposit is rejected due to insucient funds.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "12. Possibility of duplicate denoms in conguration is inecient", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Atlo/2022-05-09 Audit Report - Atlo v1.0.pdf", "body": "In contracts/account/src/contract.rs:43, denoms are added into the cong during contract instantiation phase. If the admin decides to add custom denoms via passing a valid msg.denoms vector, the corresponding denoms function will not remove duplicate denominations from the vector. Consequently, there is a possibility that the same denom is added twice to the config.denoms vector, which is inecient.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "13. Users can deposit into inactive/ended launchers", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Atlo/2022-05-09 Audit Report - Atlo v1.0.pdf", "body": "In the accounts contract, a value is stored to keep track in which state the launcher is. However, the launchers state does not get automatically updated nor does it get used to validate whether the given launcher id should receive investments or not. Hence, an investor may invest in a launcher that has ended, which would lead to a failure when allocating the funds, because the prefund contract checks for the end_date. To resolve this issue, the admin would need to withdraw funds from the prefund contracts individually.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. Delays in the execution of UpdateExecutor transactions could temporarily inhibit the capability of the protocol to execute requests", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Autonomy/2023-03-06 Audit Report - Autonomy Osmosis v1.1.pdf", "body": "the The guard in contracts/registry-stake/src/contract.rs:338 checks if current epochs executor is set or not, ensuring that update_executor is called before execute_request for the new epoch. Since transaction order from the mempool is not deterministic, the capability of the protocol to execute requests will be temporarily inhibited until an UpdateExecutor transaction is executed.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "2. stakes vector could exceed the CosmWasm VM memory limit when loaded", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Autonomy/2023-03-06 Audit Report - Autonomy Osmosis v1.1.pdf", "body": "In contracts/registry-stake/src/state.rs:68, the stakes attribute is dened in the State struct as a vector of strings. This implies that every time the read_state function is invoked, all the State data, including the stakes vector, is loaded into memory. Since the stakes vector has no maximum length, the CosmWasm VM memory could not have enough space available to load it resulting in an execution panic. A bad actor could intentionally use this issue to cause any interaction with the protocol to be very gas intensive, up to the point where any interaction will run out of gas. With current parameters on Osmosis, the cost of this attack would be in the millions of US dollars. While this might still be economically viable, we classify this issue as major, since it can be resolved with a contract upgrade.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "3. Unstake transactions are likely to fail if more than one of them is processed in the same block", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Autonomy/2023-03-06 Audit Report - Autonomy Osmosis v1.1.pdf", "body": "Unstake in The contracts/registry-stake/src/contract.rs:635-698, takes as input parameter a vector of numeric indexes that represent the users stake slots in the stakes vector. transaction handler, dened In order to process the deletion of the vector data at the provided indexes within an O(1) asymptotic cost, the swap_remove function is used. This method performs a delete substituting data in the selected index slot with the data stored in the latest element of the vector. Consequently, a removal of one element aects also the ordering of the elements stored in the latest positions of the vector. If we have more than one Unstake transaction in the same block, the indexes for any subsequent positions might be wrong, leading to an error, or, if the same sender controls the position, to the deletion of the wrong position. This implies that the likelihood of an Unstake transaction to succeed depends on dierent unpredictable factors like:  The order of transactions in a block  The cardinality of Unstake transactions in a block  The distance of the index to the end of the stakes vector The likelihood of having a transaction error increases drastically on particular events, for example a market crash where users may want to exit funds from the protocol quickly. Additionally, bad actors can grieve users by staking many small amounts, and then front-running others to cause unstake failures. This could be used together with a short of the tokens to attack the whole protocol and prot from a panic in users.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "4. Protocol is prone to censorship", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Autonomy/2023-03-06 Audit Report - Autonomy Osmosis v1.1.pdf", "body": "The guard dened in contracts/registry-stake/src/contract.rs:342-347 ensures that only the currently elected executor can submit the ExecuteRequest message. This implies that the currently elected executor is not participating, the protocol will be stuck for the entire epoch with no executed requests. responsive and actively if Since every AUTO token holder can stake its tokens and participate in the election, there is a possibility that the executor could be an inactive protocol participant. Also, a malicious actor could stake a large amount of tokens in order to intentionally stop the requests execution, causing all or targeted executions to get delayed. This is particularly impactful for users and attractive for attackers if requests contain trading transactions that require to be executed in a timely manner. Usually, in proof of stake (PoS) systems, such actors would bear an economic cost such as infrastructure maintenance, cost of staked capital, and third-party delegation loss. Also, in this case, it is required to deposit the stake in the contract only for one block since there is no unbonding period, reducing the attackers capital cost and making the attack cheaper with respect to other PoS systems. In fact, in contracts/registry-stake/src/contract.rs:635-698, the Unstake message handler allows the currently elected executor to unstake all of its stake slots without losing its role. Consequently the executor can be in charge of its role without having its stake deposited in the protocol. This would allow an attacker to get an AUTO loan, stake and be elected, unstake, repay the loan and act as an inactive executor in order to stop requests execution without having to hold or loan tokens for long. Also, it is worth to note that in contracts/registry-stake/src/contract.rs:645, during the handling of the Unstake transaction, the executor election is done before removing the unstaking users address from the stakes vector. This implies that an unstaking user could be elected as the current epoch executor without having capital at risk stored in protocol. We classify this issue as minor since the client intends to set the epoch length to 100 blocks, which corresponds to 10 minutes on Osmosis and is low enough to reduce the impact of an attack. Still, market manipulation even over a short time window may be exploited.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "5. Partially implemented tax deductions may lead to failures if tax rates are updated", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Autonomy/2023-03-06 Audit Report - Autonomy Osmosis v1.1.pdf", "body": "In packages/autonomy/src/asset.rs:44-46, used to calculate taxes to be paid when transferring native coins, always returns zero. the compute_tax function that is Consequently it is not eective and future changes in the Osmosis (or another) chain could inhibit the execution of requests submitted in the registry.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "6. Contracts are not compliant with CW2 Migration specication", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Autonomy/2023-03-06 Audit Report - Autonomy Osmosis v1.1.pdf", "body": "The following contracts do not adhere to the CW2 Migration specication standard: a) registry-stake b) wrapper-osmosis This may lead to unexpected problems during contract migration and code version handling.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "7. AssetInfo struct is not validated", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Autonomy/2023-03-06 Audit Report - Autonomy Osmosis v1.1.pdf", "body": "In contracts/registry-stake/src/contract.rs:61, representing the AUTO token provided during the instantiation is stored without validation. the AssetInfo struct Since this struct contains an address, it should be checked to ensure that it is a valid one.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "1. First depositor can be front-run for unfair prot causing direct losses", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Eris Protocol/2023-02-15 Audit Report - Eris Protocol v1.0.pdf", "body": "The hub contract does not prevent the rst depositor from being front-run to eectively get fewer shares than planned from which the attacker will prot. In contracts/hub/src/math.rs:36-38, the number of shares that a user receives depends on ustake_supply, uluna_to_bond, and uluna_bonded. However, if a malicious depositor makes a large enough donation to the vault at the right time, increasing uluna_bonded, the next depositor will not receive their expected amount of shares. The below describes a potential exploit scenario that could be followed by an attacker Mallory to take advantage of a victim Alice: 1. Upon identifying that Alice is trying to make the rst deposit of X uluna into the hub contract, Malloryfront-runs their transaction with two calls: a. Making a minimal initial deposit, let's say 1 uluna, to obtain one unit of shares and setting ustake_supply to one. b. Donating a number of tokens to the contract equal to X/2 uluna, increasing the bonded_luna value without increasing ustake_supply", "labels": ["Oak Security", "Severity: High"]}, {"title": "4. Mallory will then be able to return the share to get 1/2 + 3x/4 uluna after having spent just 1 + X/2 uluna, eectively proting X/4 uluna. Note that this issue is only exploitable at the beginning of the contracts lifecycle and does only aect the rst user making the deposit. However, as the potential loss of funds can be substantial we classify it as critical. Recommendation We recommend performing the rst deposit atomically upon contract deployment. Their rst deposit should be large enough to limit the impact of the described exploit. Status: Resolved 2. Underow upon slope calculation may lead to unreliable voting power", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Eris Protocol/2023-02-15 Audit Report - Eris Protocol v1.0.pdf", "body": "4. Mallory will then be able to return the share to get 1/2 + 3x/4 uluna after having spent just 1 + X/2 uluna, eectively proting X/4 uluna. Note that this issue is only exploitable at the beginning of the contracts lifecycle and does only aect the rst user making the deposit. However, as the potential loss of funds can be substantial we classify it as critical. Recommendation We recommend performing the rst deposit atomically upon contract deployment. Their rst deposit should be large enough to limit the impact of the described exploit. Status: Resolved 2. Underow upon slope calculation may lead to unreliable voting power", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "5. Unharvested rewards not accounted for in compute_mint_amount function", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Eris Protocol/2023-02-15 Audit Report - Eris Protocol v1.0.pdf", "body": "compute_mint_amount at the The contracts/hub/src/execute.rs:144, does not take into account unharvested rewards when calculating the mint amount for a new user. As the protocol reinvests rewards, these belong to previous users, and new users are also given a share of these new rewards. contract, function located hub of Protocol users have a natural the harvest function to minimize any unharvested rewards getting distributed to other users. We classify this issue as minor, since the client states it is expected behaviour and that they will explain this in the user interface. incentive to call", "labels": ["Oak Security", "Severity: Low"]}, {"title": "6. Period rounding can lead to undesired results", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Eris Protocol/2023-02-15 Audit Report - Eris Protocol v1.0.pdf", "body": "The function create_lock converts a timestamp into a number of periods to get the current blocks period (variable block_period) and to calculate the number of periods for the lock rounding occurs which can lead to (variable periods). unexpected and potentially undesired results. these operations, In both of The rounding down of block_period means that the start of the lock could be set to the current period. Because of that, the minimum number of periods will not be strictly enforced. For instance, if a user creates a lock just before a period ends, the capital is locked up for one week less than if he creates a lock just after a period starts. On the other hand, the rounding down of periods may confuse a user. If a user species a time that corresponds to 3.99 weeks, the lock will only be created for three periods (three weeks).", "labels": ["Oak Security", "Severity: Low"]}, {"title": "7. Lack of validation of embedded logos", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Eris Protocol/2023-02-15 Audit Report - Eris Protocol v1.0.pdf", "body": "The voting-escrow contract does not validate_marketing_info contracts/amp-governance/voting_escrow/src/marketing_validation.rs :52-69. validate embedded logos during its in function If an embedded logo is submitted on instantiation it will be saved without any further check. This is not the case for the execute_upload_logo function of CW20, which successfully validates all cases through validate_logo.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "8. Lack of validation upon instantiation of the Hub contract", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Eris Protocol/2023-02-15 Audit Report - Eris Protocol v1.0.pdf", "body": "The hub contracts instantiation function in contracts/hub/src/execute.rs:33 lacks some validation steps of epoch_period and unbond_period. In addition, the list of validators stored in line 49 is checked for duplicates but it does not actually validate addresses to be those of active validators. The same situation is found in the add_validator function in lines 666-682. We classify this issue as minor since instantiation parameters are usually reviewed with care by a privileged user or development team before deployment.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "9. Insucient validation in address blacklisting function", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Eris Protocol/2023-02-15 Audit Report - Eris Protocol v1.0.pdf", "body": "The voting-escrow contracts update_blacklist function checks that the two vectors provided as arguments, append_addrs and remove_addrs, do not clash with the current contents in the contracts/amp-governance/voting_escrow/src/contract.rs:707-714. However, it does not check if addresses are duplicated within each vector or if an address is part of both at the same time. blacklist of Duplicated addresses in append_addrs cause minor ineciencies as those will be saved into the storage, unnecessarily growing it with no purpose and opening a window for future inconsistencies. This limited impact in line 744, as processing the rst instance of any address causes the cur_power of duplicated iterations to be zero. is mitigated by the if statement On the other hand, duplicates in remove_addrs have a real impact as there are no checks in place to avoid repeated calls to the checkpoint function in line 778. This leads to additional accounting in voting power in line 347 linked to the blacklisting of the same address,  compromising the integrity of the scheduled slope changes and the stored Point. For addresses that are present in both vectors, the function rst appends addresses and then removes them. If, by mistake, the same address is part of both, that address will not be contained in the nal blacklist without the owner or guardian being aware of this situation. Although the impact of this issue can be considered major, the function is restricted to privileged addresses which are less prone to error in general. Therefore, this issue has been raised as minor.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "10. Coecient calc implementation diers from documentation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Eris Protocol/2023-02-15 Audit Report - Eris Protocol v1.0.pdf", "body": "calc_coefficient The in packages/eris/src/helpers/slope.rs:6-10 is documented with the following line: Coefficient to 1 and [`MAX_LOCK_TIME`] is 9. However, the actual implementation does not adhere to this comment as when the interval is zero weeks, the returned value will be zero instead of one. calculation [`WEEK`] function where equal found is This issue has been raised as informational as every instance that calls the aected function checks the supplied interval to not be zero before or cant be zero given the contracs logic.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "11. Widespread usage of generic errors in the Hub contract", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Eris Protocol/2023-02-15 Audit Report - Eris Protocol v1.0.pdf", "body": "The error handling in the hub contract is based on StdError::generic_err instead of declaring custom errors, as opposed to the voting-escrow contract which mostly relies on custom errors. Although not a security issue, dening individual generic error messages decreases maintainability.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "12. Lack of drop proposal function on owner transfer mechanism", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Eris Protocol/2023-02-15 Audit Report - Eris Protocol v1.0.pdf", "body": "The hub contract implements a two-step transfer mechanism for updating the owner in order to remove a new_owner address address, submitted by mistake, the current owner would have to call transfer_ownership again and overwrite the address. following best practices. However, Although eective in practice, purpose of clearing this value.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "13. Hardcoded denom and EPOCH_START", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Eris Protocol/2023-02-15 Audit Report - Eris Protocol v1.0.pdf", "body": "The hub contract makes use of the CONTRACT_DENOM constant to set the denom in multiple instances, following best practices. However, the following instances have been found to use a hardcoded uluna string instead of the CONTRACT_DENOM constant:  contracts/hub/src/types/staking.rs:44, 67, 93  contracts/hub/src/queries.rs:80 Although not a security issue, it impacts maintainability and may lead to errors in the future, such as a partial change of denoms throughout the codebase. In addition, the code in packages/eris/src/governance_helper.rs:16 denes a variable EPOCH_START with a specic value assigned to it. It is important to make sure that this value is correct and intended for the specic use case before deploying the code to production, as it may need to be adjusted or replaced with a dynamic value that can change over time.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "14. Optimization in compute_undelegations", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Eris Protocol/2023-02-15 Audit Report - Eris Protocol v1.0.pdf", "body": "iterates over merge_with_validators in The hub contract uses a loop that if the variable uluna_to_undelegate contracts/hub/src/math.rs:86. However, is set to zero, the subsequent computations on lines 91 and beyond will have no eect, wasting computational resources.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "15. Outdated documentation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Eris Protocol/2023-02-15 Audit Report - Eris Protocol v1.0.pdf", "body": "README type The ExecuteMsg::SubmitUnbond, which does not exist and was, presumably, replaced by ExecuteMsg::SubmitBatch. mentions message folder hub the le in a", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "16. Unnecessary conversion to lowercase in addresses", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Eris Protocol/2023-02-15 Audit Report - Eris Protocol v1.0.pdf", "body": "The contracts within scope used the addr_validate_to_lower helper function to sanitize addresses, found at packages/eris/src/helper.rs:25-31. Since CosmWasm 1.0.0, the addr_validate utility also validates address capitalization, hence making it redundant to perform this check manually.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "17. Incorrect comments and typographical errors", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Eris Protocol/2023-02-15 Audit Report - Eris Protocol v1.0.pdf", "body": "The following incorrect comments and typographical errors were found in the audited codebase. Although not security related, they decrease documentation quality and readability of the codebase:  contracts/amp-governance/voting_escrow/src/contract.rs:724 accumulator for old slopes instead of accumulator for old amount.  contracts/amp-governance/voting_escrow/src/state.rs:17 list of whitelisted logo urls prexes instead of list of contracts to receive updates on user's lock info, or something similar.  contracts/amp-governance/voting_escrow/src/state.rs:44 the timestamp when the lock position starts instead of the period when the lock position starts  contracts/hub/src/contract.rs:141 must be 1-2 instead of must be 1  contracts/hub/src/execute.rs:305 and 309 validatiors instead of validators", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "18. Commented code", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Eris Protocol/2023-02-15 Audit Report - Eris Protocol v1.0.pdf", "body": "A commented function was found in packages/eris/src/helpers/slope.rs:20-24. Although not a security issue, commented code decreases readability and may cause issues if re-introduced in the future without being properly re-architected.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. Removing merchant does not remove associated deposit addresses", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Osmosis Labs/2023-08-18 Audit Report - CosmWasm WBTC v1.0.pdf", "body": "the In the contracts/wbtc-controller/src/auth/merchant.rs:45-66, remove_merchant function does not remove the merchants associated deposit addresses and from MERCHANT_DEPOSIT_ADDRESS storage. When a merchant is removed, they should no longer have the associated roles assigned. However, the GetCustodianDepositAddress and GetMerchantDepositAddress queries will show that the removed merchant still has a valid deposit address on the Bitcoin blockchain. CUSTODIAN_DEPOSIT_ADDRESS_PER_MERCHANT", "labels": ["Oak Security", "Severity: Low"]}, {"title": "2. Approving mint requests does not ensure the requestor still holds the merchant role", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Osmosis Labs/2023-08-18 Audit Report - CosmWasm WBTC v1.0.pdf", "body": "In contracts/wbtc-controller/src/contract.rs:149-189, when approving a pending mint request, no validation ensures that the requester still holds the merchant role. For example, consider a scenario where the member manager revokes the merchant role post the issuance of a mint request. The mint requester, no longer holding the merchant role, should not be permitted to receive WBTC. However, due to a lack of validation when the custodian approves the mint request, the requester can still receive WBTC even though they no longer hold the merchant role. We classify this issue as minor because the custodian is considered a privileged and trusted role.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "3. Incorrect governor attribute value emitted", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Osmosis Labs/2023-08-18 Audit Report - CosmWasm WBTC v1.0.pdf", "body": "In contracts/wbtc-controller/src/contract.rs:58, the governor attribute value is emitted as info.sender. This is incorrect because the governor's address is set to msg.governor, causing o-chain event listeners and blockchain indexers to record incorrect data.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "4. Merchant deposit addresses are not ensured to be unique", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Osmosis Labs/2023-08-18 Audit Report - CosmWasm WBTC v1.0.pdf", "body": "In contracts/wbtc-controller/src/tokenfactory/deposit_address.rs:67-9 1, the set_custodian_deposit_address function does not ensure that the provided deposit_address is unique across merchants. This could lead to a custodian mistakenly assigning the same deposit_address to multiple merchants. A malicious merchant could exploit this if the custodian unsuspectingly assigns an existing address to the malicious merchant. The malicious merchant could then issue duplicate mint requests with a transaction identier of the duplicate address. Assume the custodian sets the same deposit address for two merchants. The rst merchant sends BTC to the deposit address. The second merchant did not make a deposit, but they took the rst merchant's transaction identier and issued a mint request for themselves. Since the deposit address for the second merchant matches the transaction identiers receiver address, the custodian might approve this deceptive mint request. We classify this issue as minor because it requires a misconguration by the custodian, which is a privileged and trusted role.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "5. Separation of privileged addresses is not enforced", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Osmosis Labs/2023-08-18 Audit Report - CosmWasm WBTC v1.0.pdf", "body": "While extensive eort has been made to dene privileged access roles within the protocol, privilege separation of these roles is not properly enforced. Currently, no validation exists to enforce that these privileges are designated to unique addresses. In the unlikely case of a compromised account, privilege sharing will have severe implications. While this measure cannot prevent account compromise, it can limit the impact and serve as an additional layer of security for the protocol. Another step that can be taken to reduce the impact of a compromised account is to implement timelocks to prevent frequent updates of addresses.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "6. Attributes are not properly emitted during contract instantiation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Osmosis Labs/2023-08-18 Audit Report - CosmWasm WBTC v1.0.pdf", "body": "instantiation process, During the contract the initialize_governor function in contracts/wbtc-controller/src/auth/governor.rs:16 returns attributes, but they in contracts/wbtc-controller/src/contract.rs:44. function calling used are not the by Consequently, the attributes will not be properly emitted during instantiation.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "7. GetMintRequestsCount and GetBurnRequestsCount query fails when there are no mint or burn requests", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Osmosis Labs/2023-08-18 Audit Report - CosmWasm WBTC v1.0.pdf", "body": "In the contracts/wbtc-controller/src/tokenfactory/nonce.rs:30-33, custom get function returns the stored nonce value in the storage using the load function. the Since the load function fails when there is no previously stored value, GetMintRequestsCount and GetBurnRequestsCount queries will fail when no mint or burn requests are issued.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "8. Contracts should implement a two-step ownership transfer", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Osmosis Labs/2023-08-18 Audit Report - CosmWasm WBTC v1.0.pdf", "body": "The contracts within the scope of this audit allow the current owner to execute a one-step ownership transfer. While this is common practice, it presents a risk for the ownership of the contract to become lost if the owner transfers ownership to the incorrect address. A two-step ownership transfer will allow the current owner to propose a new owner, and then the account that is proposed as the new owner may call a function that will allow them to claim ownership and actually execute the cong update.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "9. Typographical error aects codebase readability", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Osmosis Labs/2023-08-18 Audit Report - CosmWasm WBTC v1.0.pdf", "body": "In contracts/wbtc-controller/src/tokenfactory/deposit_address.rs:12, be the DepositAddressManager. DepositAddressMananger wrongly occurs, should which typed While the typography error doesnt aect the code functionality, it increases the chances of introducing mistakes that can be easily avoided.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "10. Storage entries spread across multiple les increase the chances of storage key collision", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Osmosis Labs/2023-08-18 Audit Report - CosmWasm WBTC v1.0.pdf", "body": "The contract contains multiple storage entries that are dened in separate les. While this does not aect increases the likelihood of accidental storage key collisions. One common pattern is consolidating all storage entries into a single le, increasing code readability and reducing the likelihood of storage key collisions. the code quality, it", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. Astral assembly does not impose negative consequences for creation of low-quality or malicious proposals", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-05-31 Audit Report - Astroport vxASTRO v1.0.pdf", "body": "The end_proposal function in contracts/assembly/src/contract.rs:330 returns the proposal creators funds regardless of the outcome of the proposal. This does not provide any disincentive for submission of malicious or spam proposals, which could allow malicious actors to grief the assembly contracts.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "2. Link validation allows for non fully formed domains to be whitelisted", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-05-31 Audit Report - Astroport vxASTRO v1.0.pdf", "body": "validate_links The in packages/astroport-governance/src/assembly.rs:387 performs validation on whitelisted links during instantiation and cong updates. Currently, the validation criteria for links is related to the characters of the string. This is potentially problematic when viewed in conjunction with how proposal links are checked against the whitelist. function is link proposal validation in The packages/astroport-governance/src/assembly.rs:280. the whitelisted links are used as a prex validation for the proposal link. This can be problematic if the whitelist contains entries that are not FDQNs (fully qualied domain names). Specically, if it will allow an attacker to create a the link does not contain a TLD (top level domain), if the whitelist malicious domain that will still pass the whitelist validation. For example, contains https://astroport, attackers could register a domain that shares the same prex such as https://astroport-gov.com or a domain that has a dierent TLD such as https://astroport.xyz to conduct an attack. handled Currently,", "labels": ["Oak Security", "Severity: Low"]}, {"title": "3. No minimum value for voting quorum in cong validation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-05-31 Audit Report - Astroport vxASTRO v1.0.pdf", "body": "the contracts assembly the In instantiate and update_config functions apply a maximum quorum size during cong validation. However, no validation is performed to ensure that the minimum quorum size is not below a sensible threshold. contract/assembly/src/contract.rs, in This could enable the quorum threshold to be set to a level whereby proposals could be passed without a signicant proportion of the total token supply being involved in the proposal.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "4. Unbounded loop could run out of gas", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-05-31 Audit Report - Astroport vxASTRO v1.0.pdf", "body": "function The in contract/escrow_fee_distributor/src/contract.rs:284 uses a loop and break conditions to calculate the claim amounts from the last claimed period to the current period. calc_claim_amount found In the case that claims are not processed for a long period of time this loop may run out of gas and become unexecutable. However, due to the unlikelihood of this occurring and the fact that it would only aect one user the severity is noted as minor.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "5. New owner proposal minimum and maximum expiry times", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-05-31 Audit Report - Astroport vxASTRO v1.0.pdf", "body": "The function propose_new_owner in packages/astroport/src/common.rs:34-67 enables the current owner of a contract to propose a new owner who is subsequently able to claim the contract ownership. The original owner species an amount of time, expires_in, during which the proposal is claimable. However, there are no minimum or maximum requirements to the amount of time that the proposal can be active for. This could lead to a proposal that expires immediately preventing a proposed owner from claiming or alternatively a claim being active for excessives periods of time.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "6. Incorrect attribute emission during pool deactivation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-05-31 Audit Report - Astroport vxASTRO v1.0.pdf", "body": "of execution in The upon contracts/tokenomics/generator/src/contract.rs execution. However, the attribute action of that event is incorrectly dened as setup_pool. This could lead to event listeners or other queries from being unable to identify blocks that contain deactive_pool messages. deactive_pool function event emits the an", "labels": ["Oak Security", "Severity: Low"]}, {"title": "7. Updating the expiration period can lead to unexpected behavior of live proposals", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-05-31 Audit Report - Astroport vxASTRO v1.0.pdf", "body": "the function in In contract/assembly/src/contract.rs:532 the expiration period can be updated. Doing so would also alter the expiration period of live proposals. This could have the consequence of live proposals ending much sooner than anticipated and lead to operational issues. update_config found", "labels": ["Oak Security", "Severity: Low"]}, {"title": "8. Update of factory contract owner may cause inconsistency", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-05-31 Audit Report - Astroport vxASTRO v1.0.pdf", "body": "execute_create_pair The in contracts/factory/src/contract.rs:352 instantiates a new pair contract, with the admin set to config.owner. This may be problematic as config.owner is an updatable value which may lead to a pair contracts admin being dierent from the factory contracts owner. function Note, that the scope of this issue is related to migrations of the pair contract. This means that the previous owner of the factory contract will remain the admin of the new pair contract and can perform contract migrations. This situation is not inherently malicious or exploitable, but it does present a situation where it becomes dicult to manage the migration of multiple pair contracts with potentially many dierent owners. the previous owner are compromised An extreme scenario where the private keys of presents room for human error since every pair would need to have the admin manually updated.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "9. Blacklist design presents centralization concerns", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-05-31 Audit Report - Astroport vxASTRO v1.0.pdf", "body": "a The receive_cw20 function in contracts/voting_escrow/src/contract.rs:447 implements CreateLock, ExtendLockAmount, and DepositFor functionality. While this does not pose a direct security threat, it allows the owner and guardian_addr to control which addresses have voting power. This raises concerns around centralization of the protocol. blacklist_check control access the to to", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "10. Use of magic numbers", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-05-31 Audit Report - Astroport vxASTRO v1.0.pdf", "body": "In the factory contract in packages/astroport/src/factory.rs:61, numbers are used without context for calculations  so-called magic numbers. Usage of magic numbers is problematic since they decrease the maintainability of the codebase.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "11. Duplicate zero amount check is inecient", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-05-31 Audit Report - Astroport vxASTRO v1.0.pdf", "body": "the in In contracts/escrow_fee_distributor/src/contract.rs:182-216, claim amount is validated during the creation of the transfer message to ensure it is not zero. This check is repeated in the function transfer_token_amount in line 204. This is inecient. function claim the", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "12. Contract should return error if boolean parameter is updated to the same value that is currently set", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Astroport/2022-05-31 Audit Report - Astroport vxASTRO v1.0.pdf", "body": "update_config The in contracts/escrow_fee_distributor/src/contract.rs:377 allows the owner to update the contracts conguration parameters. To improve the user experience, the function should return an error if the value of is_claim_disabled is updated to the value that is currently set to inform the caller that the value has not been changed. function", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. Lack of token whitelist validation when swapping and creating a position or executing a strategy may lead to loss of user funds", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Aperture/2022-06-27 Audit Report - Aperture 2 v1.0.pdf", "body": "In ethereum_hardhat/contracts/EthereumManager.sol:412 and 478, the swapTokenAndCreatePosition and swapTokenAndExecuteStrategy functions allow users to swap tokens and create or execute a strategy based on the provided strategy and chain identier. However, there is no validation that makes sure the swapped token toToken is whitelisted for that strategy identier strategyId and chain identier strategyChainId. and the createPosition function in line 391 veries that the assetInfos, In contrast, the strategyId, isTokenWhitelistedForStrategy mapping in line 277 to ensure the assets are whitelisted the and strategy validateAndTransferAssetFromSender function. strategyChainId arguments specied identier using chain valid are the via for The impact of this issue depends on how the contract on the other chain handles the non-whitelisted token. A possibility that might happen is that the recipient contract will reject the sent VAA message because the strategy does not support the asset token, causing a loss of funds for the sender.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "2. Contracts are not compliant with CW2 Migration specication", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Aperture/2022-06-27 Audit Report - Aperture 2 v1.0.pdf", "body": "The smart contracts do not adhere to the CW2 Migration specication standard. This may lead to unexpected problems during contract migration and code version handling.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "3. Inability to update the admin address of the terra_manager prevents incidence response", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Aperture/2022-06-27 Audit Report - Aperture 2 v1.0.pdf", "body": "In contracts/terra_manager/src/contract.rs, the admin address is saved in the storage in the instantiate message. After that, the admin cant change its address. This may lead to severe implications if the private keys controlling the admin account are ever compromised, in which case an update of the admin address would help to prevent exploits.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "4. Missing allowance check when executing a strategy with CW20 token causes meaningless error message", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Aperture/2022-06-27 Audit Report - Aperture 2 v1.0.pdf", "body": "In packages/aperture_common/src/token_utils.rs:47, when creating the message to move assets from the sender to the current contract, the execution uses a cw20::Cw20ExecuteMsg::TransferFrom. This type of message requires that the sender provided an allowance for the spender contract. If no allowance is granted, message execution will fail without a meaningful error message.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "5. Missing tax deductions", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Aperture/2022-06-27 Audit Report - Aperture 2 v1.0.pdf", "body": "While Terras tax rate has been set to zero, the tax mechanism is still implemented and the rate might be increased again in the future. It is still best practice to include functionality to deduct taxes. A non-zero tax rate could be reinstated via a governance proposal due to circumstances where the expected income from the tax rewards increases signicantly. In this situation, stablecoin transactions on Terra would expand to a state where a meaningful portion of the staking rewards income is derived from tax rewards rather than the vast majority coming from swap fees. We consider this to only be a minor issue since the contract owner can recover from tax mismatches by simply sending funds back to the contract. Additionally, the likelihood of the Terra team to increase taxes again is low. See this discussion for more details about the tax rate changes on Terra.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "6. Cross-chain fee BPS value may be set to be larger than MAX_CROSS_CHAIN_FEE_BPS", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Aperture/2022-06-27 Audit Report - Aperture 2 v1.0.pdf", "body": "the ethereum_hardhat/contracts/EthereumManager.sol:119, In the not _crossChainFeeBPS MAX_CROSS_CHAIN_FEE_BPS value as seen in line 131. As a result, an admin setting a _crossChainFeeBPS higher than MAX_CROSS_CHAIN_FEE_BPS will cause the calculated cross-chain fee in line 328 to be larger than intended. validated below value be to is", "labels": ["Oak Security", "Severity: Low"]}, {"title": "7. Usage of deprecated safeApprove function opens up front-running possibilities", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Aperture/2022-06-27 Audit Report - Aperture 2 v1.0.pdf", "body": "In ethereum_hardhat/contracts/EthereumManager.sol:187 and 338, the safeApprove function is used to give approvals for other contracts to use the current contracts token balance. However, the safeApprove functionality is deprecated as it opens up possibilities for sandwich attacks similar to the classic ERC20 approve() function.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "8. Custom implementation of admin role increases code complexity", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Aperture/2022-06-27 Audit Report - Aperture 2 v1.0.pdf", "body": "In contracts/terra_manager/src/contract.rs a custom implementation of an admin role is used. Using a battle-tested reference implementation reduces the complexity of the codebase.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "9. Removing a strategy from terra_manager may lead to unlinked data", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Aperture/2022-06-27 Audit Report - Aperture 2 v1.0.pdf", "body": "contracts/terra_manager/src/contract.rs:63, executing the selected strategy metadata is removed from when In ExecuteMsg::RemoveStrategy, STRATEGY_ID_TO_METADATA_MAP. As positions in POSITION_TO_STRATEGY_LOCATION_MAP are potentially pointing to a deleted strategy, this may lead to partial/unlinked data in the storage.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "10. Overow checks not enabled for release prole", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Aperture/2022-06-27 Audit Report - Aperture 2 v1.0.pdf", "body": "contracts/terra_manager/Cargo.toml The overflow-checks for the release prole. package does not enable While enabled implicitly through the workspace manifest, a future refactoring might break this assumption.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "11. Re-entrancy guard TODO comment in Solidity codebase", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Aperture/2022-06-27 Audit Report - Aperture 2 v1.0.pdf", "body": "ethereum_hardhat/contracts/EthereumManager.sol:290, an In outstanding TODO comment indicating whether or not to implement a reentrancy guard in recordNewPositionInfo functionality. If the reentrancy guard is not applied, an attacker can keep reentering recordNewPositionInfo functionality, allowing the attacker to create fake positions under them. That said, there arent direct security risks since the rest of the code execution validates the attacker sent assets as specied in the assetInfos and fromToken argument. theres", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. Lottery is (almost) never considered started, allowing user interaction during a running lottery which will lead to inconsistent contract states", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Glow/2021-11-12 Audit Report - Glow - v1.0.pdf", "body": "In several places in the lotto contract, the condition !current_lottery.rand_round == 0 is used to determine whether the current lottery has been started. That condition will never return true though, since !current_lottery.rand_round is evaluated rst, leading to a binary not operation on the unsigned integer, which is in almost all cases not equal to 0. The condition is found in contracts/lotto/src/contract.rs:228, 366, 567, 658, and 807. This issue implies that deposits, gifts, withdrawals, sponsor withdrawals and claims are still possible while a lottery is running, leading to an inconsistent contract state.", "labels": ["Oak Security", "Severity: High"]}, {"title": "2. Combinations beginning with 99 will not receive their prices", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Glow/2021-11-12 Audit Report - Glow - v1.0.pdf", "body": "In the execute_prize function of the lotto contract, winners are determined with a storage iteration in contracts/lotto/src/prize_strategy.rs:181. The iteration starts at the rst two digits of the winning sequence of the lottery and ends at the next integer, excluding that number. For the case of the starting digits 99 though, the next integer would be 100, which is reduced to 99 in line 175. The iteration uses an exclusive upper bound in line 185, which means that the iterator would go from 99 to 99, and hence nish directly without any iteration. That implies that any combination starting with 99 will not be determined as a winner, which is incorrect. Conversely, no winners will be stored if the winning sequence starts with 99.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "3. Lotto contracts incremental glow emission rate may be bypassed", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Glow/2021-11-12 Audit Report - Glow - v1.0.pdf", "body": "lotto contracts The contracts/lotto/src/contract.rs:885 glow_emission_rate. Updates are increments/decrements GlowEmissionRate query. of the determined that execute_epoch_ops used is function to update glow_emission_rate are done through the distributor in the in contracts The execute_epoch_ops function has no access control and no rate limit though, which means that any user can call it repeatedly to bypass incremental adjustments.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "4. Claiming deposits from the lotto contract can run out of gas if a user has many unbonding info entries", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Glow/2021-11-12 Audit Report - Glow - v1.0.pdf", "body": "During the lotto contracts claim_deposits function, an unbounded iteration happens over a depositors unbonding_info vector in contracts/lotto/src/helpers.rs:44. If In the current that vector contains too many entries, implementation, that issue cannot be recovered from, which leads to a user being unable to retrieve their funds back. run out of gas. the call will While this issue can lead to inaccessible user funds, we do not classify it as critical since it is very unlikely for a user to have a large number of unbonding_info entries. It is still possible, for example, if another contract builds on top of Glow and withdraws in quick successions.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "5. Exchange rate queries in lotto contract may receive outdated values, leading to share uctuations and unused UST stuck in the contract", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Glow/2021-11-12 Audit Report - Glow - v1.0.pdf", "body": "or In multiple places in the codebase, Anchors aUST/UST exchange rate is queried through an EpochState query and then used calculate the aUST/UST value of deposited, gifted, sponsored (in contracts/lotto/src/contract.rs:260, 399, 507, 580, 674, and 74). The query does not include the current block number though. Without a block number, Anchor returns the exchange rate based on the last interest computation, not the latest one. That implies that the actual exchange rate may be lower than expected, with the following consequences: UST/aUST withdrawn execution during lottery and  During deposit, gift, and sponsor, the stored share will be higher than the actual aUST received. That will cause the shares to vary slightly between depositors.  During withdrawal, sponsor withdrawal, and lottery execution, too much aUST is burned, leading to unused UST stuck in the contract. Additionally, in the withdraw, sponsor_withdraw and execute_lottery functions the UST amount sent back from Anchor will have taxes deducted, while the amount used in the lotto contracts calculations is not considering taxes. That causes too many funds to be distributed, which implies that the last users will not be able to claim their deposits back due to the condition in contracts/lotto/src/contract.rs:863.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "6. Winning sequence calculation may panic", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Glow/2021-11-12 Audit Report - Glow - v1.0.pdf", "body": "The winning sequence of a lottery is determined in the sequence_from_hash function of the lotto contract function, a hexadecimal string is ltered by decimal characters, and then the resulting string is sliced into the winning sequence. That slicing is done by index access of the string in line 16, which will in contracts/lotto/src/oracle.rs:14. Within that panic if the ltered string is shorter than 6 characters. Since a hexadecimal string can contain no single decimal character (an example is 0xaaaa..aa), such a panic will eventually occur. We consider this issue not to be critical since it is very unlikely and recoverable by triggering the execute_prize function again, which should result in a dierent hash and resolve the issue.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "7. Updates of the lotto contracts split factor cong value will leave user funds inaccessible and lead to errors during award calculation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Glow/2021-11-12 Audit Report - Glow - v1.0.pdf", "body": "the function in of In update_config contracts/lotto/src/contract.rs:1010, the split_factor can be updated. That split_factor is used during deposits/gifts and withdrawals to update the pools lottery_deposits, lottery_shares, and deposit_shares values. If it is changed while the lotto contract holds any user deposits, any subsequent withdrawal will apply a dierent split_factor and hence lead to an inconsistent state. contract lotto the That implies that the subtractions in contracts/lotto/src/contract.rs:737-738 will panic for the last users trying to withdraw their tokens, leaving them unable to access their funds. Additionally, the execute_lottery function in contracts/lotto/src/prize_strategy.rs:69-102 would lead to unexpected errors. the award calculation of We classify this issue as minor since it can only be caused by the contract owner.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "8. Winner prize calculation will leave inaccessible division remainder in lotto contract", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Glow/2021-11-12 Audit Report - Glow - v1.0.pdf", "body": "During the lotto contracts winner prize calculation, integer division is used to determine the prize for the winner in   contracts/lotto/src/helpers.rs:78. That integer division will leave a remainder in the contract, which is inaccessible by anyone.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "9. Lack of prize distribution validation in lotto contract could lead to too high prizes distributed", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Glow/2021-11-12 Audit Report - Glow - v1.0.pdf", "body": "The prize_distribution passed to the lotto contracts instantiate function and used in contracts/lotto/src/contract.rs:71 is not validated. If the sum of its items is greater than one, higher prizes will be assigned to winners than available, and the last winners to claim their prizes will run into an InsufficientClaimableFunds error. We still classify this issue as minor since it can only be caused by the owner during instantiation.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "5. Written signed state hash may use stale data", "html_url": "https://github.com/oak-security/audit-reports/tree/master/pTokens/20210518_pNetworks Enclaves Integration Audit Report.pdf", "body": "In src/main/java/io/ptokens/database/DatabaseWiring.java:188, the writeSignedStateHash method is called after the database transaction is ended in line 183. If any data is written between that end of the transaction and the data retrieved within writeSignedStateHash, the signed state hash references stale data and cannot be trusted.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "1. Liquidity token price source does not work with Osmosis pools", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Abstract/2023-05-09 Audit Report - Abstract Module Bases, Proxy and Manager Contracts v1.0.pdf", "body": "In packages/abstract-os/src/objects/price_source.rs:222-226, the liquidity pool token asset must be a CW20 token, or else an error will occur. This is problematic because Osmosis uses native tokens as liquidity pool tokens (e.g., gamm/pool/1), preventing root users from conguring PriceSource::LiquidityToken asset value calculation for Osmosis-based pools.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "2. API contracts cannot use reply handlers", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Abstract/2023-05-09 Audit Report - Abstract Module Bases, Proxy and Manager Contracts v1.0.pdf", "body": "In packages/abstract-api/src/endpoints.rs, is not registered for Abstract APIs. This means the API contracts reply entry point will not be executed even if dened, causing the transaction to revert. the reply entry point We classify this issue as major because it aects the correct functioning of the system.", "labels": ["Oak Security", "Severity: Medium"]}, {"title": "3. Installed modules can execute arbitrary Cosmos messages", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Abstract/2023-05-09 Audit Report - Abstract Module Bases, Proxy and Manager Contracts v1.0.pdf", "body": "The proxy contract allows whitelisted modules to execute arbitrary messages through the ExecuteMsg::ModuleAction entry-point handled by the execute_module_action function in contracts/core/proxy/src/commands.rs:19-33. As a result, any ill-intended module could perform high-impact actions on the proxy, such as stealing all funds. Similarly, the execute_ibc_action function in lines 37-63 allows arbitrary execution of Cosmos messages over IBC with a similar impact.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "4. Root users updating module addresses might cause inconsistencies", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Abstract/2023-05-09 Audit Report - Abstract Module Bases, Proxy and Manager Contracts v1.0.pdf", "body": "update_module_addresses in function The contracts/core/manager/src/commands.rs:46 allows the caller to update the OS_MODULES map directly. This privileged function is intended for contract-to-contract interaction in which the caller likely performs lookups and validations on the message parameter. For example, the manager contract calls this function internally through the register_module and set_migrate_msgs_and_context functions. In contrast, the root user should not call this function to update the module addresses as it could introduce unintended consequences to their OS, for example, if:  The new address is not whitelisted in the proxy contract using the whitelist_dapp_on_proxy function.  The old address is not removed from the proxy contract using the remove_dapp_from_proxy_msg function.  New modules that require dependencies to work are directly set instead of using the intended install procedure via the install_module function.  Modules are removed without checking their dependents from the DEPENDENTS storage state.  The root user bypasses validation in contracts/core/manager/src/commands.rs:87-89 by directly calling the module factory contract. This can be achieved by updating any dummy name to the module factory contract address via the update_module_addresses function and the install_module functions using the ExecOnModule message to forward the message to the module factory contract to register the module.  Duplicate addresses are provided within the to_add vector which would only cause the last one to be stored. While most of these examples may not cause signicant issues, not automatically removing an old module from the proxy contract would allow it to execute commands via execute_module_action even though the OS_MODULES storage state is modied.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "5. Migration to an older version is not prevented and may lead to state inconsistencies", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Abstract/2023-05-09 Audit Report - Abstract Module Bases, Proxy and Manager Contracts v1.0.pdf", "body": "an for multiple contracts in scope does not prevent a contract The migrate entry point migration and version. Currently, older to migrate_module_data functions are only executed when the contract is being migrated to a newer version. In the case that a migration is performed to an older version, no error would be raised, causing the new version of the contract to not be set, and the module data would be silently not migrated to the next version. set_contract_version the  contracts/core/manager/src/contract.rs:34  contracts/core/proxy/src/contract.rs:65  packages/abstract-app/src/endpoints/migrate.rs:41 In addition, the migrate function does not check if the contract name is indeed the same. In case of a mistake when selecting the code ID, the contract instance could be migrated to a dierent contract. We classify this issue as minor since only the root user can cause it.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "6. Governance type lacking validation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Abstract/2023-05-09 Audit Report - Abstract Module Bases, Proxy and Manager Contracts v1.0.pdf", "body": "When the os-factory contract instantiates the manager contract, the governance type is converted to a string. Then it is passed to the os_info as a string. This conversion is made, but the governance type should only support Monarchy and External, which are the two variants in by packages/abstract-os/src/objects/gov_type.rs:9. GovernanceDetails supported enum the set_root_and_gov_type in The contracts/core/manager/src/commands.rs:239 allows this value to be updated directly by the root user as a string. Hence, its value can diverge from the enum variants. function for Similarly, the instantiate function also takes this piece of data as a string instead of an enum without further validation.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "7. subscriptor_address is not updatable", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Abstract/2023-05-09 Audit Report - Abstract Module Bases, Proxy and Manager Contracts v1.0.pdf", "body": "contracts The manager contract implements the subscriptor_address role to suspend most of in function However, the contracts/core/manager/src/commands.rs:407-427 does not allow for this address to be updated. update_info functionality. the is best practice to allow updates of privileged addresses, which is useful It operational changes or if a privileged account is compromised. in case of", "labels": ["Oak Security", "Severity: Low"]}, {"title": "8. Queries might fail due to unbounded iterations", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Abstract/2023-05-09 Audit Report - Abstract Module Bases, Proxy and Manager Contracts v1.0.pdf", "body": "In packages/abstract-api/src/endpoints/query.rs:48 and 60-64, all traders and dependencies are returned without pagination. If too many traders or dependencies are the BaseQueryMsg::Traders and BaseQueryMsg::Config registered/installed, queries might fail due to an out-of-gas error.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "9. Add action prevailing over remove action when updating oracles assets", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Abstract/2023-05-09 Audit Report - Abstract Module Bases, Proxy and Manager Contracts v1.0.pdf", "body": "oracle package implements in The update_assets packages/abstract-os/src/objects/oracle.rs:47-72, which two vectors: One of the assets to be added to the oracle and one of the assets to be removed. The function rst removes any assets in the to_remove vector and then adds the ones in to_add vector. function accepts the This approach is not recommended since if the same asset is found in both vectors, it will neither be removed nor added, and no error is raised. This implies that in case of a mistake where the owner accidentally sends an asset in both vectors, they will be unaware of that mistake.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "10. Lack of input validations when upgrading modules", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Abstract/2023-05-09 Audit Report - Abstract Module Bases, Proxy and Manager Contracts v1.0.pdf", "body": "The manager contracts ExecuteMsg::Upgrade entry-point is handled by the in upgrade_modules function does not contracts/core/manager/src/commands.rs:255-277. This thoroughly validate the modules argument vector, which can lead to the following problems: function Firstly, in the case that duplicated modules are provided, two identical migration messages will be forwarded, causing the second migration attempt to fail if the migrate only if newer pattern is in place (as recommended by best practices), causing the whole call to fail. Secondly, the function does not check that the provided vector is empty, allowing for an inecient execution that will forward the Callback message without actual changes. if Thirdly, the whole execution would be short-circuited to the upgrade_self function if one of the modules to upgrade is abstract:manager. This is problematic if other modules need to be migrated along because they will be ignored and potentially cause a partial state mutation. For example, the last module to be migrated is the manager contract, the MIGRATE_CONTEXT storage state will store the previous module_id and old dependencies while the update_module_addresses function will overwrite the old module address to the new one in line 300. Since the migration is never executed for other modules, the root user can only call the ExecOnModule message to the invalid new app address (which should be the old one), and the handle_callback and assert_migrate_requirements functions will execute the same module ID more than once, consuming extra gas. Finally, as the provided modules are not checked to have a migrate function, the forwarded migrate message will fail when a non-migratable module is provided, causing the whole call to revert. We classify this issue as minor because it can only be caused by the root user.", "labels": ["Oak Security", "Severity: Low"]}, {"title": "11. Querying conguration does not return the subscriptors address", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Abstract/2023-05-09 Audit Report - Abstract Module Bases, Proxy and Manager Contracts v1.0.pdf", "body": "The manager contract implements an entry point to query its conguration. This call managed the contracts/core/manager/src/queries.rs:36-49. handle_config_query function by is in this However, details: subscriptor_address is not retrieved, even though it plays a central role as it is in charge of the contracts suspension. conguration function retrieve does not the full", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "12. Remove duplicate permission check", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Abstract/2023-05-09 Audit Report - Abstract Module Bases, Proxy and Manager Contracts v1.0.pdf", "body": "the in In contracts/core/manager/src/commands.rs:233, there is a validation to assert that the caller is the root user. This is unnecessary as the execute_update_admin function performs this check already and is called later in the function. assert_admin function", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "13. Contracts should implement a two-step ownership transfer", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Abstract/2023-05-09 Audit Report - Abstract Module Bases, Proxy and Manager Contracts v1.0.pdf", "body": "The contracts within the scope of this audit allow the current owner to execute a one-step ownership transfer. While this is common practice, it presents a risk for the ownership of the contract to become lost if the owner transfers ownership to the incorrect address. A two-step ownership transfer will allow the current owner to propose a new owner, and then the account that is proposed as the new owner may call a function that will allow them to claim ownership and actually execute the cong update.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "14. Incorrect comments", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Abstract/2023-05-09 Audit Report - Abstract Module Bases, Proxy and Manager Contracts v1.0.pdf", "body": "exec_on_module in The contracts/core/manager/src/commands.rs:167 that seems to be copied from another function. comment incorrect contains function an similar A packages/abstract-os/src/objects/module_version.rs:48-50. set_module_data situation occurs also the in function in", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "15. Insucient validation to hinder o-chain attacks", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Abstract/2023-05-09 Audit Report - Abstract Module Bases, Proxy and Manager Contracts v1.0.pdf", "body": "The manager contract includes three pieces of information that could potentially be used as part of injection or phishing schemes: name, description, and link. These could: traditional web exploits such as script 1. Contain whitespace intended to trick users 2. Contain code that may be executed in a users browser 3. Contain links to external resources that may be malicious 4. Contain insecure links", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "16. Overow checks not enabled for release prole", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Abstract/2023-05-09 Audit Report - Abstract Module Bases, Proxy and Manager Contracts v1.0.pdf", "body": "None of the packages and contracts enabled overflow-checks for the release prole. While enabled implicitly through the workspace manifest, future refactoring might break this assumption.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "17. Misleading message names", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Abstract/2023-05-09 Audit Report - Abstract Module Bases, Proxy and Manager Contracts v1.0.pdf", "body": "The SuspendOs and EnableIBC functions in the manager contract are both potentially misleading function names. Based on their names, the functions seem declarative of one specic action, but each of these functions actually supports enabling and disabling functionality. For example, a call to EnableIBC with a status of false actually disables the IBC functionality.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "18. Sudo messages are not exported", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Abstract/2023-05-09 Audit Report - Abstract Module Bases, Proxy and Manager Contracts v1.0.pdf", "body": "and In packages/abstract-api/src/endpoints.rs packages/abstract-app/src/endpoints.rs, sudo messages are not exported as valid entry points. If governance decides to vote and execute arbitrary messages on the API or app contracts, they will fail.", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "19. Governance type implementation diverges from documentation", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Abstract/2023-05-09 Audit Report - Abstract Module Bases, Proxy and Manager Contracts v1.0.pdf", "body": "The governance documentation page lists three governance types: monarchy, multisig, and in token. packages/abstract-os/src/objects/gov_type.rs:9-22 only implements two governance types: monarchy and multisig. GovernanceDetails However, enum the", "labels": ["Oak Security", "Severity: Informational"]}, {"title": "1. Pools with big but dierent token amounts allow attackers to extract free value with minimal cost", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Terra Liquidity Bootstrapping Pool/2021-12-23 Audit Report - Terra Liquidity Bootstrapping Pool v1.0.pdf", "body": "For big amounts of tokens in the oer and ask pools with dierent token values, the calc_out_given_in function in contracts/terraswap_pair/src/math.rs:11 applies rounding, which opens a way for an attacker to extract value from a pool with a very small cost. imagine a pool with 5_000_000_000_000 A tokens, and a pool with As an example, 1_000_000_000 B tokens, with both weights set to 1 for simplicity. If a user now sends 1 B token, we expect the user to get 5_000 A tokens back. When a user sends 1 A token, we expect the user to get 0 B tokens back (actually 0.0002, but since we are dealing with integers here, the remainder will be dropped). The current implementation incorrectly returns 1 B token though. Imagine further that the value of 1 B token is 5_000 USD, and the value of 1 A token is 1 USD, an attacker can now get a risk free return of around 4_999 USD (minus transaction fees) per transaction. If the attacker repeats this attack, they will be able to drain the pool. Even worse, whenever the attacker shifts the balance enough, other arbitrageurs will be able to extract value by bringing the pool back to the 5_000 to 1 ratio, allowing the attacker to repeat the attack from where they started. Here is a failing test case demonstrating the example: #[test] fn compute_swap_rounding() { let offer_pool = Uint128::from(5_000_000_000_000_u128); let offer_weight = FixedFloat::from_num(1); let ask_pool = Uint128::from( ); let ask_weight = FixedFloat::from_num(1); let offer_amount = Uint128::from(1_u128); let return_amount = Uint128::from(0_u128); let spread_amount = Uint128::from(0_u128); let commission_amount = Uint128::from(0_u128); assert_eq!( compute_swap(offer_pool, offer_weight, ask_pool, ask_weight, offer_amount), Ok((return_amount, spread_amount, commission_amount)) ); }", "labels": ["Oak Security", "Severity: High"]}, {"title": "2. Duplicate storage in two contracts could lead to inconsistencies", "html_url": "https://github.com/oak-security/audit-reports/tree/master/Terra Liquidity Bootstrapping Pool/2021-12-23 Audit Report - Terra Liquidity Bootstrapping Pool v1.0.pdf", "body": "i. e. asset_infos, Both factory and pair contracts store the information about pairs, in contract_addr, and in contracts/terraswap_factory/src/state.rs:19 contracts/terraswap_pair/src/state.rs:4. This duplicate storage might lead to inconsistencies between the two contract states. liquidity_token, start_time end_time, and", "labels": ["Oak Security", "Severity: Low"]}]