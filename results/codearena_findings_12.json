[{"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-xtribe-findings/issues/21", "labels": ["bug", "sponsor acknowledged", "QA (Quality Assurance)"], "target": "2022-04-xtribe-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-xtribe-findings/issues/17", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-04-xtribe-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-xtribe-findings/issues/15", "labels": ["bug", "G (Gas Optimization)", "sponsor todo"], "target": "2022-04-xtribe-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-xtribe-findings/issues/14", "labels": ["bug", "G (Gas Optimization)", "sponsor todo"], "target": "2022-04-xtribe-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-xtribe-findings/issues/13", "labels": ["bug", "sponsor acknowledged", "QA (Quality Assurance)"], "target": "2022-04-xtribe-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-xtribe-findings/issues/11", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-04-xtribe-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-xtribe-findings/issues/10", "labels": ["bug", "sponsor acknowledged", "QA (Quality Assurance)"], "target": "2022-04-xtribe-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-xtribe-findings/issues/9", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-04-xtribe-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-xtribe-findings/issues/8", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-04-xtribe-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-xtribe-findings/issues/7", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-04-xtribe-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-xtribe-findings/issues/6", "labels": ["bug", "disagree with severity", "sponsor disputed", "QA (Quality Assurance)", "sponsor todo"], "target": "2022-04-xtribe-findings", "body": "QA Report"}, {"title": "ERC20Gauges: The _incrementGaugeWeight function does not check the gauge parameter enough, so the user may lose rewards.", "html_url": "https://github.com/code-423n4/2022-04-xtribe-findings/issues/5", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor todo"], "target": "2022-04-xtribe-findings", "body": "ERC20Gauges: The _incrementGaugeWeight function does not check the gauge parameter enough, so the user may lose rewards."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-xtribe-findings/issues/2", "labels": ["bug", "sponsor acknowledged", "QA (Quality Assurance)"], "target": "2022-04-xtribe-findings", "body": "QA Report"}, {"title": "Oracle data feed is insufficiently validated.", "html_url": "https://github.com/code-423n4/2022-01-yield-findings/issues/136", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-yield-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/vaults/FungibleAssetVaultForDAO.sol#L105   # Vulnerability details  ## Impact Price can be stale and can lead to wrong `answer` return value.  ## Proof of Concept Oracle data feed is insufficiently validated. There is no check for stale price and round completeness. Price can be stale and can lead to wrong  `answer`  return value.  ``` function _collateralPriceUsd() internal view returns (uint256) {         int256 answer = oracle.latestAnswer();         uint8 decimals = oracle.decimals();          require(answer > 0, \"invalid_oracle_answer\");          ...  ```  https://github.com/code-423n4/2022-04-jpegd/blob/e72861a9ccb707ced9015166fbded5c97c6991b6/contracts/vaults/FungibleAssetVaultForDAO.sol#L105  ## Tools Used Manual review ## Recommended Mitigation Steps Validate data feed  ``` function _collateralPriceUsd() internal view returns (uint256) {  (uint80 roundID, int256 answer, , uint256 timestamp, uint80 answeredInRound) = oracle.latestRoundData();         require(answer > 0, \"invalid_oracle_answer\");     require(answeredInRound >= roundID, \"ChainLink: Stale price\");     require(timestamp > 0, \"ChainLink: Round not complete\");           ...  ```  "}, {"title": "calldata is cheaper than memory", "html_url": "https://github.com/code-423n4/2022-01-yield-findings/issues/122", "labels": ["bug", "G (Gas Optimization)", "sponsor disputed"], "target": "2022-01-yield-findings", "body": "calldata is cheaper than memory"}, {"title": "Rewards distribution can be disrupted by a early user", "html_url": "https://github.com/code-423n4/2022-01-yield-findings/issues/116", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2022-01-yield-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-yield/blob/e946f40239b33812e54fafc700eb2298df1a2579/contracts/ConvexStakingWrapper.sol#L206-L224  ```solidity function _calcRewardIntegral(     uint256 _index,     address[2] memory _accounts,     uint256[2] memory _balances,     uint256 _supply,     bool _isClaim ) internal {     RewardType storage reward = rewards[_index];      uint256 rewardIntegral = reward.reward_integral;     uint256 rewardRemaining = reward.reward_remaining;      //get difference in balance and remaining rewards     //getReward is unguarded so we use reward_remaining to keep track of how much was actually claimed     uint256 bal = IERC20(reward.reward_token).balanceOf(address(this));     if (_supply > 0 && (bal - rewardRemaining) > 0) {         rewardIntegral = uint128(rewardIntegral) + uint128(((bal - rewardRemaining) * 1e20) / _supply);         reward.reward_integral = uint128(rewardIntegral);     } ```  `reward.reward_integral` is `uint128`, if a early user mint (wrap) just `1` Wei of `convexToken`, and make `_supply == 1`, and then tranferring `5e18` of `reward_token` to the contract.  As a result, `reward.reward_integral` can exceed `type(uint128).max` and overflow, causing the rewards distribution to be disrupted.  ### Recommendation  Consider `wrap` a certain amount of initial totalSupply, e.g. `1e8`, and never burn it. And consider using uint256 instead of uint128 for `reward.reward_integral`. Also, consdier lower `1e20` down to `1e12`.  "}, {"title": "Comment missing function parameter", "html_url": "https://github.com/code-423n4/2022-01-yield-findings/issues/113", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2022-01-yield-findings", "body": "Comment missing function parameter"}, {"title": "Unsafe uint128 casting may overflow", "html_url": "https://github.com/code-423n4/2022-01-yield-findings/issues/112", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-yield-findings", "body": "# Handle  sirhashalot   # Vulnerability details  ## Impact  The _calcRewardIntegral function casts intermediate reward values from uint256 to uint128 and vice versa several times. Because OpenZeppelin SafeCast is not used, casting from uint256 to uint128 may overflow if a large reward value is being calculate. This overflow could result in users receiving less rewards than they are owed.  ## Proof of Concept  There are 4 uint128 casting operations and 2 uint256 casting operations [in the _calcRewardIntegral function of ConvexStakingWrapper.sol](https://github.com/code-423n4/2022-01-yield/blob/e946f40239b33812e54fafc700eb2298df1a2579/contracts/ConvexStakingWrapper.sol#L222-L253).  ## Recommended Mitigation Steps  Because reward values are an important part of this protocol, use the OpenZeppelin SafeCast library to prevent unexpected overflows when casting. SafeMath and Solidity 0.8.* handles overflows for basic math operations but not for casting.  "}, {"title": "`ConvexYieldWrapper#removeVault()` `found` is redundant", "html_url": "https://github.com/code-423n4/2022-01-yield-findings/issues/111", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-yield-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-yield/blob/e946f40239b33812e54fafc700eb2298df1a2579/contracts/ConvexYieldWrapper.sol#L74-L95  ```solidity     function removeVault(bytes12 vaultId, address account) public {         address owner = cauldron.vaults(vaultId).owner;         if (account != owner) {             bytes12[] storage vaults_ = vaults[account];             uint256 vaultsLength = vaults_.length;             bool found;             for (uint256 i = 0; i < vaultsLength; i++) {                 if (vaults_[i] == vaultId) {                     bool isLast = i == vaultsLength - 1;                     if (!isLast) {                         vaults_[i] = vaults_[vaultsLength - 1];                     }                     vaults_.pop();                     found = true;                     emit VaultRemoved(account, vaultId);                     break;                 }             }             require(found, \"Vault not found\");             vaults[account] = vaults_;         }     } ```  `found` is redundant, we can just use `return` to stop the whole function when the `vault` to be removed is found and removed.  `removeVault()` can be changed to:  ```solidity function removeVault(bytes12 vaultId, address account) public {     address owner = cauldron.vaults(vaultId).owner;     if (account != owner) {         bytes12[] storage vaults_ = vaults[account];         uint256 vaultsLength = vaults_.length;         for (uint256 i = 0; i < vaultsLength; i++) {             if (vaults_[i] == vaultId) {                 bool isLast = i == vaultsLength - 1;                 if (!isLast) {                     vaults_[i] = vaults_[vaultsLength - 1];                 }                 vaults_.pop();                 found = true;                 emit VaultRemoved(account, vaultId);                 return;             }         }         revert(\"Vault not found\");     } } ```  "}, {"title": "`ConvexYieldWrapper.sol` Redundant code", "html_url": "https://github.com/code-423n4/2022-01-yield-findings/issues/107", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-yield-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-yield/blob/e946f40239b33812e54fafc700eb2298df1a2579/contracts/ConvexYieldWrapper.sol#L74-L95  ```solidity function removeVault(bytes12 vaultId, address account) public {     address owner = cauldron.vaults(vaultId).owner;     if (account != owner) {         bytes12[] storage vaults_ = vaults[account];         uint256 vaultsLength = vaults_.length;         bool found;         for (uint256 i = 0; i < vaultsLength; i++) {             if (vaults_[i] == vaultId) {                 bool isLast = i == vaultsLength - 1;                 if (!isLast) {                     vaults_[i] = vaults_[vaultsLength - 1];                 }                 vaults_.pop();                 found = true;                 emit VaultRemoved(account, vaultId);                 break;             }         }         require(found, \"Vault not found\");         vaults[account] = vaults_;     } } ```  At L77, `vaults_` is defined as `vaults[account]`, thus `vaults[account] = vaults_` at L93 is redundant.  https://github.com/code-423n4/2022-01-yield/blob/e946f40239b33812e54fafc700eb2298df1a2579/contracts/ConvexYieldWrapper.sol#L57-L69  ```solidity function addVault(bytes12 vaultId) external {     address account = cauldron.vaults(vaultId).owner;     require(account != address(0), \"No owner for the vault\");     bytes12[] storage vaults_ = vaults[account];     uint256 vaultsLength = vaults_.length;      for (uint256 i = 0; i < vaultsLength; i++) {         require(vaults_[i] != vaultId, \"Vault already added\");     }     vaults_.push(vaultId);     vaults[account] = vaults_;     emit VaultAdded(account, vaultId); } ```  Similarly, L76 is redundant.  "}, {"title": "Perform math inside code branch", "html_url": "https://github.com/code-423n4/2022-01-yield-findings/issues/106", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-yield-findings", "body": "# Handle  sirhashalot   # Vulnerability details  ## Impact  The `_calcCvxIntegral()` function in ConvexStakingWrapper.sol doesn't use the same gas optimization that its sibling function `_calcRewardIntegral()` uses.  ## Proof of Concept  This code is from [the `_calcCvxIntegral()` function](https://github.com/code-423n4/2022-01-yield/blob/e946f40239b33812e54fafc700eb2298df1a2579/contracts/ConvexStakingWrapper.sol#L154) ``` if (_isClaim || userI < cvxRewardIntegral) {     uint256 receiveable = cvx_claimable_reward[_accounts[u]] +         ((_balances[u] * (cvxRewardIntegral - userI)) / 1e20);     if (_isClaim) {         if (receiveable > 0) {             cvx_claimable_reward[_accounts[u]] = 0;             IERC20(cvx).safeTransfer(_accounts[u], receiveable);             bal = bal - (receiveable);         }     } else {         cvx_claimable_reward[_accounts[u]] = receiveable;     }     cvx_reward_integral_for[_accounts[u]] = cvxRewardIntegral; } ```  The related code from [the `_calcRewardIntegral()` function](https://github.com/code-423n4/2022-01-yield/blob/e946f40239b33812e54fafc700eb2298df1a2579/contracts/ConvexStakingWrapper.sol#L206) has the receivable calculation inside the `if (_isClaim)` code branch to save gas if _isClaim is false.  ``` if (_isClaim || userI < rewardIntegral) {     if (_isClaim) {         uint256 receiveable = reward.claimable_reward[_accounts[u]] +             ((_balances[u] * (uint256(rewardIntegral) - userI)) / 1e20);         if (receiveable > 0) {             reward.claimable_reward[_accounts[u]] = 0;             IERC20(reward.reward_token).safeTransfer(_accounts[u], receiveable);             bal = bal - receiveable;         }     } else {         reward.claimable_reward[_accounts[u]] =             reward.claimable_reward[_accounts[u]] +             ((_balances[u] * (uint256(rewardIntegral) - userI)) / 1e20);     }     reward.reward_integral_for[_accounts[u]] = rewardIntegral; } ```  This optimization would save gas each time `_checkpoint()` is called because `_checkpoint()` sets _isClaim to false and doesn't enter the `if(_isClaim)` branch.   ## Recommended Mitigation Steps  Modify the `_calcCvxIntegral()` function to place the receiveable calculation inside the `if (_isClaim)` code branch.  "}, {"title": "Adding unchecked directive can save gas", "html_url": "https://github.com/code-423n4/2022-01-yield-findings/issues/105", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-yield-findings", "body": "Adding unchecked directive can save gas"}, {"title": "`ConvexStakingWrapper.sol#` Switching between 1, 2 instead of 0, 1 is more gas efficient", "html_url": "https://github.com/code-423n4/2022-01-yield-findings/issues/102", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-yield-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-yield/blob/e946f40239b33812e54fafc700eb2298df1a2579/contracts/ConvexStakingWrapper.sol#L54-L55  ```solidity     bool private constant _NOT_ENTERED = false;     bool private constant _ENTERED = true; ```  https://github.com/code-423n4/2022-01-yield/blob/e946f40239b33812e54fafc700eb2298df1a2579/contracts/ConvexStakingWrapper.sol#L81-L90  ```solidity     modifier nonReentrant() {         // On the first call to nonReentrant, _notEntered will be true         require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");         // Any calls to nonReentrant after this point will fail         _status = _ENTERED;         _;         // By storing the original value once again, a refund is triggered (see         // https://eips.ethereum.org/EIPS/eip-2200)         _status = _NOT_ENTERED;     } ```  `SSTORE` from 0 to 1 (or any non-zero value), the cost is 20000; `SSTORE` from 1 to 2 (or any other non-zero value), the cost is 5000.  By storing the original value once again, a refund is triggered (https://eips.ethereum.org/EIPS/eip-2200).  Since refunds are capped to a percentage of the total transaction's gas, it is best to keep them low, to increase the likelihood of the full refund coming into effect.  Therefore, switching between 1, 2 instead of 0, 1 will be more gas efficient.  See: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/86bd4d73896afcb35a205456e361436701823c7a/contracts/security/ReentrancyGuard.sol#L29-L33  "}, {"title": "Avoid unnecessary arithmetic operations and storage reads can save gas", "html_url": "https://github.com/code-423n4/2022-01-yield-findings/issues/101", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-yield-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-yield/blob/e946f40239b33812e54fafc700eb2298df1a2579/contracts/ConvexStakingWrapper.sol#L106-L111  ```solidity     if (rewardsLength == 0) {         RewardType storage reward = rewards.push();         reward.reward_token = crv;         reward.reward_pool = mainPool;         rewardsLength += 1;     } ```  When `rewardsLength` == `0`,  the new `rewardsLength` will always be 1. Therefore, replacing `+=` with `=` can avoid the unnecessary arithmetic operations and memory reads    ### Recommendation  Change to:  ```solidity     if (rewardsLength == 0) {         RewardType storage reward = rewards.push();         reward.reward_token = crv;         reward.reward_pool = mainPool;         rewardsLength = 1;     } ```  "}, {"title": "Cvx3CrvOracle earned function calculates cvx wrongly if pool claimed indirectly", "html_url": "https://github.com/code-423n4/2022-01-yield-findings/issues/95", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-yield-findings", "body": "# Handle  kenzo   # Vulnerability details  The ConvexStakingWrapper that Yield is based on recently published a fix for `earned` function in case the pool is claimed indirectly.  ## Impact Wrong results might be returned from view function `earned`.  ## Proof of Concept This is the fix for earned: [fix commit](https://github.com/convex-eth/platform/commit/9b9dd72bdb822e7f34f241d620cc1f8388bf7d6a#)  ## Recommended Mitigation Steps Apply fix.  "}, {"title": "Cvx3CrvOracle returns 0 for small baseAmount", "html_url": "https://github.com/code-423n4/2022-01-yield-findings/issues/93", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2022-01-yield-findings", "body": "Cvx3CrvOracle returns 0 for small baseAmount"}, {"title": "Malicious Users Can Transfer Vault Collateral To Other Accounts To Extract Additional Yield From The Protocol", "html_url": "https://github.com/code-423n4/2022-01-yield-findings/issues/89", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-01-yield-findings", "body": "# Handle  leastwood   # Vulnerability details  ## Impact  `ConvexYieldWrapper.sol` is a wrapper contract for staking convex tokens on the user's behalf, allowing them to earn rewards on their deposit. Users will interact with the `Ladle.sol` contract's `batch()` function which: - Approves Ladle to move the tokens. - Transfers the tokens to `ConvexYieldWrapper.sol`. - Wraps/stakes these tokens. - Updates accounting and produces debt tokens within `Ladle.sol`.  `_getDepositedBalance()` takes into consideration the user's total collateral stored in all of their owned vaults. However, as a vault owner, you are allowed to give the vault to another user, move collateral between vaults and add/remove collateral. Therefore, it is possible to manipulate the result of this function by checkpointing one user's balance at a given time, transferring ownership to another user and then create a new checkpoint with this user.   As a result, a user is able to generate protocol yield multiple times over on a single collateral amount. This can be abused to effectively extract all protocol yield.  ## Proof of Concept  Consider the following exploit scenario: - Alice owns a vault which has 100 tokens worth of collateral. - At that point in time, `_getDepositedBalance()` returns 100 as its result. A checkpoint has also been made on this balance, giving Alice claim to her fair share of the rewards. - Alice then calls `Ladle.give()`, transferring the ownership of the vault to Bob and calls `ConvexYieldWrapper.addVault()`. - Bob is able to call `user_checkpoint()` and effectively update their checkpointed balance. - At this point in time, both Alice and Bob have claim to any yield generated by the protocol, however, there is only one vault instance that holds the underlying collateral.  https://github.com/code-423n4/2022-01-yield/blob/main/contracts/ConvexYieldWrapper.sol#L100-L120 ``` function _getDepositedBalance(address account_) internal view override returns (uint256) {     if (account_ == address(0) || account_ == collateralVault) {         return 0;     }      bytes12[] memory userVault = vaults[account_];      //add up all balances of all vaults registered in the wrapper and owned by the account     uint256 collateral;     DataTypes.Balances memory balance;     uint256 userVaultLength = userVault.length;     for (uint256 i = 0; i < userVaultLength; i++) {         if (cauldron.vaults(userVault[i]).owner == account_) {             balance = cauldron.balances(userVault[i]);             collateral = collateral + balance.ink;         }     }      //add to balance of this token     return _balanceOf[account_] + collateral; } ```  ## Tools Used  Manual code review. Discussion/confirmation with the Yield Protocol team.  ## Recommended Mitigation Steps  Ensure that any change to a vault will correctly checkpoint the previous and new vault owner. The affected actions include but are not limited to; transferring ownership of a vault to a new account, transferring collateral to another vault and adding/removing collateral to/from a vault.  "}, {"title": "Only passing in one depositedBalance in _checkpointAndClaim()", "html_url": "https://github.com/code-423n4/2022-01-yield-findings/issues/88", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-yield-findings", "body": "# Handle  GeekyLumberjack   # Vulnerability details  `uint256[2] memory depositedBalance;` is defined at the beginning of [_checkpointAndClaim](https://github.com/code-423n4/2022-01-yield/blob/main/contracts/ConvexStakingWrapper.sol#L279-L291) only one `depositedBalance` slot is being filed and then the entire array gets passed into `_calcRewardIntegral()` and `_calcCvxIntegral()` along with an array of two `_accounts`. Having only one of the `depositedBalance` and two `_accounts` may cause loss in rewards for the second account. This function is currently only used in `GetReward()` which is passing in a zero address as the second address.   "}, {"title": "Malicious Users Can Duplicate Protocol Earned Yield By Transferring `wCVX` Tokens To Another Account", "html_url": "https://github.com/code-423n4/2022-01-yield-findings/issues/86", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-yield-findings", "body": "# Handle  leastwood   # Vulnerability details  ## Impact  `ConvexYieldWrapper.sol` is a wrapper contract for staking convex tokens on the user's behalf, allowing them to earn rewards on their deposit. Users will interact with the `Ladle.sol` contract's `batch()` function which: - Approves Ladle to move the tokens. - Transfers the tokens to `ConvexYieldWrapper.sol`. - Wraps/stakes these tokens. - Updates accounting and produces debt tokens within `Ladle.sol`.  During `wrap()` and `unwrap()` actions, `_checkpoint()` is used to update the rewards for the `from_` and `to_` accounts. However, the [reference](https://github.com/convex-eth/platform/blob/main/contracts/contracts/wrappers/ConvexStakingWrapper.sol#L395-L397) contract implements a `_beforeTokenTransfer()` function which has been removed from Yield Protocol's custom implementation.  As a result, it is possible to transfer `wCVX` tokens to another account after an initial checkpoint has been made. By manually calling `user_checkpoint()` on the new account, this user is able to update its deposited balance of the new account while the sender's balance is not updated. This can be repeated to effectively replicate a user's deposited balance over any number of accounts. To claim yield generated by the protocol, the user must only make sure that the account calling `getReward()` holds the tokens for the duration of the call.  ## Proof of Concept  The exploit can be outlined through the following steps: - Alice receives 100 `wCVX` tokens from the protocol after wrapping their convex tokens. - At that point in time, `_getDepositedBalance()` returns 100 as its result. A checkpoint has also been made on this balance, giving Alice claim to her fair share of the rewards. - Alice transfers her tokens to her friend Bob who then manually calls `user_checkpoint()` to update his balance. - Now from the perspective of the protocol, both Alice and Bob have 100 `wCVX` tokens as calculated by the `_getDepositedBalance()` function. - If either Alice or Bob wants to claim rewards, all they need to do is make sure the 100 `wCVX` tokens are in their account upon calling `getReward()`. Afterwards, the tokens can be transferred out.  ## Tools Used  Manual code review. Discussion/confirmation with the Yield Protocol team.  ## Recommended Mitigation Steps  Consider implementing the `_beforeTokenTransfer()` function as shown in the [reference](https://github.com/convex-eth/platform/blob/main/contracts/contracts/wrappers/ConvexStakingWrapper.sol#L395-L397) contract. However, it is important to ensure the wrapper contract and collateral vaults are excluded from the checkpointing so they are not considered in the rewards calculations.  "}, {"title": "Unnecessary check on quote in Cvx3CrvOracle", "html_url": "https://github.com/code-423n4/2022-01-yield-findings/issues/79", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-yield-findings", "body": "# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact gas costs  ## Proof of Concept  L116 of Cvx3CrvOracle enforces for the rest of the function call that `base == ethId <-> quote == cvx3CrvId`  https://github.com/code-423n4/2022-01-yield/blob/e946f40239b33812e54fafc700eb2298df1a2579/contracts/Cvx3CrvOracle.sol#L116  However on L137 we check both these conditions again.  https://github.com/code-423n4/2022-01-yield/blob/e946f40239b33812e54fafc700eb2298df1a2579/contracts/Cvx3CrvOracle.sol#L137  We could check just one of these and then rely on the require condition on 116 to enforce the other one. This will prevent us having to SLOAD `ethID` again  ## Recommended Mitigation Steps  Change L137 to `if (base == cvx3CrvId) {`  "}, {"title": "`ConvexStakingWrapper.sol`: related data should be grouped in a struct", "html_url": "https://github.com/code-423n4/2022-01-yield-findings/issues/76", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor acknowledged"], "target": "2022-01-yield-findings", "body": "`ConvexStakingWrapper.sol`: related data should be grouped in a struct"}, {"title": "`ConvexStakingWrapper.sol`: `AccessControl` capabilities aren't used", "html_url": "https://github.com/code-423n4/2022-01-yield-findings/issues/75", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2022-01-yield-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact AccessControl capabilities aren't used.  ## Proof of Concept In `ConvexStakingWrapper.sol`, `AccessControl` seem superfluous: ``` 7: import \"@yield-protocol/utils-v2/contracts/access/AccessControl.sol\"; ... 15: contract ConvexStakingWrapper is ERC20, AccessControl { ``` In the original `ConvexStakingWrapper.sol`, this `AccessControl` isn't inherited.   In this contract, I believe role-based capabilities were thought of, but were forgotten or abandonned.  ## Tools Used VS Code  ## Recommended Mitigation Steps Either use the capabilities from `AccessControl`, or delete the import + the inheritance to save gas.  "}, {"title": "`ConvexStakingWrapper.sol`: unused `nonReentrant` modifier", "html_url": "https://github.com/code-423n4/2022-01-yield-findings/issues/74", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-yield-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact No protection from reentrancy (besides the gas limit on safeTransfer). Bad practice compared to the original `ConvexStakingWrapper` contract.  ## Proof of Concept The original `ConvexStakingWrapper` contract used the `nonReentrant` modifier on all functions using the `safeTransfer` or `safeTransferFrom` methods: - `deposit`: https://github.com/convex-eth/platform/blob/main/contracts/contracts/wrappers/ConvexStakingWrapper.sol#L337 - `stake`: https://github.com/convex-eth/platform/blob/main/contracts/contracts/wrappers/ConvexStakingWrapper.sol#L352  - `withdraw`: https://github.com/convex-eth/platform/blob/main/contracts/contracts/wrappers/ConvexStakingWrapper.sol#L367 - `withdrawAndUnwrap`: https://github.com/convex-eth/platform/blob/main/contracts/contracts/wrappers/ConvexStakingWrapper.sol#L381  As the current one in the Yield solution is an upgrade, it should follow the same good practices.  ## Tools Used VS Code  ## Recommended Mitigation Steps Use the `nonReentrant` modifier on external functions that end up calling `safeTransfer` or `safeTransferFrom` (`user_checkpoint()` and `getReward()`)  "}, {"title": "less gas usage by calling the `TransferHelper` lib directly", "html_url": "https://github.com/code-423n4/2022-01-yield-findings/issues/72", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-yield-findings", "body": "# Handle  rfa   # Vulnerability details  ## Impact spend at least 6930 more gas on deployment, and spend 40 gas more per call (by using current implementasion)  ## Proof of Concept https://github.com/code-423n4/2022-01-yield/blob/main/contracts/ConvexStakingWrapper.sol#L184 https://github.com/code-423n4/2022-01-yield/blob/main/contracts/ConvexStakingWrapper.sol#L239  the `TransferHelper` lib just used twice in this contract. remove:(line 16) https://github.com/code-423n4/2022-01-yield/blob/main/contracts/ConvexStakingWrapper.sol#L16  and just call `TransferHelper.safeTransfer()` directly at those line.  This method is using almost exact the same gas as if we just copying the `safeTransfer()` and remove the `TransferHelper` lib from the contract. (since we need just 1 function from the lib)    "}, {"title": "Gas in `Cvx3CrvOracle.sol:_peek()`: `ethId` and `cvx3CrvId` should get cached ", "html_url": "https://github.com/code-423n4/2022-01-yield-findings/issues/70", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-yield-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact SLOADs are expensive (~100 gas) compared to MLOADs/MSTOREs (~3 gas). Minimizing them can save gas.  ## Proof of Concept The code is as such (see `@audit-info`): ``` File: Cvx3CrvOracle.sol 110:     function _peek( 111:         bytes6 base, 112:         bytes6 quote, 113:         uint256 baseAmount 114:     ) private view returns (uint256 quoteAmount, uint256 updateTime) { 115:         require( 116:             (base == ethId && quote == cvx3CrvId) || // @audit-info ethId SLOAD 1, cvx3CrvId SLOAD 1 117:                 (base == cvx3CrvId && quote == ethId), // @audit-info ethId SLOAD 2, cvx3CrvId SLOAD 2 118:             \"Invalid quote or base\" 119:         ); 120:         (, int256 daiPrice, , , ) = DAI.latestRoundData(); 121:         (, int256 usdcPrice, , , ) = USDC.latestRoundData(); 122:         (, int256 usdtPrice, , , ) = USDT.latestRoundData(); 123:  124:         require( 125:             daiPrice > 0 && usdcPrice > 0 && usdtPrice > 0, 126:             \"Chainlink pricefeed reporting 0\" 127:         ); 128:  129:         // This won't overflow as the max value for int256 is less than the max value for uint256 130:         uint256 minStable = min( 131:             uint256(daiPrice), 132:             min(uint256(usdcPrice), uint256(usdtPrice)) 133:         ); 134:  135:         uint256 price = (threecrv.get_virtual_price() * minStable) / 1e18; 136:  137:         if (base == cvx3CrvId && quote == ethId) { // @audit-info ethId SLOAD 3, cvx3CrvId SLOAD 3 138:             quoteAmount = (baseAmount * price) / 1e18; 139:         } else { 140:             quoteAmount = (baseAmount * 1e18) / price; 141:         } 142:  143:         updateTime = block.timestamp; 144:     } ```  By caching `ethId` and `cvx3CrvId` in memory, it's possible to save 4 SLOADs (~400gas) at the cost of 2 MSTOREs (6 gas) and 4 MLOADs (12 gas)  ## Tools Used VS Code  ## Recommended Mitigation Steps Cache `ethId` and `cvx3CrvId` in variables and use these instead  "}, {"title": "Gas in `ConvexStakingWrapper.sol:_calcRewardIntegral()`: `bal - rewardRemaining` can't underflow", "html_url": "https://github.com/code-423n4/2022-01-yield-findings/issues/67", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-yield-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact Increased gas cost due to unnecessary automatic underflow checks.  Solidity version 0.8+ comes with implicit overflow and underflow checks on unsigned integers.  When an overflow or an underflow isn't possible (as an example, when a comparison is made before the arithmetic operation, or the operation doesn't depend on user input), some gas can be saved by using an `unchecked` block.  https://docs.soliditylang.org/en/v0.8.10/control-structures.html#checked-or-unchecked-arithmetic  ## Proof of Concept In `ConvexStakingWrapper.sol:_calcRewardIntegral()`, `bal - rewardRemaining` can't underflow at line 222 as the conditional statement line 221 prevents it: ``` File: ConvexStakingWrapper.sol 221:         if (_supply > 0 && (bal - rewardRemaining) > 0) { 222:             rewardIntegral = uint128(rewardIntegral) + uint128(((bal - rewardRemaining) * 1e20) / _supply); //@audit-info (bal - rewardRemaining) can't underflow because of above if statement ``` This substraction should get computed inside an `unchecked` block and stored in a variable, which would then be used in the checked calculation for `rewardIntegral`.  ## Tools Used VS Code  ## Recommended Mitigation Steps Uncheck arithmetic operations when the risk of underflow or overflow is already contained by wrapping them in an `unchecked` block    "}, {"title": "Gas: Unused Named Returns", "html_url": "https://github.com/code-423n4/2022-01-yield-findings/issues/60", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2022-01-yield-findings", "body": "Gas: Unused Named Returns"}, {"title": "Gas: Tight variable packing in `ConvexStakingWrapper.sol`", "html_url": "https://github.com/code-423n4/2022-01-yield-findings/issues/58", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-yield-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact Solidity contracts have contiguous 32 bytes (256 bits) slots used in storage. By arranging the variables, it is possible to minimize the number of slots used within a contract's storage and therefore reduce deployment costs.  ## Proof of Concept In `ConvexStakingWrapper.sol`, the order of variables is this way: ```     uint256 public cvx_reward_integral;     uint256 public cvx_reward_remaining;     mapping(address => uint256) public cvx_reward_integral_for;     mapping(address => uint256) public cvx_claimable_reward;      //constants/immutables     address public constant convexBooster = address(0xF403C135812408BFbE8713b5A23a04b3D48AAE31);     address public constant crv = address(0xD533a949740bb3306d119CC777fa900bA034cd52);     address public constant cvx = address(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B);     address public curveToken;     address public convexToken;     address public convexPool;     address public collateralVault;     uint256 public convexPoolId;      //rewards     RewardType[] public rewards;      //management     bool public isShutdown;     bool private _status;      bool private constant _NOT_ENTERED = false;     bool private constant _ENTERED = true; ``` `address` type variables are each of 20 bytes size (way less than 32 bytes). However, they here take up a whole 32 bytes slot (they are contiguous). As `bool` type variables are of size 1 byte, there's a slot here that can get saved by moving them closer to an address  ## Recommended Mitigation Steps I suggest the following (see the @audit-info tags for more details about what moved and why): ```     uint256 public cvx_reward_integral;     uint256 public cvx_reward_remaining;     mapping(address => uint256) public cvx_reward_integral_for;     mapping(address => uint256) public cvx_claimable_reward;      //constants/immutables     uint256 public convexPoolId; //@audit-info this moved up to free collateralVault's slot.     address public constant convexBooster = address(0xF403C135812408BFbE8713b5A23a04b3D48AAE31);     address public constant crv = address(0xD533a949740bb3306d119CC777fa900bA034cd52);     address public constant cvx = address(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B);     address public curveToken;     address public convexToken;     address public convexPool;     address public collateralVault; //@audit-info this got freed from convexPoolId. Slot N is at 20/32 here      //management      bool public isShutdown; //@audit-info this moved up. Slot N is full at 21/32 here      bool private _status; //@audit-info this moved up. Slot N is full at 22/32 here      bool private constant _NOT_ENTERED = false; //@audit-info this moved up but doesn't take a slot as it's constant     bool private constant _ENTERED = true; //@audit-info this moved up but doesn't take a slot as it's constant       //rewards     RewardType[] public rewards; ```    "}, {"title": "Gas: `> 0` is less efficient than `!= 0` for unsigned integers", "html_url": "https://github.com/code-423n4/2022-01-yield-findings/issues/57", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-01-yield-findings", "body": "Gas: `> 0` is less efficient than `!= 0` for unsigned integers"}, {"title": "Gas: No need to initialize variables with default values", "html_url": "https://github.com/code-423n4/2022-01-yield-findings/issues/56", "labels": ["bug", "G (Gas Optimization)", "resolved"], "target": "2022-01-yield-findings", "body": "Gas: No need to initialize variables with default values"}, {"title": "Typos", "html_url": "https://github.com/code-423n4/2022-01-yield-findings/issues/54", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2022-01-yield-findings", "body": "Typos"}, {"title": "caching curveToken in  memory can cost less gas", "html_url": "https://github.com/code-423n4/2022-01-yield-findings/issues/49", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-yield-findings", "body": "# Handle  Funen   # Vulnerability details  https://github.com/code-423n4/2022-01-yield/blob/main/contracts/ConvexStakingWrapper.sol#L94-L95  ``` IERC20(curveToken).approve(convexBooster, 0); IERC20(curveToken).approve(convexBooster, type(uint256).max); ```  `curveToken` was called mutiple times, caching it in `memory` , it can cost less gas  "}, {"title": "Lack of important event", "html_url": "https://github.com/code-423n4/2022-01-yield-findings/issues/43", "labels": ["bug", "0 (Non-critical)", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-yield-findings", "body": "# Handle  0x1f8b   # Vulnerability details  ## Impact owner can change the source without any warning.  ## Proof of Concept The method `Cvx3CrvOracle.setSource` should emit an event in order to be able to detect this call by dapps.  ## Tools Used Manual review  ## Recommended Mitigation Steps Emit an event  "}, {"title": "Gas saving using immutable", "html_url": "https://github.com/code-423n4/2022-01-yield-findings/issues/42", "labels": ["bug", "G (Gas Optimization)", "sponsor disputed"], "target": "2022-01-yield-findings", "body": "Gas saving using immutable"}, {"title": "Unbounded loop on array can lead to DoS", "html_url": "https://github.com/code-423n4/2022-01-yield-findings/issues/36", "labels": ["bug", "1 (Low Risk)", "sponsor disputed"], "target": "2022-01-yield-findings", "body": "Unbounded loop on array can lead to DoS"}, {"title": "Missing commenting", "html_url": "https://github.com/code-423n4/2022-01-yield-findings/issues/33", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2022-01-yield-findings", "body": "Missing commenting"}, {"title": "Prefix increments are cheaper than postfix increments", "html_url": "https://github.com/code-423n4/2022-01-yield-findings/issues/14", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-yield-findings", "body": "Prefix increments are cheaper than postfix increments"}, {"title": "Unnecessary array boundaries check when loading an array element twice", "html_url": "https://github.com/code-423n4/2022-01-yield-findings/issues/13", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-yield-findings", "body": "Unnecessary array boundaries check when loading an array element twice"}, {"title": "Unused imports", "html_url": "https://github.com/code-423n4/2022-01-yield-findings/issues/8", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2022-01-yield-findings", "body": "Unused imports"}, {"title": "Race condition in approve()", "html_url": "https://github.com/code-423n4/2022-01-yield-findings/issues/6", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2022-01-yield-findings", "body": "Race condition in approve()"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-aave-lens-findings/issues/87", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-02-aave-lens-findings", "body": "QA Report"}, {"title": "Zero collection module can be whitelisted and set to a post, which will then revert all collects and mirrors with PublicationDoesNotExist", "html_url": "https://github.com/code-423n4/2022-02-aave-lens-findings/issues/86", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-02-aave-lens-findings", "body": "Zero collection module can be whitelisted and set to a post, which will then revert all collects and mirrors with PublicationDoesNotExist"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-aave-lens-findings/issues/85", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-02-aave-lens-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-aave-lens-findings/issues/84", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-aave-lens-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-aave-lens-findings/issues/83", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-aave-lens-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-aave-lens-findings/issues/82", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-02-aave-lens-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-aave-lens-findings/issues/80", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-02-aave-lens-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-aave-lens-findings/issues/79", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-aave-lens-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-aave-lens-findings/issues/75", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-aave-lens-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-aave-lens-findings/issues/74", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-aave-lens-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-aave-lens-findings/issues/73", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-02-aave-lens-findings", "body": "QA Report"}, {"title": "missing whenNotPaused", "html_url": "https://github.com/code-423n4/2022-02-aave-lens-findings/issues/71", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-02-aave-lens-findings", "body": "missing whenNotPaused"}, {"title": "It's possible to follow deleted profiles", "html_url": "https://github.com/code-423n4/2022-02-aave-lens-findings/issues/70", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-02-aave-lens-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-aave-lens/blob/main/contracts/libraries/InteractionLogic.sol#L49   # Vulnerability details  When someone tries to follow a profile, it checks if the handle exists, and if it doesn't, it reverts because the profile is deleted. The problem is that there might be a new profile with the same handle as the deleted one, allowing following deleted profiles.   ## Proof of Concept Alice creates a profile with the handle \"alice.\" The profile id is 1. she deleted the profile. she opens a new profile with the handle \"alice\". The new profile id is 2. bob tries to follow the deleted profile (id is 1). the check ``` if (_profileIdByHandleHash[keccak256(bytes(handle))] == 0)  revert Errors.TokenDoesNotExist(); ``` doesn't revert because there exists a profile with the handle \"alice\". Therefore bob followed a deleted profile when he meant to follow the new profile.   ## Recommended Mitigation Steps  change to: ``` if (_profileIdByHandleHash[keccak256(bytes(handle))] != profileIds[i])  revert Errors.TokenDoesNotExist(); ```   "}, {"title": "[WP-H3] Imprecise management of users' allowance allows the admin of the upgradeable proxy contract to rug users", "html_url": "https://github.com/code-423n4/2022-02-aave-lens-findings/issues/68", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-02-aave-lens-findings", "body": "[WP-H3] Imprecise management of users' allowance allows the admin of the upgradeable proxy contract to rug users"}, {"title": "[WP-M1] Inappropriate handling of `referralFee` makes collecting Mirror fails without error when `referrerProfileId` is burned", "html_url": "https://github.com/code-423n4/2022-02-aave-lens-findings/issues/67", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-02-aave-lens-findings", "body": "[WP-M1] Inappropriate handling of `referralFee` makes collecting Mirror fails without error when `referrerProfileId` is burned"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-aave-lens-findings/issues/66", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-02-aave-lens-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-aave-lens-findings/issues/64", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-02-aave-lens-findings", "body": "QA Report"}, {"title": "Collect modules can fail on zero amount transfers if treasury fee is set to zero", "html_url": "https://github.com/code-423n4/2022-02-aave-lens-findings/issues/62", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-02-aave-lens-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-aave-lens/blob/main/contracts/core/modules/collect/FeeCollectModule.sol#L176   # Vulnerability details  ## Impact  Treasury fee can be zero, while collect modules do attempt to send it in such a case anyway as there is no check in place. Some ERC20 tokens do not allow zero value transfers, reverting such attempts.  This way, a combination of zero treasury fee and such a token set as a collect fee currency will revert any collect operations, rendering collect functionality unavailable  ## Proof of Concept  Treasury fee can be set to zero:  https://github.com/code-423n4/2022-02-aave-lens/blob/main/contracts/core/modules/ModuleGlobals.sol#L109  Treasury fee transfer attempts are now done uncoditionally in all the collect modules.  Namely, FeeCollectModule, LimitedFeeCollectModule, TimedFeeCollectModule and LimitedTimedFeeCollectModule do not check the treasury fee to be send, `treasuryAmount`, before transferring:  https://github.com/code-423n4/2022-02-aave-lens/blob/main/contracts/core/modules/collect/FeeCollectModule.sol#L176  https://github.com/code-423n4/2022-02-aave-lens/blob/main/contracts/core/modules/collect/LimitedFeeCollectModule.sol#L194  https://github.com/code-423n4/2022-02-aave-lens/blob/main/contracts/core/modules/collect/TimedFeeCollectModule.sol#L190  https://github.com/code-423n4/2022-02-aave-lens/blob/main/contracts/core/modules/collect/LimitedTimedFeeCollectModule.sol#L205  The same happens in the FeeFollowModule:  https://github.com/code-423n4/2022-02-aave-lens/blob/main/contracts/core/modules/follow/FeeFollowModule.sol#L90  ## References  Some ERC20 tokens revert on zero value transfers:  https://github.com/d-xo/weird-erc20#revert-on-zero-value-transfers  ## Recommended Mitigation Steps  Consider checking the treasury fee amount and do transfer only when it is positive.  Now: ``` IERC20(currency).safeTransferFrom(follower, treasury, treasuryAmount); ```  To be: ``` if (treasuryAmount > 0)  IERC20(currency).safeTransferFrom(follower, treasury, treasuryAmount); ```   "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-aave-lens-findings/issues/60", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-02-aave-lens-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-aave-lens-findings/issues/56", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-aave-lens-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-aave-lens-findings/issues/54", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-02-aave-lens-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-aave-lens-findings/issues/49", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-02-aave-lens-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-aave-lens-findings/issues/47", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-aave-lens-findings", "body": "Gas Optimizations"}, {"title": "Basis points constant BPS_MAX is used as minimal fee amount requirement", "html_url": "https://github.com/code-423n4/2022-02-aave-lens-findings/issues/46", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-02-aave-lens-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-aave-lens/blob/main/contracts/core/modules/collect/FeeCollectModule.sol#L72   # Vulnerability details  ## Impact  Base fee modules require minimum fixed fee amount to be at least BPS_MAX, which is hard coded to be 10000.  This turns out to be a functionality restricting requirement for some currencies.  For example, WBTC (https://etherscan.io/token/0x2260fac5e5542a773aa44fbcfedf7c193bc2c599, #10 in ERC20 token rankings), has decimals of 8 and current market rate around $40k, i.e. if you want to use any WBTC based collect fee, it has to be at least $4 per collect or fee enabled follow.  Tether and USDC (https://etherscan.io/token/0xdac17f958d2ee523a2206206994597c13d831ec7 and https://etherscan.io/token/0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48, #1 and #3) have decimals of 6, so it is at least $0.01 per collect/follow, which also looks a bit tight for a hard floor minimum.  ## Proof of Concept  BPS_MAX is a system wide constant, now 10000:  https://github.com/code-423n4/2022-02-aave-lens/blob/main/contracts/core/modules/FeeModuleBase.sol#L17  https://github.com/code-423n4/2022-02-aave-lens/blob/main/contracts/core/modules/ModuleGlobals.sol#L20  This is correct for any fees defined in basis point terms.  When it comes to the nominal amount, 10000 can be too loose or too tight depending on a currency used, as there can be various combinations of decimals and market rates.   The following base collect module implementations require fee amount to be at least BPS_MAX (initialization reverts when amount < BPS_MAX):  All collect module implementations use the same check:  FeeCollectModule:  https://github.com/code-423n4/2022-02-aave-lens/blob/main/contracts/core/modules/collect/FeeCollectModule.sol#L72  LimitedFeeCollectModule:  https://github.com/code-423n4/2022-02-aave-lens/blob/main/contracts/core/modules/collect/LimitedFeeCollectModule.sol#L79  TimedFeeCollectModule:  https://github.com/code-423n4/2022-02-aave-lens/blob/main/contracts/core/modules/collect/TimedFeeCollectModule.sol#L81  LimitedTimedFeeCollectModule:  https://github.com/code-423n4/2022-02-aave-lens/blob/main/contracts/core/modules/collect/LimitedTimedFeeCollectModule.sol#L86   FeeFollowModule also uses the same approach:  https://github.com/code-423n4/2022-02-aave-lens/blob/main/contracts/core/modules/follow/FeeFollowModule.sol#L62  ## Recommended Mitigation Steps  As a simplest solution consider adding a separate constant for minimum fee amount in nominal terms, say 1 or 10   "}, {"title": "Reentrancy allows commenter to overwrite own comments", "html_url": "https://github.com/code-423n4/2022-02-aave-lens-findings/issues/45", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-02-aave-lens-findings", "body": "Reentrancy allows commenter to overwrite own comments"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-aave-lens-findings/issues/44", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-aave-lens-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-aave-lens-findings/issues/41", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-aave-lens-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-aave-lens-findings/issues/40", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-02-aave-lens-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-aave-lens-findings/issues/39", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-aave-lens-findings", "body": "Gas Optimizations"}, {"title": "Ineffective Whitelist", "html_url": "https://github.com/code-423n4/2022-02-aave-lens-findings/issues/30", "labels": ["bug", "2 (Med Risk)"], "target": "2022-02-aave-lens-findings", "body": "Ineffective Whitelist"}, {"title": "Name squatting", "html_url": "https://github.com/code-423n4/2022-02-aave-lens-findings/issues/27", "labels": ["bug", "2 (Med Risk)"], "target": "2022-02-aave-lens-findings", "body": "Name squatting"}, {"title": "Profile creation can be frontrun", "html_url": "https://github.com/code-423n4/2022-02-aave-lens-findings/issues/26", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-02-aave-lens-findings", "body": "Profile creation can be frontrun"}, {"title": "Approvals not cleared when transferring profile", "html_url": "https://github.com/code-423n4/2022-02-aave-lens-findings/issues/22", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-02-aave-lens-findings", "body": "Approvals not cleared when transferring profile"}, {"title": "Cashback on referral", "html_url": "https://github.com/code-423n4/2022-02-aave-lens-findings/issues/20", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-02-aave-lens-findings", "body": "Cashback on referral"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-aave-lens-findings/issues/18", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-02-aave-lens-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-aave-lens-findings/issues/17", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-aave-lens-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-aave-lens-findings/issues/16", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-02-aave-lens-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-aave-lens-findings/issues/15", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-02-aave-lens-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-aave-lens-findings/issues/13", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-aave-lens-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/265", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-02-concur-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/263", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-02-concur-findings", "body": "QA Report"}, {"title": "During stake or deposit, users would not be rewared the correct Concur token, when MasterChef has under-supply of it.", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/262", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-02-concur-findings", "body": "During stake or deposit, users would not be rewared the correct Concur token, when MasterChef has under-supply of it."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/261", "labels": ["bug", "duplicate", "QA (Quality Assurance)"], "target": "2022-02-concur-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/259", "labels": ["bug", "duplicate", "G (Gas Optimization)"], "target": "2022-02-concur-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/258", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-02-concur-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/256", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-02-concur-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/255", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-concur-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/254", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-02-concur-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/253", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-02-concur-findings", "body": "QA Report"}, {"title": "Deposits after the grace period should not be allowed", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/251", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-02-concur-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/Shelter.sol#L34 https://github.com/code-423n4/2022-02-concur/blob/main/contracts/Shelter.sol#L54   # Vulnerability details  ## Impact Function donate in Shelter shouldn't allow new deposits after the grace period ends, when the claim period begins.  Otherwise, it will be possible to increase savedTokens[_token], and thus new user claim amounts will increase after some users might already have withdrawn their shares.  ## Recommended Mitigation Steps Based on my understanding, it should contain this check: ```solidity   require(activated[_token] + GRACE_PERIOD > block.timestamp, \"too late\"); ```  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/248", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-02-concur-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/247", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-02-concur-findings", "body": "Gas Optimizations"}, {"title": "Repeated Calls to Shelter.withdraw Can Drain All Funds in Shelter", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/246", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-02-concur-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/Shelter.sol#L52-L57   # Vulnerability details  ## Impact tl;dr Anyone who can call `withdraw` to withdraw their own funds can call it repeatedly to withdraw the funds of others. `withdraw` should only succeed if the user hasn't withdrawn the token already.  The shelter can be used for users to withdraw funds in the event of an emergency. The `withdraw` function allows callers to withdraw tokens based on the tokens they have deposited into the shelter client: ConvexStakingWrapper. However, `withdraw` does not check if a user has already withdrawn their tokens. Thus a user that can `withdraw` tokens, can call withdraw repeatedly to steal the tokens of others.  ## Proof of Concept  tl;dr an attacker that can successfully call `withdraw` once on a shelter, can call it repeatedly to steal the funds of others. Below is a detailed scenario where this situation can be exploited.  1. Mallory deposits 1 `wETH` into `ConvexStakingWrapper` using [`deposit`](https://github.com/code-423n4/2022-02-concur/blob/shelter-client/contracts/ConvexStakingWrapper.sol#L280). Let's also assume that other users have deposited 2 `wETH` into the same contract. 2. An emergency happens and the owner of `ConvexStakingWrapper` calls `setShelter(shelter)` and `enterShelter([pidOfWETHToken, ...])`. Now `shelter` has 3 `wETH` and is activated for `wETH`. 3. Mallory calls `shelter.withdraw(wETHAddr, MalloryAddr)`, mallory will rightfully receive 1 wETH because her share of wETH in the shelter is 1/3. 4. Mallory calls `shelter.withdraw(wETHAddr, MalloryAddr)` again, receiving 1/3*2 = 2/3 wETH. `withdraw` does not check that she has already withdrawn. This time, the wETH does not belong to her, she has stolen the wETH of the other users. She can continue calling `withdraw` to steal the rest of the funds   ## Tools Used  Manual inspection.  ## Recommended Mitigation Steps  To mitigate this, `withdraw` must first check that `msg.sender` has not withdrawn this token before and `withdraw` must also record that `msg.sender` has withdrawn the token. The exact steps for this are below: 1. Add the following line to the beginning of `withdraw` (line 53): ``` require(!claimed[_token][msg.sender], \"already claimed\") ``` 2.  Replace [line 55](https://github.com/code-423n4/2022-02-concur/blob/main/contracts/Shelter.sol#L55) with the following: ``` claimed[_token][msg.sender] = true; ``` This replacement is necessary because we want to record who is withdrawing, not where they are sending the token which isn't really useful info.  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/245", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-02-concur-findings", "body": "Gas Optimizations"}, {"title": "Unconstrained fee", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/242", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-02-concur-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/MasterChef.sol#L86-L101   # Vulnerability details  ## Impact  Token fee in `MasterChef` can be set to more than 100%, (for example by accident) causing all `deposit` calls to fail due to underflow on subtraction when reward is lowered by the fee, thus breaking essential mechanics. Note that after the fee has been set to any value, it cannot be undone. A token cannot be removed, added, or added the second time. Thus, mistakenly (or deliberately, maliciously) added fee that is larger than 100% will make the contract impossible to recover from not being able to use the token.  ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  On setting fee ensure that it is below a set maximum, which is set to no more than 100%.   "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/241", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-02-concur-findings", "body": "QA Report"}, {"title": "Owner can steal Concur rewards", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/239", "labels": ["bug", "2 (Med Risk)", "sponsor disputed"], "target": "2022-02-concur-findings", "body": "Owner can steal Concur rewards"}, {"title": "Owner can lock tokens in `MasterChef`", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/238", "labels": ["bug", "2 (Med Risk)"], "target": "2022-02-concur-findings", "body": "Owner can lock tokens in `MasterChef`"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/233", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-02-concur-findings", "body": "Gas Optimizations"}, {"title": "ConvexStakingWrapper deposits and withdraws will frequently be disabled if a token that doesn't allow zero value transfers will be added as a reward one", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/231", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-02-concur-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L182   # Vulnerability details  ## Impact  If deposits and withdraws are done frequently enough, the reward update operation they invoke will deal mostly with the case when there is nothing to add yet, i.e. `reward.remaining` match the reward token balance.  If reward token doesn't allow for zero value transfers, the reward update function will fail on an empty incremental reward transfer, which is now done unconditionally, reverting the caller deposit/withdrawal functionality  ## Proof of Concept  When ConvexStakingWrapper isn't paused, every deposit and withdraw update current rewards via `_checkpoint` function before proceeding:  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L233  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L260  `_checkpoint` calls `_calcRewardIntegral` for each of the reward tokens of the pid:  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L220  `_calcRewardIntegral` updates the incremental reward for the token, running the logic even if reward is zero, which is frequently the case:  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L182  If the reward token doesn't allow zero value transfers, this transfer will fail, reverting the corresponding deposit or withdraw  ## Recommended Mitigation Steps  Consider checking the reward before doing transfer (and the related computations as an efficiency measure):  Now: ``` IERC20(reward.token).transfer(address(claimContract), d_reward); ```  To be: ``` if (d_reward > 0)  IERC20(reward.token).transfer(address(claimContract), d_reward); ```   "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/230", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-02-concur-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/228", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-concur-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/227", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-02-concur-findings", "body": "QA Report"}, {"title": "StakingRewards.setRewardsDuration allows setting near zero or enormous rewardsDuration, which breaks reward logic", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/223", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-02-concur-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/StakingRewards.sol#L178-185   # Vulnerability details  ## Impact  notifyRewardAmount will be inoperable if rewardsDuration bet set to zero. If will cease to produce meaningful results if rewardsDuration be too small or too big  ## Proof of Concept  The setter do not control the value, allowing zero/near zero/enormous duration:  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/StakingRewards.sol#L178-185  Division by the duration is used in notifyRewardAmount:  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/StakingRewards.sol#L143-156  ## Recommended Mitigation Steps  Check for min and max range in the rewardsDuration setter, as too small or too big rewardsDuration breaks the logic  "}, {"title": "Rewards get diluted because `totalAllocPoint` can only increase.", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/221", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-02-concur-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/MasterChef.sol   # Vulnerability details  ## Impact There is no functionality for removing pools/setting pool's allocPoints. Therefore `totalAllocPoint` only increases and rewards for pool decreases.  ## Proof of Concept Scenario: 1. Owner adds new pool (first pool) for staking with points = 900 (totalAllocPoint=900). 2. 1 week passes 3. First pool staking period ends (or for other reasons that pool is not meaningfully anymore). 4. Owner adds new pool (second pool) for staking with points = 100 (totalAllocPoint=1000) 5. 1 block later Alice stake 10 tokens there (at the same time). 6. 1 week passes 7. After some time Alice claims rewards. But she is eligible only for 10% of the rewards. 90% goes to unused pool.  ## Tools Used Manual review  ## Recommended Mitigation Steps Add functionality for removing pool or functionality for setting pool's `totalAllocPoint` param.  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/220", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-02-concur-findings", "body": "QA Report"}, {"title": "Wrong reward token calculation in MasterChef contract", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/219", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-02-concur-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/MasterChef.sol#L86   # Vulnerability details  ## Impact When adding new token pool for staking in MasterChef contract ```javascript function add(address _token, uint _allocationPoints, uint16 _depositFee, uint _startBlock) ``` All other, already added, pools should be updated but currently they are not. Instead, only totalPoints is updated. Therefore, old (and not updated) pools will lose it's share during the next update. Therefore, user rewards are not computed correctly (will be always smaller).  ## Proof of Concept Scenario 1: 1. Owner adds new pool (first pool) for staking with points = 100 (totalPoints=100)    and 1 block later Alice stakes 10 tokens in the first pool. 2. 1 week passes 3. Alice withdraws her 10 tokens and claims X amount of reward tokens.    and 1 block later Bob stakes 10 tokens in the first pool. 4. 1 week passes 5. Owner adds new pool (second pool) for staking with points = 100 (totalPoints=200)    and 1 block later Bob withdraws his 10 tokens and claims X/2 amount of reward tokens.    But he should get X amount  Scenario 2: 1. Owner adds new pool (first pool) for staking with points = 100 (totalPoints=100). 2. 1 block later Alice, Bob and Charlie stake 10 tokens there (at the same time). 3. 1 week passes 4. Owner adds new pool (second pool) for staking with points = 400 (totalPoints=500) 5. Right after that, when Alice, Bob or Charlie wants to withdraw tokens and claim rewards they will only be able to claim 20% of what they should be eligible for, because their pool is updated with 20% (100/500) rewards instead of 100% (100/100) rewards for the past week.  ## Tools Used Manual review  ## Recommended Mitigation Steps Update all existing pools before adding new pool. Use the massUdpate() function which is already present ... but unused.  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/218", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-concur-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/217", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-02-concur-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/216", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-concur-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/215", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-02-concur-findings", "body": "QA Report"}, {"title": "[WP-M17] `USDMPegRecovery.sol#withdraw()` withdraw may often fail", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/212", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-02-concur-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/USDMPegRecovery.sol#L110-L128   # Vulnerability details  Per the doc:  > USDM deposits are locked based on the KPI\u2019s from carrot.eth.  > 3Crv deposits are not locked.  https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/USDMPegRecovery.sol#L110-L128  ```solidity function withdraw(Liquidity calldata _withdrawal) external {         Liquidity memory total = totalLiquidity;         Liquidity memory user = userLiquidity[msg.sender];         if(_withdrawal.usdm > 0) {             require(unlockable, \"!unlock usdm\");             usdm.safeTransfer(msg.sender, uint256(_withdrawal.usdm));             total.usdm -= _withdrawal.usdm;             user.usdm -= _withdrawal.usdm;         }          if(_withdrawal.pool3 > 0) {             pool3.safeTransfer(msg.sender, uint256(_withdrawal.pool3));             total.pool3 -= _withdrawal.pool3;             user.pool3 -= _withdrawal.pool3;         }         totalLiquidity = total;         userLiquidity[msg.sender] = user;         emit Withdraw(msg.sender, _withdrawal);     } ```  However, because the `withdraw()` function takes funds from the balance of the contract, once the majority of the funds are added to the curve pool via `provide()`. The `withdraw()` may often fail due to insufficient funds in the balance.  ### PoC  1. Alice deposits `4M` USDM and `4M` pool3 tokens; 2. Guardian calls `provide()` and all the `usdm` and `pool3` to `usdm3crv`; 3. Alice calls `withdraw()`, the tx will fail, due to insufficient balance.  ### Recommendation  Consider calling `usdm3crv.remove_liquidity_one_coin()`  when the balance is insufficient for the user's withdrawal.  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/211", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-concur-findings", "body": "Gas Optimizations"}, {"title": "[WP-H29] `StakingRewards.sol` `recoverERC20()` can be used as a backdoor by the `owner` to retrieve `rewardsToken`", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/210", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-02-concur-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/StakingRewards.sol#L166-L176   # Vulnerability details  https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/StakingRewards.sol#L166-L176  ```solidity     function recoverERC20(address tokenAddress, uint256 tokenAmount)         external         onlyOwner     {         require(             tokenAddress != address(stakingToken),             \"Cannot withdraw the staking token\"         );         IERC20(tokenAddress).safeTransfer(owner(), tokenAmount);         emit Recovered(tokenAddress, tokenAmount);     } ```  ### Impact  Users can lose all the rewards to the malicious/compromised `owner`.  ### Recommendation  Change to:  ```solidity  function recoverERC20(     address tokenAddress,     address to,     uint256 amount ) external onlyOwner {     require(tokenAddress != address(stakingToken) && tokenAddress != address(rewardsToken), \"20\");      IERC20(tokenAddress).safeTransfer(to, amount);     emit Recovered(tokenAddress, to, amount); } ```  "}, {"title": "[WP-H28] `StakingRewards.sol#notifyRewardAmount()` Improper reward balance checks can make some users unable to withdraw their rewards", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/209", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-02-concur-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/StakingRewards.sol#L154-L158   # Vulnerability details  https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/StakingRewards.sol#L154-L158  ```solidity     uint256 balance = rewardsToken.balanceOf(address(this));     require(         rewardRate <= balance / rewardsDuration,         \"Provided reward too high\"     ); ```  In the current implementation, the contract only checks if balanceOf `rewardsToken` is greater than or equal to the future rewards.  However, under normal circumstances, since users can not withdraw all their rewards in time, the balance in the contract contains rewards that belong to the users but have not been withdrawn yet. This means the current checks can not be sufficient enough to make sure the contract has enough amount of rewardsToken.  As a result, if the `rewardsDistribution` mistakenly `notifyRewardAmount` with a larger amount, the contract may end up in a wrong state that makes some users unable to claim their rewards.  ### PoC  Given:  - rewardsDuration = 7 days;  1. Alice stakes `1,000` stakingToken; 2. `rewardsDistribution` sends `100` rewardsToken to the contract; 3. `rewardsDistribution` calls `notifyRewardAmount()` with `amount` = `100`; 4. 7 days later, Alice calls `earned()` and it returns `100` rewardsToken, but Alice choose not to `getReward()` for now; 5. `rewardsDistribution` calls `notifyRewardAmount()` with `amount` = `100` without send any fund to contract, the tx will succees; 6. 7 days later, Alice calls `earned()` `200` rewardsToken, when Alice tries to call `getReward()`, the transaction will fail due to insufficient balance of rewardsToken.  Expected Results:  The tx in step 5 should revert.  ### Recommendation  Consider changing the function `notifyRewardAmount` to `addRward` and use `transferFrom` to transfer rewardsToken into the contract:  ```solidity function addRward(uint256 reward)     external     updateReward(address(0)) {     require(         msg.sender == rewardsDistribution,         \"Caller is not RewardsDistribution contract\"     );      if (block.timestamp >= periodFinish) {         rewardRate = reward / rewardsDuration;     } else {         uint256 remaining = periodFinish - block.timestamp;         uint256 leftover = remaining * rewardRate;         rewardRate = (reward + leftover) / rewardsDuration;     }      rewardsToken.safeTransferFrom(msg.sender, address(this), reward);      lastUpdateTime = block.timestamp;     periodFinish = block.timestamp + rewardsDuration;     emit RewardAdded(reward); } ```  "}, {"title": "[WP-H16]  `MasterChef.sol` A `depositor` can deposit an arbitrary amount without no cost", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/208", "labels": ["bug", "2 (Med Risk)", "sponsor disputed"], "target": "2022-02-concur-findings", "body": "[WP-H16]  `MasterChef.sol` A `depositor` can deposit an arbitrary amount without no cost"}, {"title": "[WP-H14] `ConvexStakingWrapper`, `StakingRewards` Wrong implementation will send `concur` rewards to the wrong receiver", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/205", "labels": ["bug", "3 (High Risk)"], "target": "2022-02-concur-findings", "body": "[WP-H14] `ConvexStakingWrapper`, `StakingRewards` Wrong implementation will send `concur` rewards to the wrong receiver"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/203", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-concur-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/202", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-02-concur-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/201", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-02-concur-findings", "body": "QA Report"}, {"title": "[WP-H13] `MasterChef.sol` Users won't be able to receive the `concur` rewards", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/200", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-02-concur-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/MasterChef.sol#L135-L154   # Vulnerability details  According to:  -   README https://github.com/code-423n4/2022-02-concur#-masterchef -   Implementation of `deposit()`: [/contracts/MasterChef.sol#L157-L180](https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/MasterChef.sol#L157-L180)  MasterChef is only recording the deposited amount in the states, it's not actually holding the `depositToken`.  `depositToken` won't be transferred from `_msgSender()` to the MasterChef contract.  Therefore, in `updatePool()` L140 `lpSupply = pool.depositToken.balanceOf(address(this))` will always be `0`. And the `updatePool()` will be returned at L147.  https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/MasterChef.sol#L135-L154  ```solidity function updatePool(uint _pid) public {     PoolInfo storage pool = poolInfo[_pid];     if (block.number <= pool.lastRewardBlock) {         return;     }     uint lpSupply = pool.depositToken.balanceOf(address(this));     if (lpSupply == 0 || pool.allocPoint == 0) {         pool.lastRewardBlock = block.number;         return;     }     if(block.number >= endBlock) {         pool.lastRewardBlock = block.number;         return;     }              uint multiplier = getMultiplier(pool.lastRewardBlock, block.number);     uint concurReward = multiplier.mul(concurPerBlock).mul(pool.allocPoint).div(totalAllocPoint);     pool.accConcurPerShare = pool.accConcurPerShare.add(concurReward.mul(_concurShareMultiplier).div(lpSupply));     pool.lastRewardBlock = block.number; } ```   ### Impact  - The MasterChef contract fail to implement the most essential function; - Users won't be able to receive any `Concur` rewards from MasterChef;  ### Recommendation  Consider creating a receipt token to represent the invested token and use the receipt tokens in MasterChef.  See: https://github.com/convex-eth/platform/blob/883ffd4ebcaee12e64d18f75bdfe404bcd900616/contracts/contracts/Booster.sol#L272-L277  "}, {"title": "[WP-H8] `ConvexStakingWrapper.sol#_calcRewardIntegral` Wrong implementation can disrupt rewards calculation and distribution", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/199", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-02-concur-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/ConvexStakingWrapper.sol#L175-L204   # Vulnerability details  https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/ConvexStakingWrapper.sol#L175-L204  ```solidity     uint256 bal = IERC20(reward.token).balanceOf(address(this));     uint256 d_reward = bal - reward.remaining;     // send 20 % of cvx / crv reward to treasury     if (reward.token == cvx || reward.token == crv) {         IERC20(reward.token).transfer(treasury, d_reward / 5);         d_reward = (d_reward * 4) / 5;     }     IERC20(reward.token).transfer(address(claimContract), d_reward);      if (_supply > 0 && d_reward > 0) {         reward.integral =             reward.integral +             uint128((d_reward * 1e20) / _supply);     }      //update user integrals     uint256 userI = userReward[_pid][_index][_account].integral;     if (userI < reward.integral) {         userReward[_pid][_index][_account].integral = reward.integral;         claimContract.pushReward(             _account,             reward.token,             (_balance * (reward.integral - userI)) / 1e20         );     }      //update remaining reward here since balance could have changed if claiming     if (bal != reward.remaining) {         reward.remaining = uint128(bal);     } ```  The problems in the current implementation:  - `reward.remaining` is not a global state; the `reward.remaining` of other `reward`s with the same rewardToken are not updated; - `bal` should be refreshed before `reward.remaining = uint128(bal);`; - L175 should not use `balanceOf` but take the diff before and after `getReward()`.  ### PoC  - convexPool[1] is incentivized with CRV as the reward token, `1000 lpToken` can get `10 CRV` per day; - convexPool[2] is incentivized with CRV as the reward token, `1000 lpToken` can get `20 CRV` per day.  1. Alice deposits `1,000` lpToken to `_pid` = `1` 2. 1 day later, Alice deposits `500` lpToken to `_pid` = `1`   - convexPool `getReward()` sends `10 CRV` as reward to contract - `d_reward` = 10, `2 CRV` sends to `treasury`, `8 CRV` send to `claimContract` - `rewards[1][0].remaining` = 10  3. 0.5 day later, Alice deposits `500` lpToken to `_pid` = `1`, and the tx will fail:  - convexPool `getReward()` sends `7.5 CRV` as reward to contract - `reward.remaining` = 10 - `bal` = 7.5 - `bal - reward.remaining` will fail due to underflow  4. 0.5 day later, Alice deposits `500` lpToken to `_pid` = `1`, most of the reward tokens will be left in the contract:  - convexPool `getReward()` sends `15 CRV` as reward to the contract; - `d_reward = bal - reward.remaining` = 5 - `1 CRV` got sent to `treasury`, `4 CRV` sent to `claimContract`, `10 CRV` left in the contract; - `rewards[1][0].remaining` = 15  Expected Results:  All the `15 CRV` get distributed: `3 CRV` to the `treasury`, and `12 CRV` to `claimContract`.  Actual Results:  Only `5 CRV` got distributed. The other `10 CRV` got left in the contract which can be frozen in the contract, see below for the details:  5. Bob deposits `1,000` lpToken to `_pid` = `2`  - convexPool `getReward()` sends `0 CRV` as reward to the contract - `d_reward = bal - reward.remaining` = 10 - `2 CRV` sent to `treasury`, `8 CRV` sent to `claimContract` without calling `pushReward()`, so the `8 CRV` are now frozen in `claimContract`; - `rewards[2][0].remaining` = 10  ### Impact  - The two most important methods: `deposit()` and `withdraw()` will frequently fail as the tx will revert at `_calcRewardIntegral()`; - Rewards distributed to users can often be fewer than expected; - If there are different pools that use the same token as rewards, part of the rewards can be frozen at `claimContract` and no one can claim them.  ### Recommendation  Consider comparing the `balanceOf` reward token before and after `getReward()` to get the actual rewarded amount, and `reward.remaining` should be removed.  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/198", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-02-concur-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/197", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-02-concur-findings", "body": "QA Report"}, {"title": "[WP-H2] `ConvexStakingWrapper#deposit()` depositors may lose their funds when the `_amount` is huge", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/194", "labels": ["bug", "duplicate", "2 (Med Risk)"], "target": "2022-02-concur-findings", "body": "[WP-H2] `ConvexStakingWrapper#deposit()` depositors may lose their funds when the `_amount` is huge"}, {"title": "[WP-H1] Rewards distribution can be disrupted by a early user", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/193", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-02-concur-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/02d286253cd5570d4e595527618366f77627cdaf/contracts/ConvexStakingWrapper.sol#L184-L188   # Vulnerability details  https://github.com/code-423n4/2022-02-concur/blob/02d286253cd5570d4e595527618366f77627cdaf/contracts/ConvexStakingWrapper.sol#L184-L188  ```solidity if (_supply > 0 && d_reward > 0) {     reward.integral =         reward.integral +         uint128((d_reward * 1e20) / _supply); } ```  `reward.integral` is `uint128`, if an early user deposits with just `1` Wei of `lpToken`, and make `_supply == 1`, and then transferring `5e18` of `reward_token` to the contract.  As a result, `reward.integral` can exceed `type(uint128).max` and overflow, causing the rewards distribution to be disrupted.  ### Recommendation  Consider `wrap` a certain amount of initial totalSupply at deployment, e.g. `1e8`, and never burn it. And consider using uint256 instead of uint128 for `reward.integral`. Also, consdier lower `1e20` down to `1e12`.  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/192", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-concur-findings", "body": "Gas Optimizations"}, {"title": "[WP-M0] `USDMPegRecovery.sol#provide()` Improper design/implementation make it often unable to add liquidity to the `usdm3crv` pool", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/191", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-02-concur-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/02d286253cd5570d4e595527618366f77627cdaf/contracts/USDMPegRecovery.sol#L73-L82   # Vulnerability details  https://github.com/code-423n4/2022-02-concur/blob/02d286253cd5570d4e595527618366f77627cdaf/contracts/USDMPegRecovery.sol#L73-L82  ```solidity function provide(uint256 _minimumLP) external onlyGuardian {     require(usdm.balanceOf(address(this)) >= totalLiquidity.usdm, \"<liquidity\");     // truncate amounts under step     uint256 addingLiquidity = (usdm.balanceOf(address(this)) / step) * step;     // match usdm : pool3 = 1 : 1     uint256[2] memory amounts = [addingLiquidity, addingLiquidity];     usdm.approve(address(usdm3crv), addingLiquidity);     pool3.approve(address(usdm3crv), addingLiquidity);     usdm3crv.add_liquidity(amounts, _minimumLP); } ```  In the current implementation of `USDMPegRecovery.sol#provide()`, `addingLiquidity` is calculated solely based on `usdm` balance (truncate at a step of 250k), and it always uses the same amount of 3pool tokens to add_liquidity with.  Based on other functions of the contract, the balance of `usdm` can usually be more than the `pool3` balance, in that case, `usdm3crv.add_liquidity()` will fail.  ### Impact  When the balance of `pool3` is less than `usdm` (which is can be a common scenario), funds cannot be added to the curve pool.  For example:  When the contract got 5M of USDM and 4.2M of `pool3` tokens, it won't be possible to call `provide()` and add liquidity to the `usdm3crv` pool, as there are not enough pool3 tokens to match the 5M of USDM yet.  We expect it to add liquidity with 4M of USDM and 4M of pool3 tokens in that case.  ### Recommendation  Change to:  ```solidity function provide(uint256 _minimumLP) external onlyGuardian {     require(usdm.balanceOf(address(this)) >= totalLiquidity.usdm, \"<liquidity\");     uint256 tokenBalance = Math.min(usdm.balanceOf(address(this), pool3.balanceOf(address(this));     // truncate amounts under step     uint256 addingLiquidity = (tokenBalance / step) * step;     // match usdm : pool3 = 1 : 1     uint256[2] memory amounts = [addingLiquidity, addingLiquidity];     usdm.approve(address(usdm3crv), addingLiquidity);     pool3.approve(address(usdm3crv), addingLiquidity);     usdm3crv.add_liquidity(amounts, _minimumLP); } ```  "}, {"title": "USDM locked unless guardian remove liquidity", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/187", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-02-concur-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/USDMPegRecovery.sol#L90   # Vulnerability details  ## Impact In README.me: > USDM deposits are locked based on the KPI\u2019s from carrot.eth  However, USDM deposits are also locked until guardian remove liquidity because there are no mechanism to remove deposited USDM in `withdraw`  https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/USDMPegRecovery.sol#L90  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/186", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-02-concur-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/185", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-concur-findings", "body": "Gas Optimizations"}, {"title": "`StakingRewards` reward rate can be dragged out and diluted", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/183", "labels": ["bug", "2 (Med Risk)", "sponsor disputed"], "target": "2022-02-concur-findings", "body": "`StakingRewards` reward rate can be dragged out and diluted"}, {"title": "Fee-on-transfer token donations in `Shelter` break withdrawals", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/180", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-02-concur-findings", "body": "Fee-on-transfer token donations in `Shelter` break withdrawals"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/174", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-02-concur-findings", "body": "QA Report"}, {"title": "Donated Tokens Cannot Be Recovered If A Shelter Is Deactivated", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/173", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-02-concur-findings", "body": "Donated Tokens Cannot Be Recovered If A Shelter Is Deactivated"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/171", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-02-concur-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/169", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-concur-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/168", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-concur-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/167", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-concur-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/164", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-concur-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/163", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-02-concur-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/161", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-02-concur-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/154", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-concur-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/153", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-02-concur-findings", "body": "QA Report"}, {"title": "`ConvexStakingWrapper._calcRewardIntegral()` Can Be Manipulated To Steal Tokens From Other Pools", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/146", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-02-concur-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/shelter-client/contracts/ConvexStakingWrapper.sol#L216-L259   # Vulnerability details  ## Impact  The `ConvexStakingWrapper.sol` implementation makes several modifications to the original design. One of the key changes is the ability to add multiple pools into the wrapper contract, where each pool is represented by a unique `_pid`. By doing this, we are able to aggregate pools and their LP tokens to simplify the token distribution process.   However, the interdependence between pools introduces new problems. Because the original implementation uses the contract's reward token balance to track newly claimed tokens, it is possible for a malicious user to abuse the unguarded `getReward` function to maximise the profit they are able to generate. By calling `getReward` on multiple pools with the same reward token (i.e. `cvx`), users are able to siphon rewards from other pools. This inevitably leads to certain loss of rewards for users who have deposited LP tokens into these victim pools. As `crv` and `cvx` are reward tokens by default, it is very likely that someone will want to exploit this issue.  ## Proof of Concept  Let's consider the following scenario: - There are two convex pools with `_pid` 0 and 1. - Both pools currently only distribute `cvx` tokens. - Alice deposits LP tokens into the pool with `_pid` 0. - Both pools earn 100 `cvx` tokens which are to be distributed to the holders of the two pools. - While Alice is a sole staker of the pool with `_pid` 0, the pool with `_pid` 1 has several stakers. -  Alice decides she wants to maximise her potential rewards, so she directly calls the unguarded `IRewardStaking(convexPool[_pid]).getReward` function on both pools, resulting in 200 `cvx` tokens being sent to the contract. - She then decides to deposit the 0 amount to execute the `_calcRewardIntegral` function on the pool with `_pid` 0. However, this function will calculate `d_reward` as `bal - reward.remaining` which is effectively the change in contract balance. As we have directly claimed `cvx` tokens over the two pools, this `d_reward` will be equal to 200. - Alice is then entitled to the entire 200 tokens as she is the sole staker of her pool. So instead of receiving 100 tokens, she is able to siphon rewards from other pools.  Altogether, this will lead to the loss of rewards for other stakers as they are unable to then claim their rewards.  https://github.com/code-423n4/2022-02-concur/blob/shelter-client/contracts/ConvexStakingWrapper.sol#L216-L259 ``` function _calcRewardIntegral(     uint256 _pid,     uint256 _index,     address _account,     uint256 _balance,     uint256 _supply ) internal {     RewardType memory reward = rewards[_pid][_index];      //get difference in balance and remaining rewards     //getReward is unguarded so we use remaining to keep track of how much was actually claimed     uint256 bal = IERC20(reward.token).balanceOf(address(this));     uint256 d_reward = bal - reward.remaining;     // send 20 % of cvx / crv reward to treasury     if (reward.token == cvx || reward.token == crv) {         IERC20(reward.token).transfer(treasury, d_reward / 5);         d_reward = (d_reward * 4) / 5;     }     IERC20(reward.token).transfer(address(claimContract), d_reward);      if (_supply > 0 && d_reward > 0) {         reward.integral =             reward.integral +             uint128((d_reward * 1e20) / _supply);     }      //update user integrals     uint256 userI = userReward[_pid][_index][_account].integral;     if (userI < reward.integral) {         userReward[_pid][_index][_account].integral = reward.integral;         claimContract.pushReward(             _account,             reward.token,             (_balance * (reward.integral - userI)) / 1e20         );     }      //update remaining reward here since balance could have changed if claiming     if (bal != reward.remaining) {         reward.remaining = uint128(bal);     }      rewards[_pid][_index] = reward; } ```  ## Tools Used  Manual code review. Confirmation from Taek.  ## Recommended Mitigation Steps  Consider redesigning this mechanism such that all pools have their `getReward` function called in `_checkpoint`. The `_calcRewardIntegral` function can then ensure that each pool is allocated only a fraction of the total rewards instead of the change in contract balance. Other implementations might be more ideal, so it is important that careful consideration is taken when making these changes.  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/145", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-02-concur-findings", "body": "QA Report"}, {"title": "`ConvexStakingWrapper.exitShelter()` Will Lock LP Tokens, Preventing Users From Withdrawing", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/144", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-02-concur-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/shelter-client/contracts/ConvexStakingWrapper.sol#L121-L130 https://github.com/code-423n4/2022-02-concur/blob/shelter-client/contracts/ConvexStakingWrapper.sol#L309-L331   # Vulnerability details  ## Impact  The shelter mechanism provides emergency functionality in an effort to protect users' funds. The `enterShelter` function will withdraw all LP tokens from the pool, transfer them to the shelter contract and activate the shelter for the target LP token. Conversely, the `exitShelter` function will deactivate the shelter and transfer all LP tokens back to the `ConvexStakingWrapper.sol` contract.  Unfortunately, LP tokens aren't restaked in the pool, causing LP tokens to be stuck within the contract. Users will be unable to withdraw their LP tokens as the `withdraw` function attempts to `withdrawAndUnwrap` LP tokens from the staking pool. As a result, this function will always revert due to insufficient staked balance. If other users decide to deposit their LP tokens, then these tokens can be swiped by users who have had their LP tokens locked in the contract.  This guarantees poor UX for the protocol and will most definitely lead to LP token loss.  ## Proof of Concept  https://github.com/code-423n4/2022-02-concur/blob/shelter-client/contracts/ConvexStakingWrapper.sol#L121-L130 ``` function exitShelter(uint256[] calldata _pids) external onlyOwner {     for(uint256 i = 0; i<_pids.length; i++){         IRewardStaking pool = IRewardStaking(convexPool[_pids[i]]);         IERC20 lpToken = IERC20(             pool.poolInfo(_pids[i]).lptoken         );         amountInShelter[lpToken] = 0;         shelter.deactivate(lpToken);     } } ```  https://github.com/code-423n4/2022-02-concur/blob/shelter-client/contracts/ConvexStakingWrapper.sol#L309-L331 ``` function withdraw(uint256 _pid, uint256 _amount)     external     nonReentrant     whenNotInShelter(_pid) {     WithdrawRequest memory request = withdrawRequest[_pid][msg.sender];     require(request.epoch < currentEpoch() && deposits[_pid][msg.sender].epoch + 1 < currentEpoch(), \"wait\");     require(request.amount >= _amount, \"too much\");     _checkpoint(_pid, msg.sender);     deposits[_pid][msg.sender].amount -= uint192(_amount);     if (_amount > 0) {         IRewardStaking(convexPool[_pid]).withdrawAndUnwrap(_amount, false);         IERC20 lpToken = IERC20(             IRewardStaking(convexPool[_pid]).poolInfo(_pid).lptoken         );         lpToken.safeTransfer(msg.sender, _amount);         uint256 pid = masterChef.pid(address(lpToken));         masterChef.withdraw(msg.sender, pid, _amount);     }     delete withdrawRequest[_pid][msg.sender];     //events     emit Withdrawn(msg.sender, _amount); } ```  ## Tools Used  Manual code review. Confirmation from Taek.  ## Recommended Mitigation Steps  Consider re-depositing LP tokens upon calling `exitShelter`. This should ensure the same tokens can be reclaimed by users wishing to exit the `ConvexStakingWrapper.sol` contract.  "}, {"title": "Masterchef: Improper handling of deposit fee", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/138", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-02-concur-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/MasterChef.sol#L170-L172   # Vulnerability details  ## Impact  If a pool\u2019s deposit fee is non-zero, it is subtracted from the amount to be credited to the user.  ```jsx if (pool.depositFeeBP > 0) {   uint depositFee = _amount.mul(pool.depositFeeBP).div(_perMille);   user.amount = SafeCast.toUint128(user.amount + _amount - depositFee); } ```  However, the deposit fee is not credited to anyone, leading to permanent lockups of deposit fees in the relevant depositor contracts (StakingRewards and ConvexStakingWrapper for now).  ## Proof of Concept  ### Example 1: ConvexStakingWrapper  Assume the following  - The [curve cDai / cUSDC / cUSDT LP token](https://etherscan.io/address/0x9fC689CCaDa600B6DF723D9E47D84d76664a1F23) corresponds to `pid = 1` in the convex booster contract. - Pool is added in Masterchef with `depositFeeBP = 100 (10%)`. 1. Alice deposits 1000 LP tokens via the ConvexStakingWrapper contract. A deposit fee of 100 LP tokens is charged. Note that the `deposits` mapping of the ConvexStakingWrapper contract credits 1000 LP tokens to her. 2. However, Alice will only be able to withdraw 900 LP tokens. The 100 LP tokens is not credited to any party, and is therefore locked up permanently (essentially becomes protocol-owned liquidity). While she is able to do `requestWithdraw()` for 1000 LP tokens, attempts to execute `withdraw()` with amount = 1000 will revert because she is only credited 900 LP tokens in the Masterchef contract.  ### Example 2: StakingRewards  - CRV pool is added in Masterchef with `depositFeeBP = 100 (10%)`. 1. Alice deposits 1000 CRV into the StakingRewards contract. A deposit fee of 100 CRV is charged. 2. Alice is only able to withdraw 900 CRV tokens, while the 100 CRV is not credited to any party, and is therefore locked up permanently.  These examples are non-exhaustive as more depositors can be added / removed from the Masterchef contract.  ## Recommended Mitigation Steps  I recommend shifting the deposit fee logic out of the masterchef contract into the depositor contracts themselves, as additional logic would have to be added in the masterchef to update the fee recipient\u2019s state (rewardDebt, send pending concur rewards, update amount), which further complicates matters. As the fee recipient is likely to be the treasury, it is also not desirable for it to accrue concur rewards.  ```jsx if (pool.depositFeeBP > 0) {   uint depositFee = _amount.mul(pool.depositFeeBP).div(_perMille);   user.amount = SafeCast.toUint128(user.amount + _amount - depositFee);   UserInfo storage feeRecipient = userInfo[_pid][feeRecipient];   // TODO: update and send feeRecipient pending concur rewards   feeRecipient.amount = SafeCast.toUint128(feeRecipient.amount + depositFee);   // TODO: update fee recipient's rewardDebt } ```  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/129", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-concur-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/128", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-02-concur-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/127", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-02-concur-findings", "body": "QA Report"}, {"title": "Transfer to treasury can register as succeeded when failing in `_calcRewardIntegral`", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/120", "labels": ["bug", "duplicate", "2 (Med Risk)"], "target": "2022-02-concur-findings", "body": "Transfer to treasury can register as succeeded when failing in `_calcRewardIntegral`"}, {"title": "If The Staking Token Exists In Both `StakingRewards.sol` And `ConvexStakingWrapper.sol` Then It Will Be Possible To Continue Claiming Concur Rewards After The Shelter Has Been Activated", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/117", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-02-concur-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/shelter-client/contracts/ConvexStakingWrapper.sol https://github.com/code-423n4/2022-02-concur/blob/shelter-client/contracts/MasterChef.sol https://github.com/code-423n4/2022-02-concur/blob/shelter-client/contracts/StakingRewards.sol   # Vulnerability details  ## Impact  Staking tokens are used to deposit into the `StakingRewards.sol` and `ConvexStakingWrapper.sol` contracts. Once deposited, the user is entitled to Concur rewards in proportion to their staked balance and the underlying pool's `allocPoint` in the `MasterChef.sol` contract.  The `Shelter.sol` mechanism allows the owner of the `ConvexStakingWrapper.sol` to react to emergency events and protect depositor's assets. The staking tokens can be withdrawn after the grace period has passed. However, these staking tokens can be deposited into the `StakingRewards.sol` contract to continue receiving Concur rewards not only for `StakingRewards.sol` but also for their `ConvexStakingWrapper.sol` deposited balance which has not been wiped. As a result, users are able to effectively claim double the amount of Concur rewards they should be receiving.  ## Proof of Concept  https://github.com/code-423n4/2022-02-concur/blob/shelter-client/contracts/MasterChef.sol  https://github.com/code-423n4/2022-02-concur/blob/shelter-client/contracts/StakingRewards.sol  https://github.com/code-423n4/2022-02-concur/blob/shelter-client/contracts/ConvexStakingWrapper.sol  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Ensure that staking tokens cannot be deposited in both the `StakingRewards.sol` and `ConvexStakingWrapper.sol` contracts. If this is intended behaviour, it may be worthwhile to ensure that the sheltered users have their deposited balance wiped from the `MasterChef.sol` contract upon being sheltered.  "}, {"title": "Users Will Lose Concur Rewards If The Shelter Mechanism Is Enacted On A Pool", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/116", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-02-concur-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/shelter-client/contracts/ConvexStakingWrapper.sol https://github.com/code-423n4/2022-02-concur/blob/shelter-client/contracts/MasterChef.sol   # Vulnerability details  ## Impact  The shelter mechanism aims to protect the protocol's users by draining funds into a separate contract in the event of an emergency. However, while users are able to reclaim their funds through the `Shelter.sol` contract, they will still have a deposited balance from the perspective of `ConvexStakingWrapper.sol`.  However, if the shelter mechanism is enacted before users are able to claim their Concur rewards, any accrued tokens will be lost and the `MasterChef.sol` contract will continue to allocate tokens to the sheltered pool which will be forever locked within this contract.  There is currently no way to remove sheltered pools from the `MasterChef.sol` contract, hence any balance lost in the contract cannot be recovered due to a lack of a sweep mechanism which can be called by the contract owner.  ## Proof of Concept  https://github.com/code-423n4/2022-02-concur/blob/shelter-client/contracts/ConvexStakingWrapper.sol  https://github.com/code-423n4/2022-02-concur/blob/shelter-client/contracts/MasterChef.sol  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider removing sheltered pools from the `MasterChef.sol` Concur token distribution. It is important to ensure `massUpdatePools` is called before making any changes to the list of pools. Additionally, removing pools from this list may also create issues with how `_pid` is produced on each new pool. Therefore, it may be worthwhile to rethink this mechanism such that `_pid` tracks some counter variable and not `poolInfo.length - 1`.  "}, {"title": "Users Will Lose Rewards If The Shelter Mechanism Is Enacted Before A Recent Checkpoint", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/115", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-02-concur-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/shelter-client/contracts/ConvexStakingWrapper.sol   # Vulnerability details  ## Impact  The shelter mechanism aims to protect the protocol's users by draining funds into a separate contract in the event of an emergency. However, while users are able to reclaim their funds through the `Shelter.sol` contract, they will still have a deposited balance from the perspective of `ConvexStakingWrapper.sol`.  Because users will only receive their rewards upon depositing/withdrawing their funds due to how the checkpointing mechanism works, it is likely that by draining funds to the `Shelter.sol` contract, users will lose out on any rewards they had accrued up and until that point. These rewards are unrecoverable and can potentially be locked within the contract if the reward token is unique and only belongs to the sheltered `_pid`.  ## Proof of Concept  https://github.com/code-423n4/2022-02-concur/blob/shelter-client/contracts/ConvexStakingWrapper.sol  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider allowing users to call a public facing `_checkpoint` function once their funds have been drained to the `Shelter.sol` contract. This should ensure they receive their fair share of rewards. Careful consideration needs to be made when designing this mechanism, as by giving users full control of the `_checkpoint` function may allow them to continue receiving rewards after they have withdrawn their LP tokens.  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/110", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-concur-findings", "body": "Gas Optimizations"}, {"title": "`ConvexStakingWrapper.enterShelter()` May Erroneously Overwrite `amountInShelter` Leading To Locked Tokens", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/109", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-02-concur-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/shelter-client/contracts/ConvexStakingWrapper.sol#L107-L119 https://github.com/code-423n4/2022-02-concur/blob/shelter-client/contracts/ConvexStakingWrapper.sol#L132-L135   # Vulnerability details  ## Impact  The shelter mechanism provides emergency functionality in an effort to protect users' funds. The `enterShelter` function will withdraw all LP tokens from the pool, transfer them to the shelter contract and activate the shelter for the target LP token. If this function is called again on the same LP token, the `amountInShelter` value is overwritten, potentially by the zero amount. As a result  its possible that the shelter is put in a state where no users can withdraw from it or only a select few users with a finite number of shares are able to. Once the shelter has passed its grace period, these tokens may forever be locked in the shelter contract.  ## Proof of Concept  https://github.com/code-423n4/2022-02-concur/blob/shelter-client/contracts/ConvexStakingWrapper.sol#L107-L119 ``` function enterShelter(uint256[] calldata _pids) external onlyOwner {     for(uint256 i = 0; i<_pids.length; i++){         IRewardStaking pool = IRewardStaking(convexPool[_pids[i]]);         uint256 amount = pool.balanceOf(address(this));         pool.withdrawAndUnwrap(amount, false);         IERC20 lpToken = IERC20(             pool.poolInfo(_pids[i]).lptoken         );         amountInShelter[lpToken] = amount;         lpToken.safeTransfer(address(shelter), amount);         shelter.activate(lpToken);     } } ```  https://github.com/code-423n4/2022-02-concur/blob/shelter-client/contracts/ConvexStakingWrapper.sol#L132-L135 ``` function totalShare(IERC20 _token) external view override returns(uint256) {     // this will be zero if shelter is not activated     return amountInShelter[_token]; } ```  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider adding to the `amountInShelter[lpToken]` mapping instead of overwriting it altogether. This will allow `enterShelter` to be called multiple times with no loss of funds for the protocol's users.  "}, {"title": "`MasterChef.updatePool()` Fails To Update Reward Variables If `block.number >= endBlock`", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/107", "labels": ["bug", "2 (Med Risk)"], "target": "2022-02-concur-findings", "body": "`MasterChef.updatePool()` Fails To Update Reward Variables If `block.number >= endBlock`"}, {"title": "Shelter `claimed` mapping is set with `_to` address and not `msg.sender`", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/103", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-02-concur-findings", "body": "# Lines of code   https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/Shelter.sol#L55   # Vulnerability details  # Impact  Any user can withdraw all the funds from the shelter. This is done by calling withdraw repeatedly until all funds are drained. You only need to have a small share.  Even if the `claimed` mapping was checked, there would still be a vulnerability. This is because the `claimed` mapping is updated with the `_to` address, not the `msg.sender` address.  Remediation is to change the `_to` to `msg.sender`. https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/Shelter.sol#L55   "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/98", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-02-concur-findings", "body": "QA Report"}, {"title": "`USDMPegRecovery.provide()` Will Fail If There Is An Excess Of `usdm` Tokens", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/94", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-02-concur-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/USDMPegRecovery.sol#L73-L82   # Vulnerability details  ## Impact  The `provide` function does not take a `_steps` argument and will instead calculate `addingLiquidity` by truncating amounts under `step`. As a result, if there is an excess of `usdm` such that the truncated amount exceeds the contract's `pool3` truncated balance, then the function will revert due to insufficient `pool3` collateral.  This will prevent guardians from effectively providing liquidity whenever tokens are available. Consider the following example: - The contract has `500000e18` `usdm` tokens and `250000e18` `pool3` tokens. - `addingLiquidity` will be calculated as `500000e18 / 250000e18 * 250000e18`. - The function will attempt to add `500000e18` `usdm` and `pool3` tokens in which there are insufficient `pool3` tokens in the contract. As a result, it will revert even though there is an abundance of tokens that satisfy the `step` amount.  ## Proof of Concept  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/USDMPegRecovery.sol#L73-L82 ``` function provide(uint256 _minimumLP) external onlyGuardian {     require(usdm.balanceOf(address(this)) >= totalLiquidity.usdm, \"<liquidity\");     // truncate amounts under step     uint256 addingLiquidity = (usdm.balanceOf(address(this)) / step) * step;     // match usdm : pool3 = 1 : 1     uint256[2] memory amounts = [addingLiquidity, addingLiquidity];     usdm.approve(address(usdm3crv), addingLiquidity);     pool3.approve(address(usdm3crv), addingLiquidity);     usdm3crv.add_liquidity(amounts, _minimumLP); } ```  ## Tools Used  Manual code review. Discussions with Taek.  ## Recommended Mitigation Steps  Consider modifying the `provide` function such that a `_steps` argument can be supplied. This will allow guardians to maximise the amount of liquidity provided to the Curve pool.  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/91", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-concur-findings", "body": "Gas Optimizations"}, {"title": "[ConcurRewardPool] Possible reentrancy when claiming rewards", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/86", "labels": ["bug", "duplicate", "2 (Med Risk)"], "target": "2022-02-concur-findings", "body": "[ConcurRewardPool] Possible reentrancy when claiming rewards"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/85", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-02-concur-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/84", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-concur-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/80", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-02-concur-findings", "body": "QA Report"}, {"title": "Rogue pool in Shelter", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/74", "labels": ["bug", "2 (Med Risk)"], "target": "2022-02-concur-findings", "body": "Rogue pool in Shelter"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/73", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-concur-findings", "body": "Gas Optimizations"}, {"title": "USDMPegRecovery Risk of fund locked, due to discrepancy between curveLP token value against internal contract math", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/70", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-02-concur-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/USDMPegRecovery.sol#L90 https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/USDMPegRecovery.sol#L110 https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/USDMPegRecovery.sol#L73 https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/USDMPegRecovery.sol#L84   # Vulnerability details  ## Impact In `USDMPegRecovery` `deposit` and `withdraw` allow for direct deposits of a specific token (3crv or usdm)  The balances are directly changed and tracked in storage.  `provide` seems to be using the real balances (not the ones store) to provide liquidity. Because of how curve works, you'll be able (first deposit) to provide exactly matching liquidity.  But after (even just 1 or) multiple swaps, the pool will be slightly imbalanced, adding or removing liquidity at that point will drastically change the balances in the contract from the ones tracked in storage.  Eventually users won't be able to withdraw the exact amounts they deposited.  This will culminate with real balances not matching user deposits, sometimes to user advantage and other times to user disadvantage, ultimately to the protocol dismay.    ## Proof of Concept Deposit equal usdm and 3crv LP Do one trade on CRV Withdraw the LP  The real balances are not matching the balances in storage  User tries to withdraw all their balances, inevitable revert  ## Recommended Mitigation Steps Either find a way to price the user contribution based on the LP tokens (use virtual_price) Or simply have people deposit the LP token directly (avoiding the IL math which is a massive headache)  "}, {"title": "StakingRewards.recoverERC20 allows owner to rug the `rewardsToken`", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/69", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-02-concur-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/StakingRewards.sol#L166   # Vulnerability details  ## Impact `StakingRewards.recoverERC20` rightfully checks against the `stakingToken` being sweeped away. However there's no check against the `rewardsToken` which over time will sit in this contract.  This is the case of an admin privilege, which allows the owner to sweep the rewards tokens, perhaps as a way to rug depositors  ## Proof of Concept calling `StakingRewards.recoverERC20(rewardsToken, rewardsToken.balanceOf(this))` enables the `owner` to sweep the token  ## Recommended Mitigation Steps Add an additional check ```         require(             tokenAddress != address(rewardsToken),             \"Cannot withdraw the rewards token\"         ); ```  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/67", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-02-concur-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/66", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-02-concur-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/65", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-02-concur-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/63", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-02-concur-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/62", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-02-concur-findings", "body": "QA Report"}, {"title": "uint256 i = 0 in for loop. uint256 is default 0.", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/58", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-02-concur-findings", "body": "# Handle  kenta   # Vulnerability details  ## Impact The default value of uint256 is 0 and we do not initialize it and save a little bit of gas.   ## Proof of Concept https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L121  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L219  ## Tools Used  ## Recommended Mitigation Steps for (unit256 i; i < length; i++) {}  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/45", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-02-concur-findings", "body": "QA Report"}, {"title": "Gas Report", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/44", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-02-concur-findings", "body": "Handle:\r IllIllI\r \r Risk rating:\r Gas Optimizations\r \r Gas report: [See markdown file here](https://github.com/code-423n4/2022-02-badger-citadel-findings/blob/main/data/IllIllI_112.md)"}, {"title": "Gas Optimization report", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/41", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-concur-findings", "body": "Gas Optimization report"}, {"title": "add() in the MasterChef.sol contract is marked Public.", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/40", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-02-concur-findings", "body": "# Handle  0x510c   # Vulnerability details  ## Impact The function definition of \"add\" is marked \"public\". However, it is never directly called by another function in the same contract or in any of its descendants. Consider to mark it as \"external\" instead.  ## Proof of Concept  MasterChef.sol  function add(address _token, uint _allocationPoints, uint16 _depositFee, uint _startBlock) public onlyOwner {         require(_token != address(0), \"zero address\");         uint lastRewardBlock = block.number > _startBlock ? block.number : _startBlock;         totalAllocPoint = totalAllocPoint.add(_allocationPoints);         require(pid[_token] == 0, \"already registered\"); // pid starts from 0         poolInfo.push(             PoolInfo({                 depositToken: IERC20(_token),                 allocPoint: _allocationPoints,                 lastRewardBlock: lastRewardBlock,                 accConcurPerShare: 0,                 depositFeeBP: _depositFee             })         );         pid[_token] = poolInfo.length - 1;     }  ## Tools Used Manual Review  ## Recommended Mitigation Steps It recommended to change the visibility of the function to External to optimize the usage of gas.  "}, {"title": "Gas report", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/37", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-02-concur-findings", "body": "# Handle  wuwe1   # Vulnerability details  # Cache array length in for loops can save gas  ## POC > Caching the array length in the stack saves around 3 gas per iteration.  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConcurRewardPool.sol#L35  ```solidity function claimRewards(address[] calldata _tokens) external override {     for (uint256 i = 0; i < _tokens.length; i++) {         uint256 getting = reward[msg.sender][_tokens[i]];         IERC20(_tokens[i]).safeTransfer(msg.sender, getting);         reward[msg.sender][_tokens[i]] = 0;     } } ```  # Dead code  Remove dead code in  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/MasterChef.sol#L19  # public to external  These function can be external.  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L93  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/MasterChef.sol#L86  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/MasterChef.sol#L127  # state can be constant  These state variables can be constant  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/MasterChef.sol#L50  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/MasterChef.sol#L56  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/MasterChef.sol#L57  "}, {"title": "QA report", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/36", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-02-concur-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketOffer.sol#L150   # Vulnerability details  ## Impact In NFTMarketOffer.sol the adminCancelOffers() function has comments above it that mention   \"tokenIds The ids of the NFTs to cancel. This must be the same length as `nftContracts`\"  This means that both the tokensIds and nftContracts arrays must be the same length but this is not required in the code of the function itself which can lead to the function failing.   ## Proof of Concept https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketOffer.sol#L150  ## Tools Used Manual code review   ## Recommended Mitigation Steps Add to adminCancelOffers() function:   require(nftContracts.length == tokenIds.length, Arrays must be same length\");  "}, {"title": "deposit in ConvexStakingWrapper will most certainly revert", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/33", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-02-concur-findings", "body": "# Handle  wuwe1   # Vulnerability details  ## Proof of Concept https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L94-L99  ```solidity         address mainPool = IRewardStaking(convexBooster)             .poolInfo(_pid)             .crvRewards;         if (rewards[_pid].length == 0) {             pids[IRewardStaking(convexBooster).poolInfo(_pid).lptoken] = _pid;             convexPool[_pid] = mainPool; ```  `convexPool[_pid]` is set to `IRewardStaking(convexBooster).poolInfo(_pid).crvRewards;`  `crvRewards` is a `BaseRewardPool` like this one https://etherscan.io/address/0x8B55351ea358e5Eda371575B031ee24F462d503e#code.  `BaseRewardPool` does not implement `poolInfo`   https://github.com/code-423n4/2022-02-concur/blob/main/contracts/ConvexStakingWrapper.sol#L238  ```solidity IRewardStaking(convexPool[_pid]).poolInfo(_pid).lptoken ```  Above line calls `poolInfo` of  `crvRewards` which causes revert.  ## Recommended Mitigation Steps  According to Booster's code   https://etherscan.io/address/0xF403C135812408BFbE8713b5A23a04b3D48AAE31#code  ```solidity     //deposit lp tokens and stake     function deposit(uint256 _pid, uint256 _amount, bool _stake) public returns(bool){         require(!isShutdown,\"shutdown\");         PoolInfo storage pool = poolInfo[_pid];         require(pool.shutdown == false, \"pool is closed\");          //send to proxy to stake         address lptoken = pool.lptoken;         IERC20(lptoken).safeTransferFrom(msg.sender, staker, _amount); ```  `convexBooster` requires `poolInfo[_pid].lptoken`.  change L238 to   ```solidity IRewardStaking(convexBooster).poolInfo(_pid).lptoken ```  "}, {"title": "Deactivate function can be bypassed", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/28", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-02-concur-findings", "body": "# Handle  csanuragjain   # Vulnerability details  ## Impact onlyClient can deactivate a token even after deadline is passed and transfer all token balance to itself  ## Proof of Concept 1. Navigate to contract at https://github.com/code-423n4/2022-02-concur/blob/main/contracts/Shelter.sol  2. Observe that token can only be deactivated if activated[_token] + GRACE_PERIOD > block.timestamp. We will bypass this  3. onlyClient activates a token X using the activate function  4. Assume Grace period is crossed such that activated[_token] + GRACE_PERIOD < block.timestamp  5. Now if onlyClient calls deactivate function, it fails with \"too late\"  6. But onlyClient can bypass this by calling activate function again on token X which will reset the timestamp to latest in activated[_token] and hence onlyClient can now call deactivate function to disable the token and retrieve all funds present in the contract to his own address  ## Recommended Mitigation Steps Add below condition to activate function  ``` function activate(IERC20 _token) external override onlyClient { require(activated[_token]==0, \"Already activated\");         activated[_token] = block.timestamp;         savedTokens[_token] = _token.balanceOf(address(this));         emit ShelterActivated(_token);     } ```  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/26", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-02-concur-findings", "body": "QA Report"}, {"title": "Gas Optimization report for Concur finance", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/25", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-concur-findings", "body": "Gas Optimization report for Concur finance"}, {"title": "Gas savings", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/24", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-concur-findings", "body": "Gas savings"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/19", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-02-concur-findings", "body": "QA Report"}, {"title": "execute in VoteProxy should be payable", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/17", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-02-concur-findings", "body": "# Handle  wuwe1   # Vulnerability details  ## Impact `execute` will revert when `msg.value > 0`  ## Proof of Concept Lacking `payable` mutability specifier.  https://github.com/code-423n4/2022-02-concur/blob/main/contracts/VoteProxy.sol#L28-L35  ```solidity     function execute(         address _to,         uint256 _value,         bytes calldata _data     ) external onlyOwner returns (bool, bytes memory) {         (bool success, bytes memory result) = _to.call{value: _value}(_data);         return (success, result);     } ```   ## Recommended Mitigation Steps  Add `payable` mutability specifier.  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/13", "labels": ["bug", "QA (Quality Assurance)", "disagree with severity"], "target": "2022-02-concur-findings", "body": "QA Report"}, {"title": "Mark ConvexStakingWrapper.addRewards as External", "html_url": "https://github.com/code-423n4/2022-02-concur-findings/issues/2", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-02-concur-findings", "body": "# Handle  Heartless   # Vulnerability details  ## Impact external visibility uses less gas than public visibility. addRewards is never called internally in this project so does not need public visibility. addRewards was public in the original source from convex because they called addRewards() internally in the initialize() function, which ConvexStakingWrapper does not have.  ## Proof of Concept Line 93 in ConvexStakingWrapper.sol  ## Tools Used  ## Recommended Mitigation Steps Change addRewards visibility to external.  "}, {"title": "Gas Report", "html_url": "https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/112", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-02-badger-citadel-findings", "body": "Gas Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/111", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-02-badger-citadel-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/110", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-badger-citadel-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/108", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-badger-citadel-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/107", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-02-badger-citadel-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/106", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-02-badger-citadel-findings", "body": "QA Report"}, {"title": "Owner can steal input tokens", "html_url": "https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/105", "labels": ["bug", "2 (Med Risk)"], "target": "2022-02-badger-citadel-findings", "body": "Owner can steal input tokens"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/97", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-badger-citadel-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/96", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-02-badger-citadel-findings", "body": "QA Report"}, {"title": "QA report", "html_url": "https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/90", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-02-badger-citadel-findings", "body": "QA report"}, {"title": "QA report", "html_url": "https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/84", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-02-badger-citadel-findings", "body": "QA report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/80", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-badger-citadel-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/79", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-badger-citadel-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/77", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-badger-citadel-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/76", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-badger-citadel-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/75", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-02-badger-citadel-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/74", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-02-badger-citadel-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/73", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-badger-citadel-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/69", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-02-badger-citadel-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/68", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-badger-citadel-findings", "body": "Gas Optimizations"}, {"title": "QA report", "html_url": "https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/66", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-02-badger-citadel-findings", "body": "QA report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/64", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-02-badger-citadel-findings", "body": "QA Report"}, {"title": "[WP-H3] `saleRecipient` can rug buyers", "html_url": "https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/61", "labels": ["bug", "2 (Med Risk)"], "target": "2022-02-badger-citadel-findings", "body": "[WP-H3] `saleRecipient` can rug buyers"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/57", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-02-badger-citadel-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/56", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-badger-citadel-findings", "body": "Gas Optimizations"}, {"title": "QA report", "html_url": "https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/51", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-02-badger-citadel-findings", "body": "QA report"}, {"title": "Seven ways in which the Owner and Proxy Admin can make users lose funds (\"rug vectors\")", "html_url": "https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/50", "labels": ["bug", "duplicate", "2 (Med Risk)"], "target": "2022-02-badger-citadel-findings", "body": "Seven ways in which the Owner and Proxy Admin can make users lose funds (\"rug vectors\")"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/49", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-badger-citadel-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/48", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-badger-citadel-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/47", "labels": ["bug", "QA (Quality Assurance)", "disagree with severity"], "target": "2022-02-badger-citadel-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/46", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-02-badger-citadel-findings", "body": "QA Report"}, {"title": "QA report", "html_url": "https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/40", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-02-badger-citadel-findings", "body": "QA report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/38", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-badger-citadel-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/35", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-badger-citadel-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/34", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-02-badger-citadel-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/33", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-02-badger-citadel-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/32", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-badger-citadel-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/31", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-02-badger-citadel-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/29", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-badger-citadel-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/28", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-02-badger-citadel-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/23", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-02-badger-citadel-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/21", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-badger-citadel-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/19", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-badger-citadel-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/18", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-02-badger-citadel-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/9", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-02-badger-citadel-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/8", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-02-badger-citadel-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/7", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-badger-citadel-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/3", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-badger-citadel-findings", "body": "Gas Optimizations"}, {"title": "QA report", "html_url": "https://github.com/code-423n4/2022-02-badger-citadel-findings/issues/1", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-02-badger-citadel-findings", "body": "QA report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-nested-findings/issues/72", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-02-nested-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-nested-findings/issues/71", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-02-nested-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-nested-findings/issues/70", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-02-nested-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-nested-findings/issues/68", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-02-nested-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-nested-findings/issues/67", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-02-nested-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-nested-findings/issues/66", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-02-nested-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-nested-findings/issues/65", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-02-nested-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-nested-findings/issues/64", "labels": ["bug", "duplicate", "G (Gas Optimization)"], "target": "2022-02-nested-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-nested-findings/issues/58", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-02-nested-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-nested-findings/issues/57", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-02-nested-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-nested-findings/issues/56", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-02-nested-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-nested-findings/issues/55", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-02-nested-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-nested-findings/issues/52", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-02-nested-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-nested-findings/issues/50", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-02-nested-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-nested-findings/issues/48", "labels": ["bug", "duplicate", "G (Gas Optimization)"], "target": "2022-02-nested-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-nested-findings/issues/47", "labels": ["bug", "duplicate", "G (Gas Optimization)"], "target": "2022-02-nested-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-nested-findings/issues/46", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-02-nested-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-nested-findings/issues/45", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-02-nested-findings", "body": "QA Report"}, {"title": "NestedFactory: User can utilise accidentally sent ETH funds via processOutputOrders() / processInputAndOutputOrders()", "html_url": "https://github.com/code-423n4/2022-02-nested-findings/issues/44", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-02-nested-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L71 https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L286-L296 https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L370-L375 https://github.com/code-423n4/2022-02-nested/blob/main/contracts/NestedFactory.sol#L482-L492   # Vulnerability details  ## Impact  Should a user accidentally send ETH to the `NestedFactory`, anyone can utilise it to their own benefit by calling `processOutputOrders()` / `processInputAndOutputOrders()`. This is possible because:  1. `receive()` has no restriction on the sender 2. `processOutputOrders()` does not check `msg.value`, and rightly so, because funds are expected to come from `reserve`. 3. `transferInputTokens()` does not handle the case where `ETH` could be specified as an address by the user for an output order.  ```jsx if (address(_inputToken) == ETH) {   require(address(this).balance >= _inputTokenAmount, \"NF: INVALID_AMOUNT_IN\");   weth.deposit{ value: _inputTokenAmount }();   return (IERC20(address(weth)), _inputTokenAmount); } ```  Hence, the attack vector is simple. Should a user accidentally send ETH to the contract, create an output `Order` with `token` being `ETH` and amount corresponding to the NestedFactory\u2019s ETH balance.  ## Recommended Mitigation Steps  1. Since plain / direct`ETH` transfers are only expected to solely come from `weth` (excluding payable functions), we recommend restricting the sender to be `weth`, like how it is done in `[FeeSplitter](https://github.com/code-423n4/2022-02-nested/blob/main/contracts/FeeSplitter.sol#L101-L104)`.          We are aware that this was raised previously here: https://github.com/code-423n4/2021-11-nested-findings/issues/188 and would like to add that the restricting the sender in the `receive()` function will not affect `payable` functions. From from what we see, plain ETH transfers are also not expected to come from other sources like `NestedReserve` or operators.       ```jsx receive() external payable {   require(msg.sender == address(weth), \"NF: ETH_SENDER_NOT_WETH\"); } ```  1. Check that `_fromReserve` is false in the scenario `address(_inputToken) == ETH`.  ```jsx if (address(_inputToken) == ETH) {   require(!_fromReserve, \"NF: INVALID_INPUT_TOKEN\");   require(address(this).balance >= _inputTokenAmount, \"NF: INVALID_AMOUNT_IN\");   weth.deposit{ value: _inputTokenAmount }();   return (IERC20(address(weth)), _inputTokenAmount); } ```  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-nested-findings/issues/43", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-02-nested-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-nested-findings/issues/40", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-02-nested-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-nested-findings/issues/39", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-02-nested-findings", "body": "Gas Optimizations"}, {"title": "`NestedFactory` does not track operators properly", "html_url": "https://github.com/code-423n4/2022-02-nested-findings/issues/38", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-02-nested-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedFactory.sol#L99-L108 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/abstracts/MixinOperatorResolver.sol#L30-L47 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedFactory.sol#L110-L122 https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/abstracts/MixinOperatorResolver.sol#L49-L55   # Vulnerability details  `NestedFactory` extends the `MixinOperatorResolver` contract which comes from the [`synthetix/MixinResolver.sol`](https://github.com/Synthetixio/synthetix/blob/a1786e5d64b5b51212785ade6d8b42435f69c387/contracts/MixinResolver.sol) code base where the expectation is that `isResolverCached()` returns false until [`rebuildCache()` is called and the cache is fully up to date](https://github.com/Synthetixio/synthetix/blob/a1786e5d64b5b51212785ade6d8b42435f69c387/test/contracts/MixinResolver.js#L82-L105). Due to [a medium issue](https://github.com/code-423n4/2021-11-nested-findings/issues/217) identified in a prior contest, the `OperatorResolver.importOperators()` step was made to be atomically combined with the `NestedFactory.rebuildCache()` step. However, the atomicity was not applied everywhere and the ability to add/remove operators from the `NestedFactory` also had other cache-inconsistency issues. There are *four separate instances* of operator tracking problems in this submission.  ## Impact As with the prior issue, many core operations (such as `NestedFactory.create()` and `NestedFactory.swapTokenForTokens()`) are dependant on the assumption that the `operatorCache` cache is synced prior to these functions being executed, but this may not necessarily be the case. Unlike the prior issue which was about updates to the resolver not getting reflected in the cache, this issue is about changes to the factory not updating the cache.  ## Proof of Concept  ### 1. `removeOperator()` does not call `rebuildCache()` 1. `NestedFactory.removeOperator()` is called to remove an operator 2. A user calls `NestedFactory(MixinOperatorResolver).create()` using that operator and succeedes 3. `NestedFactory.rebuildCache()` is called to rebuild cache This flow is not aware that the cache is not in sync  ```solidity     /// @inheritdoc INestedFactory     function addOperator(bytes32 operator) external override onlyOwner {         require(operator != bytes32(\"\"), \"NF: INVALID_OPERATOR_NAME\");         bytes32[] memory operatorsCache = operators;         for (uint256 i = 0; i < operatorsCache.length; i++) {             require(operatorsCache[i] != operator, \"NF: EXISTENT_OPERATOR\");         }         operators.push(operator);         emit OperatorAdded(operator);     } ``` https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedFactory.sol#L99-L108  ### 2. Using both `removeOperator()` and `rebuildCache()` does not prevent `create()` from using the operator Even if `removeOperator()` calls `rebuildCache()` the function will still not work because `resolverOperatorsRequired()` only keeps track of remaining operators, and `rebuildCache()` currently has no way of knowing that an entry was removed from that array and that a corresponding entry from `operatorCache` needs to be removed too.  ```solidity     /// @notice Rebuild the operatorCache     function rebuildCache() external {         bytes32[] memory requiredOperators = resolverOperatorsRequired();         bytes32 name;         IOperatorResolver.Operator memory destination;         // The resolver must call this function whenever it updates its state         for (uint256 i = 0; i < requiredOperators.length; i++) {             name = requiredOperators[i];             // Note: can only be invoked once the resolver has all the targets needed added             destination = resolver.getOperator(name);             if (destination.implementation != address(0)) {                 operatorCache[name] = destination;             } else {                 delete operatorCache[name];             }             emit CacheUpdated(name, destination);         }     } ``` https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/abstracts/MixinOperatorResolver.sol#L30-L47  ### 3. `addOperator()` does not call `rebuildCache()` 1. `NestedFactory.addOperator()` is called to add an operator 2. A user calls `NestedFactory(MixinOperatorResolver).create()` using that operator and fails because the operator wasn't in the `resolverOperatorsRequired()` during the last call to `rebuildCaches()`, so the operator isn't in `operatorCache` 3. `NestedFactory.rebuildCache()` is called to rebuild cache This flow is not aware that the cache is not in sync  ```solidity     /// @inheritdoc INestedFactory     function removeOperator(bytes32 operator) external override onlyOwner {         uint256 operatorsLength = operators.length;         for (uint256 i = 0; i < operatorsLength; i++) {             if (operators[i] == operator) {                 operators[i] = operators[operatorsLength - 1];                 operators.pop();                 emit OperatorRemoved(operator);                 return;             }         }         revert(\"NF: NON_EXISTENT_OPERATOR\");     } ``` https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/NestedFactory.sol#L110-L122  ### 4. `isResolverCached()` does not reflect the actual updated-or-not state This function, like `removeOperator()` is not able to tell that there is an operator that needs to be removed from `resolverCache`, causing the owner not to know a call to `rebuildCache()` is required to 'remove' the operator ```solidity     /// @notice Check the state of operatorCache     function isResolverCached() external view returns (bool) {         bytes32[] memory requiredOperators = resolverOperatorsRequired();         bytes32 name;         IOperatorResolver.Operator memory cacheTmp;         IOperatorResolver.Operator memory actualValue;         for (uint256 i = 0; i < requiredOperators.length; i++) { ``` https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/abstracts/MixinOperatorResolver.sol#L49-L55  ## Tools Used Code inspection  ## Recommended Mitigation Steps Add calls to `rebuildCache()` in `addOperator()` and `removeOperator()`, have `INestedFactory` also track operators that have been removed with a new array, and have `isResolverCached()` also check whether this new array is empty or not.   "}, {"title": "QA report", "html_url": "https://github.com/code-423n4/2022-02-nested-findings/issues/35", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-02-nested-findings", "body": "QA report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-nested-findings/issues/33", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-02-nested-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-nested-findings/issues/32", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-02-nested-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-nested-findings/issues/28", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-02-nested-findings", "body": "Gas Optimizations"}, {"title": "Destroy can avoid the bulk of fees", "html_url": "https://github.com/code-423n4/2022-02-nested-findings/issues/27", "labels": ["bug", "2 (Med Risk)", "disagree with severity"], "target": "2022-02-nested-findings", "body": "Destroy can avoid the bulk of fees"}, {"title": "QA report", "html_url": "https://github.com/code-423n4/2022-02-nested-findings/issues/26", "labels": ["bug", "enhancement", "QA (Quality Assurance)"], "target": "2022-02-nested-findings", "body": "QA report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-nested-findings/issues/25", "labels": ["bug", "duplicate", "G (Gas Optimization)"], "target": "2022-02-nested-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-nested-findings/issues/24", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-02-nested-findings", "body": "QA Report"}, {"title": "Wrong logic around `areOperatorsImported`", "html_url": "https://github.com/code-423n4/2022-02-nested-findings/issues/17", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-02-nested-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-nested/blob/fe6f9ef7783c3c84798c8ab5fc58085a55cebcfc/contracts/OperatorResolver.sol#L42-L43   # Vulnerability details  ## Impact The logic related to the `areOperatorsImported` method is incorrect and can cause an operator not to be updated because the owner thinks it is already updated, and a vulnerable or defective one can be used.  ## Proof of Concept The `operators` mapping is made up of a key `bytes32 name` and a value made up of two values: `implementation` and `selector`, both of which identify the contract and function to be called when an operator is invoked.  The `areOperatorsImported` method tries to check if the operators to check already exist, however, the check is not done correctly, since && is used instead of ||.  If the operator with name `A` and value `{implementation=0x27f8d03b3a2196956ed754badc28d73be8830a6e,selector=\"performSwapVulnerable\"}` exists, and the owner try to check if the operator with name `A` and value `{implementation=0x27f8d03b3a2196956ed754badc28d73be8830a6e,selector=\"performSwapFixed\"}` exists, that function will return `true`, and the owner may decide not to import it , producing unexpected errors. Because operators manage the tokens, this error can produce a token lost.  ## Recommended Mitigation Steps Change && by ||    "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-nested-findings/issues/16", "labels": ["bug", "duplicate", "G (Gas Optimization)"], "target": "2022-02-nested-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-nested-findings/issues/15", "labels": ["bug", "disagree with severity", "G (Gas Optimization)"], "target": "2022-02-nested-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-nested-findings/issues/9", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-02-nested-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-nested-findings/issues/8", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-02-nested-findings", "body": "Gas Optimizations"}, {"title": "Undesired behavior", "html_url": "https://github.com/code-423n4/2022-02-nested-findings/issues/6", "labels": ["bug", "2 (Med Risk)", "disagree with severity"], "target": "2022-02-nested-findings", "body": "Undesired behavior"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-nested-findings/issues/5", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-02-nested-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-nested-findings/issues/4", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-02-nested-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-tribe-turbo-findings/issues/77", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-tribe-turbo-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-tribe-turbo-findings/issues/75", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-02-tribe-turbo-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-tribe-turbo-findings/issues/74", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-tribe-turbo-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-tribe-turbo-findings/issues/73", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-02-tribe-turbo-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-tribe-turbo-findings/issues/72", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-tribe-turbo-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-tribe-turbo-findings/issues/71", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-02-tribe-turbo-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-tribe-turbo-findings/issues/70", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-tribe-turbo-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-tribe-turbo-findings/issues/68", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-tribe-turbo-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-tribe-turbo-findings/issues/66", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-02-tribe-turbo-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-tribe-turbo-findings/issues/65", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-02-tribe-turbo-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-tribe-turbo-findings/issues/63", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-tribe-turbo-findings", "body": "Gas Optimizations"}, {"title": "Gibber can take any amount from safes", "html_url": "https://github.com/code-423n4/2022-02-tribe-turbo-findings/issues/62", "labels": ["bug", "2 (Med Risk)", "sponsor disputed"], "target": "2022-02-tribe-turbo-findings", "body": "Gibber can take any amount from safes"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-tribe-turbo-findings/issues/59", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-tribe-turbo-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-tribe-turbo-findings/issues/58", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged", "sponsor disputed"], "target": "2022-02-tribe-turbo-findings", "body": "QA Report"}, {"title": "[WP-M2] Wrong implementation of `TurboSafe.sol#less()` may cause boosted record value in TurboMaster bigger than actual lead to `BoostCapForVault` and `BoostCapForCollateral` to be permanently occupied", "html_url": "https://github.com/code-423n4/2022-02-tribe-turbo-findings/issues/55", "labels": ["bug", "2 (Med Risk)"], "target": "2022-02-tribe-turbo-findings", "body": "[WP-M2] Wrong implementation of `TurboSafe.sol#less()` may cause boosted record value in TurboMaster bigger than actual lead to `BoostCapForVault` and `BoostCapForCollateral` to be permanently occupied"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-tribe-turbo-findings/issues/53", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-02-tribe-turbo-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-tribe-turbo-findings/issues/52", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-tribe-turbo-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-tribe-turbo-findings/issues/47", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-tribe-turbo-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-tribe-turbo-findings/issues/44", "labels": ["bug", "QA (Quality Assurance)", "resolved"], "target": "2022-02-tribe-turbo-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-tribe-turbo-findings/issues/43", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-tribe-turbo-findings", "body": "Gas Optimizations"}, {"title": "QA report", "html_url": "https://github.com/code-423n4/2022-02-tribe-turbo-findings/issues/41", "labels": ["bug", "QA (Quality Assurance)", "disagree with severity", "sponsor acknowledged"], "target": "2022-02-tribe-turbo-findings", "body": "QA report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-tribe-turbo-findings/issues/39", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-02-tribe-turbo-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-tribe-turbo-findings/issues/37", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-tribe-turbo-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-tribe-turbo-findings/issues/36", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-02-tribe-turbo-findings", "body": "QA Report"}, {"title": "QA report", "html_url": "https://github.com/code-423n4/2022-02-tribe-turbo-findings/issues/35", "labels": ["bug", "QA (Quality Assurance)", "disagree with severity"], "target": "2022-02-tribe-turbo-findings", "body": "QA report"}, {"title": "QA report", "html_url": "https://github.com/code-423n4/2022-02-tribe-turbo-findings/issues/31", "labels": ["bug", "QA (Quality Assurance)", "disagree with severity", "sponsor acknowledged"], "target": "2022-02-tribe-turbo-findings", "body": "QA report"}, {"title": "Slurp can be frontrun with fee increase", "html_url": "https://github.com/code-423n4/2022-02-tribe-turbo-findings/issues/29", "labels": ["bug", "2 (Med Risk)", "sponsor disputed"], "target": "2022-02-tribe-turbo-findings", "body": "Slurp can be frontrun with fee increase"}, {"title": "`ERC4626RouterBase.withdraw` should use a **max** shares out check", "html_url": "https://github.com/code-423n4/2022-02-tribe-turbo-findings/issues/28", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "resolved"], "target": "2022-02-tribe-turbo-findings", "body": "`ERC4626RouterBase.withdraw` should use a **max** shares out check"}, {"title": "ERC4626 mint uses wrong `amount`", "html_url": "https://github.com/code-423n4/2022-02-tribe-turbo-findings/issues/27", "labels": ["bug", "3 (High Risk)"], "target": "2022-02-tribe-turbo-findings", "body": "ERC4626 mint uses wrong `amount`"}, {"title": "ERC4626 does not work with fee-on-transfer tokens", "html_url": "https://github.com/code-423n4/2022-02-tribe-turbo-findings/issues/26", "labels": ["bug", "2 (Med Risk)", "sponsor disputed"], "target": "2022-02-tribe-turbo-findings", "body": "ERC4626 does not work with fee-on-transfer tokens"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-tribe-turbo-findings/issues/22", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-tribe-turbo-findings", "body": "Gas Optimizations"}, {"title": "QA report", "html_url": "https://github.com/code-423n4/2022-02-tribe-turbo-findings/issues/21", "labels": ["bug", "QA (Quality Assurance)", "disagree with severity", "sponsor acknowledged"], "target": "2022-02-tribe-turbo-findings", "body": "QA report"}, {"title": "TurboRouter: deposit(), mint(), createSafeAndDeposit() and createSafeAndDepositAndBoost() functions do not work", "html_url": "https://github.com/code-423n4/2022-02-tribe-turbo-findings/issues/16", "labels": ["bug", "3 (High Risk)", "sponsor disputed"], "target": "2022-02-tribe-turbo-findings", "body": "TurboRouter: deposit(), mint(), createSafeAndDeposit() and createSafeAndDepositAndBoost() functions do not work"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-tribe-turbo-findings/issues/14", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged", "sponsor disputed"], "target": "2022-02-tribe-turbo-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-tribe-turbo-findings/issues/13", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-02-tribe-turbo-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-tribe-turbo-findings/issues/8", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-tribe-turbo-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-tribe-turbo-findings/issues/3", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-tribe-turbo-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-tribe-turbo-findings/issues/2", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-02-tribe-turbo-findings", "body": "QA Report"}, {"title": "Agreements & Disclosures", "html_url": "https://github.com/code-423n4/2022-02-skale-findings/issues/83", "labels": [], "target": "2022-02-skale-findings", "body": "Agreements & Disclosures"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-skale-findings/issues/81", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-02-skale-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-skale-findings/issues/79", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-skale-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-skale-findings/issues/78", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-02-skale-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-skale-findings/issues/77", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-02-skale-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-skale-findings/issues/75", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-skale-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-skale-findings/issues/74", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-skale-findings", "body": "Gas Optimizations"}, {"title": "Schain owners can rug pull users' funds", "html_url": "https://github.com/code-423n4/2022-02-skale-findings/issues/71", "labels": ["bug", "2 (Med Risk)", "sponsor disputed"], "target": "2022-02-skale-findings", "body": "Schain owners can rug pull users' funds"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-skale-findings/issues/67", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-02-skale-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-skale-findings/issues/66", "labels": ["bug", "duplicate", "QA (Quality Assurance)"], "target": "2022-02-skale-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-skale-findings/issues/65", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-skale-findings", "body": "Gas Optimizations"}, {"title": "Loss of pending messages (if any) in case removeConnectedChain is called", "html_url": "https://github.com/code-423n4/2022-02-skale-findings/issues/63", "labels": ["bug", "2 (Med Risk)"], "target": "2022-02-skale-findings", "body": "Loss of pending messages (if any) in case removeConnectedChain is called"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-skale-findings/issues/61", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-skale-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-skale-findings/issues/60", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-skale-findings", "body": "Gas Optimizations"}, {"title": "[WP-H3] S2S Transfer from the origin schain to another schain with automatic deploy disabled can cause funds to be frozen", "html_url": "https://github.com/code-423n4/2022-02-skale-findings/issues/59", "labels": ["bug", "2 (Med Risk)", "sponsor disputed"], "target": "2022-02-skale-findings", "body": "[WP-H3] S2S Transfer from the origin schain to another schain with automatic deploy disabled can cause funds to be frozen"}, {"title": "[WP-H2] When transferring tokens native on SKALE to Ethereum with `TokenManagerERC20.exitToMainERC20()`, the tokens on the schain will be frozen on `TokenManagerERC20`, but they will not receive tokens on Ethereum", "html_url": "https://github.com/code-423n4/2022-02-skale-findings/issues/58", "labels": ["bug", "2 (Med Risk)", "disagree with severity"], "target": "2022-02-skale-findings", "body": "[WP-H2] When transferring tokens native on SKALE to Ethereum with `TokenManagerERC20.exitToMainERC20()`, the tokens on the schain will be frozen on `TokenManagerERC20`, but they will not receive tokens on Ethereum"}, {"title": "[WP-H1] Transactions can be replayed when a connectedChain is removed and then reconnected", "html_url": "https://github.com/code-423n4/2022-02-skale-findings/issues/57", "labels": ["bug", "2 (Med Risk)", "disagree with severity"], "target": "2022-02-skale-findings", "body": "[WP-H1] Transactions can be replayed when a connectedChain is removed and then reconnected"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-skale-findings/issues/56", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-02-skale-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-skale-findings/issues/55", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-skale-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-skale-findings/issues/51", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-02-skale-findings", "body": "QA Report"}, {"title": "Not compatible with Rebasing/Deflationary/Inflationary tokens", "html_url": "https://github.com/code-423n4/2022-02-skale-findings/issues/50", "labels": ["bug", "2 (Med Risk)", "sponsor disputed"], "target": "2022-02-skale-findings", "body": "Not compatible with Rebasing/Deflationary/Inflationary tokens"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-skale-findings/issues/48", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-skale-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-skale-findings/issues/47", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-skale-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-skale-findings/issues/45", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-02-skale-findings", "body": "QA Report"}, {"title": "Division by zero when transmitting message array with zero length", "html_url": "https://github.com/code-423n4/2022-02-skale-findings/issues/41", "labels": ["bug", "G (Gas Optimization)", "sponsor disputed"], "target": "2022-02-skale-findings", "body": "Division by zero when transmitting message array with zero length"}, {"title": "transferredAmount on mainnet can be drained if a malicious account can mint more tokens on Schain", "html_url": "https://github.com/code-423n4/2022-02-skale-findings/issues/38", "labels": ["bug", "2 (Med Risk)", "sponsor disputed"], "target": "2022-02-skale-findings", "body": "transferredAmount on mainnet can be drained if a malicious account can mint more tokens on Schain"}, {"title": "Centralisation Risk: Admin Role of `TokenManagerEth` can Rug Pull All Eth from the Bridge", "html_url": "https://github.com/code-423n4/2022-02-skale-findings/issues/35", "labels": ["bug", "2 (Med Risk)", "disagree with severity"], "target": "2022-02-skale-findings", "body": "Centralisation Risk: Admin Role of `TokenManagerEth` can Rug Pull All Eth from the Bridge"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-skale-findings/issues/34", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-02-skale-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-skale-findings/issues/32", "labels": ["bug", "duplicate", "QA (Quality Assurance)"], "target": "2022-02-skale-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-skale-findings/issues/31", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-skale-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-skale-findings/issues/30", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-skale-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-skale-findings/issues/29", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-02-skale-findings", "body": "QA Report"}, {"title": "Gas Pricing Can Be Used To Extort Funds From Users of SChain Owner", "html_url": "https://github.com/code-423n4/2022-02-skale-findings/issues/28", "labels": ["bug", "3 (High Risk)", "disagree with severity"], "target": "2022-02-skale-findings", "body": "Gas Pricing Can Be Used To Extort Funds From Users of SChain Owner"}, {"title": "NFT owner can change tokenURI", "html_url": "https://github.com/code-423n4/2022-02-skale-findings/issues/26", "labels": ["bug", "2 (Med Risk)", "sponsor disputed"], "target": "2022-02-skale-findings", "body": "NFT owner can change tokenURI"}, {"title": "Reentrancy in `MessageProxyForSchain` leads to replay attacks", "html_url": "https://github.com/code-423n4/2022-02-skale-findings/issues/24", "labels": ["bug", "3 (High Risk)", "sponsor disputed"], "target": "2022-02-skale-findings", "body": "Reentrancy in `MessageProxyForSchain` leads to replay attacks"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-skale-findings/issues/23", "labels": ["bug", "QA (Quality Assurance)", "disagree with severity"], "target": "2022-02-skale-findings", "body": "QA Report"}, {"title": "BURNER_ROLE can burn any amount of EthErc20 from an arbitrary address", "html_url": "https://github.com/code-423n4/2022-02-skale-findings/issues/16", "labels": ["bug", "2 (Med Risk)", "sponsor disputed"], "target": "2022-02-skale-findings", "body": "BURNER_ROLE can burn any amount of EthErc20 from an arbitrary address"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-skale-findings/issues/13", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-skale-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-skale-findings/issues/9", "labels": ["bug", "QA (Quality Assurance)", "disagree with severity", "sponsor disputed"], "target": "2022-02-skale-findings", "body": "QA Report"}, {"title": "TokenManagerERC20.sol uses transferFrom() instead of safeTransferFrom()", "html_url": "https://github.com/code-423n4/2022-02-skale-findings/issues/8", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor disputed"], "target": "2022-02-skale-findings", "body": "TokenManagerERC20.sol uses transferFrom() instead of safeTransferFrom()"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-skale-findings/issues/5", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-skale-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-skale-findings/issues/3", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-skale-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-skale-findings/issues/2", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-02-skale-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/124", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-redacted-cartel-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/123", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-02-redacted-cartel-findings", "body": "QA Report"}, {"title": "Reentrancy in `depositBribeERC20` function", "html_url": "https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/122", "labels": ["bug", "2 (Med Risk)"], "target": "2022-02-redacted-cartel-findings", "body": "Reentrancy in `depositBribeERC20` function"}, {"title": "Users Can Frontrun Calls to `updateRewardsMetadata()` And Claim Tokens Twice", "html_url": "https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/118", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-02-redacted-cartel-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L97-L119 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L127-L209   # Vulnerability details  ## Impact  The `updateRewardsMetadata()` function is called by the `BribeVault` contract by the admin role. The function will take a list of distributions which are used to update the associated reward metadata. It is expected that the merkle root will be updated to correctly identify which claimers have already claimed tokens.   `reward.updateCount` is incremented to reset the claimed tracker, allowing users that may have previously claimed, to claim their updated reward. However, there is potential for mis-use if users frontrun calls to `updateRewardsMetadata()` and claim their reward after the new merkle root has been calculated and updated by the admin role. This may allow the claimer to double claim their rewards or lead to a loss in rewards if the reward metadata completely replaces the previous list of claimers.  ## Proof of Concept  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L97-L119 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L127-L209  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider implementing a delay where users cannot claim rewards before a call to `updateRewardsMetadata()` is made. This should ensure the admin role can construct a merkle tree based on the most up-to-date and correct data.  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/117", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-02-redacted-cartel-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/116", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-redacted-cartel-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/115", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-02-redacted-cartel-findings", "body": "QA Report"}, {"title": "Manipulations of setFee", "html_url": "https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/113", "labels": ["bug", "2 (Med Risk)", "disagree with severity"], "target": "2022-02-redacted-cartel-findings", "body": "Manipulations of setFee"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/111", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-02-redacted-cartel-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/110", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-redacted-cartel-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/103", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-02-redacted-cartel-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/101", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-02-redacted-cartel-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/100", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-redacted-cartel-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/99", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-02-redacted-cartel-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/97", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-02-redacted-cartel-findings", "body": "QA Report"}, {"title": "`DEPOSITOR_ROLE` can manipulate `b.amount` value", "html_url": "https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/95", "labels": ["bug", "duplicate", "2 (Med Risk)"], "target": "2022-02-redacted-cartel-findings", "body": "`DEPOSITOR_ROLE` can manipulate `b.amount` value"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/94", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-redacted-cartel-findings", "body": "Gas Optimizations"}, {"title": "[WP-H2] Improper control over the versions of distributions' metadata may lead to repeated claims of rewards", "html_url": "https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/89", "labels": ["bug", "2 (Med Risk)", "sponsor disputed"], "target": "2022-02-redacted-cartel-findings", "body": "[WP-H2] Improper control over the versions of distributions' metadata may lead to repeated claims of rewards"}, {"title": "[WP-H0] `DEFAULT_ADMIN_ROLE` of `BribeVault` can steal tokens from users' wallets", "html_url": "https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/86", "labels": ["bug", "2 (Med Risk)"], "target": "2022-02-redacted-cartel-findings", "body": "[WP-H0] `DEFAULT_ADMIN_ROLE` of `BribeVault` can steal tokens from users' wallets"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/84", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-02-redacted-cartel-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/83", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-02-redacted-cartel-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/79", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-redacted-cartel-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/78", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-02-redacted-cartel-findings", "body": "QA Report"}, {"title": "fees can be any amount", "html_url": "https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/74", "labels": ["bug", "duplicate", "2 (Med Risk)"], "target": "2022-02-redacted-cartel-findings", "body": "fees can be any amount"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/72", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-02-redacted-cartel-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/71", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-redacted-cartel-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/66", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-02-redacted-cartel-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/63", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-redacted-cartel-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/59", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-redacted-cartel-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/53", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-redacted-cartel-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/50", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-redacted-cartel-findings", "body": "Gas Optimizations"}, {"title": "ThecosomataETH: Oracle price can be better secured (freshness + tamper-resistance)", "html_url": "https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/49", "labels": ["bug", "duplicate", "2 (Med Risk)"], "target": "2022-02-redacted-cartel-findings", "body": "ThecosomataETH: Oracle price can be better secured (freshness + tamper-resistance)"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/47", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-02-redacted-cartel-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/46", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-02-redacted-cartel-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/42", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-02-redacted-cartel-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/41", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-02-redacted-cartel-findings", "body": "QA Report"}, {"title": "Admin Privilege - Owner can rug via `ThecosomataETH.withdraw`", "html_url": "https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/39", "labels": ["bug", "2 (Med Risk)", "sponsor disputed"], "target": "2022-02-redacted-cartel-findings", "body": "Admin Privilege - Owner can rug via `ThecosomataETH.withdraw`"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/37", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-02-redacted-cartel-findings", "body": "QA Report"}, {"title": "Wrong slippage check", "html_url": "https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/35", "labels": ["bug", "2 (Med Risk)", "sponsor disputed"], "target": "2022-02-redacted-cartel-findings", "body": "Wrong slippage check"}, {"title": "Distributions must not match actual bribes", "html_url": "https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/33", "labels": ["bug", "2 (Med Risk)"], "target": "2022-02-redacted-cartel-findings", "body": "Distributions must not match actual bribes"}, {"title": "`transferBribes` can revert", "html_url": "https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/32", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-02-redacted-cartel-findings", "body": "`transferBribes` can revert"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/28", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-02-redacted-cartel-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/27", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-02-redacted-cartel-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/26", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-02-redacted-cartel-findings", "body": "QA Report"}, {"title": "QA report", "html_url": "https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/19", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-02-redacted-cartel-findings", "body": "QA report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/17", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-02-redacted-cartel-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/16", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-02-redacted-cartel-findings", "body": "Gas Optimizations"}, {"title": "transferBribes could transfer before proposal deadline + Input validation", "html_url": "https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/14", "labels": ["bug", "2 (Med Risk)", "disagree with severity"], "target": "2022-02-redacted-cartel-findings", "body": "transferBribes could transfer before proposal deadline + Input validation"}, {"title": "Rewards can be lost", "html_url": "https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/13", "labels": ["bug", "2 (Med Risk)", "sponsor disputed"], "target": "2022-02-redacted-cartel-findings", "body": "Rewards can be lost"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/12", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-02-redacted-cartel-findings", "body": "Gas Optimizations"}, {"title": "Depositor can spend funds of another Depositor", "html_url": "https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/11", "labels": ["bug", "2 (Med Risk)", "sponsor disputed"], "target": "2022-02-redacted-cartel-findings", "body": "Depositor can spend funds of another Depositor"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/8", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-02-redacted-cartel-findings", "body": "Gas Optimizations"}, {"title": "Changing `bribeVault` in `RewardDistributor.sol` will Lock Current ETH Rewards", "html_url": "https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/7", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-02-redacted-cartel-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L178-#L182 https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L65-#L73   # Vulnerability details  ## Impact  Claiming of the ETH native currency requires `token` to be set to `bribeVault`. If the `bribeVault` is modified in `setBribeVault()` then users who have ETH rewards will now be considered to have `ERC20(bribeVault)` tokens. Since `bribeVault` is not an ERC20 token the `transfer()` call will fail and the users will not be able to claim their funds.   ## Recommended Mitigation Steps  Consider removing the functionality to change the `bribeVault` or ensuring all funds have been withdraw i.e. `balanceOf(address(this)) == 0` before changing the `bribeVault`.  "}, {"title": "SafeERC20.sol is imported but not used in the transferBribes() function ", "html_url": "https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/4", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-02-redacted-cartel-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L296   # Vulnerability details  ## Impact In BribeVault.sol the transferBribes() function uses token.transfer() instead of token.safeTransfer.  Tokens that don\u2019t correctly implement the latest EIP20 spec, like USDT, will be unusable in the protocol as they revert the transaction because of the missing return value.  The fact that the SafeERC20.sol library is imported at the top of the BribeVault.sol implies that safeTransfer should be being used but may have been forgotten.    ## Proof of Concept https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/BribeVault.sol#L296  ## Tools Used Manual code review   ## Recommended Mitigation Steps It's recommended to use OpenZeppelin\u2019s SafeERC20 versions with the safeTransfer and safeTransferFrom functions that handle the return value check as well as non-standard-compliant tokens.   "}, {"title": "QA report", "html_url": "https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/3", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-02-redacted-cartel-findings", "body": "QA report"}, {"title": "Send ether with call instead of transfer.", "html_url": "https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/2", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-02-redacted-cartel-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L181   # Vulnerability details  ## Impact Use call instead of transfer to send ether. And return value must be checked if sending ether is successful or not. Sending ether with the transfer is no longer recommended. ## Proof of Concept https://github.com/code-423n4/2022-02-redacted-cartel/blob/main/contracts/RewardDistributor.sol#L181  ## Tools Used review ## Recommended Mitigation Steps  (bool result, ) = payable(_account).call{value: _amount}(\"\"); require(result, \"Failed to send Ether\");  "}, {"title": "DEPOSITOR_ROLE can be granted by the deployer of BribeVault and transfer briber's approved ERC20 tokens to bribeVault by specifying any bribeIdentifier and rewardIdentifier", "html_url": "https://github.com/code-423n4/2022-02-redacted-cartel-findings/issues/1", "labels": ["bug", "2 (Med Risk)", "sponsor disputed"], "target": "2022-02-redacted-cartel-findings", "body": "DEPOSITOR_ROLE can be granted by the deployer of BribeVault and transfer briber's approved ERC20 tokens to bribeVault by specifying any bribeIdentifier and rewardIdentifier"}, {"title": "Governance issue - robee", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/140", "labels": ["2 (Med Risk)"], "target": "2022-02-hubble-findings", "body": "Governance issue - robee"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/135", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-02-hubble-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/134", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-02-hubble-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/131", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-02-hubble-findings", "body": "QA Report"}]