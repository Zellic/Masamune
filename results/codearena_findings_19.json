[{"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/69", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-velodrome-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/67", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-velodrome-findings", "body": "QA Report"}, {"title": "VotingEscrow's merge and withdraw aren't available for approved users", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/66", "labels": ["bug", "3 (High Risk)", "sponsor disputed"], "target": "2022-05-velodrome-findings", "body": "VotingEscrow's merge and withdraw aren't available for approved users"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/65", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-velodrome-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/62", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-velodrome-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/61", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-velodrome-findings", "body": "Gas Optimizations"}, {"title": "User rewards stop accruing after any _writeCheckpoint calling action", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/59", "labels": ["bug", "3 (High Risk)", "sponsor disputed"], "target": "2022-05-velodrome-findings", "body": "User rewards stop accruing after any _writeCheckpoint calling action"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/56", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-velodrome-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/55", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-velodrome-findings", "body": "Gas Optimizations"}, {"title": "Gauge set can be front run if bribe and gauge constructors aren't run atomically", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/54", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-velodrome-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-velodrome/blob/7fda97c570b758bbfa7dd6724a336c43d4041740/contracts/contracts/Bribe.sol#L30-L33   # Vulnerability details  If Bribe and Gauge constructors are run not in the same transaction, the griefing attack is possible. A malicious user can run setGauge after Bribe, but before Gauge constructor, making Bribe contract unusable. The fix here is Bribe redeployment.  Setting severity to be medium as that is temporary system breaking impact.  ## Proof of Concept  setGauge can be run by anyone, but only once with a meaningful gauge:  https://github.com/code-423n4/2022-05-velodrome/blob/7fda97c570b758bbfa7dd6724a336c43d4041740/contracts/contracts/Bribe.sol#L30-L33  ```solidity   function setGauge(address _gauge) external {     require(gauge == address(0), \"gauge already set\");     gauge = _gauge;   } ```  Now it is called in Gauge constructor:  https://github.com/code-423n4/2022-05-velodrome/blob/7fda97c570b758bbfa7dd6724a336c43d4041740/contracts/contracts/Gauge.sol#L96-L104  ```solidity     constructor(address _stake, address _bribe, address  __ve, address _voter, bool _isForPair) {         stake = _stake;         bribe = _bribe;         _ve = __ve;         voter = _voter;          factory = msg.sender;          IBribe(bribe).setGauge(address(this)); ```  This way it will not be called before Gauge constructor, but if it is not atomic with Bribe constructor, an attacker can call in-between.  ## Recommended Mitigation Steps  Consider either running Bribe and then Gauge constructors atomically, or introducing an owner role in Bribe constructor and onlyOwner access control in setGauge, setting it manually.  "}, {"title": "Rewards aren't updated before user's balance change in Gauge's withdrawToken", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/50", "labels": ["bug", "2 (Med Risk)", "sponsor disputed"], "target": "2022-05-velodrome-findings", "body": "Rewards aren't updated before user's balance change in Gauge's withdrawToken"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/47", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-velodrome-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/46", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-velodrome-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/44", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-velodrome-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/43", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-velodrome-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/40", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-velodrome-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/39", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-velodrome-findings", "body": "Gas Optimizations"}, {"title": "The minter can exceed its responsibilities.", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/38", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-05-velodrome-findings", "body": "The minter can exceed its responsibilities."}, {"title": "Alter velo receptions computation", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/36", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-05-velodrome-findings", "body": "Alter velo receptions computation"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/32", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-velodrome-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/30", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-velodrome-findings", "body": "Gas Optimizations"}, {"title": "VeloGovernor: proposalNumerator and team are updated by team, not governance", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/28", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-05-velodrome-findings", "body": "VeloGovernor: proposalNumerator and team are updated by team, not governance"}, {"title": "L2Governor: Unable to call _cancel function to lock the proposal", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/27", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-05-velodrome-findings", "body": "L2Governor: Unable to call _cancel function to lock the proposal"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/25", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-velodrome-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/24", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-velodrome-findings", "body": "Gas Optimizations"}, {"title": "Voter: Rounding causes voters to lose weight", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/23", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-05-velodrome-findings", "body": "Voter: Rounding causes voters to lose weight"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/19", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-velodrome-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/14", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-velodrome-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/13", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-velodrome-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/12", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-velodrome-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/11", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-velodrome-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/5", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-velodrome-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-velodrome-findings/issues/3", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-velodrome-findings", "body": "Gas Optimizations"}, {"title": "Usage of deprecated transfer to send ETH", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/180", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/swappers/SwapperRouter.sol#L140 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/swappers/SwapperRouter.sol#L280   # Vulnerability details  ## Impact   Usage of deprecated transfer  Swap can revert.   ## Proof of Concept  The original `transfer` used to send eth uses a fixed stipend 2300 gas.   This was used to prevent reentrancy.   However this limit your protocol to interact with others contracts that need more than that to proceess the transaction A good article about that https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/  ## Recommended Mitigation Steps  Used call instead.  For example          (bool success, ) = msg.sender.call{amount}(\"\");         require(success, \"Transfer failed.\");  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/178", "labels": ["bug", "G (Gas Optimization)", "sponsor disputed"], "target": "2022-05-backd-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/176", "labels": ["bug", "duplicate", "QA (Quality Assurance)"], "target": "2022-05-backd-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/174", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/173", "labels": ["bug", "QA (Quality Assurance)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "QA Report"}, {"title": "Minus before addition -> underflow risk (But reverted due to solidity 0.8)", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/172", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-05-backd-findings", "body": "Minus before addition -> underflow risk (But reverted due to solidity 0.8)"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/171", "labels": ["bug", "QA (Quality Assurance)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/170", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/168", "labels": ["bug", "G (Gas Optimization)", "sponsor disputed"], "target": "2022-05-backd-findings", "body": "Gas Optimizations"}, {"title": "lockFor() in BkdLocker don't check that user is not 0x0 and if user by mistake call this function with value 0x0 s/he is going to lose his funds.", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/166", "labels": ["bug", "disagree with severity", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L227-L232   # Vulnerability details  ## Impact function `lockFor()`  in `BkdLocker` is supposed to lock 'msg.sender` funds and increase `user` address funds but if anyone one calls it with `0x0` address by mistake then his funds will be locked forever.  ## Proof of Concept This is `lockFor()` code in `BkdLocker`: ```     function lockFor(address user, uint256 amount) public override {         govToken.safeTransferFrom(msg.sender, address(this), amount);         _userCheckpoint(user, amount, balances[user] + amount);         totalLocked += amount;         emit Locked(user, amount);     } ``` As you can see there is no check that `user` is not `0x0`. code calls `_userCheckpoint()` which will increase `0x0` balances in the contract and there is no check in `_userCheckpoint()` either and user can lose all his funds just by one simple mistake.  ## Tools Used VIM  ## Recommended Mitigation Steps check that `user` is not `0x0` in `lcokFor`  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/164", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/159", "labels": ["bug", "QA (Quality Assurance)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/155", "labels": ["bug", "QA (Quality Assurance)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/154", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/153", "labels": ["bug", "QA (Quality Assurance)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/151", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "Gas Optimizations"}, {"title": "Inconsistency in view functions can lead to users believing they\u2019re due for more BKD rewards", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/150", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmConvexGauge.sol#L107-L111 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmConvexGauge.sol#L129-L134   # Vulnerability details  ## Impact The view functions used for a user to check their claimable rewards vary in their implementation. This can cause users to believe they are due X amount but will receive Y.  ## Proof of Concept If the `inflationRecipient` is set, then `poolStakedIntegral` will be incremented in `claimableRewards()` but not in any other function like `allClaimableRewards()` or `poolCheckpoint()`.  If a user calls `claimableRewards()` after the `inflationRepient` has been set, `claimableRewards()` will return a larger value than `allClaimableRewards()` or the amount actually returned by `claimRewards()`.  ## Tools Used Manual review  ## Recommended Mitigation Steps To make the logic consistent, `claimableRewards()` needs `if (inflationRecipient == address(0))` added to it.  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/149", "labels": ["bug", "QA (Quality Assurance)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/148", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/146", "labels": ["bug", "QA (Quality Assurance)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/142", "labels": ["bug", "QA (Quality Assurance)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "QA Report"}, {"title": "Users can claim extremely large rewards or lock rewards from LpGauge due to uninitialised `poolLastUpdate` variable", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/141", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/LpGauge.sol#L115-L119 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/StakerVault.sol#L326-L328   # Vulnerability details  ## Impact A user can claim all of the available governance tokens or prevent any rewards from being claimed in `LpGauge.sol` if sufficient time is left between deploying the contract and initialising it in the `StakerVault.sol` contract by calling `initalizeLPGauge()` OR if a new `LPGauge` contract is deployed and added to `StakerVault` using `prepareLPGauge`.  Inside `LPGauge.sol` when calling `_poolCheckPoint()`, the `lastUpdated` variable is not initalised so defaults to a value of `0`, therefore if the user has managed to stake tokens in the `StakerVault` then the calculated `poolStakedIntegral` will be very large (as block.timestamp is very large). Therefore a user can mint most current available governance tokens for themselves when they claim their rewards (or prevent any governance tokens from being claimed).  ## Proof of Concept 1. LP Gauge and StakerVault contracts are deployed 2. Before the `initializeLpGauge()`, user A will stake 1 token with `stakeFor()` thereby increasing `_poolTotalStaked` by 1. As the `lpgauge` address is equal to the zero address, `_userCheckPoint()` will not be called and `poolLastUpdate` will remain at 0. 3. The user can then directly call `_userCheckPoint()` and be allocated a very large number of shares. This works because `poolLastUpdate` is 0 but the staked amount in the vault is larger than 0 4. Once `initializeLPGauge()` is called, the user can then call `claimRewards()` and receive a very large portion of tokens or if `poolStakedIntegral` exceeds the mint limit set by `Minter.sol` then no one else can claim governance tokens from the lpGauge.  OR 5. A new LP Gauge contract is deployed and added to the vault using `prepareGauge()`. Follow steps 2 to 4.  ## Tools Used Manual audit ## Recommended Mitigation Steps Initialise `poolLastUpdate` in the constructor  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/140", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/138", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "Gas Optimizations"}, {"title": "it's possible to initialize contract BkdLocker for multiple times by sending startBoost=0 and each time different values for other parameters", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/136", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/BkdLocker.sol#L53-L64   # Vulnerability details  ## Impact function `initialize()` of `BkdLocker` suppose to be called one time and contract initialize one time. but if it's called by `startBoost=0` then it's possible to call it again with different values for other parameters. there are some logics based on the values function `initilize()` sets which is in calculating boost and withdraw delay. by initializing multiple times different users get different values for those logics and because rewards are distributed based on boosts so those logics will be wrong too.  ## Proof of Concept This is `initiliaze()` code in `BkdLocker`: ```     function initialize(         uint256 startBoost,         uint256 maxBoost,         uint256 increasePeriod,         uint256 withdrawDelay     ) external override onlyGovernance {         require(currentUInts256[_START_BOOST] == 0, Error.CONTRACT_INITIALIZED);         _setConfig(_START_BOOST, startBoost);         _setConfig(_MAX_BOOST, maxBoost);         _setConfig(_INCREASE_PERIOD, increasePeriod);         _setConfig(_WITHDRAW_DELAY, withdrawDelay);     } ``` As you can see it checks the initialization statue by `currentUInts256[_START_BOOST]`'s value but it's not correct way to do and initializer can set `currentUInts256[_START_BOOST]` value as `0` and set other parameters values and call this function multiple times with different values for `_MAX_BOOST` and `_INCREASE_PERIOD` and `_WITHDRAW_DELAY`. setting different values for those parameters can cause different calculation in `computeNewBoost()` and `prepareUnlock()`. function `computeNewBoost()` is used to calculate users boost parameters which is used on reward distribution. so by changing `_MAX_BOOST` the rewards will be distributed wrongly between old users and new users.  ## Tools Used VIM  ## Recommended Mitigation Steps add some other variable to check the status of initialization of contract.   "}, {"title": "Fees from delisted pool still in reward handler will become stuck after delisting", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/135", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/Controller.sol#L62-L76   # Vulnerability details  ## Impact Unclaimed fees from pool will be stuck  ## Proof of Concept When delisting a pool the pool's reference is removed from address provider:  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/Controller.sol#L63  Burning fees calls a dynamic list of all pools which no longer contains the delisted pool:  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/RewardHandler.sol#L39  Since the list no longer contains the pool those fees will not be processed and will remain stuck in the contract   ## Tools Used  ## Recommended Mitigation Steps Call burnFees() before delisting a pool  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/134", "labels": ["bug", "QA (Quality Assurance)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "QA Report"}, {"title": "Fee-on transfer tokens in `FeeBurner.burnToTarget` will revert transaction", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/133", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-05-backd-findings", "body": "Fee-on transfer tokens in `FeeBurner.burnToTarget` will revert transaction"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/131", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/130", "labels": ["bug", "QA (Quality Assurance)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/129", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/128", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/127", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/126", "labels": ["bug", "QA (Quality Assurance)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/125", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/124", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/123", "labels": ["bug", "QA (Quality Assurance)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/122", "labels": ["bug", "G (Gas Optimization)", "sponsor disputed"], "target": "2022-05-backd-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/121", "labels": ["bug", "QA (Quality Assurance)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "QA Report"}, {"title": "There are multiple ways for admins/governance to rug users", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/113", "labels": ["bug", "2 (Med Risk)", "sponsor disputed"], "target": "2022-05-backd-findings", "body": "There are multiple ways for admins/governance to rug users"}, {"title": "THE FIRST AMM STAKER MAY NOT RECEIVE ACCORDING REWARDS BECAUSE OF POOR CHECKPOINTS", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/111", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L56 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L140   # Vulnerability details  ## Impact The first staker within the `AmmGauge` may not get the rewards if the pool is not checkpointed right after he stakes and before he wants to claim the rewards.  ## Proof of Concept A testing environment that reproduces how the protocol is going to be deployed and managed is used to evaluate this case under the following assumptions and simplifications.   1) The inflation rate is fixed for simplicity (`0.001`).  2) For the testing environment performed by the team, a DummyERC20 was used as testing token. The same is done on the exploit environment. 3) The minting of tokens impact both on the inflation calculation and their balance. But this test evaluates the states just before minting (claimable balances). Following how the pools are updated, they are checkpointed in the end of the `_executeInflationRateUpdate` call. Not while staking.  In order to illustrate this scenario we will show both the vulnerable and non vulnerable situations.  Vulnerable Situation: 1) Alice, Bob, Charlie and David are future users of the pool. They all notice the inception of this project and decide to stake. 2) They all stake the same amount. Their transactions are mined with 1min of difference starting from Alice and finishing with David. 3) There is no external pool checkpoint between Alice and Bob (besides the one that is triggered when Bob stakes). 4) Sometime happens and they all want to check their accumulated reward balance. Alice accumulated much less than the others.  Non Vulnerable Situation: - The same as before but calling externally `_poolCheckpoint()` between Alice stake call and Bobs' and before checking the accumulated rewards.  The code to show this has a `secureCheckpoints` toggle that can be set as true or false to trigger (or not) the intermediate poolCheckpoints.          it('First Staker Rewards Calculation', async function () {                           let secureCheckpoints = false;             let currentShare, currentStakedIntegral, balances;             await this.ammgauge.poolCheckpoint();             await ethers.provider.send(\"evm_increaseTime\", [1 * 24 * 60 * 60]); // 10 days                          const updateStates = async (from) => {                  currentShare = await this.ammgauge.perUserShare(from.address);                 currentStakedIntegral = await this.ammgauge.perUserStakedIntegral(from.address);                 balances = await this.ammgauge.balances(from.address);             }              const stake = async (to, amount) => {                 await updateStates(to)                 console.log(\" \")                 // Balance before                 let balanceBefore = await this.ammgauge.balances(to.address);                 // Stake                 await this.ammgauge.connect(to).stake(amount);                 expect(await this.ammgauge.balances(to.address)).to.be.eq(balanceBefore.add(amount));                 await updateStates(to);                 console.log(\" \")             }              const unstake = async (to, amount) => {                 await updateStates(to)                 console.log(\" \")                 // Balance before                 let balanceBefore = await this.ammgauge.balances(to.address);                 // Stake                 await this.ammgauge.connect(to).unstake(amount);                 expect(await this.ammgauge.balances(to.address)).to.be.eq(balanceBefore.sub(amount));                 await updateStates(to);                 console.log(\" \")             }              // Each user stakes tokens             let initialStaking = ethers.utils.parseEther(\"10\")             console.log(\" \")             console.log(\"USERS STAKE\");             for (const user of users) {             await stake(user, initialStaking)             if(secureCheckpoints){await this.ammgauge.poolCheckpoint()};             await ethers.provider.send(\"evm_increaseTime\", [60 * 60]); // 1hr between stakes             }             console.log(\" \")              await ethers.provider.send(\"evm_increaseTime\", [ 5 * 24 * 60 * 60]); // 5 days             if(secureCheckpoints){await this.ammgauge.poolCheckpoint()};              let claimableRewards = [];             let claimedRewards = [];             console.log(\" \")             console.log(\"USERS CLAIMABLE REWARDS AFTER 5 days\");             console.log(\" \")             for (const user of users) {                 let stepClaimable = await this.ammgauge.claimableRewards(user.address);                 claimableRewards.push(ethers.utils.formatEther(stepClaimable))                  let rewardsClaim = await (await this.ammgauge.claimRewards(user.address)).wait()                 claimedRewards.push(ethers.utils.formatEther(rewardsClaim.logs[0][\"data\"]))             }              console.log(\"Claimable calculated\")             console.log(\"   ALICE - BOB -  CHARLIE - DAVID\")             console.log(claimableRewards)              console.log(\" \")             console.log(\"Effectively Claimed\")             console.log(\"   ALICE - BOB -  CHARLIE - DAVID\")             console.log(claimableRewards)         })  The outputs for both cases are shown on the following chart. The initial staking amount is 10eth amount of the DummyERC20 token.  |         | Without Checkpoints | With Checkpoints | |:-------:|:-------------------:|:----------------:| |  Alice  |         6.6         |       115.5      | |   Bob   |        111.9        |       111.9      | | Charlie |        110.1        |       110.1      | |  David  |        108.9        |       108.9      |   ## Recommended Mitigation Steps - Check how is calculated the staking variables while the pool has no tokens staked and also how the updates and checkpoints are performed.  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/109", "labels": ["bug", "QA (Quality Assurance)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/108", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/107", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/106", "labels": ["bug", "QA (Quality Assurance)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/105", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-05-backd-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/104", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/103", "labels": ["bug", "G (Gas Optimization)", "sponsor disputed"], "target": "2022-05-backd-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/102", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "Gas Optimizations"}, {"title": "THE FIRST AMM STAKER WILL HAVE CONTROL OVER HOW THE SHARES ARE CALCULATED", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/100", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L147 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/AmmGauge.sol#L154   # Vulnerability details  ## Impact The first staker can take control of how the subsequent shares are going to be distributed by simply staking 1wei amount of the token and frontrunning future stakers. The reasons of this are related on how the variables are updated and with the amounts that the Gauge allows users to stake (anything but zero). The origin of this vulnerability relies on the evaluation of the `totalStaked` variable on its inception.  ## Proof of Concept To illustrate this attack an environment of testing was made in order to track the token flows and how the variables are being updated and read.  The initial or border conditions taken into account are the same as the used by the team to perform the tests and just a few assumptions and simplifications were taken.  1) The inflation rate is fixed for simplicity (`0.001`). This is valid within a short period of time because it is not a function of how the tokens are distributed or their flows. By tracking how the inflation rate is calculated an updated, we see that it is managed by the `currentInflationAmountAmm` within the [`Minter.sol` contract](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L184), which value is modified by `_executeInflationRateUpdate()` three lines below the last code permalink. Its value depends on non-token balance related parameters (such as inflation decays and annual rates). 2) For the testing environment performed by the team, a DummyERC20 was used as testing token. The same is done on the exploit environment. 3) The controller is not used because it is used to retrieve the inflation rate and it is now fixed because of 1).  Each user state is updated whenever he calls either `stake`, `unstake` or `claimRewards`.  Steps: - Alice is the first staker and deposits 1wei worth of DummyERC20. - Bob takes one day to find out this new protocol and decides to stake 10 ETH amount of tokens (`10 * 10**decimals()`). - Alice, who was scanning the mempool, frontruns Bob with the same amount he was willing to stake. Her txn is mined first. - Then Bobs' transaction is mined for the 10 ETH worth. - Sometime after this, the pool is checkpointed. - A few days pass, and Bob wants to stake even more tokens. The same amount as before. - Alice frontruns him again updating her shares. - Bobs' transaction is mined and his shares are also updated. - The pool is checkpointed again. And Alice managed to increase considerably her amount of shares.  Both cases were evaluated (with and without staking 1 wei first). The attack scenario outputs a 100% more shares to Alice than Bob in comparison with the ethical/non-attack situation.  The code used to perform this test is the following:      it(\"First Depositer Exploit\", async function () {             let userShares = []             let userIntegral = []             let userBalance = []              let globalIntegral, totalStaked;             let aliceBob = [alice, bob];              // Starting Checkpoint             await this.ammgauge.poolCheckpoint();             await ethers.provider.send(\"evm_increaseTime\", [1 * 24 * 60 * 60]); // 10 days                          const updateStates = async () => {                  userShares = []                 userIntegral = []                 userBalance = []                 for (const user of aliceBob) {                     let balances = ethers.utils.formatEther(await this.ammgauge.balances(user.address));                     let currentShare = ethers.utils.formatEther(await this.ammgauge.perUserShare(user.address));                     let currentStakedIntegral = ethers.utils.formatEther(await this.ammgauge.perUserStakedIntegral(user.address));                     userShares.push(currentShare);                     userIntegral.push(currentStakedIntegral);                     userBalance.push(balances);                 }                 globalIntegral = await this.ammgauge.ammStakedIntegral()                 totalStaked = await this.ammgauge.totalStaked()                 console.log(\"  \")                 console.log(\"         ALICE / BOB\");                 console.log(`Shares: ${userShares}`);                 console.log(`Integr: ${userIntegral}`);                 console.log(`Balanc: ${userBalance}`);                 console.log(\"  \")                 console.log(\"Global\")                 console.log(`Integral: ${ethers.utils.formatEther(globalIntegral)}, TotalStaked: ${ethers.utils.formatEther(totalStaked)}`)             }              const stake = async (to, amount) => {                 await updateStates()                 console.log(\" \")                 // Balance before                 let balanceBefore = await this.ammgauge.balances(to.address);                 // Stake                 await this.ammgauge.connect(to).stake(amount);                 expect(await this.ammgauge.balances(to.address)).to.be.eq(balanceBefore.add(amount));                 // await updateStates();                 console.log(\" \")             }              const unstake = async (to, amount) => {                 await updateStates()                 console.log(\" \")                 // Balance before                 let balanceBefore = await this.ammgauge.balances(to.address);                 // Stake                 await this.ammgauge.connect(to).unstake(amount);                 expect(await this.ammgauge.balances(to.address)).to.be.eq(balanceBefore.sub(amount));                 await updateStates();                 console.log(\" \")             }              // HERE IS WHERE THE SIMULATION IS PERFORMED             let simulationTimes = 2;             let withOneWeiDeposit = true;              if (withOneWeiDeposit) {                 // Alice deposits first                 console.log(\"Alice Deposits 1wei\")                 let firstUserDeposit = ethers.utils.parseEther(\"1\");                 await stake(alice, 1);             }              for (let index = 1; index <= simulationTimes; index++) {                 console.log(\" \")                 console.log(`Loop number ${index}`);                 console.log(\" \")                  console.log(\"A day passes until Bob decides to deposit\")                 await ethers.provider.send(\"evm_increaseTime\", [1 * 24 * 60 * 60]); // 1 days                  console.log(\" \")                 console.log(\"She scans that Bob is about to stake 10. So decides to frontrun him.\")                 console.log(\"Alice Frontruns\")                 let frontrunAmount = ethers.utils.parseEther(\"10\");                 await stake(alice, frontrunAmount);                  console.log(\" \")                 console.log(\"Bob stakes 10 tokens\")                 await stake(bob, frontrunAmount)                  // A few days pass                 await ethers.provider.send(\"evm_increaseTime\", [1 * 24 * 60 * 60]); // 2 days                 // The pool is checkpointed                 await this.ammgauge.poolCheckpoint();                 console.log(\"After 1 day the pool is checkpointed\")                 await updateStates()              }         })  The simulation was both made for the attacked and non attacked situations. The values that are shown represent how the contract updates them (the `totalStaked` variable is 0 when first Alice calls the stake function after `_userCheckpoint()` rans)  ### WITH 1WEI STAKE (ATTACK)   | time |                Situation               |  totalStaked  | Alice Shares | Bob Shares | |:----:|:--------------------------------------:|:-------------:|:------------:|:----------:| |  0-  |          First poolCheckpoint          |       0       |       0      |      0     | |  0+  |           Alice Deposits 1wei          |       0       |       0      |      0     | |   1  |       Alice frontruns Bob @ 10eth      |      1wei     |       0      |      0     | |   2  |         Bob 10eth txn is mined         |  10eth + 1wei |     86.4     |      0     | |   3  | 1 day later poolCheckpoint() is called | 20eth + 1 wei |     86.4     |      0     | |   4  |        Alice frontruns Bob again       | 20eth + 1 wei |     86.4     |      0     | |   5  |         Bob 10eth txn is mined         |  30eth + 1wei |     172.8    |      0     | |   6  | 1 day later poolCheckpoint() is called |  40eth + 1wei |     172.8    |    86.4    |  ### WITHOUT THE 1WEI STAKE (No \"first staker hijack\")  | time |                Situation               | totalStaked | Alice Shares | Bob Shares | |:----:|:--------------------------------------:|:-----------:|:------------:|:----------:| |  0-  |          First poolCheckpoint          |      0      |       0      |      0     | |  0+  |           Alice stakes 10eth           |      0      |       0      |      0     | |   1  |            Bob stakes 10eth            |    10eth    |       0      |      0     | |   2  | 1 day later poolCheckpoint() is called |    20eth    |       0      |      0     | |   3  |           Alice stakes 10eth           |    20eth    |       0      |      0     | |   4  |            Bob stakes 10eth            |    30eth    |     86.4     |      0     | |   5  | 1 day later poolCheckpoint() is called |    40eth    |     86.4     |    86.4    |   ## Recommended Mitigation Steps Further evaluation on how the variables are updated and how does the `Integral` (both each users and global one) is calculated on the pool inception is needed to patch this issue.  "}, {"title": "`Minter.sol#startInflation()` can be bypassed", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/99", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L104-L108   # Vulnerability details  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L104-L108  ```solidity     function startInflation() external override onlyGovernance {         require(lastEvent == 0, \"Inflation has already started.\");         lastEvent = block.timestamp;         lastInflationDecay = block.timestamp;     } ```  As `lastEvent` and `lastInflationDecay` are not initialized in the `constructor()`, they will remain to the default value of `0`.  However, the permissionless `executeInflationRateUpdate()` method does not check the value of `lastEvent` and `lastInflationDecay` and used them directly.  As a result, if `executeInflationRateUpdate()` is called before `startInflation()`:  1. L190, the check of if `_INFLATION_DECAY_PERIOD` has passed since `lastInflationDecay` will be `true`, and `initialPeriodEnded` will be set to `true` right away; 2. L188, since the `lastEvent` in `totalAvailableToNow += (currentTotalInflation * (block.timestamp - lastEvent));` is `0`, the `totalAvailableToNow` will be set to `totalAvailableToNow \u2248 currentTotalInflation * 52 years`, which renders the constrains of `totalAvailableToNow` incorrect and useless.  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L115-L117  ```solidity     function executeInflationRateUpdate() external override returns (bool) {         return _executeInflationRateUpdate();     } ```  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L187-L215  ```solidity     function _executeInflationRateUpdate() internal returns (bool) {         totalAvailableToNow += (currentTotalInflation * (block.timestamp - lastEvent));         lastEvent = block.timestamp;         if (block.timestamp >= lastInflationDecay + _INFLATION_DECAY_PERIOD) {             currentInflationAmountLp = currentInflationAmountLp.scaledMul(annualInflationDecayLp);             if (initialPeriodEnded) {                 currentInflationAmountKeeper = currentInflationAmountKeeper.scaledMul(                     annualInflationDecayKeeper                 );                 currentInflationAmountAmm = currentInflationAmountAmm.scaledMul(                     annualInflationDecayAmm                 );             } else {                 currentInflationAmountKeeper =                     initialAnnualInflationRateKeeper /                     _INFLATION_DECAY_PERIOD;                  currentInflationAmountAmm = initialAnnualInflationRateAmm / _INFLATION_DECAY_PERIOD;                 initialPeriodEnded = true;             }             currentTotalInflation =                 currentInflationAmountLp +                 currentInflationAmountKeeper +                 currentInflationAmountAmm;             controller.inflationManager().checkpointAllGauges();             lastInflationDecay = block.timestamp;         }         return true;     } ```  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L50-L51  ```solidity     // Used for final safety check to ensure inflation is not exceeded     uint256 public totalAvailableToNow; ```  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L217-L227  ```solidity     function _mint(address beneficiary, uint256 amount) internal returns (bool) {         totalAvailableToNow += ((block.timestamp - lastEvent) * currentTotalInflation);         uint256 newTotalMintedToNow = totalMintedToNow + amount;         require(newTotalMintedToNow <= totalAvailableToNow, \"Mintable amount exceeded\");         totalMintedToNow = newTotalMintedToNow;         lastEvent = block.timestamp;         token.mint(beneficiary, amount);         _executeInflationRateUpdate();         emit TokensMinted(beneficiary, amount);         return true;     } ```  ### Recommendation   Consider initializing `lastEvent`, `lastInflationDecay` in `constructor()`.  or  Consider adding `require(lastEvent != 0 && lastInflationDecay != 0, \"...\")` to `executeInflationRateUpdate()`.  "}, {"title": "`Minter.sol#_executeInflationRateUpdate()` `inflationManager().checkpointAllGauges()` is called after InflationRate is updated, causing users to lose rewards", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/98", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L187-L215   # Vulnerability details  When `Minter.sol#_executeInflationRateUpdate()` is called, if an `_INFLATION_DECAY_PERIOD` has past since `lastInflationDecay`, it will update the InflationRate for all of the gauges.  However, in the current implementation, the rates will be updated first, followed by the rewards being settled using the new rates on the gauges using `inflationManager().checkpointAllGauges()`.  If the `_INFLATION_DECAY_PERIOD` has passed for a long time before `Minter.sol#executeInflationRateUpdate()` is called, the users may lose a significant amount of rewards.  On a side note, `totalAvailableToNow` is updated correctly.  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L187-L215  ```solidity function _executeInflationRateUpdate() internal returns (bool) {     totalAvailableToNow += (currentTotalInflation * (block.timestamp - lastEvent));     lastEvent = block.timestamp;     if (block.timestamp >= lastInflationDecay + _INFLATION_DECAY_PERIOD) {         currentInflationAmountLp = currentInflationAmountLp.scaledMul(annualInflationDecayLp);         if (initialPeriodEnded) {             currentInflationAmountKeeper = currentInflationAmountKeeper.scaledMul(                 annualInflationDecayKeeper             );             currentInflationAmountAmm = currentInflationAmountAmm.scaledMul(                 annualInflationDecayAmm             );         } else {             currentInflationAmountKeeper =                 initialAnnualInflationRateKeeper /                 _INFLATION_DECAY_PERIOD;              currentInflationAmountAmm = initialAnnualInflationRateAmm / _INFLATION_DECAY_PERIOD;             initialPeriodEnded = true;         }         currentTotalInflation =             currentInflationAmountLp +             currentInflationAmountKeeper +             currentInflationAmountAmm;         controller.inflationManager().checkpointAllGauges();         lastInflationDecay = block.timestamp;     }     return true; } ```  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L110-L125  ```solidity function checkpointAllGauges() external override returns (bool) {     uint256 length = _keeperGauges.length();     for (uint256 i; i < length; i = i.uncheckedInc()) {         IKeeperGauge(_keeperGauges.valueAt(i)).poolCheckpoint();     }     address[] memory stakerVaults = addressProvider.allStakerVaults();     for (uint256 i; i < stakerVaults.length; i = i.uncheckedInc()) {         IStakerVault(stakerVaults[i]).poolCheckpoint();     }      length = _ammGauges.length();     for (uint256 i; i < length; i = i.uncheckedInc()) {         IAmmGauge(_ammGauges.valueAt(i)).poolCheckpoint();     }     return true; } ```  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L110-L117  ```solidity function poolCheckpoint() public override returns (bool) {     if (killed) return false;     uint256 timeElapsed = block.timestamp - uint256(lastUpdated);     uint256 currentRate = IController(controller).inflationManager().getKeeperRateForPool(pool);     perPeriodTotalInflation[epoch] += currentRate * timeElapsed;     lastUpdated = uint48(block.timestamp);     return true; } ```  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L507-L519  ```solidity function getKeeperRateForPool(address pool) external view override returns (uint256) {     if (minter == address(0)) {         return 0;     }     uint256 keeperInflationRate = Minter(minter).getKeeperInflationRate();     // After deactivation of weight based dist, KeeperGauge handles the splitting     if (weightBasedKeeperDistributionDeactivated) return keeperInflationRate;     if (totalKeeperPoolWeight == 0) return 0;     bytes32 key = _getKeeperGaugeKey(pool);     uint256 poolInflationRate = (currentUInts256[key] * keeperInflationRate) /         totalKeeperPoolWeight;     return poolInflationRate; } ```   https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L173-L176  ```solidity     function getKeeperInflationRate() external view override returns (uint256) {         if (lastEvent == 0) return 0;         return currentInflationAmountKeeper;     } ```  ### PoC  Given:  - currentInflationAmountAmm: 12,000 Bkd (1000 per month) - annualInflationDecayAmm: 50% - initialPeriodEnded: true - lastInflationDecay: 11 months ago - _INFLATION_DECAY_PERIOD: 1 year  1. Alice deposited as the one and only staker in the `AmmGauge` pool; 2. 1 month later; 3. `Minter.sol#_executeInflationRateUpdate()` is called; 4. Alice `claimableRewards()` and received `500` Bkd tokens.  Expected Results:  - Alice to receive `1000` Bkd tokens as rewards.  Actual Results:  - Alice received `500` Bkd tokens as rewards.  ### Recommendation  Consider moving the call to `checkpointAllGauges()` to before the `currentInflationAmountKeeper` is updated.  ```solidity function _executeInflationRateUpdate() internal returns (bool) {     totalAvailableToNow += (currentTotalInflation * (block.timestamp - lastEvent));     lastEvent = block.timestamp;     if (block.timestamp >= lastInflationDecay + _INFLATION_DECAY_PERIOD) {         controller.inflationManager().checkpointAllGauges();         currentInflationAmountLp = currentInflationAmountLp.scaledMul(annualInflationDecayLp);         if (initialPeriodEnded) {             currentInflationAmountKeeper = currentInflationAmountKeeper.scaledMul(                 annualInflationDecayKeeper             );             currentInflationAmountAmm = currentInflationAmountAmm.scaledMul(                 annualInflationDecayAmm             );         } else {             currentInflationAmountKeeper =                 initialAnnualInflationRateKeeper /                 _INFLATION_DECAY_PERIOD;              currentInflationAmountAmm = initialAnnualInflationRateAmm / _INFLATION_DECAY_PERIOD;             initialPeriodEnded = true;         }         currentTotalInflation =             currentInflationAmountLp +             currentInflationAmountKeeper +             currentInflationAmountAmm;         lastInflationDecay = block.timestamp;     }     return true; } ```  "}, {"title": "Attacker can steal funds from the contract with re-entrancy from hookable tokens", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/96", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-05-backd-findings", "body": "Attacker can steal funds from the contract with re-entrancy from hookable tokens"}, {"title": "`BkdLocker#depositFees()` can be front run to steal the newly added rewardToken", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/95", "labels": ["bug", "2 (Med Risk)", "sponsor disputed"], "target": "2022-05-backd-findings", "body": "`BkdLocker#depositFees()` can be front run to steal the newly added rewardToken"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/94", "labels": ["bug", "QA (Quality Assurance)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/93", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/92", "labels": ["bug", "G (Gas Optimization)", "sponsor disputed"], "target": "2022-05-backd-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/91", "labels": ["bug", "QA (Quality Assurance)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/90", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/89", "labels": ["bug", "QA (Quality Assurance)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "QA Report"}, {"title": "StakerVault.unstake(), StakerVault.unstakeFor() would revert with a uint underflow error of StakerVault.strategiesTotalStaked, StakerVault._poolTotalStaked.", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/87", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/StakerVault.sol#L98-L102 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/StakerVault.sol#L342-L346 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/StakerVault.sol#L391-L395   # Vulnerability details  ## Impact StakerVault.unstake(), StakerVault.unstakeFor() would revert with a uint underflow error of StakerVault.strategiesTotalStaked, StakerVault._poolTotalStaked.  ## Proof of Concept Currently it saves totalStaked for strategies and non-strategies separately. uint underflow error could be occured in these cases.  Scenario 1. 1. Address A(non-strategy) stakes some amount x and it will be added to StakerVault_poolTotalStaked. 2. This address A is approved as a strategy by StakerVault.inflationManager. 3. Address A tries to unstake amount x, it will be deducted from StakerVault.strategiesTotalStaked because this address is a strategy already. Even if it would succeed for this strategy but it will revert for other strategies because StakerVault.strategiesTotalStaked is less than correct staked amount for strategies.  Scenario 2. There is a transfer between strategy and non-strategy using StakerVault.transfer(), StakerVault.transferFrom() functions. In this case, StakerVault.strategiesTotalStaked and StakerVault._poolTotalStaked must be changed accordingly but there is no such logic.  ## Tools Used Solidity Visual Developer of VSCode  ## Recommended Mitigation Steps You need to modify 3 functions. StakerVault.addStrategy(), StakerVault.transfer(), StakerVault.transferFrom().  1. You need to move staked amount from StakerVault._poolTotalStaked to StakerVault.strategiesTotalStaked every time when StakerVault.inflationManager approves a new strategy. You can modify addStrategy() at L98-L102 like this.  function addStrategy(address strategy) external override returns (bool) {     require(msg.sender == address(inflationManager), Error.UNAUTHORIZED_ACCESS);     require(!strategies[strategy], Error.ADDRESS_ALREADY_SET);      strategies[strategy] = true;     _poolTotalStaked -= balances[strategy];     strategiesTotalStaked += balances[strategy];      return true; }  2. You need to add below code at L126 of transfer() function.  if(strategies[msg.sender] != strategies[account]) {     if(strategies[msg.sender]) { // from strategy to non-strategy         _poolTotalStaked += amount;         strategiesTotalStaked -= amount;     }     else { // from non-strategy to strategy         _poolTotalStaked -= amount;         strategiesTotalStaked += amount;     } }  3. You need to add below code at L170 of transferFrom() function.  if(strategies[src] != strategies[dst]) {     if(strategies[src]) { // from strategy to non-strategy         _poolTotalStaked += amount;         strategiesTotalStaked -= amount;     }     else { // from non-strategy to strategy         _poolTotalStaked -= amount;         strategiesTotalStaked += amount;     } }  "}, {"title": "Users can claim more fees than expected if governance migrates current rewardToken again by fault.", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/86", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/BkdLocker.sol#L70-L75 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/BkdLocker.sol#L302-L322   # Vulnerability details  ## Impact Users can claim more fees than expected if governance migrates current rewardToken again by fault.  ## Proof of Concept In the migrate() function, there is no requirement newRewardToken != rewardToken. If this function is called with the same \"rewardToken\" parameter, \"_replacedRewardTokens\" will contain the current \"rewardToken\" also. Then when the user claims fees, \"userShares\" will be added two times for the same token at L302-L305, L314-L317. It's because \"curRewardTokenData.userFeeIntegrals[user]\" is updated at L332 after the \"userShares\" calculation for past rewardTokens. So the user can get paid more fees than he should.  ## Tools Used Solidity Visual Developer of VSCode  ## Recommended Mitigation Steps You need to add this require() at L71.  require(newRewardToken != rewardToken, Error.SAME_AS_CURRENT);  "}, {"title": "Strategy in StakerVault.sol can steal more rewards even though it's designed strategies shouldn't get rewards.", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/85", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/StakerVault.sol#L95 https://github.com/code-423n4/2022-05-backd/tree/main/protocol/contracts/tokenomics/LpGauge.sol#L52-L63   # Vulnerability details  ## Impact Strategy in StakerVault.sol can steal more rewards even though it's designed strategies shouldn't get rewards. Also there will be a problem with a rewarding system in LpGauge.sol so that some normal users wouldn't get rewards properly.   ## Proof of Concept 1. Strategy A staked amount x and x will be added to StakerVault.strategiesTotalStaked. contracts\\StakerVault.sol#L312 2. Strategy A transferred the amount x to non-strategy B and StakerVault.strategiesTotalStaked, StakerVault._poolTotalStaked won't be updated. contracts\\StakerVault.sol#L111 3. After some time for the larger LpGauge.poolStakedIntegral, B claims rewards using the LpGauge.claimRewards() function. contracts\\tokenomics\\LpGauge.sol#L52  Inside LpGauge.userCheckPoint(), it's designed not to calculate LpGauge.perUserShare for strategy, but it will pass this condition because B is not a strategy. contracts\\tokenomics\\LpGauge.sol#L90  Furthermore, when calculate rewards, LpGauge.poolStakedIntegral will be calculated larger than a normal user stakes same amount. It's because StakerVault._poolTotalStaked wasn't updated when A transfers x amount to B so LpGauge.poolTotalStaked is less than correct value. contracts\\tokenomics\\LpGauge.sol#L113-L117  Finally B can get more rewards than he should and the reward system will pay more rewards than it's designed.   ## Tools Used Solidity Visual Developer of VSCode   ## Recommended Mitigation Steps I think there will be two methods to fix. Method 1 is to forbid a transfer between strategy and non-strategy so that strategy can't move funds to non-strategy. Method 2 is to update StakerVault.strategiesTotalStaked and StakerVault._poolTotalStaked correctly so that strategy won't claim more rewards than he should even though he claims rewards using non-strategy.  Method 1. You need to modify two functions. StakerVault.transfer(), StakerVault.transferFrom().  1. You need to add this require() at L112 for transfer(). require(strategies[msg.sender] == strategies[account], Error.FAILED_TRANSFER);  2. You need to add this require() at L144 for transferFrom(). require(strategies[src] == strategies[dst], Error.FAILED_TRANSFER);  Method 2. I've explained about this method in my medium risk report \"StakerVault.unstake(), StakerVault.unstakeFor() would revert with a uint underflow error of StakerVault.strategiesTotalStaked, StakerVault._poolTotalStaked\" I will copy the same code for your convenience.  You need to modify 3 functions. StakerVault.addStrategy(), StakerVault.transfer(), StakerVault.transferFrom().  1. You need to move staked amount from StakerVault._poolTotalStaked to StakerVault.strategiesTotalStaked every time when StakerVault.inflationManager approves a new strategy. You can modify addStrategy() at L98-L102 like this.  function addStrategy(address strategy) external override returns (bool) { \u00a0 \u00a0 require(msg.sender == address(inflationManager), Error.UNAUTHORIZED_ACCESS); \u00a0 \u00a0 require(!strategies[strategy], Error.ADDRESS_ALREADY_SET);  \u00a0 \u00a0 strategies[strategy] = true; \u00a0 \u00a0 _poolTotalStaked -= balances[strategy]; \u00a0 \u00a0 strategiesTotalStaked += balances[strategy];  \u00a0 \u00a0 return true; }  2. You need to add below code at L126 of transfer() function.  if(strategies[msg.sender] != strategies[account]) { \u00a0 \u00a0 if(strategies[msg.sender]) { // from strategy to non-strategy \u00a0 \u00a0 \u00a0 \u00a0 _poolTotalStaked += amount; \u00a0 \u00a0 \u00a0 \u00a0 strategiesTotalStaked -= amount; \u00a0 \u00a0 } \u00a0 \u00a0 else { // from non-strategy to strategy \u00a0 \u00a0 \u00a0 \u00a0 _poolTotalStaked -= amount; \u00a0 \u00a0 \u00a0 \u00a0 strategiesTotalStaked += amount; \u00a0 \u00a0 } }  3. You need to add below code at L170 of transferFrom() function.  if(strategies[src] != strategies[dst]) { \u00a0 \u00a0 if(strategies[src]) { // from strategy to non-strategy \u00a0 \u00a0 \u00a0 \u00a0 _poolTotalStaked += amount; \u00a0 \u00a0 \u00a0 \u00a0 strategiesTotalStaked -= amount; \u00a0 \u00a0 } \u00a0 \u00a0 else { // from non-strategy to strategy \u00a0 \u00a0 \u00a0 \u00a0 _poolTotalStaked -= amount; \u00a0 \u00a0 \u00a0 \u00a0 strategiesTotalStaked += amount; \u00a0 \u00a0 } }  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/79", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/78", "labels": ["bug", "QA (Quality Assurance)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/77", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/75", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/74", "labels": ["bug", "QA (Quality Assurance)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/72", "labels": ["bug", "QA (Quality Assurance)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "QA Report"}, {"title": "Potential DoS when removing keeper gauge", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/71", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/InflationManager.sol#L609-L618 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L82 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/actions/topup/TopUpActionFeeHandler.sol#L95-L98 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/actions/topup/TopUpAction.sol#L807 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/actions/topup/TopUpAction.sol#L653   # Vulnerability details  ## Impact When `_removeKeeperGauge` is called, there is no guarantee that the keeper gauge isn't currently in use by any `TopUpActionFeeHandler`. If it's still in use, any top up action executions will be disabled as reporting fees in `KeeperGauge.sol` will revert: ``` function reportFees(     address beneficiary,     uint256 amount,     address lpTokenAddress ) external override returns (bool) {     ...     require(!killed, Error.CONTRACT_PAUSED); // gauge is killed by InflationManager     ...     return true; } ``` If this happened during extreme market movements, some positions that require a top up will not be executed and be in risk of being liquidated.  ## Proof of Concept - Alice registers a top up action. - Governance calls `InflationManager.removeKeeperGauge`, replacing an old keeper gauge. However, governance forgot to call `TopUpActionFeeHandler.prepareKeeperGauge` so `TopUpActionFeeHandler.getKeeperGauge` still points to the killed gauge. - Market moved and Alice's position should now be executed by keepers, however any attempt to execute will revert:     ```     > Keeper calls TopUpAction.execute();     > _payFees();     > IActionFeeHandler(feeHandler).payFees();     > IKeeperGauge(keeperGauge).reportFees();     > reverts as gauge is already killed     ``` - Governance noticed and calls `prepareKeeperGauge`  with a 3 days delay. - Alice's position got liquidated before the change is executed.  ## Recommended Mitigation Steps Consider adding an on-chain check to ensure that the keeper gauge is not in use before removing them.   "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/70", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "Gas Optimizations"}, {"title": "Having no clear path to define ```totalLpPoolWeight``` and initially set ```totalLpPoolWeight``` to zero maybe problematic for the protocol ", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/67", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-05-backd-findings", "body": "Having no clear path to define ```totalLpPoolWeight``` and initially set ```totalLpPoolWeight``` to zero maybe problematic for the protocol "}, {"title": "AmmGauge stakeFor/unstakeFor allow for reentrancy that can lead to stealing the whole contract balance", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/62", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-05-backd-findings", "body": "AmmGauge stakeFor/unstakeFor allow for reentrancy that can lead to stealing the whole contract balance"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/61", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/60", "labels": ["bug", "QA (Quality Assurance)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/59", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/58", "labels": ["bug", "QA (Quality Assurance)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "QA Report"}, {"title": "Missing access control in non-batched InflationManager execute funtions", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/56", "labels": ["bug", "disagree with severity", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/InflationManager.sol#L145-L155 https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/InflationManager.sol#L236-L249 https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/InflationManager.sol#L321-L330   # Vulnerability details  ## Impact  Several actions need to be prepared and go through a time-lock before they can be executed. `InflationManager` allows anyone to call the single action execute function but requires `onlyRoles2(Roles.GOVERNANCE, Roles.INFLATION_MANAGER)` for the batched versions. This looks like an oversight since the same access control level should be enforced.  For example, the `executeLpPoolWeight` function allows anyone to call it:  https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/InflationManager.sol#L241-L249  ``` function executeLpPoolWeight(address lpToken) external override returns (uint256) {    (...) } ```   But the batched version enforces the caller to have `GOVERNANCE` or `INFLATION_MANAGER` roles:  https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/InflationManager.sol#L284-L301  ``` function batchExecuteLpPoolWeights(address[] calldata lpTokens)         external         override         onlyRoles2(Roles.GOVERNANCE, Roles.INFLATION_MANAGER)         returns (bool)     { ```  The same happens in `executeAmmTokenWeight` versus `batchExecuteAmmTokenWeights` , as well as `executeKeeperPoolWeight` versus `batchExecuteKeeperPoolWeights`.  If only trusted roles should be able to execute pending actions then the `onlyRoles` modifier should be added to the non-batched functions.  Scenarios where you would not want to allow anyone to execute could include potential votes/changes that may trigger a bug or undesired behavior noticed after it had already been approved.  ## Tools Used  vim  ## Recommended Mitigation Steps  Enforce the proper access control mechanism in non-batched execute functions.  "}, {"title": "KeeperGauge: When the Gauge is killed, the epoch can continue to increase, which may DOS the claimRewards function", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/51", "labels": ["bug", "disagree with severity", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L157-L161   # Vulnerability details  ## Impact When the Gauge is killed, the advanceEpoch and kill functions can still be called to make epoch+1, while the reportFees function cannot be called to update the value of perPeriodTotalFees, which will cause perPeriodTotalFees[epoch] == 0. Later if the user calls the claimRewards function, the default epoch parameter will cause a divide by zero crash in the code below. ```` for (uint256 i = startEpoch; i < endEpoch; i = i.uncheckedInc()) {              totalClaimable += (                  keeperRecords[beneficiary].feesInPeriod[i].scaledDiv(perPeriodTotalFees[i])              ).scaledMul(perPeriodTotalInflation[i]);          } ```` ## Proof of Concept https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L157-L161 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L96-L100 https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L57-L62 ## Tools Used None ## Recommended Mitigation Steps Require killed to be false in poolCheckpoint function ```     function poolCheckpoint() public override returns (bool) { -       if (killed) return false; +      require(!killed);         uint256 timeElapsed = block.timestamp - uint256(lastUpdated);         uint256 currentRate = IController(controller).inflationManager().getKeeperRateForPool(pool);         perPeriodTotalInflation[epoch] += currentRate * timeElapsed;         lastUpdated = uint48(block.timestamp);         return true;     } ```  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/49", "labels": ["bug", "QA (Quality Assurance)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/48", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "Gas Optimizations"}, {"title": "Amount distributed can be inaccurate when updating weights ", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/47", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "# Lines of code   https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/Minter.sol#L220  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/tokenomics/InflationManager.sol#L559  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/tokenomics/InflationManager.sol#L572  https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/tokenomics/InflationManager.sol#L586   # Vulnerability details   ## Impact  When updating pool inflation rates, other pools see their `currentRate` being modified without having `poolCheckpoint` called, which leads to false computations.  This will lead to either users losing a part of their claims, but can also lead to too many tokens could be distributed, preventing some users from claiming due to the `totalAvailableToNow` requirement in `Minter`.  ## Proof of concept  Imagine you have 2 AMM pools A and B, both with an `ammPoolWeight` of 100, where `poolCheckpoint` has not been called for a moment. Then, imagine calling [`executeAmmTokenWeight`](https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/tokenomics/InflationManager.sol#L318) to reduce the weight of A to 0.   Only A is checkpointed [here](https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/tokenomics/InflationManager.sol#L591), so when B will be checkpointed it will call `getAmmRateForToken`, which will see a pool weight of 100 and a total weight of 100 over the whole period since the last checkpoint of B, which is false, therefore it will distribute too many tokens. This is critical has the minter expects an exact or lower than expected distribution due to the requirement of `totalAvailableToNow`.  In the opposite direction, when increasing weights, it will lead to less tokens being distributed in some pools than planned, leading to a loss for users.  ## Mitigation steps Checkpoint every `LpStakerVault`, `KeeperGauge` or `AmmGauge` when updating the weights of one of them.    "}, {"title": "Total Supply is not guaranteed and is not deterministic.", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/46", "labels": ["bug", "3 (High Risk)", "disagree with severity", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "# Lines of code   https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/tokenomics/Minter.sol#L181   # Vulnerability details  ## Impact The actual total supply of the token is random and depends on when `_executeInflationRateUpdate` is executed.  ## Proof of concept The `README` and tokenomic documentation clearly states that \u201cThe token supply is limited to a total of\u00a0268435456\u00a0tokens.\u201d. However when executing [`_executeInflationRateUpdate`](https://github.com/code-423n4/2022-04-backd/blob/c856714a50437cb33240a5964b63687c9876275b/backd/contracts/tokenomics/Minter.sol#L181), it first uses the current inflation rate to update the total available before checking if it needs to be reduced.   Therefore if no one mints or calls `executeInflationRateUpdate` for some time around the decay point, the inflation will be updated using the previous rate so the  `totalAvailableToNow` will grow too much.  ## Mitigation steps  You should do ```js\u2028 totalAvailableToNow += (currentTotalInflation * (block.timestamp - lastEvent)); ```  Only if the condition `block.timestamp >= lastInflationDecay + _INFLATION_DECAY_PERIOD` is false.   Otherwise you should do   ```js\u2028 totalAvailableToNow += (currentTotalInflation * (lastInflationDecay + _INFLATION_DECAY_PERIOD - lastEvent));\u2028 ```  Then update the rates, then complete with ```js\u2028 totalAvailableToNow += (currentTotalInflation * (block.timestamp - lastInflationDecay + _INFLATION_DECAY_PERIOD));\u2028 ```  Note that as all these variables are either constants either already loaded in memory this is super cheap to do.   "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/45", "labels": ["bug", "QA (Quality Assurance)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "QA Report"}, {"title": "FeeBurner initiates swap without any slippage checks if Chainlink oracle fails ", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/44", "labels": ["bug", "2 (Med Risk)", "sponsor disputed"], "target": "2022-05-backd-findings", "body": "FeeBurner initiates swap without any slippage checks if Chainlink oracle fails "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/42", "labels": ["bug", "QA (Quality Assurance)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/40", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "Gas Optimizations"}, {"title": "DoS on KeeperGauge due to division by zero", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/35", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L151-L164   # Vulnerability details  ## Impact In the **_calcTotalClaimable()** function it should be validated that perPeriodTotalFees[i] != 0 since otherwise it would generate a DoS in **claimableRewards()** and **claimRewards()**. This would be possible since if **advanceEpoch()** or **kill()** is executed by the InflationManager address, the epoch will go up without perPeriodTotalFees[newIndexEpoch] is 0. The negative of this is that every time the **InflationManager** executes these two methods (**kill() and advanceEpoch()**) DoS is generated until you run **reportFees()**. Another possible case is that **kill()** or **advanceEpoch()** are executed 2 times in a row and there is no way of a perPeriodTotalFees[epoch-1] updating its value, therefore it would be an irreversible DoS.  ## Recommended Mitigation Steps Generate a behavior for the case that perPeriodTotalFees[i] == 0.   "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/34", "labels": ["bug", "QA (Quality Assurance)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/32", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/27", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/25", "labels": ["bug", "QA (Quality Assurance)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/24", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/22", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/18", "labels": ["bug", "QA (Quality Assurance)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/17", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/16", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/14", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "Gas Optimizations"}, {"title": "User rewards would be lost", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/12", "labels": ["bug", "disagree with severity", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/tokenomics/AmmGauge.sol#L103   # Vulnerability details  ## Impact Staking is not stopped even when Gauge is killed. User will not be getting any reward for the staked asset.  ## Proof of Concept 1. Assume the AMMGauge is killed using kill function (AmmGauge.sol#L49). This sets killed as true  2. poolCheckpoint will not further increase ammStakedIntegral and would simply return false  ``` function poolCheckpoint() public virtual override returns (bool) {         if (killed) {             return false;         }   ...   } ```  3. User calls stakeFor function and is still able to stake amount.   4. The drawback will be no rewards as poolCheckpoint will only return false and will not update ammStakedIntegral  ## Recommended Mitigation Steps Add below check in stakeFor function, restricting deposit if Gauge is killed  ``` require(!killed, \"Gauge killed\"); ```  "}, {"title": "BkdLocker depositFees can be blocked", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/8", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-backd/blob/main/protocol/contracts/RewardHandler.sol#L50   # Vulnerability details  ## Impact burnFees will fail if none of the pool tokens have underlying token as native ETH token. This is shown below. Since burnFees fails so no fees is deposited in BKDLocker  ## Proof of Concept 1. Assume RewardHandler.sol has currently amount 5 as address(this).balance (ethBalance) (even attacker can send a small balance to this contract to do this dos attack) 2. None of the pools have underlying as address(0) so no ETH tokens and only ERC20 tokens are present 3. Now feeBurner.burnToTarget is called passing current ETH balance of amount 5 with all pool tokens 4. feeBurner loops through all tokens and swap them to WETH. Since none of the token is ETH so burningEth_ variable is false 5. Now the below require condition fails since burningEth_ is false   ``` require(burningEth_ || msg.value == 0, Error.INVALID_VALUE); ```  6. This fails the burnFees function.  ## Recommended Mitigation Steps ETH should not be sent if none of pool underlying token is ETH. Change it to something like below:  ``` bool ethFound=false; for (uint256 i; i < pools.length; i = i.uncheckedInc()) {             ILiquidityPool pool = ILiquidityPool(pools[i]);             address underlying = pool.getUnderlying();             if (underlying != address(0)) {                 _approve(underlying, address(feeBurner));             } else { ethFound=true; }             tokens[i] = underlying;         }  if(ethFound){         feeBurner.burnToTarget{value: ethBalance}(tokens, targetLpToken); } else { feeBurner.burnToTarget(tokens, targetLpToken); } ```  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/5", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "Gas Optimizations"}, {"title": "Not following the Checks-Effects-Interactions pattern", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/3", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-05-backd-findings", "body": "Not following the Checks-Effects-Interactions pattern"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-backd-findings/issues/2", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-05-backd-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/277", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-connext-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/276", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-connext-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/274", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-connext-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/272", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-connext-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/271", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-connext-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/270", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-connext-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/265", "labels": ["bug", "duplicate", "G (Gas Optimization)"], "target": "2022-06-connext-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/264", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-06-connext-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/263", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-connext-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/261", "labels": ["bug", "duplicate", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-06-connext-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/258", "labels": ["bug", "G (Gas Optimization)", "resolved"], "target": "2022-06-connext-findings", "body": "Gas Optimizations"}, {"title": "Swaps done internally will be not be possible", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/249", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-06-connext-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/facets/BridgeFacet.sol#L346 https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/facets/BridgeFacet.sol#L812   # Vulnerability details    Affected  functions(that rely on swapAsset()) are:  [https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/libraries/AssetLogic.sol#L193](https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/libraries/AssetLogic.sol#L193)  [https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/libraries/AssetLogic.sol#L159](https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/libraries/AssetLogic.sol#L159)  swapAsset() facilitates two swaps, either using the internal or external pool. But if an internal pool exists, a swap will be unsuccessful because the call to  s.swapStorages[_canonicalId].swapInternal() takes two incorrect arguments (due to an incorrect ordering, this seemed to be an oversight, acknowledged by #Layne) :  [https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/libraries/AssetLogic.sol#L278-L279](https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/libraries/AssetLogic.sol#L278-L279)  Based on the above mentioned code , the arguments would be incorrectly changed to :  [https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/libraries/SwapUtils.sol#L744-L745](https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/libraries/SwapUtils.sol#L744-L745)  The condition checked here:  [https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/libraries/SwapUtils.sol#L750](https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/libraries/SwapUtils.sol#L750)  will never be true as the msg.sender would never own the quantity of tokens being swapped from since it's the wrong token.  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/247", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-connext-findings", "body": "QA Report"}, {"title": "Diamond upgrade proposition can be falsified", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/241", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-06-connext-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/facets/DiamondCutFacet.sol#L16-L29 https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/libraries/LibDiamond.sol#L94-L118 https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/libraries/LibDiamond.sol#L222-L240   # Vulnerability details  ## Impact Diamond is to be upgraded after a certain delay to give time to the community to verify changes made by the developers. If the proposition can be falsified, the contract admins can exploit the contract in any way of their choice.  ## Proof of Concept To determine the id of the proposal, only its facet changes are hashed, skipping two critical pieces of data - the `_init` and `_calldata`. During a diamond upgrade, devs can choose what code will be executed **by the contract using a delegatecall**. Thus, they can make the contract perform **any** actions of their choice.  ## Tools Used Manual analysis  ## Recommended Mitigation Steps Add `_init` and `_calldata` to the proposition hash.   "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/238", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-connext-findings", "body": "QA Report"}, {"title": "in reimburseLiquidityFees() of SponserVault contract swaps tokens without slippage limit so its possible to perform sandwich attack and it create MEV", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/237", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-06-connext-findings", "body": "in reimburseLiquidityFees() of SponserVault contract swaps tokens without slippage limit so its possible to perform sandwich attack and it create MEV"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/236", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-connext-findings", "body": "QA Report"}, {"title": "Malicious relayer could exploit sponsor vaults", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/234", "labels": ["bug", "2 (Med Risk)", "resolved"], "target": "2022-06-connext-findings", "body": "Malicious relayer could exploit sponsor vaults"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/233", "labels": ["bug", "G (Gas Optimization)", "resolved"], "target": "2022-06-connext-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/232", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-connext-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/231", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-connext-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/230", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-connext-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/229", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-connext-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/226", "labels": ["bug", "duplicate", "G (Gas Optimization)"], "target": "2022-06-connext-findings", "body": "Gas Optimizations"}, {"title": "attacker can perform griefing for process() in PromiseRouter by reverting calls to callback() in callbackAddress", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/225", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-06-connext-findings", "body": "attacker can perform griefing for process() in PromiseRouter by reverting calls to callback() in callbackAddress"}, {"title": "Current implementation of arbitrary call execute failure handler may break some use case for example NFT bridge.", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/223", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-06-connext-findings", "body": "Current implementation of arbitrary call execute failure handler may break some use case for example NFT bridge."}, {"title": "In execute() the amount routers pay is what user signed, but in _reconcile() the amount routers get is what nomad sends and this two amount are not necessary equal because of slippage in original domain", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/222", "labels": ["bug", "3 (High Risk)"], "target": "2022-06-connext-findings", "body": "In execute() the amount routers pay is what user signed, but in _reconcile() the amount routers get is what nomad sends and this two amount are not necessary equal because of slippage in original domain"}, {"title": "Relayer Will Not Receive Any Fee If `execute` Reverts", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/220", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-06-connext-findings", "body": "Relayer Will Not Receive Any Fee If `execute` Reverts"}, {"title": "`LibDiamond.diamondCut()` should check `diamondStorage().acceptanceTimes[keccak256(abi.encode(_diamondCut))] != 0`", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/215", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-06-connext-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/libraries/LibDiamond.sol#L100-L103 https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/libraries/LibDiamond.sol#L71-L79 https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/libraries/LibDiamond.sol#L83-L90   # Vulnerability details  ## Impact  Normally, `diamondStorage().acceptanceTimes[keccak256(abi.encode(_diamondCut))]` will be set in `LibDiamond.proposeDiamondCut()`. Then in `LibDiamond.diamondCut()`, it checks that `diamondStorage().acceptanceTimes[keccak256(abi.encode(_diamondCut))] < block.timestamp`.  However, `LibDiamond.rescindDiamondCut()` will set `diamondStorage().acceptanceTimes[keccak256(abi.encode(_diamondCut))]` to 0. Which can easily pass the check in `diamondCut()`. But `rescindDiamondCut` should rescind `_diamondCut`. In conclusion, using `rescindDiamondCut()` can easily bypass the delay time.  Moreover, if `proposeDiamondCut()` has never been called, the check for delay time is always passed.  ## Proof of Concept  `diamondStorage().acceptanceTimes[keccak256(abi.encode(_diamondCut))]` will be set in `LibDiamond.proposeDiamondCut()` https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/libraries/LibDiamond.sol#L71-L79 ```   function proposeDiamondCut(     IDiamondCut.FacetCut[] memory _diamondCut,     address _init,     bytes memory _calldata   ) internal {     uint256 acceptance = block.timestamp + _delay;     diamondStorage().acceptanceTimes[keccak256(abi.encode(_diamondCut))] = acceptance;     emit DiamondCutProposed(_diamondCut, _init, _calldata, acceptance);   } ```  Then in `LibDiamond.diamondCut()`, it checks that `diamondStorage().acceptanceTimes[keccak256(abi.encode(_diamondCut))] < block.timestamp` https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/libraries/LibDiamond.sol#L100-L103 ```   function diamondCut(     IDiamondCut.FacetCut[] memory _diamondCut,     address _init,     bytes memory _calldata   ) internal {     require(       diamondStorage().acceptanceTimes[keccak256(abi.encode(_diamondCut))] < block.timestamp,       \"LibDiamond: delay not elapsed\"     );     \u2026   } ```  However, `LibDiamond.rescindDiamondCut()` will set `diamondStorage().acceptanceTimes[keccak256(abi.encode(_diamondCut))]` to 0. Which can easily pass the check in `diamondCut()` https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/libraries/LibDiamond.sol#L83-L90 ```   function rescindDiamondCut(     IDiamondCut.FacetCut[] memory _diamondCut,     address _init,     bytes memory _calldata   ) internal {     diamondStorage().acceptanceTimes[keccak256(abi.encode(_diamondCut))] = 0;     emit DiamondCutRescinded(_diamondCut, _init, _calldata);   } ```  ``` diamondStorage().acceptanceTimes[keccak256(abi.encode(_diamondCut))] = 0 < block.timestamp ```   ## Tools Used  None  ## Recommended Mitigation Steps  Add another check in `diamondCut`  ```   function diamondCut(     IDiamondCut.FacetCut[] memory _diamondCut,     address _init,     bytes memory _calldata   ) internal {     require(       diamondStorage().acceptanceTimes[keccak256(abi.encode(_diamondCut))] < block.timestamp && diamondStorage().acceptanceTimes[keccak256(abi.encode(_diamondCut))] != 0,       \"LibDiamond: delay not elapsed\"     );     \u2026   } ```   "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/214", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-connext-findings", "body": "QA Report"}, {"title": "division rounding error in _handleExecuteLiquidity() and _reconcile() make routerBalances and contract fund balance to get out of sync and cause fund lose", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/213", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-06-connext-findings", "body": "division rounding error in _handleExecuteLiquidity() and _reconcile() make routerBalances and contract fund balance to get out of sync and cause fund lose"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/212", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-connext-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/210", "labels": ["bug", "duplicate", "G (Gas Optimization)"], "target": "2022-06-connext-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/209", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-connext-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/208", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-connext-findings", "body": "QA Report"}, {"title": "Tokens with `decimals` larger than `18` are not supported", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/204", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-06-connext-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/helpers/ConnextPriceOracle.sol#L99-L115   # Vulnerability details  For tokens with decimals larger than 18, many functions across the codebase will revert due to underflow.  https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/helpers/ConnextPriceOracle.sol#L99-L115  ```solidity function getPriceFromDex(address _tokenAddress) public view returns (uint256) {     PriceInfo storage priceInfo = priceRecords[_tokenAddress];     if (priceInfo.active) {       uint256 rawTokenAmount = IERC20Extended(priceInfo.token).balanceOf(priceInfo.lpToken);       uint256 tokenDecimalDelta = 18 - uint256(IERC20Extended(priceInfo.token).decimals());       uint256 tokenAmount = rawTokenAmount.mul(10**tokenDecimalDelta);       uint256 rawBaseTokenAmount = IERC20Extended(priceInfo.baseToken).balanceOf(priceInfo.lpToken);       uint256 baseTokenDecimalDelta = 18 - uint256(IERC20Extended(priceInfo.baseToken).decimals());       uint256 baseTokenAmount = rawBaseTokenAmount.mul(10**baseTokenDecimalDelta);       uint256 baseTokenPrice = getTokenPrice(priceInfo.baseToken);       uint256 tokenPrice = baseTokenPrice.mul(baseTokenAmount).div(tokenAmount);        return tokenPrice;     } else {       return 0;     }   } ```  https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/facets/StableSwapFacet.sol#L426  ```solidity precisionMultipliers[i] = 10**uint256(SwapUtils.POOL_PRECISION_DECIMALS - decimals[i]); ```  Chainlink feeds' with decimals > 18 are not supported neither:  https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/helpers/ConnextPriceOracle.sol#L122-L140  ```solidity function getPriceFromChainlink(address _tokenAddress) public view returns (uint256) {     AggregatorV3Interface aggregator = aggregators[_tokenAddress];     if (address(aggregator) != address(0)) {       (, int256 answer, , , ) = aggregator.latestRoundData();        // It's fine for price to be 0. We have two price feeds.       if (answer == 0) {         return 0;       }        // Extend the decimals to 1e18.       uint256 retVal = uint256(answer);       uint256 price = retVal.mul(10**(18 - uint256(aggregator.decimals())));        return price;     }      return 0;   } ```  ### Recommendation  Consider checking if decimals > 18 and normalize the value by div the decimals difference.  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/203", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-connext-findings", "body": "QA Report"}, {"title": "Wrong implementation of `withdrawAdminFees()` can cause the `adminFees` to be charged multiple times and therefore cause users' fund loss", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/202", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2022-06-connext-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/libraries/SwapUtils.sol#L1053-L1062   # Vulnerability details  ```solidity function withdrawAdminFees(Swap storage self, address to) internal {   IERC20[] memory pooledTokens = self.pooledTokens;   for (uint256 i = 0; i < pooledTokens.length; i++) {     IERC20 token = pooledTokens[i];     uint256 balance = self.adminFees[i];     if (balance != 0) {       token.safeTransfer(to, balance);     }   } } ```  `self.adminFees[i]` should be reset to 0 every time it's withdrawn. Otherwise, the `adminFees` can be withdrawn multiple times.  The admin may just be unaware of this issue and casualty `withdrawAdminFees()` from time to time, and rug all the users slowly.  ### Recommendation  Change to:  ```solidity function withdrawAdminFees(Swap storage self, address to) internal {   IERC20[] memory pooledTokens = self.pooledTokens;   for (uint256 i = 0; i < pooledTokens.length; i++) {     IERC20 token = pooledTokens[i];     uint256 balance = self.adminFees[i];     if (balance != 0) {       self.adminFees[i] = 0;       token.safeTransfer(to, balance);     }   } } ```  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/201", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-connext-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/200", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-06-connext-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/198", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-connext-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/197", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-connext-findings", "body": "Gas Optimizations"}, {"title": "_handleExecuteTransaction may not working correctly on fee-on-transfer tokens. Moreover, if it is failed, fund may be locked forever.", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/196", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor acknowledged"], "target": "2022-06-connext-findings", "body": "_handleExecuteTransaction may not working correctly on fee-on-transfer tokens. Moreover, if it is failed, fund may be locked forever."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/195", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-connext-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/194", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-06-connext-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/193", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-connext-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/192", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-connext-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/190", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-06-connext-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/188", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-connext-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/186", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-connext-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/185", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-connext-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/184", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-connext-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/183", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-connext-findings", "body": "QA Report"}, {"title": "BridgeFacet's _executePortalTransfer ignores underlying token amount withdrawn from Aave pool", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/181", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-06-connext-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/facets/BridgeFacet.sol#L882-L900   # Vulnerability details  _executePortalTransfer can introduce underlying token deficit by accounting for full underlying amount received from Aave unconditionally on what was actually withdrawn from Aave pool. Actual amount withdrawn is returned by `IAavePool(s.aavePool).withdraw()`, but currently is not used.  Setting the severity to medium as this can end up with a situation of partial insolvency, when where are a surplus of atokens, but deficit of underlying tokens in the bridge, so bridge functionality can become unavailable as there will be not enough underlying tokens, which were used up in the previous operations when atokens wasn't converted to underlying fully and underlying tokens from other operations were used up instead without accounting. I.e. the system in this situation supposes that all atokens are in the form of underlying tokens while there will be some atokens left unconverted due to withdrawal being only partial.  ## Proof of Concept  Call sequence here is execute() -> _handleExecuteLiquidity() -> _executePortalTransfer().   BridgeFacet._executePortalTransfer() mints the atokens needed, then withdraws them from Aave pool, always accounting for the full withdrawal:  https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/facets/BridgeFacet.sol#L882-L900  ```solidity   /**    * @notice Uses Aave Portals to provide fast liquidity    */   function _executePortalTransfer(     bytes32 _transferId,     uint256 _fastTransferAmount,     address _local,     address _router   ) internal returns (uint256, address) {     // Calculate local to adopted swap output if needed     (uint256 userAmount, address adopted) = AssetLogic.calculateSwapFromLocalAssetIfNeeded(_local, _fastTransferAmount);      IAavePool(s.aavePool).mintUnbacked(adopted, userAmount, address(this), AAVE_REFERRAL_CODE);      // Improvement: Instead of withdrawing to address(this), withdraw directly to the user or executor to save 1 transfer     IAavePool(s.aavePool).withdraw(adopted, userAmount, address(this));      // Store principle debt     s.portalDebt[_transferId] = userAmount; ```   Aave pool's withdraw() returns the amount of underlying asset that was actually withdrawn:  https://github.com/aave/aave-v3-core/blob/master/contracts/protocol/pool/Pool.sol#L196-L217  https://github.com/aave/aave-v3-core/blob/master/contracts/protocol/libraries/logic/SupplyLogic.sol#L93-L111  If a particular lending pool has liquidity shortage at the moment, say all underlying is lent out, full withdrawal of the requested underlying token amount will not be possible.  ## Recommended Mitigation Steps  Consider adjusting for the amount actually withdrawn. Also the buffer that stores minted but not yet used atoken amount, say aAmountStored, can be introduced.  For example:   ```  +   uint256 amountNeeded = userAmount < aAmountStored ? 0 : userAmount - aAmountStored;  -   IAavePool(s.aavePool).mintUnbacked(adopted, userAmount, address(this), AAVE_REFERRAL_CODE); +   if (amountNeeded > 0) { +       IAavePool(s.aavePool).mintUnbacked(adopted, amountNeeded, address(this), AAVE_REFERRAL_CODE); +   }      // Improvement: Instead of withdrawing to address(this), withdraw directly to the user or executor to save 1 transfer -   IAavePool(s.aavePool).withdraw(adopted, userAmount, address(this)); +   uint256 amountWithdrawn = IAavePool(s.aavePool).withdraw(adopted, userAmount, address(this));      // Store principle debt -   s.portalDebt[_transferId] = userAmount; +   s.portalDebt[_transferId] = amountWithdrawn; // can't exceed userAmount +   aAmountStored = (userAmount < aAmountStored ? aAmountStored : userAmount) - amountWithdrawn; // we used amountWithdrawn  ```  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/180", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-connext-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/179", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-connext-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/178", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-connext-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/177", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-connext-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/176", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-connext-findings", "body": "QA Report"}, {"title": "Missing whenNotPaused modifier", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/175", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-06-connext-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/facets/StableSwapFacet.sol#L279-L286   # Vulnerability details  ## Impact In `StableSwapFacet.sol`, two swapping functions contain the `whenNotPaused` modifier while `swapExactOut()` and `addSwapLiquidity()` do not. All functions to swap and add liquidity should contain the same modifiers to stop transactions while paused.   ## Proof of Concept ***Example with modifier*** ```   function swapExact(     bytes32 canonicalId,     uint256 amountIn,     address assetIn,     address assetOut,     uint256 minAmountOut,     uint256 deadline   ) external payable nonReentrant deadlineCheck(deadline) whenNotPaused returns (uint256) { ```  ***Examples without modifier*** ```   function swapExactOut(     bytes32 canonicalId,     uint256 amountOut,     address assetIn,     address assetOut,     uint256 maxAmountIn,     uint256 deadline   ) external payable nonReentrant deadlineCheck(deadline) returns (uint256) { ```  and  ```   function addSwapLiquidity(     bytes32 canonicalId,     uint256[] calldata amounts,     uint256 minToMint,     uint256 deadline   ) external nonReentrant deadlineCheck(deadline) returns (uint256) {     return s.swapStorages[canonicalId].addLiquidity(amounts, minToMint);   } ```  ## Tools Used Manual review.  ## Recommended Mitigation Steps Add the `whenNotPaused` modifier to all functions that perform swaps or liquidity additions.  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/173", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-connext-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/169", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-connext-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/168", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-connext-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/167", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-connext-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/166", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-connext-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/164", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-connext-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/163", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-connext-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/161", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-connext-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/156", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-connext-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/155", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-connext-findings", "body": "QA Report"}, {"title": "Did Not Approve To Zero First Causing Certain Token Transfer To Fail", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/154", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-06-connext-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/BridgeFacet.sol#L984 https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/libraries/AssetLogic.sol#L347   # Vulnerability details  ## Proof-of-Concept  Some tokens (like USDT) do not work when changing the allowance from an existing non-zero allowance value. For example Tether (USDT)'s `approve()` function will revert if the current approval is not zero, to protect against front-running changes of approvals.  #### Instance 1 - `BridgeFacet._reconcileProcessPortal`  The following function must be approved by zero first, and then the ` SafeERC20.safeIncreaseAllowance` function can be called. Otherwise, the `_reconcileProcessPortal` function will revert everytime it handles such kind of tokens. Understood from the [comment](https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/BridgeFacet.sol#L1025) that after the backUnbacked call there could be a remaining allowance.  [https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/BridgeFacet.sol#L984](https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/BridgeFacet.sol#L984)  ```solidity   function _reconcileProcessPortal(     uint256 _amount,     address _local,     address _router,     bytes32 _transferId   ) private returns (uint256) {    ..SNIP..     SafeERC20.safeIncreaseAllowance(IERC20(adopted), s.aavePool, totalRepayAmount);      (bool success, ) = s.aavePool.call(       abi.encodeWithSelector(IAavePool.backUnbacked.selector, adopted, backUnbackedAmount, portalFee)     );    ..SNIP..   } ```  #### Instance 2 - `BridgeFacet_swapAssetOut`  The following fucntion must first be approved by zero, follow by the actual allowance to be approved. Otherwise, the `_swapAssetOut` function will revert everytime it handles such kind of tokens.  [https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/libraries/AssetLogic.sol#L347](https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/libraries/AssetLogic.sol#L347)  ```solidity   function _swapAssetOut(     bytes32 _canonicalId,     address _assetIn,     address _assetOut,     uint256 _amountOut,     uint256 _maxIn   )     internal     returns (       bool,       uint256,       address     )   {     AppStorage storage s = LibConnextStorage.connextStorage();      bool success;     uint256 amountIn;      // Swap the asset to the proper local asset     if (stableSwapPoolExist(_canonicalId)) {       // get internal swap pool       SwapUtils.Swap storage ipool = s.swapStorages[_canonicalId];       // if internal swap pool exists       uint8 tokenIndexIn = getTokenIndexFromStableSwapPool(_canonicalId, _assetIn);       uint8 tokenIndexOut = getTokenIndexFromStableSwapPool(_canonicalId, _assetOut);       // calculate slippage before performing swap       // NOTE: this is less efficient then relying on the `swapInternalOut` revert, but makes it easier       // to handle slippage failures (this can be called during reconcile, so must not fail)       if (_maxIn >= ipool.calculateSwapInv(tokenIndexIn, tokenIndexOut, _amountOut)) {         success = true;         amountIn = ipool.swapInternalOut(tokenIndexIn, tokenIndexOut, _amountOut, _maxIn);       }       // slippage is too high to perform swap: success = false, amountIn = 0     } else {       // Otherwise, swap via stable swap pool       IStableSwap pool = s.adoptedToLocalPools[_canonicalId];       uint256 _amountIn = pool.calculateSwapOutFromAddress(_assetIn, _assetOut, _amountOut);       if (_amountIn <= _maxIn) {         // set the success         success = true;          // perform the swap         SafeERC20.safeApprove(IERC20(_assetIn), address(pool), _amountIn);         amountIn = pool.swapExactOut(_amountOut, _assetIn, _assetOut, _maxIn);       }       // slippage is too high to perform swap: success = false, amountIn = 0     }      return (success, amountIn, _assetOut);   } ```  ## Impact  Both the`_reconcileProcessPortal` and `_swapAssetOut` functions are called during repayment to Aave Portal if the fast-transfer was executed using portal liquidity. Thus, it is core part of the token transfer process within Connext, and failure of any of these functions would disrupt the AAVE repayment process.  Since both functions affect the AAVE repayment process, I'm grouping them as one issue.  ## Recommended Mitigation Steps  As Connext bridges/routers deal with all sort of tokens existed in various domains/chains, the protocol should try to implement measure to ensure that it is compatible with as much tokens as possible for future growth and availability of the protocol.  #### Instance 1 - `BridgeFacet._reconcileProcessPortal`  It is recommended to set the allowance to zero before increasing the allowance  ```solidity SafeERC20.safeApprove(IERC20(_assetIn), address(pool), 0); SafeERC20.safeIncreaseAllowance(IERC20(adopted), s.aavePool, totalRepayAmount); ```  #### Instance 2 - `BridgeFacet_swapAssetOut`  It is recommended to set the allowance to zero before each approve call.  ```solidity SafeERC20.safeApprove(IERC20(_assetIn), address(pool), 0); SafeERC20.safeApprove(IERC20(_assetIn), address(pool), _amountIn); ```  "}, {"title": "Router Owner Could Be Rugged By Admin", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/150", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-06-connext-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/RoutersFacet.sol#L293 https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/RoutersFacet.sol#L490 https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/RoutersFacet.sol#L212   # Vulnerability details  ## Proof-of-Concept  Assume that Alice's router has large amount of liquidity inside.  Assume that the Connext Admin decided to remove a router owned by Alice. The Connext Admin will call the `RoutersFacet.removeRouter` function, and all information related to Alice's router will be erased (set to 0x0) from the `s.routerPermissionInfo`.  [https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/RoutersFacet.sol#L293](https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/RoutersFacet.sol#L293)  ```solidity   function removeRouter(address router) external onlyOwner {     // Sanity check: not empty     if (router == address(0)) revert RoutersFacet__removeRouter_routerEmpty();      // Sanity check: needs removal     if (!s.routerPermissionInfo.approvedRouters[router]) revert RoutersFacet__removeRouter_notAdded();      // Update mapping     s.routerPermissionInfo.approvedRouters[router] = false;      // Emit event     emit RouterRemoved(router, msg.sender);      // Remove router owner     address _owner = s.routerPermissionInfo.routerOwners[router];     if (_owner != address(0)) {       emit RouterOwnerAccepted(router, _owner, address(0));       // delete routerOwners[router];       s.routerPermissionInfo.routerOwners[router] = address(0);     }      // Remove router recipient     address _recipient = s.routerPermissionInfo.routerRecipients[router];     if (_recipient != address(0)) {       emit RouterRecipientSet(router, _recipient, address(0));       // delete routerRecipients[router];       s.routerPermissionInfo.routerRecipients[router] = address(0);     }      // Clear any proposed ownership changes     s.routerPermissionInfo.proposedRouterOwners[router] = address(0);     s.routerPermissionInfo.proposedRouterTimestamp[router] = 0;   } ```  Alice is aware that her router has been removed by Connext Admin, so she decided to withdraw the liquidity from her previous router by calling `RoutersFacet.removeRouterLiquidityFor`.  However, when Alice called the `RoutersFacet.removeRouterLiquidityFor` function, it will revert every single time. This is because the condition `msg.sender != getRouterOwner(_router)` will always fail.  [https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/RoutersFacet.sol#L490](https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/RoutersFacet.sol#L490)  ```solidity   /**    * @notice This is used by any router owner to decrease their available liquidity for a given asset.    * @param _amount - The amount of liquidity to remove for the router    * @param _local - The address of the asset you're removing liquidity from. If removing liquidity of the    * native asset, routers may use `address(0)` or the wrapped asset    * @param _to The address that will receive the liquidity being removed    * @param _router The address of the router    */   function removeRouterLiquidityFor(     uint256 _amount,     address _local,     address payable _to,     address _router   ) external nonReentrant whenNotPaused {     // Caller must be the router owner     if (msg.sender != getRouterOwner(_router)) revert RoutersFacet__removeRouterLiquidityFor_notOwner();      // Remove liquidity     _removeLiquidityForRouter(_amount, _local, _to, _router);   } ```  Since the `RoutersFacet.removeRouter` function has earlier erased all information related to Alice's router within `s.routerPermissionInfo`, the `getRouterOwner` function will always return the router address.  In this case, the router address will not match against `msg.sender` address/Alice address, thus Alice attempts to call `removeRouterLiquidityFor` will always revert.  [https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/RoutersFacet.sol#L212](https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/RoutersFacet.sol#L212)  ```solidity   function getRouterOwner(address _router) public view returns (address) {     address _owner = s.routerPermissionInfo.routerOwners[_router];     return _owner == address(0) ? _router : _owner;   } ```  ## Impact  Router owner who provides liquidity could be rugged by Connext admin. When this happen, the router owner funds will be struck  within the `RoutersFacet` contract, and there is no way for the router owner to retrieve their liquidity.  In the worst case scenario, a compromised Connext admin could remove all routers, and cause all liquidity to be struck within `RoutersFacet` and no router owner could withdraw their liquidity from the contract. Next, the `RouterFacet` contract could be upgraded to include additional function to withdraw all liquidity from the contract to an arbitrary wallet address.  ## Recommended Mitigation Steps  The router owner is still entitled to their own liquidity even though their router has been removed by Connext Admin. Thus, they should be given the right to take back their liquidity when such an event happens. The contract should update its implementation to support this. This will give more assurance to the router owner.  "}, {"title": "Malicious Relayer Could Cause A Router To Provide More Liquidity Than It Should", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/149", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-06-connext-findings", "body": "Malicious Relayer Could Cause A Router To Provide More Liquidity Than It Should"}, {"title": "Malicious Relayers Could Favor Their Routers", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/147", "labels": ["bug", "2 (Med Risk)"], "target": "2022-06-connext-findings", "body": "Malicious Relayers Could Favor Their Routers"}, {"title": "Single Error Within SponsorVault Contract Could Cause Entire Cross-Chain Communication To Break Down", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/146", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-06-connext-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/BridgeFacet.sol#L819](https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/BridgeFacet.sol#L819   # Vulnerability details  ## Proof-of-Concept  A third party sponsor would need to implement a `SponsorVault` contract that is aligned with the `ISponsorVault` interface.  Assume that a `SponsorVault` contract has been defined on Optimism chain. All cross-chain communications are required to call the `BridgeFacet.execute`, which in turn will trigger the `BridgeFacet._handleExecuteTransaction` internal function.   However, if there is an error within `SponsorVault` contract in Optimism causing a revert when `s.sponsorVault.reimburseLiquidityFees` or `s.sponsorVault.reimburseRelayerFees` is called, the entire `execute` transaction will revert. Since `execute` transaction always revert, any cross-chain communication between Optimism and other domains will fail.  [https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/BridgeFacet.sol#L819](https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/BridgeFacet.sol#L819)  ```solidity   /**    * @notice Process the transfer, and calldata if needed, when calling `execute`    * @dev Need this to prevent stack too deep    */   function _handleExecuteTransaction(     ExecuteArgs calldata _args,     uint256 _amount,     address _asset, // adopted (or local if specified)     bytes32 _transferId,     bool _reconciled   ) private returns (uint256) {     // If the domain if sponsored     if (address(s.sponsorVault) != address(0)) {       // fast liquidity path       if (!_reconciled) {         // Vault will return the amount of the fee they sponsored in the native fee         // NOTE: some considerations here around fee on transfer tokens and ensuring         // there are no malicious `Vaults` that do not transfer the correct amount. Should likely do a         // balance read about it          uint256 starting = IERC20(_asset).balanceOf(address(this));         uint256 sponsored = s.sponsorVault.reimburseLiquidityFees(_asset, _args.amount, _args.params.to);          // Validate correct amounts are transferred         if (IERC20(_asset).balanceOf(address(this)) != starting + sponsored) {           revert BridgeFacet__handleExecuteTransaction_invalidSponsoredAmount();         }          _amount = _amount + sponsored;       }        // Should dust the recipient with the lesser of a vault-defined cap or the converted relayer fee       // If there is no conversion available (i.e. no oracles for origin domain asset <> dest asset pair),       // then the vault should just pay out the configured constant       s.sponsorVault.reimburseRelayerFees(_args.params.originDomain, payable(_args.params.to), _args.params.relayerFee);     }     ..SNIP.. ```  ## Impact  It will result in denial of service. The `SponsorVault` contract, which belongs to a third-party, is a single point of failure for a domain.  ## Recommended Mitigation Steps  This is a problem commonly encountered whenever a method of a smart contract calls another contract \u2013 we cannot rely on the other contract to work 100% of the time, and it is dangerous to assume that the external call will always be successful. Additionally, external smart contract might be vulnerable and compromised by an attacker. Even if the team has audited or review the SponsorVault before whitelisting them, some risk might still exist.  Therefore, it is recommended to implement a fail-safe design where failure of an external call to SponsorVault will not disrupt the cross-chain communication. Consider implementing a try-catch block as shown below. If there is any issue with the external `SponsorVault ` contract, no funds are reimbursed to the users in the worst case scenario, but the issue will not cause any impact to the cross-chain communication.  ```diff function _handleExecuteTransaction(  ExecuteArgs calldata _args,  uint256 _amount,  address _asset, // adopted (or local if specified)  bytes32 _transferId,  bool _reconciled ) private returns (uint256) {  // If the domain if sponsored  if (address(s.sponsorVault) != address(0)) {    // fast liquidity path    if (!_reconciled) {   // Vault will return the amount of the fee they sponsored in the native fee   // NOTE: some considerations here around fee on transfer tokens and ensuring   // there are no malicious `Vaults` that do not transfer the correct amount. Should likely do a   // balance read about it    uint256 starting = IERC20(_asset).balanceOf(address(this)); +  try s.sponsorVault.reimburseLiquidityFees(_asset, _args.amount, _args.params.to) returns (uint256 sponsored) { +   // Validate correct amounts are transferred +   if (IERC20(_asset).balanceOf(address(this)) != starting + sponsored) { +     revert BridgeFacet__handleExecuteTransaction_invalidSponsoredAmount(); +   } + +   _amount = _amount + sponsored; +  } catch {}    }     // Should dust the recipient with the lesser of a vault-defined cap or the converted relayer fee    // If there is no conversion available (i.e. no oracles for origin domain asset <> dest asset pair),    // then the vault should just pay out the configured constant +   try s.sponsorVault.reimburseRelayerFees(_args.params.originDomain, payable(_args.params.to), _args.params.relayerFee) {} catch {}  ..SNIP.. ```  "}, {"title": "Router Owner Could Steal All The Funds Within SponsorVault", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/145", "labels": ["bug", "3 (High Risk)", "sponsor acknowledged"], "target": "2022-06-connext-findings", "body": "Router Owner Could Steal All The Funds Within SponsorVault"}, {"title": "Malicious Relayer Can Replay Execute Calldata On Different Chains Causing Double-Spend Issue", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/144", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2022-06-connext-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/BridgeFacet.sol#L411   # Vulnerability details  ## Proof-of-Concept  > This issue is only applicable for fast-transfer. Slow transfer would not have this issue because of the built-in fraud-proof mechanism in Nomad.  First, the attacker will attempt to use Connext to send `1000 USDC` from Ethereum domain to Optimism domain.  Assume that the attacker happens to be a relayer on the relayer network utilised by Connext, and the attacker's relayer happens to be tasked to relay the above execute calldata to the Optimism's Connext [`BridgeFacet.execute`](https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/BridgeFacet.sol#L411) function.  Optimism's Connext `BridgeFacet.execute` received the execute calldata and observed within the calldata that it is a fast-transfer and Router A is responsible for providing the liquidity. It will then check that the router signature is valid, and proceed to transfer `1000 oUSDC` to attacker wallet (0x123456) in Optimism.  Next, attacker will update the `ExecuteArgs.local` within the execute calldata to a valid local representation of canonical token (USDC) used within Polygon. Attacker will then send the modified execute calldata to Polygon's Connext `BridgeFacet.execute` function. Assume that the same Router A is also providing liquidity in Polygon. The `BridgeFacet.execute` function checks that the router signature is valid, and proceed to transfer `1000 POS-USDC` to atttack wallet (0x123456) in Polygon.   At this point, the attacker has `1000 oUSDC` and `1000 POS-USDC` in his wallets. When the nomad message arrives at Optimism, Router A can claim the `1000 oUSDC` back from Connext. However, Router A is not able to claim back any fund in Polygon.  Note that same wallet address exists on different chains. For instance, the wallet address on Etherum and Polygon is the same.  ### Why changing the `ExecuteArgs.local` does not affect the router signature verification?  This is because the router signature is generated from the `transferId` + `pathLength` only, and these data are stored within the `CallParams params` within the `ExecuteArgs` struct.  [https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/libraries/LibConnextStorage.sol#L77](https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/libraries/LibConnextStorage.sol#L77)  ```solidity struct ExecuteArgs {   CallParams params;   address local; // local representation of canonical token   address[] routers;   bytes[] routerSignatures;   uint256 amount;   uint256 nonce;   address originSender; } ```  Within the [`BridgeFacet._executeSanityChecks`](https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/BridgeFacet.sol#L411) function, it will attempt to rebuild to `transferId` by calling the following code:  ```solidity // Derive transfer ID based on given arguments. bytes32 transferId = _getTransferId(_args); ```  Within the [`BridgeFacet._getTransferId`](https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/BridgeFacet.sol#L719) function, we can see that the `s.tokenRegistry.getTokenId(_args.local)` will always return the canonical `tokenDomain` and `tokenId`. In our example, it will be `Ethereum` and  `USDC`. Therefore, as long as the attacker specify a valid local representation of canonical token on a chain, the `transferId` returned by `s.tokenRegistry.getTokenId(_args.local)` will always be the same across all domains. Thus, this allows the attacker to modify the `ExecuteArgs.local` and yet he could pass the router signature check.  [https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/BridgeFacet.sol#L719](https://github.com/code-423n4/2022-06-connext/blob/4dd6149748b635f95460d4c3924c7e3fb6716967/contracts/contracts/core/connext/facets/BridgeFacet.sol#L719)  ```solidity   function _getTransferId(ExecuteArgs calldata _args) private view returns (bytes32) {     (uint32 tokenDomain, bytes32 tokenId) = s.tokenRegistry.getTokenId(_args.local);     return _calculateTransferId(_args.params, _args.amount, _args.nonce, tokenId, tokenDomain, _args.originSender);   } ```  ## Impact   Router liquidity would be drained by attacker, and affected router owner could not claim back their liquidity.  ## Recommended Mitigation Steps  The security of the current Connext design depends on how secure or reliable the relayer is. If the relayer turns rouge or act against Connext, many serious consequences can happen.  The root cause is that the current design places enormous trust on the relayers to accurately and reliably to deliver calldata to the bridge in various domains. For instance, delivering of execute call data to `execute` function. There is an attempt to prevent message replay on a single domain, however, it does not prevent message replay across multiple domains. Most importantly, the Connext's bridge appears to have full trust on the calldata delivered by the relayer. However, the fact is that the calldata can always be altered by the relayer.  Consider a classic 0x off-chain ordering book protocol. A user will sign his order with his private key, and attach the signature to the order, and send the order (with signature) to the relayer network. If the relayer attempts to tamper the order message or signature, the decoded address will be different from the signer's address and this will be detected by 0x's Smart contract on-chain when processing the order. This ensures that the integrity of the message and signer can be enforced.  Per good security practice, relayer network should always be considered as a hostile environment/network. Therefore, it is recommended that similar approach could be taken with regards to passing execute calldata across domains/chains.  For instance, at a high level, the sequencer should sign the execute calldata with its private key, and attach the signature to the execute calldata. Then, submit the execute calldata (with signature) to the relayer network. When the bridge receives the execute calldata (with signature), it can verify if the decoded address matches the sequencer address to ensure that the calldata has not been altered. This will ensure the intergrity of the execute calldata and prevent any issue that arise due to unauthorised modification of calldata.  Additionally, the execute calldata should also have a field that correspond to the destination domain. The bridge that receives the execute calldata must verify that the execute calldata is intended for its domain, otherwise reject the calldata if it belongs to other domains. This also helps to prevent the attack mentioned earlier where same execute calldata can be accepted in different domains.  "}, {"title": "Routers Are Not Enforced To Repay AAVE Portal Loan", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/143", "labels": ["bug", "3 (High Risk)", "sponsor acknowledged"], "target": "2022-06-connext-findings", "body": "Routers Are Not Enforced To Repay AAVE Portal Loan"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/141", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-connext-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/140", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-connext-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/138", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-connext-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/137", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-connext-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/136", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-connext-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/128", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-connext-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/127", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-connext-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/126", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-connext-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/125", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-connext-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/120", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-connext-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/119", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-connext-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/117", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-connext-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/116", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-connext-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/110", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-connext-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/109", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-connext-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/107", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-connext-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/106", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-connext-findings", "body": "QA Report"}, {"title": "Repaying AAVE Loan in `_local` rather than `adopted` asset", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/103", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-06-connext-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/facets/PortalFacet.sol#L80    # Vulnerability details  ## Impact  When repaying the AAVE Portal in [`repayAavePortal()`](https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/facets/PortalFacet.sol#L80) the `_local` asset is used to repay the loan in `_backLoan()` rather than the `adopted` asset. This is likely to cause issues in production when actually repaying loans if the asset/token being repayed to AAVE is not the same as the asset/token that was borrowed.  ## Proof of Concept The comment on [`L93`](https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/facets/PortalFacet.sol#L93) of [`PortalFacet.sol`](https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/facets/PortalFacet.sol) states;  ``` // Need to swap into adopted asset or asset that was backing the loan // The router will always be holding collateral in the local asset while the loaned asset // is the adopted asset ```  The swap is executed on [`L98`](https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/facets/PortalFacet.sol#L98) in the call to `AssetLogic.swapFromLocalAssetIfNeededForExactOut()` however the return value `adopted` is never used (it's an unused local variable). The full function is shown below;  ``` // Swap for exact `totalRepayAmount` of adopted asset to repay aave (bool success, uint256 amountIn, address adopted) = AssetLogic.swapFromLocalAssetIfNeededForExactOut(   _local,   totalAmount,   _maxIn );  if (!success) revert PortalFacet__repayAavePortal_swapFailed();  // decrement router balances unchecked {   s.routerBalances[msg.sender][_local] -= amountIn; }  // back loan _backLoan(_local, _backingAmount, _feeAmount, _transferId); ``` The balance of the `_local` token is reduced but instead of the `adopted` token being passed to [`_backLoan()`](https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/facets/PortalFacet.sol#L112) in L112 the `_local` token is used. ## Tools Used Vim  ## Recommended Mitigation Steps To be consistent with the comments in the [`repayAavePortal()`](https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/facets/PortalFacet.sol#L80) function `adopted` should be passed to `_backLoan` so that the loan is repayed in the appropriate token.  Remove the reference to `_local` in the [`_backLoan()`](https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/facets/PortalFacet.sol#L112) function and replace it with `adopted` so it reads;  `_backLoan(adopted, _backingAmount, _feeAmount, _transferId);`  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/101", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-connext-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/94", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-connext-findings", "body": "Gas Optimizations"}, {"title": "Incorrect Adopted mapping on updating wrapper token", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/86", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-06-connext-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/facets/AssetFacet.sol#L100   # Vulnerability details  ## Issue  1. Admin can call setWrapper function to setup a new wrapper Y instead of old wrapper X  2. This becomes a problem for any old asset which was setup during setupAsset call where s.canonicalToAdopted[_canonical.id]  will still point to old wrapper X instead of Y  ## Recommendation If wrapper is changed then all variables storing this wrapper should also update  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/82", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-connext-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/80", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-connext-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/77", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-connext-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/76", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-connext-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/74", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-connext-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/71", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-connext-findings", "body": "QA Report"}, {"title": "`PortcalFacet.repayAavePortal()` can trigger an underflow of `routerBalances`", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/68", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2022-06-connext-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-connext/blob/main/contracts/contracts/core/connext/facets/PortalFacet.sol#L80-L113   # Vulnerability details  ## Impact The caller of `repayAavePortal()` can trigger an underflow to arbitrarily increase the caller's balance through an underflow.  ## Proof of Concept ```sol // Relevant code sections:  // PortalFacet.sol   function repayAavePortal(     address _local,     uint256 _backingAmount,     uint256 _feeAmount,     uint256 _maxIn,     bytes32 _transferId   ) external {     uint256 totalAmount = _backingAmount + _feeAmount; // in adopted     uint256 routerBalance = s.routerBalances[msg.sender][_local]; // in local      // Sanity check: has that much to spend     if (routerBalance < _maxIn) revert PortalFacet__repayAavePortal_insufficientFunds();      // Need to swap into adopted asset or asset that was backing the loan     // The router will always be holding collateral in the local asset while the loaned asset     // is the adopted asset      // Swap for exact `totalRepayAmount` of adopted asset to repay aave     (bool success, uint256 amountIn, address adopted) = AssetLogic.swapFromLocalAssetIfNeededForExactOut(       _local,       totalAmount,       _maxIn     );      if (!success) revert PortalFacet__repayAavePortal_swapFailed();      // decrement router balances     unchecked {       s.routerBalances[msg.sender][_local] -= amountIn;     }      // back loan     _backLoan(_local, _backingAmount, _feeAmount, _transferId);   }  // AssetLogic.sol   function swapFromLocalAssetIfNeededForExactOut(     address _asset,     uint256 _amount,     uint256 _maxIn   )     internal     returns (       bool,       uint256,       address     )   {     AppStorage storage s = LibConnextStorage.connextStorage();      // Get the token id     (, bytes32 id) = s.tokenRegistry.getTokenId(_asset);      // If the adopted asset is the local asset, no need to swap     address adopted = s.canonicalToAdopted[id];     if (adopted == _asset) {       return (true, _amount, _asset);     }      return _swapAssetOut(id, _asset, adopted, _amount, _maxIn);   } ``` First, call `repayAavePortal()` where `_backingAmount + _feeAmount > s.routerBalances[msg.sender][_local] && _maxIn > s.routerBalances[msg.sender][_local]`. That will trigger the call to the AssetLogic contract: ```sol     (bool success, uint256 amountIn, address adopted) = AssetLogic.swapFromLocalAssetIfNeededForExactOut(       _local,       totalAmount,       _maxIn     ); ``` By setting `_local` to the same value as the adopted asset, you trigger the following edge case: ```sol     address adopted = s.canonicalToAdopted[id];     if (adopted == _asset) {       return (true, _amount, _asset);     } ``` So the `amountIn` value returned by `swapFromLocalAssetIfNeededForExactOut()` is the `totalAmount` value that was passed to it. And `totalAmount == _backingAmount + _feeAmount`.  Meaning the `amountIn` value is user-specified for this edge case. Finally, we reach the following line: ```sol     unchecked {       s.routerBalances[msg.sender][_local] -= amountIn;     } ``` `amountIn` (user-specified) is subtracted from the `routerBalances` in an `unchecked` block. Thus, the attacker is able to trigger an underflow and increase their balance arbitrarily high. The `repayAavePortal()` function only verifies that `routerBalance < _maxIn`.  Here's a test as PoC: ```sol // PortalFacet.t.sol    function test_PortalFacet_underflow() public {     s.routerPermissionInfo.approvedForPortalRouters[router] = true;      uint backing = 2 ether;     uint fee = 10000;     uint init = 1 ether;      s.routerBalances[router][_local] = init;     s.portalDebt[_id] = backing;     s.portalFeeDebt[_id] = fee;      vm.mockCall(s.aavePool, abi.encodeWithSelector(IAavePool.backUnbacked.selector), abi.encode(true));     vm.prank(router);     this.repayAavePortal(_local, backing, fee, init - 0.5 ether, _id);      // balance > init => underflow     require(s.routerBalances[router][_local] > init);   } ``` ## Tools Used none  ## Recommended Mitigation Steps After the call to `swapFromLocalAssetIfNeededForExactOut()` you should add the following check: ```sol if (_local == adopted) {   require(routerBalance >= amountIn); } ```  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/59", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-connext-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/58", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-connext-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/55", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-connext-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/52", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-connext-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/49", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-connext-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/44", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-06-connext-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/42", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-connext-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/36", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-connext-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/34", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-connext-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/32", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-connext-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/31", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-connext-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/30", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-connext-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/29", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-connext-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/25", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-connext-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/24", "labels": ["bug", "duplicate", "G (Gas Optimization)"], "target": "2022-06-connext-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/23", "labels": ["bug", "QA (Quality Assurance)", "resolved", "sponsor confirmed"], "target": "2022-06-connext-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/13", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-06-connext-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/11", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-connext-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/7", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-connext-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/6", "labels": ["bug", "duplicate", "G (Gas Optimization)"], "target": "2022-06-connext-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/5", "labels": ["bug", "QA (Quality Assurance)", "resolved", "sponsor confirmed"], "target": "2022-06-connext-findings", "body": "QA Report"}, {"title": "Agreement & Disclosures", "html_url": "https://github.com/code-423n4/2022-06-connext-findings/issues/1", "labels": [], "target": "2022-06-connext-findings", "body": "Agreement & Disclosures"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/317", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-canto-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/315", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-canto-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/312", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-canto-findings", "body": "QA Report"}, {"title": "CNote updates the accounts after sending the funds, allowing for reentrancy", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/311", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-06-canto-findings", "body": "# Lines of code  https://github.com/Plex-Engineer/lending-market/blob/2d423c7c3f62d65182d802deb99cc7bba4e057fd/contracts/CNote.sol#L70-L87   # Vulnerability details  Having no reentrancy control and updating the records after external interactions allows for funds draining by reentrancy.  Setting the severity to medium as this is conditional to transfer flow control introduction on future upgrades, but the impact is up to the full loss of the available funds by unrestricted borrowing.  ## Proof of Concept  CNote runs doTransferOut before borrowing accounts are updated:  https://github.com/Plex-Engineer/lending-market/blob/2d423c7c3f62d65182d802deb99cc7bba4e057fd/contracts/CNote.sol#L70-L87  ```         /*          * We invoke doTransferOut for the borrower and the borrowAmount.          *  Note: The cToken must handle variations between ERC-20 and ETH underlying.          *  On success, the cToken borrowAmount less of cash.          *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.          */         doTransferOut(borrower, borrowAmount);         require(getCashPrior() == 0,\"CNote::borrowFresh: Error in doTransferOut, impossible Liquidity in LendingMarket\");     //Amount minted by Accountant is always flashed from account          /* We write the previously calculated values into storage */         accountBorrows[borrower].principal = accountBorrowsNew;         accountBorrows[borrower].interestIndex = borrowIndex;         totalBorrows = totalBorrowsNew;          /* We emit a Borrow event */         emit Borrow(borrower, borrowAmount, accountBorrowsNew, totalBorrowsNew);     } ```  Call sequence here is borrow() -> borrowInternal() -> borrowFresh() -> doTransferOut(), which transfers the token to an external recipient:  https://github.com/Plex-Engineer/lending-market/blob/2d423c7c3f62d65182d802deb99cc7bba4e057fd/contracts/CErc20.sol#L189-L200  ```     /**      * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory      *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to      *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified      *      it is >= amount, this should not revert in normal conditions.      *      *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.      *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca      */     function doTransferOut(address payable to, uint amount) virtual override internal {         EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying);         token.transfer(to, amount); ```  There an attacker can call exitMarket() that have no reentrancy control to remove the account of the debt:  https://github.com/Plex-Engineer/lending-market/blob/2d423c7c3f62d65182d802deb99cc7bba4e057fd/contracts/Comptroller.sol#L167-L174  https://github.com/Plex-Engineer/lending-market/blob/2d423c7c3f62d65182d802deb99cc7bba4e057fd/contracts/ComptrollerG7.sol#L157-L164  ```     /**      * @notice Removes asset from sender's account liquidity calculation      * @dev Sender must not have an outstanding borrow balance in the asset,      *  or be providing necessary collateral for an outstanding borrow.      * @param cTokenAddress The address of the asset to be removed      * @return Whether or not the account successfully exited the market      */     function exitMarket(address cTokenAddress) override external returns (uint) { ```  This attack was carried out several times:  https://certik.medium.com/fei-protocol-incident-analysis-8527440696cc   ## Recommended Mitigation Steps  Consider moving accounting update before funds were sent out, for example as it is done in CToken's borrowFresh():  ``` https://github.com/Plex-Engineer/lending-market/blob/2d423c7c3f62d65182d802deb99cc7bba4e057fd/contracts/CToken.sol#L595-L609          /*          * We write the previously calculated values into storage.          *  Note: Avoid token reentrancy attacks by writing increased borrow before external transfer.         `*/         accountBorrows[borrower].principal = accountBorrowsNew;         accountBorrows[borrower].interestIndex = borrowIndex;         totalBorrows = totalBorrowsNew;          /*          * We invoke doTransferOut for the borrower and the borrowAmount.          *  Note: The cToken must handle variations between ERC-20 and ETH underlying.          *  On success, the cToken borrowAmount less of cash.          *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.          */         doTransferOut(borrower, borrowAmount); ```  "}, {"title": "CALL() SHOULD BE USED INSTEAD OF TRANSFER() ", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/310", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-canto-findings", "body": "CALL() SHOULD BE USED INSTEAD OF TRANSFER() "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/307", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-canto-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/306", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-canto-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/305", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-canto-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/298", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-canto-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/292", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-canto-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/290", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-canto-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/286", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-canto-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/285", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-canto-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/275", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-canto-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/273", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-canto-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/272", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-canto-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/267", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-canto-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/265", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-canto-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/264", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-canto-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/262", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-canto-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/261", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-canto-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/260", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-canto-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/259", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-canto-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/258", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-canto-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/257", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-canto-findings", "body": "QA Report"}, {"title": "Only the `state()` of the latest proposal can be checked", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/254", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-06-canto-findings", "body": "# Lines of code  https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/Governance/GovernorBravoDelegate.sol#L115   # Vulnerability details  ## Impact  `state()` function cannot view the state from any proposal except for the latest one.  ## Proof of Concept  ```solidity require(proposalCount >= proposalId && proposalId > initialProposalId, \"GovernorBravo::state: invalid proposal id\"); ```  Currently `proposalCount` needs to be bigger or equal to `proposalId`.  Assuming `proposalId` is incremented linearly in conjunction with `proposalCount`, this implies only the most recent `proposalId` will pass the `require()` check above. All other proposals will not be able to have their states checked via this function.   ## Tools Used Manual Review.  ## Recommended Mitigation Steps  Change above function to `proposalCount <= proposalId` (assuming `proposalId` is set linearly, which currently is not enforced by code).   "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/252", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-canto-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/251", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-canto-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/247", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-canto-findings", "body": "Gas Optimizations"}, {"title": "Unable to check `state()` if `proposalId == 0`", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/244", "labels": ["bug", "2 (Med Risk)", "sponsor disputed"], "target": "2022-06-canto-findings", "body": "Unable to check `state()` if `proposalId == 0`"}, {"title": "Overprivileged admin can grant unlimited WETH", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/241", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-06-canto-findings", "body": "Overprivileged admin can grant unlimited WETH"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/236", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-canto-findings", "body": "Gas Optimizations"}, {"title": "Oracle may be attacked if an attacker can pump the tokens for the entire block", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/233", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-06-canto-findings", "body": "Oracle may be attacked if an attacker can pump the tokens for the entire block"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/230", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-canto-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/229", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-canto-findings", "body": "QA Report"}, {"title": "Transferring any amount of the underlying token to the CNote contract will make the contract functions unusable", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/227", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-06-canto-findings", "body": "# Lines of code  https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/CNote.sol#L43 https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/CNote.sol#L114 https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/CNote.sol#L198 https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/CNote.sol#L310   # Vulnerability details  ## Impact  The contract expects the balance of the underlying token to == 0 at all points when calling the contract functions by requiring getCashPrior() == 0, which checks token.balanceOf(address(this)) where token is the underlying asset.  An attacker can transfer any amount of the underlying asset directly to the contract and make all of the functions requiring getCashPrior() == 0 to revert.   ## Proof of Concept [CNote.sol#L43](https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/CNote.sol#L43) [CNote.sol#L114](https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/CNote.sol#L114) [CNote.sol#198](https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/CNote.sol#L198) [CNote.sol#310](https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/CNote.sol#L310)  1. Attacker gets any balance of Note (amount = 1 token) 2. Attacker transfers the token to CNote which uses Note as an underlying asset, by calling note.transfer(CNoteAddress, amount). The function is available since Note inherits from ERC20 3. Any calls to CNote functions now revert due to getCashPrior() not being equal to 0  ## Recommended Mitigation Steps Instead of checking the underlying token balance via balanceOf(address(this)) the contract could hold an internal balance of the token, mitigating the impact of tokens being forcefully transferred to the contract.  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/221", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-canto-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/219", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-canto-findings", "body": "QA Report"}, {"title": "WETH.allowance() returns wrong result.", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/218", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-06-canto-findings", "body": "# Lines of code  https://github.com/Plex-Engineer/lending-market/blob/ab31a612be354e252d72faead63d86b844172761/contracts/WETH.sol#L104   # Vulnerability details  ## Impact WETH.allowance() returns wrong result. I can't find other contracts that use this function but WETH.sol is a base contract and it should be fixed properly.   ## Proof of Concept In this function, the \"return\" keyword is missing and it will always output 0 in this case.   ## Tools Used Solidity Visual Developer of VSCode   ## Recommended Mitigation Steps L104 should be changed like below. ``` return _allowance[owner][spender]; ```  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/215", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-canto-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/214", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-canto-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/210", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-canto-findings", "body": "QA Report"}, {"title": "use of transfer() instead of call()", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/204", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-canto-findings", "body": "use of transfer() instead of call()"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/196", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-canto-findings", "body": "QA Report"}, {"title": "In Cnote.sol, anyone can initially become both accountant and admin", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/195", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-06-canto-findings", "body": "# Lines of code  https://github.com/Plex-Engineer/lending-market/blob/ab31a612be354e252d72faead63d86b844172761/contracts/CNote.sol#L14   # Vulnerability details  ## Impact  Affected code:  - [https://github.com/Plex-Engineer/lending-market/blob/ab31a612be354e252d72faead63d86b844172761/contracts/CNote.sol#L14](https://github.com/Plex-Engineer/lending-market/blob/ab31a612be354e252d72faead63d86b844172761/contracts/CNote.sol#L14)  The function `_setAccountantContract()` is supposed to be called after contract initialization, so that the `accountant` is immediately set. However, this function completely lacks any access control (it\u2019s just `public`) so an attacker can monitor the mempool and frontrun the transaction in order to become both `accountant` and `admin`  ## Tools Used  Editor  ## Recommended Mitigation Steps  The function should:  1. have a guard that regulates access control 2. not set the `admin` too, which is dangerous and out of scope  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/194", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-canto-findings", "body": "QA Report"}, {"title": "WETH.sol computes the wrong totalSupply() ", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/191", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-06-canto-findings", "body": "# Lines of code  https://github.com/Plex-Engineer/lending-market/blob/ab31a612be354e252d72faead63d86b844172761/contracts/WETH.sol#L47   # Vulnerability details  ## Impact  Affected code:  - [https://github.com/Plex-Engineer/lending-market/blob/ab31a612be354e252d72faead63d86b844172761/contracts/WETH.sol#L47](https://github.com/Plex-Engineer/lending-market/blob/ab31a612be354e252d72faead63d86b844172761/contracts/WETH.sol#L47)  `WETH.sol` is almost copied from the infamous WETH contract that lives in mainnet. This contract is supposed to receive the native currency of the blockchain (for example ETH) and wrap it into a tokenized, ERC-20 form. This contract computes the `totalSupply()` using the balance of the contract itself stored in the `balanceOf` mapping, when instead it should be using the native `balance` function. This way, `totalSupply()` always returns zero as the `WETH` contract itself has no way of calling `deposit` to itself and increase its own balance  ## Proof of Concept  1. Alice transfers 100 ETH to `WETH.sol` 2. Alice calls `balanceOf()` for her address and it returns 100 WETH 3. Alice calls `totalSupply()`, expecting to see 100 WETH, but it returns 0  ## Tools Used  Editor  ## Recommended Mitigation Steps  ```jsx function totalSupply() public view returns (uint) {     return address(this).balance } ```  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/188", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-canto-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/183", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-canto-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/182", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-canto-findings", "body": "QA Report"}, {"title": "`lending-market/Note.sol` Wrong implementation of access control", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/173", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-06-canto-findings", "body": "# Lines of code  https://github.com/Plex-Engineer/lending-market/blob/b93e2867a64b420ce6ce317f01c7834a7b6b17ca/contracts/Note.sol#L13-L31   # Vulnerability details  ```solidity function _mint_to_Accountant(address accountantDelegator) external {     if (accountant == address(0)) {         _setAccountantAddress(msg.sender);     }     require(msg.sender == accountant, \"Note::_mint_to_Accountant: \");     _mint(msg.sender, type(uint).max); }  function RetAccountant() public view returns(address) {     return accountant; }  function _setAccountantAddress(address accountant_) internal {     if(accountant != address(0)) {         require(msg.sender == admin, \"Note::_setAccountantAddress: Only admin may call this function\");     }     accountant = accountant_;     admin = accountant; } ```  `_mint_to_Accountant()` calls `_setAccountantAddress()` when `accountant == address(0)`, which will always be the case when `_mint_to_Accountant()` is called for the first time.  And `_setAccountantAddress()` only checks if `msg.sender == admin` when `accountant != address(0)` which will always be `false`, therefore the access control is not working.  L17 will then check if `msg.sender == accountant`, now it will always be the case, because at L29, `accountant` was set to `msg.sender`.  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/170", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-canto-findings", "body": "QA Report"}, {"title": "`lending-market/NoteInterest.sol` Wrong implementation of `getBorrowRate()`", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/166", "labels": ["bug", "3 (High Risk)"], "target": "2022-06-canto-findings", "body": "`lending-market/NoteInterest.sol` Wrong implementation of `getBorrowRate()`"}, {"title": "`zeroswap/UniswapV2Library.sol` Wrong init code hash in `UniswapV2Library.pairFor()` will break `UniswapV2Oracle`, `UniswapV2Router02`, `SushiRoll`", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/164", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-06-canto-findings", "body": "# Lines of code  https://github.com/Plex-Engineer/zeroswap/blob/03507a80322112f4f3c723fc68bed0f138702836/contracts/uniswapv2/libraries/UniswapV2Library.sol#L20-L28   # Vulnerability details  ```solidity function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {     (address token0, address token1) = sortTokens(tokenA, tokenB);     pair = address(uint(keccak256(abi.encodePacked(             hex'ff',             factory,             keccak256(abi.encodePacked(token0, token1)),             hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303' // init code hash         )))); } ```  The `init code hash` in `UniswapV2Library.pairFor()` should be updated since the code of `UniswapV2Pair` has been changed. Otherwise, the `pair` address calculated will be wrong, most likely non-existing address.  There are many other functions and other contracts across the codebase, including  `UniswapV2Oracle`, `UniswapV2Router02`, and `SushiRoll`, that rely on the `UniswapV2Library.pairFor()` function for the address of the pair, with the `UniswapV2Library.pairFor()` returning a wrong and non-existing address, these functions and contracts will malfunction.  ### Recommendation  Update the init code hash from `hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303'` to the value of `UniswapV2Factory.pairCodeHash()`.  "}, {"title": "`stableswap/BaseV1Pair.sol#_update()` will revert when `reserve0CumulativeLast` or `reserve1CumulativeLast` gets large enough", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/163", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-06-canto-findings", "body": "# Lines of code  https://github.com/Plex-Engineer/stableswap/blob/0dd7ac65d923bb7462c47f6d56b564af34b34118/contracts/BaseV1-core.sol#L154-L171   # Vulnerability details  ```solidity function _update(uint balance0, uint balance1, uint _reserve0, uint _reserve1) internal {     uint blockTimestamp = block.timestamp;     uint timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired     if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {         reserve0CumulativeLast += _reserve0 * timeElapsed;         reserve1CumulativeLast += _reserve1 * timeElapsed;     }      Observation memory _point = lastObservation();     timeElapsed = blockTimestamp - _point.timestamp; // compare the last observation with current timestamp, if greater than 30 minutes, record a new event     if (timeElapsed > periodSize) {         observations.push(Observation(blockTimestamp, reserve0CumulativeLast, reserve1CumulativeLast));     }     reserve0 = balance0;     reserve1 = balance1;     blockTimestampLast = blockTimestamp;     emit Sync(reserve0, reserve1); } ```  This was forked from Uniswap v2's `update()`:  https://github.com/Uniswap/v2-core/blob/master/contracts/UniswapV2Pair.sol#L72-L81  ```solidity=L72 // update reserves and, on the first call per block, price accumulators function _update(uint balance0, uint balance1, uint112 _reserve0, uint112 _reserve1) private {     require(balance0 <= uint112(-1) && balance1 <= uint112(-1), 'UniswapV2: OVERFLOW');     uint32 blockTimestamp = uint32(block.timestamp % 2**32);     uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired     if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {         // * never overflows, and + overflow is desired         price0CumulativeLast += uint(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed;         price1CumulativeLast += uint(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed;     } ```  UniswapV2's Pair is using Solidity 0.5.16, in which the arithmetic operations will overflow/underflow without revert.  As the solidity version used in the current implementation of `BaseV1Pair.sol` is `0.8.11`, and there are some breaking changes in Solidity v0.8.0, including:  > Arithmetic operations revert on underflow and overflow.   Ref: https://docs.soliditylang.org/en/v0.8.11/080-breaking-changes.html#silent-changes-of-the-semantics  When updating `reserve0CumulativeLast` and `reserve1CumulativeLast` in `BaseV1Pair.sol`, overflow and underflow are desired as per the comment.  However, the intended overflow only works for solidity < `0.8.0` by default. If overflow and underflow are desired, then the math should be put into an `unchecked` block. Otherwise, the transaction will revert.  ### Impact  Since the overflow is desired in the original version, and it's broken because of using Solidity version >0.8. The `BaseV1Pair` contract will break when the desired overflow happens, which will be sooner or later depending on the decimals of the tokens and trading volume.  ### Recommendation  Change to:  ```solidity unchecked {     uint timeElapsed = blockTimestamp - blockTimestampLast;     if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {         reserve0CumulativeLast += _reserve0 * timeElapsed;         reserve1CumulativeLast += _reserve1 * timeElapsed;     } } ```  "}, {"title": "`zeroswap/UniswapV2Pair.sol` Token reserves per lp token can be manipulated due to lack of `MINIMUM_LIQUIDITY` when minting the first liquidity with `migrator`", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/162", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-06-canto-findings", "body": "`zeroswap/UniswapV2Pair.sol` Token reserves per lp token can be manipulated due to lack of `MINIMUM_LIQUIDITY` when minting the first liquidity with `migrator`"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/157", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-canto-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/156", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-canto-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/154", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-canto-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/153", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-canto-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/150", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-canto-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/147", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-canto-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/144", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-canto-findings", "body": "Gas Optimizations"}, {"title": "swapExactTokensForCANTO() function has call to sender without reentrancy protection.", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/141", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-06-canto-findings", "body": "swapExactTokensForCANTO() function has call to sender without reentrancy protection."}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/140", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-canto-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/139", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-canto-findings", "body": "QA Report"}, {"title": "Unchecked transfers", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/126", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-06-canto-findings", "body": "Unchecked transfers"}, {"title": "Note: When _initialSupply ! = 0, the _mint_to_Accountant function will fail", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/125", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-06-canto-findings", "body": "# Lines of code  https://github.com/Plex-Engineer/lending-market/blob/ab31a612be354e252d72faead63d86b844172761/contracts/Note.sol#L13-L19   # Vulnerability details  ## Impact In Note contract, if _initialSupply ! = 0, _totalSupply will overflow when the _mint_to_Accountant function executes _mint(msg.sender, type(uint).max) ```     constructor(string memory name_, string memory symbol_, uint256 totalSupply_) public {         _name = name_;         _symbol = symbol_;      _initialSupply = totalSupply_;      _totalSupply = totalSupply_;     } ...     function _mint(address account, uint256 amount) internal   {         require(account != address(0), \"ERC20: mint to the zero address\");          _beforeTokenTransfer(address(0), account, amount);          _totalSupply += amount;         _balances[account] += amount;         emit Transfer(address(0), account, amount);          _afterTokenTransfer(address(0), account, amount);     } ``` ## Proof of Concept https://github.com/Plex-Engineer/lending-market/blob/ab31a612be354e252d72faead63d86b844172761/contracts/Note.sol#L13-L19 https://github.com/Plex-Engineer/lending-market/blob/ab31a612be354e252d72faead63d86b844172761/contracts/ERC20.sol#L29-L34 https://github.com/Plex-Engineer/lending-market/blob/ab31a612be354e252d72faead63d86b844172761/contracts/ERC20.sol#L237-L247 ## Tools Used None ## Recommended Mitigation Steps ERC20.sol ```     constructor(string memory name_, string memory symbol_) public {         _name = name_;         _symbol = symbol_;     } ``` note.sol ```     constructor() ERC20(\"Note\", \"NOTE\") {         admin = msg.sender;     } ```  "}, {"title": "Missing zero address check can set treasury to zero address", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/121", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-06-canto-findings", "body": "# Lines of code  https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/Accountant/AccountantDelegate.sol#L15-L20   # Vulnerability details  ## Impact AccountantDelegate.initialize() is missing a zero address check for `treasury_` parameter, which could may allow treasury to be mistakenly set to 0 address.  ## Proof of Concept https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/Accountant/AccountantDelegate.sol#L20  ## Tools Used Manual review  ## Recommended Mitigation Steps Add a require() check for zero address for the treasury parameter before changing the treasury address in the initialize function.  "}, {"title": "accountant address can be set to zero by anyone leading to loss of funds/tokens", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/117", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-06-canto-findings", "body": "# Lines of code  https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/CNote.sol#L14-L21 https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/CNote.sol#L31 https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/CNote.sol#L96 https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/CNote.sol#L178 https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/CNote.sol#L258   # Vulnerability details  ## Impact In CNote._setAccountantContract() , the require() check only works when `address(_accountant) != address(0)` , leading to the ability to set `_accountant` state variable to the zero address, as well as setting admin to zero address.  The following below are impacts arising from above: ## A. Users can gain underlying asset tokens for free by minting CToken in `mintFresh()` then calling `redeemFresh()`  ## Proof of Concept 1. Alice calls `_setAccountantContract()` with parameter input as 0. 2. The _accountant state variable is now 0. 3. Alice/or a contract calls `mintFresh()` with input address 0 and mintAmount 1000. (assuming function is external, reporting a separate issue on the mutability) 4. This passes the `if (minter == address(_accountant))` and proceeds to mint 1000 CTokens to address(0) 5. Alice then calls `redeemFresh()` with her address as the `redeemer` parameter, and redeemTokensIn as 1000. 6. Assume exchangeRate is 1, Alice would receive 1000 tokens in underlying asset.    ## B. Users could borrow CToken asset for free A user can borrow CToken asset from the contract, then set _accountant to 0 after. With _accountant being set to 0 , the borrower , then call `repayBorrowFresh()` to have _accountant (address 0) to repay back the borrowed tokens assuming address(0) already has some tokens, and user's borrowed asset (all/part) are repaid.  ## Proof of Concept 1. Alice calls `borrowFresh()` to borrow 500 CTokens from contract. 2. Then Alice calls `_setAccountantContract()` with parameter input as 0. 2. The _accountant state variable is now 0. 3. With _accountant being set to 0, Alice calls `repayBorrowFresh()` having the payer be address 0, borrower being her address and 500 as repayAmount. 4. Assume address 0 already holds 1000 CTokens, Alice's debt will be fully repaid and she'll gain 500 CTokens for free.   ## C. Accounting contract could loses funds/tokens When the _accountant is set to 0, CTokens/CNote will be sent to the zero address making the Accounting contract lose funds whenever  `doTransferOut` is called.    ## Tools Used Manual review  ## Recommended Mitigation Steps Instead of a `if (address(_accountant) != address(0))` statement, an additional require check to ensure `accountant_` parameter is not 0 address can be used in addition to the require check for caller is admin.  Change this  ```if (address(_accountant) != address(0)){             require(msg.sender == admin, \"CNote::_setAccountantContract:Only admin may call this function\");         } ```  to this ``` require(msg.sender == admin, \"CNote::_setAccountantContract:Only admin may call this function\"); require(accountant_ != address(0), \"accoutant can't be zero address\"); ```  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/116", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-canto-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/115", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-canto-findings", "body": "Gas Optimizations"}, {"title": "Incorrect condition always bound to fail", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/113", "labels": ["bug", "2 (Med Risk)", "disagree with severity"], "target": "2022-06-canto-findings", "body": "Incorrect condition always bound to fail"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/110", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-canto-findings", "body": "QA Report"}, {"title": "In `ERC20`, `TotalSupply` is broken", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/108", "labels": ["bug", "3 (High Risk)", "sponsor disputed"], "target": "2022-06-canto-findings", "body": "In `ERC20`, `TotalSupply` is broken"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/106", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-canto-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/105", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-canto-findings", "body": "QA Report"}, {"title": "Incorrect amount taken", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/98", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-06-canto-findings", "body": "# Lines of code  https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/CNote.sol#L129   # Vulnerability details  ## Impact It was observed that in repayBorrowFresh function, User is asked to send repayAmount instead of repayAmountFinal. This can lead to loss of user funds as user might be paying extra  ## Proof of Concept 1. User is making a repayment which eventually calls repayBorrowFresh function  2. Assuming repayAmount == type(uint).max, so repayAmountFinal becomes accountBorrowsPrev  3. This means User should only transfer in accountBorrowsPrev instead of repayAmount but that is not true. Contract is transferring repayAmount instead of repayAmountFinal as seen at CNote.sol#L129  ``` uint actualRepayAmount = doTransferIn(payer, repayAmount); ```  ## Recommended Mitigation Steps Revise CNote.sol#L129 to below:  ``` uint actualRepayAmount = doTransferIn(payer, repayAmountFinal); ```  "}, {"title": "No max limit on update frequency", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/97", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-06-canto-findings", "body": "No max limit on update frequency"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/92", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-canto-findings", "body": "Gas Optimizations"}, {"title": " AccountantDelegate: sweepInterest function will destroy the cnote in the contract.", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/89", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-06-canto-findings", "body": "# Lines of code  https://github.com/Plex-Engineer/lending-market/blob/ab31a612be354e252d72faead63d86b844172761/contracts/Accountant/AccountantDelegate.sol#L74-L92   # Vulnerability details  ## Impact When the user borrows note tokens, the AccountantDelegate contract provides note tokens and gets cnote tokens. Later, when the user repays the note tokens, the cnote tokens are destroyed and the note tokens are transferred to the AccountantDelegate contract. However, in the sweepInterest function of the AccountantDelegate contract, all cnote tokens in the contract will be transferred to address 0. This will prevent the user from repaying the note tokens, and the sweepInterest function will not calculate the interest correctly later. ## Proof of Concept https://github.com/Plex-Engineer/lending-market/blob/ab31a612be354e252d72faead63d86b844172761/contracts/Accountant/AccountantDelegate.sol#L74-L92 https://github.com/Plex-Engineer/lending-market/blob/ab31a612be354e252d72faead63d86b844172761/contracts/CToken.sol#L533 ## Tools Used None ## Recommended Mitigation Steps ```     function sweepInterest() external override returns(uint) {      uint noteBalance = note.balanceOf(address(this));   uint CNoteBalance = cnote.balanceOf(address(this));    Exp memory expRate = Exp({mantissa: cnote.exchangeRateStored()}); // obtain exchange Rate from cNote Lending Market as a mantissa (scaled by 1e18)   uint cNoteConverted = mul_ScalarTruncate(expRate, CNoteBalance); //calculate truncate(cNoteBalance* mantissa{expRate})   uint noteDifferential = sub_(note.totalSupply(), noteBalance); //cannot underflow, subtraction first to prevent against overflow, subtraction as integers    require(cNoteConverted >= noteDifferential, \"Note Loaned to LendingMarket must increase in value\");      uint amtToSweep = sub_(cNoteConverted, noteDifferential);    note.transfer(treasury, amtToSweep);  -  cnote.transfer(address(0), CNoteBalance);    return 0;     } ```  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/86", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-canto-findings", "body": "Gas Optimizations"}, {"title": "AccountantDelegator and TreasuryDelegator: abi.decode(data, (uint)) does not check the data length", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/84", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-06-canto-findings", "body": "# Lines of code  https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/Treasury/TreasuryDelegator.sol#L44-L56   # Vulnerability details  ## Impact In AccountantDelegator and TreasuryDelegator contracts, when using abi.decode(data, (uint)) to convert data to uint type, the length of data is not checked, when the returned data is of bytes type, the abi.decode will return 0x20. ## Proof of Concept https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/Treasury/TreasuryDelegator.sol#L44-L56 https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/Accountant/AccountantDelegator.sol#L54-L74 This contract can test that when the function returns bytes data, abi.encode will decode the return value as 0x20. ``` pragma solidity 0.8.10; contract A{     uint public destination;     uint256 public number;     function convertA() external{         (bool su,bytes memory ret )= address(this).call(abi.encodeWithSelector(this.ret.selector));         number = ret.length;         destination = abi.decode(ret, (uint));     }     function ret() public returns(bytes memory){         return \"1234\";     } } ``` ## Tools Used None ## Recommended Mitigation Steps Requires data.length == 32  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/76", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-canto-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/75", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-canto-findings", "body": "Gas Optimizations"}, {"title": "baseRatePerBlock is set in constructor but not anywhere else", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/72", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-06-canto-findings", "body": "# Lines of code  https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/NoteInterest.sol#L73-L77   # Vulnerability details  ## Impact baseRatePerBlock cannot be relied on to accurately contain current interest rate  ## Proof of Concept baseRatePerBlock is set in the constructor but then not update in either updateBaseRate or _setBaseRatePerYear which update baseRatePerYear. Any contract that pulls the interest rate from baseRatePerBlock will always get the interest rate initially set at the creation of the contract  ## Tools Used  ## Recommended Mitigation Steps Update baseRatePerBlock in updateBaseRate and _setBaseRatePerYear  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/69", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-canto-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/67", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-canto-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/60", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-canto-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/59", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-canto-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/55", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-canto-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/54", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-canto-findings", "body": "QA Report"}, {"title": "Accountant can't be initialized", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/53", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-06-canto-findings", "body": "# Lines of code  https://github.com/Plex-Engineer/lending-market/blob/main/contracts/Accountant/AccountantDelegate.sol#L29   # Vulnerability details  ## Impact It's not possible to initialize the accountant because of a mistake in the function's require statement.  I rate it as MED since a key part of the protocol wouldn't be available until the contract is modified and redeployed.  ## Proof of Concept The issue is the following `require()` statement: https://github.com/Plex-Engineer/lending-market/blob/main/contracts/Accountant/AccountantDelegate.sol#L29  There, the function checks whether the accountant has received the correct amount of tokens. But, it compares the accountant's balance with the `_initialSupply`. That value is always 0. So the require statement will always fail  When the Note contract is initialized, `_initialSupply` is set to 0:  - https://github.com/Plex-Engineer/lending-market/blob/main/deploy/canto/004_deploy_Note.ts#L14 - https://github.com/Plex-Engineer/lending-market/blob/main/contracts/Note.sol#L9 - https://github.com/Plex-Engineer/lending-market/blob/main/contracts/ERC20.sol#L32  After `_mint_to_Accountant()` mints `type(uint).max` tokens to the accountant: https://github.com/Plex-Engineer/lending-market/blob/main/contracts/Note.sol#L18 That increases the `totalSupply` but not the `_initialSupply`: https://github.com/Plex-Engineer/lending-market/blob/main/contracts/ERC20.sol#L242  The `_initialSupply` value is only modified by the ERC20 contract's constructor.  ## Tools Used none  ## Recommended Mitigation Steps Change the require statement to ```sol require(note.balanceOf(msg.sender) == note.totalSupply(), \"AccountantDelegate::initiatlize: Accountant has not received payment\"); ```  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/48", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-canto-findings", "body": "QA Report"}, {"title": "Comptroller uses the wrong address for the WETH contract", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/46", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-06-canto-findings", "body": "# Lines of code  https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/Comptroller.sol#L1469   # Vulnerability details  ## Impact The Comptroller contract uses a hardcoded address for the WETH contract which is not the correct one. Because of that, it will be impossible to claim COMP rewards. That results in a loss of funds so I rate it as HIGH.  ## Proof of Concept The Comptroller's `getWETHAddress()` function: https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/Comptroller.sol#L1469  It's a left-over from the original compound repo: https://github.com/compound-finance/compound-protocol/blob/master/contracts/Comptroller.sol#L1469  It's used by the `grantCompInternal()` function: https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/Comptroller.sol#L1377  That function is called by `claimComp()`: https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/Comptroller.sol#L1365   If there is a contract stored in that address and it doesn't adhere to the interface (doesn't have a `balanceOf()` and `transfer()` function), the transaction will revert. If there is no contract, the call will succeed without having any effect. In both cases, the user doesn't get their COMP rewards.  ## Tools Used none  ## Recommended Mitigation Steps The WETH contract's address should be parsed to the Comptroller through the constructor or another function instead of being hardcoded.  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/45", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-canto-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/44", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-canto-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/43", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-canto-findings", "body": "QA Report"}, {"title": "It's not possible to execute governance proposals through the GovernorBravoDelegate contract", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/39", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-06-canto-findings", "body": "# Lines of code  https://github.com/Plex-Engineer/lending-market/blob/main/contracts/Governance/GovernorBravoDelegate.sol#L63 https://github.com/Plex-Engineer/lending-market/blob/main/contracts/Governance/GovernorBravoDelegate.sol#L87   # Vulnerability details  ## Impact It's not possible to execute a proposal through the GovernorBravoDelegate contract because the `executed` property of it is set to `true` when it's queued up.  Since this means that the governance contract is unusable, it might result in locked-up funds if those were transferred to the contract before the issue comes up. Because of that I'd rate it as HIGH.  ## Proof of Concept `executed` is set to `true`: https://github.com/Plex-Engineer/lending-market/blob/main/contracts/Governance/GovernorBravoDelegate.sol#L63  Here, the `execute()` function checks whether the proposal's state is `Queued`: https://github.com/Plex-Engineer/lending-market/blob/main/contracts/Governance/GovernorBravoDelegate.sol#L87 But, since the `execute` property is `true`, the `state()` function will return `Executed`: https://github.com/Plex-Engineer/lending-market/blob/main/contracts/Governance/GovernorBravoDelegate.sol#L117  In the original compound repo, `executed` is `false` when the proposal is queued up: https://github.com/compound-finance/compound-protocol/blob/master/contracts/Governance/GovernorBravoDelegate.sol#L111  ## Tools Used none  ## Recommended Mitigation Steps Just delete the line where `executed` is set to `true`. Since the zero-value is `false` anyway, you'll save gas as well.  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/38", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-canto-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/30", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-canto-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/29", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-canto-findings", "body": "QA Report"}, {"title": "Use call() instead of transfer() on a payable address", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/28", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-canto-findings", "body": "Use call() instead of transfer() on a payable address"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/27", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-canto-findings", "body": "Gas Optimizations"}, {"title": "Anyone can create Proposal Unigov Proposal-Store.sol", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/26", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-06-canto-findings", "body": "# Lines of code  https://github.com/Plex-Engineer/manifest/blob/688e9b4e7835854c22ef44b045d6d226b784b4b8/contracts/Proposal-Store.sol#L46 https://github.com/Plex-Engineer/lending-market/blob/b93e2867a64b420ce6ce317f01c7834a7b6b17ca/contracts/Governance/GovernorBravoDelegate.sol#L37   # Vulnerability details  ## Impact Proposal Store is used to store proposals that have already passed (https://code4rena.com/contests/2022-06-new-blockchain-contest#unigov-module-615-sloc) \" Upon a proposal\u2019s passing, the proposalHandler either deploys the ProposalStore contract (if it is not already deployed) or appends the proposal into the ProposalStore\u2019s mapping ( uint \u21d2 Proposal)\"  But anyone can add proposals to the contract directly via AddProposal() function.  Unigov proposals can be queued and executed by anyone in GovernorBravoDelegate contract https://github.com/Plex-Engineer/lending-market/blob/b93e2867a64b420ce6ce317f01c7834a7b6b17ca/contracts/Governance/GovernorBravoDelegate.sol#L37  ## Proof of Concept https://github.com/Plex-Engineer/manifest/blob/688e9b4e7835854c22ef44b045d6d226b784b4b8/contracts/Proposal-Store.sol#L46  ## Recommended Mitigation Steps Authorization checks for AddProposal, only governance module should be able to update  "}, {"title": "Anyone can set the `baseRatePerYear` after the `updateFrequency` has passed", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/22", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-06-canto-findings", "body": "# Lines of code  https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/NoteInterest.sol#L118-L129   # Vulnerability details  ## Impact The `updateBaseRate()` function is public and lacks access control, so anyone can set the critical variable `baseRatePerYear` once the block delta has surpassed the `updateFrequency` variable. This will have negative effects on the borrow and supply rates used anywhere else in the protocol.  The updateFrequency is explained to default to 24 hours per the comments, so this vulnerability will be available every day. Important to note, the admin can fix the `baseRatePerYear` by calling the admin-only `_setBaseRatePerYear()` function. However, calling this function does not set the `lastUpdateBlock` so users will still be able to change the rate back after the 24 hours waiting period from the previous change.   ## Proof of Concept ```     function updateBaseRate(uint newBaseRatePerYear) public {         // check the current block number         uint blockNumber = block.number;         uint deltaBlocks = blockNumber.sub(lastUpdateBlock);           if (deltaBlocks > updateFrequency) {             // pass in a base rate per year             baseRatePerYear = newBaseRatePerYear;             lastUpdateBlock = blockNumber;             emit NewInterestParams(baseRatePerYear);         }     } ```  ## Tools Used Manual review.  ## Recommended Mitigation Steps I have trouble understanding the intention of this function. It appears that the rate should only be able to be set by the admin, so the `_setBaseRatePerYear()` function seems sufficient. Otherwise, add access control for only trusted parties.  "}, {"title": "Stealing Wrapped Manifest in WETH.sol", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/19", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-06-canto-findings", "body": "# Lines of code  https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/WETH.sol#L85   # Vulnerability details  ## Impact Allows anyone to steal all wrapped manifest from the WETH.sol contract. Attacker can also withdraw to convert Wrapped Manifest to Manifest.  Issue in approve(address owner, address spender) external function. This allows an attacker to approve themselves to spend another user's tokens.  Attacker can then use transferFrom(address src, address dst, uint wad) function to send tokens to themself.  ## Proof of Concept Hardhat + Chai test to show exploit. Test file is test/POC.js https://github.com/soosh1337/POC_lending_market_WETH   ## Tools Used VScode, hardhat  ## Recommended Mitigation Steps I believe there is no need for this function. There is another approve(address guy, uint wad) function that uses msg.sender to approve allowance. There should be no need for someone to approve another user's allowance.  Remove the approve(address owner, address spender) function.  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/11", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-canto-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/10", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-canto-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/9", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-canto-findings", "body": "QA Report"}, {"title": "Agreement & Disclosures", "html_url": "https://github.com/code-423n4/2022-06-canto-findings/issues/1", "labels": [], "target": "2022-06-canto-findings", "body": "Agreement & Disclosures"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/413", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-illuminate-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/412", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-illuminate-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/410", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-illuminate-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/409", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-illuminate-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/408", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-illuminate-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/407", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-illuminate-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/406", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-illuminate-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/405", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-illuminate-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/404", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-illuminate-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/403", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-illuminate-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/402", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-illuminate-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/399", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-illuminate-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/395", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-illuminate-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/394", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-illuminate-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/392", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-illuminate-findings", "body": "Gas Optimizations"}, {"title": "[H-05] Not minting iPTs for lenders in several lend functions", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/391", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-06-illuminate-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/lender/Lender.sol#L247-L305 https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/lender/Lender.sol#L317-L367 https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/lender/Lender.sol#L192-L235   # Vulnerability details  ## Impact Using any of the `lend` function mentioned, will result in loss of funds to the lender - as the funds are transferred from them but no iPTs are sent back to them! Basically making lending via these external PTs unusable.   ## Proof of Concept There is no minting of iPTs to the lender (or at all) in the 2 `lend` functions below: https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/lender/Lender.sol#L247-L305 https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/lender/Lender.sol#L317-L367  Corresponding to lending of (respectively): swivel element  Furthermore, in: https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/lender/Lender.sol#L227-L234 Comment says \"Purchase illuminate PTs directly to msg.sender\", but this is not happening. sending yield PTs at best.  ## Recommended Mitigation Steps Mint the appropriate amount of iPTs to the lender - like in the rest of the lend functions.  "}, {"title": "Sandwich attacks are possible as there is no slippage control option in Marketplace and in Lender yield swaps", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/389", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-06-illuminate-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/marketplace/MarketPlace.sol#L131-L189 https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/lender/Lender.sol#L634-L657   # Vulnerability details  Swapping function in Marketplace and Lender's yield() can be sandwiched as there is no slippage control option. Trades can happen at a manipulated price and end up receiving fewer tokens than current market price dictates.  Placing severity to be medium as those are system core operations, while funds there can be substantial, so sandwich attacks are often enough economically viable and thus probable, while they result in a partial fund loss.  ## Proof of Concept  All four swapping functions of Marketplace do not allow for slippage control:  https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/marketplace/MarketPlace.sol#L131-L189  ```solidity     /// @notice sells the PT for the PT via the pool     /// @param u address of the underlying asset     /// @param m maturity (timestamp) of the market     /// @param a amount of PT to swap     /// @return uint128 amount of PT bought     function sellPrincipalToken(         address u,         uint256 m,         uint128 a     ) external returns (uint128) {         IPool pool = IPool(pools[u][m]);         Safe.transfer(IERC20(address(pool.fyToken())), address(pool), a);         return pool.sellFYToken(msg.sender, pool.sellFYTokenPreview(a));     }      /// @notice buys the underlying for the PT via the pool     /// @param u address of the underlying asset     /// @param m maturity (timestamp) of the market     /// @param a amount of underlying tokens to sell     /// @return uint128 amount of PT received     function buyPrincipalToken(         address u,         uint256 m,         uint128 a     ) external returns (uint128) {         IPool pool = IPool(pools[u][m]);         Safe.transfer(IERC20(address(pool.base())), address(pool), a);         return pool.buyFYToken(msg.sender, pool.buyFYTokenPreview(a), a);     }      /// @notice sells the underlying for the PT via the pool     /// @param u address of the underlying asset     /// @param m maturity (timestamp) of the market     /// @param a amount of underlying to swap     /// @return uint128 amount of underlying sold     function sellUnderlying(         address u,         uint256 m,         uint128 a     ) external returns (uint128) {         IPool pool = IPool(pools[u][m]);         Safe.transfer(IERC20(address(pool.base())), address(pool), a);         return pool.sellBase(msg.sender, pool.sellBasePreview(a));     }      /// @notice buys the underlying for the PT via the pool     /// @param u address of the underlying asset     /// @param m maturity (timestamp) of the market     /// @param a amount of PT to swap     /// @return uint128 amount of underlying bought     function buyUnderlying(         address u,         uint256 m,         uint128 a     ) external returns (uint128) {         IPool pool = IPool(pools[u][m]);         Safe.transfer(IERC20(address(pool.fyToken())), address(pool), a);         return pool.buyBase(msg.sender, pool.buyBasePreview(a), a);     } ```  Similarly, Lender's yield does the swapping without the ability to control the slippage:  https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/lender/Lender.sol#L634-L657  ```solidity     /// @notice transfers excess funds to yield pool after principal tokens have been lent out     /// @dev this method is only used by the yield, illuminate and swivel protocols     /// @param u address of an underlying asset     /// @param y the yield pool to lend to     /// @param a the amount of underlying tokens to lend     /// @param r the receiving address for PTs     /// @return uint256 the amount of tokens sent to the yield pool     function yield(         address u,         address y,         uint256 a,         address r     ) internal returns (uint256) {         // preview exact swap slippage on yield         uint128 returned = IYield(y).sellBasePreview(Cast.u128(a));          // send the remaing amount to the given yield pool         Safe.transfer(IERC20(u), y, a);          // lend out the remaining tokens in the yield pool         IYield(y).sellBase(r, returned);          return returned;     } ```  ## Recommended Mitigation Steps  Consider adding minimum accepted return argument to the five mentioned functions and condition execution success on it so the caller can control for the realized slippage and sustain the sandwich attacks to an extent.  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/388", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-illuminate-findings", "body": "QA Report"}, {"title": "Illuminate PT redeeming allows for burning from other accounts", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/387", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-06-illuminate-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/redeemer/Redeemer.sol#L114-L128   # Vulnerability details  Illuminate PT burns shares from a user supplied address account instead of user's account. With such a discrepancy a malicious user can burn all other's user shares by having the necessary shares on her balance, while burning them from everyone else.  Setting the severity to be high as this allows for system-wide stealing of user's funds.  ## Proof of Concept  Redeemer's Illuminate redeem() checks the balance of msg.sender, but burns from the balance of user supplied `o` address:  https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/redeemer/Redeemer.sol#L114-L128  L120:  ```solidity uint256 amount = token.balanceOf(msg.sender); ```  L126:  ```solidity token.burn(o, amount); ```  ```solidity         address principal = IMarketPlace(marketPlace).markets(u, m, p);          if (p == uint8(MarketPlace.Principals.Illuminate)) {             // Get Illuminate's principal token             IERC5095 token = IERC5095(principal);             // Get the amount of tokens to be redeemed from the sender             uint256 amount = token.balanceOf(msg.sender);             // Make sure the market has matured             if (block.timestamp < token.maturity()) {                 revert Invalid('not matured');             }             // Burn the prinicipal token from Illuminate             token.burn(o, amount);             // Transfer the original underlying token back to the user             Safe.transferFrom(IERC20(u), lender, address(this), amount); ```  `o` address isn't validated and used as provided.  Burning proceeds as usual, Illuminate PT burns second argument `a` from the first argument `f`, i.e. `f`'s balance to be reduced by `a`:  https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/marketplace/ERC5095.sol#L121-L127  ```solidity     /// @param f Address to burn from     /// @param a Amount to burn     /// @return bool true if successful     function burn(address f, uint256 a) external onlyAdmin(redeemer) returns (bool) {         _burn(f, a);         return true;     } ```  https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/marketplace/ERC5095.sol#L7  ```solidity contract ERC5095 is ERC20Permit, IERC5095 { ```  https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/marketplace/ERC20.sol#L187-L196  ```solidity     function _burn(address src, uint wad) internal virtual returns (bool) {         unchecked {             require(_balanceOf[src] >= wad, \"ERC20: Insufficient balance\");             _balanceOf[src] = _balanceOf[src] - wad;             _totalSupply = _totalSupply - wad;             emit Transfer(src, address(0), wad);         }          return true;     } ```  This way a malicious user owning some Illuminate PT can burn the same amount of PT as she owns from any another account, that is essentially from all other accounts, obtaining all the underlying tokens from the system. The behavior is somewhat similar to the public burn case.  ## Recommended Mitigation Steps  `o` address looks to be not needed in Illuminate PT case.  Consider burning the shares from `msg.sender`, for example:  https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/redeemer/Redeemer.sol#L125-L126  ```solidity             // Burn the prinicipal token from Illuminate -           token.burn(o, amount); +           token.burn(msg.sender, amount); ```  "}, {"title": "Funds may be stuck when `redeeming` for Illuminate", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/384", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-06-illuminate-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/redeemer/Redeemer.sol#L120   # Vulnerability details  ## Impact Funds may be stuck when `redeeming` for Illuminate.  ## Proof of Concept Assuming the goal of calling `redeem` for Illuminate [here](https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/redeemer/Redeemer.sol#L116) is to redeem the Illuminate principal held by the lender or the redeemer, then there is an issue because the wrong [balance](https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/redeemer/Redeemer.sol#L120) is checked. So if no `msg.sender` has a positive balance funds will be lost.   Now assuming the goal of calling `redeem` for Illuminate [here](https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/redeemer/Redeemer.sol#L116) is for users to redeem their Illuminate principal and receive the underlying as suggested by this [comment](https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/redeemer/Redeemer.sol#L127), then the underlying is not sent back to users because `Safe.transferFrom(IERC20(u), lender, address(this), amount);` send the funds to the redeemer, not the user.    ## Recommended Mitigation Steps Clarify the purpose of this function and fix the corresponding bug.  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/380", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-illuminate-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/378", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-illuminate-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/377", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-illuminate-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/375", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-illuminate-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/371", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-illuminate-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/370", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-illuminate-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/369", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-illuminate-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/367", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-illuminate-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/366", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-illuminate-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/362", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-illuminate-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/361", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-illuminate-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/360", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-illuminate-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/358", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-illuminate-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/355", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-illuminate-findings", "body": "Gas Optimizations"}, {"title": "Potential losses are not distributed fairly among the zcTokens holder, making users that withdraw earlier will be able to get back 100% of the face value, and the late users may not be able to redeem", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/352", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-06-illuminate-findings", "body": "Potential losses are not distributed fairly among the zcTokens holder, making users that withdraw earlier will be able to get back 100% of the face value, and the late users may not be able to redeem"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/351", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-illuminate-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/350", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-illuminate-findings", "body": "QA Report"}, {"title": "Able to mint any amount of PT", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/349", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-06-illuminate-findings", "body": "# Lines of code  [Lender.sol#L192-L235](https://github.com/code-423n4/2022-06-illuminate/blob/main/lender/Lender.sol#L192-L235) [Lender.sol#L486-L534](https://github.com/code-423n4/2022-06-illuminate/blob/main/lender/Lender.sol#L486-L534) [Lender.sol#L545-L589](https://github.com/code-423n4/2022-06-illuminate/blob/main/lender/Lender.sol#L545-L589)   # Vulnerability details  ## Impact  Some of the ```lend``` functions do not validate addresses sent as input which could lead to a malicous user being able to mint more PT tokens than they should.  Functions affect:  - [Illuminate and Yield ```lend``` function](https://github.com/code-423n4/2022-06-illuminate/blob/main/lender/Lender.sol#L192-L235).  - [Sense ```lend``` function](https://github.com/code-423n4/2022-06-illuminate/blob/main/lender/Lender.sol#L486-L534).  - [APWine ```lend``` function](https://github.com/code-423n4/2022-06-illuminate/blob/main/lender/Lender.sol#L545-L589).  ## Proof of Concept  In the Illuminate and Yield ```lend``` function:  1. Let the Yieldspace pool ```y``` be a malicious contract that implements the ```IYield``` interface.  2. The ```base``` and ```maturity``` functions for ```y``` may return any value so the conditions on lines 208 and 210 are easily passed.  3. The caller of ```lend``` sends any amount ```a``` for the desired underlying ```u```.  4. If principal token ```p``` corresponds to the Yield principal, then the ```yield``` function is called which has a [return value controlled by the malicious contract ```y```](https://github.com/code-423n4/2022-06-illuminate/blob/main/lender/Lender.sol#L648).  5. The ```mint``` function is then called for the principal token with an underlying ```u``` and a maturity ```m``` which will then mint the ```returned``` amount of principal tokens to the malicious user.    In the Sense ```lend``` function:  1. Let the amm ```x``` input variable be a malicous contract that implements the ```ISense``` interface.  2. The malicious user sends any amount of underlying to ```Lender.sol```.  3. Since the amm isn't validated, the ```swapUnderlyingForPTs``` function can return any amount for ```returned``` that is used to mint the Illuminate tokens.  4. The malicious user gains a disproportionate amount of PT.    In the APWine ```lend``` function:  1. Let the APWine ```pool``` input variable be a malicous contract that implements the ```IAPWineRouter``` interface.  2. The malicious user sends any amount of underlying to ```Lender.sol```.  3. The ```swapExactAmountIn``` function of the malicious ```pool``` contract returns any amount for ```returned```.  4. The ```mint``` function is called for the PT with underlying ```u``` and maturity ```m``` with the attacker controlled ```returned``` amount.  ## Recommmended Mitigation Steps  Consider validating the input addresses of [```y```](https://github.com/code-423n4/2022-06-illuminate/blob/main/lender/Lender.sol#L197), [```x```](https://github.com/code-423n4/2022-06-illuminate/blob/main/lender/Lender.sol#L492) and [```pool```](https://github.com/code-423n4/2022-06-illuminate/blob/main/lender/Lender.sol#L551) through a whitelisting procedure if possible or validating that the ```returned``` amounts correspond with the amount of PT gained from the protocols by checking the balance before and after the PTs are gained and checking the difference is equal to ```returned```.  "}, {"title": "`Redeemer.sol#redeem()` can be called by anyone before maturity, which may lead to loss of user funds", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/347", "labels": ["bug", "3 (High Risk)"], "target": "2022-06-illuminate-findings", "body": "`Redeemer.sol#redeem()` can be called by anyone before maturity, which may lead to loss of user funds"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/346", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-illuminate-findings", "body": "QA Report"}, {"title": "[M-01] Easily bypassing admins 'pause' for swivel", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/343", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-06-illuminate-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/lender/Lender.sol#L247-L305   # Vulnerability details  ## Impact Assuming admin decides to pause an external principle when it's dangerous, malicious or unprofitable, Bypassing the admins decision can result in loss of funds for the project.  ## Proof of Concept https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/lender/Lender.sol#L247-L305  * The principals enum `p` is only used for `unpaused(p)` modifier, and to emit an event. * Attacker can bypass the `unpaused(p)` modifier check by simply passing an enum of another principle that is not paused. * The function will just continue as normal, without any other side-effect, as if the `pause` is simple ignored.  ## Recommended Mitigation Steps Add this check at the beginning of the function (just like in similar functions of this solution) `        if (p != uint8(MarketPlace.Principals.Swivel)) {             revert Invalid('principal');         } `  "}, {"title": "Unable to redeem from Notional", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/341", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-06-illuminate-findings", "body": "# Lines of code  [Redeemer.sol#L193](https://github.com/code-423n4/2022-06-illuminate/blob/main/redeemer/Redeemer.sol#L193)   # Vulnerability details  ## Impact  The ```maxRedeem``` function is a view function which only returns the balance of the ```Redeemer.sol``` contract. After this value is obtained, the PT is not redeemed from Notional. The user will be unable to redeem PT from Notional through ```Redeemer.sol```.  ## Proof of Concept  Notional code: ```     function maxRedeem(address owner) public view override returns (uint256) {         return balanceOf(owner);     } ```  ## Recommmended Mitigation Steps  Call [```redeem```](https://github.com/notional-finance/wrapped-fcash/blob/019cfa20369d5e0d9e7a38fea936cc649704780d/contracts/wfCashERC4626.sol#L205) from Notional using the ```amount``` from ```maxRedeem``` as the ```shares``` input after the call to ```maxRedeem```.  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/340", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-illuminate-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/334", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-illuminate-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/333", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-illuminate-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/330", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-illuminate-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/329", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-illuminate-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/328", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-illuminate-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/324", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-illuminate-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/323", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-illuminate-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/322", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-illuminate-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/321", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-illuminate-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/319", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-illuminate-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/312", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-illuminate-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/310", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-illuminate-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/309", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-illuminate-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/303", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-illuminate-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/300", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-illuminate-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/298", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-illuminate-findings", "body": "Gas Optimizations"}, {"title": "Principal types in Illuminate and Yield lending are mixed up", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/295", "labels": ["bug", "2 (Med Risk)", "sponsor disputed"], "target": "2022-06-illuminate-findings", "body": "Principal types in Illuminate and Yield lending are mixed up"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/292", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-illuminate-findings", "body": "QA Report"}, {"title": "Leak of Value in `yield` function, slippage check is not effective", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/289", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-06-illuminate-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/lender/Lender.sol#L641-L654   # Vulnerability details  The function `yield` is using the input from `sellBasePreview` and then using it.  https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/lender/Lender.sol#L641-L654  ```solidity     function yield(         address u,         address y,         uint256 a,         address r     ) internal returns (uint256) {         // preview exact swap slippage on yield         uint128 returned = IYield(y).sellBasePreview(Cast.u128(a));          // send the remaing amount to the given yield pool         Safe.transfer(IERC20(u), y, a);          // lend out the remaining tokens in the yield pool         IYield(y).sellBase(r, returned); ```  The output of `sellBasePreview` is meant to be used off-chain to avoid front-running and price changes, additionally no validation is performed on this value (is it zero, is it less than 95% of amount) meaning the check is equivalent to setting `returned = 0`  I'd recommend to add checks, or ideally have a trusted keeper bulk `sellBase` with an additional slippage check as the function parameter  "}, {"title": "`scheduleWithdrawal` should have a timeout", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/287", "labels": ["bug", "disagree with severity", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-06-illuminate-findings", "body": "`scheduleWithdrawal` should have a timeout"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/279", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-illuminate-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/278", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-illuminate-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/276", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-illuminate-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/275", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-illuminate-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/272", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-illuminate-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/271", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-illuminate-findings", "body": "Gas Optimizations"}, {"title": "Incorrect implementation of APWine and Tempus `redeem`", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/268", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-06-illuminate-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/redeemer/Redeemer.sol#L136   # Vulnerability details  Redeeming APWine and Tempus PT will always fail, causing a portion of iPT to not be able to be redeemed for the underlying token.  The issue is caused by the incorrect implementation of `redeem`: ``` uint256 amount = IERC20(principal).balanceOf(lender); Safe.transferFrom(IERC20(u), lender, address(this), amount); ``` The first line correctly calculates the balance of PT token available in `Lender`. However, the second line tries to transfer the underlying token `u` instead of `principal` from Lender to `Redeemer`. Therefore, the redeeming process will always fail as both `APWine.withdraw` and `ITempus.redeemToBacking` will try to redeem non-existent PT.  ## Recommended Mitigation Steps Fix the transfer line: ``` Safe.transferFrom(IERC20(principal), lender, address(this), amount); ```  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/264", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-illuminate-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/263", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-illuminate-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/262", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-illuminate-findings", "body": "QA Report"}, {"title": "Lender: no check for paused market on mint", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/260", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-06-illuminate-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-illuminate/blob/main/lender/Lender.sol#L172   # Vulnerability details  Lender's `mint` function [does not check](https://github.com/code-423n4/2022-06-illuminate/blob/main/lender/Lender.sol#L172) whether the supplied market is paused.  ## Impact Even if a market is paused due to insolvency/bugs, an attacker can issue iPTs. This renders the whole pause and insolvency protection mechanism ineffective. See POC.  ## Proof of Concept Let's say market P has become insolvent, and Illuminate pauses that market, as it doesn't want to create further bad debt. Let's say P's principal tokens's value has declined severely in the market because of the insolvency. An attacker can buy many worthless P principal tokens for cheap, then call Lender and mint from them iPT. The attacker is now owed underlying which belongs to the legitimate users. There won't be enough funds to repay everybody.  ## Recommended Mitigation Steps Check in `mint` that the market is not paused.  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/256", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-illuminate-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/255", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-illuminate-findings", "body": "QA Report"}, {"title": "ERC5095 redeem/withdraw does not update allowances", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/245", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-06-illuminate-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-illuminate/blob/main/marketplace/ERC5095.sol#L100   # Vulnerability details  ERC5095's `redeem`/`withdraw` allows an ERC20-approved account to redeem user's tokens, but does not update the allowance after burning.  ## Impact User Mal can burn more tokens than Alice allowed him to. He can set himself to be the receiver of the underlying, therefore Alice will lose funds.  ## Proof of Concept [`withdraw`](https://github.com/code-423n4/2022-06-illuminate/blob/main/marketplace/ERC5095.sol#L100) and [`redeem`](https://github.com/code-423n4/2022-06-illuminate/blob/main/marketplace/ERC5095.sol#L116) functions check that the msg.sender has enough approvals to redeem the tokens: ```             require(_allowance[holder][msg.sender] >= underlyingAmount, 'not enough approvals'); ``` But they do not update the allowances. They then call `authRedeem`, which also does not update the allowances. Therefore, an approved user could \"re-use his approval\" again and again and redeem whole of approver's funds to himself.  ## Recommended Mitigation Steps Update the allowances upon spending.  "}, {"title": "Redeem Sense can be bricked", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/244", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-06-illuminate-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-illuminate/blob/main/redeemer/Redeemer.sol#L262   # Vulnerability details  Sense's `redeem` can be totally DOSd due to user supplied input.  ## Impact Using this attack, Sense market can not be redeemed.  ## Proof of Concept [This](https://github.com/code-423n4/2022-06-illuminate/blob/main/redeemer/Redeemer.sol#L253:#L262) is how Sense market is being redeemed: ```         IERC20 token = IERC20(IMarketPlace(marketPlace).markets(u, m, p));         uint256 amount = token.balanceOf(lender);         Safe.transferFrom(token, lender, address(this), amount);         ISense(d).redeem(o, m, amount); ``` The problem is that `d` is user supplied input and the function only tries to redeem the amount that was transferred from Lender.  A user can supply malicious `d` contract which does nothing on `redeem(o, m, amount)`. The user will then call Redeemer's `redeem` with his malicious contract. Redeemer will transfer all the prinicipal from Lender to itself, will call `d` (noop), and finish. Sense market has not been redeemed.  Now if somebody tries to call Sense market's `redeem` again, the `amount` variable will be 0, and Redeemer will try to redeem 0 from Sense.  All the original principal is locked and lost in the contract, like tears in rain.  ## Recommended Mitigation Steps I think you should either use a whitelisted Sense address, or send to `ISense(d).redeem` Redeemer's whole principal balance.  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/241", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-illuminate-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/239", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-illuminate-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/235", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-illuminate-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/231", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-illuminate-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/227", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-illuminate-findings", "body": "Gas Optimizations"}, {"title": "Tempus lend method wrongly calculates amount of iPT tokens to mint", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/222", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-06-illuminate-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-illuminate/blob/main/lender/Lender.sol#L465:#L466   # Vulnerability details  The Tempus `lend` method calculates the amount of tokens to mint as `amountReturnedFromTempus - lenderBalanceOfMetaPrincipalToken`. This seems wrong as there's no connection between the two items. Tempus has no relation to the iPT token.  ## Impact Wrong amount of iPT will be minted to the user. If the Lender contract has iPT balance, the function will revert, otherwise, user will get minted 0 iPT tokes.  ## Proof of Concept [This](https://github.com/code-423n4/2022-06-illuminate/blob/main/lender/Lender.sol#L465:#L469) is how the `lend` method calculates the amount of iPT tokens to mint: ```         uint256 returned = ITempus(tempusAddr).depositAndFix(Any(x), Any(t), a - fee, true, r, d) -             illuminateToken.balanceOf(address(this));         illuminateToken.mint(msg.sender, returned); ``` The Tempus `depositAndFix` method [does not return](https://etherscan.io/address/0xdB5fD0678eED82246b599da6BC36B56157E4beD8#code#F1#L127) anything. Therefore this calculation will revert if `illuminateToken.balanceOf(address(this)) > 0`, or will return 0 if the balance is 0.  [Note: there's another issue here where the depositAndFix sends wrong parameters - I will submit it in another issue.]  ## Recommended Mitigation Steps I believe that what you intended to do is to check how many Tempus principal tokens the contract received. So you need to check Lender's `x.tempusPool().principalShare()` before and after the swap, and the delta is the amount received.  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/211", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-illuminate-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/210", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-illuminate-findings", "body": "Gas Optimizations"}, {"title": "```withdraw``` eToken before ```withdrawFee``` of eToken could render ```withdrawFee``` of eToken unfunctioning", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/209", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-06-illuminate-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/lender/Lender.sol#L705-L720 https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/lender/Lender.sol#L659-L675   # Vulnerability details  ```withdrawFee``` of eToken requires the amount of eToken in ```Lender.sol``` >= ```fees[eToken]``` so ```Safe.transfer``` will not revert. However if the admin ```withdraw(eToken)``` first, the balance of eToken in ```Lender.sol``` will equal to zero while ```fees[eToken]``` remains the same and ```withdrawFee(eToken)``` will become unfunctioning since eToken in the contract does not match ```fees[eToken]```. The admin will need to rely on ```withdraw```, which takes 3 days before transfering, to get the future fees of eToken.  ### Mitigations add ```fees[eToken] = 0;``` after ```withdrawals[e] = 0;```  in ```withdraw```.   "}, {"title": "Lend method signature for illuminate does not track the accumulated fee ", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/208", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-06-illuminate-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/lender/Lender.sol#L185-L235   # Vulnerability details  Normally the amount of fees after ```calculateFee``` should be added into ```fees[u]``` so that the admin could withdraw it through ```withdrawFee```. However, illuminate ledning does not track ```fees[u]```. Therefore, the only way to get fees back is through ```withdraw``` which admin needs to wait at least 3 days before receiving the fees.    ### Mitigations  Add the amount of fee after each transaction into ```fees[u]``` like other lending method.   for example: ``` fees[u] += calculateFee(a);```  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/205", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-illuminate-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/204", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-illuminate-findings", "body": "QA Report"}, {"title": "Swivel lend method doesn't pull protocol fee from user", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/201", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-06-illuminate-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-illuminate/blob/main/lender/Lender.sol#L297   # Vulnerability details  The Swivel `lend` method adds to `fees[u]` the order fee, but does not pull that fee from the user. It only pulls the order-post-fee amount.  ## Impact `withdrawFee` will fail, as it tries to transfer more tokens than are in the contract.  ## Proof of Concept The Swivel `lend` method [sums up](https://github.com/code-423n4/2022-06-illuminate/blob/main/lender/Lender.sol#L279:#L283) the fees to `totalFee`, and the amount to send to Swivel in `lent`: ```                     totalFee += fee;                     // Amount lent for this order                     uint256 amountLent = amount - fee;                     // Sum the total amount lent to Swivel (amount of ERC5095 tokens to mint) minus fees                     lent += amountLent; ``` It then [increments](https://github.com/code-423n4/2022-06-illuminate/blob/main/lender/Lender.sol#L294:#L297) `fees[u]` by `totalFee`, but only pulls from the user `lent`: ```             fees[u] += totalFee;             // transfer underlying tokens from user to illuminate             Safe.transferFrom(IERC20(u), msg.sender, address(this), lent); ``` Therefore, `totalFee` has not been pulled from the user. The `fees` variable now includes tokens which are not in the contract, and `withdrawFee` will fail as [it tries to transfer](https://github.com/code-423n4/2022-06-illuminate/blob/main/lender/Lender.sol#L667) `fees[u]`.  ## Recommended Mitigation Steps Pull `lent + totalFee` from the user.  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/194", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-illuminate-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/193", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-illuminate-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/183", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-illuminate-findings", "body": "Gas Optimizations"}, {"title": "Redeemer.redeem() for Element withdraws PT to wrong address.", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/182", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-06-illuminate-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-illuminate/blob/92cbb0724e594ce025d6b6ed050d3548a38c264b/redeemer/Redeemer.sol#L187   # Vulnerability details  ## Impact Redeemer.redeem() for Element withdraws PT to wrong address. This might cause a result of loss of PT.   ## Proof of Concept According to the ReadMe.md, Redeemer should transfer external principal tokens from Lender.sol to Redeemer.sol. But it transfers to the \"marketPlace\" and it would lose the PT.   ## Tools Used Manual Review   ## Recommended Mitigation Steps Modify [IElementToken(principal).withdrawPrincipal(amount, marketPlace);](https://github.com/code-423n4/2022-06-illuminate/blob/92cbb0724e594ce025d6b6ed050d3548a38c264b/redeemer/Redeemer.sol#L187) like this.  ``` IElementToken(principal).withdrawPrincipal(amount, address(this)); ```  "}, {"title": "Allowance check always true in ERC5095 redeem", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/173", "labels": ["bug", "3 (High Risk)", "sponsor disputed"], "target": "2022-06-illuminate-findings", "body": "Allowance check always true in ERC5095 redeem"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/170", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-illuminate-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/169", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-illuminate-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/167", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-illuminate-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/166", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-illuminate-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/160", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-illuminate-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/150", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-illuminate-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/147", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-illuminate-findings", "body": "Gas Optimizations"}, {"title": "Checking yieldBearingToken against u instead of backingToken", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/139", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed"], "target": "2022-06-illuminate-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/lender/Lender.sol#L446   # Vulnerability details  ## Impact The lend function for tempus will fail with the right market.  ## Proof of concept checks `if (ITempus(principal).yieldBearingToken() != IERC20Metadata(u))`, while it should check `ITempus(principal).backingToken()`   ## Recommendation Do this instead: ```     if (ITempus(principal).backingToken() != IERC20Metadata(u)) ```  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/138", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-illuminate-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/128", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-illuminate-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/127", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-illuminate-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/125", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-illuminate-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/123", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-illuminate-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/122", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-illuminate-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/118", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-illuminate-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/108", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-illuminate-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/104", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-illuminate-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/103", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-illuminate-findings", "body": "Gas Optimizations"}, {"title": "`Safe.sol` allow success transaction to fail", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/100", "labels": ["bug", "disagree with severity", "QA (Quality Assurance)", "sponsor acknowledged", "sponsor confirmed"], "target": "2022-06-illuminate-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/lender/Safe.sol#L82-L105 https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/marketplace/Safe.sol#L82-L105 https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/redeemer/Safe.sol#L82-L105   # Vulnerability details   ## `Safe.sol` allow success transaction to fail Some ERC20 token implementations return more than 32 bytes(common Curve token). This can be a real concern since all core component using the same Safe Transfer Lib   After some test using  [https://github.com/Rari-Capital/solmate.git]  ``` [BAIL] testTransferFromWithReturnsTooMuch() [FAIL] testTransferFromWithReturnsTooMuch(address,address,uint256,bytes). Counterexample: (0x00000000000000000000000000000000000ffffE, 0x0000000000000000000000000000000000000001, 115792089237316195423570985008687907853269984665640564039457584007913129639935, 0x) [BAIL] testApproveWithReturnsTooMuch() [FAIL] testFailApproveWithReturnsTwo(address,uint256,bytes). Counterexample: (0x000000000000000000000000000000000004C0E4, 0, 0x) [FAIL] testApproveWithReturnsTooMuch(address,uint256,bytes). Counterexample: (0x00000000000000000000000000000000000ffffE, 1, 0x) [FAIL] testTransferWithReturnsTooMuch(address,uint256,bytes). Counterexample: (0x00000000000000000000000000000000000fFFFf, 27379694730619439495811032571422462501613862458272780721729846947764021554765, 0x) [BAIL] testTransferWithReturnsTooMuch() [FAIL] testFailTransferWithGarbage(address,uint256,bytes,bytes). Counterexample: (0x00000000000000000000000000000000000F40ae, 68959440145808540021340254471931488759807906017241826129032747446, 0x15dedf2835614b24353f20baa93783e58366c16defd811eddd5de9d9057489ca, 0xd946b45606da60c706edf8c4eb76e0d281d8f063f14850d952ea10c697f0931756bec369411fa90953093f29086d44a50b2cf829a5815f5a72124ff447ac4a69) ```   ## Impact If a transaction fail or success will not be considered and this will pass any call of Safe lib  ## Proof of Concept  https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/lender/Safe.sol  Safe lib used here ``` ./lender/Lender.sol ./marketplace/marketplace.sol ./redeemer/redeemer.sol ```      1- no data     if iszero(r) {         // Copy the revert message into memory.         returndatacopy(0, 0, returnDataSize)          // Revert with the same message.         revert(0, returnDataSize)     }      2- returndatasize > 32 bytes     default {         // It returned some malformed input.         result := 0     }      3- reverting     require(success(result), 'transfer from failed');  ### Tools Used dapp-tools, vim  ### Recommended Mitigation Steps Use the latest Safe Transfer lib available   "}, {"title": "Invalid import", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/99", "labels": ["bug", "disagree with severity", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-06-illuminate-findings", "body": "Invalid import"}, {"title": "Pendle Uses Wrong Return Value For `swapExactTokensForTokens()`", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/94", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-06-illuminate-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/lender/Lender.sol#L411   # Vulnerability details  ## Impact  The function `swapExactTokensForTokens()` will return and array with the 0 index being the input amount follow by each output amount. The 0 index is incorrectly used in Pendle `lend()` function as the output amount. As a result the value of `returned` will be the invalid (i.e. the input rather than the output).  Since this impacts how many PTs will be minted to the `msg.sender`, the value will very likely be significantly over or under stated depending on the exchange rate. Hence the `msg.sender` will receive an invalid number of PT tokens.  ## Proof of Concept  ```solidity             address[] memory path = new address[](2);             path[0] = u;             path[1] = principal;              returned = IPendle(pendleAddr).swapExactTokensForTokens(a - fee, r, path, address(this), d)[0]; ```   ## Recommended Mitigation Steps  The amount of `principal` returned should be index 1 of the array returned by `swapExactTokensForTokens()`.  "}, {"title": "Calls To `Swivel.initiate()` Do Not Verify `o.exit` or `o.vault` Allowing An Attacker To Manipulate Accounting In Their Favour", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/93", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed"], "target": "2022-06-illuminate-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-illuminate/blob/912be2a90ded4a557f121fe565d12ec48d0c4684/lender/Lender.sol#L299   # Vulnerability details  ## Impact  Swivel `lend()` does not validate the `o.exit` and `o.vault` for each order before making the external call to Swivel. These values determine which internal functions is [called in Swivel](https://github.com/Swivel-Finance/swivel/blob/2471ea5cda53568df5e5515153c6962f151bf358/contracts/v2/swivel/Swivel.sol#L64-L77).  The intended code path is `initiateZcTokenFillingVaultInitiate()` which takes the underlying tokens and mints zcTokens to the `Lender`. If one of the other functions is called the accounting in `lend()`. Swivel may transfer more tokens from `Lender` to `Swivel` than paid for by the caller of `lend()`.  The impact is that underlying tokens may be stolen from `Lender`.  ## Proof of Concept  Consider the example where [initiateZcTokenFillingZcTokenExit()](https://github.com/Swivel-Finance/swivel/blob/2471ea5cda53568df5e5515153c6962f151bf358/contracts/v2/swivel/Swivel.sol#L162) is called. This will transfer `a - premiumFilled + fee` from `Lender` to `Swivel` rather than the expected `a + fee`.  ## Recommended Mitigation Steps  In `lend()` restrict the values of `o.exit` and `o.vault` so only one case can be triggered in `Swivel.initiate()`.  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/91", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-illuminate-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/90", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-illuminate-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/89", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-illuminate-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/84", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-illuminate-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/83", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-illuminate-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/78", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-illuminate-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-illuminate-findings/issues/77", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-illuminate-findings", "body": "Gas Optimizations"}]