[{"title": "TimeswapPair.sol modifier lock: Switching between 1, 2 instead of 0, 1 is more gas efficient", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/87", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "# Handle  bitbopper   # Vulnerability details  ## Impact `https://github.com/code-423n4/2022-01-timeswap/blob/5960e07d39f2b4a60cfabde1bd51f4b1e62e7e85/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L121:L126` could be more gas efficient  ## Proof of Concept ### Version as in Repo  ``` // SPDX-License-Identifier: GPL-3.0-or-later pragma solidity =0.8.4;  contract LockProofOld {  uint256 locked = 0;   modifier lock() {      require(locked == 0, 'E211');      locked = 1;      _;      locked = 0;  }   function test() public lock {  }  } ``` ### Proposed Version ``` // SPDX-License-Identifier: GPL-3.0-or-later pragma solidity =0.8.4;  contract LockProofNew {  uint256 locked = 1;   modifier lock() {      require(locked == 1, 'E211');      locked = 2;      _;      locked = 1;  }   function test() public lock {  }  } ```  ### Comparison #### Test harness ``` // SPDX-License-Identifier: GPL-3.0-or-later pragma solidity =0.8.4;  import \"ds-test/test.sol\";  import \"./LockProofOld.sol\"; import \"./LockProofNew.sol\";  contract LockProofTest is DSTest {     LockProofOld lockproofold;     LockProofNew lockproofnew;      function setUp() public {         lockproofold = new LockProofOld();         lockproofnew = new LockProofNew();     }      function test_old() public {   lockproofold.test();     }      function test_new() public {   lockproofnew.test();     } } ``` #### Output ``` dapp test Running 2 tests for src/LockProof.t.sol:LockProofTest [PASS] test_old() (gas: 21042) [PASS] test_new() (gas: 1136) ```   "}, {"title": "DOS pay function", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/86", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-01-timeswap-findings", "body": "DOS pay function"}, {"title": "`pendingOwner` should be reset to `address(0)` after `acceptOwner()` is successfully called", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/83", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact The `acceptOwner()` external function can be called indefinitely instead of only once. The contract's state doesn't reflect reality. The code doesn't follow the standard implementation of a 2-step ownership transfer.  ## Proof of Concept Here's the current `acceptOwner()` external function, which lacks a reset of `pendingOwner` to `address(0)` : ```     function acceptOwner() external override {         require(msg.sender == pendingOwner, 'E102');         owner = msg.sender;          emit AcceptOwner(msg.sender);     } ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Change the code to: ```     function acceptOwner() external override {         require(msg.sender == pendingOwner, 'E102');         owner = msg.sender;         pendingOwner = address(0); // @audit : line to add          emit AcceptOwner(msg.sender);     } ```  "}, {"title": "Unused Named Returns", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/81", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "Unused Named Returns"}, {"title": "Gas optimization: Placement of require statements in `TimeswapPair:pay()`", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/80", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact Some of the require statements can be placed earlier to reduce gas usage on revert. As a reminder from the [Ethereum Yellow Paper](https://ethereum.github.io/yellowpaper/paper.pdf), Appendix G and Appendix H: - TIMESTAMP costs 2 gas - ADDRESS costs 2 gas - MLOAD costs 3 gas  ## Proof of Concept The following can be reorder to save gas on revert:  ```         require(block.timestamp < maturity, 'E202');          require(ids.length == assetsIn.length && ids.length == collateralsOut.length, 'E205');         require(to != address(0), 'E201');         require(to != address(this), 'E204'); ``` to ```         require(block.timestamp < maturity, 'E202');         require(to != address(0), 'E201');         require(to != address(this), 'E204');         require(ids.length == assetsIn.length && ids.length == collateralsOut.length, 'E205'); ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Relocate the said require statements  "}, {"title": "users might pay enormous amouts of gas", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/74", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-01-timeswap-findings", "body": "users might pay enormous amouts of gas"}, {"title": "Wrong Safe implementation", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/69", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2022-01-timeswap-findings", "body": "Wrong Safe implementation"}, {"title": "\"constants\" expressions are expressions, not constants. Use \"immutable\" instead.", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/62", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact   Due to how `constant` variables are implemented, an expression assigned to a `constant` variable is recomputed each time that the variable is used, which wastes some gas.      If the variable was `immutable` instead: the calculation would only be done once at deploy time (in the constructor), and then the result would be saved and read directly at runtime rather than being recalculated.    See: [ethereum/solidity#9232]([https://github.com/ethereum/solidity/issues/9232](https://github.com/ethereum/solidity/issues/9232))      ## Proof of Concept   ```   Timeswap-V1-Convenience\\contracts\\libraries\\DateTime.sol:31:    uint constant SECONDS_PER_DAY = 24 * 60 * 60; Timeswap-V1-Convenience\\contracts\\libraries\\DateTime.sol:32:    uint constant SECONDS_PER_HOUR = 60 * 60; ```      ## Tools Used   VS Code      ## Recommended Mitigation Steps   Change these expressions from `constant` to `immutable` and implement the calculation in the constructor   "}, {"title": "Use Custom Errors instead of Revert Strings to save Gas", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/61", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-timeswap-findings", "body": "Use Custom Errors instead of Revert Strings to save Gas"}, {"title": "Mint library uses wrong error code for max collateral check", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/56", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "# Handle  hyh   # Vulnerability details  ## Impact  There can be issues with troubleshooting and system usage analytics.  ## Proof of Concept  E512 error code is meant for 'Debt is greater than max Debt' situation:  https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Convenience/ErrorCodes.md#e512   In Mint library E512 is used for collateral max value check:  https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Convenience/contracts/libraries/Mint.sol#L482   Also, code E513, that is to be used for collateral check above, is also used for max asset increase check, which doesn\u2019t seem to have an error code of its own:  https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Convenience/contracts/libraries/Mint.sol#L481  https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Convenience/contracts/libraries/Mint.sol#L643   ## Recommended Mitigation Steps  Change Mint line 482 error code to be 513: https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Convenience/ErrorCodes.md#e513  Possibly add an error code for max asset check for Mint lines 481 and 643.  "}, {"title": "Gas saving", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/51", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "Gas saving"}, {"title": "A more efficient for loop index proceeding", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/49", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "A more efficient for loop index proceeding"}, {"title": "No check that _factory and _weth are different addresses in constructor ", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/45", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "# Handle  jayjonah8   # Vulnerability details  ## Impact In TimeswapConvenience.sol the constructor takes in 2 addresses for _factory and _weth and sets them in storage without checking that they are unique which can introduce possible costly errors during deployment.   ## Proof of Concept https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Convenience/contracts/TimeswapConvenience.sol#L62  ## Tools Used Manuel code review   ## Recommended Mitigation Steps Add to TimeswapConvenience.sol constructor:   require(_factory != _weth, \"Duplicate address\")  "}, {"title": "no reentrancy guard on mint() function that has a callback ", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/43", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "# Handle  jayjonah8   # Vulnerability details  ## Impact In CollateralizedDebt.sol, the mint() function calls _safeMint() which has a callback to the \"to\" address argument.  Functions with callbacks should have reentrancy guards in place for protection against possible malicious actors both from inside and outside the protocol.    ## Proof of Concept https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Convenience/contracts/CollateralizedDebt.sol#L76  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/ERC721.sol#L263  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/ERC721.sol#L395  ## Tools Used Manual code review   ## Recommended Mitigation Steps Add a reentrancy guard modifier on the mint() function in CollateralizedDebt.sol   "}, {"title": "Insurance.sol constructor doesn't check if addresses passed are unique ", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/42", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2022-01-timeswap-findings", "body": "Insurance.sol constructor doesn't check if addresses passed are unique "}, {"title": "Liquidity constructor doesn't check that addresses are unique ", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/39", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2022-01-timeswap-findings", "body": "Liquidity constructor doesn't check that addresses are unique "}, {"title": "waste of gas", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/37", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-timeswap-findings", "body": "waste of gas"}, {"title": "gas", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/36", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "# Handle  danb   # Vulnerability details  https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/libraries/MintMath.sol#L65  ``` y <= x ``` can be removed  "}, {"title": "dangerous receive function", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/35", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "# Handle  danb   # Vulnerability details  https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Convenience/contracts/TimeswapConvenience.sol#L69  the contract should receive ether only from weth,  consider adding:  ``` require(msg.sender == weth); ```  "}, {"title": "Core configuration variables aren't checked for operational mistakes on construction", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/34", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2022-01-timeswap-findings", "body": "Core configuration variables aren't checked for operational mistakes on construction"}, {"title": "Improper Upper Bound Definition on the Fee", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/33", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2022-01-timeswap-findings", "body": "Improper Upper Bound Definition on the Fee"}, {"title": "Use `calldata` instead of `memory` for function parameters", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/32", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-timeswap-findings", "body": "Use `calldata` instead of `memory` for function parameters"}, {"title": "Named return issue", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/24", "labels": ["bug", "1 (Low Risk)"], "target": "2022-01-timeswap-findings", "body": "Named return issue"}, {"title": "Not verified function inputs of public / external functions", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/23", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2022-01-timeswap-findings", "body": "Not verified function inputs of public / external functions"}, {"title": "Public functions to external", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/16", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "Public functions to external"}, {"title": "SafeTransfer library called from pay() function is not needed ", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/11", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "# Handle  jayjonah8   # Vulnerability details  ## Impact In TimeswapPair.sol the pay() function calls safeTransfer() and does so using the SafeTransfer.sol library when it can simply add the open zeppelin SafeERC20.sol import directly inside TimeswapPair.sol itself eliminating the unnecessary code in the protocols own SafeTransfer library.   ## Proof of Concept https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L374  https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/libraries/SafeTransfer.sol#L7  ## Tools Used Manual code review   ## Recommended Mitigation Steps Use the open zeppelin SafeERC20 import directly inside the TimeswapPair.sol file instead of calling your own library.  The extra safeTransfer library can then be deleted.   "}, {"title": "missing check  in constructor ", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/10", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2022-01-timeswap-findings", "body": "missing check  in constructor "}, {"title": "pay() function has callback to msg.sender before important state updates ", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/7", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "# Handle  jayjonah8   # Vulnerability details  ## Impact In TimeswapPair.sol, the pay() function has a callback to the msg.sender in the middle of the function while there are still updates to state that take place after the callback.  The lock modifier guards against reentrancy but not against cross function reentrancy.  Since the protocol implements Uniswap like functionality,  this can be extremely dangerous especially with regard to composability/interacting with other protocols and contracts.  The callback before important state changes (updates to reserves collateral and reserves assets) also violates the Checks Effects Interactions best practices further widening the attack surface.   ## Proof of Concept https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L369  https://fravoll.github.io/solidity-patterns/checks_effects_interactions.html  cross function reentrancy https://medium.com/coinmonks/protect-your-solidity-smart-contracts-from-reentrancy-attacks-9972c3af7c21  ## Tools Used Manual code review   ## Recommended Mitigation Steps The callback \"if (assetIn > 0) Callback.pay(asset, assetIn, data);\"  should be placed at the end of the pay() function after all state updates have taken place.   "}, {"title": "borrow() function has state updates after a callback to msg.sender ", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/6", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "# Handle  jayjonah8   # Vulnerability details  ## Impact In TimeswapPair.sol, the borrow() function has a callback to the msg.sender in the middle of the function while there are still updates to state that take place after the callback.  The lock modifier guards against reentrancy but not against cross function reentrancy.  Since the protocol implements Uniswap like functionality,  this can be extremely dangerous especially with regard to composability/interacting with other protocols and contracts.  The callback before important state changes (updates to collateral, totalDebtCreated and reserves assets) also violates the Checks Effects Interactions best practices further widening the attack surface.   ## Proof of Concept https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L322  https://fravoll.github.io/solidity-patterns/checks_effects_interactions.html  cross function reentrancy https://medium.com/coinmonks/protect-your-solidity-smart-contracts-from-reentrancy-attacks-9972c3af7c21  ## Tools Used Manual code review   ## Recommended Mitigation Steps The callback Callback.borrow(collateral, dueOut.collateral, data); should be placed at the end of the borrow() function after all state updates have taken place.   "}, {"title": "In the lend() function state updates are made after the callback ", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/5", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "# Handle  jayjonah8   # Vulnerability details  ## Impact In TimeswapPair.sol, the lend() function has a callback to the msg.sender in the middle of the function while there are still updates to state that take place after the callback.  The lock modifier guards against reentrancy but not against cross function reentrancy.  Since the protocol implements Uniswap like functionality,  this can be extremely dangerous especially with regard to composability/interacting with other protocols and contracts.  The callback before important state changes (updates to totalClaims bonds,  insurance and reserves assets) also violates the Checks Effects Interactions best practices further widening the attack surface.   ## Proof of Concept https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L246  https://fravoll.github.io/solidity-patterns/checks_effects_interactions.html  cross function reentrancy https://medium.com/coinmonks/protect-your-solidity-smart-contracts-from-reentrancy-attacks-9972c3af7c21  ## Tools Used Manual code review   ## Recommended Mitigation Steps The callback Callback.lend(asset, xIncrease, data); should be placed at the end of the lend() function after all state updates have taken place.   "}, {"title": "Important state updates are made after the callback in the mint() function ", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/4", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "# Handle  jayjonah8   # Vulnerability details  ## Impact In TimeswapPair.sol, the mint() function has a callback in the middle of the function while there are still updates to state that take place after the callback.  The lock modifier guards against reentrancy but not against cross function reentrancy.  Since the protocol implements Uniswap like functionality,  this can be extremely dangerous especially with regard to composability/interacting with other protocols and contracts.  The callback before important state changes (updates to reserve asset, collateral, and totalDebtCreated) also violates the Checks Effects Interactions best practices further widening the attack surface.   ## Proof of Concept https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L177  https://fravoll.github.io/solidity-patterns/checks_effects_interactions.html  cross function reentrancy https://medium.com/coinmonks/protect-your-solidity-smart-contracts-from-reentrancy-attacks-9972c3af7c21  ## Tools Used Manual code review   ## Recommended Mitigation Steps The callback Callback.mint(asset, collateral, xIncrease, dueOut.collateral, data) should be placed at the end of the mint() function after all state updates have taken place.   "}, {"title": "Repeated calls", "html_url": "https://github.com/code-423n4/2022-01-elasticswap-findings/issues/178", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-elasticswap-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact Result of this.totalSupply() could be cached to avoid duplicate calls: ```solidity   require(this.totalSupply() > 0, \"Exchange: INSUFFICIENT_LIQUIDITY\");   ...   uint256 totalSupplyOfLiquidityTokens = this.totalSupply(); ```   "}, {"title": "Unchecked maths", "html_url": "https://github.com/code-423n4/2022-01-elasticswap-findings/issues/177", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-elasticswap-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact Using the unchecked keyword to avoid redundant arithmetic checks and save gas when an underflow/overflow cannot happen, e.g.: ```solidity     if (rootK > rootKLast) {         uint256 numerator =             _totalSupplyOfLiquidityTokens * (rootK - rootKLast); ``` rootK - rootKLast will never underflow here.   "}, {"title": "quoteTokenQtyToReturn = internalBalances.quoteTokenReserveQty", "html_url": "https://github.com/code-423n4/2022-01-elasticswap-findings/issues/176", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-elasticswap-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact Would be cheapier to have >= here when quoteTokenQtyToReturn = internalBalances.quoteTokenReserveQty to skip math operation: ```solidity     // We should ensure no possible overflow here.     if (quoteTokenQtyToReturn > internalBalances.quoteTokenReserveQty) {         internalBalances.quoteTokenReserveQty = 0;     } else {         internalBalances.quoteTokenReserveQty -= quoteTokenQtyToReturn;     } ```   "}, {"title": "Inclusive conditions", "html_url": "https://github.com/code-423n4/2022-01-elasticswap-findings/issues/175", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-elasticswap-findings", "body": "Inclusive conditions"}, {"title": "Redundant code", "html_url": "https://github.com/code-423n4/2022-01-elasticswap-findings/issues/173", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-elasticswap-findings", "body": "Redundant code"}, {"title": "Revert when K >= 2^256", "html_url": "https://github.com/code-423n4/2022-01-elasticswap-findings/issues/172", "labels": ["bug", "1 (Low Risk)", "sponsor disputed"], "target": "2022-01-elasticswap-findings", "body": "Revert when K >= 2^256"}, {"title": "saving gas by not returning the variables that was declared to be returned", "html_url": "https://github.com/code-423n4/2022-01-elasticswap-findings/issues/171", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-elasticswap-findings", "body": "# Handle  OriDabush   # Vulnerability details  ## Mathlib.sol (`calculateAddQuoteTokenLiquidityQuantities()`) In the `calculateAddQuoteTokenLiquidityQuantities()` function, the return line is unnecessary, because those variables are returned anyway (it will save gas if you'll remove the return line.)  ```sol return (quoteTokenQty, liquidityTokenQty); // remove this line to save gas ```  "}, {"title": "inlining a function to save gas", "html_url": "https://github.com/code-423n4/2022-01-elasticswap-findings/issues/169", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-elasticswap-findings", "body": "inlining a function to save gas"}, {"title": "Gas Optimization: float multiplication optimization", "html_url": "https://github.com/code-423n4/2022-01-elasticswap-findings/issues/167", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-elasticswap-findings", "body": "Gas Optimization: float multiplication optimization"}, {"title": "Gas Optimization: Use deterministic contract address", "html_url": "https://github.com/code-423n4/2022-01-elasticswap-findings/issues/163", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-elasticswap-findings", "body": "Gas Optimization: Use deterministic contract address"}, {"title": "Gas Optimization: `> 0` is less efficient than `!= 0` for uint in require condition", "html_url": "https://github.com/code-423n4/2022-01-elasticswap-findings/issues/161", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-elasticswap-findings", "body": "# Handle  gzeon   # Vulnerability details  ## Impact `> 0` is less gas efficient than `!= 0` for uint in require condition when optimizer is enabled Ref: https://twitter.com/GalloDaSballo/status/1485430908165443590  ## Proof of Concept https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/contracts/Exchange.sol#L176 ```         require(this.totalSupply() > 0, \"Exchange: INSUFFICIENT_LIQUIDITY\"); ```   "}, {"title": "swapBaseTokenForQuoteToken and swapQuoteTokenForBaseToken do not check output quantities to be achievable", "html_url": "https://github.com/code-423n4/2022-01-elasticswap-findings/issues/160", "labels": ["bug", "duplicate", "0 (Non-critical)", "sponsor acknowledged"], "target": "2022-01-elasticswap-findings", "body": "swapBaseTokenForQuoteToken and swapQuoteTokenForBaseToken do not check output quantities to be achievable"}, {"title": "Custom Errors", "html_url": "https://github.com/code-423n4/2022-01-elasticswap-findings/issues/159", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-elasticswap-findings", "body": "Custom Errors"}, {"title": "Initialize to default state is redundant", "html_url": "https://github.com/code-423n4/2022-01-elasticswap-findings/issues/158", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-elasticswap-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/contracts/Exchange.sol#L27-L28  ```solidity MathLib.InternalBalances public internalBalances =     MathLib.InternalBalances(0, 0, 0); ```  Initialize `internalBalances` to the default state is redundant.  Change to `MathLib.InternalBalances public internalBalances;` can make the code simpler and save some gas.  "}, {"title": "Remove unused code can save gas", "html_url": "https://github.com/code-423n4/2022-01-elasticswap-findings/issues/157", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-elasticswap-findings", "body": "Remove unused code can save gas"}, {"title": "Cache and read storage variables from the stack can save gas", "html_url": "https://github.com/code-423n4/2022-01-elasticswap-findings/issues/156", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-elasticswap-findings", "body": "Cache and read storage variables from the stack can save gas"}, {"title": " Outdated versions of OpenZeppelin library", "html_url": "https://github.com/code-423n4/2022-01-elasticswap-findings/issues/155", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-elasticswap-findings", "body": "# Handle  WatchPug   # Vulnerability details  Outdated versions of OpenZeppelin library are used.  New versions of OpenZeppelin libraries can be more gas efficient.   For example:  `ERC20.sol` in @openzeppelin/contracts@4.1.0:  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.1.0/contracts/token/ERC20/ERC20.sol#L152-L153  ```solidity require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\"); _approve(sender, _msgSender(), currentAllowance - amount); ```  A gas optimization upgrade has been added to @openzeppelin/contracts@4.4.2:  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.4.2/contracts/token/ERC20/ERC20.sol#L158-L161 ```solidity require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\"); unchecked {     _approve(sender, _msgSender(), currentAllowance - amount); } ```  "}, {"title": "Incorrect implementation of `_quoteTokenQtyMin`, `_baseTokenQtyMin`", "html_url": "https://github.com/code-423n4/2022-01-elasticswap-findings/issues/153", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor disputed"], "target": "2022-01-elasticswap-findings", "body": "Incorrect implementation of `_quoteTokenQtyMin`, `_baseTokenQtyMin`"}, {"title": "Redundant `return` for named returns", "html_url": "https://github.com/code-423n4/2022-01-elasticswap-findings/issues/151", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-elasticswap-findings", "body": "# Handle  WatchPug   # Vulnerability details  Redundant code increase contract size and gas usage at deployment.  https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L227-L233  ```solidity function calculateAddQuoteTokenLiquidityQuantities(     uint256 _quoteTokenQtyDesired,     uint256 _quoteTokenQtyMin,     uint256 _baseTokenReserveQty,     uint256 _totalSupplyOfLiquidityTokens,     InternalBalances storage _internalBalances ) public returns (uint256 quoteTokenQty, uint256 liquidityTokenQty) { ```  https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L282-L282  ```solidity return (quoteTokenQty, liquidityTokenQty); ```  L282, `return (quoteTokenQty, liquidityTokenQty)` is redundant.   "}, {"title": "Simplify `MathLib#sqrt()` can save gas", "html_url": "https://github.com/code-423n4/2022-01-elasticswap-findings/issues/147", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-elasticswap-findings", "body": "# Handle  WatchPug   # Vulnerability details  The check of `y > 3` is unnecessary and most certainly adds more gas cost than it saves as the majority of use cases of this function will not be handling `y <= 3`.  https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L82-L93  ```solidity function sqrt(uint256 y) internal pure returns (uint256 z) {     if (y > 3) {         z = y;         uint256 x = y / 2 + 1;         while (x < z) {             z = x;             x = (y / x + x) / 2;         }     } else if (y != 0) {         z = 1;     } } ```   ### Recommendation  Change to:  ```solidity function sqrt(uint x) public pure returns (uint y) {     uint z = (x + 1) / 2;     y = x;     while (z < y) {         y = z;         z = (x / z + z) / 2;     } } ```  Or use:  https://github.com/Rari-Capital/solmate/blob/dd13c61b5f9cb5c539a7e356ba94a6c2979e9eb9/src/utils/FixedPointMathLib.sol#L150-L205   "}, {"title": "[WP-H2] Transferring `quoteToken` to the exchange pool contract will cause future liquidity providers to lose funds", "html_url": "https://github.com/code-423n4/2022-01-elasticswap-findings/issues/146", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-elasticswap-findings", "body": "# Handle  WatchPug   # Vulnerability details  In the current implementation, the amount of LP tokens to be minted when `addLiquidity()` is calculated based on the ratio between the amount of newly added `quoteToken` and the current wallet balance of `quoteToken` in the `Exchange` contract.  However, since anyone can transfer `quoteToken` to the contract, and make the balance of `quoteToken` to be larger than `_internalBalances.quoteTokenReserveQty`, existing liquidity providers can take advantage of this by donating `quoteToken` and make future liquidity providers receive fewer LP tokens than expected and lose funds.  https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L578-L582  ```solidity liquidityTokenQty = calculateLiquidityTokenQtyForDoubleAssetEntry(     _totalSupplyOfLiquidityTokens,     quoteTokenQty,     _quoteTokenReserveQty // IERC20(quoteToken).balanceOf(address(this)) ); ```  ### PoC  Given:  - The `Exchange` pool is new;  1. Alice `addLiquidity()` with `1e18 baseToken` and `1e18 quoteToken`, recived `1e18` LP token; 2. Alice transfer `99e18 quoteToken` to the `Exchange` pool contract; 3. Bob `addLiquidity()` with `1e18 baseToken` and `1e18 quoteToken`; 3. Bob `removeLiquidity()` with all the LP token in balance.  **Expected Results**: Bob recived `1e18 baseToken` and >= `1e18 quoteToken`.  **Actual Results**: Bob recived ~`0.02e18 baseToken` and ~`1e18 quoteToken`.  Alice can now `removeLiquidity()` and recive ~`1.98e18 baseToken` and ~`100e18 quoteToken`.  As a result, Bob suffers a fund loss of `0.98e18 baseToken`.  ### Recommendation  Change to:  ```solidity liquidityTokenQty = calculateLiquidityTokenQtyForDoubleAssetEntry(     _totalSupplyOfLiquidityTokens,     quoteTokenQty,     _internalBalances.quoteTokenReserveQty ); ```  "}, {"title": "[WP-H1] The value of LP token can be manipulated by the first minister, which allows the attacker to dilute future liquidity providers' shares", "html_url": "https://github.com/code-423n4/2022-01-elasticswap-findings/issues/145", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2022-01-elasticswap-findings", "body": "# Handle  WatchPug   # Vulnerability details  For the first minter of an Exchange pool, the ratio of `X/Y` and the `totalSupply` of the LP token can be manipulated.  A sophisticated attacker can mint and burn all of the LP tokens but `1 Wei`, and then artificially create a situation of rebasing up by transferring baseToken to the pool contract. Then `addLiquidity()` in `singleAssetEntry` mode.  Due to the special design of `singleAssetEntry` mode, the value of LP token can be inflated very quickly.  As a result, `1 Wei` of LP token can be worthing a significate amount of baseToken and quoteToken.  Combine this with the precision loss when calculating the amount of LP tokens to be minted to the new liquidity provider, the attacker can turn the pool into a trap which will take a certain amount of cut for all future liquidity providers by minting fewer LP tokens to them.  https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L493-L512  ```solidity } else {     // this user will set the initial pricing curve     require(         _baseTokenQtyDesired > 0,         \"MathLib: INSUFFICIENT_BASE_QTY_DESIRED\"     );     require(         _quoteTokenQtyDesired > 0,         \"MathLib: INSUFFICIENT_QUOTE_QTY_DESIRED\"     );      tokenQtys.baseTokenQty = _baseTokenQtyDesired;     tokenQtys.quoteTokenQty = _quoteTokenQtyDesired;     tokenQtys.liquidityTokenQty = sqrt(         _baseTokenQtyDesired * _quoteTokenQtyDesired     );      _internalBalances.baseTokenReserveQty += tokenQtys.baseTokenQty;     _internalBalances.quoteTokenReserveQty += tokenQtys.quoteTokenQty; } ```  https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L204-L212  ```solidity function calculateLiquidityTokenQtyForDoubleAssetEntry(     uint256 _totalSupplyOfLiquidityTokens,     uint256 _quoteTokenQty,     uint256 _quoteTokenReserveBalance ) public pure returns (uint256 liquidityTokenQty) {     liquidityTokenQty =         (_quoteTokenQty * _totalSupplyOfLiquidityTokens) /         _quoteTokenReserveBalance; } ```  ### PoC  Given:  - The `Pool` is newly created; - The market price of `baseToken` in terms of `quoteToken` is `1`.  The attacker can do the following steps in one tx:  1. `addLiquidity()` with `2 Wei of baseToken` and `100e18 quoteToken`, received `14142135623` LP tokens; 2. `removeLiquidity()` with `14142135622` LP tokens, the Pool state becomes: - totalSupply of LP tokens: 1 Wei - baseTokenReserveQty: 1 Wei - quoteTokenReserveQty: 7071067813 Wei 3. `baseToken.transfer()` 7071067812 Wei to the Pool contract; 4. `addLiquidity()` with no baseToken and `50e18 quoteToken`; 5. `swapBaseTokenForQuoteToken()` with `600000000000000 baseToken`, the Pool state becomes: - totalSupply of LP tokens: 1 Wei - quoteTokenReserveQty 591021750159032 - baseTokenReserveQty 600007071067801 6. `baseToken.transfer()` 999399992928932200 Wei to the Pool contract; 7. `addLiquidity()` with no baseToken and `1e18 quoteToken`, the Pool state becomes: - totalSupply of LP tokens: 1 Wei - quoteTokenReserveQty: 1000000000000000013 - quoteTokenReserveQty: 985024641638342212 - baseTokenDecay: 0  From now on, `addLiquidity()` with less than `1e18` of `baseToken` and `quoteToken` will receive `0` LP token due to precision loss.  The amounts can be manipulated to higher numbers and cause most future liquidity providers to receive fewer LP tokens than expected, and the attacker will be able to profit from it as the attacker will take a larger share of the pool than expected.  ### Recommendation  Consider requiring a certain amount of minimal LP token amount (eg, 1e8) for the first minter and lock some of the first minter's LP tokens by minting ~1% of the initial amount to the factory address.  "}, {"title": "[WP-H0] In the case of Single Asset Entry, new liquidity providers will suffer fund loss due to wrong formula of \u0394Ro", "html_url": "https://github.com/code-423n4/2022-01-elasticswap-findings/issues/144", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-elasticswap-findings", "body": "# Handle  WatchPug   # Vulnerability details  ### Current Implementation  #### When `baseToken` rebase up  Per the document: https://github.com/ElasticSwap/elasticswap/blob/a90bb67e2817d892b517da6c1ba6fae5303e9867/ElasticSwapMath.md#:~:text=When%20there%20is%20alphaDecay  and related code: https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L227-L283  `Gamma` is the ratio of shares received by the new liquidity provider when `addLiquidity()` (\u0394Ro) to the new totalSupply (total shares = Ro' = Ro + \u0394Ro).  ``` \u0394Ro = (Ro/(1 - \u03b3)) * \u03b3          Ro * Gamma     = --------------          1 - Gamma \u27fa \u0394Ro * ( 1 - Gamma ) = Gamma * Ro \u0394Ro - Gamma * \u0394Ro = Gamma * Ro \u0394Ro = Gamma * Ro + Gamma * \u0394Ro            \u0394Ro     Gamma = ---------          Ro + \u0394Ro  ```  In the current implementation:  ``` \u03b3 = \u0394Y / Y' / 2 * ( \u0394X / \u03b1^ ) ```  \u0394Y is the `quoteToken` added by the new liquidity provider. See: -   https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L277  Y' is the new Y after `addLiquidity()`, `Y' = Y + \u0394Y`. See: -   https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L272 -   https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L278  \u0394X is `\u0394Y * Omega`. See: -   https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L259-L263 -   https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L279  \u03b1^ is `Alpha - X`. See: -   https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L234-L235 -   https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L280   For instance:  Given: -   Original State: X = Alpha = 1, Y = Beta = 1, Omega = X/Y = 1 -   When `baseToken` rebase up: Alpha becomes 10 -   Current State: Alpha = 10, X = 1, Y = Beta = 1, Omega = 1   When: new liquidity provider `addLiquidity()` with 4 quoteToken:  ```              4          4 * Omega      16 Gamma = ------------ * ------------ = ----          (1+4) * 2       10 - 1        90 ``` After `addLiquidity()`:  -   baseToken belongs to the newLP: 10 * 16 / 90 = 160 / 90 = 1.7777777777777777 -   quoteToken belongs to the newLP: (1+4) * 16 / 90 = 80 / 90 = 0.8888888888888888 -   In the terms of `quoteToken`, the total value is: 160 / 90 / Omega + 80 / 90 = 240 / 90 = 2.6666666666666665   As a result, the new liquidity provider suffers a fund loss of `4 - 240 / 90 = 1.3333333333333333 in the terms of quoteToken`  The case above can be reproduced by changing the numbers in [this test unit](https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/test/exchangeTest.js#L1804).   #### When `baseToken` rebase down   Per the document: https://github.com/ElasticSwap/elasticswap/blob/a90bb67e2817d892b517da6c1ba6fae5303e9867/ElasticSwapMath.md#:~:text=When%20there%20is%20betaDecay  and related code: https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L297-L363  `Gamma` is the ratio of shares received by the new liquidity provider when `addLiquidity()` (\u0394Ro) to the new totalSupply (total shares = Ro' = Ro + \u0394Ro).   ``` \u0394Ro = (Ro/(1 - \u03b3)) * \u03b3          Ro * Gamma     = --------------          1 - Gamma \u27fa \u0394Ro * ( 1 - Gamma ) = Gamma * Ro \u0394Ro - Gamma * \u0394Ro = Gamma * Ro \u0394Ro = Gamma * Ro + Gamma * \u0394Ro            \u0394Ro     Gamma = ---------          Ro + \u0394Ro  ```  In the current implementation:  ``` \u03b3 = \u0394X / X / 2 * ( \u0394XByQuoteTokenAmount / \u03b2^ ) ```  \u0394X is the amount of `baseToken` added by the new liquidity provider. See: -   https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L357  X is the balanceOf `baseToken`. See: -   https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L358  \u0394XByQuoteTokenAmount is \u0394X / Omega, the value of \u0394X in the terms of `quoteToken`. See: -   https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L318-L322 -   https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L329-L333 -   https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L359  \u03b2^ is max\u0394X / Omega, the value of max\u0394X in the terms of `quoteToken`. `max\u0394X = X - Alpha`. See: -   https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L304-L305 -   https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L318-L322 -   https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L341-L342 -   https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/libraries/MathLib.sol#L360    For instance:  Given: -   Original State: X = Alpha = 10, Y = Beta = 10, Omega = X/Y = 1 -   When `baseToken` rebase down, Alpha becomes 1 -   Current State: Alpha = 1, X = 10, Y = Beta = 10, Omega = 1   When: new liquidity provider `addLiquidity()` with `4 baseToken` ```             4          4 / Omega       8 Gamma = -------- * ---------------- = ----           10 * 2    (10-1) / Omega     90 ``` After `addLiquidity()`: -   baseToken belongs to the newLP: (1 + 4) * 8 / 90 = 40 / 90 = 0.4444444444444444 -   quoteToken belongs to the newLP: 10 * 8 / 90 = 80 / 90 = 0.8888888888888888 -   In the terms of quoteToken, the total value is: 40 / 90 + 80 / 90 * Omega = 120 / 90 = 1.3333333333333333 < 4  As a result, the new liquidity provider suffers a fund loss of `4 - 120 / 90 = 2.6666666666666665 in the terms of quoteToken`  The case above can be reproduced by changing the numbers in [this test unit](https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/test/exchangeTest.js#L2146).   ### The correct formula for \u0394Ro  #### When baseToken rebase up  ```md When: new liquidity provider addLiquidity with \u0394Y quoteToken (\u0394Y <= max\u0394Y or \u0394Y <= \u03b1^ / \u03c9)  After addLiquidity(): -   baseToken belongs to the newLP: \u0394XOfNewLP -   quoteToken belongs to the newLP: \u0394YOfNewLP  \u0394Y can be divided into 2 parts: -   \u0394YToX: the part used for swap \u0394XOfNewLP.  \u0394XOfNewLP = \u0394YToX * Omega                  (a1) -   \u0394Y - \u0394YToX: the rest as \u0394YOfNewLP  The ratio of newly minted LP tokens for new liquidity provider to the new totalSupply (Ro'): Gamma              \u0394Ro       \u0394Y - \u0394YToX     \u0394XOfNewLP        = --------- = ----------- = -----------                                    (a2)          Ro + \u0394Ro     Y + \u0394Y          Alpha                       \u0394Y - \u0394YToX     \u0394YToX * Omega                      = ----------- = ---------------   // substituting (a1)             (a_exp1)                       Y + \u0394Y          Alpha          \u27fa  (\u0394Y - \u0394YToX) * Alpha = \u0394YToX * Omega * (Y + \u0394Y) \u0394Y * Alpha - \u0394YToX * Alpha = \u0394YToX * Omega * (Y + \u0394Y) \u0394Y * Alpha = \u0394YToX * Alpha + \u0394YToX * Omega * (Y + \u0394Y)            = \u0394YToX * ( Alpha + Omega * (Y + \u0394Y))                \u0394Y * Alpha                  \u0394Y * Alpha             \u0394YToX = ---------------------------  = --------------------                       (a_r1)          Alpha + Omega * (Y + \u0394Y)       Alpha + Omega * Y'      Continue from (a_exp1):            \u0394YToX * Omega  Gamma  = ---------------             Alpha                       \u0394Y * Omega        = -----------------------   // substituting (a_r1)                              (a_r2(1))            Alpha + Omega * Y'                   \u0394Y         = ---------------------                                                   (a_r2(2))             Alpha/Omega + Y'   Gamma is the ratio of \u0394Y to the total amounts of baseToken and quoteToken after addLiquidity: -   (a_r2(1)) is the formula in the terms of baseToken -   (a_r2(2)) is the formula in the terms of quoteToken    Based on (a2):             \u0394Ro     Gamma = ---------          Ro + \u0394Ro  \u27fa \u0394Ro = Gamma * Ro + Gamma * \u0394Ro \u0394Ro - Gamma * \u0394Ro = Gamma * Ro \u0394Ro * ( 1 - Gamma ) = Gamma * Ro         Ro * Gamma \u0394Ro = --------------          1 - Gamma  ```  #### When baseToken rebase down  ```md When: new liquidity provider addLiquidity with \u0394X baseToken (\u0394X <= max\u0394X or \u0394Y <= \u03b1^)  After addLiquidity() -   baseToken belongs to the newLP: \u0394XOfNewLP -   quoteToken belongs to the newLP: \u0394YOfNewLP  \u0394X can be divided into 2 parts: -   \u0394XToY:  the part used for swap \u0394YOfNewLP. \u0394YOfNewLP = \u0394XToY / Omega                 (b1) -   \u0394X - \u0394XToY: the rest as \u0394XOfNewLP   The ratio of newly minted LP tokens for new liquidity provider to the new totalSupply (Ro'): Gamma            \u0394Ro        \u0394X - \u0394XToY     \u0394YOfNewLP          = --------- = ------------ = ------------                                  (b2)         Ro + \u0394Ro     Alpha + \u0394X         Y                                        \u0394XToY / Omega                                = -------------    // substituting (b1)                                       Y                                       \u0394XToY                                     = -------------                                   (b_exp1)                                    Y * Omega     \u27fa  (\u0394X - \u0394XToY) * Y = (Alpha + \u0394X) * \u0394XToY / Omega \u0394X * Y - \u0394XToY * Y = (Alpha + \u0394X) * \u0394XToY / Omega \u0394X * Y = \u0394XToY * Y + (Alpha + \u0394X) * \u0394XToY / Omega        = \u0394XToY * ( Y + (Alpha + \u0394X) / Omega )                    \u0394X * Y \u0394XToY = --------------------------                                               (b_r1)          Y + (Alpha + \u0394X) / Omega    Continue from (b_exp1)              \u0394XToY     Gamma = -------------           Y * Omega                      \u0394X * Y       = ----------------------------------------    // substituting (b_r1)          (Y + (Alpha + \u0394X) / Omega) * Y * Omega                 \u0394X / Omega       = ---------------------------                                               (b_r2(2))          Y + (Alpha + \u0394X) / Omega                     \u0394X       = ---------------------------                                               (b_r2(1))          Y * Omega + (Alpha + \u0394X)                 \u0394X       = -------------------  // substituting (Omega = X/Y)          X + (Alpha + \u0394X)    Gamma is the ratio of \u0394X to the total amounts of baseToken and quoteToken after addLiquidity: -   (b_r2(1)) is the formula in the terms of baseToken -   (b_r2(2)) is the formula in the terms of quoteToken   Based on (b2):             \u0394Ro     Gamma = ---------          Ro + \u0394Ro  \u27fa         Ro * Gamma \u0394Ro = --------------          1 - Gamma  ```  ### Recommendation  Update code and document using the correct formula for \u0394Ro.  "}, {"title": "Making the MathLib internal", "html_url": "https://github.com/code-423n4/2022-01-elasticswap-findings/issues/141", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-elasticswap-findings", "body": "# Handle  UncleGrandpa925   # Vulnerability details  ## Impact Saving gas-cost for all transactions interacting with the pools.   Currently the bytecode size of the Exchange is 10.99KB. Making the entire MathLib internal (therefore embedding it into the Exchange) will only make the bytecode size grows to 14.45KB, which is well below the limit of 24576 bytes. Doing this will save at least 2300 gas for every transaction since that the cost for cold-load the bytecode of the library, and also saving the gas cost of doing delegate call to the library instead of doing internal call.  ## Recommended Mitigation Steps Converting all public properties in the MathLib to internal.  ## Note  Normally I'm not into farming gas-optimization issues, but I think this is worth doing.   "}, {"title": "Leftover tokens will be stuck in the contract with no ways to recover", "html_url": "https://github.com/code-423n4/2022-01-elasticswap-findings/issues/136", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2022-01-elasticswap-findings", "body": "Leftover tokens will be stuck in the contract with no ways to recover"}, {"title": "10 ** 18 can be changed to 1e18 ", "html_url": "https://github.com/code-423n4/2022-01-elasticswap-findings/issues/134", "labels": ["bug", "0 (Non-critical)"], "target": "2022-01-elasticswap-findings", "body": "10 ** 18 can be changed to 1e18 "}, {"title": "Exchange.sol is not Pausable", "html_url": "https://github.com/code-423n4/2022-01-elasticswap-findings/issues/124", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2022-01-elasticswap-findings", "body": "Exchange.sol is not Pausable"}, {"title": "Fee-on-transfer check can be avoided", "html_url": "https://github.com/code-423n4/2022-01-elasticswap-findings/issues/119", "labels": ["bug", "duplicate", "1 (Low Risk)", "disagree with severity"], "target": "2022-01-elasticswap-findings", "body": "Fee-on-transfer check can be avoided"}, {"title": "Comment missing function parameter", "html_url": "https://github.com/code-423n4/2022-01-elasticswap-findings/issues/114", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2022-01-elasticswap-findings", "body": "# Handle  sirhashalot   # Vulnerability details  ## Impact  The Cvx3CrvOracle.sol contract has functions that take the baseAmount input parameter but fail to mention or describe this parameter in the function's natspec comments. Issues with comments are low risk based on [Code4rena risk categories](https://docs.code4rena.com/roles/wardens/judging-criteria#estimating-risk-tl-dr).  ## Proof of Concept  The functions missing the baseAmount input parameter in comments include: - [peek()](https://github.com/code-423n4/2022-01-yield/blob/e946f40239b33812e54fafc700eb2298df1a2579/contracts/Cvx3CrvOracle.sol#L59-L66) - [get()](https://github.com/code-423n4/2022-01-yield/blob/e946f40239b33812e54fafc700eb2298df1a2579/contracts/Cvx3CrvOracle.sol#L81-L88) - [_peek()](https://github.com/code-423n4/2022-01-yield/blob/e946f40239b33812e54fafc700eb2298df1a2579/contracts/Cvx3CrvOracle.sol#L102-L109)  ## Recommended Mitigation Steps  Make sure natspec comments include all function input parameters.  "}, {"title": "Base token properties not verified", "html_url": "https://github.com/code-423n4/2022-01-elasticswap-findings/issues/111", "labels": ["bug", "duplicate", "0 (Non-critical)", "disagree with severity"], "target": "2022-01-elasticswap-findings", "body": "Base token properties not verified"}, {"title": "Users can grief name and symbol for a market, DAO unable to change", "html_url": "https://github.com/code-423n4/2022-01-elasticswap-findings/issues/110", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2022-01-elasticswap-findings", "body": "# Handle  camden   # Vulnerability details  ## Impact https://github.com/ElasticSwap/elasticswap/blob/a90bb67e2817d892b517da6c1ba6fae5303e9867/src/contracts/ExchangeFactory.sol#L38  A user could create an exchange with a name and symbol that is misleading or allows phishing into an exchange created with an unexpected token.  ## Recommended Mitigation Steps Allow the ExchangeFactory to change the name and symbol of an exchange.  "}, {"title": "Math base functions can be made internal", "html_url": "https://github.com/code-423n4/2022-01-elasticswap-findings/issues/107", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2022-01-elasticswap-findings", "body": "Math base functions can be made internal"}, {"title": "Shift Right instead of Dividing by 2", "html_url": "https://github.com/code-423n4/2022-01-elasticswap-findings/issues/100", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-elasticswap-findings", "body": "Shift Right instead of Dividing by 2"}, {"title": "`removeLiquidity.sol#baseTokenQtyToRemoveFromInternalAccounting` should not be cached", "html_url": "https://github.com/code-423n4/2022-01-elasticswap-findings/issues/94", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-elasticswap-findings", "body": "# Handle  0x0x0x   # Vulnerability details  `removeLiquidity.sol#baseTokenQtyToRemoveFromInternalAccounting` is used only once and caching it does cost extra gas. So ```         uint256 baseTokenQtyToRemoveFromInternalAccounting =             (_liquidityTokenQty * internalBalances.baseTokenReserveQty) /                 totalSupplyOfLiquidityTokens;          internalBalances             .baseTokenReserveQty -= baseTokenQtyToRemoveFromInternalAccounting; ``` can be replaced with ```          internalBalances.baseTokenReserveQty -= (_liquidityTokenQty * internalBalances.baseTokenReserveQty) / totalSupplyOfLiquidityTokens; ```  "}, {"title": "Description of `_expirationTimestamp` is not exact", "html_url": "https://github.com/code-423n4/2022-01-elasticswap-findings/issues/93", "labels": ["bug", "1 (Low Risk)", "disagree with severity"], "target": "2022-01-elasticswap-findings", "body": "Description of `_expirationTimestamp` is not exact"}, {"title": "removeLiquidity() _tokenRecipient Lack of Zero Address Check May Cause User Lose Fund Permanently", "html_url": "https://github.com/code-423n4/2022-01-elasticswap-findings/issues/87", "labels": ["bug", "1 (Low Risk)", "disagree with severity"], "target": "2022-01-elasticswap-findings", "body": "removeLiquidity() _tokenRecipient Lack of Zero Address Check May Cause User Lose Fund Permanently"}, {"title": "createNewExchange() Possible to Add Elastic Token as Quote Token Due to No Validation", "html_url": "https://github.com/code-423n4/2022-01-elasticswap-findings/issues/84", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2022-01-elasticswap-findings", "body": "createNewExchange() Possible to Add Elastic Token as Quote Token Due to No Validation"}, {"title": "`ExchangeFactory.sol`'s `transferOwnership` should be a two-step process", "html_url": "https://github.com/code-423n4/2022-01-elasticswap-findings/issues/81", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2022-01-elasticswap-findings", "body": "`ExchangeFactory.sol`'s `transferOwnership` should be a two-step process"}, {"title": "using modifier instead of function can save gas", "html_url": "https://github.com/code-423n4/2022-01-elasticswap-findings/issues/77", "labels": ["bug", "G (Gas Optimization)", "sponsor disputed"], "target": "2022-01-elasticswap-findings", "body": "using modifier instead of function can save gas"}, {"title": "Gas in `MathLib.sol:calculateQuoteTokenQty()`: SLOADs minimization", "html_url": "https://github.com/code-423n4/2022-01-elasticswap-findings/issues/63", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-01-elasticswap-findings", "body": "Gas in `MathLib.sol:calculateQuoteTokenQty()`: SLOADs minimization"}, {"title": "`internalBalance` state variable is read and written multiple times within a single transaction", "html_url": "https://github.com/code-423n4/2022-01-elasticswap-findings/issues/55", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-elasticswap-findings", "body": "# Handle  Ruhum   # Vulnerability details  ## Impact The `internalBalances` state variable is used extensively throughout the `Exchange` contract. Reading and writing to storage is expensive. Instead of working the state variable directly, the functions should work with a  cached memory variable. The final value should then be saved to storage.  ## Proof of Concept There are too many places where this is happening. Most prominently in the `MathLib` library, where the state variable is passed around as a function parameter. Working with a cached version will be way cheaper.   ## Tools Used  ## Recommended Mitigation Steps Replace the storage variable with a cached memory variable. The library has to be refactored to return the modified values so they can be written back to storage.  "}, {"title": "Gas in `MathLib.sol:calculateQtyToReturnAfterFees()`: Avoid expensive calculation by checking if `_tokenASwapQty == 0 || _tokenBReserveQty == 0`", "html_url": "https://github.com/code-423n4/2022-01-elasticswap-findings/issues/48", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-elasticswap-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact Saving the gas cost from the calculation  ## Proof of Concept See the `@audit-info` tags: ``` File: MathLib.sol 141:     function calculateQtyToReturnAfterFees( 142:         uint256 _tokenASwapQty, 143:         uint256 _tokenAReserveQty, 144:         uint256 _tokenBReserveQty, 145:         uint256 _liquidityFeeInBasisPoints 146:     ) public pure returns (uint256 qtyToReturn) { 147:         uint256 tokenASwapQtyLessFee = //@audit-info == 0 if _tokenASwapQty == 0 148:             _tokenASwapQty * (BASIS_POINTS - _liquidityFeeInBasisPoints);  149:         qtyToReturn = 150:             (tokenASwapQtyLessFee * _tokenBReserveQty) / //@audit-info 0 is possible if _tokenBReserveQty == 0 or above is equal to 0 151:             ((_tokenAReserveQty * BASIS_POINTS) + tokenASwapQtyLessFee); 152:     } ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Return 0 if `_tokenASwapQty == 0 || _tokenBReserveQty == 0` or the `&&` equivalent. Here's an example: ``` File: MathLib.sol 141:     function calculateQtyToReturnAfterFees( 142:         uint256 _tokenASwapQty, 143:         uint256 _tokenAReserveQty, 144:         uint256 _tokenBReserveQty, 145:         uint256 _liquidityFeeInBasisPoints 146:     ) public pure returns (uint256 qtyToReturn) { 147:         if(_tokenASwapQty != 0 && _tokenBReserveQty != 0){ 148:             uint256 tokenASwapQtyLessFee = _tokenASwapQty *  149:                 (BASIS_POINTS - _liquidityFeeInBasisPoints);  150:             qtyToReturn = (tokenASwapQtyLessFee * _tokenBReserveQty) /  151:                 ((_tokenAReserveQty * BASIS_POINTS) + tokenASwapQtyLessFee); 152:         } 153:     } ``` (here `qtyToReturn` if set to 0 by default so the value returned would be 0)  "}, {"title": "Gas: Mark `ExchangeFactory.sol:setFeeAddress()` as payable", "html_url": "https://github.com/code-423n4/2022-01-elasticswap-findings/issues/41", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-elasticswap-findings", "body": "Gas: Mark `ExchangeFactory.sol:setFeeAddress()` as payable"}, {"title": "Gas: `MathLib.sol` is importing `Exchange.sol`", "html_url": "https://github.com/code-423n4/2022-01-elasticswap-findings/issues/35", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2022-01-elasticswap-findings", "body": "Gas: `MathLib.sol` is importing `Exchange.sol`"}, {"title": "Gas: Reorder require statements `MathLib.sol:calculateAddLiquidityQuantities()` to save gas on revert", "html_url": "https://github.com/code-423n4/2022-01-elasticswap-findings/issues/34", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-elasticswap-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact  Some of the require statements can be placed earlier to reduce gas usage on revert.  ## Proof of Concept  The following can be reordered to save gas on revert:  ``` File: MathLib.sol 464:                 tokenQtys.baseTokenQty += baseTokenQtyFromDecay; 465:                 tokenQtys.quoteTokenQty += quoteTokenQtyFromDecay; 466:                 tokenQtys.liquidityTokenQty += liquidityTokenQtyFromDecay; 467:  468:                 require( 469:                     tokenQtys.baseTokenQty >= _baseTokenQtyMin, 470:                     \"MathLib: INSUFFICIENT_BASE_QTY\" 471:                 ); 472:  473:                 require( 474:                     tokenQtys.quoteTokenQty >= _quoteTokenQtyMin, 475:                     \"MathLib: INSUFFICIENT_QUOTE_QTY\" 476:                 ); ``` to ``` File: MathLib.sol 464:                 tokenQtys.baseTokenQty += baseTokenQtyFromDecay; 465:                  466:                 require( 467:                     tokenQtys.baseTokenQty >= _baseTokenQtyMin, 468:                     \"MathLib: INSUFFICIENT_BASE_QTY\" 469:                 ); 470:  471:                 tokenQtys.quoteTokenQty += quoteTokenQtyFromDecay; 472:  473:                 require( 474:                     tokenQtys.quoteTokenQty >= _quoteTokenQtyMin, 475:                     \"MathLib: INSUFFICIENT_QUOTE_QTY\" 476:                 ); 477:  478:                 tokenQtys.liquidityTokenQty += liquidityTokenQtyFromDecay; ```  ## Tools Used  VS Code   ## Recommended Mitigation Steps  Relocate the said require statements  "}, {"title": "Gas: Reorder require statements `Exchange.sol:removeLiquidity()` to save gas on revert", "html_url": "https://github.com/code-423n4/2022-01-elasticswap-findings/issues/33", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-01-elasticswap-findings", "body": "Gas: Reorder require statements `Exchange.sol:removeLiquidity()` to save gas on revert"}, {"title": "Gas: Conditional flow optimization in `Exchange.sol:removeLiquidity()`", "html_url": "https://github.com/code-423n4/2022-01-elasticswap-findings/issues/28", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-elasticswap-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact   It's possible to save gas by optimizing conditional flows to avoid some unnecessary opcodes    ## Proof of Concept   In `Exchange.sol:removeLiquidity()`, the code is as follows: ``` File: Exchange.sol 225:         if (quoteTokenQtyToReturn > internalBalances.quoteTokenReserveQty) { 226:             internalBalances.quoteTokenReserveQty = 0; 227:         } else { 228:             internalBalances.quoteTokenReserveQty -= quoteTokenQtyToReturn; 229:         } ```   However, this can be optimized :   - Strict inequalities (`>`) are more expensive than non-strict ones (`>=`). This is due to some supplementary checks (ISZERO, 3 gas)   - In this case here, if `quoteTokenQtyToReturn == internalBalances.quoteTokenReserveQty`: `internalBalances.quoteTokenReserveQty = 0` should be used   - Avoiding the else clause would avoid some opcodes (1 SUB = 3 gas, 2 MLOADs = 6 gas...)      The code would become:   ``` File: Exchange.sol 225:         if (quoteTokenQtyToReturn >= internalBalances.quoteTokenReserveQty) { 226:             internalBalances.quoteTokenReserveQty = 0; 227:         } else { 228:             internalBalances.quoteTokenReserveQty -= quoteTokenQtyToReturn; 229:         } ```      ## Tools Used   VS Code      ## Recommended Mitigation Steps   Use the non-strict greater-than operator in this particular case   "}, {"title": "Gas: `ExchangeFactory.feeAddress()` should be declared external", "html_url": "https://github.com/code-423n4/2022-01-elasticswap-findings/issues/26", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2022-01-elasticswap-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact Public functions that are never called by the contract should be declared external to save gas.  ## Proof of Concept Instances include: ``` File: ExchangeFactory.sol 81:     function feeAddress() public view virtual override returns (address) { 82:         return feeAddress_; 83:     } ```  ## Tools Used Slither  ## Recommended Mitigation Steps Change the visibility to `external`  "}, {"title": "Use of Similar variable names", "html_url": "https://github.com/code-423n4/2022-01-elasticswap-findings/issues/20", "labels": ["bug", "0 (Non-critical)", "disagree with severity"], "target": "2022-01-elasticswap-findings", "body": "Use of Similar variable names"}, {"title": "Event for merge", "html_url": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/197", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2022-01-xdefi-findings", "body": "# Handle  0xsanson   # Vulnerability details  Not an issue.  I noticed that the `merge` function doesn't have an event associated with it. Depending on the kind of offchain analysis/tools you will end up using, an event here may turn up useful to know which NFTs got merged together into a new one.  ## Recommended Mitigation Steps Add an event which contains `uint256[] memory tokenIds_` and `tokenId_`.  "}, {"title": "Improper event declaration", "html_url": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/196", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2022-01-xdefi-findings", "body": "# Handle  Czar102   # Vulnerability details  ## Impact  Proper event declaration eases off-chain monitoring.  ## Proof of Concept  In the case of qualitative variables, it is recommended to use `indexed` keyword.  Despite the `uint duration` argument seems to be a quantitative one, it is limited to few values, which specify the \"locking mode\".  ## Recommended Mitigation Steps  `uint duration` variable should be considered qualitative and be marked `indexed` in the following events: ``` event LockPeriodSet(uint256 duration, uint8 bonusMultiplier); event LockPositionCreated(uint256 indexed tokenId, address indexed owner, uint256 amount, uint256 duration); ```   "}, {"title": "\"Safe\" ERC20 functions for XDEFI?", "html_url": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/194", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-xdefi-findings", "body": "# Handle  0xsanson   # Vulnerability details  ## Impact Throughout the code the safe functions `safeTransfer` and `safeTransferFrom` are used when dealing with XDEFI. Isn't this token a standard ERC20? I believe the normal ERC20 transfer functions can be used. The advantage is gaining some 100s gas otherwise spent in unneeded logic.  ## Proof of Concept grep safeT *.sol  ## Recommended Mitigation Steps Consider removing the SafeERC20 library.  "}, {"title": "Possible profitability manipulations", "html_url": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/193", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2022-01-xdefi-findings", "body": "# Handle  Czar102   # Vulnerability details  ## Impact  An owner of the contract may, by ordering their or others' locking transactions, significantly increase or decrease `bonusMultiplier` for some set of transactions.  So, by mining a single block, an owner can lower other's bonus multipliers, execute locking transactions and then restore bonus multipliers.  A user might send a locking transaction in a similar time as an owner lowers the multipliers, resulting in lowering the revenue against data presented to the user.  An owner can also pass ownership to a contract that will change bonus multipliers and lock funds with a very high bonus multiplier, then restore previous multipliers' state not to let others do the same. This way, the owner can gain an unfair advantage over others.  ## Recommended Mitigation Steps  Use a timelock for `setLockPeriods(...)` function and require passing `bonusMultiplier` in locking functions, revert if they are different from the state variables.   "}, {"title": "Adding unchecked directive can save gas", "html_url": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/185", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-xdefi-findings", "body": "Adding unchecked directive can save gas"}, {"title": "No option to unlock funds before set duration", "html_url": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/183", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-xdefi-findings", "body": "# Handle  sirhashalot   # Vulnerability details  ## Impact  If a user locks funds in the contract, they can only withdraw funds by calling functions that in turn call the `_unlock()` function. The `_unlock()` function requires the position to have block.timestamp >= position.expiry. If there is a problem with the contract, with the XDEFI ERC20 token, or a user changes their mind and wants their funds back, they do not have this option. This can be more problematic with very long lock duration values.  ## Proof of Concept  There is a hard requirement that block.timestamp >= uint256(expiry) for any position before it can be unlocked and the funds released. All code paths that allow a use to withdraw their XDEFI rely on the `_unlock()` function:  https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L305  ## Recommended Mitigation Steps  Different options exist to assist users with this issue. One would be to keep lock duration values small, especially when the contract is first released to users. Another is to add an emergency withdrawal function that has the onlyOwner modifier, such as using OpenZeppelin's Pausable module: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/Pausable.sol   "}, {"title": "Unnecessary require statement", "html_url": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/179", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-xdefi-findings", "body": "# Handle  sirhashalot   # Vulnerability details  ## Impact  There is a require statement that contains the comment \"Throw convenient error if trying to re-lock more than was unlocked. `amountUnlocked_ - lockAmount_` would have reverted below anyway.\" This comment is correct that the require statement is unnecessary and removing saves on gas during relock functions.  ## Proof of Concept  The unnecessary require statement is in the `relock()` and `relockBatch()` functions of XDEFIDistribution.sol: https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L115 https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L170  ## Recommended Mitigation Steps  Remove the unnecessary require statement to save gas  "}, {"title": "Wrong revert message", "html_url": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/171", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2022-01-xdefi-findings", "body": "# Handle  Czar102   # Vulnerability details  ## Impact  Wrong revert messages might lead to confusion.  ## Proof of Concept  In line 52 of XDEFIDistribution, the reason for a fail of a reentrant call is `\"LOCKED\"`. In DeFi, it usually means that contract's functionality is temporarily limited. This is not true in this case.  ## Recommended Mitigation Steps  Consider changing the revert string to `\"REENTRY_NOT_ALLOWED\"`.  "}, {"title": "Malicious early user/attacker can malfunction the contract and even freeze users' funds in edge cases", "html_url": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/156", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-xdefi-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L151-L151  ```solidity     _pointsPerUnit += ((newXDEFI * _pointsMultiplier) / totalUnitsCached); ```  In the current implementation,  `_pointsPerUnit` can be changed in `updateDistribution()` which can be called by anyone.   A malicious early user can `lock()` with only `1 wei` of XDEFI and makes `_pointsPerUnit` to be very large, causing future users not to be able to `lock()` and/or `unlock()` anymore due to overflow in arithmetic related to `_pointsMultiplier`.  As a result, the contract can be malfunctioning and even freeze users' funds in edge cases.  ### PoC  Given:  - bonusMultiplierOf[30 days] = 100  1. Alice `lock()` `1 wei` of XDEFI for 30 days as the first user of the contract. Got `1` units, and `totalUnits` now is `1`; 2. Alice sends `170141183460469 wei` of `XDEFI` to the contract and calls `updateDistribution()`:  ```solidity     _pointsPerUnit += ((170141183460469 * 2**128) / 1); ```  3. Bob tries to `lock()` `1,100,000 * 1e18` of `XDEFI` for 30 days, the tx will fail, as `_pointsPerUnit * units` overlows; 4. Bob `lock()` `1,000,000 * 1e18` of `XDEFI` for 30 days; 5. The rewarder sends `250,000 * 1e18` of `XDEFI` to the contract and calls `updateDistribution()`:   ```solidity     _pointsPerUnit += ((250_000 * 1e18 * 2**128) / (1_000_000 * 1e18 + 1)); ```  6. 30 days later, Bob tries to call `unlock()`, the tx will fail, as `_pointsPerUnit * units` overflows.    ### Recomandation  Uniswap v2 solved a similar problem by sending the first 1000 lp tokens to the zero address.  The same solution should work here, i.e., on constructor set an initial amount (like 1e8) for `totalUnits`    https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L39-L44  ```solidity constructor (address XDEFI_, string memory baseURI_, uint256 zeroDurationPointBase_) ERC721(\"Locked XDEFI\", \"lXDEFI\") {         require((XDEFI = XDEFI_) != address(0), \"INVALID_TOKEN\");         owner = msg.sender;         baseURI = baseURI_;         _zeroDurationPointBase = zeroDurationPointBase_;          totalUnits = 100_000_000;     } ```  "}, {"title": "`XDEFIDistribution.sol#_updateXDEFIBalance()` Avoiding unnecessary storage writes can save gas", "html_url": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/151", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-xdefi-findings", "body": "# Handle  WatchPug   # Vulnerability details  Storage writes (`SSTORE`) to `distributableXDEFI` may not be needed when `previousDistributableXDEFI == currentDistributableXDEFI`, therefore the code can be reorganized to save gas from unnecessary storage writes.  https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L330-L336  ```solidity function _updateXDEFIBalance() internal returns (int256 newFundsTokenBalance_) {     uint256 previousDistributableXDEFI = distributableXDEFI;     uint256 currentDistributableXDEFI = distributableXDEFI = IERC20(XDEFI).balanceOf(address(this)) - totalDepositedXDEFI;      return _toInt256Safe(currentDistributableXDEFI) - _toInt256Safe(previousDistributableXDEFI); } ```  ### Recommendation  Change to:  ```solidity function _updateXDEFIBalance() internal returns (int256 newFundsTokenBalance_) {     uint256 previousDistributableXDEFI = distributableXDEFI;     uint256 currentDistributableXDEFI = IERC20(XDEFI).balanceOf(address(this)) - totalDepositedXDEFI;      newFundsTokenBalance_ = _toInt256Safe(currentDistributableXDEFI) - _toInt256Safe(previousDistributableXDEFI);     if (newFundsTokenBalance_ != 0) {         distributableXDEFI = currentDistributableXDEFI;     } } ```  "}, {"title": "Unsafe type casting", "html_url": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/142", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "sponsor acknowledged"], "target": "2022-01-xdefi-findings", "body": "Unsafe type casting"}, {"title": "`_zeroDurationPointBase` can potentially be exploited to get more scores", "html_url": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/139", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-xdefi-findings", "body": "# Handle  WatchPug   # Vulnerability details  `_zeroDurationPointBase` can be set at deploy time so that locks with 0 duration can get scores.  However, if the value of `_zeroDurationPointBase` is being set high enough. It can potentially be exploited by repeatedly lock(), and unlock() with 0 duration to get scores.  This can get amplified with flashloans.  https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L245-L247  ```solidity function _getPoints(uint256 amount_, uint256 duration_) internal view returns (uint256 points_) {     return amount_ * (duration_ + _zeroDurationPointBase); } ```  ## Recommendation  Consider changing `_zeroDurationPointBase` to a constant of value `1`.  "}, {"title": "Avoid inline code for better readibility", "html_url": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/136", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2022-01-xdefi-findings", "body": "Avoid inline code for better readibility"}, {"title": "Implicit casts should be explicit as per the global code style", "html_url": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/129", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2022-01-xdefi-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact Code clarity / code style  ## Proof of Concept At the following places, the casts are implicit, whereas the project's style hints at explicit casts everywhere : https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-beta.0/contracts/XDEFIDistribution.sol#L255 https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-beta.0/contracts/XDEFIDistribution.sol#L269 https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-beta.0/contracts/XDEFIDistribution.sol#L314  ## Tools Used VS Code  ## Recommended Mitigation Steps Use explicit casts everywhere for unsigned integers, as it's the practice everywhere else  "}, {"title": "&& operator can use more gas", "html_url": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/128", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-xdefi-findings", "body": "# Handle  rfa   # Vulnerability details  ## Impact more expensive gas usage  ## Proof of Concept instead of using operator && on single require check (XDEFIDistribution.sol line 255). using double require check can save more gas:   require(amount_ != uint256(0) && amount_ <= MAX_TOTAL_XDEFI_SUPPLY, \"INVALID_AMOUNT\");  ## Tools Used  ## Recommended Mitigation Steps require(amount_ != uint256(0), \"INVALID_AMOUNT\" ); require(amount_ <= MAX_TOTAL_XDEFI_SUPPLY, \"INVALID_AMOUNT\");  "}, {"title": "`XDEFIDistribution.sol#relock()` Implementation can be simpler and save some gas", "html_url": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/123", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-xdefi-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L120-L125  ```solidity=120 uint256 withdrawAmount = amountUnlocked_ - lockAmount_;  if (withdrawAmount != uint256(0)) {     // Send the excess XDEFI to the destination, if needed.     SafeERC20.safeTransfer(IERC20(XDEFI), destination_, withdrawAmount); } ```  https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L175-L180  ```solidity=175 uint256 withdrawAmount = amountUnlocked_ - lockAmount_;  if (withdrawAmount != uint256(0)) {     // Send the excess XDEFI to the destination, if needed.     SafeERC20.safeTransfer(IERC20(XDEFI), destination_, withdrawAmount); } ``` ### Recommendation  Change to:  ```solidity if (amountUnlocked_ > lockAmount_) {     SafeERC20.safeTransfer(IERC20(XDEFI), destination_, amountUnlocked_ - lockAmount_); } ```  - Removed a local variable: `withdrawAmount`; - Only do the arithmetic when needed: `amountUnlocked_ - lockAmount_`.  "}, {"title": "Gas optimization in XDEFIDistribution.sol - shifting instead of multiplying or dividing by power of 2", "html_url": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/122", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-xdefi-findings", "body": "# Handle  OriDabush   # Vulnerability details  ## XDEFIDistribution.sol lines 151, 338-344 Instead of multiplying by _pointsMultiplier, which is 2 ** 128, it is more efficient to shift by 128 (x * (2 ** 128) = x << 128), same for dividing (x / (2 ** 128) = x >> 128) ```sol // line 151 - old _pointsPerUnit += ((newXDEFI * _pointsMultiplier) / totalUnitsCached);  // line 151 - new _pointsPerUnit += ((newXDEFI << 128) / totalUnitsCached);   // lines 338-344 - old return (     _toUint256Safe(         _toInt256Safe(_pointsPerUnit * uint256(units_)) +         pointsCorrection_     ) / _pointsMultiplier ) + uint256(depositedXDEFI_);  // lines 338-344 - new return (     _toUint256Safe(         _toInt256Safe(_pointsPerUnit * uint256(units_)) +         pointsCorrection_     ) >> 128 ) + uint256(depositedXDEFI_); ```  "}, {"title": "Gas optimization in XDEFIDistribution.sol - inlining some functions", "html_url": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/121", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-xdefi-findings", "body": "Gas optimization in XDEFIDistribution.sol - inlining some functions"}, {"title": "Gas optimization in XDEFIDistribution.sol - variable that is not used", "html_url": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/120", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-xdefi-findings", "body": "# Handle  OriDabush   # Vulnerability details  ## XDEFIDistribution.sol line 332  The \"currentDistributableXDEFI\" variable is not used (can use distributableXDEFI instead). ```sol // function before: function _updateXDEFIBalance() internal returns (int256 newFundsTokenBalance_) {     uint256 previousDistributableXDEFI = distributableXDEFI;     uint256 currentDistributableXDEFI = distributableXDEFI = IERC20(XDEFI).balanceOf(address(this)) - totalDepositedXDEFI;     return _toInt256Safe(currentDistributableXDEFI) - _toInt256Safe(previousDistributableXDEFI); }  // function after: function _updateXDEFIBalance() internal returns (int256 newFundsTokenBalance_) {     uint256 previousDistributableXDEFI = distributableXDEFI;     distributableXDEFI = IERC20(XDEFI).balanceOf(address(this)) - totalDepositedXDEFI;     return _toInt256Safe(distributableXDEFI) - _toInt256Safe(previousDistributableXDEFI); } ```  "}, {"title": "Sub-optimal calls should be allowed instead of reverted as resending the transaction will cost more gas", "html_url": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/116", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-xdefi-findings", "body": "# Handle  WatchPug   # Vulnerability details  In the current implementation, when `_unlockBatch()` is called with `tokenIds_.length == 1`, the transaction will be reverted with an error `USE_UNLOCK`.  Even though it's sub-optimal to use `relockBatch()` and `unlockBatch()` for only 1 tokenId, reverting and requiring the user to resend the transaction to another method still costs more gas than allowing it.  Therefore, we sugguest not to revert in `_unlockBatch()` when `tokenIds_.length == 1`.  https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L320-L328  ```solidity=320     function _unlockBatch(address account_, uint256[] memory tokenIds_) internal returns (uint256 amountUnlocked_) {         uint256 count = tokenIds_.length;         require(count > uint256(1), \"USE_UNLOCK\");          // Handle the unlock for each position and accumulate the unlocked amount.         for (uint256 i; i < count; ++i) {             amountUnlocked_ += _unlock(account_, tokenIds_[i]);         }     } ```  ### Recommendation  Change to:  ```solidity     function _unlockBatch(address account_, uint256[] memory tokenIds_) internal returns (uint256 amountUnlocked_) {         uint256 count = tokenIds_.length;         require(count > 0, \"NO_TOKEN_IDS\");          // Handle the unlock for each position and accumulate the unlocked amount.         for (uint256 i; i < count; ++i) {             amountUnlocked_ += _unlock(account_, tokenIds_[i]);         }     } ```  "}, {"title": "Constants are not explicitly declared", "html_url": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/115", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2022-01-xdefi-findings", "body": "Constants are not explicitly declared"}, {"title": "gas optimization", "html_url": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/103", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-xdefi-findings", "body": "# Handle  Fitraldys   # Vulnerability details  ## Impact expensive gas, because in the line https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-beta.0/contracts/XDEFIDistributionHelper.sol#L23,  the tokenids.length is save to a new variable to be used in the for loop, instead of call tokenids.length directly in the for loop  ## Proof of Concept ``` pragma solidity =0.8.7;  contract pikir {      function putar1 (uint256 [] memory tokenIds) external view returns(uint256) {                  uint256 alltokens = tokenIds.length;         uint256 hasil;          for (uint256 i; i < alltokens; ++i){                          hasil += 1;          }         return hasil;      }  } //24714 gas  contract pikir2 {      function putar1 (uint256 [] memory tokenIds) external view returns(uint256) {              uint256 hasil;          for (uint256 i; i < tokenIds.length; ++i){                          hasil += 1;          }         return hasil;      }  } //24710 gas ```  ## Tools Used remix   "}, {"title": "Field bonusMultiplier of struct Position can be removed", "html_url": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/101", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-xdefi-findings", "body": "# Handle  wuwe1   # Vulnerability details  ## Proof of Concept  In contract `XDEFIDistribution`, the only use of `bonusMultiplier` is to calculate `units` in `_lock`.  In contract `XDEFIDistributionHelper`, `bonusMultiplier` is used for return value. However, `bonusMultiplier` can be calculated by `units * 100 / depositedXDEFI`.  "}, {"title": "XDEFIDistribution: _unlock function should only be called with tokenId_ parameter", "html_url": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/98", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-xdefi-findings", "body": "XDEFIDistribution: _unlock function should only be called with tokenId_ parameter"}, {"title": "Less than 256 uints are not gas efficient", "html_url": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/97", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-xdefi-findings", "body": "Less than 256 uints are not gas efficient"}, {"title": "in function setLockPeriods, multiplier can be set to lower than 100", "html_url": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/96", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-xdefi-findings", "body": "# Handle  Tomio   # Vulnerability details  ## Impact in function setLockPeriods multiplier can be set to lower than 100 which will break the calculation when dividing the multiplier in function _lock https://github.com/XDeFi-tech/xdefi-distribution/blob/master/contracts/XDEFIDistribution.sol#L268. If the amount times bonus multiplier below 100 the units value will be 0, therefore the totalUnits won't be added but the positionOf[tokenId_] bill be added.  ## Proof of Concept https://github.com/XDeFi-tech/xdefi-distribution/blob/master/contracts/XDEFIDistribution.sol#L77 https://github.com/XDeFi-tech/xdefi-distribution/blob/master/contracts/XDEFIDistribution.sol#L268  ## Tools Used  ## Recommended Mitigation Steps in function setLockPeriods need to be add  ```function setLockPeriods(uint256[] memory durations_, uint8[] memory multipliers) external onlyOwner {            uint256 count = durations_.length;          for (uint256 i; i < count; ++i) {             require(multipliers >= 100); //added             uint256 duration = durations_[i];             require(duration <= uint256(18250 days), \"INVALID_DURATION\");             emit LockPeriodSet(duration, bonusMultiplierOf[duration] = multipliers[i]);         }     } ```  "}, {"title": "`> 0 can be replaced with != 0 for gas optimization`", "html_url": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/88", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-xdefi-findings", "body": "`> 0 can be replaced with != 0 for gas optimization`"}, {"title": "`pointCorrection` can be stored in a uint256 rather than int256 to save gas from casting.", "html_url": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/87", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-xdefi-findings", "body": "# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact  Extra gas costs from unnecessary casting.  ## Proof of Concept  `pointsCorrection` is stored as a int256 variable.  https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/interfaces/IXDEFIDistribution.sol#L15  However we can see that this variable is always negative (`_pointsPerUnit` and  `units` are both positive)  https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L277  The only usage of `pointsCorrection` is in the `_withdrawableGiven` function as shown below.  https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L341-L342  ``` (   _toUint256Safe(       _toInt256Safe(_pointsPerUnit * uint256(units_)) +       pointsCorrection_   ) / _pointsMultiplier ) + uint256(depositedXDEFI_); ```  `pointsCorrection` is set to `_pointsPerUnit * uint256(units_)` when locking and `_pointsPerUnit` only increases so we can safely store `pointsCorrection as a positive uint256 (note this is an assumption of the original code as well) and simplify the above expression.  ``` // notice the sign change before `pointsCorrection_` (_pointsPerUnit * uint256(units_) - pointsCorrection_) / _pointsMultiplier + uint256(depositedXDEFI_); ```  We can then remove a significant amount of casting along with the associated costs.  ## Recommended Mitigation Steps  store `pointsCorrection` in a uint256 and subtract rather than add.  "}, {"title": "Various Non-Conformance to Solidity naming conventions", "html_url": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/60", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2022-01-xdefi-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact Solidity defines a naming convention that should be followed.  ## Proof of Concept ``` Variable XDEFIDistribution.MAX_TOTAL_XDEFI_SUPPLY (contracts/XDEFIDistribution.sol#14) is not in mixedCase Constant XDEFIDistribution._pointsMultiplier (contracts/XDEFIDistribution.sol#17) is not in UPPER_CASE_WITH_UNDERSCORES Variable XDEFIDistribution._pointsPerUnit (contracts/XDEFIDistribution.sol#18) is not in mixedCase Variable XDEFIDistribution.XDEFI (contracts/XDEFIDistribution.sol#20) is not in mixedCase Variable XDEFIDistribution._zeroDurationPointBase (contracts/XDEFIDistribution.sol#30) is not in mixedCase Variable XDEFIDistribution._locked (contracts/XDEFIDistribution.sol#37) is not in mixedCase Function IXDEFIDistribution.XDEFI() (contracts/interfaces/IXDEFIDistribution.sol#37) is not in mixedCase ```  ## Tools Used Slither  ## Recommended Mitigation Steps Follow the Solidity naming convention: https://docs.soliditylang.org/en/v0.4.25/style-guide.html#naming-conventions  "}, {"title": "Gas Optimization: Tight variable packing in `XDEFIDistribution.sol`", "html_url": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/54", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-xdefi-findings", "body": "Gas Optimization: Tight variable packing in `XDEFIDistribution.sol`"}, {"title": "Owner can steal XDEFI without any capital risk", "html_url": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/52", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2022-01-xdefi-findings", "body": "# Handle  onewayfunction   # Vulnerability details  ## Impact The owner of the `XDEFIDistribution` contract can use flash loans to atomically steal XDEFI from the contract without taking on any capital risk.  ## Proof of Concept In my previous submission, \"Anyone can steal XDEFI from the `XDEFIDistribution` contract and make the contract insolvent\", I showed how any user can use the `onERC721Received` hook of the `_safeMint` function to steal XDEFI tokens from the contract and generally bork the contract's accounting. The attacker in that case took on some risk proportional to the minimum allowable `duration` and was limited in the amount they could steal based on their own capital available (how much XDEFI they had to use during the malicious lockup).  However, when a similar attack is performed by the `owner` of the `XDEFIDistribution` contract, it can be done (1) without the owner taking on any risk at all and (2) the owner can use flashloans to dramatically increase the amount of XDEFI they can steal.  In particular, the owner can perform all of the following in a single transaction (or in a single flashbots bundle):  First, the owner can call the [`setLockPeriods` function](https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-beta.0/contracts/XDEFIDistribution.sol#L77) to allow `0` duration locks with a large `multiplier`.  Next, they can flash borrow as much XDEFI as possible from DEXs and loaning platforms. Call this amount of XDEFI `X`.  Then they do a (normal) `0` duration lock with `X/2` XDEFI. This could give them a large proportion of locked XDEFI.  Next, they do the \"malicious lock\" technique that I previously reported, using the remaining `X/2` XDEFI. This means that their first lock with be able to withdraw more than `X/2` XDEFI when they unlock.  Then, in the same transaction -- which is possible because they are using a `0` duration lock -- they can unlock both thier first \"normal\" lock, as well as their \"malicious\" lock, giving them more than `X` XDEFI in total.  They can repay the flash loan, and keep the difference.  Since the never have to hold a lock for any positive duration, and never even have to have any exposure to XDEFI, the attack is risk free for them. And since they can use flash loans, they'll likely have access to dramatically more capital than a non-owner (who can't use flash loans) could.   ## Recommended Mitigation Steps  In addition to the \"use `_mint()` instead of `_safeMint()`\" suggestion from the previous submission, I also recommend adding a `require(duration > 0, \"INVALID_DURATION\");` statement just above [L82](https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-beta.0/contracts/XDEFIDistribution.sol#L82).  Not only will disallowing `0` duration locks prevent most flashloan shenanigans by the owner, it would also help prevent sandwich attacks that steal incoming distributableX DEFI tokens by sandwiching such incoming txs with a `lock` and `unlock` transaction.  "}, {"title": "Gas: avoid unnecessary SSTORE on `proposeOwnership`", "html_url": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/51", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-xdefi-findings", "body": "Gas: avoid unnecessary SSTORE on `proposeOwnership`"}, {"title": "Gas: `XDEFIDistribution.sol`'s `withdrawAmount` substraction can be unchecked", "html_url": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/49", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-xdefi-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact   Waste of gas due to unnecessary underflow checks  ## Proof of Concept   On `XDEFIDistribution.sol:120` and `XDEFIDistribution.sol:175`, you can find the following substraction: `uint256 withdrawAmount = amountUnlocked_ - lockAmount_;`  However, as the Solidity version is 0.8.10, default overflow and underflow checks are made, which cost some gas.  You can save this gas with the `unchecked` keyword to bypass these checks as 5 lines above (L115 and L170), a `require` statement already checks that `lockAmount_ <= amountUnlocked_`.   Therefore, no underflow is possible.  ## Tools Used   VS Code      ## Recommended Mitigation Steps   Use the \"unchecked\" keyword   "}, {"title": "XDEFIDistribution: lock should be reused in lockWithPermit", "html_url": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/47", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-xdefi-findings", "body": "# Handle  PierrickGT   # Vulnerability details  ## Impact In [lockWithPermit](https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L99), we use the same code to transfer XDEFI and lock the position than in [lock](https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-beta.0/contracts/XDEFIDistribution.sol#L92-96). We can create an internal function to reuse this code and avoid duplication.  ## Proof of Concept Create an internal function called `_lockPosition` that will transfer XDEFI and lock the position. This function will be called in `lock` and `lockWithPermit`.  ## Recommended Mitigation Steps The following change is recommended.  ``` function _lockPosition(uint256 amount_, uint256 duration_, address destination_) internal returns (uint256 tokenId_) {     // Lock the XDEFI in the contract.     SafeERC20.safeTransferFrom(IERC20(XDEFI), msg.sender, address(this), amount_);      // Handle the lock position creation and get the tokenId of the locked position.     return _lock(amount_, duration_, destination_); }  function lock(uint256 amount_, uint256 duration_, address destination_) external noReenter returns (uint256 tokenId_) {     return _lockPosition(amount_, duration_, destination_); }  function lockWithPermit(uint256 amount_, uint256 duration_, address destination_, uint256 deadline_, uint8 v_, bytes32 r_, bytes32 s_) external noReenter returns (uint256 tokenId_) {     // Approve this contract for the amount, using the provided signature.     IEIP2612(XDEFI).permit(msg.sender, address(this), amount_, deadline_, v_, r_, s_);      return _lockPosition(amount_, duration_, destination_); } ```  "}, {"title": "setLockPeriods function lack of input validation", "html_url": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/38", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2022-01-xdefi-findings", "body": "# Handle  cccz   # Vulnerability details  ## Impact  In the setLockPeriods function, there is no verification of the multipliers parameter, multipliers[i] may be 0, and the length of multipliers may not be equal to the length of durations_.  ```     function setLockPeriods(uint256[] memory durations_, uint8[] memory multipliers) external onlyOwner {         uint256 count = durations_.length;          for (uint256 i; i < count; ++i) {             uint256 duration = durations_[i];             require(duration <= uint256(18250 days), \"INVALID_DURATION\");             emit LockPeriodSet(duration, bonusMultiplierOf[duration] = multipliers[i]);         }     } ```  ## Proof of Concept  https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-beta.0/contracts/XDEFIDistribution.sol#L77-L85  ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  ```     function setLockPeriods(uint256[] memory durations_, uint8[] memory multipliers) external onlyOwner { +      require(durations_.length == multipliers.length);         uint256 count = durations_.length;          for (uint256 i; i < count; ++i) {             uint256 duration = durations_[i]; +         require(multipliers[i] != 0);             require(duration <= uint256(18250 days), \"INVALID_DURATION\");             emit LockPeriodSet(duration, bonusMultiplierOf[duration] = multipliers[i]);         }     } ```    "}, {"title": "MAX_TOTAL_XDEFI_SUPPLY should be constant", "html_url": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/36", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-xdefi-findings", "body": "# Handle  agusduha   # Vulnerability details  ## Impact  MAX_TOTAL_XDEFI_SUPPLY has always the same value and is used only in one place, it should be constant to optimize gas  ## Proof of Concept  Variable declaration: https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L14  Variable utilization: https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L255  ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  Add the \"constant\" keyword to the storage variable declaration  "}, {"title": "Distribution Updates Can Be Gamed", "html_url": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/30", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2022-01-xdefi-findings", "body": "Distribution Updates Can Be Gamed"}, {"title": "Use `calldata` instead of `memory` for external functions where the function argument is read-only.", "html_url": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/29", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-xdefi-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact   On external functions, when using the `memory` keyword with a function argument, what's happening is that a `memory` acts as an intermediate.      Reading directly from `calldata` using `calldataload` instead of going via `memory` saves the gas from the intermediate memory operations that carry the values.      As an extract from [https://ethereum.stackexchange.com/questions/74442/when-should-i-use-calldata-and-when-should-i-use-memory](https://ethereum.stackexchange.com/questions/74442/when-should-i-use-calldata-and-when-should-i-use-memory) :   > `memory` and `calldata` (as well as `storage`) are keywords that define the data area where a variable is stored. To answer your question directly, `memory` should be used when declaring variables (both function parameters as well as inside the logic of a function) that you want stored in memory (temporary), and `calldata` _must_ be used when declaring an **external** function's **dynamic** parameters. The easiest way to think about the difference is that `calldata` is a non-modifiable, non-persistent area where function arguments are stored, and behaves mostly like memory.      ## Proof of Concept   ```   interfaces\\IXDEFIDistribution.sol:55:    function baseURI() external view returns (string memory baseURI_); interfaces\\IXDEFIDistribution.sol:74:    function setBaseURI(string memory baseURI_) external; interfaces\\IXDEFIDistribution.sol:77:    function setLockPeriods(uint256[] memory durations_, uint8[] memory multipliers) external; interfaces\\IXDEFIDistribution.sol:106:    function relockBatch(uint256[] memory tokenIds_, uint256 lockAmount_, uint256 duration_, address destination_) external returns (uint256 amountUnlocked_, uint256  newTokenId_); interfaces\\IXDEFIDistribution.sol:109:    function unlockBatch(uint256[] memory tokenIds_, address destination_) external returns (uint256 amountUnlocked_); interfaces\\IXDEFIDistribution.sol:119:    function merge(uint256[] memory tokenIds_, address destination_) external returns (uint256 tokenId_); interfaces\\IXDEFIDistribution.sol:125:    function tokenURI(uint256 tokenId_) external view returns (string memory tokenURI_); XDEFIDistribution.sol:73:    function setBaseURI(string memory baseURI_) external onlyOwner { XDEFIDistribution.sol:77:    function setLockPeriods(uint256[] memory durations_, uint8[] memory multipliers) external onlyOwner { XDEFIDistribution.sol:165:    function relockBatch(uint256[] memory tokenIds_, uint256 lockAmount_, uint256 duration_, address destination_) external noReenter returns (uint256 amountUnlocked_, uint256  newTokenId_) { XDEFIDistribution.sol:186:    function unlockBatch(uint256[] memory tokenIds_, address destination_) external noReenter returns (uint256 amountUnlocked_) { XDEFIDistribution.sol:205:    function merge(uint256[] memory tokenIds_, address destination_) external returns (uint256 tokenId_) { ```      ## Tools Used   VS Code      ## Recommended Mitigation Steps   Use `calldata` instead of `memory` for external functions where the function argument is read-only.  "}, {"title": "\"constants\" expressions are expressions, not constants. Use \"immutable\" instead.", "html_url": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/26", "labels": ["bug", "G (Gas Optimization)", "sponsor disputed"], "target": "2022-01-xdefi-findings", "body": "\"constants\" expressions are expressions, not constants. Use \"immutable\" instead."}, {"title": "The reentrancy vulnerability in _safeMint can allow an attacker to steal all rewards", "html_url": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/25", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-xdefi-findings", "body": "# Handle  cccz   # Vulnerability details  ## Impact  There is a reentrancy vulnerability in the _safeMint function  ```     function _safeMint(         address to,         uint256 tokenId,         bytes memory _data     ) internal virtual {         _mint(to, tokenId);         require(             _checkOnERC721Received(address(0), to, tokenId, _data),             \"ERC721: transfer to non ERC721Receiver implementer\"         );     }     ...     function _checkOnERC721Received(         address from,         address to,         uint256 tokenId,         bytes memory _data     ) private returns (bool) {         if (to.isContract()) {             try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {                 return retval == IERC721Receiver.onERC721Received.selector; ```  The lock function changes the totalDepositedXDEFI variable after calling the _safeMint function  ```     function lock(uint256 amount_, uint256 duration_, address destination_) external noReenter returns (uint256 tokenId_) {         // Lock the XDEFI in the contract.         SafeERC20.safeTransferFrom(IERC20(XDEFI), msg.sender, address(this), amount_);          // Handle the lock position creation and get the tokenId of the locked position.         return _lock(amount_, duration_, destination_);     }     ...         function _lock(uint256 amount_, uint256 duration_, address destination_) internal returns (uint256 tokenId_) {         // Prevent locking 0 amount in order generate many score-less NFTs, even if it is inefficient, and such NFTs would be ignored.         require(amount_ != uint256(0) && amount_ <= MAX_TOTAL_XDEFI_SUPPLY, \"INVALID_AMOUNT\");          // Get bonus multiplier and check that it is not zero (which validates the duration).         uint8 bonusMultiplier = bonusMultiplierOf[duration_];         require(bonusMultiplier != uint8(0), \"INVALID_DURATION\");          // Mint a locked staked position NFT to the destination.         _safeMint(destination_, tokenId_ = _generateNewTokenId(_getPoints(amount_, duration_)));          // Track deposits.         totalDepositedXDEFI += amount_;  ``` Since the updateDistribution function does not use the noReenter modifier, the attacker can re-enter the updateDistribution function in the _safeMint function. Since the value of totalDepositedXDEFI is not updated at this time, the _pointsPerUnit variable will become abnormally large.   ```      function updateDistribution() external {         uint256 totalUnitsCached = totalUnits;          require(totalUnitsCached> uint256(0), \"NO_UNIT_SUPPLY\");          uint256 newXDEFI = _toUint256Safe(_updateXDEFIBalance());          if (newXDEFI == uint256(0)) return;          _pointsPerUnit += ((newXDEFI * _pointsMultiplier) / totalUnitsCached);          emit DistributionUpdated(msg.sender, newXDEFI);     }     ...     function _updateXDEFIBalance() internal returns (int256 newFundsTokenBalance_) {         uint256 previousDistributableXDEFI = distributableXDEFI;         uint256 currentDistributableXDEFI = distributableXDEFI = IERC20(XDEFI).balanceOf(address(this))-totalDepositedXDEFI;          return _toInt256Safe(currentDistributableXDEFI)-_toInt256Safe(previousDistributableXDEFI);     }   ``` If the attacker calls the lock function to get the NFT before exploiting the reentrance vulnerability, then the unlock function can be called to steal a lot of rewards, and the assets deposited by the user using the reentrance vulnerability can also be redeemed by calling the unlock function. Since the unlock function calls the _updateXDEFIBalance function, the attacker cannot steal the assets deposited by the user   ```      function unlock(uint256 tokenId_, address destination_) external noReenter returns (uint256 amountUnlocked_) {         // Handle the unlock and get the amount of XDEFI eligible to withdraw.         amountUnlocked_ = _unlock(msg.sender, tokenId_);          // Send the the unlocked XDEFI to the destination.         SafeERC20.safeTransfer(IERC20(XDEFI), destination_, amountUnlocked_);          // NOTE: This needs to be done after updating `totalDepositedXDEFI` (which happens in `_unlock`) and transferring out.         _updateXDEFIBalance();     } ...      function _unlock(address account_, uint256 tokenId_) internal returns (uint256 amountUnlocked_) {         // Check that the account is the position NFT owner.         require(ownerOf(tokenId_) == account_, \"NOT_OWNER\");          // Fetch position.         Position storage position = positionOf[tokenId_];         uint96 units = position.units;         uint88 depositedXDEFI = position.depositedXDEFI;         uint32 expiry = position.expiry;          // Check that enough time has elapsed in order to unlock.         require(expiry != uint32(0), \"NO_LOCKED_POSITION\");         require(block.timestamp >= uint256(expiry), \"CANNOT_UNLOCK\");          // Get the withdrawable amount of XDEFI for the position.         amountUnlocked_ = _withdrawableGiven(units, depositedXDEFI, position.pointsCorrection);          // Track deposits.         totalDepositedXDEFI -= uint256(depositedXDEFI);          // Burn FDT Position.         totalUnits -= units;         delete positionOf[tokenId_];          emit LockPositionWithdrawn(tokenId_, account_, amountUnlocked_);     }     ...      function _withdrawableGiven(uint96 units_, uint88 depositedXDEFI_, int256 pointsCorrection_) internal view returns (uint256 withdrawableXDEFI_) {         return             (                 _toUint256Safe(                     _toInt256Safe(_pointsPerUnit * uint256(units_)) +                     pointsCorrection_                 ) / _pointsMultiplier             ) + uint256(depositedXDEFI_);     }  ``` ## Proof of Concept  https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-beta.0/contracts/XDEFIDistribution.sol#L253-L281  ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  ``` -    function updateDistribution() external  { +    function updateDistribution() external  noReenter { ```  "}, {"title": "Use Custom Errors to save Gas", "html_url": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/22", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-xdefi-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact   Custom errors from Solidity 0.8.4 are cheaper than revert strings.    ## Proof of Concept   Source: https://blog.soliditylang.org/2021/04/21/custom-errors/:  Starting from [Solidity v0.8.4](https://github.com/ethereum/solidity/releases/tag/v0.8.4), there is a convenient and gas-efficient way to explain to users why an operation failed through the use of custom errors. Until now, you could already use strings to give more information about failures (e.g., `revert(\"Insufficient funds.\");`), but they are rather expensive, especially when it comes to deploy cost, and it is difficult to use dynamic information in them.  Custom errors are defined using the `error` statement, which can be used inside and outside of contracts (including interfaces and libraries).  Instances include:   ```   XDEFIDistribution.sol:40:        require((XDEFI = XDEFI_) != address(0), \"INVALID_TOKEN\"); XDEFIDistribution.sol:47:        require(owner == msg.sender, \"NOT_OWNER\"); XDEFIDistribution.sol:52:        require(_locked == 0, \"LOCKED\"); XDEFIDistribution.sol:63:        require(pendingOwner == msg.sender, \"NOT_PENDING_OWNER\"); XDEFIDistribution.sol:82:            require(duration <= uint256(18250 days), \"INVALID_DURATION\"); XDEFIDistribution.sol:115:        require(lockAmount_ <= amountUnlocked_, \"INSUFFICIENT_AMOUNT_UNLOCKED\"); XDEFIDistribution.sol:145:        require(totalUnitsCached > uint256(0), \"NO_UNIT_SUPPLY\"); XDEFIDistribution.sol:170:        require(lockAmount_ <= amountUnlocked_, \"INSUFFICIENT_AMOUNT_UNLOCKED\"); XDEFIDistribution.sol:207:        require(count > uint256(1), \"MIN_2_TO_MERGE\"); XDEFIDistribution.sol:214:            require(ownerOf(tokenId) == msg.sender, \"NOT_OWNER\"); XDEFIDistribution.sol:215:            require(positionOf[tokenId].expiry == uint32(0), \"POSITION_NOT_UNLOCKED\");  XDEFIDistribution.sol:227:        require(_exists(tokenId_), \"NO_TOKEN\"); XDEFIDistribution.sol:232:        require(_exists(tokenId_), \"NO_TOKEN\"); XDEFIDistribution.sol:255:        require(amount_ != uint256(0) && amount_ <= MAX_TOTAL_XDEFI_SUPPLY, \"INVALID_AMOUNT\"); XDEFIDistribution.sol:259:        require(bonusMultiplier != uint8(0), \"INVALID_DURATION\"); XDEFIDistribution.sol:295:        require(ownerOf(tokenId_) == account_, \"NOT_OWNER\"); XDEFIDistribution.sol:304:        require(expiry != uint32(0), \"NO_LOCKED_POSITION\"); XDEFIDistribution.sol:305:        require(block.timestamp >= uint256(expiry), \"CANNOT_UNLOCK\"); XDEFIDistribution.sol:322:        require(count > uint256(1), \"USE_UNLOCK\"); ```      ## Tools Used   VS Code    ## Recommended Mitigation Steps   Replace revert strings with custom errors.   "}, {"title": "`_safeMint` Will Fail Due To An Edge Case In Calculating `tokenId` Using The `_generateNewTokenId` Function", "html_url": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/17", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-xdefi-findings", "body": "# Handle  leastwood   # Vulnerability details  ## Impact  NFTs are used to represent unique positions referenced by the generated `tokenId`. The `tokenId` value contains the position's score in the upper 128 bits and the index wrt. the token supply in the lower 128 bits.  When positions are unlocked after expiring, the relevant position stored in the `positionOf` mapping is deleted, however, the NFT is not. The `merge()` function is used to combine points in unlocked NFTs, burning the underlying NFTs upon merging. As a result, `_generateNewTokenId()` may end up using the same `totalSupply()` value, causing `_safeMint()` to fail if the same `amount_` and `duration_` values are used.  This edge case only occurs if there is an overlap in the `points_` and `totalSupply() + 1` values used to generate `tokenId`. As a result, this may impact a user's overall experience while interacting with the `XDEFI` protocol, as some transactions may fail unexpectedly.  ## Proof of Concept  ``` function _lock(uint256 amount_, uint256 duration_, address destination_) internal returns (uint256 tokenId_) {     // Prevent locking 0 amount in order generate many score-less NFTs, even if it is inefficient, and such NFTs would be ignored.     require(amount_ != uint256(0) && amount_ <= MAX_TOTAL_XDEFI_SUPPLY, \"INVALID_AMOUNT\");      // Get bonus multiplier and check that it is not zero (which validates the duration).     uint8 bonusMultiplier = bonusMultiplierOf[duration_];     require(bonusMultiplier != uint8(0), \"INVALID_DURATION\");      // Mint a locked staked position NFT to the destination.     _safeMint(destination_, tokenId_ = _generateNewTokenId(_getPoints(amount_, duration_)));      // Track deposits.     totalDepositedXDEFI += amount_;      // Create Position.     uint96 units = uint96((amount_ * uint256(bonusMultiplier)) / uint256(100));     totalUnits += units;     positionOf[tokenId_] =         Position({             units: units,             depositedXDEFI: uint88(amount_),             expiry: uint32(block.timestamp + duration_),             created: uint32(block.timestamp),             bonusMultiplier: bonusMultiplier,             pointsCorrection: -_toInt256Safe(_pointsPerUnit * units)         });      emit LockPositionCreated(tokenId_, destination_, amount_, duration_); } ```  ``` function _generateNewTokenId(uint256 points_) internal view returns (uint256 tokenId_) {     // Points is capped at 128 bits (max supply of XDEFI for 10 years locked), total supply of NFTs is capped at 128 bits.     return (points_ << uint256(128)) + uint128(totalSupply() + 1); } ```  ``` function merge(uint256[] memory tokenIds_, address destination_) external returns (uint256 tokenId_) {     uint256 count = tokenIds_.length;     require(count > uint256(1), \"MIN_2_TO_MERGE\");      uint256 points;      // For each NFT, check that it belongs to the caller, burn it, and accumulate the points.     for (uint256 i; i < count; ++i) {         uint256 tokenId = tokenIds_[i];         require(ownerOf(tokenId) == msg.sender, \"NOT_OWNER\");         require(positionOf[tokenId].expiry == uint32(0), \"POSITION_NOT_UNLOCKED\");          _burn(tokenId);          points += _getPointsFromTokenId(tokenId);     }      // Mine a new NFT to the destinations, based on the accumulated points.     _safeMint(destination_, tokenId_ = _generateNewTokenId(points)); } ```  ## Tools Used  Manual code review. Discussions with Michael.  ## Recommended Mitigation Steps  Consider replacing `totalSupply()` in `_generateNewTokenId()` with an internal counter. This should ensure that `_generateNewTokenId()` always returns a unique `tokenId` that is monotomically increasing .  "}, {"title": "Missing event for admin function setBaseURI", "html_url": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/16", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2022-01-xdefi-findings", "body": "# Handle  BouSalman   # Vulnerability details  ## Vulnerability description In Contract **XDEFIDistribution** the function **setBaseURI** is missing an event for this admin functionality.  ## Impact Users can't monitor admin changes done to the contract to reflect it in their clients.  ## Proof of Concept https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L73  ## Tools Used manual code review.  ## Recommended Mitigation Steps create event for base URI changes and emit it.  "}, {"title": "Assert instead require to validate user inputs", "html_url": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/14", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-xdefi-findings", "body": "Assert instead require to validate user inputs"}, {"title": "Require with not comprehensive message", "html_url": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/11", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2022-01-xdefi-findings", "body": "Require with not comprehensive message"}, {"title": "Prefix increments are cheaper than postfix increments", "html_url": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/9", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-xdefi-findings", "body": "Prefix increments are cheaper than postfix increments"}, {"title": "Unnecessary array boundaries check when loading an array element twice", "html_url": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/8", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-xdefi-findings", "body": "Unnecessary array boundaries check when loading an array element twice"}, {"title": "Public functions to external", "html_url": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/6", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-xdefi-findings", "body": "Public functions to external"}, {"title": "Unneccessary check on total supply of XDEFI token", "html_url": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/3", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-xdefi-findings", "body": "# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact Extra gas costs of all locking operations.  ## Proof of Concept  XDEFIDistribution.sol stores the total supply of the XDEFI token:  https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L14  This is so that the amount being locked can be checked to be less than this on each call  https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L255  This is unnecessary as the XDEFI token has no external mint function and so has a fixed supply. It's then impossible for any user to supply more than 240M XDEFI in order to fail this check.  https://etherscan.io/address/0x72b886d09c117654ab7da13a14d603001de0b777#code  ## Recommended Mitigation Steps  Remove the unnecessary check on the total supply.  "}, {"title": "Use of return value from assignment hampers readability", "html_url": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/2", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-xdefi-findings", "body": "# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact  Reduced readability  ## Proof of Concept  In a number of placed we seem to be inlining an assignment with the usage of that variable:  https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L40  https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L70  https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L83  This is quite atypical in my experience and reduces readability: lines which contain require statements and event emission now modify contract storage.  ## Recommended Mitigation Steps  Consider whether any small benefits to gas/compactness are worth the reduced clarity.  "}, {"title": "Usage of zero storage for reentrancy guard increases chance that gas refund is capped", "html_url": "https://github.com/code-423n4/2022-01-xdefi-findings/issues/1", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-xdefi-findings", "body": "# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact  Reduction of potential gas refunds.  ## Proof of Concept  The reentrancy guard variable is initially set to zero, set to a nonzero value and then reset to zero:  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/4a9cc8b4918ef3736229a5cc5a310bdc17bf759f/contracts/security/ReentrancyGuard.sol#L29-L35  We then have to the higher cost for writing to clean storage rather than dirty storage (which is then refunded). This is not recommended as it can cause the size of the gas refunded to users to be capped. For more info see the OZ implementation:  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/4a9cc8b4918ef3736229a5cc5a310bdc17bf759f/contracts/security/ReentrancyGuard.sol#L29-L35  ## Recommended Mitigation Steps  Change from 0->1->0 to 1->2->1  "}, {"title": "missing whenNotPaused", "html_url": "https://github.com/code-423n4/2022-01-sherlock-findings/issues/280", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-sherlock-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-aave-lens/blob/main/contracts/core/LensHub.sol#L929   # Vulnerability details  All the external function of LensHub have whenNotPasued modifier. However, LensHub is erc721 and the transfer function doesn't have the whenNotPaused modifier.  ## Impact In case where the governance wants to stop all activity, they still can't stop transferring profiles nfts. an example where stopping transferring tokens was actually very helpful: [https://mobile.twitter.com/flashfish0x/status/1466369783016869892](https://mobile.twitter.com/flashfish0x/status/1466369783016869892)   ## Recommended Mitigation Steps add whenNotPasued to `_beforeTokenTransfer`  "}, {"title": "debt = balance", "html_url": "https://github.com/code-423n4/2022-01-sherlock-findings/issues/276", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-01-sherlock-findings", "body": "debt = balance"}, {"title": "Re-entrancy protection", "html_url": "https://github.com/code-423n4/2022-01-sherlock-findings/issues/274", "labels": ["bug", "0 (Non-critical)"], "target": "2022-01-sherlock-findings", "body": "Re-entrancy protection"}, {"title": "Pausable paused() is not enforced to be present", "html_url": "https://github.com/code-423n4/2022-01-sherlock-findings/issues/273", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2022-01-sherlock-findings", "body": "Pausable paused() is not enforced to be present"}, {"title": "Claim SHER on behalf of others", "html_url": "https://github.com/code-423n4/2022-01-sherlock-findings/issues/271", "labels": ["bug", "help wanted", "0 (Non-critical)", "disagree with severity"], "target": "2022-01-sherlock-findings", "body": "Claim SHER on behalf of others"}, {"title": "Slippage parameter for SherBuy", "html_url": "https://github.com/code-423n4/2022-01-sherlock-findings/issues/270", "labels": ["bug", "1 (Low Risk)", "disagree with severity"], "target": "2022-01-sherlock-findings", "body": "Slippage parameter for SherBuy"}, {"title": "safeApprove will fail if the current approval is not 0", "html_url": "https://github.com/code-423n4/2022-01-sherlock-findings/issues/269", "labels": ["bug", "1 (Low Risk)"], "target": "2022-01-sherlock-findings", "body": "safeApprove will fail if the current approval is not 0"}, {"title": "Withrawals will fail if the market has high utilization", "html_url": "https://github.com/code-423n4/2022-01-sherlock-findings/issues/267", "labels": ["bug", "0 (Non-critical)", "disagree with severity"], "target": "2022-01-sherlock-findings", "body": "Withrawals will fail if the market has high utilization"}, {"title": "cheaper to calculate stakeShares first then do the transfer", "html_url": "https://github.com/code-423n4/2022-01-sherlock-findings/issues/256", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-01-sherlock-findings", "body": "cheaper to calculate stakeShares first then do the transfer"}, {"title": "Adding unchecked directive can save gas", "html_url": "https://github.com/code-423n4/2022-01-sherlock-findings/issues/253", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-01-sherlock-findings", "body": "Adding unchecked directive can save gas"}, {"title": "Cheaper to use calldata than memory", "html_url": "https://github.com/code-423n4/2022-01-sherlock-findings/issues/249", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-01-sherlock-findings", "body": "Cheaper to use calldata than memory"}, {"title": "Unnecessary typcasting", "html_url": "https://github.com/code-423n4/2022-01-sherlock-findings/issues/245", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2022-01-sherlock-findings", "body": "Unnecessary typcasting"}, {"title": "Name collision in `SherlockProtocolManager`", "html_url": "https://github.com/code-423n4/2022-01-sherlock-findings/issues/239", "labels": ["bug", "0 (Non-critical)", "disagree with severity"], "target": "2022-01-sherlock-findings", "body": "Name collision in `SherlockProtocolManager`"}, {"title": "Gas Optimization: Struct layout", "html_url": "https://github.com/code-423n4/2022-01-sherlock-findings/issues/236", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-01-sherlock-findings", "body": "Gas Optimization: Struct layout"}, {"title": "Cache array length in for loops can save gas", "html_url": "https://github.com/code-423n4/2022-01-sherlock-findings/issues/231", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-01-sherlock-findings", "body": "Cache array length in for loops can save gas"}, {"title": "SherlockClaimManager: Incorrect amounts needed and paid for escalated claims ", "html_url": "https://github.com/code-423n4/2022-01-sherlock-findings/issues/230", "labels": ["bug", "documentation", "2 (Med Risk)", "disagree with severity"], "target": "2022-01-sherlock-findings", "body": "SherlockClaimManager: Incorrect amounts needed and paid for escalated claims "}, {"title": "ISherlockClaimManager: Outdated example on claims process", "html_url": "https://github.com/code-423n4/2022-01-sherlock-findings/issues/229", "labels": ["bug", "documentation", "0 (Non-critical)", "disagree with severity"], "target": "2022-01-sherlock-findings", "body": "ISherlockClaimManager: Outdated example on claims process"}, {"title": "SherlockClaimManager: Confusing comment on BOND", "html_url": "https://github.com/code-423n4/2022-01-sherlock-findings/issues/228", "labels": ["bug", "documentation", "0 (Non-critical)", "disagree with severity"], "target": "2022-01-sherlock-findings", "body": "SherlockClaimManager: Confusing comment on BOND"}, {"title": "SherlockClaimManager: startClaim() has outdated comment", "html_url": "https://github.com/code-423n4/2022-01-sherlock-findings/issues/226", "labels": ["bug", "documentation", "0 (Non-critical)"], "target": "2022-01-sherlock-findings", "body": "SherlockClaimManager: startClaim() has outdated comment"}, {"title": "Sherlock: Revert for non-existent ID in viewRewardForArbRestake", "html_url": "https://github.com/code-423n4/2022-01-sherlock-findings/issues/225", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-sherlock-findings", "body": "# Handle  GreyArt   # Vulnerability details  ## Impact  Other relevant view functions like `lockupEnd()`, `sherRewards()` and `tokenBalanceOf()` revert for non-existent IDs, but `viewRewardForArbRestake()` doesn\u2019t.  ## Recommended Mitigation Steps  Include the existence check in `viewRewardForArbRestake()`.  `if (!_exists(_tokenID)) revert NonExistent();`  "}, {"title": "SherBuy: SHER and USDC token addresses should be derived from _sherlockPosition", "html_url": "https://github.com/code-423n4/2022-01-sherlock-findings/issues/222", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2022-01-sherlock-findings", "body": "SherBuy: SHER and USDC token addresses should be derived from _sherlockPosition"}, {"title": "SherlockClaimManager: Clarify why sherlockCore is used as proposer in UMA.requestAndProposePriceFor()", "html_url": "https://github.com/code-423n4/2022-01-sherlock-findings/issues/220", "labels": ["bug", "documentation", "0 (Non-critical)"], "target": "2022-01-sherlock-findings", "body": "SherlockClaimManager: Clarify why sherlockCore is used as proposer in UMA.requestAndProposePriceFor()"}, {"title": "Grammar", "html_url": "https://github.com/code-423n4/2022-01-sherlock-findings/issues/219", "labels": ["bug", "documentation", "0 (Non-critical)"], "target": "2022-01-sherlock-findings", "body": "Grammar"}, {"title": "Inconsistent Acronym of UmaHaltOperator", "html_url": "https://github.com/code-423n4/2022-01-sherlock-findings/issues/218", "labels": ["bug", "documentation", "0 (Non-critical)"], "target": "2022-01-sherlock-findings", "body": "Inconsistent Acronym of UmaHaltOperator"}, {"title": "SherlockClaimManager: reentrancy comment for priceProposed() and priceDisputed() can be phrased better", "html_url": "https://github.com/code-423n4/2022-01-sherlock-findings/issues/217", "labels": ["bug", "documentation", "0 (Non-critical)"], "target": "2022-01-sherlock-findings", "body": "SherlockClaimManager: reentrancy comment for priceProposed() and priceDisputed() can be phrased better"}, {"title": "Spelling Errors", "html_url": "https://github.com/code-423n4/2022-01-sherlock-findings/issues/216", "labels": ["bug", "documentation", "0 (Non-critical)"], "target": "2022-01-sherlock-findings", "body": "Spelling Errors"}, {"title": "SherDistributionManager: Cheaper to assign than add _tvl", "html_url": "https://github.com/code-423n4/2022-01-sherlock-findings/issues/215", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-01-sherlock-findings", "body": "SherDistributionManager: Cheaper to assign than add _tvl"}, {"title": "Manager: Check non-zero ETH balance before sending", "html_url": "https://github.com/code-423n4/2022-01-sherlock-findings/issues/211", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-01-sherlock-findings", "body": "Manager: Check non-zero ETH balance before sending"}, {"title": "Updating Manager contract could destruct Sherlock core functionalities   ", "html_url": "https://github.com/code-423n4/2022-01-sherlock-findings/issues/201", "labels": ["bug", "documentation", "0 (Non-critical)", "disagree with severity"], "target": "2022-01-sherlock-findings", "body": "Updating Manager contract could destruct Sherlock core functionalities   "}, {"title": "Saving gas by used length", "html_url": "https://github.com/code-423n4/2022-01-sherlock-findings/issues/200", "labels": ["bug", "duplicate", "G (Gas Optimization)"], "target": "2022-01-sherlock-findings", "body": "Saving gas by used length"}, {"title": "Gas: Non-strict inequalities are cheaper than strict ones", "html_url": "https://github.com/code-423n4/2022-01-sherlock-findings/issues/193", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-01-sherlock-findings", "body": "Gas: Non-strict inequalities are cheaper than strict ones"}, {"title": "`SherlockProtocolManager.sol`: `setMinActiveBalance()` and `forceRemoveByActiveBalance()` should be put behind a timelock", "html_url": "https://github.com/code-423n4/2022-01-sherlock-findings/issues/191", "labels": ["bug", "documentation", "0 (Non-critical)", "disagree with severity"], "target": "2022-01-sherlock-findings", "body": "`SherlockProtocolManager.sol`: `setMinActiveBalance()` and `forceRemoveByActiveBalance()` should be put behind a timelock"}, {"title": "USDC is upgradeable: received amount should be calculated", "html_url": "https://github.com/code-423n4/2022-01-sherlock-findings/issues/188", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2022-01-sherlock-findings", "body": "USDC is upgradeable: received amount should be calculated"}, {"title": "10 ** 18 can be changed to 1e18 and save some gas", "html_url": "https://github.com/code-423n4/2022-01-sherlock-findings/issues/185", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-01-sherlock-findings", "body": "10 ** 18 can be changed to 1e18 and save some gas"}, {"title": "There is a deviation in the parameter value setting.", "html_url": "https://github.com/code-423n4/2022-01-sherlock-findings/issues/174", "labels": ["bug", "documentation", "0 (Non-critical)", "disagree with severity"], "target": "2022-01-sherlock-findings", "body": "There is a deviation in the parameter value setting."}, {"title": "Many `protocolUpdate()` calls erase historic previousCoverage", "html_url": "https://github.com/code-423n4/2022-01-sherlock-findings/issues/171", "labels": ["bug", "1 (Low Risk)", "disagree with severity"], "target": "2022-01-sherlock-findings", "body": "Many `protocolUpdate()` calls erase historic previousCoverage"}, {"title": "Incorrect comment about callback call", "html_url": "https://github.com/code-423n4/2022-01-sherlock-findings/issues/169", "labels": ["bug", "documentation", "0 (Non-critical)", "disagree with severity"], "target": "2022-01-sherlock-findings", "body": "Incorrect comment about callback call"}, {"title": "Bond price not controlled by Sherlock", "html_url": "https://github.com/code-423n4/2022-01-sherlock-findings/issues/166", "labels": ["bug", "documentation", "0 (Non-critical)", "disagree with severity"], "target": "2022-01-sherlock-findings", "body": "Bond price not controlled by Sherlock"}, {"title": "Implementation is not align with documentation #2", "html_url": "https://github.com/code-423n4/2022-01-sherlock-findings/issues/154", "labels": ["bug", "documentation", "0 (Non-critical)", "disagree with severity"], "target": "2022-01-sherlock-findings", "body": "Implementation is not align with documentation #2"}, {"title": "Gas in `SherlockClaimManager.sol:priceDisputed():`: a value used only once shouldn't get cached", "html_url": "https://github.com/code-423n4/2022-01-sherlock-findings/issues/146", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-01-sherlock-findings", "body": "Gas in `SherlockClaimManager.sol:priceDisputed():`: a value used only once shouldn't get cached"}, {"title": "saving gas on reverted transactions", "html_url": "https://github.com/code-423n4/2022-01-sherlock-findings/issues/142", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-01-sherlock-findings", "body": "saving gas on reverted transactions"}, {"title": "yieldStrategyDeposit doesn't check that there is enough USDC to deposit", "html_url": "https://github.com/code-423n4/2022-01-sherlock-findings/issues/141", "labels": ["bug", "0 (Non-critical)", "disagree with severity"], "target": "2022-01-sherlock-findings", "body": "yieldStrategyDeposit doesn't check that there is enough USDC to deposit"}, {"title": "Gas: Using the logical NOT operator `!` is cheaper than a comparison to the constant boolean value `false`", "html_url": "https://github.com/code-423n4/2022-01-sherlock-findings/issues/132", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-01-sherlock-findings", "body": "Gas: Using the logical NOT operator `!` is cheaper than a comparison to the constant boolean value `false`"}, {"title": "If condition can be removed from SherlockClaimManager.cleanUp function", "html_url": "https://github.com/code-423n4/2022-01-sherlock-findings/issues/130", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-01-sherlock-findings", "body": "If condition can be removed from SherlockClaimManager.cleanUp function"}, {"title": "Missing parameter check or confusing comment in function protocolRemove (SherlockProtocolManager.sol)", "html_url": "https://github.com/code-423n4/2022-01-sherlock-findings/issues/123", "labels": ["bug", "help wanted", "1 (Low Risk)"], "target": "2022-01-sherlock-findings", "body": "Missing parameter check or confusing comment in function protocolRemove (SherlockProtocolManager.sol)"}, {"title": "Gas: Consider making some constants as non-public to save gas", "html_url": "https://github.com/code-423n4/2022-01-sherlock-findings/issues/116", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-01-sherlock-findings", "body": "Gas: Consider making some constants as non-public to save gas"}, {"title": "Gas: \"constants\" expressions are expressions, not constants. Use \"immutable\" instead.", "html_url": "https://github.com/code-423n4/2022-01-sherlock-findings/issues/113", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-01-sherlock-findings", "body": "Gas: \"constants\" expressions are expressions, not constants. Use \"immutable\" instead."}, {"title": "Wrong user input check of incoming USDC when escalating claim", "html_url": "https://github.com/code-423n4/2022-01-sherlock-findings/issues/112", "labels": ["bug", "1 (Low Risk)", "disagree with severity"], "target": "2022-01-sherlock-findings", "body": "Wrong user input check of incoming USDC when escalating claim"}, {"title": "Gas: `++i` costs less gas compared to `i++`", "html_url": "https://github.com/code-423n4/2022-01-sherlock-findings/issues/111", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-01-sherlock-findings", "body": "Gas: `++i` costs less gas compared to `i++`"}, {"title": "Use of the reserved keyword `error` as a variable name", "html_url": "https://github.com/code-423n4/2022-01-sherlock-findings/issues/110", "labels": ["bug", "0 (Non-critical)", "disagree with severity"], "target": "2022-01-sherlock-findings", "body": "Use of the reserved keyword `error` as a variable name"}, {"title": "tokenBalanceOfAddress of nftOwner becomes permanently incorrect after arbRestake", "html_url": "https://github.com/code-423n4/2022-01-sherlock-findings/issues/109", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-sherlock-findings", "body": "# Handle  hyh   # Vulnerability details  ## Impact  Sucessfull `arbRestake` performs `_redeemShares` for `arbRewardShares` amount to extract the arbitrager reward. This effectively reduces shares accounted for an NFT, but leaves untouched the `addressShares` of an `nftOwner`.  As a result the `tokenBalanceOfAddress` function will report an old balance that existed before arbitrager reward was slashed away. This will persist if the owner will transfer the NFT to someone else as its new reduced shares value will be subtracted from `addressShares` in `_beforeTokenTransfer`, leaving the arbitrage removed shares permanently in `addressShares` of the NFT owner, essentially making all further reporting of his balance incorrectly inflated by the cumulative arbitrage reward shares from all arbRestakes happened to the owner's NFTs.  ## Proof of Concept  `arbRestake` redeems `arbRewardShares`, which are a part of total shares of an NFT:  https://github.com/code-423n4/2022-01-sherlock/blob/main/contracts/Sherlock.sol#L673   This will effectively reduce the `stakeShares`:  https://github.com/code-423n4/2022-01-sherlock/blob/main/contracts/Sherlock.sol#L491  But there is no mechanics in place to reduce `addressShares` of the owner apart from mint/burn/transfer, so `addressShares` will still correspond to NFT shares before arbitrage. This discrepancy will be accumulated further with arbitrage restakes.   ## Recommended Mitigation Steps  Add a flag to `_redeemShares` indicating that it was called for a partial shares decrease, say `isPartialRedeem`, and do `addressShares[nftOwner] -= _stakeShares` when `isPartialRedeem == true`.  Another option is to do bigger refactoring, making stakeShares and addressShares always change simultaneously.   "}, {"title": "No Transfer Ownership Pattern", "html_url": "https://github.com/code-423n4/2022-01-sherlock-findings/issues/100", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor acknowledged"], "target": "2022-01-sherlock-findings", "body": "No Transfer Ownership Pattern"}, {"title": "_isEscalateState Comment Improvement", "html_url": "https://github.com/code-423n4/2022-01-sherlock-findings/issues/95", "labels": ["bug", "documentation", "0 (Non-critical)", "disagree with severity"], "target": "2022-01-sherlock-findings", "body": "_isEscalateState Comment Improvement"}, {"title": "Incorrect comparison for prevCoverage in startClaim()", "html_url": "https://github.com/code-423n4/2022-01-sherlock-findings/issues/94", "labels": ["bug", "documentation", "0 (Non-critical)", "disagree with severity"], "target": "2022-01-sherlock-findings", "body": "Incorrect comparison for prevCoverage in startClaim()"}, {"title": "Pause/unpause functions descriptions aren't fully correct ", "html_url": "https://github.com/code-423n4/2022-01-sherlock-findings/issues/90", "labels": ["bug", "documentation", "0 (Non-critical)", "disagree with severity"], "target": "2022-01-sherlock-findings", "body": "Pause/unpause functions descriptions aren't fully correct "}, {"title": "Implementation is not align with documentation", "html_url": "https://github.com/code-423n4/2022-01-sherlock-findings/issues/88", "labels": ["bug", "documentation", "0 (Non-critical)", "disagree with severity"], "target": "2022-01-sherlock-findings", "body": "Implementation is not align with documentation"}, {"title": "Use return value of assignments to save gas", "html_url": "https://github.com/code-423n4/2022-01-sherlock-findings/issues/78", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-01-sherlock-findings", "body": "Use return value of assignments to save gas"}, {"title": "Avoid unneeded SLOADs by caching values in memory", "html_url": "https://github.com/code-423n4/2022-01-sherlock-findings/issues/77", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-01-sherlock-findings", "body": "Avoid unneeded SLOADs by caching values in memory"}, {"title": "updateYieldStrategy will freeze some funds with the old Strategy if yieldStrategy fails to withdraw all the funds because of liquidity issues", "html_url": "https://github.com/code-423n4/2022-01-sherlock-findings/issues/76", "labels": ["bug", "enhancement", "2 (Med Risk)", "disagree with severity"], "target": "2022-01-sherlock-findings", "body": "updateYieldStrategy will freeze some funds with the old Strategy if yieldStrategy fails to withdraw all the funds because of liquidity issues"}, {"title": "Use structs instead of three mappings in Sherlock.sol", "html_url": "https://github.com/code-423n4/2022-01-sherlock-findings/issues/69", "labels": ["bug", "0 (Non-critical)"], "target": "2022-01-sherlock-findings", "body": "Use structs instead of three mappings in Sherlock.sol"}, {"title": "Hardhat references in Manager.sol code", "html_url": "https://github.com/code-423n4/2022-01-sherlock-findings/issues/67", "labels": ["bug", "0 (Non-critical)"], "target": "2022-01-sherlock-findings", "body": "Hardhat references in Manager.sol code"}, {"title": "Never-used ETH transfers in _sweep", "html_url": "https://github.com/code-423n4/2022-01-sherlock-findings/issues/66", "labels": ["bug", "0 (Non-critical)"], "target": "2022-01-sherlock-findings", "body": "Never-used ETH transfers in _sweep"}, {"title": "Reenterancy in `_sendSherRewardsToOwner()`", "html_url": "https://github.com/code-423n4/2022-01-sherlock-findings/issues/60", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2022-01-sherlock-findings", "body": "# Handle  kirk-baird   # Vulnerability details  ## Impact  This is a reentrancy vulnerability that would allow the attacker to drain the entire SHER balance of the contract.  Note: this attack requires gaining control of execution `sher.transfer()` which will depend on the implementation of the SHER token. Control may be gained by the attacker if the contract implements ERC777 or otherwise makes external calls during `transfer()`.  ## Proof of Concept  See [_sendSherRewards](https://github.com/code-423n4/2022-01-sherlock/blob/main/contracts/Sherlock.sol#L442)  ```solidity   function _sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {     uint256 sherReward = sherRewards_[_id];     if (sherReward == 0) return;      // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner     sher.safeTransfer(_nftOwner, sherReward);     // Deletes the SHER reward mapping for this NFT ID     delete sherRewards_[_id];   } ```  Here `sherRewards` are deleted after the potential external call is made in `sher.safeTransfer()`. As a result if an attacker reenters this function `sherRewards_` they will still maintain the original balance of rewards and again transfer the SHER tokens.  As `_sendSherRewardsToOwner()` is `internal` the attack can be initiated through the `external` function `ownerRestake()` [see here.](https://github.com/code-423n4/2022-01-sherlock/blob/main/contracts/Sherlock.sol#L595)  Steps to produce the attack:  1) Deploy attack contract to handle reenterancy 2) Call `initialStake()` from the attack contract with the smallest `period` 3) Wait for `period` amount of time to pass 4) Have the attack contract call `ownerRestake()`. The attack contract will gain control of the (See note above about control flow). This will recursively call `ownerRestake()` until the balance of `Sherlock` is 0 or less than the user's reward amount. Then allow reentrancy loop to unwind and complete.  ## Tools Used  n/a  ## Recommended Mitigation Steps  Reentrancy can be mitigated by one of two solutions.  The first option is to add a reentrancy guard like `nonReentrant` the is used in `SherlockClaimManager.sol`.  The second option is to use the checks-effects-interactions pattern. This would involve doing all validation checks and state changes before making any potential external calls. For example the above function could be modified as follows.  ```solidity   function _sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {     uint256 sherReward = sherRewards_[_id];     if (sherReward == 0) return;      // Deletes the SHER reward mapping for this NFT ID     delete sherRewards_[_id];      // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner     sher.safeTransfer(_nftOwner, sherReward);   } ```  Additionally the following functions are not exploitable however should be updated to use the check-effects-interations pattern. - `Sherlock._redeemShares()` should do `_transferTokensOut()` last. - `Sherlock.initialStake()` should do `token.safeTransferFrom(msg.sender, address(this), _amount);` last - `SherClaim.add()` should do `sher.safeTransferFrom(msg.sender, address(this), _amount);` after updating `userClaims`  - `SherlockProtocolManager.depositToActiveBalance()` should do `token.safeTransferFrom(msg.sender, address(this), _amount);` after updating `activeBalances`    "}, {"title": "ISherlockGov.removeSherDistributionManager description is incorrect", "html_url": "https://github.com/code-423n4/2022-01-sherlock-findings/issues/56", "labels": ["bug", "documentation", "0 (Non-critical)"], "target": "2022-01-sherlock-findings", "body": "ISherlockGov.removeSherDistributionManager description is incorrect"}, {"title": "Function call can be done after required check.", "html_url": "https://github.com/code-423n4/2022-01-sherlock-findings/issues/54", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-01-sherlock-findings", "body": "Function call can be done after required check."}, {"title": "addressShares introduction made further shares accounting error prone", "html_url": "https://github.com/code-423n4/2022-01-sherlock-findings/issues/53", "labels": ["bug", "0 (Non-critical)", "disagree with severity"], "target": "2022-01-sherlock-findings", "body": "addressShares introduction made further shares accounting error prone"}, {"title": "`Sherlock.sol#_beforeTokenTransfer()` has not needed if statements", "html_url": "https://github.com/code-423n4/2022-01-sherlock-findings/issues/48", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-01-sherlock-findings", "body": "`Sherlock.sol#_beforeTokenTransfer()` has not needed if statements"}, {"title": "`SherDistributionManager.sol#slopeRewardsAvailable` can be calculated later to save gas", "html_url": "https://github.com/code-423n4/2022-01-sherlock-findings/issues/44", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-01-sherlock-findings", "body": "`SherDistributionManager.sol#slopeRewardsAvailable` can be calculated later to save gas"}, {"title": "first user can steal everyone else's tokens", "html_url": "https://github.com/code-423n4/2022-01-sherlock-findings/issues/39", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-sherlock-findings", "body": "# Handle  egjlmn1   # Vulnerability details  ## Impact A user who joins the systems first (stakes first) can steal everybody's tokens by sending tokens to the system externally. This attack is possible because you enable staking a small amount of tokens.  ## Proof of Concept See the following attack: 1. the first user (user A) who enters the system stake 1 token 2. another user (user B) is about to stake X tokens 3. user A frontrun and transfer X tokens to the system via `ERC20.transfer` 4. user B stakes X tokens, and the shares he receives is: `shares = (_amount * totalStakeShares_) / (totalTokenBalanceStakers() - _amount);` `shares = (X * 1) / (X + 1 + X - X) = X/(X+1) = 0` meaning all the tokens he staked got him no shares, and those tokens are now a part of the single share that user A holds 5. user A can now redeem his shares and get the 1 token he staked, the X tokens user B staked, and the X tokens he `ERC20.transfer` to the system because all the money in the system is in a single share that user A holds.  In general, since there is only a single share, for any user who is going to stake X tokens, if the system has X+1 tokens in its balance, the user won't get any shares and all the money will go to the attacker.  ## Tools Used Manual code review  ## Recommended Mitigation Steps Force users to stake at least some amount in the system (Uniswap forces users to pay at least `1e18`) That way the amount the attacker will need to ERC20.transfer to the system will be at least `X*1e18` instead of `X` which is unrealistic  "}, {"title": "gas saving III", "html_url": "https://github.com/code-423n4/2022-01-sherlock-findings/issues/31", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-01-sherlock-findings", "body": "gas saving III"}, {"title": "safeApprove of openZeppelin is deprecated", "html_url": "https://github.com/code-423n4/2022-01-sherlock-findings/issues/11", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2022-01-sherlock-findings", "body": "safeApprove of openZeppelin is deprecated"}, {"title": "Gas in `FlashGovernanceArbiter.assertGovernanceApproved()`: `flashGovernanceConfig.asset` and `flashGovernanceConfig.amount` should get cached", "html_url": "https://github.com/code-423n4/2022-01-behodler-findings/issues/336", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-behodler-findings", "body": "Gas in `FlashGovernanceArbiter.assertGovernanceApproved()`: `flashGovernanceConfig.asset` and `flashGovernanceConfig.amount` should get cached"}, {"title": "All the scxMinted is at risk of being burnt.(Limbo.sol)", "html_url": "https://github.com/code-423n4/2022-01-behodler-findings/issues/335", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-01-behodler-findings", "body": "All the scxMinted is at risk of being burnt.(Limbo.sol)"}, {"title": "Gas in `LimboDAO.seed()`: Avoiding a 2N for-loop for a N one", "html_url": "https://github.com/code-423n4/2022-01-behodler-findings/issues/309", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-behodler-findings", "body": "Gas in `LimboDAO.seed()`: Avoiding a 2N for-loop for a N one"}, {"title": "Logic error in `burnFlashGovernanceAsset` can cause locked assets to be stolen", "html_url": "https://github.com/code-423n4/2022-01-behodler-findings/issues/305", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-behodler-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  A logic error in the `burnFlashGovernanceAsset` function that resets a user's `pendingFlashDecision` allows that user to steal other user's assets locked in future flash governance decisions. As a result, attackers can get their funds back even if they execute a malicious flash decision and the community burns their assets.  ## Proof of Concept  1. An attacker Alice executes a malicious flash governance decision, and her assets are locked in the `FlashGovernanceArbiter` contract. 2. The community disagrees with Alice's flash governance decision and calls `burnFlashGovernanceAsset` to burn her locked assets. However, the `burnFlashGovernanceAsset` function resets Alice's `pendingFlashDecision` to the default config (see line 134). 3. A benign user, Bob executes another flash governance decision, and his assets are locked in the contract.  4. Now, Alice calls `withdrawGovernanceAsset` to withdraw Bob's locked asset, effectively the same as stealing Bob's assets. Since Alice's `pendingFlashDecision` is reset to the default, the `unlockTime < block.timestamp` condition is fulfilled, and the withdrawal succeeds.  Referenced code: [DAO/FlashGovernanceArbiter.sol#L134](https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/FlashGovernanceArbiter.sol#L134) [DAO/FlashGovernanceArbiter.sol#L146](https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/FlashGovernanceArbiter.sol#L146)  ## Recommended Mitigation Steps  Change line 134 to `delete pendingFlashDecision[targetContract][user]` instead of setting the `pendingFlashDecision` to the default.  "}, {"title": "LP pricing formula is vulnerable to flashloan manipulation", "html_url": "https://github.com/code-423n4/2022-01-behodler-findings/issues/304", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-behodler-findings", "body": "# Handle  shw   # Vulnerability details  ## Impact  The LP pricing formula used in the `burnAsset` function of `LimboDAO` is vulnerable to flashloan manipulation. By swapping a large number of EYE into the underlying pool, an attacker can intentionally inflate the value of the LP tokens to get more `fate` than he is supposed to with a relatively low cost.  With the large portion of `fate` he gets, he has more voting power to influence the system's decisions, or even he can convert his `fate` to Flan tokens for a direct profit.  ## Proof of Concept  Below is an example of how the attack works:  1. Suppose that there are 1000 EYE and 1000 LINK tokens in the UniswapV2 LINK-EYE pool. The pool's total supply is 1000, and the attacker has 100 LP tokens. 2. If the attacker burns his LP tokens, he earns `1000 * 100/1000 * 20 = 2000` amount of `fate`. 3. Instead, the attacker swaps in 1000 EYE and gets 500 LINK from the pool (according to `x * y = k`, ignoring fees for simplicity). Now the pool contains 2000 EYE and 500 LINK tokens. 4. After the manipulation, he burns his LP tokens and gets `2000 * 100/1000 * 20 = 4000` amount of `fate`. 5. Lastly, he swaps 500 LINK into the pool to get back his 1000 EYE. 6. Compared to Step 2, the attacker earns a double amount of `fate` by only paying the swapping fees to the pool. The more EYE tokens he swaps into the pool, the more `fate` he can get. This attack is practically possible by leveraging flashloans or flashswaps from other pools containing EYE tokens.  The `setEYEBasedAssetStake` function has the same issue of using a manipulatable LP pricing formula. For more detailed explanations, please refer to the analysis of the [Cheese Bank attack](https://peckshield.medium.com/cheese-bank-incident-root-cause-analysis-d076bf87a1e7) and the [Warp Finance attack](https://peckshield.medium.com/warpfinance-incident-root-cause-analysis-581a4869ee00).  Referenced code: [DAO/LimboDAO.sol#L356](https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/LimboDAO.sol#L356) [DAO/LimboDAO.sol#L392](https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/LimboDAO.sol#L392)  ## Recommended Mitigation Steps  Use a fair pricing formula for the LP tokens, for example, the one proposed by [Alpha Finance](https://blog.alphafinance.io/fair-lp-token-pricing/).  "}, {"title": "Lack of access control on `assertGovernanceApproved` can cause funds to be locked", "html_url": "https://github.com/code-423n4/2022-01-behodler-findings/issues/300", "labels": ["bug", "3 (High Risk)", "resolved"], "target": "2022-01-behodler-findings", "body": "Lack of access control on `assertGovernanceApproved` can cause funds to be locked"}, {"title": "Lack of access control in the `parameterize` function of proposal contracts", "html_url": "https://github.com/code-423n4/2022-01-behodler-findings/issues/296", "labels": ["bug", "duplicate", "2 (Med Risk)", "resolved"], "target": "2022-01-behodler-findings", "body": "Lack of access control in the `parameterize` function of proposal contracts"}, {"title": "Gas in `TransferHelper.ERC20NetTransfer`: check if amount != 0 before transfer", "html_url": "https://github.com/code-423n4/2022-01-behodler-findings/issues/290", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-behodler-findings", "body": "Gas in `TransferHelper.ERC20NetTransfer`: check if amount != 0 before transfer"}, {"title": "use multiple require() instead of &&", "html_url": "https://github.com/code-423n4/2022-01-behodler-findings/issues/282", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor disputed"], "target": "2022-01-behodler-findings", "body": "use multiple require() instead of &&"}, {"title": "Immutable variables", "html_url": "https://github.com/code-423n4/2022-01-behodler-findings/issues/270", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-behodler-findings", "body": "Immutable variables"}, {"title": "Gas in `FlashGovernanceArbiter.enforceTolerance()`: substractions that can't underflow should be unchecked", "html_url": "https://github.com/code-423n4/2022-01-behodler-findings/issues/265", "labels": ["bug", "duplicate", "G (Gas Optimization)", "resolved"], "target": "2022-01-behodler-findings", "body": "Gas in `FlashGovernanceArbiter.enforceTolerance()`: substractions that can't underflow should be unchecked"}, {"title": "Gas in `UniswapHelper.configure()`: require statements should be reordered to save gas on revert", "html_url": "https://github.com/code-423n4/2022-01-behodler-findings/issues/256", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-behodler-findings", "body": "Gas in `UniswapHelper.configure()`: require statements should be reordered to save gas on revert"}, {"title": "Limbo, LimboDAO and FlashGovernanceArbiter events aren't indexed", "html_url": "https://github.com/code-423n4/2022-01-behodler-findings/issues/249", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2022-01-behodler-findings", "body": "# Handle  hyh   # Vulnerability details  ## Impact  No events in Limbo, LimboDAO and FlashGovernanceArbiter contracts are indexed, so their filtering is disabled, which makes it harder to programmatically use the system  ## Proof of Concept  Contract's events don't have indices:  Limbo:  https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/Limbo.sol#L253-260  FlashGovernanceArbiter:  https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/FlashGovernanceArbiter.sol#L22  LimboDAO:  https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/LimboDAO.sol#L56-61  ## Recommended Mitigation Steps  Consider adding the indices to the key parameters, first of all to the addresses of the tokens and accounts broadcasted   "}, {"title": "dai already update on constructor", "html_url": "https://github.com/code-423n4/2022-01-behodler-findings/issues/246", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-behodler-findings", "body": "dai already update on constructor"}, {"title": "Use of _msgSender()", "html_url": "https://github.com/code-423n4/2022-01-behodler-findings/issues/242", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-behodler-findings", "body": "Use of _msgSender()"}, {"title": "Consistently check account balance before and after transfers for Fee-On-Transfer discrepencies", "html_url": "https://github.com/code-423n4/2022-01-behodler-findings/issues/237", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2022-01-behodler-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact Wrong fateBalance bookkeeping for a user. Wrong fateCreated value emitted.  ## Proof of Concept Taking into account the FOT is done almost everywhere important in the solution already. That's a known practice in the solution.  However, it's missing here (see @audit-info tags): ``` File: LimboDAO.sol 383:   function burnAsset(address asset, uint256 amount) public isLive incrementFate { 384:     require(assetApproved[asset], \"LimboDAO: illegal asset\"); 385:     address sender = _msgSender(); 386:     require(ERC677(asset).transferFrom(sender, address(this), amount), \"LimboDAO: transferFailed\"); //@audit-info FOT not taken into account 387:     uint256 fateCreated = fateState[_msgSender()].fateBalance; 388:     if (asset == domainConfig.eye) { 389:       fateCreated = amount * 10; //@audit-info wrong amount due to lack of FOT calculation 390:       ERC677(domainConfig.eye).burn(amount);//@audit-info wrong amount due to lack of FOT calculation 391:     } else { 392:       uint256 actualEyeBalance = IERC20(domainConfig.eye).balanceOf(asset); 393:       require(actualEyeBalance > 0, \"LimboDAO: No EYE\"); 394:       uint256 totalSupply = IERC20(asset).totalSupply(); 395:       uint256 eyePerUnit = (actualEyeBalance * ONE) / totalSupply; 396:       uint256 impliedEye = (eyePerUnit * amount) / ONE;//@audit-info wrong amount due to lack of FOT calculation 397:       fateCreated = impliedEye * 20; 398:     } 399:     fateState[_msgSender()].fateBalance += fateCreated; //@audit-info potentially wrong fateCreated as fateCreated can be equal to amount * 10;   400:     emit assetBurnt(_msgSender(), asset, fateCreated);//@audit-info potentially wrong fateCreated emitted 401:   } ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Check the balance before and after the transfer to take into account the Fees-On-Transfer  "}, {"title": "UniswapHelper is open to manipulations on all chains whose id isn't 1", "html_url": "https://github.com/code-423n4/2022-01-behodler-findings/issues/236", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor disputed"], "target": "2022-01-behodler-findings", "body": "UniswapHelper is open to manipulations on all chains whose id isn't 1"}, {"title": "Loss of precision in `purchasePyroFlan()`", "html_url": "https://github.com/code-423n4/2022-01-behodler-findings/issues/232", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2022-01-behodler-findings", "body": "Loss of precision in `purchasePyroFlan()`"}, {"title": "Flash loan price manipulation in `purchasePyroFlan()`", "html_url": "https://github.com/code-423n4/2022-01-behodler-findings/issues/231", "labels": ["bug", "3 (High Risk)", "sponsor acknowledged"], "target": "2022-01-behodler-findings", "body": "Flash loan price manipulation in `purchasePyroFlan()`"}, {"title": "UniswapHelper.buyFlanAndBurn is a subject to sandwich attacks", "html_url": "https://github.com/code-423n4/2022-01-behodler-findings/issues/230", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-01-behodler-findings", "body": "UniswapHelper.buyFlanAndBurn is a subject to sandwich attacks"}, {"title": "Incorrect unlockTime can DOS withdrawGovernanceAsset", "html_url": "https://github.com/code-423n4/2022-01-behodler-findings/issues/228", "labels": ["bug", "duplicate", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-behodler-findings", "body": "# Handle  csanuragjain   # Vulnerability details  ## Impact unlockTime is set incorrectly  ## Proof of Concept  1. Navigate to contract at https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/FlashGovernanceArbiter.sol  2. Observe the assertGovernanceApproved function  ``` function assertGovernanceApproved(     address sender,     address target,     bool emergency   ) public { ... pendingFlashDecision[target][sender].unlockTime += block.timestamp; ... } ```  3. Assume assertGovernanceApproved is called with sender x and target y and pendingFlashDecision[target][sender].unlockTime is 100 and block.timestamp is 10000 then  ``` pendingFlashDecision[target][sender].unlockTime += block.timestamp; // 10000+100=10100 ```  4. Again assertGovernanceApproved is called with same argument after timestamp 10100. This time unlockTime is set to very high value  (assume block.timestamp is 10500). This is incorrect  ``` pendingFlashDecision[target][sender].unlockTime += block.timestamp; // 10100+10500=20600 ```  ## Recommended Mitigation Steps unlock time should be calculated like below  ``` constant public CONSTANT_UNLOCK_TIME = 1 days; // example pendingFlashDecision[target][sender].unlockTime = CONSTANT_UNLOCK_TIME +  block.timestamp; ```  "}, {"title": "Gas Optimization: Struct layout", "html_url": "https://github.com/code-423n4/2022-01-behodler-findings/issues/222", "labels": ["bug", "duplicate", "G (Gas Optimization)", "resolved"], "target": "2022-01-behodler-findings", "body": "Gas Optimization: Struct layout"}, {"title": "Gas savings", "html_url": "https://github.com/code-423n4/2022-01-behodler-findings/issues/217", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-behodler-findings", "body": "Gas savings"}, {"title": "Incorrect require statement", "html_url": "https://github.com/code-423n4/2022-01-behodler-findings/issues/213", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2022-01-behodler-findings", "body": "# Handle  csanuragjain   # Vulnerability details  ## Impact   ## Proof of Concept  1. Navigate to contract at https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/UniswapHelper.sol  2. Observe the configure function which has below require condition  ``` require(priceBoostOvershoot < 100, \"Set overshoot to number between 1 and 100.\"); ```  3. This means priceBoostOvershoot can be set to 0 which contradicts the require statement message mentioning \"Set overshoot to number between 1 and 100.\" ## Tools Used  ## Recommended Mitigation Steps Change the require condition to   ``` require(priceBoostOvershoot < 100 && priceBoostOvershoot > 0, \"Set overshoot to number between 1 and 100.\"); ```  "}, {"title": "Unstake wont work if pending reward is 0", "html_url": "https://github.com/code-423n4/2022-01-behodler-findings/issues/210", "labels": ["bug", "duplicate", "1 (Low Risk)", "resolved"], "target": "2022-01-behodler-findings", "body": "Unstake wont work if pending reward is 0"}, {"title": "Gas: \"constants\" expressions are expressions, not constants.", "html_url": "https://github.com/code-423n4/2022-01-behodler-findings/issues/197", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-behodler-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact   Due to how `constant` variables are implemented (replacements at compile-time), an expression assigned to a `constant` variable is recomputed each time that the variable is used, which wastes some gas.      See: [ethereum/solidity#9232](https://github.com/ethereum/solidity/issues/9232)  > Consequences: each usage of a \"constant\" costs ~100gas more on each access (it is still a little better than storing the result in storage, but not much..). since these are not real constants, they can't be referenced from a real constant environment (e.g. from assembly, or from another library )    ## Proof of Concept   ``` UniswapHelper.sol:56:  uint256 constant year = (1 days * 365); ```     ## Tools Used   VS Code      ## Recommended Mitigation Steps   Replace with: ``` UniswapHelper.sol:56:  uint256 constant year = 365 days; ```    "}, {"title": "Proposal cost doesn't use votingDuration", "html_url": "https://github.com/code-423n4/2022-01-behodler-findings/issues/189", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2022-01-behodler-findings", "body": "# Handle  sirhashalot   # Vulnerability details  ## Impact  The LimboDAO.sol contract allows the votingDuration to be modified in the [`setProposalConfig()` function](https://github.com/code-423n4/2022-01-behodler/blob/cedb81273f6daf2ee39ec765eef5ba74f21b2c6e/contracts/DAO/LimboDAO.sol#L302), but the `makeProposal()` function hard codes this value as two days, which is the initialized value, in the `makeProposal()` fee calculation.  ## Proof of Concept  First, observe the comment on line 209 has a comment: ``` proposalConfig.requiredFateStake = 223 * ONE; //50000 EYE for 24 hours ```  This comment indicates that the quantity of 50,000 EYE is needed for each day. The votingDuration value [is initialized to 2 days](https://github.com/code-423n4/2022-01-behodler/blob/cedb81273f6daf2ee39ec765eef5ba74f21b2c6e/contracts/DAO/LimboDAO.sol#L208). Later in the code, the \"proposalConfig.requiredFateStake\" variable is multiplied by 2. Although there is no explanation for this value, given the earlier comment that the \"proposalConfig.requiredFateStake\" value is required every day, the cost to make a proposal should vary based on the current votingDuration value:  ``` fateState[proposer].fateBalance = fateState[proposer].fateBalance - proposalConfig.requiredFateStake * 2; ```  Because a constant value of 2 is used, most likely assuming a constant 2 day votingDuration, later modifications to the votingDuration will not change the cost of making a proposal. If the votingDuration increases, the proposal cost will be less EYE per hour, and if the votingDuration decreases, the proposal cost will be more EYE per hour.  ## Recommended Mitigation Steps  One of two portions of the code is wrong and needs modification: 1. The comment about \"50000 EYE for 24 hours\" is wrong because it doesn't take into account the variability of votingDuration. Even if the comment only refers to the initialized values, it should state \"50000 EYE for 48 hours\" because the votingDuration is 2 days. 2. The `makeProposal()` function calculates the fate cost incorrectly because it never uses the votingDuration variables in its calculation.  "}, {"title": "Wrong units in `convertFateToFlan()`", "html_url": "https://github.com/code-423n4/2022-01-behodler-findings/issues/188", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2022-01-behodler-findings", "body": "# Handle  sirhashalot   # Vulnerability details  ## Impact  The `convertFateToFlan()` function in LimboDAO.sol appears to perform a calculate with improper units. The variable \"flan\" should hold a quantity of flan, but the units used in the calculation of flan don't match this. This incorrect calculation can allow users to call this function and receive much more flan than the fateToFlan exchange rate specifies.  ## Proof of Concept  The `convertFateToFlan()` function is in [the LimboDAO.sol contract](https://github.com/code-423n4/2022-01-behodler/blob/cedb81273f6daf2ee39ec765eef5ba74f21b2c6e/contracts/DAO/LimboDAO.sol#L239) ```   function convertFateToFlan(uint256 fate) public returns (uint256 flan) {     require(fateToFlan > 0, \"LimboDAO: Fate conversion to Flan disabled.\");     fateState[msg.sender].fateBalance -= fate;     flan = (fateToFlan * fate) / ONE;     Flan(domainConfig.flan).mint(msg.sender, flan);   } ```  The line where flan is calculated multiplies fateToFlan and fate. The units of fateToFlan are \"fate / flan\" while the units of fate are \"fate\". The product of the two has units \"fate^2 / flan\" as shown below: ``` fate     fate      fate ^ 2 \u2014\u2014   x         =   \u2014\u2014\u2014\u2014 flan                flan ```  ## Recommended Mitigation Steps  I see two solutions: 1. Modify the line calculating flan to `flan = fate / (fateToFlan * ONE);` 2. Either the fateToFlan value should be renamed to \"flanToFate\". This would require renaming the `setFateToFlan()` function, the comments describing the respective variable and function, and the unit tests  "}, {"title": "transferFrom gas improvement", "html_url": "https://github.com/code-423n4/2022-01-behodler-findings/issues/187", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-behodler-findings", "body": "# Handle  sirhashalot   # Vulnerability details  ## Impact  The ERC20Burnable.sol file has code copied from the OpenZeppelin ERC20.sol contract. The Behodler code `transferFrom()` function does use the latest version of the OpenZeppelin code, modified earlier in Jan 2022 in [PR 3085](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3085), which can save gas if currentAllowance == type(uint256).max.  A second gas savings that has been present in OpenZeppelin for some time but is not in the Behodler code is to add an unchecked clause around the `approve()` call.  ## Proof of Concept  The Behodler `transferFrom()` function [doesn't use the latest edits from OZ or the unchecked clause on the approve call](https://github.com/code-423n4/2022-01-behodler/blob/cedb81273f6daf2ee39ec765eef5ba74f21b2c6e/contracts/ERC677/ERC20Burnable.sol#L204-L218). In contrast, the OZ code [does use these edits for gas savings](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/4f8af2dceb0fbc36cb32eb2cc14f80c340b9022e/contracts/token/ERC20/ERC20.sol#L156-L172).  ## Recommended Mitigation Steps  Use the latest OZ edits and the unchecked clause for gas savings if it doesn't introduce overflow or underflow conditions.  "}, {"title": "Revert string > 32 bytes", "html_url": "https://github.com/code-423n4/2022-01-behodler-findings/issues/185", "labels": ["bug", "G (Gas Optimization)", "resolved"], "target": "2022-01-behodler-findings", "body": "Revert string > 32 bytes"}, {"title": "Using type(uint).max is cheaper than using calculation.", "html_url": "https://github.com/code-423n4/2022-01-behodler-findings/issues/173", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor disputed"], "target": "2022-01-behodler-findings", "body": "Using type(uint).max is cheaper than using calculation."}, {"title": "`LimboDAO.seed`: Wrong error message", "html_url": "https://github.com/code-423n4/2022-01-behodler-findings/issues/167", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2022-01-behodler-findings", "body": "# Handle  cmichel   # Vulnerability details  The error message for the `uniLPs` is still referring to `Sushi` instead of `Uniswap`  ```solidity require(UniPairLike(uniLPs[i]).factory() == uniFactory, \"LimboDAO: invalid Sushi LP\"); ```  "}, {"title": "`Limbo.sol` Does Not Implement `WithdrawERC20Proposal` Functionality", "html_url": "https://github.com/code-423n4/2022-01-behodler-findings/issues/165", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-behodler-findings", "body": "# Handle  kirk-baird   # Vulnerability details  ## Impact  The proposal contract `WithdrawERC20Proposal` allows a the DAO to withdraw ERC20 tokens to a destination the the function [withdrawERC20()](https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/Proposals/WithdrawERC20Proposal.sol#L35).  However, this function is not implemented in [Limbo.sol](https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/Limbo.sol) and thus the execution can never succeed.  ## Recommended Mitigation Steps  Consider implementing this functionality in `Limbo.sol` or deleting the proposal.  "}, {"title": "flan can't be transferred unless the flan contract has flan balance greater than the amount we want to transfer", "html_url": "https://github.com/code-423n4/2022-01-behodler-findings/issues/160", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2022-01-behodler-findings", "body": "# Handle  CertoraInc   # Vulnerability details  ## Flan.sol (`safeTransfer()` function) The flan contract must have balance (and must have more flan then we want to transfer) in order to allow flan transfers. If it doesn't have any balance, the safeTransfer, which is the only way to transfer flan, will call `_transfer()` function with `amount = 0`. It should check `address(msg.sender)`'s balance instead of `address(this)`'s balance.  ```sol function safeTransfer(address _to, uint256 _amount) external {        uint256 flanBal = balanceOf(address(this)); // the problem is in this line        uint256 flanToTransfer = _amount > flanBal ? flanBal : _amount;        _transfer(_msgSender(), _to, flanToTransfer);    } ```  "}, {"title": "Insufficient Validation of `burnFlashGovernanceAsset()` Parameters", "html_url": "https://github.com/code-423n4/2022-01-behodler-findings/issues/158", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2022-01-behodler-findings", "body": "Insufficient Validation of `burnFlashGovernanceAsset()` Parameters"}, {"title": "Burning a User's Tokens for a Flash Proposal will not Deduct Their Balance", "html_url": "https://github.com/code-423n4/2022-01-behodler-findings/issues/157", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-behodler-findings", "body": "# Handle  kirk-baird   # Vulnerability details  ## Impact  The proposal to burn a user's tokens for a flash governance proposal does not result in the user losing any funds and may in fact unlock their funds sooner.  ## Proof of Concept  The function [burnFlashGovernanceAsset()](https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/FlashGovernanceArbiter.sol#L124)  will simply overwrite the user's state with `pendingFlashDecision[targetContract][user] = flashGovernanceConfig;` as seen below.  ```   function burnFlashGovernanceAsset(     address targetContract,     address user,     address asset,     uint256 amount   ) public virtual onlySuccessfulProposal {     if (pendingFlashDecision[targetContract][user].assetBurnable) {       Burnable(asset).burn(amount);     }      pendingFlashDecision[targetContract][user] = flashGovernanceConfig;   } ```  Since `flashGovernanceConfig` is not modified in [BurnFlashStakeDeposit.execute()](https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/Proposals/BurnFlashStakeDeposit.sol#L39) the user will have `amount` set to the current config amount which is likely what they originally transferred in {assertGovernanceApproved()](https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/FlashGovernanceArbiter.sol#L60).   Furthermore, `unlockTime` will be set to the config unlock time.  The config unlock time is the length of time in seconds that proposal should lock tokens for not the future timestamp. That is unlock time may be say `7 days` rather than `now + 7 days`. As a result the check in [withdrawGovernanceAsset()](https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/FlashGovernanceArbiter.sol#L146)  `pendingFlashDecision[targetContract][msg.sender].unlockTime < block.timestamp,` will always pass unless there is a significant misconfiguration.  ## Recommended Mitigation Steps  Consider deleting the user's data (i.e. `delete pendingFlashDecision[targetContract][user]`) rather than setting it to the config. This would ensure the user cannot withraw any funds afterwards.  Alternatively, only update `pendingFlashDecision[targetContract][user].amount` to subtract the amount sent as a function parameter and leave the remaining fields untouched.  "}, {"title": "Loss Of Flash Governance Tokens If They Are Not Withdrawn Before The Next Request", "html_url": "https://github.com/code-423n4/2022-01-behodler-findings/issues/156", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-behodler-findings", "body": "# Handle  kirk-baird   # Vulnerability details  ## Impact  Users who have not called [withdrawGovernanceAsset()](https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/FlashGovernanceArbiter.sol#L142)  after  they have locked their tokens from a previous proposal (i.e. [assertGovernanceApproved](https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/FlashGovernanceArbiter.sol#L60)), will lose their tokens if [assertGovernanceApproved()](https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/FlashGovernanceArbiter.sol#L60) is called again with the same `target` and `sender`.  The `sender` will lose `pendingFlashDecision[target][sender].amount` tokens and the tokens will become unaccounted for and locked in the contract. Since the new amount is not added to the previous amount, instead the previous amount is overwritten with the new amount.  The impact of this is worsened by another vulnerability, that is [assertGovernanceApproved()](https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/FlashGovernanceArbiter.sol#L60) is a `public` function and may be called by any arbitrary user so long as the `sender` field has called `approve()` for `FlashGovernanceArbiter` on the ERC20 token. This would allow an attacker to make these tokens inaccessible for any arbitrary `sender`.  ## Proof of Concept  In [assertGovernanceApproved()](https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/FlashGovernanceArbiter.sol#L60) as seen below, the line`pendingFlashDecision[target][sender] = flashGovernanceConfig` will overwrite the previous contents. Thereby, making any previous rewards unaccounted for and inaccessible to anyone.  Note that we must wait `pendingFlashDecision[target][sender].unlockTime` between calls.  ```   function assertGovernanceApproved(     address sender,     address target,     bool emergency   ) public {     if (       IERC20(flashGovernanceConfig.asset).transferFrom(sender, address(this), flashGovernanceConfig.amount) &&       pendingFlashDecision[target][sender].unlockTime < block.timestamp     ) {       require(         emergency || (block.timestamp - security.lastFlashGovernanceAct > security.epochSize),         \"Limbo: flash governance disabled for rest of epoch\"       );       pendingFlashDecision[target][sender] = flashGovernanceConfig;       pendingFlashDecision[target][sender].unlockTime += block.timestamp;        security.lastFlashGovernanceAct = block.timestamp;       emit flashDecision(sender, flashGovernanceConfig.asset, flashGovernanceConfig.amount, target);     } else {       revert(\"LIMBO: governance decision rejected.\");     }   } ```   ## Recommended Mitigation Steps  Consider updating the initial if statement to ensure the `pendingFlashDecision` for that `target` and `sender` is empty, that is: ```   function assertGovernanceApproved(     address sender,     address target,     bool emergency   ) public {     if (       IERC20(flashGovernanceConfig.asset).transferFrom(sender, address(this), flashGovernanceConfig.amount) &&       pendingFlashDecision[target][sender].unlockTime == 0     ) { ... ```  Note we cannot simply add the new `amount` to the previous `amount` incase the underlying `asset` has been changed.  "}, {"title": "Reentrancy on Flash Governance Proposal Withdrawal", "html_url": "https://github.com/code-423n4/2022-01-behodler-findings/issues/154", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-01-behodler-findings", "body": "Reentrancy on Flash Governance Proposal Withdrawal"}, {"title": "The system can get to a \"stuck\" state if a bad proposal (proposal that can't be executed) is accepted", "html_url": "https://github.com/code-423n4/2022-01-behodler-findings/issues/153", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-behodler-findings", "body": "# Handle  CertoraInc   # Vulnerability details  ## LimboDAO.sol (`updateCurrentProposal()` modifier and `makeProposal()` function) The LimboDAO contract has a variable that indicates the current proposal - every time there can be only one proposal. The only way a proposal can be done and a new proposal can be registered is to finish the previous proposal by either accepting it and executing it or by rejecting it. If a proposal that can't succeed, like for example an `UpdateMultipleSoulConfigProposal` proposal that has too much tokens and not enough gas, will stuck the system if it will be accepted. Thats because its time will pass - the users won't be able to vote anymore (because the `vote` function will revert), and the proposal can't be executed - the `execute` function will revert. So the proposal won't be able to be done and the system will be stuck because new proposal won't be able to be registered.  When trying to call the `executeCurrentProposal()` function that activates the `updateCurrentProposal()` modifier, the modifier will check the balance of fate, it will see that it's positive and will call `currentProposalState.proposal.orchestrateExecute()` to execute the proposal. the proposal will revert and cancel it all (leaving the proposal as the current proposal with `voting` state).  When trying to call `makeProposal()` function to make a new proposal it will revert because the current proposal is not equal to address(0).  To sum up, the system can get to a \"stuck\" state if a bad proposal (proposal that can't be executed) is accepted.  "}, {"title": "not emitting `ClaimedReward` event ", "html_url": "https://github.com/code-423n4/2022-01-behodler-findings/issues/148", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2022-01-behodler-findings", "body": "# Handle  CertoraInc   # Vulnerability details  ## Limbo.sol (`_unstake()` and `stake()` functions)  not emitting the `ClaimedReward` event when the user claims his rewards (also when staking and getting the current reward, I don't know if it is done in purpose but just making sure)  "}, {"title": "user won't be able to get his rewards in case of staking with amount = 0", "html_url": "https://github.com/code-423n4/2022-01-behodler-findings/issues/146", "labels": ["bug", "question", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-behodler-findings", "body": "# Handle  CertoraInc   # Vulnerability details  ## Limbo.sol (`stake()` function) if a user has a pending reward and he call the `stake` function with `amount = 0`, he won't be able to get his reward (he won't get the reward, and the reward debt will cover the reward)  that's happening because the reward calculation is done only if the staked amount (given as a parameter) is greater than 0, and it updates the reward debt also if the amount is 0, so the reward debt will be updated without the user will be able to get his reward  "}, {"title": "inline a function (use its code) instead of calling it", "html_url": "https://github.com/code-423n4/2022-01-behodler-findings/issues/143", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-behodler-findings", "body": "inline a function (use its code) instead of calling it"}, {"title": "a not needed variable", "html_url": "https://github.com/code-423n4/2022-01-behodler-findings/issues/142", "labels": ["bug", "disagree with severity", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-behodler-findings", "body": "a not needed variable"}, {"title": "use a defined constant to save gas", "html_url": "https://github.com/code-423n4/2022-01-behodler-findings/issues/127", "labels": ["bug", "disagree with severity", "G (Gas Optimization)", "resolved", "sponsor disputed"], "target": "2022-01-behodler-findings", "body": "use a defined constant to save gas"}, {"title": "typo", "html_url": "https://github.com/code-423n4/2022-01-behodler-findings/issues/123", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2022-01-behodler-findings", "body": "typo"}, {"title": "save gas by using `if else` instead of calculating the same expression twice", "html_url": "https://github.com/code-423n4/2022-01-behodler-findings/issues/122", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-behodler-findings", "body": "save gas by using `if else` instead of calculating the same expression twice"}, {"title": "use variables indtead of array to save gas", "html_url": "https://github.com/code-423n4/2022-01-behodler-findings/issues/119", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-behodler-findings", "body": "use variables indtead of array to save gas"}, {"title": "You can flip governance decisions without extending vote duration", "html_url": "https://github.com/code-423n4/2022-01-behodler-findings/issues/106", "labels": ["bug", "question", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-behodler-findings", "body": "# Handle  camden   # Vulnerability details  ## Impact The impact here is that a user can, right at the end of the voting period, flip the decision without triggering the logic to extend the vote duration. The user doesn't even have to be very sophisticated: they can just send one vote in one transaction to go to 0, then in a subsequent transaction send enough to flip the vote.  ## Proof of Concept https://github.com/code-423n4/2022-01-behodler/blob/608cec2e297867e4d954a63fecd720e80c1d5ae8/contracts/DAO/LimboDAO.sol#L281 You can send exactly enough fate to send the fate amount to 0, then send fate to change the vote. You'll never trigger this logic.  On the first call, to send the currentProposalState.fate to 0, `(fate + currentFate) * fate == 0`, so we won't extend the proposal state.  Then, on the second call, to actually change the vote, `fate * currentFate == 0` because `currentFate` is 0.   ## Recommended Mitigation Steps Make sure that going to 0 is equivalent to a flip, but going away from 0 isn't a flip.  "}, {"title": "You can grief migrations by sending SCX to the UniswapHelper", "html_url": "https://github.com/code-423n4/2022-01-behodler-findings/issues/105", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-01-behodler-findings", "body": "You can grief migrations by sending SCX to the UniswapHelper"}, {"title": "Calling `generateFLNQuote` twice in every block prevents any migration", "html_url": "https://github.com/code-423n4/2022-01-behodler-findings/issues/102", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-behodler-findings", "body": "# Handle  camden   # Vulnerability details  # Impact and PoC https://github.com/code-423n4/2022-01-behodler/blob/71d8e0cfd9388f975d6a90dffba9b502b222bdfe/contracts/UniswapHelper.sol#L138 In the Uniswap helper, `generateFLNQuote` is public, so any user can generate the latest quote. If you call this twice in any block, then the two latest flan quotes will have a `blockProduced` value of the current block's number.  These quotes are used in the `_ensurePriceStability` function. The last require statement here is key: https://github.com/code-423n4/2022-01-behodler/blob/71d8e0cfd9388f975d6a90dffba9b502b222bdfe/contracts/UniswapHelper.sol#L283-L285  This function will revert if this statement is false: ``` localFlanQuotes[0].blockProduced - localFlanQuotes[1].blockProduced > VARS.minQuoteWaitDuration ``` Since `VARS.minQuoteWaitDuration` is a `uint256`, it is at least 0 ``` localFlanQuotes[0].blockProduced - localFlanQuotes[1].blockProduced > 0 ``` But, as we've shown above, we can create a transaction in every block that will make `localFlanQuotes[0].blockProduced - localFlanQuotes[1].blockProduced == 0`. In any block we can make any call to `_ensurePriceStability` revert.  `_ensurePriceStability` is called in the `ensurePriceStability` modifier: https://github.com/code-423n4/2022-01-behodler/blob/71d8e0cfd9388f975d6a90dffba9b502b222bdfe/contracts/UniswapHelper.sol#L70  This modifier is used in `stabilizeFlan`:  https://github.com/code-423n4/2022-01-behodler/blob/71d8e0cfd9388f975d6a90dffba9b502b222bdfe/contracts/UniswapHelper.sol#L162  Lastly, `stabilizeFlan` is used in `migrate` in `Limbo.sol` https://github.com/code-423n4/2022-01-behodler/blob/71d8e0cfd9388f975d6a90dffba9b502b222bdfe/contracts/Limbo.sol#L234  Therefore, we can grief a migration in any block. In reality, the `minQuoteWaitDuration` would be set to a much higher value than 0, making this even easier to grief for people (you only need to call `generateFLNQuote` every `minQuoteWaitDuration - 1` blocks to be safe).  # Mitigation Mitigation is to just use a time weighted oracle for uniswap.  "}, {"title": "commented debugging code", "html_url": "https://github.com/code-423n4/2022-01-behodler-findings/issues/97", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2022-01-behodler-findings", "body": "commented debugging code"}, {"title": "gas optimization by using shift operator", "html_url": "https://github.com/code-423n4/2022-01-behodler-findings/issues/95", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-behodler-findings", "body": "gas optimization by using shift operator"}, {"title": "Unnecessary if else in `UniswapHelper.configure()`", "html_url": "https://github.com/code-423n4/2022-01-behodler-findings/issues/89", "labels": ["bug", "disagree with severity", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-behodler-findings", "body": "# Handle  Ruhum   # Vulnerability details  ## Impact The if else here doesn't really do anything. Might as well just remove it: https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/UniswapHelper.sol#L132  ## Recommended Mitigation Steps `VARS.precision = precision`  "}, {"title": "Add emergency stop for specific stablecoins in `FlanBackstop`", "html_url": "https://github.com/code-423n4/2022-01-behodler-findings/issues/88", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-behodler-findings", "body": "# Handle  Ruhum   # Vulnerability details  ## Impact The recent events concerning MIM showed that stablecoins are not always worth $1. It might be worth it to add an option to stop accepting a specific stablecoin for the time being in `FlanBackstop`.  https://coinmarketcap.com/currencies/magic-internet-money/  Generally, it would allow someone to mint `PyroFlan` for cheaper than expected. Whether there are more possible attack vectors is not entirely clear to me.  I'd argue that you don't lose much by adding it.  ## Proof of Concept Currently, a backer can only be updated through a proposal which will most likely take too long: https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/FlanBackstop.sol#L63  ## Tools Used none  ## Recommended Mitigation Steps Allow pausing the use of specific backers. Using the `governanceApproved()` modifier might be good  "}, {"title": "`LimboDAO.killDAO()` doesn't update the DAO address of `FlanBackstop`, `UniswapHelper`, and `ProposalFactory`", "html_url": "https://github.com/code-423n4/2022-01-behodler-findings/issues/86", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2022-01-behodler-findings", "body": "# Handle  Ruhum   # Vulnerability details  ## Impact `LimboDAO.killDAO()` is used to assign control of the contracts to a new DAO. Currently, it only updates `Flan` & `Limbo`. But, `FlanBackstop`, `UniswapHelper`, and `ProposalFactory` also depend on the DAO. Those are not updated. The new DAO loses control over them.  ## Proof of Concept https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/LimboDAO.sol#L226  ## Tools Used none  ## Recommended Mitigation Steps Instead of calling `setDAO()` on hardcoded address, the function should allow passing an array of addresses for which `setDAO()` is called.  ```sol function killDAO(address[] calldata a, address newOwner) public onlyOwner isLive {     domainConfig.live = false;     for (uint i; i < a.length; i++) {         Governable(a[i]).setDAO(newOwner);     }     emit daoKilled(newOwner);   } ```  "}, {"title": "Remove duplicate call to save gas", "html_url": "https://github.com/code-423n4/2022-01-behodler-findings/issues/79", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-behodler-findings", "body": "# Handle  Ruhum   # Vulnerability details  ## Impact There's a duplicate call here: https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/FlanBackstop.sol#L93-L94  Remove it to reduce gas   "}, {"title": "`Governable` configuration can be backrun", "html_url": "https://github.com/code-423n4/2022-01-behodler-findings/issues/78", "labels": ["bug", "question", "1 (Low Risk)", "resolved", "sponsor disputed"], "target": "2022-01-behodler-findings", "body": "`Governable` configuration can be backrun"}, {"title": "`approveUnstake` is unsafe ", "html_url": "https://github.com/code-423n4/2022-01-behodler-findings/issues/55", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-behodler-findings", "body": "# Handle  CertoraInc   # Vulnerability details  Similar to ERC20.approve, `approveUnstake()` is unsafe due to the fact that it set the allowance to a fixed number and doesn't increase or decrease it. Usually, the `ERC20.approve` doesn't get much attention because they leave it to the user to make sure his operation is safe, however here the user cannot do it because the `unstakeApproval` state variable is private and there is no getter for it.  In `ERC20.approve` users can simply check the allowance and change it in the same transaction and eliminate the risk, but here it's impossible.  ## Impact Users will not be able to change the allowance of the unstake without the risk of the frontrunning stealing like the classic `ERC20.approve` (there the risk can be removed). This will cause users to not change allowance for users that they don't 100% trust which can be problematic  ## Proof of Concept The function that sets the allowance to a fixed number: https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/Limbo.sol#L606-L612  The private map state variable that has no getter (in solidity state variables are automatically private unless declared otherwise) https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/Limbo.sol#L288  ## Tools Used Manual code review  ## Recommended Mitigation Steps If you insist changing the allowance to a fixed number and not increase it or decrease it, at least make the allowance public so it can be checked before changing  "}, {"title": "Denial of Service in UpdateMultipleSoulConfigProposal", "html_url": "https://github.com/code-423n4/2022-01-behodler-findings/issues/52", "labels": ["bug", "duplicate", "1 (Low Risk)", "resolved"], "target": "2022-01-behodler-findings", "body": "Denial of Service in UpdateMultipleSoulConfigProposal"}, {"title": "Lack of Governance in Governable methods", "html_url": "https://github.com/code-423n4/2022-01-behodler-findings/issues/51", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor disputed"], "target": "2022-01-behodler-findings", "body": "Lack of Governance in Governable methods"}, {"title": "Gas saving removing variable", "html_url": "https://github.com/code-423n4/2022-01-behodler-findings/issues/50", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-behodler-findings", "body": "# Handle  0x1f8b   # Vulnerability details  ## Impact Detailed description of the impact of this finding.  ## Proof of Concept Removing the variable `_redeemRate` and using only the call `redeemRate()` in the method `mint` inside the contract `RebaseProxy` it`s possible to save gas. It will save gas if the case of `transferFrom` failure.  ``` function mint(address to, uint256 amount)         public         override         returns (uint256)     {         uint256 _redeemRate = redeemRate();         require(             IERC20(baseToken).transferFrom(msg.sender, address(this), amount)         );         uint256 baseBalance = IERC20(baseToken).balanceOf(address(this));         uint256 proxy = (baseBalance * ONE) / _redeemRate;         _mint(to, proxy);     } ```  ## Tools Used Manual review.  ## Recommended Mitigation Steps Remove the mentioned argument.  "}, {"title": "transfer return value of a general ERC20 is ignored", "html_url": "https://github.com/code-423n4/2022-01-behodler-findings/issues/37", "labels": ["bug", "1 (Low Risk)", "resolved"], "target": "2022-01-behodler-findings", "body": "transfer return value of a general ERC20 is ignored"}, {"title": "Two Steps Verification before Transferring Ownership", "html_url": "https://github.com/code-423n4/2022-01-behodler-findings/issues/27", "labels": ["bug", "question", "1 (Low Risk)", "sponsor acknowledged"], "target": "2022-01-behodler-findings", "body": "Two Steps Verification before Transferring Ownership"}, {"title": "Use calldata instead of memory", "html_url": "https://github.com/code-423n4/2022-01-behodler-findings/issues/22", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-behodler-findings", "body": "Use calldata instead of memory"}, {"title": "Unnecessary default assignment", "html_url": "https://github.com/code-423n4/2022-01-behodler-findings/issues/20", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-behodler-findings", "body": "Unnecessary default assignment"}, {"title": "Unnecessary constructor", "html_url": "https://github.com/code-423n4/2022-01-behodler-findings/issues/18", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-behodler-findings", "body": "Unnecessary constructor"}, {"title": "Use != 0 instead of > 0", "html_url": "https://github.com/code-423n4/2022-01-behodler-findings/issues/15", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-behodler-findings", "body": "Use != 0 instead of > 0"}, {"title": "Caching array length can save gas", "html_url": "https://github.com/code-423n4/2022-01-behodler-findings/issues/12", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-behodler-findings", "body": "Caching array length can save gas"}, {"title": "Prefix increments are cheaper than postfix increments", "html_url": "https://github.com/code-423n4/2022-01-behodler-findings/issues/10", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-behodler-findings", "body": "Prefix increments are cheaper than postfix increments"}, {"title": "Unused imports", "html_url": "https://github.com/code-423n4/2022-01-behodler-findings/issues/2", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor disputed"], "target": "2022-01-behodler-findings", "body": "Unused imports"}, {"title": "Users Can Game `sNOTE` Minting If Buybacks Occur Infrequently", "html_url": "https://github.com/code-423n4/2022-01-notional-findings/issues/231", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2022-01-notional-findings", "body": "Users Can Game `sNOTE` Minting If Buybacks Occur Infrequently"}, {"title": "A Malicious Treasury Manager Can Burn Treasury Tokens By Setting `makerFee` To The Amount The Maker Receives", "html_url": "https://github.com/code-423n4/2022-01-notional-findings/issues/230", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-01-notional-findings", "body": "# Handle  leastwood   # Vulnerability details  ## Impact  The treasury manager contract holds harvested assets/`COMP` from Notional which are used to perform `NOTE` buybacks or in other areas of the protocol. The manager account is allowed to sign off-chain orders used on 0x to exchange tokens to `WETH` which can then be deposited in the Balancer LP and distributed to `sNOTE` holders.  However, `_validateOrder` does not validate that `takerFee` and `makerFee` are set to zero, hence, it is possible for a malicious manager to receive tokens as part of a swap, but the treasury manager contract receives zero tokens as `makerFee` is set to the amount the maker receives. This can be abused to effectively burn treasury tokens at no cost to the order taker.  ## Proof of Concept  https://github.com/0xProject/0x-monorepo/blob/0571244e9e84b9ad778bccb99b837dd6f9baaf6e/contracts/exchange/contracts/src/MixinExchangeCore.sol#L196-L250  https://github.com/0xProject/0x-monorepo/blob/0571244e9e84b9ad778bccb99b837dd6f9baaf6e/contracts/exchange-libs/contracts/src/LibFillResults.sol#L59-L91  https://github.com/code-423n4/2022-01-notional/blob/main/contracts/utils/EIP1271Wallet.sol#L147-L188 ``` function _validateOrder(bytes memory order) private view {     (         address makerToken,         address takerToken,         address feeRecipient,         uint256 makerAmount,         uint256 takerAmount     ) = _extractOrderInfo(order);      // No fee recipient allowed     require(feeRecipient == address(0), \"no fee recipient allowed\");      // MakerToken should never be WETH     require(makerToken != address(WETH), \"maker token must not be WETH\");      // TakerToken (proceeds) should always be WETH     require(takerToken == address(WETH), \"taker token must be WETH\");      address priceOracle = priceOracles[makerToken];      // Price oracle not defined     require(priceOracle != address(0), \"price oracle not defined\");      uint256 slippageLimit = slippageLimits[makerToken];      // Slippage limit not defined     require(slippageLimit != 0, \"slippage limit not defined\");      uint256 oraclePrice = _toUint(         AggregatorV2V3Interface(priceOracle).latestAnswer()     );      uint256 priceFloor = (oraclePrice * slippageLimit) /         SLIPPAGE_LIMIT_PRECISION;      uint256 makerDecimals = 10**ERC20(makerToken).decimals();      // makerPrice = takerAmount / makerAmount     uint256 makerPrice = (takerAmount * makerDecimals) / makerAmount;      require(makerPrice >= priceFloor, \"slippage is too high\"); } ```  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider checking that `makerFee == 0` and `takerFee == 0` in `EIP1271Wallet._validateOrder` s.t. the treasury manager cannot sign unfair orders which severely impact the `TreasuryManager` contract.  "}, {"title": "`sNOTE` Holders Are Not Incetivized To Vote On Proposals To Call `extractTokensForCollateralShortfall`", "html_url": "https://github.com/code-423n4/2022-01-notional-findings/issues/229", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-01-notional-findings", "body": "`sNOTE` Holders Are Not Incetivized To Vote On Proposals To Call `extractTokensForCollateralShortfall`"}, {"title": "Prefix (`++i`), rather than postfix (`i++`), increment/decrement operators should be used in for-loops", "html_url": "https://github.com/code-423n4/2022-01-notional-findings/issues/228", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-notional-findings", "body": "# Handle  IllIllI   # Vulnerability details  ## Impact When the value of the post-loop increment/decrement is not stored or used in any calculations, the prefix increment/decrement operators (`++i`/`--i`) cost less gas PER LOOP than the postfix increment/decrement operators (`i++`/`i--`)  ## Proof of Concept There is one example of this issue in the codebase:  ```Solidity for (uint256 i; i < currencies.length; i++) {         ``` https://github.com/code-423n4/2022-01-notional/blob/main/contracts/TreasuryAction.sol#L157   ## Tools Used Code inspection  ## Recommended Mitigation Steps Use `++i` rather than `i++` in all places  "}, {"title": "`extractTokensForCollateralShortfall` Can Be Frontrun By Non-Stakers", "html_url": "https://github.com/code-423n4/2022-01-notional-findings/issues/227", "labels": ["bug", "1 (Low Risk)", "sponsor disputed"], "target": "2022-01-notional-findings", "body": "`extractTokensForCollateralShortfall` Can Be Frontrun By Non-Stakers"}, {"title": "Improper Contract Upgrades Can Lead To Loss Of Contract Ownership", "html_url": "https://github.com/code-423n4/2022-01-notional-findings/issues/223", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2022-01-notional-findings", "body": "Improper Contract Upgrades Can Lead To Loss Of Contract Ownership"}, {"title": "`getVotingPower` Truncates Result Leading To Inaccuracies In Voting Power", "html_url": "https://github.com/code-423n4/2022-01-notional-findings/issues/222", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2022-01-notional-findings", "body": "# Handle  leastwood   # Vulnerability details  ## Impact  The `getVotingPower` function is an essential part of Notional's on-chain governance. However, the `priceRatio` calculation includes a division which slightly truncates the result which is then used in calculating `noteAmount` which also divides the result.  ## Proof of Concept  https://github.com/code-423n4/2022-01-notional/blob/main/contracts/sNOTE.sol#L271-L293 ``` function getVotingPower(uint256 sNOTEAmount) public view returns (uint256) {     // Gets the BPT token price (in ETH)     uint256 bptPrice = IPriceOracle(address(BALANCER_POOL_TOKEN)).getLatest(IPriceOracle.Variable.BPT_PRICE);     // Gets the NOTE token price (in ETH)     uint256 notePrice = IPriceOracle(address(BALANCER_POOL_TOKEN)).getLatest(IPriceOracle.Variable.PAIR_PRICE);          // Since both bptPrice and notePrice are denominated in ETH, we can use     // this formula to calculate noteAmount     // bptBalance * bptPrice = notePrice * noteAmount     // noteAmount = bptPrice/notePrice * bptBalance     uint256 priceRatio = bptPrice * 1e18 / notePrice;     uint256 bptBalance = BALANCER_POOL_TOKEN.balanceOf(address(this));      // Amount_note = Price_NOTE_per_BPT * BPT_supply * 80% (80/20 pool)     uint256 noteAmount = priceRatio * bptBalance * 80 / 100;      // Reduce precision down to 1e8 (NOTE token)     // priceRatio and bptBalance are both 1e18 (1e36 total)     // we divide by 1e28 to get to 1e8     noteAmount /= 1e28;      return (noteAmount * sNOTEAmount) / totalSupply(); } ```  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider performing all multiplication before division to minimise the degree of truncation by the final result.  "}, {"title": "Double _requireAccountNotInCoolDown", "html_url": "https://github.com/code-423n4/2022-01-notional-findings/issues/214", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-notional-findings", "body": "# Handle  Tomio   # Vulnerability details  ## Impact The check to make sure account is not in cool down is happening twice, on _mint() and _beforeTokenTransfer(), _beforeTokenTransfer() already has a _requireAccountNotInCoolDown() an the _mint() inside erc20upgradable will call the _beforeTokenTransfer(), this can make unnecessary call in the https://github.com/code-423n4/2022-01-notional/blob/main/contracts/sNOTE.sol#L328.  ## Proof of Concept https://github.com/code-423n4/2022-01-notional/blob/main/contracts/sNOTE.sol#L328.  ## Tools Used  ## Recommended Mitigation Steps  "}, {"title": "Optimization on _redeemAndTransfer", "html_url": "https://github.com/code-423n4/2022-01-notional-findings/issues/213", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-notional-findings", "body": "# Handle  Tomio   # Vulnerability details  ## Impact There is unnecessary if else condition on _redeemAndTransfer(), and can be optimized by removing the inline if else condition on line https://github.com/code-423n4/2022-01-notional/blob/main/contracts/TreasuryAction.sol#L137-L140  ## Proof of Concept https://github.com/code-423n4/2022-01-notional/blob/main/contracts/TreasuryAction.sol#L137-L140  ## Tools Used  ## Recommended Mitigation Steps From: ```     if (underlying.tokenAddress == address(0)) {             WETH9(WETH).deposit{value: address(this).balance}();         }          address underlyingAddress = underlying.tokenAddress == address(0)             ? address(WETH)             : underlying.tokenAddress;         IERC20(underlyingAddress).safeTransfer(treasuryManagerContract, redeemedExternalUnderlying); ```  To: ```     if (underlying.tokenAddress == address(0)) {             WETH9(WETH).deposit{value: address(this).balance}();             IERC20(WETH).safeTransfer(treasuryManagerContract, redeemedExternalUnderlying);         }else{             IERC20(underlying.tokenAddress).safeTransfer(treasuryManagerContract, redeemedExternalUnderlying);         } ```  "}, {"title": "considered changing it to storage ", "html_url": "https://github.com/code-423n4/2022-01-notional-findings/issues/210", "labels": ["bug", "G (Gas Optimization)", "sponsor disputed"], "target": "2022-01-notional-findings", "body": "considered changing it to storage "}, {"title": "MAX_SHORTFALL_WITHDRAW limit on BTP extraction is not enforced", "html_url": "https://github.com/code-423n4/2022-01-notional-findings/issues/209", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-01-notional-findings", "body": "# Handle  gellej   # Vulnerability details  ## Impact   The function `extractTokensForCollateralShortfall()` allows the owner of the sNote contract to withdraw up to 50% of the total amount of BPT.   Presumably, this 50% limit is in place to prevent the owner from \"rug-pulling\" the sNote holders (or at least to give them a guarantee that their loss is limited to 50% of the underlying value).   However, this limit is easily circumvented as the function can simply be called a second, third and fourth time, to withdraw almost all of the BPT.   As the contract does not enforce this limit, the bug requires stakers to trust the governance to not withdraw more than 50% of the underlying collateral. This represents a higher risk for the stakers, which may  also result in a larger discount on sNote wrt its BPT collateral (this is why I classified the bug as medium risk - users may lose value - not from an exploit, but from the lack of enforcing the 50% rule)  # Proof of Concept  See above. The code affected is here: https://github.com/code-423n4/2022-01-notional/blob/main/contracts/sNOTE.sol#L100    ## Recommended Mitigation Steps  Rewrite the logic and enforce a limit during a time period - i.e. do not allow to withdraw over 50% _per week_ (or any time period that is longer than the cooldown period, so that users have time to withdraw their collateral)  "}, {"title": "Unused state variables", "html_url": "https://github.com/code-423n4/2022-01-notional-findings/issues/204", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-notional-findings", "body": "Unused state variables"}, {"title": "Inclusive conditions", "html_url": "https://github.com/code-423n4/2022-01-notional-findings/issues/202", "labels": ["bug", "0 (Non-critical)"], "target": "2022-01-notional-findings", "body": "Inclusive conditions"}, {"title": "Gas: `reserveInternal.subNoNeg(bufferInternal)` can be unchecked", "html_url": "https://github.com/code-423n4/2022-01-notional-findings/issues/199", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-notional-findings", "body": "# Handle  cmichel   # Vulnerability details  The `reserveInternal.subNoNeg(bufferInternal)` computation in `TreasuryAction.transferReserveToTreasury` can be a standard, unchecked subtraction as `if (reserveInternal <= bufferInternal) continue;` is checked before this computation.   "}, {"title": "`makerPrice` assumes oracle price is always in 18 decimals", "html_url": "https://github.com/code-423n4/2022-01-notional-findings/issues/198", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2022-01-notional-findings", "body": "# Handle  cmichel   # Vulnerability details  The `EIP1271Wallet._validateOrder` function computes a `makerPrice` which ends up in `takerAmount` decimals which are 18 decimals as `takerToken` is always `WETH`. It is compared to the `priceFloor` return value from chainlink which must therefore also be in 18 decimals. This seems to be the case for this old deprecated API but should be fixed and adjusted to use the oracle decimals if Chainlink is upgraded to the new API.  ## Recommended Mitigation Steps Upgrade and adjust the decimals of `makerPrice` to match `priceFloor` decimals.   "}, {"title": "Usage of deprecated ChainLink API in `EIP1271Wallet`", "html_url": "https://github.com/code-423n4/2022-01-notional-findings/issues/197", "labels": ["bug", "2 (Med Risk)"], "target": "2022-01-notional-findings", "body": "Usage of deprecated ChainLink API in `EIP1271Wallet`"}, {"title": "`StorageId` enums may never be shuffled", "html_url": "https://github.com/code-423n4/2022-01-notional-findings/issues/196", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2022-01-notional-findings", "body": "`StorageId` enums may never be shuffled"}, {"title": "Missing parameter validation", "html_url": "https://github.com/code-423n4/2022-01-notional-findings/issues/195", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2022-01-notional-findings", "body": "Missing parameter validation"}, {"title": "Treasury cannot claim COMP tokens & COMP tokens are stuck", "html_url": "https://github.com/code-423n4/2022-01-notional-findings/issues/192", "labels": ["bug", "3 (High Risk)", "disagree with severity"], "target": "2022-01-notional-findings", "body": "Treasury cannot claim COMP tokens & COMP tokens are stuck"}, {"title": "No upper limit check on swap fee Percentage", "html_url": "https://github.com/code-423n4/2022-01-notional-findings/issues/182", "labels": ["bug", "1 (Low Risk)", "disagree with severity"], "target": "2022-01-notional-findings", "body": "No upper limit check on swap fee Percentage"}, {"title": "`sNOTE.sol#_mintFromAssets()` Lack of slippage control", "html_url": "https://github.com/code-423n4/2022-01-notional-findings/issues/181", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-01-notional-findings", "body": "# Handle  WatchPug   # Vulnerability details  ttps://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/sNOTE.sol#L195-L209  ```solidity BALANCER_VAULT.joinPool{value: msgValue}(     NOTE_ETH_POOL_ID,     address(this),     address(this), // sNOTE will receive the BPT     IVault.JoinPoolRequest(         assets,         maxAmountsIn,         abi.encode(             IVault.JoinKind.EXACT_TOKENS_IN_FOR_BPT_OUT,             maxAmountsIn,             0 // Accept however much BPT the pool will give us         ),         false // Don't use internal balances     ) ); ```  The current implementation of `mintFromNOTE()` and `mintFromETH()` and `mintFromWETH()` (all are using `_mintFromAssets()` with `minimumBPT` hardcoded to `0`) provides no parameter for slippage control, making it vulnerable to front-run attacks.  ### Recommendation  Consider adding a `minAmountOut` parameter for these functions.  "}, {"title": "Multiple Missing zero address checks ", "html_url": "https://github.com/code-423n4/2022-01-notional-findings/issues/174", "labels": ["bug", "0 (Non-critical)", "disagree with severity"], "target": "2022-01-notional-findings", "body": "Multiple Missing zero address checks "}, {"title": "Missing validation check in totalSupply()", "html_url": "https://github.com/code-423n4/2022-01-notional-findings/issues/170", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2022-01-notional-findings", "body": "# Handle  SolidityScan   # Vulnerability details  ## Description The value of `totalSupply()` at https://github.com/code-423n4/2022-01-notional/blob/main/contracts/sNOTE.sol#L260 does not check if the value of totalSupply is 0 or not and it is per   ## Impact The return value for the function `getPoolTokenShare` can be invalid because if there's an error in the `totalSupply()` the code at Line 260 will evaluate to divide by zero creating inconsistencies in the function logic.   ## Proof of Concept 1. Check the function at https://github.com/code-423n4/2022-01-notional/blob/main/contracts/sNOTE.sol#L257-L261 2. At line 260 we will notice that the value of totalSupply() is directly being used to perform division to the multiplication of `bptBalance * sNOTEAmount`   ## Recommended Mitigation Steps Add a check if the value of `totalSupply()` is zero or not or some other edge cases that can cause inconsistencies.   "}, {"title": "`getVotingPower` Is Not Equipped To Handle On-Chain Voting", "html_url": "https://github.com/code-423n4/2022-01-notional-findings/issues/165", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-01-notional-findings", "body": "# Handle  leastwood   # Vulnerability details  ## Impact  As `NOTE` continues to be staked in the `sNOTE` contract, it is important that Notional's governance is able to correctly handle on-chain voting by calculating the relative power `sNOTE` has in terms of its equivalent `NOTE` amount.   `getVotingPower` is a useful function in tracking the relative voting power a staker has, however, it does not utilise any checkpointing mechanism to ensure the user's voting power is a snapshot of a specific block number. As a result, it would be possible to manipulate a user's voting power by casting a vote on-chain and then have them transfer their `sNOTE` to another account to then vote again.  ## Proof of Concept  https://github.com/code-423n4/2022-01-notional/blob/main/contracts/sNOTE.sol#L271-L293 ``` function getVotingPower(uint256 sNOTEAmount) public view returns (uint256) {     // Gets the BPT token price (in ETH)     uint256 bptPrice = IPriceOracle(address(BALANCER_POOL_TOKEN)).getLatest(IPriceOracle.Variable.BPT_PRICE);     // Gets the NOTE token price (in ETH)     uint256 notePrice = IPriceOracle(address(BALANCER_POOL_TOKEN)).getLatest(IPriceOracle.Variable.PAIR_PRICE);          // Since both bptPrice and notePrice are denominated in ETH, we can use     // this formula to calculate noteAmount     // bptBalance * bptPrice = notePrice * noteAmount     // noteAmount = bptPrice/notePrice * bptBalance     uint256 priceRatio = bptPrice * 1e18 / notePrice;     uint256 bptBalance = BALANCER_POOL_TOKEN.balanceOf(address(this));      // Amount_note = Price_NOTE_per_BPT * BPT_supply * 80% (80/20 pool)     uint256 noteAmount = priceRatio * bptBalance * 80 / 100;      // Reduce precision down to 1e8 (NOTE token)     // priceRatio and bptBalance are both 1e18 (1e36 total)     // we divide by 1e28 to get to 1e8     noteAmount /= 1e28;      return (noteAmount * sNOTEAmount) / totalSupply(); } ```  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider implementing a `getPriorVotingPower` function which takes in a `blockNumber` argument and returns the correct balance at that specific block.  "}, {"title": "Gas Optimization: Unnecessary comparison", "html_url": "https://github.com/code-423n4/2022-01-notional-findings/issues/161", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-notional-findings", "body": "# Handle  gzeon   # Vulnerability details  ## Impact In `_requireAccountNotInCoolDown` if `block.timestamp < coolDown.redeemWindowEnd`, we must have `coolDown.redeemWindowEnd > 0` hence `0 < coolDown.redeemWindowBegin`  https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/sNOTE.sol#L308 ```         bool isInCoolDown = (0 < coolDown.redeemWindowBegin && block.timestamp < coolDown.redeemWindowEnd);         require(!isInCoolDown, \"Account in Cool Down\"); ``` to  ```         require(block.timestamp >= coolDown.redeemWindowEnd, \"Account in Cool Down\"); ```  "}, {"title": "`_validateOrder` Does Not Allow Anyone To Be A Taker Of An Off-Chain Order", "html_url": "https://github.com/code-423n4/2022-01-notional-findings/issues/152", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-01-notional-findings", "body": "# Handle  leastwood   # Vulnerability details  ## Impact  The `EIP1271Wallet` contract intends to allow the treasury manager account to sign off-chain orders in 0x on behalf of the `TreasuryManager` contract, which holds harvested assets/`COMP` from Notional. While the `EIP1271Wallet._validateOrder` function mostly prevents the treasury manager from exploiting these orders, it does not ensure that the `takerAddress` and `senderAddress` are set to the zero address. As a result, it is possible for the manager to have sole rights to an off-chain order and due to the flexibility in `makerPrice`, the manager is able to extract value from the treasury by maximising the allowed slippage.  By setting `takerAddress` to the zero address, any user can be the taker of an off-chain order. By setting `senderAddress` to the zero address, anyone is allowed to access the exchange methods that interact with the order, including filling the order itself. Hence, these two order addresses can be manipulated by the manager to effectively restrict order trades to themselves.  ## Proof of Concept  https://github.com/0xProject/0x-monorepo/blob/0571244e9e84b9ad778bccb99b837dd6f9baaf6e/contracts/exchange-libs/contracts/src/LibOrder.sol#L66 ``` address takerAddress;           // Address that is allowed to fill the order. If set to 0, any address is allowed to fill the order. ```  https://github.com/0xProject/0x-monorepo/blob/0571244e9e84b9ad778bccb99b837dd6f9baaf6e/contracts/exchange/contracts/src/MixinExchangeCore.sol#L196-L250  https://github.com/0xProject/0x-monorepo/blob/0571244e9e84b9ad778bccb99b837dd6f9baaf6e/contracts/exchange/contracts/src/MixinExchangeCore.sol#L354-L374   https://github.com/code-423n4/2022-01-notional/blob/main/contracts/utils/EIP1271Wallet.sol#L147-L188 ``` function _validateOrder(bytes memory order) private view {     (         address makerToken,         address takerToken,         address feeRecipient,         uint256 makerAmount,         uint256 takerAmount     ) = _extractOrderInfo(order);      // No fee recipient allowed     require(feeRecipient == address(0), \"no fee recipient allowed\");      // MakerToken should never be WETH     require(makerToken != address(WETH), \"maker token must not be WETH\");      // TakerToken (proceeds) should always be WETH     require(takerToken == address(WETH), \"taker token must be WETH\");      address priceOracle = priceOracles[makerToken];      // Price oracle not defined     require(priceOracle != address(0), \"price oracle not defined\");      uint256 slippageLimit = slippageLimits[makerToken];      // Slippage limit not defined     require(slippageLimit != 0, \"slippage limit not defined\");      uint256 oraclePrice = _toUint(         AggregatorV2V3Interface(priceOracle).latestAnswer()     );      uint256 priceFloor = (oraclePrice * slippageLimit) /         SLIPPAGE_LIMIT_PRECISION;      uint256 makerDecimals = 10**ERC20(makerToken).decimals();      // makerPrice = takerAmount / makerAmount     uint256 makerPrice = (takerAmount * makerDecimals) / makerAmount;      require(makerPrice >= priceFloor, \"slippage is too high\"); } ```  ## Tools Used  Manual code review. Discussions with Notional team.  ## Recommended Mitigation Steps  Consider adding `require(takerAddress == address(0), \"manager cannot set taker\");` and `require(senderAddress == address(0), \"manager cannot set sender\");` statements to `_validateOrder`. This should allow any user to fill an order and prevent the manager from restricting exchange methods to themselves.  "}, {"title": "Oracle Time Interval Is Small", "html_url": "https://github.com/code-423n4/2022-01-notional-findings/issues/150", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2022-01-notional-findings", "body": "Oracle Time Interval Is Small"}, {"title": "TreasuryManager and sNOTE events aren't indexed", "html_url": "https://github.com/code-423n4/2022-01-notional-findings/issues/131", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2022-01-notional-findings", "body": "# Handle  hyh   # Vulnerability details    ## Impact  No events in TreasuryManager and sNOTE contracts are indexed, so their filtering is disabled, which makes it harder to programmatically use the system  ## Proof of Concept  TreasuryManager events don't have indices:  https://github.com/code-423n4/2022-01-notional/blob/main/contracts/TreasuryManager.sol#L38-41  sNOTE events also aren't indexed:  https://github.com/code-423n4/2022-01-notional/blob/main/contracts/sNOTE.sol#L43-50  ## Recommended Mitigation Steps  Consider adding the indices to the key parameters, first of all owner and account addresses   "}, {"title": "Gas in `TreasuryManager.sol`: Inline function `_investWETHToBuyNOTE()`", "html_url": "https://github.com/code-423n4/2022-01-notional-findings/issues/129", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-notional-findings", "body": "# Handle  Dravee   # Vulnerability details  Here's the only `_investWETHToBuyNOTE()` call: ``` File: TreasuryManager.sol 140:     function investWETHToBuyNOTE(uint256 wethAmount) external onlyManager { 141:         _investWETHToBuyNOTE(wethAmount); 142:     } ```  While I can understand why some functions have the same style, these other functions are as such because they are calling an inherited function, as an example for `setSlippageLimit()`, which really is calling an inherited function from `EIP1271Wallet.sol`: ``` File: TreasuryManager.sol 89:     function setSlippageLimit(address tokenAddress, uint256 slippageLimit) 90:         external 91:         onlyOwner 92:     { 93:         _setSlippageLimit(tokenAddress, slippageLimit); 94:     } ```  However, for `_investWETHToBuyNOTE()`, this style doesn't hold.   ## Recommended Mitigation Steps All the logic from `_investWETHToBuyNOTE()` should be inlined in `investWETHToBuyNOTE()` to save gas.  "}, {"title": "Gas in `Bitmap.sol:getMSB()`: unnecessary arithmetic operation", "html_url": "https://github.com/code-423n4/2022-01-notional-findings/issues/128", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-notional-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact Increased gas cost due to unnecessary arithmetic operation  ## Proof of Concept See the @audit-info tag: ``` File: Bitmap.sol 46:     function getMSB(uint256 x) internal pure returns (uint256 msb) { 47:         // If x == 0 then there is no MSB and this method will return zero. That would 48:         // be the same as the return value when x == 1 (MSB is zero indexed), so instead 49:         // we have this require here to ensure that the values don't get mixed up. 50:         require(x != 0); // dev: get msb zero value 51:         if (x >= 0x100000000000000000000000000000000) { 52:             x >>= 128; 53:             msb += 128; //@audit-info this one and only can be replaced with =  54:         } 55:         if (x >= 0x10000000000000000) { 56:             x >>= 64; 57:             msb += 64; 58:         } 59:         if (x >= 0x100000000) { 60:             x >>= 32; 61:             msb += 32; 62:         } 63:         if (x >= 0x10000) { 64:             x >>= 16; 65:             msb += 16; 66:         } 67:         if (x >= 0x100) { 68:             x >>= 8; 69:             msb += 8; 70:         } 71:         if (x >= 0x10) { 72:             x >>= 4; 73:             msb += 4; 74:         } 75:         if (x >= 0x4) { 76:             x >>= 2; 77:             msb += 2; 78:         } 79:         if (x >= 0x2) msb += 1; // No need to shift xc anymore 80:     } ```  ## Tools Used VS Code  ## Recommended Mitigation Steps On line 53, and only there, it is absolutely certain that `+=` can be replaced with `=`, which would look like this: ``` 53:             msb = 128; ```  "}, {"title": "`BalanceHandler.sol:getBalanceStorage()`: `store` is used only once and shouldn't get cached", "html_url": "https://github.com/code-423n4/2022-01-notional-findings/issues/125", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-notional-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact Increased gas cost  ## Proof of Concept `store` is a variable used only once. A comment should suffice instead of a variable (see @audit-info): ``` File: BalanceHandler.sol 72:         mapping(address => mapping(uint256 => BalanceStorage)) storage store = LibStorage.getBalanceStorage(); //@audit-info store is used only once, below 73:         BalanceStorage storage balanceStorage = store[account][currencyId]; ``` ## Tools Used VS Code  ## Recommended Mitigation Steps Do not store this data in a variable. Inline it instead: ``` BalanceStorage storage balanceStorage = LibStorage.getBalanceStorage()[account][currencyId]; ```    "}, {"title": "`approve()` return value not checked", "html_url": "https://github.com/code-423n4/2022-01-notional-findings/issues/115", "labels": ["bug", "0 (Non-critical)"], "target": "2022-01-notional-findings", "body": "`approve()` return value not checked"}, {"title": "Remove unnecessary super._beforeTokenTransfer()", "html_url": "https://github.com/code-423n4/2022-01-notional-findings/issues/112", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-notional-findings", "body": "# Handle  sirhashalot   # Vulnerability details  ## Impact  The sNOTE.sol `_beforeTokenTransfer()` function overrides the ERC20 `_beforeTokenTransfer()` function, but also calls `super._beforeTokenTransfer()`. This call to the parent function is unnecessary because no actions are performed, so it can be removed to save gas. This function call is probably placed here for consistency with the `_afterTokenTransfer()` function, but it is unnecessary with the current code (unlike the call in the `_afterTokenTransfer()` function)  ## Proof of Concept  [Line 374 of sNOTE.sol](https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/sNOTE.sol#L374) calls super._beforeTokenTransfer(), which does not need to be called because it performs no actions.  ## Recommended Mitigation Steps  Remove line 374 from sNOTE.sol to remove the `super._beforeTokenTransfer()` call   "}, {"title": "`TreasuryAction.sol:transferReserveToTreasury()`: Missing @return comment ", "html_url": "https://github.com/code-423n4/2022-01-notional-findings/issues/111", "labels": ["bug", "0 (Non-critical)", "disagree with severity"], "target": "2022-01-notional-findings", "body": "`TreasuryAction.sol:transferReserveToTreasury()`: Missing @return comment "}, {"title": "Revert string > 32 bytes", "html_url": "https://github.com/code-423n4/2022-01-notional-findings/issues/110", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-notional-findings", "body": "Revert string > 32 bytes"}, {"title": "`TreasuryAction.sol`:`modifier onlyOwner()`'s revert message is confusing", "html_url": "https://github.com/code-423n4/2022-01-notional-findings/issues/106", "labels": ["bug", "0 (Non-critical)", "disagree with severity"], "target": "2022-01-notional-findings", "body": "`TreasuryAction.sol`:`modifier onlyOwner()`'s revert message is confusing"}, {"title": "setReserveCashBalance can only set less reserves", "html_url": "https://github.com/code-423n4/2022-01-notional-findings/issues/103", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2022-01-notional-findings", "body": "# Handle  GeekyLumberjack   # Vulnerability details  ## Impact There is a fairly decent chance that setReserveCashBalance will mistakenly be set too low. Unlike the case for addresses, the number required is more likely to be manually typed. This will lead to higher chance of a mistype causing unusable reserves. With some functions risks like these are unavoidable. However, in this case, the actions are already performed with a trusted party.  ## Proof of Concept 1. call [setReserveCashBalance()](https://github.com/code-423n4/2022-01-notional/blob/main/contracts/TreasuryAction.sol#L80-L91) with the newBalance parameter set to 1. 2. call setReserveCashBalance() with newBalance parameter set to 100. 3. balanceStorage.cashBalance will still be set to 1. Step 2 would have reverted due to `require(newBalance < reserveBalance, \"cannot increase reserve balance\");`  ## Tools Used Manual Analysis  ## Recommended Mitigation Step Consider removing `require(newBalance < reserveBalance, \"cannot increase reserve balance\");`  https://github.com/code-423n4/2022-01-notional/blob/main/contracts/TreasuryAction.sol#L88   "}, {"title": "Gas: When a function use the `onlyOwner` modifier, use `msg.sender` instead of `owner`", "html_url": "https://github.com/code-423n4/2022-01-notional-findings/issues/97", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-notional-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact `msg.sender` costs 2 gas (CALLER opcode) `owner` costs 100 gas (SLOAD opcode) The `onlyOwner` modifier already checks that `msg.sender == owner`.  ## Proof of Concept Instances include: ``` contracts\\sNOTE.sol:118:            payable(owner), // Owner will receive the NOTE and WETH contracts\\TreasuryManager.sol:108:        IERC20(token).safeTransfer(owner, amount); ```  ## Tools Used VS Code  ## Recommended Mitigation Steps When a function use the `onlyOwner` modifier, use `msg.sender` instead of `owner`  "}, {"title": "Gas: Places where both the `return` statement and a named `returns` are used", "html_url": "https://github.com/code-423n4/2022-01-notional-findings/issues/95", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-01-notional-findings", "body": "Gas: Places where both the `return` statement and a named `returns` are used"}, {"title": "Gas: Missing checks for non-zero transfer value calls", "html_url": "https://github.com/code-423n4/2022-01-notional-findings/issues/94", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-notional-findings", "body": "Gas: Missing checks for non-zero transfer value calls"}, {"title": "Consider making contracts Pausable", "html_url": "https://github.com/code-423n4/2022-01-notional-findings/issues/90", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2022-01-notional-findings", "body": "Consider making contracts Pausable"}, {"title": "Gas: Use Custom Errors instead of Revert Strings to save Gas", "html_url": "https://github.com/code-423n4/2022-01-notional-findings/issues/86", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-notional-findings", "body": "Gas: Use Custom Errors instead of Revert Strings to save Gas"}, {"title": "Conversions between sNOTE and BPT when burning cause less sNOTE to be burned than expected", "html_url": "https://github.com/code-423n4/2022-01-notional-findings/issues/71", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2022-01-notional-findings", "body": "# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact  `sNOTE.redeem` burns an amount of sNOTE other than `sNOTEAmount`, potentially giving a better rate to redeemers than it should.  ## Proof of Concept  Following the process of burning sNOTE for BPT:  https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/sNOTE.sol#L238-L252  1. We pass an amount of sNOTE to burn which is converted into BPT. (L248)  https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/sNOTE.sol#L315-L323  2. We calculate the what fraction of the total amount of BPT this user is entitled to this amount of BPT represents and then multiply that by their balance of sNOTE (L320)  Rather than burning `sNOTEAmount` we then end up burning   ``` realSNOTEAmount = balanceOf(account) * getPoolTokenShare(sNOTEAmount) / getPoolTokenShare(balanceOf(account)) ```  This looks to round down such that we end up burning less sNOTE than expected. We're then going to be giving the user a slightly better rate of BPT for sNOTE than we should whereas any rounding should be in favour of the sNOTE contract.  In any case, we're performing many reads from storage (including from other contracts) in order to calculate a value which was originally passed by the user so using `sNOTEAmount` directly would be a gas optimisation.  ## Recommended Mitigation Steps  Change `_burn` to take an amount of sNOTE to burn as an argument rather than an amount of BPT which is equivalent to the amount of sNOTE to be burnt. `sNOTEAmount` can then be passed from the `redeem` function directly. `bptToRedeem` will still be rounded down so sNOTE will always have favourable rounding.  "}, {"title": "Cooldown and redeem windows can be rendered useless.", "html_url": "https://github.com/code-423n4/2022-01-notional-findings/issues/68", "labels": ["bug", "3 (High Risk)", "disagree with severity", "sponsor confirmed"], "target": "2022-01-notional-findings", "body": "# Handle  ShippooorDAO   # Vulnerability details  ## Impact Cooldown and redeem windows can be rendered useless.  ## Proof of Concept - Given an account that has not staked sNOTE. - Account calls sNOTE.startCooldown - Account waits for the duration of the cooldown period. Redeem period starts. - Account can then deposit and redeem as they wish, making the cooldown useless. - Multiple accounts could be used to \"hop\" between redeem windows by transfering between them, making the redeem window effictively useless.  Could be used for voting power attacks using flash loan if voting process is not monitored  https://www.coindesk.com/tech/2020/10/29/flash-loans-have-made-their-way-to-manipulating-protocol-elections/  ## Tools Used - Eyes - Brain - VS Code  ## Recommended Mitigation Steps A few ways to mitigate this problem: Option A: Remove the cooldown/redeem period as it's not really preventing much in current state. Option B: Let the contract start the cooldown on mint, and bind the cooldown/redeem window to the amount that was minted at that time by the account. Don't make sNOTE.startCooldown() available externally. Redeem should verify amount of token available using this new logic.  "}, {"title": "`_investWETHToBuyNOTE` is unnecessarily roundabout.", "html_url": "https://github.com/code-423n4/2022-01-notional-findings/issues/65", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-notional-findings", "body": "# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact Gas costs  ## Proof of Concept  TreasuryManager has a `_investWETHToBuyNOTE` function which deposits WETH stored on the contract into the NOTE-WETH Balancer pool.  https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/TreasuryManager.sol#L168-L211  Note there's a bit of a disconnect between the function name and what it's actually doing. You could argue that you're buying NOTE as you'll end up with an 80% note position but I think it's  more helpful for the purposes of this function to think of it as a \"trade\" of WETH for BPT.  The current function is as so: ``` IPriceOracle.OracleAverageQuery[] memory queries = new IPriceOracle.OracleAverageQuery[](1);  queries[0].variable = IPriceOracle.Variable.PAIR_PRICE; queries[0].secs = 3600; // last hour queries[0].ago = 0; // now  // Gets the balancer time weighted average price denominated in ETH uint256 noteOraclePrice = IPriceOracle(address(BALANCER_POOL_TOKEN))     .getTimeWeightedAverage(queries)[0];  BALANCER_VAULT.joinPool(     NOTE_ETH_POOL_ID,     address(this),     sNOTE, // sNOTE will receive the BPT     IVault.JoinPoolRequest(         assets,         maxAmountsIn,         abi.encode(             IVault.JoinKind.EXACT_TOKENS_IN_FOR_BPT_OUT,             maxAmountsIn,             0 // Accept however much BPT the pool will give us         ),         false // Don't use internal balances     ) );  uint256 noteSpotPrice = _getNOTESpotPrice();  // Calculate the max spot price based on the purchase limit uint256 maxPrice = noteOraclePrice +     (noteOraclePrice * notePurchaseLimit) /     NOTE_PURCHASE_LIMIT_PRECISION; ```  In this function we query the recent price average between NOTE and ETH, perform an unconditional join and then check that the spot price of NOTE in terms of ETH is below some maximum value to ensure that the pool's balances haven't been manipulated such that ETH is being undervalued.  This seems like a fairly roundabout method to set a slippage limit on a join which would be simpler if we queried the exchange rate between BPT and WETH. That allows us to specify a minimum amount of BPT we'd accept.  We'd then avoid using the function `_getNOTESpotPrice` entirely and could save the costs of querying the pool's balances again.  ## Recommended Mitigation Steps  Consider changing to something along the lines of  ``` IPriceOracle.OracleAverageQuery[] memory queries = new IPriceOracle.OracleAverageQuery[](1);  // Note we're querying the BPT price rather than the pair price now queries[0].variable = IPriceOracle.Variable.BPT_PRICE; queries[0].secs = 3600; // last hour queries[0].ago = 0; // now  // Gets the balancer time weighted average price denominated in ETH uint256 bptOraclePrice = IPriceOracle(address(BALANCER_POOL_TOKEN))     .getTimeWeightedAverage(queries)[0];  uint256 minBptOut = (bptOraclePrice * notePurchaseLimit) /  NOTE_PURCHASE_LIMIT_PRECISION;  BALANCER_VAULT.joinPool(     NOTE_ETH_POOL_ID,     address(this),     sNOTE, // sNOTE will receive the BPT     IVault.JoinPoolRequest(         assets,         maxAmountsIn,         abi.encode(             IVault.JoinKind.EXACT_TOKENS_IN_FOR_BPT_OUT,             maxAmountsIn,             minBptOut         ),         false // Don't use internal balances     ) ); ```  We're directly enforcing a slippage limit on the WETH -> BPT conversion rather than doing it in a roundabout way so it's easier to reason about. We save having to query the pool's balances again so save gas and also in the case where the slippage limit is triggered it'll be hit earlier, again saving gas.  "}, {"title": "Unnecessary inheritance messing with inheritance tree.", "html_url": "https://github.com/code-423n4/2022-01-notional-findings/issues/62", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-notional-findings", "body": "# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact Extra boilerplate code (including the whole of the _afterTokenTransfer function)  ## Proof of Concept  sNOTE inherits from both ERC20Upgradeable and ERC20VotesUpgradeable.  https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/sNOTE.sol#L15  This causes us to have to add explicit helpers for how to handle the inheritance tree to a bunch of functions  https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/sNOTE.sol#L315  https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/sNOTE.sol#L328  https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/sNOTE.sol#L362  https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/sNOTE.sol#L381  If we look at OZ however, we can see that ERC20VotesUpgradeable inherits from ERC20PermitUpgradeable which in turn inherits from ERC20Upgradeable   https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/fd165faaf00587377b5ab93be3cafb4ffdc96976/contracts/token/ERC20/extensions/ERC20VotesUpgradeable.sol#L28  https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/fd165faaf00587377b5ab93be3cafb4ffdc96976/contracts/token/ERC20/extensions/draft-ERC20PermitUpgradeable.sol#L23  There's then no real reason for sNOTE to inherit from ERC20Upgradeable directly. Removing this inheritance should allow you to remove a bunch of the explicit overrides you have.  ## Recommended Mitigation Steps  Remove direct inheritance of ERC20Upgradeable and remove all the `override(ERC20Upgradeable, ERC20VotesUpgradeable)` stuff. You should be able to just delete `_afterTokenTransfer` in its entirety.  "}, {"title": "Initialisation of zero entries in arrays is unnecessary", "html_url": "https://github.com/code-423n4/2022-01-notional-findings/issues/59", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-notional-findings", "body": "# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact Gas costs. ## Proof of Concept  In a number of places we create an array and then fill every element with zero. There's no need to do this as a newly declared array will have zero-valued elements by default. We can then avoid the costs of writing a new zero to them.  For example we could remove these three lines entirely: https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/sNOTE.sol#L111-L113  We can then just pass an empty array in the lines below as so. ``` BALANCER_VAULT.exitPool(   NOTE_ETH_POOL_ID,   address(this),   payable(owner), // Owner will receive the NOTE and WETH   IVault.ExitPoolRequest(       assets,       new uint256[](2), // inlined here       abi.encode(           IVault.ExitKind.EXACT_BPT_IN_FOR_TOKENS_OUT,           bptExitAmount       ),       false // Don't use internal balances   ) ); ```  This also crops up elsewhere: https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/sNOTE.sol#L156 https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/sNOTE.sol#L169 https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/sNOTE.sol#L185  ## Tools Used  ## Recommended Mitigation Steps  Omit lines writing zeros to an empty array.  "}, {"title": "Placement of require statement", "html_url": "https://github.com/code-423n4/2022-01-notional-findings/issues/55", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-notional-findings", "body": "# Handle  Jujic   # Vulnerability details  ## Impact The require statement can be placed earlier (`before get coolDown`) to reduce gas usage.   ## Proof of Concept https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/sNOTE.sol#L240 ``` function redeem(uint256 sNOTEAmount) external nonReentrant {         AccountCoolDown memory coolDown = accountCoolDown[msg.sender];         require(sNOTEAmount <= balanceOf(msg.sender), \"Insufficient balance\");         require(             coolDown.redeemWindowBegin != 0 &&             coolDown.redeemWindowBegin < block.timestamp &&             block.timestamp < coolDown.redeemWindowEnd,             \"Not in Redemption Window\"         );          uint256 bptToRedeem = getPoolTokenShare(sNOTEAmount);         _burn(msg.sender, bptToRedeem);          BALANCER_POOL_TOKEN.safeTransfer(msg.sender, bptToRedeem);     } ``` ## Tools Used Remix ## Recommended Mitigation Steps Relocate the require statement upper.  "}, {"title": "Incorrect comment on cooldown check", "html_url": "https://github.com/code-423n4/2022-01-notional-findings/issues/45", "labels": ["bug", "0 (Non-critical)", "disagree with severity"], "target": "2022-01-notional-findings", "body": "Incorrect comment on cooldown check"}, {"title": "coolDown.redeemWindowEnd serves no purpose", "html_url": "https://github.com/code-423n4/2022-01-notional-findings/issues/43", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-notional-findings", "body": "# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact Increases gas costs due to manipulating redeemWindowEnd and usage of structs for `AccountCooldown`  ## Proof of Concept  `redeemWindowEnd` will always equal `redeemWindowBegin + REDEEM_WINDOW_SECONDS` so it can just be calculated when needed (excluding the situation where both of these are zero which is already handled in the code.)  We then don't need to store both of these values in storage and deal with the overhead of using structs.  https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/sNOTE.sol#L244  We can then just replace this line with   ``` block.timestamp < coolDown.redeemWindowBegin + REDEEM_WINDOW_SECONDS ```  ## Recommended Mitigation Steps  Remove `coolDown.redeemWindowEnd` and store cooldowns as a simple uint rather than a struct.  "}, {"title": "Comment refers to NOTE when it means WETH", "html_url": "https://github.com/code-423n4/2022-01-notional-findings/issues/42", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2022-01-notional-findings", "body": "# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact  ## Proof of Concept  This comment should refer to WETH not NOTE  https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/sNOTE.sol#L177  ## Recommended Mitigation Steps  Change to refer to WETH  "}, {"title": "`mintFromNOTE`, `mintFromETH` and `mintFromWETH` can be merged into two functions to give users better experience.", "html_url": "https://github.com/code-423n4/2022-01-notional-findings/issues/41", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-notional-findings", "body": "# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact Greater flexibility for users and better conversion between a mix of ETH/NOTE and sNOTE.  ## Proof of Concept  `sNOTE` allows users to provider either NOTE, ETH or WETH to provide liquidity in return for BPT to mint sNOTE with through the functions `mintFromNOTE`, `mintFromETH` and `mintFromWETH`.  https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/sNOTE.sol#L146-L188  Balancer allows users to deposit multiple assets at once so the same functionality while being more flexible (by allowing deposits in both NOTE and ETH at the same time) and giving users better execution (A user depositing NOTE and ETH together gets more SNOTE than one who deposits NOTE and then ETH afterwards)  Consider the code snippet:  ``` /// @notice Mints sNOTE from some amount of NOTE and ETH /// @param noteAmount amount of NOTE to transfer into the sNOTE contract function mintFromETH(uint256 noteAmount) payable external nonReentrant {     IAsset[] memory assets = new IAsset[](2);     assets[0] = IAsset(address(0));     assets[1] = IAsset(address(NOTE));     uint256[] memory maxAmountsIn = new uint256[](2);     maxAmountsIn[0] = msg.value;     maxAmountsIn[1] = noteAmount;      _mintFromAssets(assets, maxAmountsIn); }  /// @notice Mints sNOTE from some amount of NOTE and WETH /// @param wethAmount amount of WETH to transfer into the sNOTE contract /// @param noteAmount amount of NOTE to transfer into the sNOTE contract function mintFromWETH(uint256 wethAmount, uint256 noteAmount) external nonReentrant {     // Transfer the WETH and NOTE balance into sNOTE first     WETH.safeTransferFrom(msg.sender, address(this), wethAmount);     NOTE.safeTransferFrom(msg.sender, address(this), noteAmount);      IAsset[] memory assets = new IAsset[](2);     assets[0] = IAsset(address(WETH));     assets[1] = IAsset(address(NOTE));     uint256[] memory maxAmountsIn = new uint256[](2);     maxAmountsIn[0] = wethAmount;     maxAmountsIn[1] = noteAmount;      _mintFromAssets(assets, maxAmountsIn); } ```  ## Recommended Mitigation Steps  Replace current functions with above versions  "}, {"title": "No upper limit on `coolDownTimeInSeconds` allows funds to be locked sNOTE owner.", "html_url": "https://github.com/code-423n4/2022-01-notional-findings/issues/40", "labels": ["bug", "2 (Med Risk)"], "target": "2022-01-notional-findings", "body": "No upper limit on `coolDownTimeInSeconds` allows funds to be locked sNOTE owner."}, {"title": "Require statement on nonzero pool address is impossible to fail ", "html_url": "https://github.com/code-423n4/2022-01-notional-findings/issues/39", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-notional-findings", "body": "# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact Extra gas costs ## Proof of Concept  Here we check that `_noteETHPoolId` corresponds to a registered Balancer pool.  https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/TreasuryManager.sol#L59  `_balancerVault.getPool(_noteETHPoolId)` will revert if _noteETHPoolId is not a registered poolId  https://github.com/balancer-labs/balancer-v2-monorepo/blob/3c1c362adb1fa003cc33f64da93a2e286b5a1257/pkg/vault/contracts/PoolRegistry.sol#L93  https://github.com/balancer-labs/balancer-v2-monorepo/blob/3c1c362adb1fa003cc33f64da93a2e286b5a1257/pkg/vault/contracts/PoolRegistry.sol#L56  The require statement on the next line is impossible to fail unless we somehow manage to deploy a balancer pool to the zero address (which would be impressive)  https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/TreasuryManager.sol#L60  We can then safely remove this statement without any change in behaviour.  ## Recommended Mitigation Steps  Remove require statement.  "}, {"title": "_getToken not resilient to errors", "html_url": "https://github.com/code-423n4/2022-01-notional-findings/issues/36", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2022-01-notional-findings", "body": "# Handle  0x1f8b   # Vulnerability details  ## Impact `_getToken` return empty values instead of revert.  ## Proof of Concept The library `TokenHandler` has the `_getToken` method and this method returns an empty struct instead of revert if the currencyId was not found, this can produce in unexpected errors.  ## Tools Used Manual review.  ## Recommended Mitigation Steps revert if it was not found.  "}, {"title": "safeApprove of openZeppelin is deprecated", "html_url": "https://github.com/code-423n4/2022-01-notional-findings/issues/20", "labels": ["bug", "duplicate", "0 (Non-critical)"], "target": "2022-01-notional-findings", "body": "safeApprove of openZeppelin is deprecated"}, {"title": "Require with empty message", "html_url": "https://github.com/code-423n4/2022-01-notional-findings/issues/18", "labels": ["bug", "0 (Non-critical)", "disagree with severity"], "target": "2022-01-notional-findings", "body": "Require with empty message"}, {"title": "Cheaper operation should be done first in an if statement", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/319", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-trader-joe-findings", "body": "# Handle  pedroais   # Vulnerability details  ## Impact Save gas ## Proof of Concept The cheaper operation should be done first to save gas . auctionStart == 0 is cheaper than block.timestamp < auctionStart  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/LaunchEvent.sol#L291     "}, {"title": "Lack of input checks (withrawal penalties should always be greater than 0)", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/314", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor acknowledged"], "target": "2022-01-trader-joe-findings", "body": "Lack of input checks (withrawal penalties should always be greater than 0)"}, {"title": "Gas Optimziation: Unnecessary pairBalance call", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/310", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-trader-joe-findings", "body": "# Handle  gzeon   # Vulnerability details  ## Impact If `msg.sender == issuer`, we don't need to call `pairBalance(msg.sender)` https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/LaunchEvent.sol#L447 ```         uint256 balance = pairBalance(msg.sender);         user.hasWithdrawnPair = true;          if (msg.sender == issuer) {             balance = lpSupply / 2;              emit IssuerLiquidityWithdrawn(msg.sender, address(pair), balance);              if (tokenReserve > 0) {                 uint256 amount = tokenReserve;                 tokenReserve = 0;                 token.transfer(msg.sender, amount);             }         } else {             emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);         } ``` to ```         uint256 balance;         user.hasWithdrawnPair = true;          if (msg.sender == issuer) {             balance = lpSupply / 2;              emit IssuerLiquidityWithdrawn(msg.sender, address(pair), balance);              if (tokenReserve > 0) {                 uint256 amount = tokenReserve;                 tokenReserve = 0;                 token.transfer(msg.sender, amount);             }         } else {             balance = pairBalance(msg.sender);             emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);         } ```  "}, {"title": "Gas Optimization: Use type(uint256).max instead of block.timestamp", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/309", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-trader-joe-findings", "body": "Gas Optimization: Use type(uint256).max instead of block.timestamp"}, {"title": "Reasonable upper limits for phase durations", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/303", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2022-01-trader-joe-findings", "body": "Reasonable upper limits for phase durations"}, {"title": "Repeated storage access", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/300", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-trader-joe-findings", "body": "Repeated storage access"}, {"title": "Unchecked math operations", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/296", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-trader-joe-findings", "body": "Unchecked math operations"}, {"title": "Unchecked math operations", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/295", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-trader-joe-findings", "body": "Unchecked math operations"}, {"title": "Separate issuer functions from regular users", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/294", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-trader-joe-findings", "body": "Separate issuer functions from regular users"}, {"title": "Unsafe call to decimals()", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/291", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2022-01-trader-joe-findings", "body": "Unsafe call to decimals()"}, {"title": "Gas Optimization: fmul optimization", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/290", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-trader-joe-findings", "body": "Gas Optimization: fmul optimization"}, {"title": "Gas Optimization: Variables that could be set immutable", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/284", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-trader-joe-findings", "body": "Gas Optimization: Variables that could be set immutable"}, {"title": "Use constructors", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/282", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-trader-joe-findings", "body": "Use constructors"}, {"title": "Error never thrown", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/278", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-trader-joe-findings", "body": "Error never thrown"}, {"title": "Mark unchanging variables immutable", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/274", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-01-trader-joe-findings", "body": "Mark unchanging variables immutable"}, {"title": "Use Shift Right/Left instead of Division/Multiplication if possible", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/271", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-trader-joe-findings", "body": "Use Shift Right/Left instead of Division/Multiplication if possible"}, {"title": "RocketJoeStaking.initialize arguments need to be checked", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/266", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2022-01-trader-joe-findings", "body": "# Handle  hyh   # Vulnerability details  ## Impact  Being instantiated with wrong configuration the contract will be inoperable.  If a misconfiguration is noticed too late the various types of malfunctions become possible.  ## Proof of Concept  RocketJoeStaking.initialize doesn't check input parameters, which are immutable due to initializer pattern:  https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/RocketJoeStaking.sol#L72-75   ## Recommended Mitigation Steps  Consider checking joe, rJoe addresses and lastRewardTimestamp to be non-zero and also checking rJoePerSec to be within pre specified bounds  "}, {"title": "using += to save gas", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/265", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-trader-joe-findings", "body": "# Handle  rfa   # Vulnerability details  ## Impact expensive gas  ## Proof of Concept https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/RocketJoeStaking.sol#L169-L172  ## Tools Used  ## Recommended Mitigation Steps ```             accRJoePerShare  +=             (rJoeReward * PRECISION) /             joeSupply; ```  "}, {"title": "Missing consistent zero address checks", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/263", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2022-01-trader-joe-findings", "body": "# Handle  sirhashalot   # Vulnerability details  ## Impact  Some functions in RocketJoeFactory.sol have zero checks for setting specific state variables, but there zero address checks are not always applied. Setting some of these state variables to the zero address, whether intentional or not, can break the protocol functionality. Adding these checks consistently would prevent this scenario.  ## Proof of Concept  The [constructor in RocketJoeFactory.sol](https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/RocketJoeFactory.sol#L53-L61) performs zero address checks before setting the router, factory, penaltyCollector, and rJoe state variables.  Later in the same contract, the functions `setRJoe()`, `setPenaltyCollector()`, `setRouter()`, and `setFactory()` [omit the same zero address checks](https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/RocketJoeFactory.sol#L159-L188) that were applied earlier. Since the issues that can be caused by setting these state variables to the zero address exist whether setting the value in the constructor or in the setter function, these checks should be applied consistently.  ## Recommended Mitigation Steps  Add zero address checks in the setter functions for these state variables just like is done in the constructor. If it is determined that a zero check for any of these state variables is not needed, then the zero check can be removed from the RocketJoeFactory.sol constructor for consistency.  "}, {"title": "Functions can be external", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/262", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-trader-joe-findings", "body": "# Handle  sirhashalot   # Vulnerability details  ## Impact  The `withdrawAVAX()` function of LaunchEvent.sol and `initialize()` function of RocketJoeStaking.sol can be declared external for gas savings  ## Proof of Concept  - [withdrawAVAX](https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/LaunchEvent.sol#L349) - [initialize](https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/RocketJoeStaking.sol#L57)  ## Recommended Mitigation Steps  Declare functions as external instead of public when possible  "}, {"title": "possibility of minting rJOE tokens before ownership  is changed to RocketJoeStaking", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/261", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-01-trader-joe-findings", "body": "possibility of minting rJOE tokens before ownership  is changed to RocketJoeStaking"}, {"title": "using `unchecked` can save gas", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/260", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-trader-joe-findings", "body": "using `unchecked` can save gas"}, {"title": "Improper Upper Bound Definition on the Fee", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/255", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed"], "target": "2022-01-trader-joe-findings", "body": "Improper Upper Bound Definition on the Fee"}, {"title": "`createRJLaunchEvent()` Multiple `launchEvent` can be created unexpectedly by reentrancy", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/248", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2022-01-trader-joe-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-trader-joe/blob/119e12d715ececc31478e833297f124cc15d27c2/contracts/RocketJoeFactory.sol#L97-L154  ```solidity function createRJLaunchEvent(     address _issuer,     uint256 _phaseOneStartTime,     address _token,     uint256 _tokenAmount,     uint256 _tokenIncentivesPercent,     uint256 _floorPrice,     uint256 _maxWithdrawPenalty,     uint256 _fixedWithdrawPenalty,     uint256 _maxAllocation,     uint256 _userTimelock,     uint256 _issuerTimelock ) external override returns (address) {     require(         getRJLaunchEvent[_token] == address(0),         \"RJFactory: token has already been issued\"     );     require(_issuer != address(0), \"RJFactory: issuer can't be 0 address\");     require(_token != address(0), \"RJFactory: token can't be 0 address\");     require(_token != wavax, \"RJFactory: token can't be wavax\");     require(         _tokenAmount > 0,         \"RJFactory: token amount needs to be greater than 0\"     );     require(         IJoeFactory(factory).getPair(_token, wavax) == address(0) ||             IJoePair(IJoeFactory(factory).getPair(_token, wavax))                 .totalSupply() ==             0,         \"RJFactory: liquid pair already exists\"     );      address launchEvent = Clones.clone(eventImplementation);      // msg.sender needs to approve RocketJoeFactory     IERC20(_token).transferFrom(msg.sender, launchEvent, _tokenAmount);      ILaunchEvent(payable(launchEvent)).initialize(         _issuer,         _phaseOneStartTime,         _token,         _tokenIncentivesPercent,         _floorPrice,         _maxWithdrawPenalty,         _fixedWithdrawPenalty,         _maxAllocation,         _userTimelock,         _issuerTimelock     );      getRJLaunchEvent[_token] = launchEvent;     isRJLaunchEvent[launchEvent] = true;     allRJLaunchEvents.push(launchEvent);      _emitLaunchedEvent(_issuer, _token, _phaseOneStartTime);      return launchEvent; } ```  At L132, `_token.transferFrom()` can be used to re-enter the `createRJLaunchEvent()` function, before the storage change at L147-149.  This will allow the attacker to create multiple `launchEvent` contracts and get them listed in `allRJLaunchEvents`.  Even though there is no significant impact as far as we can tell from the smart contract code. We believe this is still unexpected and may cause other parts of the system, say the frontend to malfunction in some cases.  ### Recommendation  Consider moving L132 `_token.transferFrom()` to after L147-149 to prevent re-entrance.  "}, {"title": "`createRJLaunchEvent()` can be called by anyone with 1 Wei of `_token` and stop others from creating RJLaunchEvent with the same token anymore", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/247", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-01-trader-joe-findings", "body": "`createRJLaunchEvent()` can be called by anyone with 1 Wei of `_token` and stop others from creating RJLaunchEvent with the same token anymore"}, {"title": "`RocketJoeFactory.sol#createRJLaunchEvent()` Check of `_issuer != address(0)`, `_token != address(0)`, `_tokenAmount > 0` can be done earlier to save gas", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/245", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-trader-joe-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/RocketJoeFactory.sol#L98-L155  ```solidity     function createRJLaunchEvent(         address _issuer,         uint256 _phaseOneStartTime,         address _token,         uint256 _tokenAmount,         uint256 _tokenIncentivesPercent,         uint256 _floorPrice,         uint256 _maxWithdrawPenalty,         uint256 _fixedWithdrawPenalty,         uint256 _maxAllocation,         uint256 _userTimelock,         uint256 _issuerTimelock     ) external override returns (address) {         require(             getRJLaunchEvent[_token] == address(0),             \"RJFactory: token has already been issued\"         );         require(_issuer != address(0), \"RJFactory: issuer can't be 0 address\");         require(_token != address(0), \"RJFactory: token can't be 0 address\");         require(_token != wavax, \"RJFactory: token can't be wavax\");         require(             _tokenAmount > 0,             \"RJFactory: token amount needs to be greater than 0\"         );         require(             IJoeFactory(factory).getPair(_token, wavax) == address(0) ||                 IJoePair(IJoeFactory(factory).getPair(_token, wavax))                     .totalSupply() ==                 0,             \"RJFactory: liquid pair already exists\"         );         // ...     } ```  `_issuer != address(0)`, `_token != address(0)`, `_tokenAmount > 0` are cheaper than other checks who read storage or do external call.   Therefore, checking `_issuer != address(0)`, `_token != address(0)`, `_tokenAmount > 0` first can save some gas.   ### Recommendation  Change to:  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/RocketJoeFactory.sol#L98-L155  ```solidity     function createRJLaunchEvent(         address _issuer,         uint256 _phaseOneStartTime,         address _token,         uint256 _tokenAmount,         uint256 _tokenIncentivesPercent,         uint256 _floorPrice,         uint256 _maxWithdrawPenalty,         uint256 _fixedWithdrawPenalty,         uint256 _maxAllocation,         uint256 _userTimelock,         uint256 _issuerTimelock     ) external override returns (address) {         require(_issuer != address(0), \"RJFactory: issuer can't be 0 address\");         require(_token != address(0), \"RJFactory: token can't be 0 address\");         require(             _tokenAmount != 0,             \"RJFactory: token amount needs to be greater than 0\"         );         require(             getRJLaunchEvent[_token] == address(0),             \"RJFactory: token has already been issued\"         );         require(_token != wavax, \"RJFactory: token can't be wavax\");         require(             IJoeFactory(factory).getPair(_token, wavax) == address(0) ||                 IJoePair(IJoeFactory(factory).getPair(_token, wavax))                     .totalSupply() ==                 0,             \"RJFactory: liquid pair already exists\"         );         // ...     } ```  "}, {"title": "Use short reason strings can save gas", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/242", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-trader-joe-findings", "body": "Use short reason strings can save gas"}, {"title": "`Ownable` library is redundant", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/241", "labels": ["bug", "disagree with severity", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-trader-joe-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/LaunchEvent.sol#L19-L19  ```solidity contract LaunchEvent is Ownable { ```  The `LaunchEvent.sol` contract never utilized `onlyOwner` / `owner()` or any other features provided by the `Ownable` library.  Therefore, `is Ownable` can be removed.   "}, {"title": "\"> 0\" is less efficient than \"!= 0\" for unsigned integers", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/240", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-trader-joe-findings", "body": "\"> 0\" is less efficient than \"!= 0\" for unsigned integers"}, {"title": "Check if amount > 0 before token transfer can save gas", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/238", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-01-trader-joe-findings", "body": "Check if amount > 0 before token transfer can save gas"}, {"title": "Cache external call results can save gas", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/236", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-trader-joe-findings", "body": "Cache external call results can save gas"}, {"title": "Redundant type casting", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/235", "labels": ["bug", "disagree with severity", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-trader-joe-findings", "body": "Redundant type casting"}, {"title": "Cache and read storage variables from the stack can save gas", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/234", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-trader-joe-findings", "body": "Cache and read storage variables from the stack can save gas"}, {"title": "Adding unchecked directive can save gas", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/233", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-trader-joe-findings", "body": "Adding unchecked directive can save gas"}, {"title": "Code Style: non-constant should not be named in all caps", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/230", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2022-01-trader-joe-findings", "body": "# Handle  WatchPug   # Vulnerability details  Non-constant (especially public) variables should not be in `SCREAMING_SNAKE_CASE`, or they may be misunderstood as constants.  Consider changing to `camelCase`.  See: https://docs.soliditylang.org/en/v0.8.11/style-guide.html?highlight=name#local-and-state-variable-names  Instances include:  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/interfaces/IRocketJoeFactory.sol#L35-L39  ```solidity function PHASE_ONE_DURATION() external view returns (uint256);  function PHASE_ONE_NO_FEE_DURATION() external view returns (uint256);  function PHASE_TWO_DURATION() external view returns (uint256); ```  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/RocketJoeFactory.sol#L29-L31  ```solidity uint256 public override PHASE_ONE_DURATION = 2 days; uint256 public override PHASE_ONE_NO_FEE_DURATION = 1 days; uint256 public override PHASE_TWO_DURATION = 1 days; ```  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/RocketJoeFactory.sol#L200-L214  ```solidity function setPhaseDuration(uint256 _phaseNumber, uint256 _duration)     external     override     onlyOwner {     if (_phaseNumber == 1) {         require(             _duration > PHASE_ONE_NO_FEE_DURATION,             \"RJFactory: phase one duration lower than no fee duration\"         );         PHASE_ONE_DURATION = _duration;     } else if (_phaseNumber == 2) {         PHASE_TWO_DURATION = _duration;     } } ```  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/RocketJoeFactory.sol#L218-L228  ```solidity function setPhaseOneNoFeeDuration(uint256 _noFeeDuration)     external     override     onlyOwner {     require(         _noFeeDuration < PHASE_ONE_DURATION,         \"RJFactory: no fee duration bigger than phase one duration\"     );     PHASE_ONE_NO_FEE_DURATION = _noFeeDuration; } ```  "}, {"title": "Saving more gas by using `immutable phase`", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/229", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-trader-joe-findings", "body": "Saving more gas by using `immutable phase`"}, {"title": "Caching `rJoe` variable", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/227", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-trader-joe-findings", "body": "Caching `rJoe` variable"}, {"title": "Mint() by OnlyOwner Lack of Zero Address Check for Address _to", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/223", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-trader-joe-findings", "body": "Mint() by OnlyOwner Lack of Zero Address Check for Address _to"}, {"title": "Gas in `LaunchEvent.sol:pairBalance()`: `wavaxAllocated` should get cached", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/219", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-trader-joe-findings", "body": "Gas in `LaunchEvent.sol:pairBalance()`: `wavaxAllocated` should get cached"}, {"title": "Gas in `LaunchEvent.sol:getPenalty()`: `PHASE_ONE_DURATION` and `PHASE_ONE_NO_FEE_DURATION` should get cached", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/218", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-trader-joe-findings", "body": "Gas in `LaunchEvent.sol:getPenalty()`: `PHASE_ONE_DURATION` and `PHASE_ONE_NO_FEE_DURATION` should get cached"}, {"title": "Gas in `LaunchEvent.sol:emergencyWithdraw()`: `issuer` should get cached", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/217", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-trader-joe-findings", "body": "Gas in `LaunchEvent.sol:emergencyWithdraw()`: `issuer` should get cached"}, {"title": "Gas in `LaunchEvent.sol:withdrawLiquidity()`: `tokenReserve` should get cached earlier", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/216", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-trader-joe-findings", "body": "Gas in `LaunchEvent.sol:withdrawLiquidity()`: `tokenReserve` should get cached earlier"}, {"title": "Gas in `LaunchEvent.sol:createPair()`: `wavaxReserve` should get cached", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/215", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-trader-joe-findings", "body": "Gas in `LaunchEvent.sol:createPair()`: `wavaxReserve` should get cached"}, {"title": "Gas in `LaunchEvent.sol:currentPhase()`: `auctionStart` and `PHASE_ONE_DURATION` should get cached", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/214", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-trader-joe-findings", "body": "Gas in `LaunchEvent.sol:currentPhase()`: `auctionStart` and `PHASE_ONE_DURATION` should get cached"}, {"title": "Gas in `RocketJoeFactory.sol:createRJLaunchEvent()`: `wavax` should get cached", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/211", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-trader-joe-findings", "body": "Gas in `RocketJoeFactory.sol:createRJLaunchEvent()`: `wavax` should get cached"}, {"title": "Gas: `RocketJoeStaking.withdraw`", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/210", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-trader-joe-findings", "body": "# Handle  cmichel   # Vulnerability details  `RocketJoeStaking.withdraw`: The `_safeRJoeTransfer(msg.sender, pending)` only needs to be performed if `pending > 0`.  "}, {"title": "Misleading comment in `LaunchEvent.getReserves`", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/209", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "sponsor confirmed"], "target": "2022-01-trader-joe-findings", "body": "# Handle  cmichel   # Vulnerability details  `LaunchEvent.getReserves`: The comment says: `@notice Returns the current balance of the pool`. The \"of the pool\" part can be misleading as the `tokenIncentivesBalance` are never part of the _pool pair_. Consider changing this to \"Returns the outstanding balance of the launch event contract\".  "}, {"title": "`LaunchEvent.tokenIncentivesPercent` wrong docs", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/208", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "sponsor confirmed"], "target": "2022-01-trader-joe-findings", "body": "# Handle  cmichel   # Vulnerability details  `LaunchEvent.tokenIncentivesPercent`: The math in the comment is wrong: `/// then 105 000 * 1e18 / (1e18 + 5e16) = 5 000 tokens are used for incentives`. It should be `105 000 * 5e16 / (1e18 + 5e16) = 5 000 tokens are used for incentives`  "}, {"title": "Gas in `RocketJoeStaking.sol:updatePool()`: `lastRewardTimestamp` should get cached", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/207", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-trader-joe-findings", "body": "Gas in `RocketJoeStaking.sol:updatePool()`: `lastRewardTimestamp` should get cached"}, {"title": "Penalty Collector must be trusted", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/206", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2022-01-trader-joe-findings", "body": "Penalty Collector must be trusted"}, {"title": "Uninitialized `RocketJoeStaking.lastRewardTimestamp` can inflate `rJoe` supply", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/202", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-01-trader-joe-findings", "body": "# Handle  cmichel   # Vulnerability details  The `RocketJoeStaking.lastRewardTimestamp` is initialized to zero. Usually, this does not matter as `updatePool` is called before the first deposit and when `joeSupply = joe.balanceOf(address(this)) == 0`, it is set to the current time.  ```solidity function updatePool() public {     if (block.timestamp <= lastRewardTimestamp) {         return;     }     uint256 joeSupply = joe.balanceOf(address(this));      // @audit lastRewardTimestamp is not initialized. can send 1 Joe to this contract directly => lots of rJoe minted to this contract     if (joeSupply == 0) {         lastRewardTimestamp = block.timestamp;         return;     }     uint256 multiplier = block.timestamp - lastRewardTimestamp;     uint256 rJoeReward = multiplier * rJoePerSec;     accRJoePerShare =         accRJoePerShare +         (rJoeReward * PRECISION) /         joeSupply;     lastRewardTimestamp = block.timestamp;      rJoe.mint(address(this), rJoeReward); } ```  However, if a user first directly transfers `Joe` tokens to the contract before the first `updatePool` call, the `block.timestamp - lastRewardTimestamp = block.timestamp` will be a large timestamp value and lots of `rJoe` will be minted (but not distributed to users). Even though they are not distributed to the users, inflating the `rJoe` total supply might not be desired.  #### Recommendation Consider tracking the actual total deposits in a storage variable and using this value instead of the current balance for `joeSupply`. This way, transferring tokens to the contract has no influence and depositing through `deposit` first calls `updatePool` and initializes `lastRewardTimestamp`.   "}, {"title": "`rJoeAmount` can never be less than the `_avaxAmount`", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/201", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2022-01-trader-joe-findings", "body": "# Handle  cmichel   # Vulnerability details  The `LaunchEvent.rJoePerAvax` variable is an _unscaled_ integer value and used to compute the `rJoeAmount` as:  ```solidity function getRJoeAmount(uint256 _avaxAmount) public view returns (uint256) {     return _avaxAmount * rJoePerAvax; } ```  This means the required `rJoeAmount` to burn can never be less than the deposited `avaxAmount`. If a launch event desires to use `0.5 rJoe` per AVAX, this is not possible.  #### Recommendation Consider the `rJoePerAvax` value as a value scaled by `1e18` and then divide by this scale in `getRJoeAmount` again.  "}, {"title": "Users can lose value in emergency state", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/199", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-01-trader-joe-findings", "body": "# Handle  cmichel   # Vulnerability details  Imagine the following sequence of events:  - `LaunchEvent.createPair()` is called which sets `wavaxReserve = 0`, adds liquidity to the pair and receives `lpSupply` LP tokens. - `LaunchEvent.allowEmergencyWithdraw()` is called which enters emergency / paused mode and disallows normal withdrawals. - Users can only call `LaunchEvent.emergencyWithdraw` which reverts as the WAVAX reserve was already used to provide liquidity and cannot be paid out. Users don't receive their LP tokens either. The users lost their entire deposit in this case.  #### Recommendation Consider paying out LP tokens in `emergencyWithdraw`.   "}, {"title": "ERC20 return values not checked", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/198", "labels": ["bug", "duplicate", "2 (Med Risk)"], "target": "2022-01-trader-joe-findings", "body": "ERC20 return values not checked"}, {"title": "Pair creation can be denied", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/197", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed"], "target": "2022-01-trader-joe-findings", "body": "# Handle  cmichel   # Vulnerability details  The `LaunchEvent.createPair` requires that no previous pool was created for the `WAVAX <> _token` pair.  ```solidity function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {     (address wavaxAddress, address tokenAddress) = (         address(WAVAX),         address(token)     );     // @audit grief: anyone can create pair     require(         factory.getPair(wavaxAddress, tokenAddress) == address(0),         \"LaunchEvent: pair already created\"     );      // ... } ```  A griefer can create a pool for the `WAVAX <> _token` pair by calling [`JoeFactory.createPair(WAVAX, _token)`](https://snowtrace.io/address/0x9ad6c38be94206ca50bb0d90783181662f0cfa10#contracts) while the launch event phase 1 or 2 is running. No liquidity can then be provided and an emergency state must be triggered for users and the issuer to be able to withdraw again.  #### Recommendation It must be assumed that the pool is already created and even initialized as pool creation and liquidity provisioning is permissionless. Special attention must be paid if the pool is already initialized with liquidity at a different price than the launch event price.  It would be enough to have a standard min. LP return \"slippage\" check (using parameter values for `amountAMin/amountBMin` instead of the hardcoded ones in `router.addLiquidity`) in `LaunchEvent.createPair()`. The function must then be callable with special privileges only, for example, by the issuer. Alternatively, the slippage check can be hardcoded as a percentage of the raised amounts (`amountADesired = 0.95 * wavaxReserve, amountBDesired = 0.95 * tokenAllocated`).  This will prevent attacks that try to provide LP at a bad pool price as the transaction will revert when receiving less than the slippage parameter. If the pool is already initialized, it should just get arbitraged to the auction token price and liquidity can then be provided at the expected rate again.   "}, {"title": "Gas in `RocketJoeStaking.sol:deposit()`: `accRJoePerShare` should get cached", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/196", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-trader-joe-findings", "body": "Gas in `RocketJoeStaking.sol:deposit()`: `accRJoePerShare` should get cached"}, {"title": "Wrong token allocation computation for token decimals != 18 if floor price not reached", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/193", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-trader-joe-findings", "body": "# Handle  cmichel   # Vulnerability details  In `LaunchEvent.createPair`, when the floor price is not reached (`floorPrice > wavaxReserve * 1e18 / tokenAllocated`), the tokens to be sent to the pool are lowered to match the raised WAVAX at the floor price.  Note that the `floorPrice` is supposed to have a precision of 18:  > /// @param _floorPrice Price of each token in AVAX, scaled to 1e18  The `floorPrice > (wavaxReserve * 1e18) / tokenAllocated` check is correct but the `tokenAllocated` computation involves the `token` decimals:  ```solidity // @audit should be wavaxReserve * 1e18 / floorPrice tokenAllocated = (wavaxReserve * 10**token.decimals()) / floorPrice; ```  This computation does not work for `token`s that don't have 18 decimals.  #### Example Assume I want to sell `1.0 wBTC = 1e8 wBTC` (8 decimals) at `2,000.0 AVAX = 2,000 * 1e18 AVAX`. The `floorPrice` is `2000e18 * 1e18 / 1e8 = 2e31`  Assume the Launch event only raised `1,000.0 AVAX` - half of the floor price for the issued token amount of `1.0 WBTC` (it should therefore allocate only half a WBTC) - and the token amount will be reduced as: `floorPrice = 2e31 > 1000e18 * 1e18 / 1e8 = 1e31 = actualPrice`. Then, `tokenAllocated = 1000e18 * 1e8 / 2e31 = 1e29 / 2e31 = 0` and no tokens would be allocated, instead of `0.5 WBTC = 0.5e8 WBTC`.  The computation should be `tokenAllocated = wavaxReserve * 1e18 / floorPrice = 1000e18 * 1e18 / 2e31 = 1e39 / 2e31 = 10e38 / 2e31 = 5e7 = 0.5e8`.  #### Recommendation The new `tokenAllocated` computation should be `tokenAllocated = wavaxReserve * 1e18 / floorPrice;`.   "}, {"title": "Gas in `RocketJoeStaking.sol:withdraw()`: `accRJoePerShare` should get cached", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/192", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-trader-joe-findings", "body": "Gas in `RocketJoeStaking.sol:withdraw()`: `accRJoePerShare` should get cached"}, {"title": "Gas in `RocketJoeStaking.sol:withdraw()`: `user.amount` should get cached and used for calculation", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/187", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-trader-joe-findings", "body": "Gas in `RocketJoeStaking.sol:withdraw()`: `user.amount` should get cached and used for calculation"}, {"title": "Incorecct calculation between actual code and comment", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/186", "labels": ["bug", "1 (Low Risk)", "disagree with severity"], "target": "2022-01-trader-joe-findings", "body": "Incorecct calculation between actual code and comment"}, {"title": "Gas in `RocketJoeStaking.sol:deposit()`: `user.amount` should get cached and used for calculation", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/185", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-trader-joe-findings", "body": "Gas in `RocketJoeStaking.sol:deposit()`: `user.amount` should get cached and used for calculation"}, {"title": "Gas in `RocketJoeFactory.sol:_emitLaunchedEvent()`: a value used only once shouldn't get cached", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/184", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-trader-joe-findings", "body": "Gas in `RocketJoeFactory.sol:_emitLaunchedEvent()`: a value used only once shouldn't get cached"}, {"title": "Gas in `LaunchEvent.sol:emergencyWithdraw()`: `user.balance` should get cached earlier", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/182", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-trader-joe-findings", "body": "Gas in `LaunchEvent.sol:emergencyWithdraw()`: `user.balance` should get cached earlier"}, {"title": "The contracts use unlocked pragma", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/181", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-trader-joe-findings", "body": "# Handle  hyh   # Vulnerability details  ## Impact  As different compiler versions have critical behavior specifics if the contract gets accidentally deployed using another compiler version compared to one they tested with, various types of undesired behavior can be introduced.  ## Proof of Concept  All the contracts in scope use unlocked pragma: ```pragma solidity ^0.8.0```, allowing wide enough range of versions.  Examples:  https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L4  https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/RocketJoeToken.sol#L3   ## Recommended Mitigation Steps  Consider locking compiler version, for example `pragma solidity 0.8.6`.  This can have additional benefits, for example using custom errors to save gas and so forth.  "}, {"title": "Gas in `LaunchEvent.sol:withdrawLiquidity()`: `address(pair)` should get cached", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/180", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-trader-joe-findings", "body": "Gas in `LaunchEvent.sol:withdrawLiquidity()`: `address(pair)` should get cached"}, {"title": "Gas in `LaunchEvent.sol:createPair()`: calculation should get cached", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/179", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-trader-joe-findings", "body": "Gas in `LaunchEvent.sol:createPair()`: calculation should get cached"}, {"title": "Gas: Non-strict inequalities are cheaper than strict ones", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/178", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-trader-joe-findings", "body": "Gas: Non-strict inequalities are cheaper than strict ones"}, {"title": "Gas savings", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/174", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-trader-joe-findings", "body": "Gas savings"}, {"title": "Failed transfer with low level call could be overlooked", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/170", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-01-trader-joe-findings", "body": "# Handle  harleythedog   # Vulnerability details  ## Impact The `CallFacet.sol` contract has the function `_call` : ``` function  _call(  address  _target,  bytes  memory  _calldata,  uint256  _value ) internal {  require(address(this).balance >= _value, \"ETH_BALANCE_TOO_LOW\");  (bool success, ) = _target.call{value: _value}(_calldata);  require(success, \"CALL_FAILED\");  emit  Call(msg.sender, _target, _calldata, _value); } ``` This function is utilized in a lot of different places. According to the [Solidity docs]([https://docs.soliditylang.org/en/develop/control-structures.html#error-handling-assert-require-revert-and-exceptions](https://docs.soliditylang.org/en/develop/control-structures.html#error-handling-assert-require-revert-and-exceptions)), \"The low-level functions `call`, `delegatecall` and `staticcall` return `true` as their first return value if the account called is non-existent, as part of the design of the EVM. Account existence must be checked prior to calling if needed\".      As a result, it is possible that this call will not work but `_call` will not notice anything went wrong. It could be possible that a user is interacting with an exchange or token that has been deleted, but `_call` will not notice that something has gone wrong and as a result, ether can become stuck in the contract. For this reason, it would be better to also check for the contract's existence prior to executing `_target.call`.   For reference, see a similar high severity reported in a Uniswap audit here (report # 9): https://github.com/Uniswap/v3-core/blob/main/audits/tob/audit.pdf    ## Proof of Concept See `_call` here: https://github.com/code-423n4/2021-12-amun/blob/98f6e2ff91f5fcebc0489f5871183566feaec307/contracts/basket/contracts/facets/Call/CallFacet.sol#L108.  ## Tools Used Inspection  ## Recommended Mitigation Steps To ensure tokens don't get stuck in edge case where user is interacting with a deleted contract, make sure to check that contract actually exists before calling it.   "}, {"title": "LP Tokens May Be Locked in Contract Due to `allowEmergencyWithdraw()` in Stage 3", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/169", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-01-trader-joe-findings", "body": "# Handle  kirk-baird   # Vulnerability details  ## Impact  The function [allowEmergencyWithdraw()](https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L520) may be called by the `rocketJoeFactory.owner()` at any time. If it is called while the protocol is in Stage 3 and a pair has been created then the LP tokens will be locked and both issues and depositors will be unable to withdraw.  ## Proof of Concept  If `allowEmergencyWithdraw()`  is called `stopped` is set to `true`. As a result functions [withdrawIncentives()](https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L468) and [withdrawLiquidity()](https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L438) will revert due to the `isStopped(false)` modifier reverting.  Additionally, [emergencyWithdraw()](https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L494) will revert since all the `WAVAX` and `token` balances have been transferred to the liquidity pool.  Thus, depositors and issuers will have no methods of removing their LP tokens or incentives.   ## Recommended Mitigation Steps  Consider adding the requirement `require(address(pair) != address(0), \"LaunchEvent: pair not created\");` to the function `allowEmergencyWithdraw()`.  "}, {"title": "Gas: Missing checks for non-zero transfer value calls", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/166", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-trader-joe-findings", "body": "Gas: Missing checks for non-zero transfer value calls"}, {"title": "Missing inheritances", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/164", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2022-01-trader-joe-findings", "body": "Missing inheritances"}, {"title": "Gas Optimisation - Simplify `_atPhase()` Logic", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/162", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-trader-joe-findings", "body": "# Handle  kirk-baird   # Vulnerability details  ## Impact  The logic in [_atPhase()`](https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L590) can be simplified to save gas and code complexity.  The code can be simplified to the follwoing.  ```solidity     function _atPhase(Phase _phase) internal view {             require(currentPhase() == _phase, \"LaunchEvent: incorrect phase\");     } ```  ## Proof of Concept  n/a  ## Tools Used  n/a  ## Recommended Mitigation Steps  Consider updating the code to that procided above.  "}, {"title": "`RocketJoeStaking.sol#withdraw` has an unneeded require statement", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/160", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-trader-joe-findings", "body": "`RocketJoeStaking.sol#withdraw` has an unneeded require statement"}, {"title": "Gas: Tight variable packing in `LaunchEvent.sol`", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/159", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-trader-joe-findings", "body": "Gas: Tight variable packing in `LaunchEvent.sol`"}, {"title": "Gas Optimisation - Unnecessary External Calls in `LaunchEvent.initialize()`", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/158", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-trader-joe-findings", "body": "Gas Optimisation - Unnecessary External Calls in `LaunchEvent.initialize()`"}, {"title": "Inclusive checks in LaunchEvent.sol for time-management", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/157", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2022-01-trader-joe-findings", "body": "Inclusive checks in LaunchEvent.sol for time-management"}, {"title": "`LaunchEvent.sol`: Use `SafeERC20.safeApprove` in `createPair()`", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/154", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2022-01-trader-joe-findings", "body": "`LaunchEvent.sol`: Use `SafeERC20.safeApprove` in `createPair()`"}, {"title": "Wrong comment", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/149", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "sponsor confirmed"], "target": "2022-01-trader-joe-findings", "body": "# Handle  wuwe1   # Vulnerability details  ## Impact Causing confuse to user and developer.  ## Proof of Concept https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L55  `105000 * 1e18 / (1e18 + 5e16)` is equal to `100000`    ## Recommended Mitigation Steps  change to  `105000 - 105000 * 1e18 / (1e18 + 5e16) = 5000`  "}, {"title": "Missing event emitting", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/148", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor confirmed"], "target": "2022-01-trader-joe-findings", "body": "# Handle  wuwe1   # Vulnerability details  ## Impact Off-chain tools will not work as expected.  ## Proof of Concept  Missing UserWithdrawn  [https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L132](https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L132)  [https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L372](https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L372)  Missing IssuingTokenDeposited  [https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L124](https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L124)  [https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L287](https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L287)   ## Recommended Mitigation Steps  Add `emit UserWithdrawn(user, amountMinusFee)` after L372  Add `emit IssuingTokenDeposited(_token, balance)` after L287  "}, {"title": "`createPair()` expects zero slippage", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/146", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-01-trader-joe-findings", "body": "`createPair()` expects zero slippage"}, {"title": "Missing divide by 0 check on tokenAllocated", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/140", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2022-01-trader-joe-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact A division by 0 could occur  ## Proof of Concept There are no checks that the denominator is `!= 0` here: ``` File: LaunchEvent.sol 392:         uint256 tokenAllocated = tokenReserve; 393:  394:         // Adjust the amount of tokens sent to the pool if floor price not met 395:         if ( 396:             floorPrice > (wavaxReserve * 10**token.decimals()) / tokenAllocated 397:         ) { ```  tokenReserve (`uint256 tokenAllocated = tokenReserve;`) can be equal to 0 according to this comment: https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L106  Therefore this could happen  ## Tools Used VS Code  ## Recommended Mitigation Steps Check for `tokenAllocated != 0` before this division  "}, {"title": "Gas: Mark functions as payable when users can't mistakenly send ETH", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/132", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-trader-joe-findings", "body": "Gas: Mark functions as payable when users can't mistakenly send ETH"}, {"title": "Gas Optimisation - Reduce storage loads", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/128", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-trader-joe-findings", "body": "Gas Optimisation - Reduce storage loads"}, {"title": "Re-enterable Code When Making a Deposit to Stake", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/127", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed"], "target": "2022-01-trader-joe-findings", "body": "# Handle  kirk-baird   # Vulnerability details  ## Impact  Note: this attack requires `rJoe` to relinquish control during `tranfer()` which under the current [RocketJoeToken](https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/RocketJoeToken.sol) it does not. Thus this vulnerability is raised as medium rather than high. Although it's not exploitable currently, it is a highly risky code pattern that should be avoided.  This vulnerability would allow the entire rJoe balance to be drained from the contract.  ## Proof of Concept  The function [deposit()](https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/RocketJoeStaking.sol#L96) would be vulnerable to reentrancy if rJoe relinquished control flow.  The following lines show the reward calculations in variable `pending`. These calculations use two state variables `user.amount` and `user.rewardDebt`. Each of these are updated after `_safeRJoeTransfer()`.  Thus if an attacker was able to get control flow during the `rJoe::tranfer()` function they would be able to reenter `deposit()` and the value calculated for `pending`would be the same as the previous iteration hence they would again be transferred `pending` rJoe tokens. During the rJoe transfer the would again gain control of the execution and call `deposit()` again. The process could be repeated until the entire rJoe balance of the contract has been transferred to the attacker.  ```solidity         if (user.amount > 0) {             uint256 pending = (user.amount * accRJoePerShare) /                 PRECISION -                 user.rewardDebt;             _safeRJoeTransfer(msg.sender, pending);         }         user.amount = user.amount + _amount;         user.rewardDebt = (user.amount * accRJoePerShare) / PRECISION; ```   ## Tools Used  n/a  ## Recommended Mitigation Steps  There are two possible mitigations. First is to use the [openzeppelin reentrancy guard](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol) over the `deposit()` function which will prevent multiple deposits being made simultaneously.  The second mitigation is to follow the [checks-effects-interactions](https://docs.soliditylang.org/en/v0.8.11/security-considerations.html#re-entrancy) pattern. This would involve updating all state variables before making any external calls.  "}, {"title": "Owner of LaunchEvent token has the ability to DOS attack the event", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/121", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-01-trader-joe-findings", "body": "Owner of LaunchEvent token has the ability to DOS attack the event"}, {"title": "Useless storage variable", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/116", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-trader-joe-findings", "body": "# Handle  p4st13r4   # Vulnerability details  ## Impact  `pendingRJoe()` reads a user into a storage variable, which is redundant since it\u2019s a `view()` function and the variable is never modified in place. It can be replaced by a `memory` variable for readability  ## Proof of Concept  [https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/RocketJoeStaking.sol#L82](https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/RocketJoeStaking.sol#L82)  ## Tools Used  Editor  ## Recommended Mitigation Steps  ```jsx UserInfo memory user = userInfo[_user]; ```  "}, {"title": "Unused variable _amount", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/115", "labels": ["bug", "0 (Non-critical)"], "target": "2022-01-trader-joe-findings", "body": "Unused variable _amount"}, {"title": "The staking contract should have pause/unpause functionality.", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/109", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2022-01-trader-joe-findings", "body": "The staking contract should have pause/unpause functionality."}, {"title": "instead of using && in require. just use require multiple time", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/103", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-trader-joe-findings", "body": "# Handle  rfa   # Vulnerability details  ## Impact expensive gas  ## Proof of Concept https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/RocketJoeFactory.sol#L53-L59 && operator cost more gas. ## Tools Used  ## Recommended Mitigation Steps use require multiple times instead of && ``` require(_eventImplementation != address(0), \"RJFactory: Addresses can't be null address\"); require(_rJoe != address(0),  \"RJFactory: Addresses can't be null address\"); ...  ```  "}, {"title": "UserData struct can be packed into a single slot.", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/88", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-trader-joe-findings", "body": "UserData struct can be packed into a single slot."}, {"title": "Explicit initialisation variable wastes gas.", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/87", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-trader-joe-findings", "body": "# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact gas costs  ## Proof of Concept  LaunchEvent has an explicit `initialized` variable which is in storage. https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/LaunchEvent.sol#L228  To save an SSTORE we could just check that `_auctionStart > 0` as this is a sufficient check for initialisation. If a getter is needed then a function like the below could be added.  ``` function initialized() external view returns bool {   return auctionStart > 0; } ```  ## Recommended Mitigation Steps  As above.  "}, {"title": "LaunchEvent pays out fewer incentives then expected", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/82", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "sponsor confirmed"], "target": "2022-01-trader-joe-findings", "body": "# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact  LaunchEvent pays out fewer incentives than expected.  ## Proof of Concept  When creating a launch event, issuers must provide the total amount of tokens they want to send to the contract and what percentage of these are reserved for incentives.  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/RocketJoeFactory.sol#L84-L86  Note that there's an inconsistency between the documentation and the implementation. Documentation implies that the issuer provides `_tokenAmount` tokens and an additional `_tokenAmount * _tokenIncentivesPercent / 1e18` as an incentive whereas in reality they only provide `_tokenAmount`   This can be seen here:  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/RocketJoeFactory.sol#L133  For us to pay out the correct percentage of `_tokenAmount` as incentives would expect that amount to be `(_tokenAmount * _tokenIncentivesPercent) / 1e18` however as can be seen we pay out `_tokenAmount - (_tokenAmount * 1e18) / (1e18 + _tokenIncentivesPercent)`  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/LaunchEvent.sol#L273  This will consistently pay out a smaller percentage of the total amount of tokens than `_tokenIncentivesPercent`.  ## Recommended Mitigation Steps  Switch to having the issuer provide explicit amounts `_tokenIssuanceAmount` and `_tokenIncentivesAmount` to avoid mistakes about how percentages are handled.  Add tests to ensure that the contract is initialised with the correct state.  "}, {"title": "Use clones with immutable variables to reduce costs from SLOADs", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/79", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-trader-joe-findings", "body": "Use clones with immutable variables to reduce costs from SLOADs"}, {"title": "Free gas savings for using solidity 0.8.10+", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/78", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-trader-joe-findings", "body": "Free gas savings for using solidity 0.8.10+"}, {"title": "maxWithdrawPenalty and fixedWithdrawPenalty can be packed together", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/74", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-trader-joe-findings", "body": "maxWithdrawPenalty and fixedWithdrawPenalty can be packed together"}, {"title": "Timestamps/durations held in storage can be packed", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/73", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-trader-joe-findings", "body": "Timestamps/durations held in storage can be packed"}, {"title": "Missing Sanity Checks Will Cause To Revert On the Function", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/71", "labels": ["bug", "disagree with severity", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-trader-joe-findings", "body": "# Handle  defsec   # Vulnerability details  ## Impact  In the JoeStaking contract, the amount check should be placed on the contract. IF the amount is more than transfer operations should be completed.  ## Proof of Concept  1. Navigate to the following contract.  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/RocketJoeStaking.sol#L129  2. _amount is not checked if Its more than zero.  ```     function withdraw(uint256 _amount) external {         UserInfo storage user = userInfo[msg.sender];         require(             user.amount >= _amount,             \"RocketJoeStaking: withdraw amount exceeds balance\"         );          updatePool();          uint256 pending = (user.amount * accRJoePerShare) /             PRECISION -             user.rewardDebt;          user.amount = user.amount - _amount;         user.rewardDebt = (user.amount * accRJoePerShare) / PRECISION;          _safeRJoeTransfer(msg.sender, pending);         joe.safeTransfer(address(msg.sender), _amount);         emit Withdraw(msg.sender, _amount);     }  ```  ## Tools Used  Code Review  ## Recommended Mitigation Steps  Consider to add the following check.   ```     function withdraw(uint256 _amount) external {         UserInfo storage user = userInfo[msg.sender];         require(             user.amount >= _amount,             \"RocketJoeStaking: withdraw amount exceeds balance\"         );          updatePool();          uint256 pending = (user.amount * accRJoePerShare) /             PRECISION -             user.rewardDebt;          user.amount = user.amount - _amount;         user.rewardDebt = (user.amount * accRJoePerShare) / PRECISION;   if(pending != 0) {         _safeRJoeTransfer(msg.sender, pending); }  if(_amount != 0){         joe.safeTransfer(address(msg.sender), _amount); }          emit Withdraw(msg.sender, _amount);      }   ```   "}, {"title": "Initialization Function Is Missing If Token is Equals To WAVAX On the LaunchEvent", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/64", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2022-01-trader-joe-findings", "body": "# Handle  defsec   # Vulnerability details  ## Impact  During the code review, It has been observed that the token can be same as WAVAX. The initialize function should not allow if token is equals to wavax. That would affect all asset management.   ## Proof of Concept  1. Navigate to the following contract.  ``` https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L219  https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L411  ```  ## Tools Used  Code Review  ## Recommended Mitigation Steps  On the Launchevent, token should not be equal to wavax.   "}, {"title": "Storing phase durations rather than start times duplicates calculations", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/59", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-trader-joe-findings", "body": "Storing phase durations rather than start times duplicates calculations"}, {"title": "Internal functions to private", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/52", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-trader-joe-findings", "body": "Internal functions to private"}, {"title": "Cache powers of 10 used several times", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/49", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-trader-joe-findings", "body": "Cache powers of 10 used several times"}, {"title": "Check if amount is not zero to save gas", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/48", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-trader-joe-findings", "body": "Check if amount is not zero to save gas"}, {"title": "Mult instead div in compares", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/46", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2022-01-trader-joe-findings", "body": "Mult instead div in compares"}, {"title": "safeApprove of openZeppelin is deprecated", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/44", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2022-01-trader-joe-findings", "body": "safeApprove of openZeppelin is deprecated"}, {"title": "Not verified function inputs of public / external functions", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/43", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2022-01-trader-joe-findings", "body": "Not verified function inputs of public / external functions"}, {"title": "Missing commenting", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/39", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor acknowledged"], "target": "2022-01-trader-joe-findings", "body": "# Handle  robee   # Vulnerability details  The following functions are missing commenting as describe below:              ConvexStakingWrapper.sol, user_checkpoint (external), @return is missing  "}, {"title": "withdrawAVAX() function has call to sender without reentrancy protection ", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/32", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-01-trader-joe-findings", "body": "# Handle  jayjonah8   # Vulnerability details  ## Impact In LauchEvent.sol the withdrawAVAX() function makes an external call to the msg.sender by way of _safeTransferAVAX.  This allows the caller to reenter this and other functions in this and other protocol files.  To prevent reentrancy and cross function reentrancy there should be reentrancy guard modifiers placed on the withdrawAVAX() function and any other function that makes external calls to the caller.   ## Proof of Concept https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L368  https://github.com/code-423n4/2022-01-trader-joe/blob/main/contracts/LaunchEvent.sol#L370  ## Tools Used Manual code review   ## Recommended Mitigation Steps Add reentrancy guard modifier to withdrawAVAX() function.   "}, {"title": "Lack of ownership check", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/27", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2022-01-trader-joe-findings", "body": "Lack of ownership check"}, {"title": "Admin Deny of Service", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/25", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "sponsor confirmed"], "target": "2022-01-trader-joe-findings", "body": "# Handle  0x1f8b   # Vulnerability details  ## Impact Owner can Denial of service.  ## Proof of Concept In the contract `RocketJoeStaking` there are two ways to set `rJoePerSec`, one in the `initialize` and the second one in `updateEmissionRate`, in both of them there are no checks of the received value, so it's possible to use a high value and deny the service in line `updatePool:168`.  ## Tools Used Manual review  ## Recommended Mitigation Steps Change the type to uint128 for `rJoePerSec`.  "}, {"title": "RocketJoeFactory assume the input address is WAVAX", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/23", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2022-01-trader-joe-findings", "body": "RocketJoeFactory assume the input address is WAVAX"}, {"title": "Must approve 0 first", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/22", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2022-01-trader-joe-findings", "body": "Must approve 0 first"}, {"title": "Incompatibility With Rebasing/Deflationary/Inflationary tokens", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/18", "labels": ["bug", "2 (Med Risk)", "sponsor disputed"], "target": "2022-01-trader-joe-findings", "body": "Incompatibility With Rebasing/Deflationary/Inflationary tokens"}, {"title": "Use safeTransfer/safeTransferFrom consistently instead of transfer/transferFrom", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/12", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-01-trader-joe-findings", "body": "Use safeTransfer/safeTransferFrom consistently instead of transfer/transferFrom"}, {"title": "No Transfer Ownership Pattern", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/10", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "sponsor acknowledged"], "target": "2022-01-trader-joe-findings", "body": "No Transfer Ownership Pattern"}, {"title": "FRONT-RUNNABLE INITIALIZERS", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/8", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2022-01-trader-joe-findings", "body": "FRONT-RUNNABLE INITIALIZERS"}, {"title": "rJoe rewards can be manipulated for all users ", "html_url": "https://github.com/code-423n4/2022-01-trader-joe-findings/issues/5", "labels": ["bug", "1 (Low Risk)", "disagree with severity"], "target": "2022-01-trader-joe-findings", "body": "rJoe rewards can be manipulated for all users "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-xtribe-findings/issues/98", "labels": ["bug", "QA (Quality Assurance)", "sponsor todo"], "target": "2022-04-xtribe-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-neotokyo-findings/blob/main/data/Deathstore-Q.md)."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-xtribe-findings/issues/97", "labels": ["bug", "QA (Quality Assurance)", "sponsor todo"], "target": "2022-04-xtribe-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-xtribe-findings/issues/96", "labels": ["bug", "G (Gas Optimization)", "sponsor todo"], "target": "2022-04-xtribe-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-xtribe-findings/issues/95", "labels": ["bug", "G (Gas Optimization)", "sponsor todo"], "target": "2022-04-xtribe-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-xtribe-findings/issues/90", "labels": ["bug", "G (Gas Optimization)", "sponsor todo"], "target": "2022-04-xtribe-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-xtribe-findings/issues/89", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-04-xtribe-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-xtribe-findings/issues/87", "labels": ["bug", "sponsor acknowledged", "QA (Quality Assurance)"], "target": "2022-04-xtribe-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-xtribe-findings/issues/85", "labels": ["bug", "G (Gas Optimization)", "sponsor todo"], "target": "2022-04-xtribe-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-xtribe-findings/issues/84", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-04-xtribe-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-xtribe-findings/issues/83", "labels": ["bug", "sponsor disputed", "QA (Quality Assurance)"], "target": "2022-04-xtribe-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-xtribe-findings/issues/81", "labels": ["bug", "sponsor disputed", "QA (Quality Assurance)"], "target": "2022-04-xtribe-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-xtribe-findings/issues/79", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-04-xtribe-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-xtribe-findings/issues/77", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-04-xtribe-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-xtribe-findings/issues/76", "labels": ["bug", "sponsor confirmed", "QA (Quality Assurance)"], "target": "2022-04-xtribe-findings", "body": "QA Report"}, {"title": "Unbounded delegating increases gas cost of transfer and can lock all funds", "html_url": "https://github.com/code-423n4/2022-04-xtribe-findings/issues/75", "labels": ["bug", "sponsor disputed", "QA (Quality Assurance)"], "target": "2022-04-xtribe-findings", "body": "Unbounded delegating increases gas cost of transfer and can lock all funds"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-xtribe-findings/issues/74", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-04-xtribe-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-xtribe-findings/issues/73", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-04-xtribe-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-xtribe-findings/issues/72", "labels": ["bug", "sponsor acknowledged", "QA (Quality Assurance)"], "target": "2022-04-xtribe-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-xtribe-findings/issues/71", "labels": ["bug", "sponsor acknowledged", "QA (Quality Assurance)"], "target": "2022-04-xtribe-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-xtribe-findings/issues/70", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-04-xtribe-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-xtribe-findings/issues/69", "labels": ["bug", "sponsor confirmed", "QA (Quality Assurance)", "sponsor todo"], "target": "2022-04-xtribe-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-xtribe-findings/issues/68", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-04-xtribe-findings", "body": "Gas Optimizations"}, {"title": "xERC4626 does not work well with token tax on transfer", "html_url": "https://github.com/code-423n4/2022-04-xtribe-findings/issues/67", "labels": ["bug", "sponsor disputed", "QA (Quality Assurance)"], "target": "2022-04-xtribe-findings", "body": "xERC4626 does not work well with token tax on transfer"}, {"title": "First xERC4626 deposit exploit can break share calculation", "html_url": "https://github.com/code-423n4/2022-04-xtribe-findings/issues/66", "labels": ["bug", "2 (Med Risk)"], "target": "2022-04-xtribe-findings", "body": "First xERC4626 deposit exploit can break share calculation"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-xtribe-findings/issues/64", "labels": ["bug", "sponsor disputed", "QA (Quality Assurance)"], "target": "2022-04-xtribe-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-xtribe-findings/issues/63", "labels": ["bug", "sponsor disputed", "QA (Quality Assurance)"], "target": "2022-04-xtribe-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-xtribe-findings/issues/62", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-04-xtribe-findings", "body": "Gas Optimizations"}, {"title": "Incorrect accounting of free weight in `_decrementWeightUntilFree`", "html_url": "https://github.com/code-423n4/2022-04-xtribe-findings/issues/61", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "sponsor todo"], "target": "2022-04-xtribe-findings", "body": "# Lines of code  https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L547-L583   # Vulnerability details  ## Impact In `_decrementWeightUntilFree`, the free weight is calculated by `balanceOf[user] - getUserWeight[user]` plus weight freed from non-deprecated gauges. The non-deprecated criteria is unnecessary and lead to incorrect accounting of free weight.  ## Proof of Concept https://github.com/fei-protocol/flywheel-v2/blob/77bfadf388db25cf5917d39cd9c0ad920f404aad/src/token/ERC20Gauges.sol#L547-L583 ```     function _decrementWeightUntilFree(address user, uint256 weight) internal {         uint256 userFreeWeight = balanceOf[user] - getUserWeight[user];          // early return if already free         if (userFreeWeight >= weight) return;          uint32 currentCycle = _getGaugeCycleEnd();          // cache totals for batch updates         uint112 userFreed;         uint112 totalFreed;          // Loop through all user gauges, live and deprecated         address[] memory gaugeList = _userGauges[user].values();          // Free gauges until through entire list or under weight         uint256 size = gaugeList.length;         for (uint256 i = 0; i < size && (userFreeWeight + totalFreed) < weight; ) {             address gauge = gaugeList[i];             uint112 userGaugeWeight = getUserGaugeWeight[user][gauge];             if (userGaugeWeight != 0) {                 // If the gauge is live (not deprecated), include its weight in the total to remove                 if (!_deprecatedGauges.contains(gauge)) {                     totalFreed += userGaugeWeight;                 }                 userFreed += userGaugeWeight;                 _decrementGaugeWeight(user, gauge, userGaugeWeight, currentCycle);                  unchecked {                     i++;                 }             }         }          getUserWeight[user] -= userFreed;         _writeGaugeWeight(_totalWeight, _subtract, totalFreed, currentCycle);     } ``` Consider Alice allocated 3 weight to gauge D, gauge A and gauge B equally where gauge D is depricated 1. Alice call _decrementWeightUntilFree(alice, 2) 2. userFreeWeight = 0 3. gauge D is freed, totalFreed = 0, userFreed = 1 4. (userFreeWeight + totalFreed) < weight, continue to free next gauge 5. gauge A is freed, totalFreed = 1, userFreed = 2 6. (userFreeWeight + totalFreed) < weight, continue to free next gauge 7. gauge B is freed, totalFreed = 2, userFreed = 3 8. All gauge is freed  Alternatively, Alice can 1. Alice call _decrementWeightUntilFree(alice, 1) 2. userFreeWeight = balanceOf[alice] - getUserWeight[alice] = 3 - 3 = 0 3. gauge D is freed, totalFreed = 0, userFreed = 1 4. (userFreeWeight + totalFreed) < weight, continue to free next gauge 5. gauge A is freed, totalFreed = 1, userFreed = 2 6. (userFreeWeight + totalFreed) >= weight, break 7. getUserWeight[alice] -= totalFreed 8. Alice call _decrementWeightUntilFree(alice, 2) 9. userFreeWeight = balanceOf[alice] - getUserWeight[alice] = 3 - 1 = 2 10. (userFreeWeight + totalFreed) >= weight, break 11. Only 2 gauge is freed  ## Recommended Mitigation Steps No need to treat deprecated gauge seperately  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-xtribe-findings/issues/60", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-04-xtribe-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-xtribe-findings/issues/59", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-04-xtribe-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-xtribe-findings/issues/56", "labels": ["bug", "sponsor confirmed", "QA (Quality Assurance)", "sponsor todo"], "target": "2022-04-xtribe-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-xtribe-findings/issues/54", "labels": ["bug", "QA (Quality Assurance)", "sponsor todo"], "target": "2022-04-xtribe-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-xtribe-findings/issues/52", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-04-xtribe-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-xtribe-findings/issues/51", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-04-xtribe-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-xtribe-findings/issues/50", "labels": ["bug", "sponsor disputed", "QA (Quality Assurance)"], "target": "2022-04-xtribe-findings", "body": "QA Report"}, {"title": "[WP-H0] `xERC4626.sol` Some users may not be able to withdraw until `rewardsCycleEnd` the due to underflow in `beforeWithdraw()`", "html_url": "https://github.com/code-423n4/2022-04-xtribe-findings/issues/48", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed", "sponsor todo"], "target": "2022-04-xtribe-findings", "body": "# Lines of code  https://github.com/fei-protocol/ERC4626/blob/2b2baba0fc480326a89251716f52d2cfa8b09230/src/xERC4626.sol#L65-L68   # Vulnerability details  https://github.com/fei-protocol/ERC4626/blob/2b2baba0fc480326a89251716f52d2cfa8b09230/src/xERC4626.sol#L65-L68  ```solidity function beforeWithdraw(uint256 amount, uint256 shares) internal virtual override {     super.beforeWithdraw(amount, shares);     storedTotalAssets -= amount; } ```  https://github.com/fei-protocol/ERC4626/blob/2b2baba0fc480326a89251716f52d2cfa8b09230/src/xERC4626.sol#L78-L87  ```solidity function syncRewards() public virtual {     uint192 lastRewardAmount_ = lastRewardAmount;     uint32 timestamp = block.timestamp.safeCastTo32();      if (timestamp < rewardsCycleEnd) revert SyncError();      uint256 storedTotalAssets_ = storedTotalAssets;     uint256 nextRewards = asset.balanceOf(address(this)) - storedTotalAssets_ - lastRewardAmount_;      storedTotalAssets = storedTotalAssets_ + lastRewardAmount_; // SSTORE     ... ```  `storedTotalAssets` is a cached value of total assets which will only include the `unlockedRewards` when the whole cycle ends.  This makes it possible for `storedTotalAssets -= amount` to revert when the withdrawal amount exceeds `storedTotalAssets`, as the withdrawal amount may include part of the `unlockedRewards` in the current cycle.  ### PoC  Given:  - rewardsCycleLength = 100 days  1. Alice `deposit()` 100 TRIBE tokens; 2. The owner transferred 100 TRIBE tokens as rewards and called `syncRewards()`; 3. 1 day later, Alice `redeem()` with all shares, the transaction will revert at `xERC4626.beforeWithdraw()`.  Alice's shares worth 101 TRIBE at this moment, but `storedTotalAssets` = 100, making `storedTotalAssets -= amount` reverts due to underflow.  4. Bob `deposit()` 1 TRIBE tokens; 5. Alice `withdraw()` 101 TRIBE tokens, `storedTotalAssets` becomes `0`; 6. Bob can't even withdraw 1 wei of TRIBE token, as `storedTotalAssets` is now `0`.  If there are no new deposits, both Alice and Bob won't be able to withdraw any of their funds until `rewardsCycleEnd`.  ### Recommendation  Consider changing to:  ```solidity function beforeWithdraw(uint256 amount, uint256 shares) internal virtual override {     super.beforeWithdraw(amount, shares);     uint256 _storedTotalAssets = storedTotalAssets;     if (amount >= _storedTotalAssets) {         uint256 _totalAssets = totalAssets();         // _totalAssets - _storedTotalAssets == unlockedRewards         lastRewardAmount -= _totalAssets - _storedTotalAssets;         lastSync = block.timestamp;         storedTotalAssets = _totalAssets - amount;     } else {         storedTotalAssets = _storedTotalAssets - amount;     } } ```  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-xtribe-findings/issues/47", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-xtribe-findings", "body": "Gas Optimizations"}, {"title": "xTRIBE reward syncing is not permissionless allowing the owner to grieve users", "html_url": "https://github.com/code-423n4/2022-04-xtribe-findings/issues/43", "labels": ["bug", "sponsor disputed", "QA (Quality Assurance)"], "target": "2022-04-xtribe-findings", "body": "xTRIBE reward syncing is not permissionless allowing the owner to grieve users"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-xtribe-findings/issues/41", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-xtribe-findings", "body": "Gas Optimizations"}, {"title": "FlywheelCore's setFlywheelRewards can remove access to reward funds from current users", "html_url": "https://github.com/code-423n4/2022-04-xtribe-findings/issues/40", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged", "sponsor todo"], "target": "2022-04-xtribe-findings", "body": "FlywheelCore's setFlywheelRewards can remove access to reward funds from current users"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-xtribe-findings/issues/39", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-xtribe-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-xtribe-findings/issues/38", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-xtribe-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-xtribe-findings/issues/37", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-xtribe-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-xtribe-findings/issues/36", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-xtribe-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-xtribe-findings/issues/34", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-xtribe-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-xtribe-findings/issues/33", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-xtribe-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-xtribe-findings/issues/32", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-xtribe-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-xtribe-findings/issues/31", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged", "sponsor todo"], "target": "2022-04-xtribe-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-xtribe-findings/issues/30", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-xtribe-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-xtribe-findings/issues/29", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-04-xtribe-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-xtribe-findings/issues/28", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-xtribe-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-xtribe-findings/issues/27", "labels": ["bug", "QA (Quality Assurance)", "sponsor todo"], "target": "2022-04-xtribe-findings", "body": "QA Report"}, {"title": "`FlywheelCore.setBooster()` can be used to steal unclaimed rewards", "html_url": "https://github.com/code-423n4/2022-04-xtribe-findings/issues/23", "labels": ["bug", "help wanted", "2 (Med Risk)"], "target": "2022-04-xtribe-findings", "body": "`FlywheelCore.setBooster()` can be used to steal unclaimed rewards"}, {"title": "In ERC20Gauges, contribution to total weight is double-counted when incrementGauge is called before addGauge for a given gauge.", "html_url": "https://github.com/code-423n4/2022-04-xtribe-findings/issues/22", "labels": ["bug", "2 (Med Risk)"], "target": "2022-04-xtribe-findings", "body": "In ERC20Gauges, contribution to total weight is double-counted when incrementGauge is called before addGauge for a given gauge."}]