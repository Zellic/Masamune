[{"title": "1. Strategy.sol no slippage tolerance limit set on _sellRewardForWant", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-LevGeist.md", "body": "_claimAndSellRewards always passes 0 as the minOut argument to the _sellRewardForWant method, so there is no slippage tolerance limit.", "labels": ["yAudit", "Severity: Medium", "Difficulty: n/a"]}, {"title": "2. BaseStrategy.sol Missing non-zero address check in setHealthCheck", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-LevGeist.md", "body": "The function does not have a non-zero address check for its address argument. All other setter methods for address type variables in the contract have non-zero address checks.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "3. liquidatePosition loss recording does not record loss when _amountNeeded.sub(_liquidatedAmount) <= minWant", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-LevGeist.md", "body": "Losses are only recorded when _amountNeeded.sub(_liquidatedAmount); <= minWant if (diff <= minWant) { _loss = diff; } Instead of _amountNeeded.sub(_liquidatedAmount) >= minWant", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "4. Strategy.sol Missing non-zero address check in _initializeThis", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-LevGeist.md", "body": "The function calls an external contract to get some token addresses (address _aToken, , address _debtToken) = protocolDataProvider.getReserveTokensAddresses(address(want)); and then has a non-zero address check for _aToken, but not for _debtToken.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "5. Strategy.sol Missing invariants checks in liquidatePosition", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-LevGeist.md", "body": "In the code we see the following comments: // NOTE: Maintain invariant `want.balanceOf(this) >= _liquidatedAmount` // NOTE: Maintain invariant `_liquidatedAmount + _loss <= _amountNeeded But they are just assumptions made by the developer and there are no assert/require statements to ensure they are really correct.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "6. Strategy.sol unreachable code in prepareReturn", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-LevGeist.md", "body": "On lines 254 to 257, the if statement: if (amountRequired.sub(_debtPayment) < _profit) does not evaluate, this is because amountRequired is debtOutstanding + _profit and _debtPayment is debtOutstanding, meaning that the if statement always evaluates to _profit < _profit which is never true, meaning that line 256 never evaluates.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "7. Unnecessary liquidation procedures", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-LevGeist.md", "body": "On line 336 https://github.com/Yacademy-block-2/yearnV2-gen-lev-lending/blob/levgeist/contracts/Strategy.sol#L336 the function checks if the want balance is sufficient to cover the amountNeeded, this is set as wantBalance > _amountNeeded. If wantBalance is the same as _amountNeeded the strategy still has sufficient funds to cover the withdraw, meaning the logic that follows this if statement is unnecessary.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "8. Strategy.sol & BaseStrategy.sol inefficient usage of for loops", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-LevGeist.md", "body": "Strategy.sol lines 199, 455, 509 and BaseStrategy.sol line 893 contain for loops that are implemented inefficiently in terms of gas for the EVM. Omitting assigning a default-zero type variable to zero, caching array's length, using ++i instead of i++ can save a good chunk of gas, especially if the loop is long running.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "9. Regular math can be used instead of SafeMath when it is safe", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-LevGeist.md", "body": "if (totalDebt > totalAssets) { // we have losses _loss = totalDebt.sub(totalAssets); } else { // we have profit _profit = totalAssets.sub(totalDebt); }", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "10. BaseStrategy.sol does not emit event in setHealthCheck", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-LevGeist.md", "body": "All other setter methods for address type variables in the contract emit events on state change, example: function setStrategist(address _strategist) external onlyAuthorized { require(_strategist != address(0)); strategist = _strategist; emit UpdatedStrategist(_strategist); }", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "11. Strategy.sol does not emit event in setCollateralTargets, setMinsAndMaxs, setRewardBehavior", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-LevGeist.md", "body": "11. Strategy.sol does not emit event in setCollateralTargets, setMinsAndMaxs, setRewardBehavior", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "12. Strategy.sol has rewards local variable defined in a couple of places which shadows reward state variable as defined in BaseStrategy.sol", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-LevGeist.md", "body": "12. Strategy.sol has rewards local variable defined in a couple of places which shadows reward state variable as defined in BaseStrategy.sol", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "13. Strategy.sol uses now keyword in _sellRewardForWant", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-LevGeist.md", "body": "The code makes use of the now keyword in Solidity which is deprecated in future Solidity versions.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "14. Strategy.sol estimatedTotalAssets can be declared as external", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-LevGeist.md", "body": "The estimatedTotalAssets method is declared as public which should be used for method that will be called from inside of the contract, but estimatedTotalAssets isn't.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "15. Centralised control of LP tokens on Spookyswap", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-LevGeist.md", "body": "As of 24/06/2022 84.6% of all Geist/FTM LP tokens are controlled by a single address as seen here: https://ftmscan.com/token/0x668ae94d0870230ac007a01b471d02b2c94ddcb9#balances this address is a MasterChef so does decentralise the system slightly, however if for whatever reason this liquidity was pulled it could result in extremely high slippage which reduces profitability of the strategy and exacerbates the chances of a sandwich attack.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "1. Double voting using cross-chain voting", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md", "body": "The process a staker would take to double vote with their assets is: Vote on the first chain (can be Ethereum mainnet or Polygon) Take the 15% instant withdrawal fee Bridge assets Restake GET to receive xGET Vote again on the second chain The end result is 85% more votes than should be possible from the original asset value There is even more complexity involved in cross-chain voting. Some other cases to consider are: The argument could be made that no user would want to lose 15% of their assets to get extra votes. This would depend on the bribe market and other factors, but there is also a way for the user to recapture some of their \"lost\" 15%. If a user has X amount of assets staked in the vault, 10% of the total amount could be used for this cross-chain double voting while the other 90% of the assets reclaim some of the \"lost\" 15% because the 15% fee is distributed among the stakers in the vault. To take this to the next level, a user who knows they will be performing an instant withdrawal can borrow GET at a certain interest rate, stake it, take the 15% instant withdrawal fee hit, and later withdraw the borrowed GET potentially at a profit before returning it to the borrower. Some modeling or linear programming is necessary to determine exactly when recapturing the 15% fee is profitable, especially in the scenario involving borrowed GET, which will not be examined further here. If a snapshot of user assets at a specific block is used to determine votes held by each address, the question is how to synchronize this point in time across chains. It is unlikely such a process would be exact, given that mining a block is not an instant process. If there is a different in snapshot times between Ethereum mainnet and Polygon, it may enable time for assets to be bridged across chains to enable this double voting. The exact plans around how this would work were not outlined in the smart contract and are not in scope of this review, but should be considered.", "labels": ["yAudit", "Severity: High", "Difficulty: n/a"]}, {"title": "2. Withdraw and cancel requests can be frontrun for profit", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md", "body": "In the following test example, Alice deposits funds, profits are scheduled, and Alice makes a withdrawal request while funds are being streamed. Right before the executeWithdrawalRequest() is triggered by Alice, Bob deposits funds, and he will be able to get the profits immediately. Because Alice executeWithdrawalRequest() is triggered right after the deposit, the leftover profits from the duration of the lockTime are distributed to everyone, including Bob, immediately through the burn of shares. In the test, we compare the shares with Eve's shares. Eve deposited right after Alice's withdrawal. They are very different from the amount of Bob shares's. The share amount is very different because the price per share has dramatically increased. function testFrontRunWithdraw() public { address eve = address(0x0E5E); // first Alice deposit _setUpDepositor(alice, 1 ether); // We add some profit asset.mint(address(vault), 1 ether); vault.updateVestingSchedule(); vm.warp(block.timestamp + 2 days); // Alice starts a withdrawal request vault.createWithdrawalRequest(1 ether); // we increase time to reach the end of the lock vm.warp(block.timestamp + 26 weeks); // Bob deposit _setUpDepositor(bob, 1 ether); vm.stopPrank(); // Alice execute the withdraw vm.startPrank(alice); vault.executeWithdrawalRequest(0); // Eve deposit vm.stopPrank(); _setUpDepositor(eve, 1 ether); vm.stopPrank(); assertApproxEqRel(vault.balanceOf(eve), vault.balanceOf(bob), 10e6); } function convertToAssets(uint256 shares_) public view virtual override returns (uint256 assets_) { uint256 supply = totalSupply; // Cache to stack. assets_ = supply == 0 ? shares_ : (shares_ * totalAssets()) / supply; }", "labels": ["yAudit", "Severity: High", "Difficulty: n/a"]}, {"title": "3. Vault may be susceptible to donation attack", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md", "body": "The first user to call deposit() on the GovernanceLockedRevenueDistributionToken.sol contract is issued the same quantity of shares as the underlying assets they provide. A user can abuse this to deposit a single quantity of assets in return for one share, setting the supply to 1. This same user could then send a large donation of underlying assets to the vault through a direct transfer and call the updateVestingSchedule() function to begin increasing the totalAssets() value. The ability to call updateVestingSchedule() after a donation is a requisite for this attack due to the totalAssets() value relying on the issuanceRate. The required capital for a successful donation attack will diminish over the course of a 14 day period. The below POC can be added to Compound.t.sol to show the donation amount needed to round another depositor's share issuance to 0 after 1 day has passed between deposits: function testDonationAttack() public { // after set up, allow alice to withdraw all but a dust amount from the vault // we warp ahead in time to avoid withdrawal penalties to ensure the vault is left with only dust vm.startPrank(alice); uint256 allButDust = 1 ether - 1; vault.createWithdrawalRequest((allButDust)); uint256 afterWithdrawalPenalties = start + 26 weeks; vm.warp(afterWithdrawalPenalties); // execute the withdrawal request vault.executeWithdrawalRequest(0); vm.stopPrank(); // print out the shares that would be minted from 1 ether console.log(\"1 ether deposit before donation attack yields _%s_ shares.\", vault.previewDeposit(1 ether)); // provide bob with starting capital asset.mint(bob, 14 ether + 1); // bob performs the donation. With a 1 day wait, it will require 14 times the capital of the other user to issue 0 shares // this is because the vesting schedule follows a linear issuance mechanism over the course of 14 days vm.startPrank(bob); asset.transfer(address(vault), 14 ether + 1); // call the update vesting schedule and wait 1 day for issuance rate to increase vault.updateVestingSchedule(); vm.warp(afterWithdrawalPenalties + (1 days)); // demonstrate that a user who wishes to deposit 1 ether will now be minted 0 shares console.log(\"1 ether deposit after donation attack yields _%s_ shares.\", vault.previewDeposit(1 ether)); }", "labels": ["yAudit", "Severity: Medium", "Difficulty: n/a"]}, {"title": "4. Redistribute event emits incorrect value and could underflow", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md", "body": "Within the executeWithdrawalRequest() function, a user's withdrawal request is processed, shares are transferred from the vault to the user, and the equivalent number of the user's shares are burned. When this internal _burn() function is called, the issuanceRate, totalAssets(), and supply values change. The Redistribute event is then emitted and the value it calculates in its convertToAssets() call is significantly impacted by these changes. Adding the following POC to InstantWithdrawal.t.sol demonstrates that the skewed value can even prevent the last share(s) from being withdrawn from the vault due to an arithmetic underflow: function testExecuteWithdrawalRedistributeUnderflow() public { // Alice deposits 1 ether of underlying asset to the vault // Bob deposits 2 ether of underlying asset to the vault _setUpDepositor(alice, 1 ether); _setUpDepositor(bob, 2 ether); // Allow bob to redeem early as seen in the instantWithdrawalFeeSharing test // This leaves positive yield in the vault for alice vault.redeem(vault.balanceOf(bob), bob, bob); uint256 bobFee_ = _instantWithdrawalFee(2 ether); // == 0.3 ether assertEq(asset.balanceOf(bob), 2 ether - bobFee_); vm.stopPrank(); // Attempt to withdraw our balance as alice // This will throw an arithmetic underflow due to the incorrect calculation in // The Redistribute event vm.startPrank(alice); vault.createWithdrawalRequest(vault.balanceOf(alice)); vault.executeWithdrawalRequest(0); vm.stopPrank(); }", "labels": ["yAudit", "Severity: Medium", "Difficulty: n/a"]}, {"title": "5. Incorrect _burn function in cancelWithdrawalRequest()", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md", "body": "The standard ERC20 _burn() function with two function arguments exists in the contracts inherited from the ERC20 contract, but RevenueDistributionToken has a _burn() function with five function arguments. The latter is what is normally called in LockedRevenueDistributionToken (1, 2, 3) except for in cancelWithdrawalRequest(). The purpose of line 137 is to burn any excess shares beyond what is returned to the staker cancelling their withdrawal request, because in this case the staker will receive the same value of shares (priced in underlying assets) as when they deposited, but this may be a lesser number of shares than they submitted a withdrawal request for. Phrased another way, the accrued value that the shares gained while the contract held the shares is returned to the vault to be shared among shareholders. When the value in the vault has changed, the value of each share should change by updating freeAssets and issuanceRate. But freeAssets and issuanceRate are not updated when _burn() with two function arguments is called. So after cancelWithdrawalRequest() is called, freeAssets and issuanceRate may not be accurate. Specifically, freeAssets could be overinflated by convertToAssets(burnShares_). And if the _burn happens after vestingPeriodFinish, the issuanceRate will not be updated to zero, meaning the return value of totalAssets() would not be accurate.", "labels": ["yAudit", "Severity: Medium", "Difficulty: n/a"]}, {"title": "6. updateVestingSchedule() may not be called on time", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md", "body": "There are two closely related issues here: updateVestingSchedule() can be called any time within 24 hours of vestingPeriodFinish. The optimal strategy for calling updateVestingSchedule() from the perspective of a staker who will withdraw from the vault if the yield is any lower is to 1. call updateVestingSchedule() as soon as possible if issuanceRate will increase from its current value (the rate of rewards distribution increases) or 2. delay calling updateVestingSchedule() until vestingPeriodFinish if issuanceRate will decrease. The issue here is that by delaying the updateVestingSchedule() call, the function may not be called until after vestingPeriodFinish. It may be even further delayed if gas is very high and the staker(s) running bots to automatically call the function determine that the \"lost yield\" from the time where issuanceRate is zero is less than the gas cost of calling vestingPeriodFinish. This is possible because the staker(s) running bots may not have a large number of vault shares. issuanceRate can only be changed in updateVestingSchedule() except when block.timestamp > vestingPeriodFinish. When block.timestamp > vestingPeriodFinish, issuanceRate can be set to zero when the _burn() or _mint() RevenueDistributionToken functions are called. This could be done accidentally, with a normal user wishing to stake into the vault who unknowingly sets issuanceRate to zero while staking their GET. Even if issuanceRate is non-zero, rewards will not be distributed after vestingPeriodFinish due to the math in totalAssets(). Any time that vestingPeriodFinish is less than the current block.timestamp is a zero yield scenario for stakers. In short, an issuanceRate of zero is not good for stakers, but there is a question of who will call updateVestingSchedule() and when they will call it. Competing incentives and a lack of integration with a keeper system like Gelato may result in non-ideal scenarios for all stakers.", "labels": ["yAudit", "Severity: Medium", "Difficulty: n/a"]}, {"title": "7. External call made to non-existent permit function", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md", "body": "The mintWithPermit() and depositWithPermit() functions are intended to allow users to transfer assets to the vault in a single transaction. To achieve this, these functions call permit on the underlying asset with a user's signature that was gathered off-chain. However, the vault's underlying asset is intended to be GET which does not contain a permit function on Ethereum or Polygon.", "labels": ["yAudit", "Severity: Medium", "Difficulty: n/a"]}, {"title": "8. Vault lacks slippage protection", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md", "body": "When an EOA user wants to participate in staking with the vault, they can check what the current exchange rate of their GET and/or xGET will be using functions such as previewDeposit(). Since they are an EOA, they must then wait for this transaction to be mined for it to return results before they can post a new transaction acting on this information. There is no guarantee that the previously returned exchange rate will be the same and in fact it could be drastically different. There are numerous reasons a price change may occur, such as from exploitative front-run attempts, reward distributions, or even the ratio completely resetting if all of the shares have been removed from the vault. ERC-4626 alludes to this issue in its security considerations, and many other protocols in the ecosystem that offer swaps and exchanges have slippage protection mechanisms for their users.", "labels": ["yAudit", "Severity: Medium", "Difficulty: n/a"]}, {"title": "9. Unsafe casting", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md", "body": "OpenZeppelin uses SafeCast in functions like numCheckpoints(), getCurrentVotes(), and getPriorVotes() to prevent overflows due to casting. GovernanceLockedRevenueDistributionToken.sol has similar implementations of numCheckpoints(), getCurrentVotes(), and getPriorVotes() but without SafeCast. The SafeCast library protects against overflows when casting from a large int value to a small int value, and GovernanceLockedRevenueDistributionToken.sol doesn't have any casting overflow protection in the existing contract. A comparison of the numCheckpoints() implementation is compared below. function numCheckpoints(address account_) public view virtual override returns (uint32 numCheckpoints_) { - numCheckpoints_ = uint32(userCheckpoints[account_].length); // this is the GovernanceLockedRevenueDistributionToken.sol implementation + numCheckpoints_ = SafeCast.toUint32(_checkpoints[account].length); // this is how OpenZeppelin implements the casting }", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "10. previewWithdrawalRequest() may return incorrect user's request", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md", "body": "Regardless of what value for owner_ is passed to the previewWithdrawalRequest(), the withdrawal request is gathered based on the msg.sender. The owner_ value is then used to determine if this request should be fee exempt or not. This incorrectly associates the withdrawal request and any corresponding fee exemptions. Adding the following POC to InstantWithdrawal.t.sol demonstrates the issue: function testIncorrectPreviewWithdrawal() public { // Exempt bob from fees vault.setWithdrawalFeeExemption(bob, true); // Create a deposit and withdrawal request for 2 ether for Bob // This should be fee exempt _setUpDepositor(bob, 2 ether); vault.createWithdrawalRequest(vault.balanceOf(bob)); // Create a deposit and withdrawal request for 1 ether for Alice // This should not be fee exempt // Note that the current prank is now using alice's context _setUpDepositor(alice, 1 ether); vault.createWithdrawalRequest(vault.balanceOf(alice)); // Bob should have no withdrawal fees and a balance of 2 ether // so we would expect this to return 2 ether. Instead it returns 1 ether // which is a combination of Alice's withdrawal request and bob's fee exemption (, uint256 bobWithdrawAmount, uint256 bobFee) = vault.previewWithdrawalRequest(0, bob); console.log(\"Amount to withdraw: %s\", bobWithdrawAmount); }", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "11. Withdrawal requests incentivized if issuanceRate is zero", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md", "body": "When a withdrawal request is created, the contract takes and holds the staker's shares until the withdrawal is executed or canceled. The staker receives no interest or yield while the contract holds the shares. But if the interest or yield is zero, stakers are incentivized to submit a withdrawal request because there are no rewards to miss out on when the contract holds the shares, which happens when issuanceRate is zero.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "12. Lack of issuance rate synchronization across chains may lead to uneven voting rewards", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md", "body": "Voting power is denominated in the underlying assets (GET) as opposed to the vault's shares (xGET) to better facilitate voting across chains. This way, stakers on a vault with a lower share to underlying asset exchange rate are not necessarily penalized (as far as voting is concerned). This does not necessarily hold true for reward distribution. Rewards are granted through a vesting schedule whereby an issuanceRate is calculated to issue rewards linearly throughout the vesting period. Since rewards are issued in GET, higher issuanceRate vaults may reward their stakers with more voting power.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "13. Incorrect value getVotes(address account)", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md", "body": "The function is changed from standard one to include additional votes that will be available after the next action from the user. Only after the user write action a new checkpoint is stored for him, with a new vote value.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "14. Lack of input sanitization in the constructor function", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md", "body": "The variables instantWithdrawalFee and lockTime are not checked to be valid in the constructor. constructor( string memory name_, string memory symbol_, address owner_, address asset_, uint256 precision_, uint256 instantWithdrawalFee_, uint256 lockTime_ ) RevenueDistributionToken(name_, symbol_, owner_, asset_, precision_) { instantWithdrawalFee = instantWithdrawalFee_; lockTime = lockTime_; } LockedRevenueDistributionToken.sol#L55-L56", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "15. Add require statement in updateVestingSchedule", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md", "body": "The function updateVestingSchedule allows anyone to update the vesting schedule even if the issuanceRate_ is zero.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "16. Avoid && logic in require statements", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md", "body": "One instance of require with && logic was found.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "17. Use Solidity errors in 0.8.4+", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md", "body": "Require statements are used in the strategy and error messages are not used anywhere. Using this new solidity feature can provide gas savings on revert conditions.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "18. Use unchecked if no underflow risk", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md", "body": "There is at least one location where unchecked can be applied + unchecked { return high_ == 0 ? 0 : (isVotes_ ? _unsafeAccess(ckpts, high_ - 1).votes : _unsafeAccess(ckpts, high_ - 1).shares); + } There is another example of a subtraction operation that can use unchecked for gas savings in LockedRevenueDistributionToken. if (withdrawalFeeExemptions[owner_] || request_.unlockedAt <= block.timestamp) { return (request_, request_.assets, 0); } - uint256 remainingTime_ = request_.unlockedAt - block.timestamp; + uint256 remainingTime_; + unchecked { remainingTime_ = request_.unlockedAt - block.timestamp; }", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "19. Make DELEGATE_TYPEHASH private", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md", "body": "DELEGATE_TYPEHASH is a private constant in the OpenZeppelin contract that the GET contract is based on. This variable is public in the GET GovernanceLockedRevenueDistributionToken.sol contract. Note this has been applied to PERMIT_TYPEHASH already, which is public in OpenZeppelin but private in GET.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "20. Duplicate zero check", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md", "body": "_mint() is always called with the argument shares_ = previewDeposit(assets_) or with assets_ = previewMint(shares_). previewDeposit() rounds down while previewMint() rounds up. This means if assets_ is zero, shares_ will be zero, but it is possible for shares_ to be zero when assets_ is non-zero. Therefore the weaker check of assets_ can be removed. The same change can be made to _burn().", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "21. Duplicate balance check", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md", "body": "createWithdrawalRequest() checks if msg.sender has sufficient shares balance, but the ERC20 transfer a few lines later effectively does the same check, because this subtraction would revert if msg.sender has insufficient shares balance.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "22. Make variables immutable", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md", "body": "The asset state variable in the constructor of RevenueDistributionToken can be declared immutable. In addition, ERC20.sol symbol and name aren't changed after the contract is initialized so they can be immutable.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "23. Make functions external", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md", "body": "getPastTotalSupply() is never called in GovernanceLockedRevenueDistributionToken and can be external instead of public. The change could be applied to delegate() too.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "24. Make variables uint32", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md", "body": "instantWithdrawalFee and lockTime have hard coded maximum values of 100 and MAXIMUM_LOCK_TIME (or 62899200) respectively. These variables are of uint256 type but can be defined as uint32. The same approach can be taken with the constant values MAXIMUM_LOCK_TIME, VESTING_PERIOD, and WITHDRAWAL_WINDOW in the same contract.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "25. Transfer isn't necessary before calling _burn()", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md", "body": "Burn can be performed without the transfer: - _transfer(address(this), msg.sender, request_.shares); - _burn(request_.shares, assets_, msg.sender, msg.sender, msg.sender); + _burn(request_.shares, assets_, msg.sender, address(this), address(this)); LockedRevenueDistributionToken.sol#L159", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "26. Unnecessary nonReentrant protection", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md", "body": "The following functions have an unnecessary non-reentrant check: RevenueDistributionToken.sol#L99 RevenueDistributionToken.sol#111 RevenueDistributionToken.sol#L117 RevenueDistributionToken.sol#L130 RevenueDistributionToken.sol#L138 RevenueDistributionToken.sol#L142 LockedRevenueDistributionToken.sol#L110 LockedRevenueDistributionToken.sol#L127 LockedRevenueDistributionToken.sol#L152 LockedRevenueDistributionToken.sol#L205", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "27. Replace != with >", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md", "body": "In updateVestingSchedule, instead of using != in L181 > can be used for minor gas savings. - require(totalSupply != 0, \"LRDT:UVS:ZERO_SUPPLY\"); + require(totalSupply > 0, \"LRDT:UVS:ZERO_SUPPLY\");", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "28. Emit memory variables in events instead of storage", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md", "body": "In following functions, memory variables can be emitted in events instead of global. setInstantWithdrawalFee - emit InstantWithdrawalFeeChanged(instantWithdrawalFee); + emit InstantWithdrawalFeeChanged(percentage_); setLockTime - emit LockTimeChanged(lockTime); + emit LockTimeChanged(lockTime_);", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "29. Usage of booleans for storage incurs overhead", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md", "body": "In the LockedRevenueDistributionToken.sol file, the withdrawalFeeExemptions mapping maps user address with a boolean flag to indicate fee exemption, which could cost some additional gas. In solidity, booleans (bool) are a bit expensive to use in comparison to other data types because each bool value is stored in a single byte. This means that each bool value requires at least one gas unit to be read or written. In comparison, other data types like uint (unsigned integer) can be stored in much less space, allowing for more efficient use of gas. It's generally more efficient to use other data types, like uint, whenever possible. Read more here: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/58f635312aa21f947cae5f8578638a85aa2519f5/contracts/security/ReentrancyGuard.sol#L23-L27", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "30. Redundant imports can be removed", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md", "body": "GovernanceLockedRevenueDistributionToken.sol imports ERC20.sol. But the ERC20.sol import already exists in LockedRevenueDistributionToken.sol and in RevenueDistributionToken.sol. The ERC20.sol import can be removed from GovernanceLockedRevenueDistributionToken.sol and from LockedRevenueDistributionToken.sol because it will be included from RevenueDistributionToken.sol.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "31. Clarify order of operations", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md", "body": "The Math library is based on OpenZeppelin's Math library. The OpenZeppelin library has parenthesis on these lines but the GET Math library doesn't have these. No issue is expected here, but clarifying the order of operations can make the code easier for readers to understand and make upgrades to future version of solidity less problematic in case the compiler has changes made to the order of operations.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "32. Operational order during minting could be improved", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md", "body": "When a user makes a deposit call in the RevenueDistributionToken.sol contract, the underlying _mint() function with 4 parameters is called. Inside of this function, the user is given their shares before they officially transfer in the underlying asset to the vault. If reentrancy were to occur in a before token transfer hook during this transferFrom call, the vault would have issued shares without receiving assets in return at that point in time. Reordering these operations may make it possible to remove the nonReentrant modifiers on functions that call _mint().", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "33. Abandoned withdrawal shares are irretrievable", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md", "body": "After createWithdrawalRequest() is called, the contract takes possession of the user's shares. But the contract has no way of redeeming these shares that it holds, and there is no time limit for shares to be considered \"abandoned\" or \"forfeited\" if left in the contract. This may be similar to a user transferring their shares to an inaccessible random address, except: The contract holding the shares is the ERC4626 vault contract itself The ERC4626 vault cannot do anything with these shares The user can retrieve these shares if the want, unlike sending them to an irretrievable address", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "34. Shares escrowed for withdrawal can't vote", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md", "body": "The GET Locked Revenue Distribution token contracts hold shares that are waiting to be withdrawn, but these shares are not able to be used for voting because the contract never delegates these shares. Because there is no quorum, this is unlikely to result in altering the outcome of a vote directly, but it would make it easier to potentially swing a vote because the shares held in escrow during the withdrawal process will not vote.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "35. Improve function and variable names", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md", "body": "createWithdrawalRequest() takes a function argument of shares and returns a value in units of assets, but the standard ERC4626 withdraw() does the opposite by taking assets as a function argument and returning a value in units of shares. Instead, the function might be better named createRedeemRequest() if it is going to take a function argument of shares to match the ERC4626 redeem() function. totalAssets_ found in previewRedeem() and previewWithdraw() doesn't related to the return value of totalAssets(). It might be better named preFeeAssets_ or assetsPlusFee_. The Checkpoint array function argument is named ckpts, but this is the same name as the state variable ckpts. Consider removing this function argument if the same state variable will always be accessed when _unsafeAccess() is called.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "36. Use actual GET token contract for tests", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md", "body": "Since the GET token is the ERC20 token that the tests care about, consider using the GET contract code directly. The tests can use a fork of mainnet to use the on-chain contract, or the relevant contract code could be imported. If testing on a fork, consider testing on mainnet and Polygon, the two places where these contracts are planned to be deployed.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "37. Documentation nitpicks", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md", "body": "The Governance section makes no mention of this crucial nuance in the governance logic - that the staker must \"delegate to themselves in order to activate checkpoints and have their voting power tracked\". The list of state variables that can be controlled by governance votes is either incomplete or omits variables that can be changed by the owner outside of governance votes. Specifically, setPendingOwner() and updateVestingSchedule() are not in the list.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "38. Conversion calculations not protected from shadow overflow", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md", "body": "In an expression such as uint256 D = A * B / C, Solidity will attempt to store the intermediary result of A * B before it performs the division by C. If this overflows, then the transaction will revert. The muldiv technique was created to prevent the possibility of an intermediary overflow on calculations that perform both multiplication and division.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "39. Inaccurate comment", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md", "body": "updateVestingSchedule() has a misleading comment description and a typo that misspelled \"Identical\" as \"Intentical\".", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "40. Mainnet deposit delay incentivized due to bridging delay", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md", "body": "The GET token contract on Ethereum is where GET can be minted, but there is a GET contract on Polygon that is properly mapped and registered with Polygon. The GET token is bridged using the Polygon PoS Bridge, which Polygon docs describe as having a delay of 20 minutes to 3 hours. When GET is bridged across by the bridging contract, stakers will be able to see that rewards are going to arrive soon to the xGET contract on mainnet. The prospective stakers may delay the start of their staking for the amount of time it takes for the assets to bridge and earn yield elsewhere during that time.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "41. Influence of blockchain data on xGET rewards", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md", "body": "Because GET tickets are NFTs, the sales of those tickets are visible in real-time. The sales of the tickets may provide insight into the future yield that could be earned by stakers. This is not a security concern per se, but may influence the decision making of stakers to stake sooner or later based on this information and depending on how rewards are transmitted to the contract.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "42. Partial comments", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md", "body": "The function is defined in GovernanceLockedRevenueDistributionToken: https://github.com/GETProtocolDAO/locked-revenue-distribution-token/blob/ab272ced94d6bc8cc1ded2664408a3fa7ce67128/src/GovernanceLockedRevenueDistributionToken.sol#L300.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "43. issuanceRate_ is scaled up", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md", "body": "issuanceRate_ is scaled up using precision.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "44. Use named constants instead of magic numbers", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md", "body": "100 in the following instances should use a constant variable instead: LockedRevenueDistributionToken.sol#L68 LockedRevenueDistributionToken.sol#L265 LockedRevenueDistributionToken.sol#L292 LockedRevenueDistributionToken.sol#L135", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "45. Silence compiler warning for unused variables", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md", "body": "If any function param is not used, do not declare that param with a name in functions maxDeposit, maxMint. For e.g., - function maxDeposit(address receiver_) + function maxDeposit(address)", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "46. Use the latest Solidity version with a stable pragma", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md", "body": "Using a stable pragma ensures that the contract will continue to function as intended even if there are breaking changes in future versions of Solidity. By using a stable pragma, the contract will be locked to a specific version of Solidity, which can help to prevent unexpected behavior or errors if the contract is compiled with a newer version of the compiler. Also consider using the latest version of Solidity since it will include the most up-to-date features, enhancements, and bug fixes, which can help to make the contract more efficient and secure.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "47. Delete doesn't reduce the size of the array", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-GET-Protocol-Staking.md", "body": "delete userWithdrawalRequests[msg.sender][pos_]; LockedRevenueDistributionToken.sol#L131 (LockedRevenueDistributionToken.sol#L157)[https://github.com/GETProtocolDAO/locked-revenue-distribution-token/blob/ab272ced94d6bc8cc1ded2664408a3fa7ce67128/src/LockedRevenueDistributionToken.sol#L157]", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "1. No function to freeze transfers after unfreezing them", "html_url": "https://github.com/yAudit/reports/blob/main/md/09-2022-yFu-NFT.md", "body": "YFUtechne.sol#L16, YFUtechne.sol#L33-L35", "labels": ["yAudit", "Severity: Medium", "Difficulty: n/a"]}, {"title": "2. Fix supportsInterface()", "html_url": "https://github.com/yAudit/reports/blob/main/md/09-2022-yFu-NFT.md", "body": "YFUtechne.sol#L65-L72", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "3. NFT minting might be unfair if demand is high", "html_url": "https://github.com/yAudit/reports/blob/main/md/09-2022-yFu-NFT.md", "body": "YFUtechne.sol#L41-L50", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "4. Add sweep functions for Ether and ERC20 tokens", "html_url": "https://github.com/yAudit/reports/blob/main/md/09-2022-yFu-NFT.md", "body": "YFUtechne.sol", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "5. Use call to transfer Ether", "html_url": "https://github.com/yAudit/reports/blob/main/md/09-2022-yFu-NFT.md", "body": "YFUtechne.sol#L45: The mint fee is transferred to depositAddress as follows: depositAddress.transfer(PRICE);", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "6. Use constant and internal variables", "html_url": "https://github.com/yAudit/reports/blob/main/md/09-2022-yFu-NFT.md", "body": "YFUtechne.sol#L13-L14", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "7. Mark public functions as external", "html_url": "https://github.com/yAudit/reports/blob/main/md/09-2022-yFu-NFT.md", "body": "YFUtechne.sol#L25-L50", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "8. Use OpenZeppelin's Ownable instead of AccessControl", "html_url": "https://github.com/yAudit/reports/blob/main/md/09-2022-yFu-NFT.md", "body": "YFUtechne.sol#L5", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "9. Don't transfer mint fee to depositAddress on each mint", "html_url": "https://github.com/yAudit/reports/blob/main/md/09-2022-yFu-NFT.md", "body": "YFUtechne.sol#L45", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "10. Use uint256 for _tokenIdCounter", "html_url": "https://github.com/yAudit/reports/blob/main/md/09-2022-yFu-NFT.md", "body": "YFUtechne.sol#L11, YFUtechne.sol#L47-L49", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "11. Explore solmate's ERC721 and ERC1155 implementation", "html_url": "https://github.com/yAudit/reports/blob/main/md/09-2022-yFu-NFT.md", "body": "solmate's ERC721.sol, solmate's ERC1155.sol", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "12. Make sure to add / at the end of IPFS base URI", "html_url": "https://github.com/yAudit/reports/blob/main/md/09-2022-yFu-NFT.md", "body": "OpenZeppelin's ERC721.sol#L97", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "13. _beforeTokenTransfer() should be marked as view", "html_url": "https://github.com/yAudit/reports/blob/main/md/09-2022-yFu-NFT.md", "body": "YFUtechne.sol#L52", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "14. Add unit tests to gain confidence", "html_url": "https://github.com/yAudit/reports/blob/main/md/09-2022-yFu-NFT.md", "body": "YFUtechne.sol", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "15. Follow Solidity style guide", "html_url": "https://github.com/yAudit/reports/blob/main/md/09-2022-yFu-NFT.md", "body": "YFUtechne.sol", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "1. Rounded down principal could be carried over in debtor cache struct", "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2023-TempleDAO-Lending-Recheck.md", "body": "The _initDebtorCache() function is in charge of building the cache structure associated with a debtor. While calculating the baseInterest value, the function may eventually overwrite the principal: // Because the shares => debt conversion is rounded down in some scenarios, // there is a chance the `_debtor.principal` outstanding may be // less than this rounded down number. So use the minimum of the two. _debtorCache.principal = _debtorPrincipalAndBaseInterest < _debtorCache.principal ? _debtorPrincipalAndBaseInterest : _debtorCache.principal; // The baseInterest outstanding for this debtor is now the difference. unchecked { _debtorCache.baseInterest = _debtorPrincipalAndBaseInterest - _debtorCache.principal; } As hinted in the comment from the snippet, _debtorPrincipalAndBaseInterest may be lower than the actual principal due to rounding issues. The solution present in the implementation is to take the minimum of these values so that the subtraction to calculate _debtorCache.baseInterest doesn't overflow. While this sounds reasonable (the base interest value would end up being zero in such case), it is important to note that the principal value present in the cache struct is overwritten with a value that is actually lower than the original principal, which may impact other calculations that use the value from the struct. For example, mint() initializes the debtor cache and then uses the principal stored in the cache struct to update the principal value in storage.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "2. Enabled borrow tokens configuration is not cleared when shutting down a strategy", "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2023-TempleDAO-Lending-Recheck.md", "body": "The implementation of the shutdown() function, which is in charge of removing a strategy from the vault, fails to clear the configuration associated with the enabled borrow tokens of a strategy.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "3. G7 treasuryReservesVault optimization not implemented in DsrBaseStrategy", "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2023-TempleDAO-Lending-Recheck.md", "body": "The suggestion to cache treasuryReservesVault in DsrBaseStrategy::trvWithdraw() was not applied but is still applicable.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "4. Change visibility of public constants", "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2023-TempleDAO-Lending-Recheck.md", "body": "This was originally reported as G-06 in the first audit report. Most of the occurrences have been resolved, except the one in AbstractStrategy.sol. The VERSION constant in ThresholdSafeGuard.sol is also marked as public, although this contract doesn't have a separate getter that publishes the constant, as the others do.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "5. Avoid copying calldata to memory in addStrategy()", "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2023-TempleDAO-Lending-Recheck.md", "body": "Line 184 defines a variable in memory that is used to assign each element of the debtCeiling array, which will end up copying the AssetBalance structure from calldata to memory.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "6. Imprecise comment", "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2023-TempleDAO-Lending-Recheck.md", "body": "_debtTokenCache(), _getDebtorCache(), and _getBaseCache() are similar functions in different contracts. The NatSpec describing _debtTokenCache() is Update storage if and only if the state has changed. while the NatSpec for _getBaseCache() and _getDebtorCache() is Update storage if and only if the timestamp has changed since last time. In reality, the functions rely on a timestamp if statement check, not specifically a state change check. The timestamp comment is more accurate and can be applied to both functions. Additional alignment between related caching functions is possible. _initDebtTokenCache() checks if blockTs != interestAccumulatorUpdatedAt while _initBaseCache() and _initDebtorCache() checks if _timeElapsed > 0. Aligning the logic in related functions can reduce overall protocol complexity.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "7. Potential overflow in _initDebtorCache()", "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2023-TempleDAO-Lending-Recheck.md", "body": "In _initDebtorCache() the debtor's principal and current risk premium are added together to calculate the updated risk premium interest. Since the data type of the resulting expression (_debtorTotalDue) is of type uint128 (same as the operands), the calculation may silently overflow due to the usage of unchecked math.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "8. Unchecked statement could overflow", "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2023-TempleDAO-Lending-Recheck.md", "body": "A summation in _mintDToken() newly moved to an unchecked block could hypothetically overflow. The comment before this line hints that the overflow is checked within the dToken.mint(), but this is incorrect. dToken.mint() does not check for an overflow of _newDebt + dTokenBalance, where dTokenBalance is the sum of principal, baseInterest, and riskPremiumInterest. The closest that dToken.mint() achieves is confirming no overflow in the summation _debtorCache.principal + _mintAmountUInt128, but this summation omits the baseInterest and riskPremiumInterest values that are included in dTokenBalance.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "9. Code without math operations doesn't need unchecked", "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2023-TempleDAO-Lending-Recheck.md", "body": "Consider moving the line if (_delta > maxTreasuryPriceIndexDelta) revert BreachedMaxTpiDelta(_oldTpi, _newTpi, maxTreasuryPriceIndexDelta) outside of this unchecked block. The same suggestion applies to debtTokenData.totalDebt = _cache.totalDebt = _newDebt; in _repayTotalDebt().", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "10. currentTotalDebt() can be declared external", "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2023-TempleDAO-Lending-Recheck.md", "body": "currentTotalDebt() is a public function that does not need to be public.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "11. _withdrawFromBaseStrategy() should also revert explicitly if withdrawn amount from base strategy is not enough", "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2023-TempleDAO-Lending-Recheck.md", "body": "The check and the revert was added in line 624 which only covers the else branch of the conditional present in line 591. If there is a base strategy associated with the debt token, it is possible that this strategy may not have the required funds and could potentially return an amount less than what was requested. In such a scenario, the condition may fail to be correctly checked.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "12. Emit RewardTokensSet event in AuraStaking.sol constructor", "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2023-TempleDAO-Lending-Recheck.md", "body": "Given the inclusion of the setRewardTokens() function, which now emits the RewardTokensSet event when the reward tokens array is updated, the constructor of the contract should also emit the same event since it performs an assignment of the same array.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "13. Strategy details could output debt ceiling only for enabled tokens", "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2023-TempleDAO-Lending-Recheck.md", "body": "Both strategyDetails() and strategyBalanceSheet() return information based on all tokens present in the configured set of borrow tokens (i.e. _borrowTokenSet). With the introduction of the enabled borrow tokens feature for each particular strategy, these results could be bound to only the enabled tokens instead of the whole set.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "14. Debt ceiling hook is not triggered when a strategy is added to the vault", "html_url": "https://github.com/yAudit/reports/blob/main/md/08-2023-TempleDAO-Lending-Recheck.md", "body": "The setStrategyDebtCeiling() function fires the debtCeilingUpdated() callback to signal the strategy that its associated debt ceiling has been updated. The same hook is not triggered in the addStrategy() function, which initializes the debt ceiling value for each of the configured tokens for the strategy. Considering the strategy contract is created before being added to the vault, the strategy might not be aware about the eventual configuration and could potentially require this value during its setup.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "1. Possible locking of pool fee funds", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md", "body": "1. Possible locking of pool fee funds", "labels": ["yAudit", "Severity: High", "Difficulty: n/a"]}, {"title": "2. Pools mechanics don't incentivize end goal", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md", "body": "2. Pools mechanics don't incentivize end goal", "labels": ["yAudit", "Severity: High", "Difficulty: n/a"]}, {"title": "3. Flashloan/Whale slippage manipulation", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md", "body": "3. Flashloan/Whale slippage manipulation", "labels": ["yAudit", "Severity: High", "Difficulty: n/a"]}, {"title": "4. Single depositor in pool can steal funds from other pools", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md", "body": "4. Single depositor in pool can steal funds from other pools", "labels": ["yAudit", "Severity: High", "Difficulty: n/a"]}, {"title": "5. allPrices gas grieving causes complete loss of on-chain oracle", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md", "body": "5. allPrices gas grieving causes complete loss of on-chain oracle", "labels": ["yAudit", "Severity: High", "Difficulty: n/a"]}, {"title": "6. Pool drain via Oracle Update Sandwich Attack", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md", "body": "6. Pool drain via Oracle Update Sandwich Attack", "labels": ["yAudit", "Severity: High", "Difficulty: n/a"]}, {"title": "7. Incorrect tolerance for price reported by Chainlink Oracle", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md", "body": "7. Incorrect tolerance for price reported by Chainlink Oracle", "labels": ["yAudit", "Severity: High", "Difficulty: n/a"]}, {"title": "8. Frozen protocol fee when too many pools are deployed", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md", "body": "8. Frozen protocol fee when too many pools are deployed", "labels": ["yAudit", "Severity: High", "Difficulty: n/a"]}, {"title": "9. Planned functionality incentivizes low pool liquidity", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md", "body": "9. Planned functionality incentivizes low pool liquidity", "labels": ["yAudit", "Severity: High", "Difficulty: n/a"]}, {"title": "10. Deposit fees even below 100% CR & withdrawal fees above 100%", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md", "body": "10. Deposit fees even below 100% CR & withdrawal fees above 100%", "labels": ["yAudit", "Severity: High", "Difficulty: n/a"]}, {"title": "11. _getG is not continuous", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md", "body": "11. _getG is not continuous", "labels": ["yAudit", "Severity: High", "Difficulty: n/a"]}, {"title": "12. maxPriceTolerance does not work correctly", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md", "body": "12. maxPriceTolerance does not work correctly", "labels": ["yAudit", "Severity: High", "Difficulty: n/a"]}, {"title": "13. Price updates can be sandwiched", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md", "body": "13. Price updates can be sandwiched", "labels": ["yAudit", "Severity: High", "Difficulty: n/a"]}, {"title": "14. Chainlink oracle may return stale data", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md", "body": "14. Chainlink oracle may return stale data", "labels": ["yAudit", "Severity: Medium", "Difficulty: n/a"]}, {"title": "15. Fee-free deposit() and withdraw() can be gamed", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md", "body": "15. Fee-free deposit() and withdraw() can be gamed", "labels": ["yAudit", "Severity: Medium", "Difficulty: n/a"]}, {"title": "16. Mechanics increase bank run risk", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md", "body": "16. Mechanics increase bank run risk", "labels": ["yAudit", "Severity: Medium", "Difficulty: n/a"]}, {"title": "17. Oracle price lag enables 1% arbitrage opportunities", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md", "body": "17. Oracle price lag enables 1% arbitrage opportunities", "labels": ["yAudit", "Severity: Medium", "Difficulty: n/a"]}, {"title": "18. Slippage calculations are not path independent for large trades", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md", "body": "18. Slippage calculations are not path independent for large trades", "labels": ["yAudit", "Severity: Medium", "Difficulty: n/a"]}, {"title": "19. Reentrancy in SingularityPool.collectFees()", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md", "body": "19. Reentrancy in SingularityPool.collectFees()", "labels": ["yAudit", "Severity: Medium", "Difficulty: n/a"]}, {"title": "20. It can be profitable to split up orders", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md", "body": "20. It can be profitable to split up orders", "labels": ["yAudit", "Severity: Medium", "Difficulty: n/a"]}, {"title": "21. _getG exponentiation can overflow for large CR values", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md", "body": "21. _getG exponentiation can overflow for large CR values", "labels": ["yAudit", "Severity: Medium", "Difficulty: n/a"]}, {"title": "22. Todo comment indicates necessary change", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md", "body": "22. Todo comment indicates necessary change", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "23. Denial of service edge case if onlyUseChainlink is false", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md", "body": "23. Denial of service edge case if onlyUseChainlink is false", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "24. No pool existence check", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md", "body": "24. No pool existence check", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "25. Missing zero address check", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md", "body": "25. Missing zero address check", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "26. g function discontinuity at 0.3", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md", "body": "26. g function discontinuity at 0.3", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "27. Missing two-step transfer ownership pattern", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md", "body": "27. Missing two-step transfer ownership pattern", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "28. Division before multiplication", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md", "body": "28. Division before multiplication", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "29. Deposit cap is inaccurate", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md", "body": "29. Deposit cap is inaccurate", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "30. Use unchecked in SingularityPool.sol", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md", "body": "30. Use unchecked in SingularityPool.sol", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "31. Replace modifiers with internal functions", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md", "body": "31. Replace modifiers with internal functions", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "32. Payable functions can save gas", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md", "body": "32. Payable functions can save gas", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "33. Use short require strings", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md", "body": "33. Use short require strings", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "34. Use Solidity errors in 0.8.4+", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md", "body": "34. Use Solidity errors in 0.8.4+", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "35. Using simple comparison", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md", "body": "35. Using simple comparison", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "36. Using Yul iszero()", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md", "body": "36. Using Yul iszero()", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "37. Replace bool with uint256", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md", "body": "37. Replace bool with uint256", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "38. Declare immutable variables internal when possible", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md", "body": "38. Declare immutable variables internal when possible", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "39. Redundant function", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md", "body": "39. Redundant function", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "40. Remove nonReentrant modifiers", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md", "body": "40. Remove nonReentrant modifiers", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "41. Remove feeA > feeB test in getDepositFee()", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md", "body": "41. Remove feeA > feeB test in getDepositFee()", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "42. Collateral ratio calculations have redundant SLOADs", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md", "body": "42. Collateral ratio calculations have redundant SLOADs", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "43. Replace ProtocolFees state var with Slippage", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md", "body": "43. Replace ProtocolFees state var with Slippage", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "44. Tight variable packing", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md", "body": "44. Tight variable packing", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "45. Use unchecked when there is no risk of overflow or underflow", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md", "body": "45. Use unchecked when there is no risk of overflow or underflow", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "46. Do not load calldata length in memory for loops", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md", "body": "46. Do not load calldata length in memory for loops", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "47. Unnecessary named return variable assignment", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md", "body": "47. Unnecessary named return variable assignment", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "48. Combine accounting updates in swapIn and swapOut", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md", "body": "48. Combine accounting updates in swapIn and swapOut", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "49. Routers can give infinite token approval to pools", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md", "body": "49. Routers can give infinite token approval to pools", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "50. Immutable state variable which is defined as a public variable", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md", "body": "50. Immutable state variable which is defined as a public variable", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "51. Difference from Uniswap's safeTransferFrom() logic", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md", "body": "51. Difference from Uniswap's safeTransferFrom() logic", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "52. Centralization risk with admin role", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md", "body": "52. Centralization risk with admin role", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "53. baseFee value not limited", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md", "body": "53. baseFee value not limited", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "54. No way to remove pools", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md", "body": "54. No way to remove pools", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "55. Fee-on-transfer tokens not supported", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md", "body": "55. Fee-on-transfer tokens not supported", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "56. Documentation inconsistencies", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md", "body": "56. Documentation inconsistencies", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "57. Decimals value borrowed from underlying ERC20", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md", "body": "57. Decimals value borrowed from underlying ERC20", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "58. Typo", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md", "body": "58. Typo", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "59. nonReentrant modifier is specific to each pool", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md", "body": "59. nonReentrant modifier is specific to each pool", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "60. Pool may not be able to reach depositCap", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md", "body": "60. Pool may not be able to reach depositCap", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "61. Incorrect balance accounting for fee-on-transfer and rebasing tokens", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md", "body": "USDT has a zero fee on transfer but it can be turned in future, resulting in lower funds in pool. Consider its transfer() function  function transfer(address _to, uint _value) public onlyPayloadSize(2 * 32) { uint fee = (_value.mul(basisPointsRate)).div(10000); if (fee > maximumFee) { fee = maximumFee; } uint sendAmount = _value.sub(fee); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(sendAmount); if (fee > 0) { balances[owner] = balances[owner].add(fee); Transfer(msg.sender, owner, fee); } Transfer(msg.sender, _to, sendAmount); } 2. Informational - Reduce footgun risk of deposit() and withdraw() (devtooligan) The dev team has confirmed that the deposit() and withdraw() functions are intentionally \"low-level functions\" that could result in loss if the caller is not careful. While true, we still recommend mitigating the risk of misuse as a kind of public good. The lowest cost way of reducing this risk is through natspec on the functions with a clear warning to callers of the potential pitfalls. Another potential solution to consider that would greatly eliminate this risk would be by adding the minIn / minOut params to the internal swapIn() swapOut() fns, thereby forcing the caller to intentionally pass 0 if they really did not want slippage protection. This would slightly add to the overall runtime gas profile but the difference would be negligible. It costs much less gas to do this than to, for example, call routerOnly which incurs a cold SLOAD. Guest auditors Informational Findings 1. Informational - Code does not match docs", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "62. Reduce footgun risk of deposit() and withdraw()", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md", "body": "USDT has a zero fee on transfer but it can be turned in future, resulting in lower funds in pool. Consider its transfer() function  function transfer(address _to, uint _value) public onlyPayloadSize(2 * 32) { uint fee = (_value.mul(basisPointsRate)).div(10000); if (fee > maximumFee) { fee = maximumFee; } uint sendAmount = _value.sub(fee); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(sendAmount); if (fee > 0) { balances[owner] = balances[owner].add(fee); Transfer(msg.sender, owner, fee); } Transfer(msg.sender, _to, sendAmount); } 2. Informational - Reduce footgun risk of deposit() and withdraw() (devtooligan) The dev team has confirmed that the deposit() and withdraw() functions are intentionally \"low-level functions\" that could result in loss if the caller is not careful. While true, we still recommend mitigating the risk of misuse as a kind of public good. The lowest cost way of reducing this risk is through natspec on the functions with a clear warning to callers of the potential pitfalls. Another potential solution to consider that would greatly eliminate this risk would be by adding the minIn / minOut params to the internal swapIn() swapOut() fns, thereby forcing the caller to intentionally pass 0 if they really did not want slippage protection. This would slightly add to the overall runtime gas profile but the difference would be negligible. It costs much less gas to do this than to, for example, call routerOnly which incurs a cold SLOAD. Guest auditors Informational Findings 1. Informational - Code does not match docs", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "63. Code does not match docs", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md", "body": "USDT has a zero fee on transfer but it can be turned in future, resulting in lower funds in pool. Consider its transfer() function  function transfer(address _to, uint _value) public onlyPayloadSize(2 * 32) { uint fee = (_value.mul(basisPointsRate)).div(10000); if (fee > maximumFee) { fee = maximumFee; } uint sendAmount = _value.sub(fee); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(sendAmount); if (fee > 0) { balances[owner] = balances[owner].add(fee); Transfer(msg.sender, owner, fee); } Transfer(msg.sender, _to, sendAmount); } 2. Informational - Reduce footgun risk of deposit() and withdraw() (devtooligan) The dev team has confirmed that the deposit() and withdraw() functions are intentionally \"low-level functions\" that could result in loss if the caller is not careful. While true, we still recommend mitigating the risk of misuse as a kind of public good. The lowest cost way of reducing this risk is through natspec on the functions with a clear warning to callers of the potential pitfalls. Another potential solution to consider that would greatly eliminate this risk would be by adding the minIn / minOut params to the internal swapIn() swapOut() fns, thereby forcing the caller to intentionally pass 0 if they really did not want slippage protection. This would slightly add to the overall runtime gas profile but the difference would be negligible. It costs much less gas to do this than to, for example, call routerOnly which incurs a cold SLOAD. Guest auditors Informational Findings 1. Informational - Code does not match docs", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "64. Just-in-time LP provision can be profitable", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md", "body": "USDT has a zero fee on transfer but it can be turned in future, resulting in lower funds in pool. Consider its transfer() function  function transfer(address _to, uint _value) public onlyPayloadSize(2 * 32) { uint fee = (_value.mul(basisPointsRate)).div(10000); if (fee > maximumFee) { fee = maximumFee; } uint sendAmount = _value.sub(fee); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(sendAmount); if (fee > 0) { balances[owner] = balances[owner].add(fee); Transfer(msg.sender, owner, fee); } Transfer(msg.sender, _to, sendAmount); } 2. Informational - Reduce footgun risk of deposit() and withdraw() (devtooligan) The dev team has confirmed that the deposit() and withdraw() functions are intentionally \"low-level functions\" that could result in loss if the caller is not careful. While true, we still recommend mitigating the risk of misuse as a kind of public good. The lowest cost way of reducing this risk is through natspec on the functions with a clear warning to callers of the potential pitfalls. Another potential solution to consider that would greatly eliminate this risk would be by adding the minIn / minOut params to the internal swapIn() swapOut() fns, thereby forcing the caller to intentionally pass 0 if they really did not want slippage protection. This would slightly add to the overall runtime gas profile but the difference would be negligible. It costs much less gas to do this than to, for example, call routerOnly which incurs a cold SLOAD. Guest auditors Informational Findings 1. Informational - Code does not match docs", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "65. Potentially misleading description of \"no impermanent loss\"", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md", "body": "USDT has a zero fee on transfer but it can be turned in future, resulting in lower funds in pool. Consider its transfer() function  function transfer(address _to, uint _value) public onlyPayloadSize(2 * 32) { uint fee = (_value.mul(basisPointsRate)).div(10000); if (fee > maximumFee) { fee = maximumFee; } uint sendAmount = _value.sub(fee); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(sendAmount); if (fee > 0) { balances[owner] = balances[owner].add(fee); Transfer(msg.sender, owner, fee); } Transfer(msg.sender, _to, sendAmount); } 2. Informational - Reduce footgun risk of deposit() and withdraw() (devtooligan) The dev team has confirmed that the deposit() and withdraw() functions are intentionally \"low-level functions\" that could result in loss if the caller is not careful. While true, we still recommend mitigating the risk of misuse as a kind of public good. The lowest cost way of reducing this risk is through natspec on the functions with a clear warning to callers of the potential pitfalls. Another potential solution to consider that would greatly eliminate this risk would be by adding the minIn / minOut params to the internal swapIn() swapOut() fns, thereby forcing the caller to intentionally pass 0 if they really did not want slippage protection. This would slightly add to the overall runtime gas profile but the difference would be negligible. It costs much less gas to do this than to, for example, call routerOnly which incurs a cold SLOAD. Guest auditors Informational Findings 1. Informational - Code does not match docs", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "66. Miscellaneous", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Singularity.md", "body": "USDT has a zero fee on transfer but it can be turned in future, resulting in lower funds in pool. Consider its transfer() function  function transfer(address _to, uint _value) public onlyPayloadSize(2 * 32) { uint fee = (_value.mul(basisPointsRate)).div(10000); if (fee > maximumFee) { fee = maximumFee; } uint sendAmount = _value.sub(fee); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(sendAmount); if (fee > 0) { balances[owner] = balances[owner].add(fee); Transfer(msg.sender, owner, fee); } Transfer(msg.sender, _to, sendAmount); } 2. Informational - Reduce footgun risk of deposit() and withdraw() (devtooligan) The dev team has confirmed that the deposit() and withdraw() functions are intentionally \"low-level functions\" that could result in loss if the caller is not careful. While true, we still recommend mitigating the risk of misuse as a kind of public good. The lowest cost way of reducing this risk is through natspec on the functions with a clear warning to callers of the potential pitfalls. Another potential solution to consider that would greatly eliminate this risk would be by adding the minIn / minOut params to the internal swapIn() swapOut() fns, thereby forcing the caller to intentionally pass 0 if they really did not want slippage protection. This would slightly add to the overall runtime gas profile but the difference would be negligible. It costs much less gas to do this than to, for example, call routerOnly which incurs a cold SLOAD. Guest auditors Informational Findings 1. Informational - Code does not match docs", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "1. Incorrect ratios used for delta neutral rebalancing", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-RageTrade.md", "body": "Rage Trade relies on providing liquidity to the GMX protocol for long exposure to WETH and WBTC. The GMX Vault is where all GMX protocol underlying assets are stored. The GMX vault has a target weight for each underlying asset, but the target weight is not the same as the current weight of the asset in the vault during a specific block. The actual weights of the tokens The Rage Trade rebalancing approach uses the ideal target weight, not the actual current weight of the asset. This means the Rage trade strategy is not actually delta neutral because it assumes an ideal mix of underlying assets when holding GLP and doesn't consider the current underlying assets. To demonstrate the issue, data was taken from the Arbitrum blockchain to plot the exposure that Rage Trade has had to the underlying assets WETH and WBTC since around the time that the delta neutral strategy began receiving funds. The short exposure takes the form of WETH or WBTC borrowed from Aave. To calculate this percentage, the amount of WETH or WBTC borrowed was multiplied by the price of the asset and then divided by the total value of GLP held by the Rage trade strategy. The short exposure does a good job of targeting the 35% and 15% marks for WETH and WBTC respectively. The 35% and 15% marks are the target allocations for the GMX vault to hold of WETH and WBTC. The long exposure takes the form of GLP, which holds roughly 50% stablecoins and 50% WETH and WBTC. The data for the exposure to WETH and WBTC was taken from at stats.gmx.io during the same period as the short position exposure chart. The comparison of the short and long exposure to WETH and WBTC is shown below. As the charts demonstrate, since the deployment of Rage Trade in December 2022, the GMX vault, and therefore GLP, has consistently held more WBTC and less WETH than the GMX vault target weights. But the Rage Trade short positions do not reflect this, and instead use the target weights to determine the ideal short exposure to these assets. In its current form, Rage Trade has held a position of long WBTC and short WETH since it was deployed. Examining the asset exposure in the GMX Vault over the entire duration of GMX's history, it is more apparent how far the asset allocations can stray from the target. The second figure below focuses on the less volatile period of GMX asset allocation in 2022 to provide a closer look at how different the asset allocation is from the 35% WETH and 15% WBTC targets. Since June 2022, the GMX vault has mostly been overweight in WBTC and underweight in WETH, but sometimes it is overweight in both assets. Focusing on more \"extreme\" changes in the asset allocations of the vault, the vault held a total of 39.4% in WETH and WBTC combined on May 26 2022, but that rose to 54% on July 24 2022, less than 2 months later. If this strategy was active at this time, it would have had too large of a short position and too small of a long position. It is true that during this time the value of WETH and WBTC dropped by around 22%, so in actuality these months would have been profitable for this strategy, but a reverse scenario where the assets increased by 22% in value would have left the strategy at a loss. Even if the above scenario where the strategy is weighted in the wrong direction of market movements does not occur, another risk is if the correlation between WETH and WBTC prices change significantly. It's possible there is an implied assumption that WETH and WBTC prices are correlated, so as long as the sum of allocations WETH and WBTC in the GMX vault is roughly 50% of the GMX vault, then the long position should neutralize the short position. But if the WETH/WBTC price correlation changes while they GMX vault allocations are not near the targets, this could be problematic. The chart from CoinGecko shows this ratio over the last two years and demonstrates that it can easily change by 10% or more in a short timespan. In summary, the risk this issue highlights includes: strategy losses from when WETH and WBTC positions are overweighted towards a long position and the prices of these assets drops. The reverse can also happen, where WETH and WBTC positions are underweighted towards a long position and the prices of these assets rises. strategy losses from when WETH and WBTC weights in the GMX vault are not at the target weights and the WETH/WBTC price ratio changes in the wrong direction from how the GMX vault (and therefore the Rage Trade strategy) is weighted.", "labels": ["yAudit", "Severity: High", "Difficulty: n/a"]}, {"title": "2. Junior vault getPriceX128() has wrong decimals", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-RageTrade.md", "body": "The term X128 as used in Uniswap documentation indicates a Q128 value. This means that the value should be divided by 1 << 128 to get the actual value that it represents. Examining getPriceX128() in the junior vault finds a problem. The return value is aum.mulDiv(1 << 128, totalSupply * 1e24). This is similar to the previous junior vault example. aum is 1E12, but the denominator is totalSupply of 1E18 multiplied by 1E24. This leaves the numerator with 1E12 but the denominator with 1E42, the resulting values is not correct. When the value of getPriceX128() in the existing on-chain deployment is divided by 1 << 128, the resulting value is 8.34E-13. In contrast, the price of GLP is $0.834 and the return value of getPrice(bool) in the junior vault with 18 decimals like GLP is 0.834E18. We can apply the same approach to getPriceX128() in the senior vault and find that it is implemented correctly. We can double check the decimals of the return value price.mulDiv(1 << 128, 1e8). price is 1E8 and it is divided by 1E8, so the price value is properly multiplied by 1 << 128. We can also confirm the decimals in getPrice(bool) in the junior vault are correct. The price value is documented in GMX docs: The sell price would be getAum(false) / glpSupply getPrice(bool) returns aum.mulDivDown(PRICE_PRECISION, totalSupply * 1e24). aum is 1E12, PRICE_PRECISION is 1E30, totalSupply is 1E18 and it is multiplied by 1E24. This results in 1E12 * 1E30 / (1E18 * 1E24) = 1E42 / 1E42 = 1. And because GLP has a decimals value of 18, the value is returned with 18 decimals. The return value can be confirmed against the GLP price in the GMX frontend.", "labels": ["yAudit", "Severity: Medium", "Difficulty: n/a"]}, {"title": "3. maxWithdraw() and maxRedeem() are inaccurate if Aave pool doesn't permit withdrawals", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-RageTrade.md", "body": "EIP4626 states the following requirements for maxRedeem(): Maximum amount of Vault shares that can be redeemed from the owner balance in the Vault, through a redeem call. MUST return the maximum amount of shares that could be transferred from owner through redeem and not cause a revert, which MUST NOT be higher than the actual maximum that would be accepted (it should underestimate if necessary). MUST factor in both global and user-specific limits, like if redemption is entirely disabled (even temporarily) it MUST return 0. If an Aave pool is paused or inactive, maxWithdraw() and maxRedeem() in the senior vault should return zero. The functions currently do not. Currently the senior vault is not compliant with the ERC4626 spec if the Aave pool is inactive or paused. maxMint() and maxDeposit() should also have a similar change.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "4. maxMint() and maxDeposit() are inaccurate if Aave pool is frozen", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-RageTrade.md", "body": "EIP4626 states the following requirements for maxMint(): MUST return the maximum amount of shares mint would allow to be deposited to receiver and not cause a revert, which MUST NOT be higher than the actual maximum that would be accepted (it should underestimate if necessary). This assumes that the user has infinite assets, i.e. MUST NOT rely on balanceOf of asset. MUST factor in both global and user-specific limits, like if mints are entirely disabled (even temporarily) it MUST return 0. If an Aave pool is frozen, Aave documentation states it will not accept deposits. Therefore maxMint() and maxDeposit() should return zero in this case. The functions currently do not. Currently the senior vault is not compliant with the ERC4626 spec if the Aave pool is frozen.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "5. setGmxParams() doesn't update dependent variable", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-RageTrade.md", "body": "The value state.glpManager can be updated in setGmxParams() by the owner. The value state.gmxVault is set in initialize() by calling vault() in state.glpManager. When state.glpManager is updated, the value state.gmxVault is not updated, which may leave the gmx vault variable outdated.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "6. Biased delta neutral position", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-RageTrade.md", "body": "The junior vault attempts to hold equal long and short positions to maintain a delta neutral position in the market. The reason this is done is to avoid impermanent loss, which is a common problem for liquidity providers. The junior vault holds a short position by borrowing WETH and WBTC from Aave (after depositing USDC to maintain a reasonable health factor). The junior vault holds an equal long position by holding GLP (technically fsGLP, the staked version of GLP) which consists of a basket of underlying assets mostly consistently of WETH, WBTC and stablecoins. There are two small ways in which the Rage Trade delta neutral strategy has bias in its holdings that could create unwanted exposure to certain assets. A consistent bias over the long run can impact yield returns to depositors because impermanent loss may cause losses in the long run. The GLP vault does not hold exactly 50% WETH & WBTC with the remaining 50% in stablecoins. It targets a holding of 1% LINK and 1% UNI, so in reality the targeted exposure is 35% WETH, 15% WBTC, 1% UNI, 1% LINK, and 50% stablecoins. The delta neutral strategy has no short position to cover the long exposure held in UNI or LINK. Although the percentage of UNI and LINK holdings is small, this exposure can result in non-zero impermanent loss over the long run. If there is an assumption that UNI and LINK prices are correlated to WETH and WBTC, then the value of the short positions should be increased to roughly 52% of the GLP value, rather than the currently targeted 50%. LINK is an asset that can be borrowed and shorted on Aave like WETH and WBTC currently are, an approach which would maintain a more precise neutral position. The second bias is that the process that rebalances the junior vault holdings consistently has more long exposure than short. This can be seen on the long timescale where the ratio is targeting 2 (the reason the target ratio is 2 and not 1 is because only 50% of the holdings in the GMX vault are WETH and WBTC) but the actual value is consistently above 2. Zooming in on the shorter timescale, observe the point in time when a rebalance happens in the middle of this plot. While the rebalance brings the ratio closer to 2, it could do better, and this inaccuracy may be due to an inaccuracy in the implementation's math.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "7. Make functions external", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-RageTrade.md", "body": "Make getVaultMarketValue() in the senior vault and the junior vault external, not public. The same can be done for getPriceX128() in the senior vault and the junior vault. getPriceX128() in the senior vault includes a comment that it is only used in the frontend.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "8. Immutable variables are cheaper", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-RageTrade.md", "body": "pool can be immutable for gas savings.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "9. Remove unused function", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-RageTrade.md", "body": "getMaxVariableBorrowRate() is not used in any contracts in the Rage Trade repo and can be removed.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "10. Remove duplicate length check", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-RageTrade.md", "body": "The array length check in _executeFlashloan() is unnecessary because it is duplicated a few lines later when the Balancer vault flashloan() call happens.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "11. Unnecessary addition operation", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-RageTrade.md", "body": "usdcBorrowed is zero at the start of totalUsdcBorrowed(), so the line can be changed to: - if (address(leveragePool) != address(0)) usdcBorrowed += leveragePool.getUsdcBorrowed(); + if (address(leveragePool) != address(0)) usdcBorrowed = leveragePool.getUsdcBorrowed();", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "12. No way to remove approvals", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-RageTrade.md", "body": "grantAllowances() in the junior vault and senior vault exists solely to set the allowances for the vault, even though these are set in the initializer(). It may also be useful to have a way to remove these allowances. For example, if the Aave pool address is updated or there is a security concern with an approved contract, it may be useful to remove the approval. But there is currently no ability to do this with the vaults. This ability may be useful to introduce because a paused vault will not prevent tokens from being withdrawn by an approved address when an infinite allowance is set.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "13. Move Aave pool and oracle update to new function", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-RageTrade.md", "body": "The second half of setHedgeParams() is unrelated to the first half and may not be necessary to use each time the other state variables are updated. Consider moving the second half of setHedgeParams() to a separate function.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "14. Unused dependencies imported", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-RageTrade.md", "body": "The WadRayMath import from Aave V3 is never used by DnGmxJuniorVault. The same applies to IRewardTracker.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "15. Hypothetical revert condition breaks EIP4626 requirements", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-RageTrade.md", "body": "EIP4626 states totalAssets() has the requirement that it MUST NOT revert. But in the senior vault, the call flow totalAssets() -> totalUsdcBorrowed() -> dnGmxJuniorVault.getUsdcBorrowed() -> .toInt256() calls a SafeCast function that could revert if the uint256 value in getUsdcBorrowed() is greater than or equal to 2**255. It is unlikely that Rage Trade will hold this much value, which would equate to 2**249 dollars of value, but totalAssets() would revert in such a case.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "16. Replace magic numbers with constants", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-RageTrade.md", "body": "There are many instances of magic numbers with powers of ten. Consider replacing these magic numbers with a constant internal variable, which is already done in some cases like PRICE_PRECISION. Some examples are these magic numbers 1e12, 1e14, 1e16, and 1e30.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "17. Unnecessary reimplementation of GMX functions", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-RageTrade.md", "body": "The junior vault's getPrice() and the junior vault manager's _getGlpPrice() functions are identical other than the different of the state function argument. Furthermore, these functions reimplement a function named getPrice() in GlpManager that returns the GLP price. In fact, the return value and decimals of the junior vault's getPrice() and getPrice() in GlpManager is identical, so arguably the function isn't needed at all and the GlpManager contract can be called directly when needed. The same applies to the first half of _getGlpPriceInUsdc() in the junior vault manager.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "18. Library functions with unusual visibility", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-RageTrade.md", "body": "A library is slightly different than a contract in that the functions in a library are only accessible to the contract that imports the library. This means the junior vault manager library can remove any external functions that are declared external in the library but are not called by the junior vault (which is the only contract that imports the library). Such functions include getTokenReservesInGlp(), rebalanceBorrow(), getTokenPrice(), getGlpPrice(), getGlpPriceInUsdc(), getTokenPriceInUsdc(), getLiquidationThreshold(), flashloanAmounts(), getOptimalCappedBorrows(), getTokenReservesInGlp(), and isWithinAllowedDelta(). Another change that could be made with the library is combining external and internal functions if the external function only calls the internal function.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "19. Functions altering state variables missing events", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-RageTrade.md", "body": "Some functions that modify state variables do not emit events: updateFeeStrategyParams() unstakeAndVestEsGmx() stopVestAndStakeEsGmx() claimVestedGmx()", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "20. Dead link in ERC4626Upgradeable.sol comment", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-RageTrade.md", "body": "This link points to a repo that no longer exists.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "21. Move excessUtilizationRate calculation in calculateFeeSplit() into if statement", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-RageTrade.md", "body": "This line can be moved inside the if statement.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "1. Inaccurate rounding from maximize", "html_url": "https://github.com/yAudit/reports/blob/main/md/02-2023-RageTrade-Upgrade.md", "body": "There are two locations where mulDivDown() uses _getGlpPriceInUsdc(state, maximize) in the denominator and one place where _getGlpPriceInUsdc(state, !maximize) is in the denominator. This inconsistency indicates a bug. If a fraction is intended to be maximized (with maximize set to true), then the denominator should be reduced (with maximize set to false). If the fraction is intended to be minimized (with maximize set to false), then the denominator should be increased (with maximize set to true). This indicates that the correct value of maximize when it is used in the denominator is inverted from the value it holds in the current function. The two cases where this is not done, line 1140 and line 1146, should be fixed to align to line 1172.", "labels": ["yAudit", "Severity: Medium", "Difficulty: n/a"]}, {"title": "2. Loss of precision can lead to loss of value", "html_url": "https://github.com/yAudit/reports/blob/main/md/02-2023-RageTrade-Upgrade.md", "body": "The calculation of minTokenOut in _convertToToken() is done in a way where the value is reduced to 6 decimals of precision, then increased to the number of decimals needed for that specific token. This process means that all digits beyond the first 6 decimals of precision will be zeros. This effectively rounds down the value, which increases the amount of possible slippage from the value targeted by the slippageThreshold value. This could result in minor loss of value.", "labels": ["yAudit", "Severity: Medium", "Difficulty: n/a"]}, {"title": "3. Possible underflow could cause revert", "html_url": "https://github.com/yAudit/reports/blob/main/md/02-2023-RageTrade-Upgrade.md", "body": "A comment in _executeVaultUserBatchStake() attempts to explain why _roundUsdcBalance will be always >= _usdcToConvert, but the logic does not hold up. Take the following example scenario. Starting values: usdcAmountToConvert = 1 _roundUsdcBalance = 2 minUsdcConversionAmount = 4 Logical steps After line 388: _usdcToConvert = 1 After line 397: _usdcToConvert = 4 _roundUsdcBalance - _usdcToConvert will underflow on line 399 because _roundUsdcBalance = 2 while _usdcToConvert = 4 The same logic is found in DnGmxBatchingManagerGlp.sol.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "4. Cannot undo infinite approval", "html_url": "https://github.com/yAudit/reports/blob/main/md/02-2023-RageTrade-Upgrade.md", "body": "grantAllowances() in the batching managers gives an infinite approval of sGLP to dnGmxJuniorVault, but there is no way to undo this approval. It may be useful to add a function argument to grantAllowances() to allow a custom approval value to be set, including an approval of zero. While the batching managers are implemented behind proxies, in the event that the approval needs to be removed, response time will likely be important so it is preferable to have failsafes in place before they are needed. Because dnGmxJuniorVault is implemented behind a proxy, the code at that address today may differ from the code at that address in the future, making safety measures more important.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "5. abs() reverts for type(int256).min", "html_url": "https://github.com/yAudit/reports/blob/main/md/02-2023-RageTrade-Upgrade.md", "body": "The abs() implementation in SignedFixedPointMathLib is not from OpenZeppelin's SignedMath. OpenZeppelin's code has a comment indicating unchecked must be used to support the argument value of type(int256).min. The current abs() implementation reverts on this value. Because mulDivDown() relies on this abs() implementation, it too would revert in the case of x == type(int256).min.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "6. Missing assert risks casting overflow", "html_url": "https://github.com/yAudit/reports/blob/main/md/02-2023-RageTrade-Upgrade.md", "body": "_calculateSwapLoss() contains two casting operations where a value is negated. In the second case, it is clear that the negation will make tokenAmount positive because tokenAmount is less than zero in that code branch. But in the first case, it is not clear that the negation will make otherTokenAmount positive rather than negative. _calculateSwapLoss() is called with values returned from QuoterLib.quoteCombinedSwap(). quoteCombinedSwap() contains an assert that validates ethAmountInEthSwap and usdcAmountInEthSwap have opposite signs. But there is no similar check to confirm btcAmountInBtcSwap and usdcAmountInBtcSwap have opposite signs. This means the _calculateSwapLoss() call with BTC values may have a chance of a casting overflow because there is no assertion to guarantee avoidance of this case.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "7. Combine zero checks", "html_url": "https://github.com/yAudit/reports/blob/main/md/02-2023-RageTrade-Upgrade.md", "body": "In batching manager, when executeBatch() is called it checks if the function argument is zero and then later checks if a value derived from the argument is zero. The first check can be removed, because if the function argument is zero it will be caught in the second check. The same logic is in DnGmxBatchingManagerGlp.sol.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "8. Use unchecked if no underflow risk", "html_url": "https://github.com/yAudit/reports/blob/main/md/02-2023-RageTrade-Upgrade.md", "body": "There is at least one example where unchecked can be applied, because the line before the subtraction prevents an underflow: - userDeposit.unclaimedShares = userUnclaimedShares - amount.toUint128(); + unchecked { userDeposit.unclaimedShares = userUnclaimedShares - amount.toUint128(); } The same modification could be made to DnGmxBatchingManagerGlp.sol.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "9. Use cached value", "html_url": "https://github.com/yAudit/reports/blob/main/md/02-2023-RageTrade-Upgrade.md", "body": "userDeposit.usdcBalance is cached in userUsdcBalance in depositUsdc(). This cached value can be used instead of userDeposit.usdcBalance on line 225. This optimization is already used later in the same contract. The same edit can be made in DnGmxBatchingManagerGlp.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "10. Remove unused functions", "html_url": "https://github.com/yAudit/reports/blob/main/md/02-2023-RageTrade-Upgrade.md", "body": "simulateSwap() with 4 function arguments is not used anywhere and can safely be removed from Simulate.sol to save some gas on deployment. The onlyDnGmxJuniorVault modifier is declared in DnGmxBatchingManager and DnGmxBatchingManagerGlp but is never used in Rage Trade. These modifier declarations can be removed.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "11. Consider refactoring", "html_url": "https://github.com/yAudit/reports/blob/main/md/02-2023-RageTrade-Upgrade.md", "body": "_getMaxTokenHedgeAmount() is nearly identical to _getTokenHedgeAmount(). The only difference is in the last line of these functions. _getTokenHedgeAmount() could be replaced with _getMaxTokenHedgeAmount() * _traderOIHedgeBps / MAX_BPS.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "12. Update and improve comments", "html_url": "https://github.com/yAudit/reports/blob/main/md/02-2023-RageTrade-Upgrade.md", "body": "Several improvements can be made in comments: DnGmxBatchingManagerGlp.sol now handles USDC instead of GLP. Many comments still reference GLP but should now mention USDC. For example, this comment and this comment in depositUsdc() should say USDC not sGLP. There are other comments that also need updating to reflect the switch to using USDC. slippageThresholdGmxBps in DnGmxBatchingManager is used for USDC slippage but also WETH slippage in rescueFees(). This comment only mentions USDC but should mention WETH. _getMaxTokenHedgeAmount() is nearly identical to _getTokenHedgeAmount() but the comments of the two functions are identical. The difference is that _getTokenHedgeAmount() returns a value multiplied by _traderOIHedgeBps. This difference in not reflect in the comments of the function.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "13. Efficiency improvement", "html_url": "https://github.com/yAudit/reports/blob/main/md/02-2023-RageTrade-Upgrade.md", "body": "The tokenTraderOIMax function argument for the function _checkTokenHedgeAmount() is returned from _getMaxTokenHedgeAmount(). This returned value should always be positive. This means tokenTraderOIMax.sign() == 1, so _checkTokenHedgeAmount() can be simplified with the following: function _checkTokenHedgeAmount(int256 tokenTraderOIHedge, int256 tokenTraderOIMax) internal pure returns (bool) { - if (tokenTraderOIHedge.sign() * tokenTraderOIMax.sign() < 0) return false; + if (tokenTraderOIHedge.sign() < 0) return false; - if (tokenTraderOIHedge.abs() > tokenTraderOIMax.abs()) return false; + if (tokenTraderOIHedge > tokenTraderOIMax) return false; return true; }", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "14. Migration requires managing slot reuse", "html_url": "https://github.com/yAudit/reports/blob/main/md/02-2023-RageTrade-Upgrade.md", "body": "In DnGmxBatchingManager.sol, the glpDepositPendingThreshold variable in the old contract version is renamed to minUsdcConversionAmount in the new contract version. This storage slot used to store an amount of GLP but now stores an amount of USDC. If the logic contract behind the proxy is upgraded before this storage slot value is changed, a well-timed attack may be able to take advantage of the incorrect value. Similarly, the deprecated variables should be set to zero before the upgrade. While roundGlpDepositPending is already set to zero, the private bypass variable is not, so setBypass() should be called before the upgrade, otherwise the variable will remain set. batchingManager in", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "15. Use updated solmate import", "html_url": "https://github.com/yAudit/reports/blob/main/md/02-2023-RageTrade-Upgrade.md", "body": "Consider replacing the outdated reference in package.json and multiple solidity files to use the current location of the solmate library. This will help to ensure the latest bug fixes and improvements are used.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "16. Possible mulDivDown confusion", "html_url": "https://github.com/yAudit/reports/blob/main/md/02-2023-RageTrade-Upgrade.md", "body": "Consider renaming the custom mulDivDown() implementation to indicate the first argument is a int256, not a uint256 like the solmate implementation of mulDivDown(). One place where this ambiguity may cause confusion is this line. Solidity will prevent an underflow from happening, so the solmate implementation will be used if no revert happens, but should an underflow be allowed here with unchecked to allow the custom implementation to be used?", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "17. Unnecessary operations", "html_url": "https://github.com/yAudit/reports/blob/main/md/02-2023-RageTrade-Upgrade.md", "body": "This line unnecessarily casts netSlippage to uint256 when it is already of that type. This line emits an event with the constant value of address(0). Because this event is used in only this one location, there is no point in this event taking a constant value.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "18. Change variable name", "html_url": "https://github.com/yAudit/reports/blob/main/md/02-2023-RageTrade-Upgrade.md", "body": "The variables name unhedgedGlp is used in two places in DnGmxJuniorVaultManager. Only the second case of this variable actually refers to the exact value of unhedged GLP maintained by Rage Trade, while the first case actually refers to the target amount of unhedged GLP that the protocol should rebalance to.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "19. Missing NatSpec comments", "html_url": "https://github.com/yAudit/reports/blob/main/md/02-2023-RageTrade-Upgrade.md", "body": "Several variables and functions could benefit from improved NatSpec: depositCap: add the comment \"Maximum USDC that can be deposited in one round\" depositCap: add the comment \"Maximum sGLP that can be deposited in one round\" depositUsdc(), executeBatch(), claimAndRedeem(), rescueFees(), and all internal functions are missing NatSpec in DnGmxBatchingManager.sol. batchingManager variable in State struct should be marked as deprecated because batching manager integration was removed. _getBorrowValue() should have a comment to specify the return value is in USDC not USD", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "20. Typos in comments", "html_url": "https://github.com/yAudit/reports/blob/main/md/02-2023-RageTrade-Upgrade.md", "body": "These typos were found in comments: cooldowm -> cooldown depoists -> deposits roudn -> round accumuated -> accumulated mangager -> manager cooldowm -> cooldown depoists -> deposits roudn -> round accumuated -> accumulated flase -> false (found here, here, here, and here) glp price in usd -> glp price in usdc (found here and here) againts -> against assests -> assets retunrs -> returns", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "1. Vault should mint exactly the specified number of shares", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-Yearn-v3.md", "body": "Shares are minted by first converting the shares argument to assets using the _convert_to_assets() function with the option to round up the calculation. The assets variable is then forwarded to the internal function _deposit(), which takes this amount and recalculates the number of shares in the _issue_shares_for_amount() function. This breaks the compliance with EIP-4626, as the mint() function is expected to mint the receiver the exact number of shares: Mints exactly shares Vault shares to receiver by depositing assets of underlying tokens.", "labels": ["yAudit", "Severity: Medium", "Difficulty: n/a"]}, {"title": "2. Non-compliance with ERC4626 Withdrawal Standard", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-Yearn-v3.md", "body": "See: EIP-4626 The methods used in both the v3 vault and the v3 strategy are to convert assets into shares and to burn this number of shares. If any losses occur, the number of assets to be sent back is currently reduced. However, this approach does not align with the ERC4626 protocol. Instead, more shares should be burned to match the requested number of assets. https://github.com/yearn/yearn-vaults-v3/blob/3e51c08d88d2764b39348c98f20e18c51b475722/contracts/VaultV3.vy#L1523 https://github.com/yearn/tokenized-strategy/blob/72a71b16088f1a7821f299aa013d824b3dbb8d4e/src/TokenizedStrategy.sol#L464", "labels": ["yAudit", "Severity: Medium", "Difficulty: n/a"]}, {"title": "3. set_open_role() might only be used for a single role while putting at risk all the others", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-Yearn-v3.md", "body": "VaultV3.vy#L1255-L1275", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "4. lastReport() function does not return timestamp of last report for all cases", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-Yearn-v3.md", "body": "The implementation of lastReport() returns the value of the last_profit_update storage variable. This timestamp is handled during the call to process_report() but is only updated if shares are burned (line 425) or if there are locked shares after logic is executed (line 1139).", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "5. Use a two step process to update the management account", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-Yearn-v3.md", "body": "The implementation of the setManagement() function performs the role transfer in a single step, by directly transferring this key role to the specified account.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "6. Strategy deposit limits should be checked on the receiver account", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-Yearn-v3.md", "body": "The implementation of the deposit() and mint() functions check for deposit limits on the caller (msg.sender) account. The EIP-4626 standard specifies that these limits should be queried for the receiver account. Taking the maxDeposit function as an example, the specification states: Maximum amount of the underlying asset that can be deposited into the Vault for the receiver, through a deposit call.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "7. Strategy may allow to redeem more assets than the available limit", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-Yearn-v3.md", "body": "In order to calculate the maximum number of shares that can be minted, the implementation of maxRedeem() takes the amount of assets specified by availableWithdrawLimit() and calculates the associated number of shares by using previewWithdraw(), which uses up rounding. The resulting number of shares can then be used in redeem() to withdraw assets according to the calculation of previewRedeem(). This double rounding may, under certain circumstances, result in more assets than the original limit specified by availableWithdrawLimit().", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "8. Inconsistent rounding of losses_user_share", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-Yearn-v3.md", "body": "losses_user_share: uint256 = assets_needed - assets_needed * strategy_assets / strategy_current_debt The calculation is done with a loss of precision, it should be rounded up instead of down. yearn", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "9. Potential fund loss due to missing zero address check", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-Yearn-v3.md", "body": "The lack of a zero address check on the receiver could lead to unintentional loss of funds. If the receiver address were mistakenly set to the zero address, the transferred funds would be irretrievably lost. Given that this function appears to handle fund withdrawal, this could potentially lead to a significant loss. https://github.com/yearn/yearn-vaults-v3/blob/3e51c08d88d2764b39348c98f20e18c51b475722/contracts/VaultV3.vy#L802", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "10. Update debt does not check that strategy is active", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-Yearn-v3.md", "body": "The update_debt() function does not check that the given strategy is currently active (i.e. self.strategies[strategy].activation != 0).", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "11. Cache storage variable locally to prevent multiple reads from storage", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-Yearn-v3.md", "body": "VaultV3.vy#L328 VaultV3.vy#L334 VaultV3.vy#L838 VaultV3.vy#L1329", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "12. Don't initialize variables with default value", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-Yearn-v3.md", "body": "VaultV3.vy#L294", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "13. Function can be marked external", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-Yearn-v3.md", "body": "on the TokenizedStrategy.sol contract, several functions can be marked external. TokenizedStrategy.sol#L587 TokenizedStrategy.sol#L599 TokenizedStrategy.sol#L615 TokenizedStrategy.sol#L1355 TokenizedStrategy.sol#L1404 TokenizedStrategy.sol#L1450 TokenizedStrategy.sol#L1482 TokenizedStrategy.sol#L1509 TokenizedStrategy.sol#L1536", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "14. Use != 0 instead of > 0 for comparison", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-Yearn-v3.md", "body": "TokenizedStrategy.sol#L878 TokenizedStrategy.sol#L885 TokenizedStrategy.sol#L897 TokenizedStrategy.sol#L911 TokenizedStrategy.sol#L915 TokenizedStrategy.sol#L925 TokenizedStrategy.sol#L934 TokenizedStrategy.sol#L942 TokenizedStrategy.sol#L1340", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "15. Use unchecked for subtractions where the operands cannot underflow", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-Yearn-v3.md", "body": "TokenizedStrategy.sol#L1065 TokenizedStrategy.sol#L1073 VaultV3.vy#L304 VaultV3.vy#L309 VaultV3.vy#L310 VaultV3.vy#L378 VaultV3.vy#L533 VaultV3.vy#L581 VaultV3.vy#L695 VaultV3.vy#L889 VaultV3.vy#L897 VaultV3.vy#L950 VaultV3.vy#L1025 VaultV3.vy#L1028 VaultV3.vy#L1329", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "16. Vyper 0.3.8 introduces transient storage for non-reentrancy checks, leading to notable gas savings", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-Yearn-v3.md", "body": "yearn vault", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "17. Unnecessary return variable declaration", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-Yearn-v3.md", "body": "BaseTokenizedStrategy.sol", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "18. Use constants for literal or magic values", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-Yearn-v3.md", "body": "TokenizedStrategy.sol#L1302 TokenizedStrategy.sol#L1302", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "19. Prefer abi.encodeCall() over abi.encodeWithSignature() or abi.encodeWithSelector()", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-Yearn-v3.md", "body": "BaseTokenizedStrategy.sol#L433", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "20. Optional ERC-20 functions", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-Yearn-v3.md", "body": "VaultV3.vy#L280 TokenizedStrategy.sol#L383 TokenizedStrategy.sol#L1366", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "21. Typos in tokenized-strategy repo", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-Yearn-v3.md", "body": "21. Typos in tokenized-strategy repo", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "22. Vyper raw_call() can be replaced with the new vyper default_return syntax", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-Yearn-v3.md", "body": "The existing codebase uses low-level raw_call to handle non-standard ERC20 calls. This can be simplified using the new syntax.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "23. Selector clashing attack in strategies", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-Yearn-v3.md", "body": "The current design of strategies is composed of two contracts, an abstract BaseTokenizedStrategy.sol contract inherited by strategist and a TokenizedStrategy.sol contract that implements the vault's core logic. Communication between the two is done using delegatecall. Similar to the proxy pattern, the main strategy contract uses a fallback() function to delegatecall any non-matching function to the TokenizedStrategy.sol contract. Since function selectors are 4 bytes long, it is feasible to mine a function signature that matches one of the functions in the TokenizedStrategy.sol contract. A bad actor can then hide such a function in the strategy implementation that will be unintentionally called while trying to access the \"real\" function. Due to the current contract design, this function will be caught by the strategy implementation instead of being delegated to the TokenizedStrategy.sol contract, as function dispatch will happen first in the main strategy contract.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "24. Lack of event logging in tend()", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-Yearn-v3.md", "body": "TokenizedStrategy.sol#L1051", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "25. Lack of event logging in emergencyWithdraw()", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-Yearn-v3.md", "body": "TokenizedStrategy.sol#L1122", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "1. VeBeacon contract vulnerable to denial of service", "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-timeless-gauges.md", "body": "The following code reverts when ETH is left on the contract. if (address(this).balance != 0) revert VeBeacon__LeftoverEth(); This ensures users don't overpay for the Arbitrum bridge, but it has two issues: An attacker will be able to DOS the contract by sending some ETH dust that will remain, causing the check to revert. A user might get his transaction reverted because the Arbitrum fee might change between the time the transaction is broadcasted and the time it gets executed. VeBeacon.sol#L66", "labels": ["yAudit", "Severity: High", "Difficulty: n/a"]}, {"title": "2. Potential denial of service vulnerability in bridger contracts", "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-timeless-gauges.md", "body": "When a user tries to bridge tokens like USDT that doesn't return a boolean value on transferFrom() and approve() function calls, the operation will fail since the Bridger contracts use the assert statement to validate the function call's success. In Vyper, the assert function throws an exception if the condition is unmet and reverts all changes.", "labels": ["yAudit", "Severity: Medium", "Difficulty: n/a"]}, {"title": "3. Child gauge vulnerability: uncontrolled reward addition by managers", "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-timeless-gauges.md", "body": "Refer to ChildGauge.vy#L579 for the relevant code snippet.", "labels": ["yAudit", "Severity: Medium", "Difficulty: n/a"]}, {"title": "4. unkillGauge should checkpoint funds distribution to prevent distributing for the time it was killed", "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-timeless-gauges.md", "body": "The function unkillGauge() merely changes the gauge state flag to active. User reward claims will trigger a checkpoint that will distribute rewards for the period up until the last checkpoint, which was set when the gauge was 'killed'. Consequently, this distributes rewards corresponding to the duration in which the pool was inactive.", "labels": ["yAudit", "Severity: Medium", "Difficulty: n/a"]}, {"title": "5. Potential user exploitation of boost adjustment mechanism", "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-timeless-gauges.md", "body": "The function at ChildGauge.vy#L699 sets a new boost value. While a 'kick' function exists, it cannot be utilized to update a user's effective balance. The kick() method can only be used when the user has updated a lock.", "labels": ["yAudit", "Severity: Medium", "Difficulty: n/a"]}, {"title": "6. Rewards can be locked in Gauges", "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-timeless-gauges.md", "body": "childGuage.vy function deposit_reward_token allows anyone to create, and rewards distribution is done using the reward rate. Still, if the reward distributor deposits _amount (in WEI) less than 1 WEEK (or 604800 Wei), the transferred rewards will be locked into the contract. self.reward_data[_reward_token].rate = _amount / WEEK If _amount < 604800 then self.reward_data[_reward_token].rate = 0.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "7. Add missing input validation on constructor/initializer/setters", "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-timeless-gauges.md", "body": "Certain functions are missing necessary input validation. In childGaugeFactory.vy: set_implementation, set_voting_escrow, deploy_gauge, and __init__. In childGuage.vy: __init__, add_reward, set_manager, initialize.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "8. Potential user manipulation of Uniswap deposit to claim rewards within range", "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-timeless-gauges.md", "body": "For more information, refer to ChildGauge.vy#L744.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "9. votingEscrow.epoch() can't be zero if a user created a lock", "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-timeless-gauges.md", "body": "The following code snippet is not necessary: if (epoch == 0) revert VeBeacon__EpochIsZero(); This check is redundant as a validation already exists in line 117. If a user has created a lock, the global epoch cannot be zero, as confirmed in the ve contract. VeBeacon.sol#L122", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "10. Consolidating Gauge State Setters for Gas Optimization", "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-timeless-gauges.md", "body": "Multiple setters are currently used to modify the gauge_state value. To optimize gas usage, it is recommended to consolidate these setters into a single function.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "11. Potential transaction order discrepancy and impact on total supply calculation in sidechain", "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-timeless-gauges.md", "body": "There is no warranty on transaction ordering from L1 to L2. A transaction can be mined on L1, fail on L2, and then be retried later, resulting in a different order. Here is an example: User A creates a lock that will last for 4 years. User A broadcasts their lock to L2. User B creates a lock that will last two weeks. User B broadcasts their lock to L2. If the broadcast from User B is processed by L2 before the one from User A, then the slope changes corresponding to the end of the lock from User B will be removed from the corresponding variable when User A's transaction is processed on L2.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "12. Optimizing bytecode size by removing unused constant variable", "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-timeless-gauges.md", "body": "There is an unused constant variable in the contract childGaugeFactory.vy that should be removed.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "13. Missing events for critical operations", "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-timeless-gauges.md", "body": "Ideally, the following critical operations should trigger events. In VeRecipient constructor() should emit SetBeacon In childGuage, following function lacks event emission. killGauge() unkillGauge() makeGaugePermissionless() set_manager() deposit_reward_token() kick() set_reward_distributor() add_reward() claim_rewards() set_rewards_receiver() In rootGuage, following functions lacks event emission. set_killed()", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "14. Leveraging new syntax in Vyper 0.3.4 for default return value", "html_url": "https://github.com/yAudit/reports/blob/main/md/05-2023-timeless-gauges.md", "body": "The existing codebase uses low-level raw_calls for safe calls. This can be simplified using the new syntax.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "1. decodeCtx() missing error checks", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md", "body": "1. decodeCtx() missing error checks", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "2. No function to unregister an agreement class", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md", "body": "2. No function to unregister an agreement class", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "3. App registration front-running can set a different configword", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md", "body": "3. App registration front-running can set a different configword", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "4. appCallbackPop() missing modifier", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md", "body": "4. appCallbackPop() missing modifier", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "5. Unnecessary zero initialization", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md", "body": "5. Unnecessary zero initialization", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "6. Avoid && logic in require statements", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md", "body": "6. Avoid && logic in require statements", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "7. Use != 0 for gas savings", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md", "body": "7. Use != 0 for gas savings", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "8. Use short require strings", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md", "body": "8. Use short require strings", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "9. External functions are cheaper than public functions", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md", "body": "9. External functions are cheaper than public functions", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "10. Use Solidity errors in 0.8.4+", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md", "body": "10. Use Solidity errors in 0.8.4+", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "11. Use prefix in loops", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md", "body": "11. Use prefix in loops", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "12. Declare constant internal when possible", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md", "body": "12. Declare constant internal when possible", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "13. Use of memory for function arguments", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md", "body": "13. Use of memory for function arguments", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "14. Unnecessary variable computation", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md", "body": "14. Unnecessary variable computation", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "15. Shorted revert strings", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md", "body": "15. Shorted revert strings", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "16. Custom error", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md", "body": "16. Custom error", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "17. Using >0 for unsigned integers", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md", "body": "17. Using >0 for unsigned integers", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "18. Unchecked counter incrementation in \"for\" loop", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md", "body": "18. Unchecked counter incrementation in \"for\" loop", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "19. Potential underflow condition", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md", "body": "19. Potential underflow condition", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "20. Potential hash collision", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md", "body": "20. Potential hash collision", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "21. Logic inconsistency between callAgreementWithContext() and callAppActionWithContext()", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md", "body": "21. Logic inconsistency between callAgreementWithContext() and callAppActionWithContext()", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "22. Upgradable Superfluid.sol has hardcoded version", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md", "body": "22. Upgradable Superfluid.sol has hardcoded version", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "23. _callAppAction() logic varies from _callAgreement()", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md", "body": "23. _callAppAction() logic varies from _callAgreement()", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "24. Use named cached variable", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md", "body": "24. Use named cached variable", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "25. _replacePlaceholderCtx() logic could be simplified", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md", "body": "25. _replacePlaceholderCtx() logic could be simplified", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "26. _callCallback() logic can be simplified", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md", "body": "26. _callCallback() logic can be simplified", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "27. Broken link", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md", "body": "27. Broken link", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "28. FIXME or TODO comments remain in code", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md", "body": "28. FIXME or TODO comments remain in code", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "29. Typos", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md", "body": "29. Typos", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "30. Incorrect external code reference", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md", "body": "30. Incorrect external code reference", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "31. Match callInfo masks and shifts to data size", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md", "body": "31. Match callInfo masks and shifts to data size", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "32. isConfigWordClean doesn't check some unused bits", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md", "body": "32. isConfigWordClean doesn't check some unused bits", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "33. Remove unnecessary casting to ISuperApp type", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md", "body": "33. Remove unnecessary casting to ISuperApp type", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "34. Incorrect comments", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md", "body": "34. Incorrect comments", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "35. Variation in isTrustedForwarder() implementations", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md", "body": "35. Variation in isTrustedForwarder() implementations", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "36. Implementation contracts not initialized", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md", "body": "Superfluid, SuperfluidAgreement, SuperTokenFactory are deployed as UUPS proxy contracts. Anyone call their initialize() function as implementation contracts are not initialized.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "37. Possible to register multiple apps with same registrationKey", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md", "body": "Governance's owner can call setConfig() to allow an address a (hashed into key) to register a SuperApp with Superfluid.sol (host). The value parameter is the timestamp until which the address can register the app. a can initiate a transaction to register multiple apps through registerAppWithKey() as long as block.timestamp <= value.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "38. Valid context is not checked before modifying it", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md", "body": "For reference, appCallbackPush() has asserts a valid context through assertValidCtx(ctx). There is no such verification for appCallbackPop().", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "39. Typo", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md", "body": "agreeement (Superfluid.sol#L1053 and Superfluid.sol#L1063) might be better spelled as agreement.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "40. Ambiguous endian of bitmap", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md", "body": "40. Ambiguous endian of bitmap", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "41. Add more comments and documentation", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2022-Superfluid.md", "body": "There is NatSpec on the interface ISuperfluid.sol but still lacking on documentation and inline comments.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "1. Minting with different position indices yields a higher total boostAmount than minting with the same index", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-RAMSES.md", "body": "When minting or burning the liquidityDelta is added to an existing position's liquidity to determine the newLiquidity which is used throughout _updatePosition() for various calculations, to include the veRamRatio and newBoostedLiquidity. Eventually a boostedLiquidityCap is calculated using the veRamRatio and hypotheticalLiquidity. This boostedLiquidityCap is intended to limit the amount of newBoostedLiquidity that can be added by a position. However, this can be bypassed by using many small positions rather than the same position. This can be done relatively simply by an attacker by using a different index for their positions, and since a veRamTokenId balance can be re-used by multiple positions, there is no detriment to using multiple positions to mint liquidity. See this POC illustrating the point in code: contract AttachTest is Test { RamsesV2Pool _pool; RamsesV2Factory _factory; MockVoter _voter; MockNFPManager _nfpManager; MockVotingEscrow _veRam; MockERC20 _token0; MockERC20 _token1; function setUp() public { _pool = new RamsesV2Pool(); _factory = new RamsesV2Factory(); _voter = new MockVoter(); _nfpManager = new MockNFPManager(); _veRam = new MockVotingEscrow(); _token0 = new MockERC20(\"0\", \"token_0\", 18); _token1 = new MockERC20(\"1\", \"token_1\", 18); deal(address(_token0), address(this), type(uint256).max); deal(address(_token1), address(this), type(uint256).max); _factory.initialize(address(_nfpManager), address(_veRam), address(_voter), address(0)); _pool.initialize(address(_factory), address(_nfpManager), address(_veRam), address(_voter), address(_token0), address(_token1), 10_000, 200); _pool.initialize(393495975901102234655829); } function ramsesV2MintCallback( uint256 amount0Owed, uint256 amount1Owed, bytes calldata data ) external { _token0.transfer(address(_pool), amount0Owed); _token1.transfer(address(_pool), amount1Owed); } function positionHash( address owner, uint256 index, int24 tickLower, int24 tickUpper ) internal pure returns (bytes32) { return keccak256(abi.encodePacked(owner, index, tickLower, tickUpper)); } function testMultipleAttachmentPOC() public { uint256 period = block.timestamp / (1 weeks); ( uint160 sqrtPriceX96, int24 tick, uint16 observationIndex, uint16 observationCardinality, uint16 observationCardinalityNext, uint8 feeProtocol, bool unlocked ) = _pool.slot0(); int24 tickLower = tick - 132; int24 tickUpper = tick + 68; // get the boostAmount when using the same index to repeatedly mint for (uint i = 0; i < 10; i++) { _pool.mint(address(this), 0, tickLower, tickUpper, 100, 1, \"\"); } (uint128 boostAmountMintingSameIndex,,,) = _pool.boostInfos(period, positionHash(address(this), 0, tickLower, tickUpper)); // clear out all the state from this minting such that it doesn't affect the minting below. In essence, the two operations should functional independently of one another. _pool.burn(0, tickLower, tickUpper, 100 * 10, 1); _pool.collect(address(this), tickLower, tickUpper, uint128(_token0.balanceOf(address(_pool))), uint128(_token1.balanceOf(address(_pool)))); vm.startPrank(address(_pool)); _token0.transfer(address(this), _token0.balanceOf(address(_pool))); // clear the fee balances _token1.transfer(address(this), _token1.balanceOf(address(_pool))); vm.stopPrank(); skip(1 weeks); // skip forward a week to ensure the prior period's `totalVeRamAmount` doesn't affect this period's. period = period + 1; // get the boostAmount when using different indices to repeatedly mint uint128 boostAmountMintingDifferentIndices; for (uint i = 0; i < 10; i++) { _pool.mint(address(this), i+1, tickLower, tickUpper, 100, 2, \"\"); // the VotingEscrow contract is hard coded to return the same balanceOfNFT for every tokenId to illustrate the point. (uint128 boostAmountAccumulator,,,) = _pool.boostInfos(period, positionHash(address(this), i+1, tickLower, tickUpper)); boostAmountMintingDifferentIndices += boostAmountAccumulator; } // the boostAmount of all the differently indexed positions is > the boost amount when using the same position supplying the same liquidity assertGt(uint(boostAmountMintingDifferentIndices), uint(boostAmountMintingSameIndex)); } } Note that the pool in the POC has been initialized similarly to the deployed DEUS/USDC pool which can be found here. Also, note that the MockVotingEscrow contract has been hard coded to return the same balanceOfNFT() (the balance taken from the deployed veRAM contract for tokenId 1 at the time of the test) and isApproverOrOwner() for ease of testing and to illustrate the difference between the two minting strategies. function isApprovedOrOwner(address, uint256) external override view returns (bool) { return true; } function balanceOfNFT(uint256) external override view returns (uint256) { return 21487469130353205716474214; }", "labels": ["yAudit", "Severity: High", "Difficulty: n/a"]}, {"title": "2. Treasury fees can be bypassed with repeated calls to notifyRewardAmount()", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-RAMSES.md", "body": "Protocol fees are collected in the pushFees modifier when notifyRewardAmount() in GaugeV2.sol is called, which can be called by anyone at any time. FeeCollector.sol contract's collectProtocolFees() collects the pool's protocol fees and then uses the amount retrieved from the pool to calculate the treasury fee amount.", "labels": ["yAudit", "Severity: Medium", "Difficulty: n/a"]}, {"title": "3. boostAmount stays attached to a position after ownership is lost", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-RAMSES.md", "body": "When a veRamTokenId is attached to a position there is a check to ensure that the msg.sender isApprovedOrOwner of the veRamTokenId. If this check passes, the balance of the NFT is attached to the boostedPosition. However, if the ownership of the veRamTokenId changes, or the position owner is no longer approved, this veRamAmount stays attached to the boostedPosition indefinitely unless the veRamTokenId is explicitly changed, or the liquidity of the position goes to 0.", "labels": ["yAudit", "Severity: Medium", "Difficulty: n/a"]}, {"title": "4. Minting, burning, and minting yields higher boostAmount than minting", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-RAMSES.md", "body": "When minting a new position, the pool's token balances are used to determine hypotheticalLiquidity and therefore the boostedLiquidityCap, veRamBoostAvailable, and positionBoostUsedRatio. However, when a position is burned, the tokens continue to accrue to the pool until collect() is called by the burner. This means that even though the tokens may be allocated to the burner, and they can retrieve them at any time, they continue to contribute to the boostedLiquidityCap, veRamBoostAvailable, and positionBoostUsedRatio variables when positions are updated. This means that boostedLiquidityCap and veRamBoostAvailable can be inflated, and positionBoostUsedRatio deflated, to any value an attacker would like without supplying additional liquidity. See this POC illustrating the point in code: contract AttachTest is Test { RamsesV2Pool _pool; RamsesV2Factory _factory; MockVoter _voter; MockNFPManager _nfpManager; MockVotingEscrow _veRam; MockERC20 _token0; MockERC20 _token1; function setUp() public { _pool = new RamsesV2Pool(); _factory = new RamsesV2Factory(); _voter = new MockVoter(); _nfpManager = new MockNFPManager(); _veRam = new MockVotingEscrow(); _token0 = new MockERC20(\"0\", \"token_0\", 18); _token1 = new MockERC20(\"1\", \"token_1\", 18); deal(address(_token0), address(this), type(uint256).max); deal(address(_token1), address(this), type(uint256).max); vm.label(address(_pool), \"_pool\"); vm.label(address(_token0), \"_token0\"); vm.label(address(_token1), \"_token1\"); vm.label(address(_factory), \"_factory\"); vm.label(address(_veRam), \"veRam\"); vm.label(address(_nfpManager), \"_nfpManager\"); vm.label(address(_voter), \"_voter\"); _factory.initialize(address(_nfpManager), address(_veRam), address(_voter), address(0)); _pool.initialize(address(_factory), address(_nfpManager), address(_veRam), address(_voter), address(_token0), address(_token1), 10_000, 200); _pool.initialize(393495975901102234655829); } function tickSpacingToMaxLiquidityPerTick(int24 tickSpacing) public pure returns (uint128) { int24 minTick = (TickMath.MIN_TICK / tickSpacing) * tickSpacing; int24 maxTick = (TickMath.MAX_TICK / tickSpacing) * tickSpacing; uint24 numTicks = uint24((maxTick - minTick) / tickSpacing) + 1; return type(uint128).max / numTicks; } function testBurnAndMint() public { uint256 period = block.timestamp / (1 weeks); ( uint160 sqrtPriceX96, int24 tick, uint16 observationIndex, uint16 observationCardinality, uint16 observationCardinalityNext, uint8 feeProtocol, bool unlocked ) = _pool.slot0(); int24 tickLower = tick - 132; int24 tickUpper = tick + 68; _pool.mint(address(this), 0, tickLower, tickUpper, tickSpacingToMaxLiquidityPerTick(200), 1, \"\"); (uint128 boostAmountPreBurn,,,) = _pool.boostInfos(period, positionHash(address(this), 0, tickLower, tickUpper)); _pool.burn(0, tickLower, tickUpper, tickSpacingToMaxLiquidityPerTick(200), 1); _pool.mint(address(this), 0, tickLower, tickUpper, tickSpacingToMaxLiquidityPerTick(200), 1, \"\"); (uint128 boostAmountPostBurn,,,) = _pool.boostInfos(period, positionHash(address(this), 0, tickLower, tickUpper)); assertGt(uint(boostAmountPostBurn), uint(boostAmountPreBurn)); } } Note that the pool in the POC has been initialized similarly to the deployed DEUS/USDC pool which can be found here. Also, note that the MockVotingEscrow contract has been hard coded to return the same balanceOfNFT() (the balance taken from the deployed veRAM contract for tokenId 1 at the time of the test) and isApproverOrOwner() for ease of testing. function isApprovedOrOwner(address, uint256) external override view returns (bool) { return true; } function balanceOfNFT(uint256) external override view returns (uint256) { return 21487469130353205716474214; }", "labels": ["yAudit", "Severity: Medium", "Difficulty: n/a"]}, {"title": "5. Incorrect math in left()", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-RAMSES.md", "body": "The line calculating elapsedTime calculates the difference between _blockTimestamp(), with units of seconds, and period, with units of weeks. Subtracting weeks from seconds will result in a nonsensical result, so the two values must have the same units before the difference is calculated.", "labels": ["yAudit", "Severity: Medium", "Difficulty: n/a"]}, {"title": "6. The first mint in a pool gets 0 boostAmount regardless of veRamTokenId or liquidity supplied", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-RAMSES.md", "body": "The boostedLiquidityCap is based on the hypotheticalLiquidity which is based on the pool's token balances. When a pool is first deployed, it has no liquidity, so the first minter will receive no boostedLiquidity regardless of the size of their mint or veRamTokenId's balance. This is particularly acute if the minter is minting a large position as is illustrated in the POC below. See this POC for an illustration of the point in code: function testFirstMint() public { uint256 period = block.timestamp / (1 weeks); ( , int24 tick, , , , , ) = _pool.slot0(); int24 tickLower = tick - 132; int24 tickUpper = tick + 68; _pool.mint(address(this), 0, tickLower, tickUpper, tickSpacingToMaxLiquidityPerTick(200) - 100, 1, \"\"); (uint128 boostAmountFirstMint,,,) = _pool.boostInfos(period, positionHash(address(this), 0, tickLower, tickUpper)); assertEq(uint256(boostAmountFirstMint), 0); _pool.mint(address(this), 1, tickLower, tickUpper, 100, 2, \"\"); // This could be a new minter, however we're using a different index and veRamTokenId for illustration purposes. (uint128 boostAmountSecondMintDifferentPosition,,,) = _pool.boostInfos(period, positionHash(address(this), 1, tickLower, tickUpper)); assertGt(uint256(boostAmountSecondMintDifferentPosition), 0); }", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "7. GaugeV2.getPeriodReward() can skip lastClaimByToken for a valid claim", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-RAMSES.md", "body": "In function, GaugeV2.getPeriodReward(), consider the following: User wants to claim the reward for period = 13, current period = 14, and lastClaimByToken was made for all the tokens in period 10. That means the condition comes out to be 10 < period < 13. if ( period > lastClaimByToken[tokens[i]][_positionHash] && period < _blockTimestamp() / WEEK - 1 ) The period for which the rewards were claimed doesn't lie in the range. Hence, it skips the check and then moves on to the _getReward() call, which lets the user claim a reward for period 13, and lastClaimByToken remained 10. Well, it should be able to set the lastClaim to that period as it has been passed, and the user can claim the reward for that period later in the function.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "8. The rewards list can grow unbounded in GaugeV2.sol", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-RAMSES.md", "body": "notifyRewardAmount() is an external function, with no access control modifier, which means anyone can call notifyRewardAmount(). If a token has not been seen before, it is added to the isReward mapping and pushed into the rewards list. This means an attacker could fill the list with a large number of random token addresses. Elsewhere in GaugeV2.sol, such as getPeriodReward(), tokens are passed into the function such that the entire reward list is not iterated through. However, this is not the case in the RamsesRewards.sol contract's addressEarnedCl() function, where the entire reward list is iterated through.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "9. createCLGauge() code doesn't match comment", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-RAMSES.md", "body": "This comment and a line of code earlier in the function directly conflict with one another. require(_pool != address(0), \"no pool\"); ... // gov can create for any pool, even non-Ramses pairs By requiring _pool != address(0) value of true, governance is limited to only adding gauges to valid RAMSES pairs. This is in contrast to createGauge() for Ramses v1, where the equivalent check requiring isPair to be true is only applied to a non-governor msg.sender.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "10. Inconsistent first period in GaugeV2", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-RAMSES.md", "body": "The firstPeriod variable is set during initialization as: firstPeriod = _blockTimestamp() / WEEK; This value will be rounded down. The end result of this value rounding down is the same whether the week of firstPeriod is 5% complete or 95% complete during initialization. This rounding down will artificially shorten the time period for the firstPeriod. This may skew the rewards per second during firstPeriod compared to future periods.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "11. Errors in left()", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-RAMSES.md", "body": "The NatSpec for left() references a function that does not exist, getTokenTotalSupplyByPeriod(). The NatSpec should be updated to remove this reference. The name of the function left() is misleading. The return value sees the elapsedTime value in the numerator, not the remaining time. This means that the return value of left() increases as the period approaches the end of the period, when the function name indicates that the opposite should be true.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "12. No validation of pool address in createGauge()", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-RAMSES.md", "body": "Like other contracts in RAMSES, RamsesV2GaugeFactory.sol is loosely based on UniswapV3Factory.sol, with the implementation of createGauge() based on createPool(). In Uniswap, anyone can create a pool between two ERC20 tokens. It is unclear whether the same should be true of createGauge(), but there is no access control enforced on this function. The pool address function argument is not verified as a RAMSES pool before it is passed to _deploy(), which also does not validate the pool address value. The result is that a gauge will exist with a pool address that is not a pool, and a malicious party can create a contract that implements the same interface as a RAMSES pool but does not necessarily perform the same actions. There are external calls to the pool address in GaugeV2.sol (such as 1, 2, 3) that may be leveraged into an attack vector, though the specifics have not been fully worked out yet.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "13. v1 Gauge.sol poke() should cache length before loop", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-RAMSES.md", "body": "Gauge.poke() should cache rewards.length before the for loop, then reference the cache length value in the loop, to achieve gas savings. Otherwise the length of the rewards state variable is checked on each iteration of the loop. This finding was automatically identified by slither.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "14. _find_time_user_epoch() loop iterations can be reduced", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-RAMSES.md", "body": "VotingEscrow.vy in Curve has a function find_block_epoch() which implements binary search using a for loop that repeats 128 times. RAMSES has a similar VotingEscrow._find_time_user_epoch() function that implements binary search using a for loop that repeats 256 times. The RAMSES VotingEscrow._find_time_user_epoch() implementation is in contrast to the RAMSES implementation of VotingEscrow._balanceOfAtNFT(), which loops 128 times like Curve. There is no need for VotingEscrow._find_time_user_epoch() to loop 256 times, it can stop at 128.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "15. Move logic into if statement", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-RAMSES.md", "body": "_supplied is only needed in the if branch, so it can be set inside that branch. function _updateFor(address _gauge) internal { address _pool = poolForGauge[_gauge]; - uint256 _supplied = weights[_pool]; uint256 _supplyIndex = supplyIndex[_gauge]; // only new pools will have 0 _supplyIndex if (_supplyIndex > 0) { + uint256 _supplied = weights[_pool]; uint256 _index = index; // get global index0 for accumulated distro", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "16. periodSecondsPerBoostedLiquidityOutsideBeforeX128 and periodSecondsPerLiquidityOutsideBeforeX128 are 0 and can be removed from subtraction", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-RAMSES.md", "body": "In cross() periodSecondsPerLiquidityOutsideBeforeX128 and periodSecondsPerBoostedLiquidityOutsideBeforeX128 must be 0 for the if logic to be executed. In this case, their subtraction does nothing to contribute to the final periodSecondsPerLiquidityOutsideX128 and periodSecondsPerBoostedLiquidityOutsideX128 values.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "17. ERC721PermitUpgradeable inherits from Initializable twice", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-RAMSES.md", "body": "ERC721PermitUpgradeable inherits from Initializable explicitly. However, ERC721Upgradeable already inherits from Initializable.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "18. positionLiquidity - params.liquidity is calculated twice", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-RAMSES.md", "body": "position.liquidity is stored as positionLiquidity - params.liquidity. This is recomputed to check if the liquidity difference is 0 and unset the veRamTokenId.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "19. Gas can be saved calling a different periodEarned() in GaugeV2.sol", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-RAMSES.md", "body": "Currently, in earned() periodEarned(period, token, tokenId) is called to accumulate the reward. This periodEarned() function re-computes the tickLower and tickUpper which are already known at the time periodEarned() is called in earned().", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "20. Restrict reward claim for current epoch", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-RAMSES.md", "body": "Since all the important (rewards deciding) variables for the current epoch get set at the start of the next epoch, it is crucial to not let the user claim the reward for the current epoch. Additionally, the reward that the user is claiming for the current week turns out to be an arbitrary value calculated using a fixed value of boostedInRange as 1 WEEK. Even if the user claims the reward for the current week, his/her rewards are still accumulating which the user can't claim as those rewards become available in the next epoch. Then it is better to restrict users to claim rewards for the current epoch.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "21. initialize should emit event for variable set", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-RAMSES.md", "body": "Ideally, the following should trigger events. FeeCollector.initialize() should emit TreasuryChanged. RamsesV2Factory.initialize() should emit ImplementationChanged", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "22. _switchAttachment shouldn't allow switch if position.liquidity == 0", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-RAMSES.md", "body": "Once a user decreases all the liquidity from its nfpManager position, the veRamTokenId from both the pool and nfpManager position gets detached (becomes 0). But if the user calls _switchAttachment it will set veRamTokenId in nfpManager, but in the pool, the user attachedVeRamId remains zero. (nfpManager.switchAttachment() -> pool.burn() -> _updateLiquidity() which only updates veRamTokenId, if newLiquidity > 0). This can make the pool and nfpManager contract out of sync for a user position.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "23. Incorrect NatSpec comment in ProtocolActions Library", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-RAMSES.md", "body": "CollectProtocol event is emitted when feeCollector calls the collectProtocol function of RamsesV2Pool.sol, as the function has a modifier onlyFeeCollector which means it can only be called by feeCollector.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "24. Revert doesn't contain error message", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-RAMSES.md", "body": "Revert statement reverts without error message in the following functions. RamsesV2Pool.sol: onlyFeeCollector() mint() RamsesV2Factory.sol: enableFeeAmount() NonfungiblePositionManager.sol: tokenURI() decreaseLiquidity() SwapRouter.sol: ramsesV2SwapCallback() exactOutputInternal()", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "25. inconsistency in preventing implementation initialization", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-RAMSES.md", "body": "There needs to be more consistent behavior in the constructor of implementation contracts. The following contracts use _disableInitializers(); to disable initialization of implementation (which is good): GuageV2.sol FeeCollector.sol RamsesLens.sol But other contracts follow constructor() initializer {} (which does the same thing, but it is recommended to use _disableInitializers for implementations)", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "26. Imports are unused", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-RAMSES.md", "body": "Various imports throughout the codebase are not used and can be removed. The IWETH9.sol import in SwapRouter.sol. The SqrtPriceMath.sol, IRamsesV2PoolDeployer.sol, IVotingEscrow.sol, and IVoter.sol imports in RamsesV2Pool.sol. RamsesPool.sol in RamsesV2Factory.sol. IGaugeV2.sol in RamsesV2GaugeFactory.sol.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "27. Contract without proxy can be simplified", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-RAMSES.md", "body": "Several proxy artifacts in RamsesDeployer.sol can be modified because it is not behind a proxy: The file imported from @openzeppelin/contracts-upgradeable can be changed to the @openzeppelin/contracts version of the file. Initializer is not necessary. initialize() can be replaced by the contract constructor.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "28. Whitelisted tokens for gauges cannot be removed", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-RAMSES.md", "body": "There is no way to reverse the action of the whitelist() operation in Voter.sol. If there is a token that should be removed from the whitelist, the Voter contract (which is deployed behind a proxy) may need to be replaced. Adding a function to reverse the whitelisting of tokens can improve the mitigation of future threats if a trusted token contract is maliciously or incompatibly upgraded.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "29. Emergency council identical to governor in Voter.sol", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-RAMSES.md", "body": "Voter.sol has a governor role and an emergencyCouncil role. In the on-chain contract, the same RAMSES multisig is set for these two different roles. In other Solidly fork implementations with the emergencyCouncil role, such as Velodrome on Optimism and PearlFi on Polygon, these roles are assigned to different multisigs. Specifically, the emergencyCouncil multisig has a higher threshold than the governance multisig, suggesting a design choice where controlling the uptime of the protocol requires cooperation from more signers than adding gauges to the protocol. This is a design choice and RAMSES may have decided that the current approach is best, but without clear documentation on this choice, the current settings make the RAMSES multisig a centralized source of power over the full protocol.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "30. On-chain contracts using different library versions", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-RAMSES.md", "body": "Some of the on-chain code does not match the contract versions reviewed during this audit. Specifically, the on-chain Oracle.sol deployment at 0xf70c9C4F6281C0750d68da8878894b1235cb6020 has some minor differences in 3 dependencies, States.sol, LiquidityMath.sol, and Tick.sol, compared to the code reviewed in this audit. Similarly, Tick.sol deployed at 0xc989D669831Cd5258369CB0Dce7752CbfE7303E8 and ProtocolActions.sol deployed at 0xa67f82621540017a679153423CA0B8a1b4518B49 have different versions of the State.sol library dependency compared to the version of State.sol in this audit.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "31. Reduce rounding error inaccuracy", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-RAMSES.md", "body": "The two division operations can be reduced to one to minimize error created by the rounding down inherent in a solidity division operation. function rewardRate(address token) external view returns (uint256) { uint256 period = _blockTimestamp() / WEEK; - return (tokenTotalSupplyByPeriod[period][token] * 4) / 10 / WEEK; + return (tokenTotalSupplyByPeriod[period][token] * 4) / (10 * WEEK); }", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "32. Beacon proxy inconsistency", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-RAMSES.md", "body": "RamsesV2PoolDeployer uses the value keccak256(abi.encode()) for the beacon proxy creation while RamsesV2GaugeDeployer uses keccak256(abi.encodePacked()). These contracts perform almost the exact same task, so the same code logic should be used.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "33. STATES_SLOT can accidentally match a known pre-image", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-RAMSES.md", "body": "By calculating STATES_SLOT = keccak256(\"states.storage\") using a string value, the first pre-image of STATES_SLOT is known (\"states.storage\"), which makes it accidentally match the known pre-image (\"states.storage\"). Openzeppelin and all proxy standards derive their custom storage slot in this way. Ref", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "34. First period has default zero value for startTick and previousPeriod", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-RAMSES.md", "body": "The implementation of RamsesV2Pool._advancePeriod() primarily updates the values for states.periods[_lastPeriod], or the state of the last period. Only one line of code updates the current period value. Because _advancePeriod() is first called in initialize(), the initial _lastPeriod value of zero will be meaningless, but it will have no values set for startTick and previousPeriod, so these values will remain zero. The first real period is the 1st period (not the 0th period). Any loop that iterates through the period states should consider this, but there is no comment to clarify this is how the period values are handled.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "35. Forked Uniswap v3 code uses OZ 3.4.1 not 3.4.2", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-RAMSES.md", "body": "The changes made between 3.4.2 and 3.4.1 are minimal, which just one commit made in TimelockController, which is not directly used in the v2-periphery/ directory. However, if the goal is to maintain maximum similarity to the original Uniswap, this dependency on OpenZeppelin in the v2-periphery/ directory should be upgraded to OZ 3.4.2.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "36. Improve naming choices", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-RAMSES.md", "body": "Several naming choices that could be improved include: RamsesV2Pool.sol has two functions named \"initialize\". The second function sets the initial price for the pool and may be better named \"setInitialPoolPrice\" to avoid confusion. The function name \"initialize\" is generally used for a single function in an implementation contract sitting behind a proxy. This function can only be called once and sets initial values similar to how a constructor would work in a non-proxy context. But in RamsesV2Pool.sol, the second initialize function can be called more than once because it lacks an initializer modifier. PeripheryUpgradeable.sol is a renamed version of PeripheryImmutableState.sol in Uniswap v3. The interface for PeripheryUpgradeable.sol still has the original name of IPeripheryImmutableState.sol, which does not match the contract implementing the interface file. PeripheryUpgradeable.sol is a modified version of Uniswap's PeripheryImmutableState.sol. But the interface that is implemented in the RAMSES file is not renamed to match the contract name. Instead, the original IPeripheryImmutableState interface name remains. Although out of scope, the _gauges function argument in Voter.initialize() would be better named _gaugefactory, because the variable name _gauges is used elsewhere in the contract to refer to a different variable.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "37. Remove library functions that are never used", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-RAMSES.md", "body": "checkTicks() is declared at the end of Tick.sol but is never called. The only place where the code acknowledges this function is a comment in collect() with the word \"checkTicks\". checkTicks() could be called in RamsesV2Pool.snapshotCumulativesInside() to replace the existing tick checks, but this may only make sense if checkTicks() gets called in more than one location.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "38. RamsesV2Pool view functions don't return all struct values", "html_url": "https://github.com/yAudit/reports/blob/main/md/06-2023-RAMSES.md", "body": "One specific example of this is ticks() that does not return: cleanUnusedSlot cleanUnusedSlot2 periodSecondsPerLiquidityOutsideX128 periodSecondsPerBoostedLiquidityOutsideX128 Another example is boostInfos(uint256, bytes32) which returns values from a BoostInfo struct but does not return secondsPerLiquidityPeriodStartX128 or secondsPerBoostedLiquidityPeriodStartX128. A third example is observations() which returns all values from the Observation struct except for boostedInRange.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "1. Underflow in int256 -> uint256 conversion", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md", "body": "In GTranche.sol, pnlDistribution() and _pnlDistribution() calculate the new _trancheBalances in int256 values before casting them to uint256 when storing in the return variables. This final casting will cause an underflow if the int256 value _trancheBalances is negative. For example: Assume a scenario where the Junior Tranche is permitted 50x leverage, so the Senior Tranche has 5000 wei and the Junior Tranche has 100 wei (root causes include: no minimum deposit in the tranche, no limit on the leverage allowed, no limit on the fixed yield paid to the Senior Tranche) If the PnL distribution is not done in a long time, it is possible that the seniorProfit owed to the Senior Tranche will be greater than 100 wei. This needs to be paid to the Senior Tranche even if the profit of the tranche is zero (if lastTotal <= totalValue then distributeProfit() will be triggered). distributeLoss() prevents loss[0] from holding a value that is greater than _trancheBalances[0], which would cause a negative _trancheBalances[0] after this subtraction and would later underflow. In contrast, distributeProfit() has no similar check and there is even a comment stating that the profit to the Junior Tranche can be negative, which would make it similar to a loss scenario for this tranche. If the value of -1 * (_amount - seniorProfit) is greater than _trancheBalances[0], then the addition operation will actually become a subtraction and result in _trancheBalances[0] holding a negative value, which would underflow in a later casting. The same underflow issue may theoretically occur with distributeLoss() if _amount - _trancheBalances[0] > _trancheBalances[1]. This might be possible in a tranche setup where nearly all the deposits are in the Junior Tranche so the utilization ratio is nearly zero, but an accounting error causes the losses to be greater than the total tranche assets. This scenario seems unlikely but still may be worth protecting against.", "labels": ["yAudit", "Severity: High", "Difficulty: n/a"]}, {"title": "2. sellAllRewards() reverts with non-zero numberOfRewards", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md", "body": "The swapExactTokensForTokens() function in Uniswap V2 Router has a safeTransferFrom() call. The address calling the Uniswap V2 router must approve the tokens for the Router before calling this function, otherwise the function will revert. The ConvexStrategy fails to approve additional reward tokens before calling Uniswap V2.", "labels": ["yAudit", "Severity: Medium", "Difficulty: n/a"]}, {"title": "3. wethAmount in rewards calculations should be balanceOf", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md", "body": "When _sellRewards() calculates the rewards that can be reinvested into 3CRV, it starts calculating with a wethAmount of zero. However, the minimum amount for converting CRV rewards or CVX rewards to ETH is 1E18 of CRV or CVX, while the minimum amount for converting ETH to 3CRV is 1E16 ETH. Assuming the current prices of $1200 WETH, $0.5 CRV, and $3.50 CVX, it is possible for a scenario where $11 worth of CRV and CVX is converted into WETH, but because the 1E16 threshold for converting WETH to 3CRV is $12, the WETH will not be converted into 3CRV. If this case happens many times, substantial WETH could accumulate in the strategy without getting reinvested to earn more yield.", "labels": ["yAudit", "Severity: Medium", "Difficulty: n/a"]}, {"title": "4. Tranche deposit/withdrawal denial of service", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md", "body": "The current code is written in a way that assumes the utilisation ratio remains below the utilisationThreshold unless a deposit or withdrawal will move it above the threshold. In fact, the utilisation ratio can achieve a value greater than utilisationThreshold in a couple of ways: The owner can set utilisationThreshold to any value with setUtilizationThreshold(). If the threshold is set to a value less than the current utilisation ratio, it can break assumptions about how the protocol should work and prevent tranche deposits or withdrawals. Losses for the Junior Tranche may result in a scenario where the utilisation ratio exceeds the utilisationThreshold. Note that the Junior tranche can experience a loss even when distributeProfit() is called because the yield paid to the Senior Tranche depositors may exceed the profit earned. If the utilisation ratio exceeds the utilisationThreshold, a GTranche deposit() or withdraw() that attempts to move the utilisation ratio in the correct direction may revert if it does not bring the ratio below utilisationThreshold. This behaviour breaks an assumption in the protocol documentation that such actions should always be allowed.", "labels": ["yAudit", "Severity: Medium", "Difficulty: n/a"]}, {"title": "5. Unreliable Senior Tranche yield", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md", "body": "PnLFixedRate.sol does not account for seniorProfit in two cases: In distributeLoss() when the loss is greater than or equal to the value of the Junior Tranche and could cause losses for the Senior Tranche In distributeProfit() when the utilisation ratio is greater than utilisationThreshold", "labels": ["yAudit", "Severity: Medium", "Difficulty: n/a"]}, {"title": "6. Timing mismatch between time-gated actions", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md", "body": "_calculateLockedProfit() is designed to slowly release profits to the GVault depositors. If the releaseTime is surpassed, which is 24 hours, it returns zero, which means no profit is locked. The lockedProfit value is updated when report() in GVault is called by a strategy's runHarvest(). ConvexStrategy's canHarvest(), which indicates when a keeper can call runHarvest(), has a constant MIN_REPORT_DELAY value of 48 hours. This means that if MIN_REPORT_DELAY is the determining factor for when a harvest happens, _calculateLockedProfit() will return zero for roughly half of that minimum time period. During the time that _calculateLockedProfit() returns zero, the profit calculation in PnLFixedRate of totalValue - lastTotal will return zero. This will causes the Senior Tranche to take value from the Junior Tranche to pay the fixed yield of the Senior Tranche. An example of how this could be leveraged to cause a loss for Junior Tranche holders: Depositor deposits 3CRV into the GVault The GVault does not move 3CRV to the strategy until report() is called by a strategy, so the assets may not maximize their yield for some time Depositor deposits their GVault ERC4626 tokens into the Senior Tranche and soon withdraws. The deposit and withdrawal may both be done in a short period (say, 24 hours) while _calculateLockedProfit() is returning zero. This means before report() will not have been called to deposit the loose 3CRV in the GVault to maximize yield, yet the depositor claims their fixed yield from the Senior Tranche at the cost of Junior Tranche depositors, who don't reap the full benefits of the 3CRV deposit into the GVault. If the above actions are performed frequently with large amounts of capital, say twice a week, the Junior Tranche may be less appealing for depositors. This is because the Junior Tranche is willing to pay the Senior Tranche the borrowing cost for leverage, but this cost makes more sense if the Junior Tranche is able to use the 3CRV in the strategy and not when it is sitting idle in the GVault. This scenario would get worse if the tranche had a large utilization ratio, say 10x, because the fee paid to the Senior Tranche would be larger. The flip side of this is that Junior Tranche depositors would be incentivized to withdraw their deposits during the time when _calculateLockedProfit() returns zero for the same reason.", "labels": ["yAudit", "Severity: Medium", "Difficulty: n/a"]}, {"title": "7. Whale invest() and divest() denial of service", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md", "body": "A whale may deposit an extremely large amount of 3CRV into GVault. When the GVault provides this 3CRV to ConvexStrategy to invest, the invest() function makes sure that the liquidity added to the metapool is within proper slippage tolerance. If the Curve pool is imbalanced sufficiently by the added liquidity, it may not return sufficient value and cause invest() to revert due to the slippage exceeding the slippage tolerance. This denial of service would not cost the whale much to sustain the DoS because they could deposit the GVault tokens into the Senior Tranche (at least until the utilization ratio is met) and receive their fixed yield, even though the Junior Tranche is not receiving its yield because the strategy's harvesting mechanism is locked up. In theory this could lead to bankrupting the Junior Tranche if carried out for long enough because the whale's deposit can't be deposited into the metapool to maximize rewards, like the \"leach attack\" described in a separate finding. divest() has a similar slippage check that may also revert under some conditions. Since users cannot control when divest happens, the whale would need to imbalance the pool outside of Gro. This DoS is likely far more costly than the invest() DoS vector because imbalancing the Curve pool would most likely create and arbitrage opportunity.", "labels": ["yAudit", "Severity: Medium", "Difficulty: n/a"]}, {"title": "8. Strategy migration should remove old approvals", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md", "body": "setPool() in ConvexStrategy.sol gives a new metaPool infinite approval. But when this happens, the old metapool (if one was previously set) does not have its infinite approval revoked. If the old metapool had a security issue, the inability to revoke the prior approval could be problematic and would require emergency mode activation which would not be required if the approval could be revoked. The same process should take place to remove the BOOSTER approval of the old LP token.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "9. Inconsistent ERC20 imports", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md", "body": "One example showing the mixup between the OpenZeppelin and solmate ERC20 libraries is in IGVault and GVault. IGVault imports IERC20 from OpenZeppelin while GVault imports ERC20 from solmate. The solmate ERC20 library has EIP-2612 support while OpenZeppelin does not include such logic in the default ERC20 file and instead packages it in the file draft-ERC20Permit.sol. The way the code is currently written may be confusing for protocols integrating with Gro Protocol because The GVault ERC4626 token will support EIP-2612 but the GToken (and therefore the JuniorTranche and SeniorTranche) will not. Because the tranche is intended to be a wrapper for the GVault ERC4626, which does support permit(), this is not ideal because the tranche wrapper does not support permit() like the GVault ERC4626. The below slither commands can be used to demonstrate the difference in EIP2612 support. slither-check-erc --erc ERC2612 --solc-remaps \"@openzeppelin/=lib/openzeppelin-contracts/ @chainlink/=lib/chainlink-brownie-contracts/ ds-test/=lib/forge-std/lib/ds-test/src/\" ./src/tokens/GToken.sol GToken slither-check-erc --erc ERC2612 --solc-remaps \"@openzeppelin/=lib/openzeppelin-contracts/ @chainlink/=lib/chainlink-brownie-contracts/ ds-test/=lib/forge-std/lib/ds-test/src/\" ./src/GVault.sol GVault", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "10. Similar functions have different logic", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md", "body": "executeStopLoss() includes the line if (strategy == address(0)) continue; which is not in canExecuteStopLossPrimer(). Likewise, canExecuteStopLossPrimer() includes the line if (strategyCheck[strategy].primerTimestamp == 0) continue; which is not in executeStopLoss(). The two functions should share logic. Currently, the lack of a zero check for strategyCheck[strategy].primerTimestamp in executeStopLoss() means a rogue keeper could execute a stop loss before primerTimestamp has been set to a non-zero value.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "11. ConvexStrategy owner can sweep tokens", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md", "body": "Many DeFi protocols attempt to remain immutable to enable the user to maintain control over their assets at all times. While the underlying asset token is prevented from owner sweeping, the rewards returned by the Curve metapool are impacted as are the metapool LP tokens. This could lead to loss of user funds if the owner count is compromised or acts maliciously. In order to increase trust in the protocol, the owner should be a sufficiently distributed multisig to allow users to trust it.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "12. Inconsistent minimum reward amount", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md", "body": "_claimableRewards() should compare the WETH value of rewards to MIN_WETH_SELL_AMOUNT and not to , otherwise _claimableRewards() will not return a value if the amount of rewards has a value of less than 1 ETH, which is quite a large requirement for rewards values to be included in the calculations in rewards(). The existing strategy code will underestimate the rewards returned by _estimatedTotalAssets() when the value of _claimableRewards() is between 1E16 WETH and 1E18 WETH which impacts the PnL calculations.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "13. Inconsistent metapool fee inclusion", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md", "body": "The Curve docs describe calc_token_amount(), which is used in divest(), with the following: This calculation accounts for slippage, but not fees. It should be used as a basis for determining expected amounts when calling add_liquidity or remove_liquidity_imbalance, but should not be considered to be precise! This means that in invest(), the slippage calculation compares _credit, the initial 3CRV token amount, with amount * ratio, which is the 3CRV value after slippage and fees. In contrast, divest() compares _debt, the initial 3CRV token amount, with meta_amount * ratio, which is the 3CRV value after slippage but without fees.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "14. Potentially incorrect branching logic", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md", "body": "This line of realisePnl() is unreachable because if loss > _excessDebt evaluates to true, to flow would have entered this if statement instead. The duplicate line of logic should be removed or changed. The comment of here for safety, but should really never be the case before the line of code that is duplicated and never reached indicates some of the nuance of the branching may not be fully understood.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "15. setStrategies() doesn't set strategyCheck values", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md", "body": "setStrategies() does not allow setting values in strategyCheck, which is in contrast to addStrategy(). This could impact the use case where setStrategies() is useful. For example, if strategyCheck values are not set, the strategy will never return true in functions like canEndStopLoss().", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "16. Weak oracle result staleness check in staleCheck()", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md", "body": "staleCheck() only checks that the Chainlink price data is under 24 hours old. The staleness check does not consider whether the roundId data may be outdated. It is recommended to do both, as shown in other security report findings here and here. Specifically, the DAI/USD oracle updates more regularly than every 24 hours. Considering that the Gro protocol has protections in place for stablecoins losing their peg, improving the Chainlink price staleness check is a crucial consideration.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "17. No minDeposit in GTranche", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md", "body": "GVault sets a minDeposit value to prevent very small 1 wei deposits. GTranche has no comparable minimum value. When combined with the implementation of utilization() adding 1 wei to the denominator, the lack of a minDeposit is problematic in the following scenario: The utilisationThreshold is set to 3E4, implying there can be 3 tokens deposit into the Senior Tranche for every token deposited into the Junior Tranche 1 wei is deposited into the Junior Tranche 3 wei is deposited into the Senior Tranche, which should be the maximum amount permitted to maintain the 3-to-1 ratio With the current tranche holdings, utilization() returns a value of (3 * 1E4) / (1+1) = 15000, which is half of the utilisationThreshold limit of 3E4 An additional 3 wei can be deposited into the Senior Tranche. Now utilization() returns (6 * 1E4) / (1+1) = 30000, but the ratio of Senior Tranche deposits to Junior Tranche deposits is 6-to-1, not the originally intended 3-to-1 Beyond the risk of underinsured Senior Tranche deposits, another side effect of the lack of minDeposit is the possibility of an inflation attack.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "18. Volatile token price causes higher vault fees", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md", "body": "_calcFees() is called only once in GVault, from report(). _calcFees() is a bit of a misnomer because the function also takes those fees and sends them to the feeCollector address specified by the owner using setFeeCollector() while returning the gains amount minus fees. The gains are defined as the difference between all the strategy's assets (loose assets, LP tokens, and rewards) and the strategy's debt, which is a value stored in strategies[strategyAddress].totalDebt in the GVault. A key part of this is that when a strategy reports a loss, the totalDebt of the strategy is reduced to account for the loss, so it is as though the strategy received fewer assets to begin with. The combination of how fees are taken from gains and the goal post for how gains are calculated getting moved on every loss creates a problematic combination. Consider the following series of events: Value of Strategy is $1000 Strategy loses $20 and report() is triggered Strategy gains $20 and report() is triggered (pays vault fee on $20 gains) Strategy loses $20 and report() is triggered Strategy gains $20 and report() is triggered (pays vault fee on $20 gains) The strategy has paid the vault fee twice even though the value in the strategy hasn't changed. It is only the volatility in the strategy's assets that caused the fees to be applied. This penalizes depositors for market volatility instead of penalizing them for withdrawing, which is how the Gro protocol is documented to work today. Note that this specific strategy is built on 3CRV and the Frax Curve metapool, so the value of the LP tokens should only increase and not be subject to such volatility. By deducting fees at the time of profit, there is less value in the vault to compound and grow, which slightly reduces the appeal of the strategy.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "19. High default slippage tolerance", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md", "body": "The default value of PERCENTAGE_DECIMAL_FACTOR if 1E4 while baseSlippage is 50. This means the default tolerance is (10000 - 50) / 10000 = 9950 / 10000 = 99.5%, allowing for 0.5% slippage, in invest() and divest(). When the Frax metapool was examined at the time of this review, the Curve Finance frontend estimated a 0.03% slippage if withdrawing 1E8 LP tokens, which was over 20% of the total supply of the metapool. Similarly, when estimating the slippage for a deposit of 1E8 CRV tokens, which would increase the existing balance of CRV in the metapool by over 50%, the frontend estimated a 0.06% slippage. Given the size of the slippage with such large deposits or withdrawals, and considering that the default slippage tolerance on the Curve frontend for this Frax metapool is 0.1%, the existing combination of PERCENTAGE_DECIMAL_FACTOR and baseSlippage provides too large of a slippage tolerance.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "20. Use prefix in loops", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md", "body": "There are instances of this throughout the contracts, with examples of this optimization opportunity found in GStrategyGuard.sol, GTranche.sol, and GRouter.sol.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "21. Unnecessary zero initializations", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md", "body": "There are instances of this throughout the contracts, with examples of this optimization opportunity found in GTranche.sol, GRouter.sol, StrategyQueue.sol, and ConvexStrategy.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "22. Use simple comparison", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md", "body": "The withdraw() function in ConvexStrategy provides one example of this, but there are other instances in the contracts: if (withdrawnAssets <= _amount) { loss += _amount - withdrawnAssets; } else { if (loss > withdrawnAssets - _amount) { loss -= withdrawnAssets - _amount; } else { loss = 0; } } By switching around the if/else clauses, we can replace the compound operator with a simple one if (withdrawnAssets > _amount) { if (loss > withdrawnAssets - _amount) { loss -= withdrawnAssets - _amount; } else { loss = 0; } } else { loss += _amount - withdrawnAssets; }", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "23. Remove redundant check", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md", "body": "mint() in GVault checks if assets is zero and then checks if assets is less than minDeposit. The first check is redundant because if assets is zero, then assets < minDeposit is true and it will revert in the next check. This suggestion assumes that minDeposit should be 10 ** _asset.decimals() instead of _asset.decimals(), since 10 ** X where X is a uint cannot result in a value of zero. Separately, the returns in mint(), deposit(), and withdraw() are unnecessary and can be removed because the return value is the same as the named return variable.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "24. Use Solidity errors in 0.8.4+", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md", "body": "Require statements are found in the JuniorTranche, SeniorTranche, GToken, and GVault contracts (examples include 1, 2, 3, 4). Using this new solidity feature can provide gas savings on revert conditions.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "25. Declare variables immutable when possible", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md", "body": "The IsGTrancheSet boolean is set only once in GMigration.sol and can be immutable.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "26. Use unchecked if no underflow risk", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md", "body": "One example where unchecked can be applied: - loss = lastTotal - totalValue; + unchecked { loss = lastTotal - totalValue; } Similar savings can be found throughout the contracts including here, here, and here.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "27. Unusual minDeposit choice", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md", "body": "This line of GVault.sol may have a typo if the intent is to have a minimum deposit of at least one dollar (because the vault is designed for stablecoins).", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "28. Fees may be sent to address(0)", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md", "body": "The GVault default is to have vaultFee and feeCollector remain unset, which keeps them at the default values of 0 and address(0) respectively. It is possible for vaultFee to be set to a non-zero value while feeCollector remains at zero, resulting in fees getting sent to address(0).", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "29. Missing _minAmount check in redeem", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md", "body": "deposit() and mint() verify the deposit amount is greater than minDeposit while withdraw() checks that the asset amount is greater than the user-specified _minAmount before transferring tokens. redeem() does have a comparable minimum value check before assets are transferred.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "30. _owner argument shadows Ownable state variable", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md", "body": "withdraw() in GVault.sol has a _owner argument that shadows a state variable with the same name in OpenZeppelin's Ownable library.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "31. Junior tranche lacks immediate withdrawal guarantees", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md", "body": "In order to deposit in the Senior Tranche, there must be sufficient value in the Junior Tranche to protect Senior Tranche deposits. This means that if the Junior Tranche protects the Senior Tranche 1-to-1 and there is 100% utilization, no Junior Tranche funds can be withdraw. In the event that all depositors to the Junior Tranche wish to withdraw, there could be a \"bank run\" where the first users to withdrawer receive their funds, but when the utilization ratio hits 100%, no Junior Tranche funds can be withdrawn because they are needed to protect the funds in the Senior Tranche. This behaviour is the norm for tranche structures, but users who have not interacted with such a pool design may not clearly understand the limitations of the system. This could be problematic for users if they have a loan in a protocol like Aave that is about to be liquidated and they cannot withdraw their funds from the Junior Tranche to increase their loan collateralization ratio. A real scenario where this would be incentivized to take place is a \"leach attack\", when the fixed yield on the Senior Tranche exceeds what the underlying vault is capable of producing and the Senior Tranche depositors leach off the Junior Tranche value. If the Senior Tranche promised an absurdly high fixed yield, or if the underlying vault yield drops to a near-zero value, the Senior Tranche depositors would be more incentivized to keep their token in the Senior Tranche to receive the \"impossibly good\" yield, even though the yield the Senior Tranche is receiving is being taken from the token value of the Junior Tranche depositors (because the yield from the vault cannot cover the fixed yield amount). It is true that the tranche owner can set the fixed rate with setRate(), but there may be a delay before this happens (possibly a DAO vote), during which time value could be leached from Junior Tranche depositors and the Junior Tranche depositors would be unable to withdraw because 1. the utilization ratio does not permit it 2. the leaching causes a loss of value in the Junior Tranche which makes the utilization ratio even worse.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "32. Change call sequence for reentrancy mitigation", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md", "body": "In _withdraw(), funds are transferred out of the GVault before the vaultAssets state variable is updated. According to checks-effects-interactions, the external interactions should happen last, meaning the vaultAssets variable should be updated before funds are transferred. This is what the solmate ERC4626 implementation does by calling the internal _burn() first to update the totalSupply value before transferring funds, which is the opposite of when the transfer happens relative to _mint() in mint(). The same change can be applied to redeem() and report() (1, 2).", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "33. Undocumented assumption of private Gelato mempool", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md", "body": "MEV protection mitigates the risk of a frontrun, backrun, or sandwich that can extract value from a transaction. This most often happens during swap operations. The design of Gro Protocol assumes that when a Gelato keeper executes a transaction, there will be MEV protection. The Gelato documentation does not clarify that this is a guarantee that keepers offer and whether there is still risk of an uncle bandit attack. The MEV mitigation is expected to exist based on discussions with the Gro devs, but the lack of official documentation around the mempool guarantees provided by Gelato jobs, the possibility of changes over time, and the risk of a rogue Gelato keeper are all possible concerns with this approach.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "34. Inconsistent interface files", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md", "body": "metapool is cast as ICurve3Pool here because get_virtual_price() is found in the external Curve3Pool contract and is inherited by the metapool contract. However, the same could be said about remove_liquidity_one_coin(), but metapool is cast as ICurveMeta when removing liquidity (1, 2, 3) because the Curve3Pool usage in ConvexStrategy didn't use that function.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "35. Inconsistent Uniswap array indices", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md", "body": "Uniswap references the amountOut value with amounts[amounts.length - 1] with comparing that value to amountOutMin, and this approach is found once in ConvexStrategy. Another approach of hard coding an index of 1 is found elsewhere.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "36. _additionalRewardTokens() works in unexpected way", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md", "body": "In rewards(), _additionalRewardTokens() is summed with _claimableRewards(). The latter returns the value of claimable rewards that can be received if getReward() is called as it is in sellAllRewards(). In contrast, _additionalRewardTokens() does not do this. Instead, _additionalRewardTokens() sums the current balance of award tokens in the strategy. This can result in a different value than the return value of sellAllRewards(), which is likely unexpected behaviour.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "37. Non-ideal _sellAdditionalRewards() min reward limit", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md", "body": "Consider a value different from the current MIN_REWARD_SELL_AMOUNT used in _sellAdditionalRewards() because different tokens have different decimals values and different values. A more flexible choice of value would be preferable to enable flexibility with future reward tokens.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "38. Strategy migration logic can revert", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md", "body": "divestAll() is written to avoid a revert condition at all costs because it is intended to be used for the emergency scenario where reverting is not an option. divestAll() is called immediately before migratePool(). After the migration, realisePnl() is called which has has divest() calls (1, 2) which offer an opportunity for a revert to happen. This could prevent the migration from happening in some circumstances.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "39. Theoretical casting overflow", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md", "body": "This line of StopLossLogic casts a uint256 dy_diff to an int256 value. It is possible a very large unsigned value would be converted to a negative number.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "40. Differing approach to keeper role", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md", "body": "The keeper variable in GStrategyGuard stores a single address while a similar keepers variable in ConvexStrategy allows for multiple addresses to serve as keepers. Allowing more keepers provides more flexibility if Gelato changes their operations to have multiple addresses executing transactions, or to allow the owner address to serve as a keeper.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "41. Duplicate strategies possible with setStrategies()", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md", "body": "_addStrategy() does not permit a strategy to be added to the strategies array if it is already in the array. But the owner could use setStrategies() to do the same.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "42. Unnecessary ERC4626 casting", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md", "body": "getYieldToken() in FixedTokensCurve returns an ERC4626 value. But GTranche needlessly casts this return value to an ERC4626 in several places (1, 2, 3, 4).", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "43. getSwappingPrice() doesn't make sense with single strategy and vault", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md", "body": "The Gro protocol as examined only has one token that is deposited into it, as the return value of getYieldToken() shows. The current implementation of getSwappingPrice() allows any uint256 input values for function arguments i and j and always returns the input _amount which implies a 1-to-1 exchange rate between token i and token j. This return value doesn't make sense. It would make more sense to follow an implementation like getYieldToken() shows and only allow an i and j value of zero, reverting in other cases.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "44. No upper limit to Junior Tranche leverage or fixed yield", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md", "body": "Setting an upper bound on the leverage available to a Junior Tranche, and therefore a lower bound on the protection available to Senior Tranche depositors, may be prudent to avoid blatant misuse of the Gro tranche design. Additionally consider a limit on the fixed yield amount, which could be adjusted by the protocol owner depending on market conditions. Be aware that the yield in the tranche design is dollar denominated, so if the underlying asset drops in value, there could be issues in paying the fixed yield to the Senior Tranche. We can take one example of the Junior Tranche taking 20x leverage by borrowing from the Senior Tranche, with a fixed Senior Tranche yield of 2%: 100% utilizationRatio * (20x leverage - 1x from Junior Tranche) * 2% Senior Tranche Fixed Yield = 38% borrowing cost owed to Senior Tranche Due to the amount of leverage in the Junior Tranche and the yield promised to the Senior Tranche depositors, the Junior Tranche could easily see losses if it cannot continue to deliver the 38% yield.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "45. Multiple migration functions increase trancheBalances", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md", "body": "migrateFromOldTranche() increases the tranche balances here. migrate() does so here. The two migration functions appear to serve different purposes, but a boolean protecting the two functions from both getting called does not exist. Instead, hasMigratedFromOldTranche is only found in migrateFromOldTranche().", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "46. Unclear redistribution of vault fees", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md", "body": "Existing Gro protocol documentation mentions the withdrawal fees are redistributed back to the protocol. While this may not be true with the upgraded Gro protocol, if the fees are to be redistributed to the protocol, it should be done in a way that is not gameable.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "47. Tranche tokens not compliant with ERC4626", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md", "body": "To clarify, the tranche tokens do not currently implement ERC4626 but the documentation uses the word \"ERC4626 wrapper\" when describing the tranche, which could be misleading. GVault and tranche tokens import the same ERC4626 to implement basic ERC4626 support. GVault overrides many virtual functions from this import to implement them correctly according to ERC4626 specifications, but GTranche does not. The functions that should be implemented in GTranche to comply with ERC4626 include: mint() deposit() withdraw() redeem() convertToShares() convertToAssets() maxRedeem() previewRedeem() maxWithdraw() previewWithdraw() maxMint() previewMint() maxDeposit() previewDeposit()", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "48. Silent returns", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md", "body": "move() in StrategyQueue silently returns in three cases. This may give the owner calling moveStrategy() a false sense of confidence that the strategy was moved, when it in fact was not.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "49. Minor nitpicks", "html_url": "https://github.com/yAudit/reports/blob/main/md/12-2022-Gro-Protocol.md", "body": "Consider naming withdrawalQueue(uint256 i) to withdrawalQueueAt(uint256 i) and withdrawalQueue() to fullWithdrawalQueue(). Consider clarifying the strategy return value is an address, not a Strategy struct. getStrategyDebt() and getStrategyAssets() return the totalDebt of a strategy and might be improved with more similar names to avoid confusion over debt vs. assets. NatSpec is incomplete for some functions, such as missing return value descriptions for beforeWithdraw()/excessDebt/_excessDebt and no NatSpec for _removeStrategy() in GVault depositIntoTrancheForCaller() is missing a comment that _token_index of 3 or greater is 3CRV Typo: adapetr -> adapter Typo: Apporve -> Approve Typo: CHIANLINK_FACTOR -> CHAINLINK_FACTOR Typo: add_liquididty -> add_liquidity Typo: strategies -> strategy's and same here Typo: enstimated -> estimated Typo: excluding and profits -> excluding profits Typo: srategy -> strategy Typo: do generate -> to generate Typo: unledrying -> underlying Typo: beneth -> beneath and here Typo: baring -> bearing Typo: extensoin -> extension Typo: their -> there Typo: underlyng -> underlying Typo: prive -> price Typo: it -> its Typo: utiliszation -> utilisation Typo: _tranchTokens -> _trancheTokens Typo: between to underlying -> between the underlying Typo: amount of price -> amount of yield token Typo: and ontermiadry -> an intermediary Typo: amount of transform (unclear what this means) Typo: setUtilizationThreshold() (note utilization with a 'z') sets the variable utilisationThreshold (note utilisation with 's') and there is a function utilization() (note utilization with a 'z') Typo: experiene -> experience Improve precision by changing ((_lockedProfit / _releaseTime) * _timeSinceLastReport) to ((_lockedProfit * _timeSinceLastReport) / _releaseTime) to match Vault.vy approach Fix this comment that references a non-existent emergencyExit() function The emergency boolean function argument is missing a NatSpec comment as is _calcFactor() in GTranche and _loss in PnL The debt variable is not used for any purpose. It may be better to simply compare debtPayment to the value of _excessDebt(msg.sender) to replace the safeMath in this line. Inaccurate NatSpec for withdraw()'s _amount (better would be \"asset quantity needed by Vault if not holding enough asset balance\") and missing NatSpec for return values Replace PnL magic numbers with constants. For example, replace 10000 with utilisationThreshold. Junior Tranche is branded as GVT token, so this comment should replace PWRD with GVT Consider a better name than \"controller\" or \"ctrl\" in GToken for the GTranche address, because the word \"controller\" does not appear anywhere in GTranche Assets in Convex are not locked and therefore are not used to vote in reward distribution. There are potential downsides to this approach and this choice should be documented somewhere in Gro's documentation. The strategy that ConvexStrategy was inspired by does lock some tokens for voting. _claimableRewards() in ConvexStrategy does not return a value if MIN_REWARD_SELL_AMOUNT is not met and this if statement is not entered Consider replacing slippage in divestAll() with the baseSlippage value used elsewhere because baseSlippage can be modified by the owner unlike slippage estimatedTotalAssets() should replace _estimatedTotalAssets(true) with _estimatedTotalAssets(false) because the rewards return value is not needed Incomplete NatSpec for factor in _calcTrancheValue() and factor elsewhere in GTranche This return is redundant, the named return values would be returned properly without this line The SafeMath OpenZeppelin import in GToken is redundant because solidity 0.8.10 is used. The contract should be updated accordingly. The Ownable import in GToken is redundant because the import of Whitelist.sol includes Ownable already _calcTokenAmount() can remove the _deposit boolean function argument because it is never used for anything useful in the function The NatSpec in CurveOracle uses the term \"yield token\" to mostly refer to 3CRV while FixedTokensCurve NatSpec uses \"yield token\" to mostly refer to GVault shares. Consider terms that more clearly differentiate the tokens. Remove unused _tranche bool function argument from _calcTrancheValue() Remove if (_factor == 0) logic from _calcTrancheValue() because this can never happen based on current contract logic lastDistribution could be uint32 instead of uint64 Consider renaming _calcFees() to _gainSubFees()", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "1. On-chain contracts assume off-chain trust", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Incubator-DAO.md", "body": "The 90-day phase 1 period of the Incubator DAO ROOK rage quit process will involve swapping ROOK for pROOK at a 1-to-1 exchange rate. Along with the pROOK token, USDC will also be received at a rate specified by the exchangeRate value. The ROOK token will effectively be pegged to a specific number of USDC tokens during Phase 1. There are some ROOK holders that are excluded from participating in this redemption process according to the governance proposal, but there is no logic in the exchangeROOK.sol contract to prevent these parties from interacting with the contract. This could result in the draining of USDC held in the contract by these excluded parties, which would effectively cause a bank run on the exchangeROOK.sol contract because some ROOK holders will not be able to receive their promised USDC at the set exchange rate. However, it should be noted that the evidence of these acts would be visible on-chain and there is a level of established trust between the ROOK holders which allowed the current governance proposal to be agreed on. Another scenario that would have a negative impact for ROOK holders would involve the Incubator DAO multisig withdrawing ROOK from exchangeROOK.sol using withdrawAssets() to take all the USDC from this contract before other ROOK holders can redeem their tokens. By depositing ROOK into exchangeROOK.sol to get USDC, then using withdrawAssets() to withdraw the ROOK, then depositing ROOK into exchangeROOK.sol ad infinitum, the USDC would get drained from exchangeROOK.sol. This would also effectively cause a bank run on the exchangeROOK.sol contract because some ROOK holders will not be able to receive their promised USDC at the set exchange rate. An alternative approach for the Incubator DAO multisig to gain value is to withdraw ROOK from exchangeROOK.sol using withdrawAssets(), then to swap the ROOK tokens in a liquidity pool before the ROOK token has no value. While the liquidity pool would be imbalanced and be arbitraged due to the set exchangeRate value in exchangeROOK.sol, the multisig could once again take any new ROOK tokens deposited into exchangeROOK.sol and swap it into a liquidity pool again until the exchangeROOK.sol holds no more USDC.", "labels": ["yAudit", "Severity: High", "Difficulty: n/a"]}, {"title": "2. Contract owner can manipulate value received by ROOK or pROOK holders", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Incubator-DAO.md", "body": "The contract owner will be a 3-of-4 multisig and should generally be a trusted party. However, if this assumption does not hold true, there are several ways the owner could manipulate the value received by ROOK or pROOK token holders: withdrawAssets() could take out all the USDC from the exchangeROOK.sol or exchangepROOK.sol contracts. The mint() function in prook.sol can be called at any time for any amount. The owner could mint many pROOK tokens at the start of Phase 2 and sweep all the USDC from this contract before other token holders get the chance to redeem their pROOK. The setExchangeRate() function could be called to change the ROOK-USDC or pROOK-USDC exchangeRate value in exchangeROOK.sol or exchangepROOK.sol, giving some users more or less USDC in return for their ROOK tokens.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "3. Remove ERC20Votes.sol import", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Incubator-DAO.md", "body": "Incubator DAO will use the incubdao.eth snapshot.org space for governance voting. Because the governance approach will follow the approach used by ROOK, the same erc20-balance-of snapshot.org voting strategy will be used. This means that there is no need for the pROOK token to include voting logic on-chain, because the token balance held by an address will determine the votes that address receives.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "4. Limit pROOK burn functions", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Incubator-DAO.md", "body": "If a user burns their pROOK token, they will lose the chance to redeem their pROOK for USDC during Phase 2 of the Incubator DAO rage quit process. Because ERC20Burnable.sol includes a public burnFrom() function, which only requires an allowance to be given to burn pROOK tokens, it's possible that scam websites could attempt to phish users to sign a pROOK allowance and burn their tokens during Phase 1 so that pROOK holders in Phase 2 would be allocated more USDC. This is because the exchangeRate in Phase 2 will be set to remaining_USDC / pRook.totalSupply(), and burning pROOK would reduce the totalSupply value.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "5. Remove SafeMath import", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Incubator-DAO.md", "body": "Solidity 0.8.0 introduced a breaking change to implement overflow and underflow protection. This means the SafeMath imports can be removed to save gas on deployment: exchangeROOK.sol import exchangepROOK.sol import", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "6. Declare variables immutable when possible", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Incubator-DAO.md", "body": "The token variables in exchangeROOK.sol and exchangepROOK.sol can be immutable. They are only set in the constructor and are not changed after that. exchangeROOK.sol token variables exchangepROOK.sol token variables", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "7. Remove ERC20.sol import from exchange contracts", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Incubator-DAO.md", "body": "The ERC20.sol import in the exchange contracts is not needed and will spend unnecessary gas on deployment, so it can be removed. exchangeROOK.sol ERC20 import exchangepROOK.sol ERC20 import", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "8. Use consistent solidity versions", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Incubator-DAO.md", "body": "exchangeROOK.sol and exchangepROOK.sol use solidity 0.8.12, but prook.sol uses solidity ^0.8.9. Because different versions of solidity contain minor differences, and because the newer versions of solidity contain bug fixes and gas optimizations, it is generally recommended to use one of the most recent solidity versions.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "9. Add event to setExchangeRate()", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Incubator-DAO.md", "body": "Consider adding a ExchangeRateSet event in: exchangeRook.setExchangeRate() exchangepRook.setExchangeRate()", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "10. Make public functions external", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Incubator-DAO.md", "body": "Declare these public functions as external because they do not need to be called internally: mint() in prook.sol pause() in exchangeROOK.sol and in exchangepROOK.sol unpause() in exchangepROOK.sol and in exchangepROOK.sol", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "11. Incorrect values in governance proposal", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2023-Incubator-DAO.md", "body": "The governance proposal states that the exchangeROOK.sol exchangeRate will be set by the following equation: an exchange rate defined by Incubator DAO total treasury  (ROOK total supply [1,268,253.79] - DAO owned ROOK [162,807.40] - Strategic Reserve owned ROOK [452,137.53] - DAO contributors owned ROOK [35,175.14]) The first number in this equation is inaccurate and is off by about 5 ROOK. The current on-chain totalSupply value of ROOK token is 1268248.759, which is visible with etherscan or with: cast --from-wei $(cast call 0xfa5047c9c78b8877af97bdcb85db743fd7313d4a \"totalSupply()(uint256)\") The second number in this equation is also inaccurate. Based on the top ROOK holders etherscan chart, the 2nd largest ROOK holder, which we will assume is the DAO owned ROOK tokens, holds 162,780 ROOK. This is a difference of roughly 27 ROOK from the value in the governance proposal. The governance proposal does use the correct value for the Strategic Reserve owner ROOK of 452,137.53. The DAO contributors owned ROOK value is not easily checked at the time of the audit because the tokens are held by different addresses but will be combined into a multisig.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "1. Debtor debt can be cleared if rate is set to zero", "html_url": "https://github.com/yAudit/reports/blob/main/md/07-2023-TempleDAO-Lending.md", "body": "Debtor interests are calculated using the function _compoundedDebtorInterest(). The implementation of this function will return zero if the rate is set to zero: function _compoundedDebtorInterest(Debtor storage debtor) internal view returns (uint256) { uint256 _rate = debtor.rate; if (_rate == 0) return 0; .... If the interest rate is first set to a positive number and then later set to zero, then the accrued debt of the debtor will be nullified as it will be reset to zero. As we can see in the following snippet of code, the return value of _compoundedDebtorInterest() will be stored in debtor.checkpoint, which represents the current accrued debt. function _checkpointDebtor(Debtor storage debtor) internal returns (uint256) { uint256 interest = _compoundedDebtorInterest(debtor); unchecked { estimatedTotalRiskPremiumInterest += (interest - debtor.checkpoint); } debtor.checkpoint = uint160(interest); debtor.checkpointTime = uint32(block.timestamp); return interest; } Note also that balanceOf() and currentDebtOf() will be affected as these use _compoundedDebtorInterest() internally.", "labels": ["yAudit", "Severity: High", "Difficulty: n/a"]}, {"title": "2. TPI can still be updated while there is a pending change", "html_url": "https://github.com/yAudit/reports/blob/main/md/07-2023-TempleDAO-Lending.md", "body": "The TreasuryPriceIndexOracle.sol uses a cooldown mechanism for price updates. Whenever the price is updated using setTreasuryPriceIndex(), the contract will store the overwritten value and will continue to return this price as long as the cooldown duration is in effect. However, there's nothing preventing this function from being called again during the cooldown period. Doing so will nullify the cooldown for the current change: the currentTpi value (which should be active after the cooldown) will become the previousTpi and treasuryPriceIndex() will return this value before the original cooldown expires. After discussions with the devs, it was determined that the cooldown is intended to allow for the TPI to be changed again during the cooldown period if the first TPI value was set incorrectly. The logic flow in this case where setTreasuryPriceIndex() is called a 2nd time during the cooldown period to fix an error causes an even larger problem. The problem is that during the cooldown period, the previous TPI value is considered the correct TPI value. If an incorrect TPI value is set, it will be stored in the currentTpi variable, but when it gets replaces with a second setTreasuryPriceIndex() call, the value previously stored in currentTpi will be stored as previousTpi. This means the incorrect TPI value will immediately become the real TPI value used by the protocol during the process of attempting to replace and fix the original mistake. The result is that the cooldown and the surrounding logic potentially make the situation worse than if the contract didn't implement the cooldown, because in the current flow, an attempt to fix a mistake by updating the TPI causes the mistaken TPI value to immediately be used in production. Note also that it is possible to adjust the cooldown duration while there is a current pending change too. This is another way that the TPI can be changed faster than the existing cooldown.", "labels": ["yAudit", "Severity: Medium", "Difficulty: n/a"]}, {"title": "3. Updating the debt ceiling for the line of credit strategy should trigger an update to the interest rate", "html_url": "https://github.com/yAudit/reports/blob/main/md/07-2023-TempleDAO-Lending.md", "body": "The calculation of the interest rate in the line of credit contract depends on the interest rate model and the utilization ratio, which is the debt over the available amount of tokens, defined as the debt ceiling of the strategy. If any of these values changes, the interest rate should be updated. While the rate is updated when the strategy changes, there is nothing ensuring that the interest rate is recalculated if the debt ceiling for the line of credit strategy gets updated in the TreasuryReservesVault.sol contract.", "labels": ["yAudit", "Severity: Medium", "Difficulty: n/a"]}, {"title": "4. Possibility of TLC bad debt from TPI increase", "html_url": "https://github.com/yAudit/reports/blob/main/md/07-2023-TempleDAO-Lending.md", "body": "The TPI is a value that is set by TempleDAO governance. This value is updated in a single block. For example, the latest TPI increase can be seen with: cast call 0xC3133cB9e685ccc82C73FbE580eCeDC667B41917 \"templePriceFloorNumerator()(uint256)\" --block 17737310 Return Value: 10250 cast call 0xC3133cB9e685ccc82C73FbE580eCeDC667B41917 \"templePriceFloorNumerator()(uint256)\" --block 17737311 Return Value: 10600 The TPI value is assumed to be equal to the price of TEMPLE when the value of TEMPLE collateral is calculated in TempleLineOfCredit.sol. This is in contrast to lending protocols such as Compound Finance, which use the current price of a token from Chainlink to determine the value of user collateral. It is possible, in fact likely, that the TPI value is greater than the value of TEMPLE based on the spot price of the Balancer pool. The graph illustrating the variation of the two prices is found on TempleDAO's homepage. If the difference between the spot price in the Balancer pool and the TLC is too great, an arbitrageur can leave the protocol with bad debt. Consider a scenario where TPI was at $1, the spot price of TEMPLE is $0.90, and the TPI was just raised by governance to $1.15: User takes DAI flashloan from Balancer with a 0% cost. User swaps DAI for TEMPLE in TEMPLE-DAI balancer pool. The volume of the swap can raise the TEMPLE price in the pool to $0.95 User deposits the newly acquired TEMPLE into the TLC and maxes out their LTC with a 85% LTV loan. The user will get liquidated almost immediately because the interest accumulated in the next block will cause them to exceed the max LTC threshold of 85%. But the user doesn't care, because $1 worth of DAI got them 1/0.95 = 1.053 TEMPLE. This TEMPLE is valued at 1.053*1.15 = $1.211 and can have 85% of its value borrowed, which is 1.211*0.85 = 1.029 In this example scenario, the arbitrageur walks away with a 2.9% profit. The bad debt will lower the holdings of the TempleDAO treasury and reduce the TPI, impacting TEMPLE token price. Another version of this bad debt scenario can happen in reverse if the TPI is decreased significantly while the TEMPLE spot price is significantly below TPI: User takes TEMPLE flashloan from Balancer with a 0% cost. User deposits TEMPLE into TLC, takes out DAI loan with max LTV when TPI is high relative to current TEMPLE token price. User swaps DAI to TEMPLE in Balancer pool when TEMPLE price is below TPI. User repays flashloan, retaining any profit. The profit comes at the expense of the TempleDAO treasury. There are already some protective measures preventing this scenario, but because these protective measures are controlled by governance, it's possible that future protocol changes may limit the effectiveness of these protective measures. The protective measures include: RAMOS should rebalance the price of TEMPLE in the Balancer pool if the price of TEMPLE drops below 1% of the TPI (note: the script linked to was not in the commit hash that the audit focused on). The maxTreasuryPriceIndexDelta value limits how large of a change the TPI can experience thanks to a check in setTreasuryPriceIndex(). The current choice of setting maxTreasuryPriceIndexDelta to 0.05 combined with the current choice of setting the max LTV to 0.85 should protect the protocol. However, be aware these values can be changed by governance, and there is no cooldown on setTreasuryPriceIndex(), meaning there is no real limit to how much governance can increase TPI in a single block. The first protective measure mentioned, the RAMOS rebalancing, is run by a bot controlled by governance. This bot is running off-chain and has the potential for more downtime that the Ethereum blockchain. Therefore, when consider extreme edge cases, the most extreme case is a scenario where the RAMOS bot is offline and is temporarily unable to stabilize the price of TEMPLE in the Balancer pool.", "labels": ["yAudit", "Severity: Medium", "Difficulty: n/a"]}, {"title": "5. checkNSignatures() logic causes revert", "html_url": "https://github.com/yAudit/reports/blob/main/md/07-2023-TempleDAO-Lending.md", "body": "SafeForked.checkNSignatures() has an extra line require(keccak256(data) == dataHash, \"GS027\"); that is not found in v1.3.0. This line is found in the latest v1.4.1 release of the Gnosis Safe code. But the values of dataHash and data in the gnosis code are set differently than in the TempleDAO code. When checkNSignatures() is called from ThresholdSafeGuard.checkTransaction() with the line SafeForked.checkNSignatures(safeTxExecutor, safe, keccak256(txHashData), data, signatures, threshold);, the expectation is that data == txHashData to pass the later require statement. But data != txHashData because txHashData consists of encoded values that includes data. If this require() check fails, all calls to ThresholdSafeGuard.checkTransaction() that include at least one contract signature (when v == 0) will fail, reverting the transactions passing through the Gnosis guard. After discussions with the development team, the bug exists in the if/else branch where v == 0. This logical branch is not expected to be reached because the new governance multisig that will be using the Gnosis Safe Guard will only have EOA signers and no smart contract signers. This means the problematic line of code should not be reached by TempleDAO logic.", "labels": ["yAudit", "Severity: Medium", "Difficulty: n/a"]}, {"title": "6. Can repay debt for wrong borrow token", "html_url": "https://github.com/yAudit/reports/blob/main/md/07-2023-TempleDAO-Lending.md", "body": "repay() and repayAll() accept a token and strategy function argument. There are two valid token values, the DAI address or the TEMPLE address. This is confirmed by the existing strategies and the deployment scripts for dUSD and dTEMPLE as the only debt tokens. There is no verification that the token and strategy arguments match, meaning that the token address can be a borrow token that does not match with the borrow token used by the strategy. The only strategy that handles more than one token (DAI and TEMPLE) is the Ramos strategy, so the other strategies should be limited to accumulating only debt in the token that they handle. It is unclear how the debt token and credit balances are queried off-chain to handle accounting of the overall system (this accounting is not performed on-chain with an equivalent of yearn vault's report()), but this scenario may cause accounting issues if the debt and credit balances are handled improperly. The caller of repay() does donate tokens to the protocol, so there is a cost to this call flow. A foundry test demonstrating this issue, based on the existing test_repay_withDTokenDebts_noCreditLeft test: function test_repay_withDTokenDebts_wrongToken() public { // Setup the config { vm.startPrank(executor); trv.setBorrowToken(dai, address(0), 0, 0, address(dUSD)); trv.setBorrowToken(temple, address(0), 0, 0, address(dTEMPLE)); deal(address(dai), address(trv), 120e18, true); deal(address(temple), address(trv), 120e18, true); ITempleStrategy.AssetBalance[] memory debtCeiling = new ITempleStrategy.AssetBalance[](1); debtCeiling[0] = ITempleStrategy.AssetBalance(address(dai), 50e18); trv.addStrategy(address(strategy), -123, debtCeiling); } // Borrow some so there's a debt { changePrank(address(strategy)); trv.borrow(dai, 5e18, address(strategy)); } // Fund alice so she can repay on behalf of the strategy { deal(address(temple), alice, 50e18, true); changePrank(address(alice)); temple.approve(address(trv), 50e18); } { trv.repay(temple, 7e18, address(strategy)); } // TEMPLE transferred to TRV, dToken DAI credit given to strategy as it started with no debt assertEq(dai.balanceOf(address(strategy)), 5e18); assertEq(dai.balanceOf(address(trv)), 120e18 - 5e18); assertEq(temple.balanceOf(address(alice)), 50e18-7e18); assertEq(trv.strategyTokenCredits(address(strategy), dai), 0); assertEq(trv.strategyTokenCredits(address(strategy), temple), 7e18); assertEq(dUSD.balanceOf(address(strategy)), 5e18); assertEq(dTEMPLE.balanceOf(address(strategy)), 0); }", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "7. Potential clashing between function calls and ETH payments in ThresholdSafeGuard.sol", "html_url": "https://github.com/yAudit/reports/blob/main/md/07-2023-TempleDAO-Lending.md", "body": "Threshold configurations for functions are stored in a mapping whose keys are the contract address and the function selector. The check then queries this mapping to fetch the associated threshold setting. ETH transfer transactions are represented by a function selector of zero, as indicated by this comment: @dev functionSignature=bytes(0) is ok as this represents an ETH transfer which may also have an explicit threshold. As zero function selectors are valid (see issue Function selectors with a zero value are valid), this unveils a potential clashing between a function whose selector is zero and an ETH transfer. The checkTransaction() function casts the calldata parameter to bytes4 without checking the size: ... threshold = getThreshold(to, bytes4(data)); ... If the data argument is empty, then bytes4(data) will be zero, creating a conflict with a potential call to a function with a zero selector.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "8. currentUtilisation() can return stale data", "html_url": "https://github.com/yAudit/reports/blob/main/md/07-2023-TempleDAO-Lending.md", "body": "The logic of _currentUtilisation() is to loop through the buckets and sums the amounts. But this naive approach omits the possibility that the buckets contain old data that will be cleared on the next preCheck() and therefore the values stored in some buckets may not be relevant to checking the proximity to the current cap. These stale buckets should be ignored, the same way those stale buckets are cleared in preCheck(). This is only an issue when _currentUtilisation() is called from currentUtilisation(), because when called from preCheck() the buckets are updated before the call to _currentUtilisation().", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "9. setConfig() resets buckets and gives minor circuit breaker bypass", "html_url": "https://github.com/yAudit/reports/blob/main/md/07-2023-TempleDAO-Lending.md", "body": "setConfig() lets governance choose new values for period duration, buckets, and cap. In this process, it resets the amount value of every bucket. While the bucket values are all reset to zero (or 1, though this dust is subtracted out later), this gives a window of opportunity to maximize the value passing through the circuit breaker. The worst case scenario with one setConfig() call is twice the circuit breaker cap value, and this can be generalized to n+1 times the circuit breaker cap for n number of setConfig() calls in a short timespan. So if a user frontruns a single setConfig() call to reach the cap before the config is changed, then setConfig() will reset all the buckets and the user can reach the cap again (second time) in a very short timespan, potentially in a single block.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "10. Weak liquidation incentives can result in unliquidated bad debt", "html_url": "https://github.com/yAudit/reports/blob/main/md/07-2023-TempleDAO-Lending.md", "body": "The liquidation of an undercollateralized position in TLC is performed by batchLiquidate(). The function checks if an address has an undercollateralized loan, and if so, the TEMPLE collateral is burned. No DAI is moved because the lender did not return the loaned funds, so only the collateral is in the protocol's possession. The burning of user-owned TEMPLE means that there is more treasury value per user-owned TEMPLE, increasing the protocol TPI. An increase in TPI indicates an increase in TEMPLE token price. This means that even though there is no liquidation incentive like there is in a protocol such as Compound Finance, TEMPLE holders should be incentivized to perform liquidations because it increases the value of the token they hold. The problem with this assumption is that it may fail in conditions with high gas prices or where all token holders hold only small amounts of the token, leading to a bad debt situation that sits unresolved and grows worse due to accumulating interest. Assume turbulent market conditions exist and cause mainnet gas prices to increase to $100 for a liquidation transaction. Further, assume that some loans might be eligible for liquidation due to interest accumulation, possibly from the same market turbulence. If a user owns 1% of all circulating TEMPLE, then to make the $100 transaction profitable to execute, the liquidation would have to result in a $10,000 profit to the protocol. If the $10,000 profit represents the 15% overcollateralization of the loan, then the total loan size is $66,666, which is a very large loan. Given this example, it may be no surprise that the protocol is designed in a way that the bot maintained by governance is expected to be the main liquidator for the protocol. This is because there is no incentive given to the liquidator except an increase in TPI (as long as the liquidation is profitable), and because the protocol multisig is the largest token holder at the current time, governance has the most incentive to liquidate positions and increase TPI. But in the case that governance is the primary liquidator, there is the risk that if governance liquidates positions when gas costs exceed liquidation profits, this impacts token value for all TEMPLE holders by lowering TPI because gas costs are paid by the same treasury that represents the value held by the TEMPLE token. There is the addition risk that if the bot goes offline, no one will have incentive to liquidate positions, but given the borrowing interest rate curve and active role of governance in this protocol, that is a much lesser risk. This example shows that there is limited incentive for most TEMPLE token holders to liquidate undercollateralized positions. If the undercollateralized loan sits unresolved, the TEMPLE that serves as collateral to that loan is effectively weighing down the TPI. Even though it is not profitable for any user to liquidate the undercollateralized position, especially smaller loans, there will be no increase in TPI until gas prices drop enough to make the liquidation profitable (a quicker solution) or the loan accumulates enough interests to counteract the high gas prices (a slower solution). The current design of TempleDAO is to use a governance-run bot to perform the liquidations, but this bot can encounter the same situation of unprofitable liquidations. If there are small value loans that are undercollateralized, the bot should not liquidate the loans when there are very high gas costs, because the protocol will lose value. It is also possible that the governance-run bot goes offline due to an outage in Google Cloud, AWS, or whichever server provider(s) are used, so the on-chain bot cannot be relied on to have 100% uptime on par with a stable blockchain.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "11. Function selectors with a zero value are valid", "html_url": "https://github.com/yAudit/reports/blob/main/md/07-2023-TempleDAO-Lending.md", "body": "Function selectors are represented by the first four bytes of the hash of the function signature. As these are the result of a hash function, it is possible and valid to have a function selector with the zero value (i.e. the first four bytes are zero). There are two occurrences in the codebase in which function selectors taken as input arguments are validated to be different from zero: setExplicitAccess() in TempleElevatedAccess.sol setFunctionThresholdBatch() in ThresholdSafeGuard.sol", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "12. Aura rewards may be locked in AuraStaking", "html_url": "https://github.com/yAudit/reports/blob/main/md/07-2023-TempleDAO-Lending.md", "body": "The getReward() function is intended to collect the reward tokens received from staking in Aura and send those tokens to rewardsRecipient. But the rewardTokens array is only set in the constructor and cannot be modified after. The Aura contract has a addExtraReward() function that can add to the existing list of reward tokens, but AuraStaking.sol is not designed for such flexibility. If AuraStaking.sol does not contain the full list of reward tokens, then the missing tokens will be sent from Aura to AuraStaking.sol and stay trapped in the TempleDAO contract.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "13. Borrowers may be instantly liquidated after rescue mode is disabled", "html_url": "https://github.com/yAudit/reports/blob/main/md/07-2023-TempleDAO-Lending.md", "body": "After rescue mode is enabled, all major functions of the contract are paused (notInRescueMode modifier). This means that repayments cannot be done by borrowers (since repay() and repayAll() are blocked), but their debt is still accrued. If a position becomes unhealthy while the rescue mode is enabled, a borrower can be liquidated as soon as the pause is disabled, and before they can even attempt to normalize their situation.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "14. Token allowance isn't revoked when updating TRV in Gnosis strategy", "html_url": "https://github.com/yAudit/reports/blob/main/md/07-2023-TempleDAO-Lending.md", "body": "When repayments to the treasury vault are made from the Gnosis strategy, both repay() and repayAll() will execute an infinite (i.e. type(uint256).max) token approval so that the vault can pull the tokens from the strategy contract. The treasury vault contract can be updated in strategies, however, the implementation of _updateTrvApprovals() is empty for the GnosisStrategy.sol contract. This means that previously configured vaults will still have unrestricted access to tokens held by the strategy contract.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "15. Validate rate parameters in LinearWithKinkInterestRateModel.sol", "html_url": "https://github.com/yAudit/reports/blob/main/md/07-2023-TempleDAO-Lending.md", "body": "When the utilization ratio is above the kink, the slope of the linear model is defined as (maxInterestRate - kinkInterestRate) / kinkUtilizationRatio. This means that maxInterestRate >= kinkInterestRate. Similarly, in the other case, the slope is defined as (kinkInterestRate - baseInterestRate) / kinkUtilizationRatio, which implies that kinkInterestRate >= baseInterestRate.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "16. Account validation in TempleElevatedAccess.sol", "html_url": "https://github.com/yAudit/reports/blob/main/md/07-2023-TempleDAO-Lending.md", "body": "The constructor of TempleElevatedAccess.sol initializes initialRescuer and initialExecutor without checking for zero/empty addresses. Additionally, as the rescuer account is intended to be a support role of the executor account, it is important to validate that both accounts are not the same address. The design intent is for rescuer and executor to be multisigs and not EOA, so an extra check can be added to verify these addresses are contracts.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "17. Zero token transfers while claiming rewards in AuraStaking.sol", "html_url": "https://github.com/yAudit/reports/blob/main/md/07-2023-TempleDAO-Lending.md", "body": "Some ERC20 implementations revert on zero value transfers. The implementation of the getReward() function in the AuraStaking.sol contract executes a token transfer of the contract's token balance without actually checking if the balance is not zero. Since all reward tokens are pulled and transferred simultaneously, a failure in any of the token transfers would result in a transaction revert, causing a denial of service in the reward claiming process.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "18. Insufficient gas for max buckets in TempleCircuitBreakerAllUsersPerPeriod.sol", "html_url": "https://github.com/yAudit/reports/blob/main/md/07-2023-TempleDAO-Lending.md", "body": "TempleCircuitBreakerAllUsersPerPeriod.sol comments and the declaration of buckets indicate that the design is intended to allow up to 65535 buckets. But it is not easy to create anywhere near this number of buckets directly, because setConfig() reverts due to lack of gas if less than 10% that many buckets are supplied in the constructor. This is because _setConfig() clear the bucket values by looping through all buckets to set their initial value to 1. Now because of how solidity memory works, it may be possible for governance to clear 4000 buckets of array space at a time without running out of gas. But then in order to reach 65k buckets, setConfig() would need to be called over 10 times, incrementally increasing the value of nBuckets each time. Overall, the current design means that realistically the maximum number of buckets is too large, and the buckets array is oversized for an ETH mainnet deployment with a 30 million gas limit.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "19. addStrategy() allows setting debt ceiling for tokens without borrowing enabled", "html_url": "https://github.com/yAudit/reports/blob/main/md/07-2023-TempleDAO-Lending.md", "body": "setStrategyDebtCeiling() checks if a token is a borrowable token before setting the debt ceiling of that token with the line if (!_borrowTokenSet.contains(address(token))) revert BorrowTokenNotEnabled();. When the debt ceiling is set in addStrategy(), there is no such check to confirm that the token is a borrowable token. This means the two functions have different checks even though they have the same onlyElevatedAccess modifier controlling who can call these functions.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "20. shutdown() doesn't delete strategyTokenCredits values", "html_url": "https://github.com/yAudit/reports/blob/main/md/07-2023-TempleDAO-Lending.md", "body": "The goal of shutdown() in TreasuryReservesVault.sol is to remove all data related to a strategy from variables and mappings. Although the credit value stored in the strategyTokenCredits mapping is used in the StrategyShutdownCreditAndDebt event, the value is never deleted.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "21. Casting overflow risk in strategy borrowing", "html_url": "https://github.com/yAudit/reports/blob/main/md/07-2023-TempleDAO-Lending.md", "body": "_availableForStrategyToBorrow() calculates how many more tokens a strategy is allowed to borrow. To prevent a revert due to underflow, the function casts uint256 values to int256 values. Casting has no overflow protection, and because the debtCeiling value can be set to any arbitrary integer, it is possible that a very high ceiling value would result in an overflow. An overflow of the sum _ceiling + _credit would not give a strategy more borrowing than it should, but an overflow of dTokenBalance could cause int256(dTokenBalance) to resolve to a negative value, increasing the strategies borrowing greater than it should be. dTokens are minted 1:1 for the amount of tokens borrowed, so it is unlikely to reach a value that is large enough to overflow the int256 data type, but a modified implementation for this function could remove the problem entirely.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "22. Ramos inconsistencies between constructor and setter functions", "html_url": "https://github.com/yAudit/reports/blob/main/md/07-2023-TempleDAO-Lending.md", "body": "setPostRebalanceSlippage() reverts when trying to set postRebalanceSlippage as zero. Because postRebalanceSlippage is zero by default, and it is not set in the constructor, it will remain zero until setPostRebalanceSlippage() is called. The same issue of a default zero value until otherwise set applies to setMaxRebalanceAmounts(), setRebalancePercentageBounds(), setTpiOracle(), setTokenVault(), and setRebalanceFees(). feeCollector() does not have this issue because feeCollector is set in the constructor. The constructor does not check if any state variables are set to valid values, but the setter functions do introduce this check. This means that the value set in the constructor may not align with the assumptions made elsewhere in the contract. For example, feeCollector cannot be set to the zero address value in setFeeCollector(), but can be set to the zero address value in the constructor. The maxRebalanceFee value implicitly should be less than BPS_PRECISION due to the accounting logic in the contract, but there is no logic in the constructor to confirm that maxRebalanceFee < BPS_PRECISION.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "23. Hardcoded Maker DSR base rate doesn't match on-chain value", "html_url": "https://github.com/yAudit/reports/blob/main/md/07-2023-TempleDAO-Lending.md", "body": "There are two issues related to how TempleDAO handles the MarkerDAO DSR rate: The first issue is easy to fix. The deployment script uses the old MakerDAO DSR value of 3.49%, but the new value is 3.19%. This is confirmed by makerburn.com and by querying the on-chain value: cast call 0x197E90f9FAD81970bA7976f33CbD77088E5D7cf7 \"dsr()(uint256)\" --block 17722371 Return value: 1000000001087798189708544327 (equates to 3.49%) cast call 0x197E90f9FAD81970bA7976f33CbD77088E5D7cf7 \"dsr()(uint256)\" --block 17722372 Return value: 1000000000995743377573746041 (equates to 3.19%) The second and third issues suggest that a redesign may be a better approach to properly handle integration with MakerDAO's DSR. Instead of storing a baseRate value and calculating the accumulated interest, these operations should be outsourced to MakerDAO's contracts to avoid conflicting accounting calculations. If mismatched accounting is allowed to operate over long timespans, the delta between the actual value accrued from MakerDAO's DSR and the estimated interest accumulated calculated by TempleDAO can grow. If the value is overestimated, this can lead to bad debt and users can be misinformed about the interest rate they expect they are getting with the MakerDAO DSR integration. Although the ideal case would be for the base rate to match the Maker DSR rate, the developer intent is to allow the base rate to change in the future to be based on a different protocol. The contract therefore cannot be designed only around MakerDAO. Additionally, governance has options to adjust the accumulated interest (by minting/burning debt tokens or temporarily overcorrecting the base rate for a short period) if precision of the internal credit and debt becomes important later. For now, the internal credit and debt is only useful for governance to compare the performance of strategies against one another, and because the comparison is relative, precise values matching the MakerDAO DSR rate will not impact the comparison process.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "24. Simplify logic in removeLiquidity() function", "html_url": "https://github.com/yAudit/reports/blob/main/md/07-2023-TempleDAO-Lending.md", "body": "In the implementation of removeLiquidity(), tokens are repaid to the strategy by iterating the array of assets and checking if each asset corresponds to the quote or protocol token. This is not really needed and can be simplified by removing the loop and just repaying both tokens.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "25. Avoid burn logic if amount is zero", "html_url": "https://github.com/yAudit/reports/blob/main/md/07-2023-TempleDAO-Lending.md", "body": "The amount of tokens to burn is limited by the actual debt amount of the debtor. This means that, even if the original argument (_burnAmount) is greater than zero, it can be overridden to zero if the debtor doesn't have any debt. If this is the case, the implementation will still call the internal function _burn(), wasting gas in operations that won't alter the state. This is particularly relevant, in the context of the vault, for strategies that execute repayments without having any actual debt. Repayment logic calls the burn() function of the debt token to know how much excess should be accounted for as credit.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "26. Duplicate and unneeded logic in repayAll()", "html_url": "https://github.com/yAudit/reports/blob/main/md/07-2023-TempleDAO-Lending.md", "body": "Shared logic present in the _repayToken() contains code which is not really needed for the case of repayAll(). Account debt is recalculated (calls to _currentAccountDebt()). The check to validate that the amount does not exceed the debt is not needed (since _repayAmount equals _newDebt). debtCheckpoint can be set directly to zero, as it is paying the full debt.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "27. Move debt token cache out of the loop in computeLiquidity()", "html_url": "https://github.com/yAudit/reports/blob/main/md/07-2023-TempleDAO-Lending.md", "body": "In computeLiquidity(), the debt token cache struct is data independent in the for loop and can be moved outside to improve gas costs.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "28. Debt token cache is re-initialized in borrow() function", "html_url": "https://github.com/yAudit/reports/blob/main/md/07-2023-TempleDAO-Lending.md", "body": "The borrow() function first initializes the cache in line 204 and then calls the _checkLiquidity() internal function which also initializes the same cache.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "29. Change visibility of public constants", "html_url": "https://github.com/yAudit/reports/blob/main/md/07-2023-TempleDAO-Lending.md", "body": "Several contracts define a VERSION constant that is marked as public, while at the same time expose the same constant value in an explicit getter function. Examples: TempleDebtToken.sol TreasuryReservesVault.sol DsrBaseStrategy.sol", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "30. Cache storage variable locally to prevent multiple reads from storage", "html_url": "https://github.com/yAudit/reports/blob/main/md/07-2023-TempleDAO-Lending.md", "body": "rewardsRecipient in AuraStaking::getReward() rewardTokens[i] in AuraStaking::getReward() poolHelper in Ramos::rebalanceUpExit() poolHelper in Ramos::rebalanceDownExit() poolHelper in Ramos::rebalanceUpJoin() poolHelper in Ramos::rebalanceDownJoin() tokenVault in Ramos::addLiquidity() tokenVault in Ramos::removeLiquidity() totalPrincipal in TempleDebtToken::currentTotalDebt() maxTreasuryPriceIndexDelta in TreasuryPriceIndexOracle::setTreasuryPriceIndex() rescuer in TempleElevatedAccess::proposeNewRescuer() cap in TempleCircuitBreakerAllUsersPerPeriod::preCheck() treasuryReservesVault in DsrBaseStrategy::trvWithdraw() treasuryReservesVault in GnosisStrategy::borrowMax() treasuryReservesVault in GnosisStrategy::repay() treasuryReservesVault in GnosisStrategy::repayAll() treasuryReservesVault in TempleTokenBaseStrategy::trvWithdraw() _accountData.collateral in TempleLineOfCredit::removeCollateral()", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "31. Unneeded unsafe downcasting in debt token cache", "html_url": "https://github.com/yAudit/reports/blob/main/md/07-2023-TempleDAO-Lending.md", "body": "The DebtTokenCache struct is used in TempleLineOfCredit.sol as a cache to initialize several values from storage to be used in different functions of the contract. In this cache struct, the interestAccumulator field is defined as uint128 while its matching field in the struct used in storage is defined as uint256, leading to an unsafe downcast while initializing the struct in _initDebtTokenCache()", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "32. Set proper types to remove SafeCast operations", "html_url": "https://github.com/yAudit/reports/blob/main/md/07-2023-TempleDAO-Lending.md", "body": "Multiple setter functions in TreasuryPriceIndexOracle.sol cast function arguments to smaller integer types (1, 2, 3). This casting is unnecessary if the function argument is the proper type.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "33. Use unchecked if no underflow risk", "html_url": "https://github.com/yAudit/reports/blob/main/md/07-2023-TempleDAO-Lending.md", "body": "The subtractions in _mintDToken() can be unchecked because they are inside if/else branches with logic that prevents an underflow from happening (L569, L577). The calculation of _remaining in _burnDToken() can be made unchecked because _burnedAmount is the same as the value of toBurnAmount or less, based on the logic found in dToken burn(). The calculation of _delta in setTreasuryPriceIndex() can be unchecked. The calculation of _newDebt in _repayTotalDebt() can be unchecked. In _burn(), the updates to the _burnAmount variable can be unchecked, as the repaid amount should be less than the amount to burn (L275, L284, L293, L297).", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "34. enoughCooldown modifier can be simplified", "html_url": "https://github.com/yAudit/reports/blob/main/md/07-2023-TempleDAO-Lending.md", "body": "enoughCooldown performs two checks: lastRebalanceTimeSecs != 0 lastRebalanceTimeSecs + cooldownSecs > block.timestamp In the case that lastRebalanceTimeSecs is zero, the 2nd condition will return false assuming cooldownSecs is set to a value less than block.timestamp. This means the first condition can be removed from the if statement to save gas.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "35. Upgrade outdated dependencies", "html_url": "https://github.com/yAudit/reports/blob/main/md/07-2023-TempleDAO-Lending.md", "body": "package.json lists @gnosis.pm/safe-contracts version 1.3.0 as a dependency. This version is the latest version available in the npm package but v1.4.1 is the latest available from the main gnosis repository. While the dependency is not used extensively though and is only imported into ThresholdSafeGuard.sol, SafeForked.sol, and IThresholdSafeGuard.sol, dependencies should remain updated to include the latest bug fixes. The prb/math dependency might be an easier to change because the npm package is update. Only the version number needs upgrading from 3.3.1 to the latest 4.0.1.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "36. Incorrect variable type in BalancerPoolHelper", "html_url": "https://github.com/yAudit/reports/blob/main/md/07-2023-TempleDAO-Lending.md", "body": "The two return value structs are defined in IBalancerVault.sol. Observe that assets is of type IERC20 in JoinPoolRequest but of type address in ExitPoolRequest. struct JoinPoolRequest { IERC20[] assets; uint256[] maxAmountsIn; bytes userData; bool fromInternalBalance; } struct ExitPoolRequest { address[] assets; uint256[] minAmountsOut; bytes userData; bool toInternalBalance; } In comparison, these structs should have the same types according to the Balancer docs. The on-chain Balancer implementations of JoinPoolRequest and ExitPoolRequest also shows consistency in variable types between the structs, although type IAsset is used instead of type address.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "37. High centralization risk throughout protocol", "html_url": "https://github.com/yAudit/reports/blob/main/md/07-2023-TempleDAO-Lending.md", "body": "Every DeFi protocol must decide how immutable or centralized the protocol will be. TempleDAO's design falls on the very centralized end of the spectrum. This by design and does not add risks if governance actions are only performed by trusted parties. But because this assumption is not governed by immutable code, some users may not be convinced that this assumption holds at all time. If this assumption does not hold, governance can: Withdraw tokens directly from the protocol contracts including AuraStaking.recoverToken(), AuraStaking.withdrawAllAndUnwrap(), AuraStaking.withdrawAndUnwrap(), Ramos.recoverToken(), TempleLineOfCredit.recoverToken(), TreasuryReservesVault.recoverToken(), etc. The majority of public or external functions in TempleDAO v2, especially in RAMOS and the strategies, has access control modifiers that allow only a governance multisig to call these functions. Many functions control key state variables that influence fees, Off-chain bots controlled by governance play a key role in performing swaps to stabilize the TEMPLE token price and handle liquidations. It was not clear during this audit what the off-chain bot implementation looks like and what the security around its operation looks like. In summary, the centralized nature of TempleDAO adds some risk because of the power that governance has. This finding has a risk of Informational only because the assumption was made that the protocol has trustworthy governance. If this assumption does not hold, the risk severity would likely jump to Critical. Even if all governance operates as a trusted party, centralization brings with it the risk of private key theft that has impacted several DAOs in the last couple of years.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "38. Add events to RamosStrategy.sol", "html_url": "https://github.com/yAudit/reports/blob/main/md/07-2023-TempleDAO-Lending.md", "body": "The borrow and repay functions in RamosStrategy.sol do not emit events. This is unlike the other events such as DsrBaseStrategy.sol and TempleTokenBaseStrategy.sol.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "39. TLC lending curve configuration choices may result in low utilization ratio", "html_url": "https://github.com/yAudit/reports/blob/main/md/07-2023-TempleDAO-Lending.md", "body": "The values set in the deployment script for LinearWithKinkInterestRateModel.sol result in a significantly different borrowing curve compared to Compound v2 and Aave DAI markets. Consider the goals and risk implications of the current choices to determine how closely TempleDAO aims to align with these other protocols to remain competitive and maintain a utilization ratio in line with the DAO's goals. If the lowest borrowing rate at zero utilization is 5%, this may be too high of a borrowing rate with current market conditions to remain competitive. Compound and Aave regularly modify the values that determine their borrowing curves based on feedback from Gauntlet that accounts for current market conditions. The suggestion to lower the interest rate at zero utilization is only valid with the current Maker DSR rate of 3.19%. If Maker increases the DSR rate, such as with the recent eDSR proposal that passed, then a different y-intercept value would make sense nearer to whatever base rate DAI in the TempleDAO base strategy is earning.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "40. Potential denial of service in TempleLineOfCredit.sol contract", "html_url": "https://github.com/yAudit/reports/blob/main/md/07-2023-TempleDAO-Lending.md", "body": "The TempleLineOfCredit.sol contract contains a circuit breaker safety measure in the removeCollateral() and borrow() functions. The current implementation of the circuit breaker (TempleCircuitBreakerAllUsersPerPeriod.sol) enforces a global volume limit over a sliding window period of time. As these limits apply globally to all users, any account can artificially generate volume to hit the caps defined by the circuit breaker, causing a temporary denial of service in the contract. For example, a malicious user can repeatedly call the addCollateral() and removeCollateral() functions to exhaust the limits of the circuit breaker and make the preCheck() call revert for all other users.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "41. Unused fields in AccountData struct", "html_url": "https://github.com/yAudit/reports/blob/main/md/07-2023-TempleDAO-Lending.md", "body": "The following fields from the AccountData struct are not used throughout the codebase: removeCollateralRequestAmount borrowRequestAmount removeCollateralRequestAt borrowRequestAt", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "42. Replace magic numbers with constants", "html_url": "https://github.com/yAudit/reports/blob/main/md/07-2023-TempleDAO-Lending.md", "body": "The value 65535 appears in an if statement in TempleCircuitBreakerAllUsersPerPeriod.sol, but the value represents the length of the buckets array. The length of the array should be used instead of this magic number to give more context and accuracy to the if statement.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "43. Complexity reduction possible", "html_url": "https://github.com/yAudit/reports/blob/main/md/07-2023-TempleDAO-Lending.md", "body": "Multiple lines of code can be combined to reduce overall complexity.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "44. Hypothetical overflow", "html_url": "https://github.com/yAudit/reports/blob/main/md/07-2023-TempleDAO-Lending.md", "body": "There is no logic that prevents this summation from overflowing in _withdrawFromBaseStrategy(). However, it is very unlikely for token balances to reach such a high value, so this would be safe in most normal cases.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "45. _withdrawFromBaseStrategy() does not check if transfer may revert", "html_url": "https://github.com/yAudit/reports/blob/main/md/07-2023-TempleDAO-Lending.md", "body": "A comment in _withdrawFromBaseStrategy() indicates that the amount that is intended to be withdrawn from the base strategy may not be the amount that the base strategy returns. Specifically, the DsrBaseStrategy may return fewer tokens than requested if it does not have the amount requested.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "46. totalAvailable() can be declared external", "html_url": "https://github.com/yAudit/reports/blob/main/md/07-2023-TempleDAO-Lending.md", "body": "totalAvailable() is a public function that does not need to be public.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "47. Typos", "html_url": "https://github.com/yAudit/reports/blob/main/md/07-2023-TempleDAO-Lending.md", "body": "In AuraStaking.sol: \"_recipeint\" -> \"_recipient\" In TreasuryReservesVault.sol, recoverToken() was copied from TempleDebtToken.sol but the comment was not modified: \"Recover any token from the debt token\" -> \"Recover any token from the TRV\" In TreasuryReservesVault.sol: \"mroe\" -> \"more\" In TreasuryReservesVault.sol:: \"dToken's\" -> \"dTokens\" In AbstractStrategy.sol and the 5 other strategy contracts: \"stratgy\" -> \"strategy\" In AbstractStrategy.sol and the 5 other strategy contracts: \"onthe\" -> \"on the\" In TempleDebtToken.sol: \"stoarge\" -> \"storage\" The link in this comment is broken", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "48. Usage of onlyElevatedAccess modifier in public functions", "html_url": "https://github.com/yAudit/reports/blob/main/md/07-2023-TempleDAO-Lending.md", "body": "The implementation of the onlyElevatedAccess() modifier relies on msg.sig to authorize access to a particular function. This variable refers to the first 4 bytes of the calldata, which contains the intended function selector to be executed on the called contract. The TempleElevatedAccess.sol contract holds a mapping that defines which callers have access to which functions (represented by their function selectors). It may be possible to ignore the restrictions if this modifier is used in public functions. Consider the following example contract: contract SomeContract is TempleElevatedAccess { function foo() external onlyElevatedAccess { ... bar(); ... } function bar() public onlyElevatedAccess { ... } } If bar() is called externally then onlyElevatedAccess will correctly check the authorization using the function selector for bar(). But if bar() is called internally, like in the case of foo(), then the check will be done using the function selector of the original call to the contract (foo()), as msg.sig will still refer to the first four bytes of the calldata.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "49. TLC design may increase liquidation risk", "html_url": "https://github.com/yAudit/reports/blob/main/md/07-2023-TempleDAO-Lending.md", "body": "Unlike protocols like Compound Finance, there is no difference between the max LTV that a user can borrow and the liquidation threshold. When combined with the interest that accumulates on the loan each block, this means that a loan with 85% LTV can be liquidated in the next block. Another scenario that can cause user liquidation is reducing the Treasury Price Index (TPI). Because the value of TEMPLE collateral is price using the TPI, when the TPI drops, this causes an immediate drop in the value of collateral in TLC and cause positions to be eligible for liquidation. In normal market conditions, a reduction in TPI is unlikely, and a liquidation is unlikely to induce bad debt, but in the worst case scenario, governance's choice to reduce TPI can trigger liquidations that lead to bad debt for the protocol.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "1. Incompatible Vote Delegation", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-veYFI.md", "body": "The VoteDelegation.sol contract has functions including delegate() and removeDelegation(), but the VoteDelegation.sol contract does not have any interaction with the snapshot DelegateRegistry contract. Because there are no contract calls to snapshot.org contracts, snapshot.org will not register any vote delegation.", "labels": ["yAudit", "Severity: High", "Difficulty: n/a"]}, {"title": "2. Lock 1e-18 YFI to Get Rewards", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-veYFI.md", "body": "def test_gauge_cheat_yfi_lock( yfi, ve_yfi, whale, whale_amount, shark, shark_amount, fish, fish_amount, create_vault, create_gauge, gov ): yfi.approve(ve_yfi, shark_amount, {\"from\": shark}) ve_yfi.create_lock( shark_amount, chain.time() + 4 * 3600 * 24 * 365, {\"from\": shark} ) assert yfi.balanceOf(shark) == 0 yfi.approve(ve_yfi, fish_amount, {\"from\": fish}) ve_yfi.create_lock( fish_amount, chain.time() + 4 * 3600 * 24 * 365, {\"from\": fish} ) assert yfi.balanceOf(fish) == 0 yfi.approve(ve_yfi, 1, {\"from\": whale}) ve_yfi.create_lock( 1, chain.time() + 4 * 3600 * 24 * 365, {\"from\": whale} ) assert yfi.balanceOf(whale) == whale_amount - 1 lp_amount = 10**18 vault = create_vault() tx = create_gauge(vault) gauge = Gauge.at(tx.events[\"GaugeCreated\"][\"gauge\"]) vault.mint(shark, lp_amount/100) vault.approve(gauge, lp_amount, {\"from\": shark}) gauge.deposit({\"from\": shark}) vault.mint(fish, lp_amount/100) vault.approve(gauge, lp_amount, {\"from\": fish}) gauge.deposit({\"from\": fish}) vault.mint(whale, 100*lp_amount) vault.approve(gauge, 100*lp_amount, {\"from\": whale}) gauge.deposit({\"from\": whale}) yfi_to_distribute = 10**16 yfi.mint(gov, yfi_to_distribute) yfi.approve(gauge, yfi_to_distribute, {\"from\": gov}) gauge.queueNewRewards(yfi_to_distribute, {\"from\": gov}) assert pytest.approx(gauge.rewardRate()) == yfi_to_distribute / (7 * 24 * 3600) chain.sleep(3600*24*7) chain.mine() assert gauge.earned(whale) < .39 * yfi_to_distribute gauge.getReward({\"from\": whale}) assert yfi.balanceOf(whale) < .39 * yfi_to_distribute + whale_amount gauge.withdraw({\"from\": whale}) assert vault.balanceOf(whale) == 100*lp_amount", "labels": ["yAudit", "Severity: High", "Difficulty: n/a"]}, {"title": "3. Flash Loan Sybil Attack to Boost Rewards", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-veYFI.md", "body": "Boosted Balance equation: https://github.com/YAcademy-Residents/veYFI/blob/7846291efec36638eae32ac8798544050ca20877/contracts/Gauge.sol#L302 Deposit Update Reward call: https://github.com/YAcademy-Residents/veYFI/blob/7846291efec36638eae32ac8798544050ca20877/contracts/Gauge.sol#L351 Total Supply increase: https://github.com/YAcademy-Residents/veYFI/blob/7846291efec36638eae32ac8798544050ca20877/contracts/Gauge.sol#L362", "labels": ["yAudit", "Severity: High", "Difficulty: n/a"]}, {"title": "4. Incorrect variables in getRewardFor call", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-veYFI.md", "body": "The _account variable should be used in this line instead of msg.sender https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Gauge.sol#L512 IExtraReward(extraRewards[i]).getRewardFor(msg.sender); The _account variable should be used in this line instead of msg.sender https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Gauge.sol#L501 IVotingEscrow(veToken).deposit_for(msg.sender, reward);", "labels": ["yAudit", "Severity: Medium", "Difficulty: n/a"]}, {"title": "5. Unclear Integration of Vote Delegation Until Value", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-veYFI.md", "body": "The VoteDelegation.sol contract has functions including delegate() and removeDelegation(), but the VoteDelegation.sol contract does not have any interaction with the snapshot DelegateRegistry contract. Because the actual act of voting is planned to happen off-chain with snapshot.org, snapshot.org needs to recognize what a valid vote or delegation is in the snapshot that it takes for each proposal. Currently there is no option in the snapshot.org delegation approach for an \"until\" value. Factoring in the \"until\" value could be implemented in a custom snapshot.org voting strategy, but because no such strategy is mentioned anywhere in the veYFI repository, it is expected that this has not been considered.", "labels": ["yAudit", "Severity: Medium", "Difficulty: n/a"]}, {"title": "6. force_withdraw() penalty may inadequately deter gamification and attacks on voting", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-veYFI.md", "body": "The penalty_ratio equation https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/VotingEscrow.vy#L570", "labels": ["yAudit", "Severity: Medium", "Difficulty: n/a"]}, {"title": "7. Voting delegation is missing edge case checks", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-veYFI.md", "body": "The VoteDelegation.sol contract permits an until variable value of zero if the tokens are not locked. Any until variable value that is less than block.timestamp should have no impact on voting or delegation. But if the until value starts at zero, it is possible for the value to be increased to a value less than block.timestamp to reference a time in the recent past, but still have no impact. It is possible that the voting logic, which is not within the scope of these solidity contracts, may not properly consider this edge case. This edge case can be solved by adding a check in all functions that modify the until state variable, including _delegate() and increaseDelegationDuration(), to validate require(until > block.timestamp). An exception could be made for an until value of zero, resulting in a require statement that looks like require(_until > block.timestamp || _until == 0). Another edge case is a situation where the until value is set to a time beyond the lock expiration of the veYFI tokens. There is no check for to confirm until < locked.end. This edge case could also happen if a user delegated votes, then withdrew their tokens to a new account where the tokens were locked and votes delegated again. It is unclear whether the off-chain voting mechanism will handle this edge case, which could allow multiple votes from a single token. Otherwise, consider adding the check require(_until < locked.end).", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "8. Sawtooth Wave Effect from Computing veYFI Balance and Supply Using Different Time Scales", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-veYFI.md", "body": "Equation to compute Total Supply: https://github.com/YAcademy-Residents/veYFI/blob/7846291efec36638eae32ac8798544050ca20877/contracts/VotingEscrow.vy#L756 (t_i is truncated to a value in weeks at L748 and L750.) Equation to compute Balance: https://github.com/YAcademy-Residents/veYFI/blob/7846291efec36638eae32ac8798544050ca20877/contracts/VotingEscrow.vy#L677 _t is set to block.timestamp for balance computation: https://github.com/YAcademy-Residents/veYFI/blob/7846291efec36638eae32ac8798544050ca20877/contracts/VotingEscrow.vy#L647", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "9. Equal penalty reward distribution not incentive aligned", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-veYFI.md", "body": "A discussion for this issue was started by someone from Ribbon Finance (who forked the veYFI code) before the review ended in veYFI Issue 135 and a fix is being developed in PR #136. The issue is centered around how penalty fees paid in VotingEscrow.vy and Gauge.sol are redistributed to users.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "10. No penalty during migration", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-veYFI.md", "body": "The _lockingRatio() function returns PRECISON_FACTOR, equivalent to locking for the MAX_TIME value, when the ve token is undergoing migration: https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Gauge.sol#L221 Instead, it would be better to revert in this case so that the ve token can be finished without any users taking advantage of this edge case.", "labels": ["yAudit", "Severity: Low", "Difficulty: n/a"]}, {"title": "11. Using \"unchecked\"", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-veYFI.md", "body": "The _lockingRatio() function returns PRECISON_FACTOR, equivalent to locking for the MAX_TIME value, when the ve token is undergoing migration: https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Gauge.sol#L221 Instead, it would be better to revert in this case so that the ve token can be finished without any users taking advantage of this edge case.", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "12. Using simple comparison", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-veYFI.md", "body": "The _notifyRewardAmount() function in BaseGauge.sol contains https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/BaseGauge.sol#L170-L177 if (block.timestamp >= periodFinish) { rewardRate = reward / duration; } else { uint256 remaining = periodFinish - block.timestamp; uint256 leftover = remaining * rewardRate; reward = reward + leftover; rewardRate = reward / duration; } By switching around the if/else clauses, we can replace the compound operator with a simple one if (block.timestamp < periodFinish) { uint256 remaining = periodFinish - block.timestamp; uint256 leftover = remaining * rewardRate; reward = reward + leftover; rewardRate = reward / duration; } else { rewardRate = reward / duration; }", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "13. Use prefix in loops", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-veYFI.md", "body": "There are 4 instances of this in Gauge.sol and 1 instance in VoteDelegation.sol https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Gauge.sol#L161 https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Gauge.sol#L357 https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Gauge.sol#L386 https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Gauge.sol#L511 https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/VoteDelegation.sol#L121", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "14. Payable functions can save gas", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-veYFI.md", "body": "The following functions have the onlyOwner modifier and can be marked as payable setVe() https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Registry.sol#L49 addVaultToRewards() https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Registry.sol#L67 removeVaultFromRewards() https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Registry.sol#L94 setVe() https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/VeYfiRewards.sol#L30 setVe() https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Gauge.sol#L110 setDuration() https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/BaseGauge.sol#L73 sweep() https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/BaseGauge.sol#L111", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "15. Use != 0 for gas savings", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-veYFI.md", "body": "15. Use != 0 for gas savings", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "16. Use Solidity errors in 0.8.4+", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-veYFI.md", "body": "16. Use Solidity errors in 0.8.4+", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "17. Declare functions external for gas savings", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-veYFI.md", "body": "There are two public functions that can be external https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Gauge.sol#L287 https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Gauge.sol#L317", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "18. Remove Aragon calls for gas savings", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-veYFI.md", "body": "The following functions include comments indicating they are fulling or partially used for Aragon compatibility, and may not otherwise be necessary: version state variable and _version init parameter https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/VotingEscrow.vy#L155 controller() https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/VotingEscrow.vy#L129-L131 transfersEnabled() https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/VotingEscrow.vy#L129-L131 balanceOf() https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/VotingEscrow.vy#L650 totalSupply() https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/VotingEscrow.vy#L772 changeController() https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/VotingEscrow.vy#L831-L837", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "19. Inconsistent zero case in VotingEscrow.vy", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-veYFI.md", "body": "The balanceOf() function uses this code: if upoint.bias < 0: upoint.bias = 0 return convert(upoint.bias, uint256) while the balanceOfAt() function uses this code: if upoint.bias >= 0: return convert(upoint.bias, uint256) else: return 0", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "20. Remove duplicated code", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-veYFI.md", "body": "The logic for the case block.timestamp >= periodFinish and (distributedSoFar * 12) / 10 < _amount is the same, so they can be placed into the same if statement. https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/BaseGauge.sol#L146-L150 https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/BaseGauge.sol#L156-L162 The revised queueNewRewards() function can look like this function queueNewRewards(uint256 _amount) external override returns (bool) { require(_amount != 0, \"==0\"); SafeERC20.safeTransferFrom( IERC20(rewardToken), msg.sender, address(this), _amount ); emit RewardsQueued(msg.sender, _amount); _amount = _amount + queuedRewards; uint256 elapsedSinceBeginingOfPeriod = block.timestamp - (periodFinish - duration); uint256 distributedSoFar = elapsedSinceBeginingOfPeriod * rewardRate; // we only restart a new week if _amount is 120% of distributedSoFar. if (block.timestamp >= periodFinish || (distributedSoFar * 12) / 10 < _amount) { _notifyRewardAmount(_amount); queuedRewards = 0; } else { queuedRewards = _amount; } return true; }", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "21. SLOAD gas savings", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-veYFI.md", "body": "Existing code https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/BaseGauge.sol#L80-L84 Modified code to use local variable instead of state variable in emit if (block.timestamp < periodFinish) { uint256 remaining = periodFinish - block.timestamp; uint256 newRate = remaining * rewardRate / newDuration; rewardRate = leftover; } duration = newDuration; emit DurationUpdated(newDuration, newRate); A similar type of improvement can be made in Registry.sol https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Registry.sol#L95-L96 The code can be modified to address gauge = gauges[_vault]; require(gauge != address(0x0), \"!exist\");", "labels": ["yAudit", "Severity: Gas", "Difficulty: n/a"]}, {"title": "22. SafeERC20 functions not used", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-veYFI.md", "body": "Gauge.sol line 500 => rewardToken.approve(address(veToken), reward); Gauge.sol line 527 => IERC20(rewardToken).approve(veYfiRewardPool, toTransfer); VeYfiRewards.sol line 140 => rewardToken.approve(address(veToken), reward);", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "23. Unspecified Voting Requirements", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-veYFI.md", "body": "There are built-in voting assumptions in the contract code, mostly borrowed from Convex: When a proposal is created, the checkpoint() function in VotingEscrow.vy should be called to properly set the epoch Voting power should be calculated using the on-chain functions such as get_last_user_slope(), balanceOf(), balanceOfAt(), supplyAt(), totalSupply(), and totalSupplyAt() in VotingEscrow.vy. Note that some of the math in these calculations could be moved to an off-chain voting strategy for gas savings Voting for a proposal with veYFI is allowed as soon as the veYFI is locked. Because there is potential for gamification in increasing veYFI stake shortly before key votes, protocols like Convex have implemented a minimum locking duration of several weeks before a token holder can vote, which is implemented in their VotingEligibility.sol contract. Some open and unanswered questions include: Who is allowed to create proposals on snapshot.org? How are the results of each snapshot vote converted to on-chain rewards? Is this automated? Will all vaults receive a gauge that can be voted for on snapshot.org, even those holding very little value? If so, this could lead to gamification of deprecated or old vaults. Is there a maximum allocation a gauge can receive? Is there minimum quorum for governance votes? Convex specifies these values: https://docs.convexfinance.com/convexfinance/general-information/voting-and-gauge-weights", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "24. Variable naming inconsistency", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-veYFI.md", "body": "The first input to initialize() has the following comment https://github.com/yearn/veYFI/blob/d53465c5f615a04204faed55728840a1e79377fc/contracts/Gauge.sol#L67 _stakingToken The vault token to stake Elsewhere in veYFI, the naming convention assumes that each gauge corresponds to one Yearn vault. But the name _stakingToken and the comment in issue 46 indicates this might not be correct. This should be clarified in the comments and the variable names.", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "25. Missing 0 check in setDuration()", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-veYFI.md", "body": "If block.timestamp < periodFinish, then the code will check if newDuration is zero, but this check will not happen if the if statement is skipped when block.timestamp > periodFinish https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/BaseGauge.sol#L73 This can cause problems in other functions that divide by the duration https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/BaseGauge.sol#L170-L177", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "26. Typos", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-veYFI.md", "body": "The MAX_DELAGATED variable should be spelled MAX_DELEGATED https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/VoteDelegation.sol#L16 betwwen should be between https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Gauge.sol#L324 The last sentence in the ExtraReward.sol contract needs to be fixed, most likely by removing the words \"Gauge will\". It reads \"Gauge will this contract is used behind multiple delegate proxies.\" https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/ExtraReward.sol#L13-L14 \"claimm veYFI and aditional reward\" should be \"claim veYFI and additional reward\" (two typos) https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Gauge.sol#L373 Triger should be Trigger https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/BaseGauge.sol#L131 veYFITotalSypply should be veYFITotalSupply https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Gauge.sol#L284 \"rewards are distributed during 7 days\" should says \"rewards are distributed during reward duration\" because duration is a variable and could change https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/BaseGauge.sol#L12 \"over a week\" should say \"over the reward duration\" because duration is a variable and could change https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/BaseGauge.sol#L130 \"restart a new week\" should say \"restart a new reward duration\" because duration is a variable and could change https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/BaseGauge.sol#L154 A reference to CRV exists in the vyper code. Change ERC20CRV to ERC20YFI https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/VotingEscrow.vy#L152 \"earning for an account\" should be \"earnings for an account\" https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Gauge.sol#L248-L249 \"address acccount\" should be \"address account\" https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Gauge.sol#L219", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "27. Replace magic numbers with constants", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-veYFI.md", "body": "The value 1e18 appears throughout the contracts https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/VeYfiRewards.sol#L62 https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/VeYfiRewards.sol#L69 https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Gauge.sol#L245 https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Gauge.sol#L274 https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Gauge.sol#L280 https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/ExtraReward.sol#L75 https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/ExtraReward.sol#L86 https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/ExtraReward.sol#L92", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "28. Code inconsistency", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-veYFI.md", "body": "The three different _updateReward() functions https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/ExtraReward.sol#L44 https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/VeYfiRewards.sol#L36 https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Gauge.sol#L183", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "29. Curve safety check removed", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-veYFI.md", "body": "This is the check in Curve: https://github.com/curvefi/curve-dao-contracts/blob/master/contracts/VotingEscrow.vy#L418 https://github.com/curvefi/curve-dao-contracts/blob/master/contracts/VotingEscrow.vy#L438 https://github.com/curvefi/curve-dao-contracts/blob/master/contracts/VotingEscrow.vy#L455 The check does not exist in the same locations in the veYFI VotingEscrow contract: https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/VotingEscrow.vy#L458 https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/VotingEscrow.vy#L496 https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/VotingEscrow.vy#L512 If this check is added to veYFI, it should also be added to createLockFor, a function that Curve does not have: https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/VotingEscrow.vy#L477", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "30. No migrateLock sample implementation", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-veYFI.md", "body": "The migrateLock() call in the existing veYFI code: https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/VotingEscrow.vy#L606", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "31. Use -= to keep code concise", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-veYFI.md", "body": "The += operator is used often in veYFI, but the -= operator is not used in this line https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Gauge.sol#L391 _balances[msg.sender] = _balances[msg.sender] - _amount; Consider changing this line to _balances[msg.sender] -= _amount;", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}, {"title": "32. Update rewards for other users", "html_url": "https://github.com/yAudit/reports/blob/main/md/04-2022-veYFI.md", "body": "The depositFor() function: https://github.com/YAcademy-Residents/veYFI/blob/master/contracts/Gauge.sol#L344", "labels": ["yAudit", "Severity: Informational", "Difficulty: n/a"]}]