[{"title": "6.11 Unused field in ForgePropsMulti struct   ", "body": "  Resolution  The field is currently used but will be used in a future version.  Description  The ForgePropsMulti struct defines the field isValid which always seems to be true:  code/contracts/masset/shared/MassetStructs.sol:L78-L84  /** @dev All details needed to Forge with multiple bAssets */  struct ForgePropsMulti {  bool isValid; // Flag to signify that forge bAssets have passed validity check  Basset[] bAssets;  address[] integrators;  uint8[] indexes;  If it is indeed always true, one could remove the following line:  code/contracts/masset/Masset.sol:L518  if(!props.isValid) return 0;  Recommendation  If the field is indeed always true please consider removing it to simplify the code.  ", "labels": ["Consensys", "Minor", "Won't Fix"], "html_url": "https://consensys.io/diligence/audits/2020/07/mstable-1.1/"}, {"title": "6.12 BassetStatus enum defines multiple unused states   ", "body": "  Resolution  The states will potentially be used in future releases.  Description  The BassetStatus enum defines several values that do not seem to be assigned in the code:  Default (different from  Normal ?)  Blacklisted  Liquidating  Liquidated  Failed  code/contracts/masset/shared/MassetStructs.sol:L59-L69  /** @dev Status of the Basset - has it broken its peg? */  enum BassetStatus {  Default,  Normal,  BrokenBelowPeg,  BrokenAbovePeg,  Blacklisted,  Liquidating,  Liquidated,  Failed  Since some of these are used in the code there might be some dead code that can be removed as a result. For example:  code/contracts/masset/forge-validator/ForgeValidator.sol:L46-L47  _bAsset.status == BassetStatus.Liquidating ||  _bAsset.status == BassetStatus.Blacklisted  Recommendation  If those values are indeed never used please consider removing them to simplify the code.  ", "labels": ["Consensys", "Minor", "Won't Fix"], "html_url": "https://consensys.io/diligence/audits/2020/07/mstable-1.1/"}, {"title": "6.13 Potential gas savings by terminating early   ", "body": "  Resolution  acknowledged that gas savings are possible, might be moved changed in a future version.  Description  If a function invocation is bound to revert, one should try to revert as soon as possible to save gas. In ForgeValidator.validateRedemption it is possible to terminate more early:  code/contracts/masset/forge-validator/ForgeValidator.sol:L264  if(atLeastOneBecameOverweight) return (false, \"bAssets must remain below max weight\", false);  Recommendation  Consider moving the require-statement a few lines up (for instance, after assigning to atLeastOneBecameOverweight).  ", "labels": ["Consensys", "Minor", "Acknowledged"], "html_url": "https://consensys.io/diligence/audits/2020/07/mstable-1.1/"}, {"title": "6.14 Discrepancy between code and comments    Addressed", "body": "  Resolution  The comments have been updated.  Description  There is a discrepancy between the code at:  code/contracts/masset/BasketManager.sol:L417  require(weightSum >= 1e18 && weightSum <= 4e18, \"Basket weight must be >= 100 && <= 400%\");  And the comment at:  code/contracts/masset/BasketManager.sol:L409  Recommendation  @dev Throws if the total Basket weight does not sum to 100  Recommendation  Update the code or the comment to be consistent.  ", "labels": ["Consensys", "Minor"], "html_url": "https://consensys.io/diligence/audits/2020/07/mstable-1.1/"}, {"title": "6.15 Outdated Solidity version   ", "body": "  Resolution   the issue was deemed acceptable because an update to solc 0.5.17   would not fix any relevant security bugs.  Description  The codebase is using an outdated version of the Solidity compiler.  Recommendation  Please consider using an up-to-date version (ideally 0.6.12 or at least 0.5.17).  ", "labels": ["Consensys", "Minor", "Won't Fix"], "html_url": "https://consensys.io/diligence/audits/2020/07/mstable-1.1/"}, {"title": "5.1 zAuction - incomplete / dead code zWithdraw and zDeposit    ", "body": "  Resolution   obsolete with changes from   zer0-os/zAuction@135b2aa removing the  Description  Examples  zAuction/contracts/zAuctionAccountant.sol:L44-L52  function zDeposit(address to) external payable onlyZauction {  ethbalance[to] = SafeMath.add(ethbalance[to], msg.value);  emit zDeposited(to, msg.value);  function zWithdraw(address from, uint256 amount) external onlyZauction {  ethbalance[from] = SafeMath.sub(ethbalance[from], amount);  emit zWithdrew(from, amount);  Recommendation  The methods do not seem to be used by the zAuction contract. It is highly discouraged from shipping incomplete implementations in productive code. Remove dead/unreachable code. Fix the implementations to perform proper accounting before reintroducing them if they are called by zAuction.  ", "labels": ["Consensys", "Major", "Fixed"], "html_url": "https://consensys.io/diligence/audits/2021/05/zer0-zauction/"}, {"title": "5.2 zAuction - Unpredictable behavior for users due to admin front running or general bad timing    ", "body": "  Resolution  obsolete with changes from zer0-os/zAuction@135b2aa removing the zAccountAccountant. The client provided the following remark:  ", "labels": ["Consensys", "Major", "Fixed"], "html_url": "https://consensys.io/diligence/audits/2021/05/zer0-zauction/"}, {"title": "5.20 accountant deprecated", "body": "  Description  An administrator of zAuctionAccountant contract can update the zAuction contract without warning. This has the potential to violate a security goal of the system.  Specifically, privileged roles could use front running to make malicious changes just ahead of incoming transactions, or purely accidental negative effects could occur due to the unfortunate timing of changes.  In general users of the system should have assurances about the behavior of the action they re about to take.  Examples  updating the zAuction takes effect immediately. This has the potential to fail acceptance of bids by sellers on the now outdated zAuction contract as interaction with the accountant contract is now rejected. This forces bidders to reissue their bids in order for the seller to be able to accept them using the Accountant contract. This may also be used by admins to selectively censor the acceptance of accountant based bids by changing the active zAuction address.  zAuction/contracts/zAuctionAccountant.sol:L60-L68  function SetZauction(address zauctionaddress) external onlyAdmin{  zauction = zauctionaddress;  emit ZauctionSet(zauctionaddress);  function SetAdmin(address newadmin) external onlyAdmin{  admin = newadmin;  emit AdminSet(msg.sender, newadmin);  Upgradeable contracts may introduce the same unpredictability issues where the proxyUpgradeable owner may divert execution to a new zNS registrar implementation selectively for certain transactions or without prior notice to users.  Recommendation  The underlying issue is that users of the system can t be sure what the behavior of a function call will be, and this is because the behavior can change at any time.  We recommend giving the user advance notice of changes with a time lock. For example, make all system-parameter and upgrades require two steps with a mandatory time window between them. The first step merely broadcasts to users that a particular change is coming, and the second step commits that change after a suitable waiting period. This allows users that do not accept the change to withdraw immediately.  Validate arguments before updating contract addresses (at least != current/0x0). Consider implementing a 2-step admin ownership transfer (transfer+accept) to avoid losing control of the contract by providing the wrong ETH address.  ", "labels": ["Consensys"], "html_url": "https://consensys.io/diligence/audits/2021/05/zer0-zauction/"}, {"title": "5.3 zAuction, zNS - Bids cannot be cancelled, never expire, and the auction lifecycle is unclear    ", "body": "  Resolution  Addressed with zer0-os/zNS@ab7d62a by refactoring the StakingController to control the lifecycle of bids instead of handling this off-chain.  Addressed with zer0-os/zAuction@135b2aa for zAuction by adding a bid/saleOffer expiration for bids. The client also provided the following statement:  ", "labels": ["Consensys", "Major", "Fixed"], "html_url": "https://consensys.io/diligence/audits/2021/05/zer0-zauction/"}, {"title": "5.6 added expireblock and startblock to zauction, expireblock to zsale", "body": " Decided not to add a cancel function. Paying gas to cancel isn t ideal, and it can be used as a griefing function. though that s still possible to do by moving weth but differently  The stateless nature of auctions may make it hard to enforce bid/sale expirations and it is not possible to cancel a bid/offer that should not be valid anymore. The expiration reduces the risk of old offers being used as they now automatically invalidate after time, however, it is still likely that multiple valid offers may be present at the same time. As outlined in the recommendation, one option would be to allow someone who signed a commitment to explicitly cancel it in the contract. Another option would be to create a stateful auction where the entity that puts up something for  starts  an auction, creating an auction id, requiring bidders to bid on that auction id. Once a bid is accepted the auction id is invalidated which invalidates all bids that might be floating around.  zer0-os/zAuction@2f92aa1 for  Description  The lifecycle of a bid both for zAuction and zNS is not clear, and has many flaws.  zAuction - Consider the case where a bid is placed, then the underlying asset in being transferred to a new owner. The new owner can now force to sell the asset even though it s might not be relevant anymore.  zAuction - Once a bid was accepted and the asset was transferred, all other bids need to be invalidated automatically, otherwise and old bid might be accepted even after the formal auction is over.  zAuction, zNS - There is no way for the bidder to cancel an old bid. That might be useful in the event of a significant change in market trend, where the old pricing is no longer relevant. Currently, in order to cancel a bid, the bidder can either withdraw his ether balance from the zAuctionAccountant, or disapprove WETH which requires an extra transaction that might be front-runned by the seller.  Examples  zAuction/contracts/zAuction.sol:L35-L45  function acceptBid(bytes memory signature, uint256 rand, address bidder, uint256 bid, address nftaddress, uint256 tokenid) external {  address recoveredbidder = recover(toEthSignedMessageHash(keccak256(abi.encode(rand, address(this), block.chainid, bid, nftaddress, tokenid))), signature);  require(bidder == recoveredbidder, 'zAuction: incorrect bidder');  require(!randUsed[rand], 'Random nonce already used');  randUsed[rand] = true;  IERC721 nftcontract = IERC721(nftaddress);  accountant.Exchange(bidder, msg.sender, bid);  nftcontract.transferFrom(msg.sender, bidder, tokenid);  emit BidAccepted(bidder, msg.sender, bid, nftaddress, tokenid);  zNS/contracts/StakingController.sol:L120-L152  function fulfillDomainBid(  uint256 parentId,  uint256 bidAmount,  uint256 royaltyAmount,  string memory bidIPFSHash,  string memory name,  string memory metadata,  bytes memory signature,  bool lockOnCreation,  address recipient  ) external {  bytes32 recoveredBidHash = createBid(parentId, bidAmount, bidIPFSHash, name);  address recoveredBidder = recover(recoveredBidHash, signature);  require(recipient == recoveredBidder, \"ZNS: bid info doesnt match/exist\");  bytes32 hashOfSig = keccak256(abi.encode(signature));  require(approvedBids[hashOfSig] == true, \"ZNS: has been fullfilled\");  infinity.safeTransferFrom(recoveredBidder, controller, bidAmount);  uint256 id = registrar.registerDomain(parentId, name, controller, recoveredBidder);  registrar.setDomainMetadataUri(id, metadata);  registrar.setDomainRoyaltyAmount(id, royaltyAmount);  registrar.transferFrom(controller, recoveredBidder, id);  if (lockOnCreation) {  registrar.lockDomainMetadataForOwner(id);  approvedBids[hashOfSig] = false;  emit DomainBidFulfilled(  metadata,  name,  recoveredBidder,  id,  parentId  );  Recommendation  Consider adding an expiration field to the message signed by the bidder both for zAuction and zNS. Consider adding auction control, creating an auctionId, and have users bid on specific auctions. By adding this id to the signed message, all other bids are invalidated automatically and users would have to place new bids for a new auction. Optionally allow users to cancel bids explicitly.  ", "labels": ["Consensys"], "html_url": "https://consensys.io/diligence/audits/2021/05/zer0-zauction/"}, {"title": "5.4 zAuction - pot. initialization fronrunning and unnecessary init function    ", "body": "  Resolution  Addressed with zer0-os/zAuction@135b2aa and the following statement:  ", "labels": ["Consensys", "Medium", "Fixed"], "html_url": "https://consensys.io/diligence/audits/2021/05/zer0-zauction/"}, {"title": "5.21 init deprecated, constructor added", "body": "  Description  The zAuction initialization method is unprotected and while only being executable once, can be called by anyone. This might allow someone to monitor the mempool for new deployments of this contract and fron-run the initialization to initialize it with different parameters.  A mitigating factor is that this condition can be detected by the deployer as subsequent calls to init() will fail.  Note: this doesn t adhere to common interface naming convention/oz naming convention where this method would be called initialize.  Note: that zNS in contrast relies on ou/initializable pattern with proper naming.  Note: that this function might not be necessary at all and should be replaced by a constructor instead, as the contract is not used with a proxy pattern.  Examples  zAuction/contracts/zAuction.sol:L22-L26  function init(address accountantaddress) external {  require(!initialized);  initialized = true;  accountant = zAuctionAccountant(accountantaddress);  Recommendation  The contract is not used in a proxy pattern, hence, the initialization should be performed in the constructor instead.  ", "labels": ["Consensys"], "html_url": "https://consensys.io/diligence/audits/2021/05/zer0-zauction/"}, {"title": "5.5 zAuction - unclear upgrade path    ", "body": "  Resolution   obsolete with changes from   zer0-os/zAuction@135b2aa removing the  Description  https://github.com/ConsenSys/zer0-zauction-audit-2021-05/issues/7).  Acceptance of bids via the accountant on the old contract immediately fail after an admin updates the referenced zAuction contract while WETH bids may still continue. This may create an unfavorable scenario where two contracts may be active in parallel accepting WETH bids.  It should also be noted that 2nd layer bids (signed data) using the accountant for the old contract will not be acceptable anymore.  Examples  zAuction/contracts/zAuctionAccountant.sol:L60-L63  function SetZauction(address zauctionaddress) external onlyAdmin{  zauction = zauctionaddress;  emit ZauctionSet(zauctionaddress);  Recommendation  Consider re-thinking the upgrade path. Avoid keeping multiple versions of the auction contact active.  ", "labels": ["Consensys", "Medium", "Fixed"], "html_url": "https://consensys.io/diligence/audits/2021/05/zer0-zauction/"}, {"title": "5.6 zAuction, zNS - gas griefing by spamming offchain fake bids   ", "body": "  Resolution  Addressed and acknowledged with changes from zer0-os/zAuction@135b2aa. The client provided the following remark:  ", "labels": ["Consensys", "Medium", "Acknowledged"], "html_url": "https://consensys.io/diligence/audits/2021/05/zer0-zauction/"}, {"title": "5.19 I have attempted to order the requires sensibly, putting the least expensive first. Please advise if the ordering is optimal. gas griefing will be mitigated in the dapp with off-client checks", "body": "  Description  The execution status of both zAuction.acceptBid and StakingController.fulfillDomainBid transactions depend on the bidder, as his approval is needed, his signature is being validated, etc. However, these transactions can be submitted by accounts that are different from the bidder account, or for accounts that do not have the required funds/deposits available, luring the account that has to perform the on-chain call into spending gas on a transaction that is deemed to fail (gas griefing). E.g. posting high-value fake bids for zAuction without having funds deposited or WETH approved.  Examples  zNS/contracts/StakingController.sol:L120-L152  function fulfillDomainBid(  uint256 parentId,  uint256 bidAmount,  uint256 royaltyAmount,  string memory bidIPFSHash,  string memory name,  string memory metadata,  bytes memory signature,  bool lockOnCreation,  address recipient  ) external {  bytes32 recoveredBidHash = createBid(parentId, bidAmount, bidIPFSHash, name);  address recoveredBidder = recover(recoveredBidHash, signature);  require(recipient == recoveredBidder, \"ZNS: bid info doesnt match/exist\");  bytes32 hashOfSig = keccak256(abi.encode(signature));  require(approvedBids[hashOfSig] == true, \"ZNS: has been fullfilled\");  infinity.safeTransferFrom(recoveredBidder, controller, bidAmount);  uint256 id = registrar.registerDomain(parentId, name, controller, recoveredBidder);  registrar.setDomainMetadataUri(id, metadata);  registrar.setDomainRoyaltyAmount(id, royaltyAmount);  registrar.transferFrom(controller, recoveredBidder, id);  if (lockOnCreation) {  registrar.lockDomainMetadataForOwner(id);  approvedBids[hashOfSig] = false;  emit DomainBidFulfilled(  metadata,  name,  recoveredBidder,  id,  parentId  );  zAuction/contracts/zAuction.sol:L35-L44  function acceptBid(bytes memory signature, uint256 rand, address bidder, uint256 bid, address nftaddress, uint256 tokenid) external {  address recoveredbidder = recover(toEthSignedMessageHash(keccak256(abi.encode(rand, address(this), block.chainid, bid, nftaddress, tokenid))), signature);  require(bidder == recoveredbidder, 'zAuction: incorrect bidder');  require(!randUsed[rand], 'Random nonce already used');  randUsed[rand] = true;  IERC721 nftcontract = IERC721(nftaddress);  accountant.Exchange(bidder, msg.sender, bid);  nftcontract.transferFrom(msg.sender, bidder, tokenid);  emit BidAccepted(bidder, msg.sender, bid, nftaddress, tokenid);  Recommendation  Revert early for checks that depend on the bidder before performing gas-intensive computations.  Consider adding a dry-run validation for off-chain components before transaction submission.  ", "labels": ["Consensys"], "html_url": "https://consensys.io/diligence/audits/2021/05/zer0-zauction/"}, {"title": "5.7 zAuction - functionality outlined in specification that is not implemented yet    ", "body": "  Resolution   implemented as   zer0-os/zAuction@135b2aa.  Description  The specification outlines three main user journeys of which one does not seem to be implemented.  Users will be able to do simple transfer of NFTs. - which does not require functionality in the smart contract  Users will be able to post NFTs at a sale price, and buy at that price. - does not seem to be implemented  Users will be able to post NFTs for auction, bid on auctions, and accept bids - is implemented  Recommendation  User flow (2) is not implemented in the smart contract system. Consider updating the spec or clearly highlighting functionality that is still in development for it to be excluded from security testing.  ", "labels": ["Consensys", "Medium", "Fixed"], "html_url": "https://consensys.io/diligence/audits/2021/05/zer0-zauction/"}, {"title": "5.8 zAuction - auctions/offers can be terminated by reusing the auction id    ", "body": "  Resolution  zer0-os/zAuction@8ff0eab by binding  In the zSale case the saleId is chosen by the seller. The offer (signed offer parameters including saleid) is shared on an off-chain channel. The buyer calls zSale.purchase to buy the token from the offer. The offer and all offers containing the same seller+saleid are then invalidated.  In zAuction there is no seller or someone who initiates an auction. Anyone can bid for nft s held by anyone else. The bidder chooses an auction id. There might be multiple bidders. Since the auctionId is an individual choice and the smart contract does not enforce an auction to be started there may be multiple auctions for the same token but using different auction ids. The current mechanism automatically invalidates all current bids for the token+auctionId combination for the winning bidder. Bids by other holders are not automatically invalidated but they can be invalidated manually via cancelBidsUnderPrice for an auctionId. Note that the winning bid is chosen by the nftowner/seller. The new owner of the nft may be able to immediately accept another bid and transfer the token [seller]--acceptBid-->[newOwner-A]--acceptBid-->[newOwner-B].  Description  zer0-os/zAuction@2f92aa1 introduced a way of tracking auctions/sales by using an auctionId/saleId. The id s are unique and the same id cannot be used for multiple auctions/offers.  Two different auctions/offers may pick the same id, the first auction/offer will go through while the latter cannot be fulfilled anymore. This may happen accidentally or intentionally be forced by a malicious actor to terminate active auctions/sales (griefing, front-running).  Examples  Alice puts out an offer for someone to buy nft X at a specific price. Bob decides to accept that offer and buy the nft by calling zSale.purchase(saleid, price, token, ...). Mallory monitors the mempool, sees this transaction, front-runs it to fulfill its own sale (for a random nft he owns) reusing the saleid from Bobs transaction. Since Mallories transaction marks the saleid as consumed it terminates Alie s offer and hence Bob cannot buy the token as the transaction will revert.  Recommendation  Consider using keccak(saleid+nftcontract+nfttokenid) as the unique sale/auction identifier instead, or alternatively associate the bidder address with the auctionId (require that consumed[bidder][auctionId]== false)  ", "labels": ["Consensys", "Medium", "Fixed"], "html_url": "https://consensys.io/diligence/audits/2021/05/zer0-zauction/"}, {"title": "5.9 zAuction - hardcoded ropsten token address    ", "body": "  Resolution  Addressed with zer0-os/zAuction@135b2aa and the following statement:  ", "labels": ["Consensys", "Minor", "Fixed"], "html_url": "https://consensys.io/diligence/audits/2021/05/zer0-zauction/"}, {"title": "5.30 weth address in constructor", "body": "  Note: does not perform input validation as recommended  Description  The auction contract hardcodes the WETH ERC20 token address. this address will not be functional when deploying to mainnet.  Examples  zAuction/contracts/zAuction.sol:L15-L16  IERC20 weth = IERC20(address(0xc778417E063141139Fce010982780140Aa0cD5Ab)); // rinkeby weth  Recommendation  Consider taking the used WETH token address as a constructor argument. Avoid code changes to facilitate testing! Perform input validation on arguments rejecting address(0x0) to facilitate the detection of potential misconfiguration in the deployment pipeline.  ", "labels": ["Consensys"], "html_url": "https://consensys.io/diligence/audits/2021/05/zer0-zauction/"}, {"title": "5.10 zAuction - accountant allows zero value withdrawals/deposits/exchange    ", "body": "  Resolution   Obsolete. The affected component has been removed from the system with   zer0-os/zAuction@135b2aa.  Description  Zero value transfers effectively perform a no-operation sometimes followed by calling out to the recipient of the withdrawal.  A transfer where from==to or where the value is 0 is ineffective.  Examples  zAuction/contracts/zAuctionAccountant.sol:L38-L42  function Withdraw(uint256 amount) external {  ethbalance[msg.sender] = SafeMath.sub(ethbalance[msg.sender], amount);  payable(msg.sender).transfer(amount);  emit Withdrew(msg.sender, amount);  zAuction/contracts/zAuctionAccountant.sol:L33-L36  function Deposit() external payable {  ethbalance[msg.sender] = SafeMath.add(ethbalance[msg.sender], msg.value);  emit Deposited(msg.sender, msg.value);  zAuction/contracts/zAuctionAccountant.sol:L44-L58  function zDeposit(address to) external payable onlyZauction {  ethbalance[to] = SafeMath.add(ethbalance[to], msg.value);  emit zDeposited(to, msg.value);  function zWithdraw(address from, uint256 amount) external onlyZauction {  ethbalance[from] = SafeMath.sub(ethbalance[from], amount);  emit zWithdrew(from, amount);  function Exchange(address from, address to, uint256 amount) external onlyZauction {  ethbalance[from] = SafeMath.sub(ethbalance[from], amount);  ethbalance[to] = SafeMath.add(ethbalance[to], amount);  emit zExchanged(from, to, amount);  Recommendation  Consider rejecting ineffective withdrawals (zero value) or at least avoid issuing a zero value ETH transfers. Avoid emitting successful events for ineffective calls to not trigger 3rd party components on noop s.  ", "labels": ["Consensys", "Minor", "Fixed"], "html_url": "https://consensys.io/diligence/audits/2021/05/zer0-zauction/"}, {"title": "5.11 zAuction - seller should not be able to accept their own bid    ", "body": "  Resolution  Addressed with zer0-os/zAuction@135b2aa by disallowing the seller to accept their own bid. The client provided the following note:  ", "labels": ["Consensys", "Minor", "Fixed"], "html_url": "https://consensys.io/diligence/audits/2021/05/zer0-zauction/"}, {"title": "5.28 seller != buyer required", "body": "  Description  A seller can accept their own bid which is an ineffective action that is emitting an event.  Examples  zAuction/contracts/zAuction.sol:L35-L56  function acceptBid(bytes memory signature, uint256 rand, address bidder, uint256 bid, address nftaddress, uint256 tokenid) external {  address recoveredbidder = recover(toEthSignedMessageHash(keccak256(abi.encode(rand, address(this), block.chainid, bid, nftaddress, tokenid))), signature);  require(bidder == recoveredbidder, 'zAuction: incorrect bidder');  require(!randUsed[rand], 'Random nonce already used');  randUsed[rand] = true;  IERC721 nftcontract = IERC721(nftaddress);  accountant.Exchange(bidder, msg.sender, bid);  nftcontract.transferFrom(msg.sender, bidder, tokenid);  emit BidAccepted(bidder, msg.sender, bid, nftaddress, tokenid);  /// @dev 'true' in the hash here is the eth/weth switch  function acceptWethBid(bytes memory signature, uint256 rand, address bidder, uint256 bid, address nftaddress, uint256 tokenid) external {  address recoveredbidder = recover(toEthSignedMessageHash(keccak256(abi.encode(rand, address(this), block.chainid, bid, nftaddress, tokenid, true))), signature);  require(bidder == recoveredbidder, 'zAuction: incorrect bidder');  require(!randUsed[rand], 'Random nonce already used');  randUsed[rand] = true;  IERC721 nftcontract = IERC721(nftaddress);  weth.transferFrom(bidder, msg.sender, bid);  nftcontract.transferFrom(msg.sender, bidder, tokenid);  emit WethBidAccepted(bidder, msg.sender, bid, nftaddress, tokenid);  Recommendation  Disallow transfers to self.  ", "labels": ["Consensys"], "html_url": "https://consensys.io/diligence/audits/2021/05/zer0-zauction/"}, {"title": "5.1 Similar token-to-token swap methods can yield very different results ", "body": "  Description  BPool s interface exposes several methods to perform token swaps. Because the formula used to calculate trade values varies depending on the method, we compared token swaps performed using two different methods:  BPool.swapExactAmountIn performs a direct token-to-token swap between two bound assets within the pool. Some amount tokenAmountIn of tokenIn is directly traded for some minimum amount minAmountOut of tokenOut. An additional parameter, maxPrice, allows the trader to specify the maximum amount of slippage allowed during the trade.  BPool.joinswapExternAmountIn allows a trader to exchange an amount tokenAmountIn of tokenIn for a minimum amount minPoolAmountOut of the pool s token. A subsequent call to BPool.exitswapPoolAmountIn allows a trader to exchange amount poolAmountIn of the pool s tokens for a minimum amount minAmountOut of tokenOut.  While the latter method performs a swap by way of the pool s token as an intermediary, both methods can be used in order to perform a token-to-token swap. Our comparison between the two tested the relative amount tokenAmountOut of tokenOut between the two methods with a variety of different parameters.  Examples  Each example made use of a testing contract, found here: https://gist.github.com/wadeAlexC/12ee22438e8028f5439c5f0faaf9b7f7  Additionally, BPool was modified; unneeded functions were removed so that deployment did not exceed the block gas limit.  1. tokenIn weight: 25 BONE  tokenOut weight: 25 BONE  tokenIn, tokenOut at equal balances (50 BONE)  tokenAmountIn: 1 BONE  swapExactAmountIn tokenAmountOut: 980391195693945000  joinswapExternAmountIn + exitSwapPoolAmountIn tokenAmountOut: 980391186207949598  Result: swapExactAmountIn gives 1.00000001x more tokens  2. tokenIn weight: 1 BONE  tokenOut weight: 49 BONE  tokenIn, tokenOut at equal balances (50 BONE)  tokenAmountIn: 1 BONE  swapExactAmountIn tokenAmountOut: 20202659955287800  joinswapExternAmountIn + exitSwapPoolAmountIn tokenAmountOut: 20202659970818843  Result: joinswap/exitswap gives 1.00000001x more tokens  3. tokenIn weight: 25 BONE  tokenOut weight: 25 BONE  tokenIn, tokenOut at equal balances (1 BONE)  tokenAmountIn: 0.5 BONE  swapExactAmountIn tokenAmountOut: 333333111111037037  joinswapExternAmountIn + exitSwapPoolAmountIn tokenAmountOut: 333333055579388951  Result: swapExactAmountIn gives 1.000000167x more tokens  4. tokenIn weight: 25 BONE  tokenOut weight: 25 BONE  tokenIn, tokenOut at equal balances (30 BONE)  tokenAmountIn: 15 BONE  swapExactAmountIn tokenAmountOut: 9999993333331111110  joinswapExternAmountIn + exitSwapPoolAmountIn tokenAmountOut: 9999991667381668530  Result: swapExactAmountIn gives 1.000000167x more tokens  The final test raised the swap fee from MIN_FEE (0.0001%) to MAX_FEE (10%):    tokenIn weight: 25 BONE  tokenOut weight: 25 BONE  tokenIn, tokenOut at equal balances (30 BONE)  tokenAmountIn: 15 BONE  swapExactAmountIn tokenAmountOut: 9310344827586206910  joinswapExternAmountIn + exitSwapPoolAmountIn tokenAmountOut: 9177966102628338740  Result: swapExactAmountIn gives 1.014423536x more tokens  Recommendation  Our final test showed that with equivalent balances and weights, raising the swap fee to 10% had a drastic effect on relative tokenAmountOut received, with swapExactAmountIn yielding >1.44% more tokens than the joinswap/exitswap method.  Reading through Balancer s provided documentation, our assumption was that these two swap methods were roughly equivalent. Discussion with Balancer clarified that the joinswap/exitswap method applied two swap fees: one for single asset deposit, and one for single asset withdrawal. With the minimum swap fee, this double application proved to have relatively little impact on the difference between the two methods. In fact, some parameters resulted in higher relative yield from the joinswap/exitswap method. With the maximum swap fee, the double application was distinctly noticeable.  Given the relative complexity of the math behind BPools, there is much that remains to be tested. There are alternative swap methods, as well as numerous additional permutations of parameters that could be used; these tests were relatively narrow in scope.  We recommend increasing the intensity of unit testing to cover a more broad range of interactions with BPool s various swap methods. In particular, the double application of the swap fee should be examined, as well as the differences between low and high swap fees.  Those using BPool should endeavor to understand as much of the underlying math as they can, ensuring awareness of the various options available for performing trades.  ", "labels": ["Consensys", "Medium"], "html_url": "https://consensys.io/diligence/audits/2020/05/balancer-finance/"}, {"title": "5.2 Commented code exists in BMath ", "body": "  Description  There are some instances of code being commented out in the BMath.sol that should be removed. It seems that most of the commented code is related to exit fee, however this is in contrast to BPool.sol code base that still has the exit fee code flow, but uses 0 as the fee.  Examples  code/contracts/BMath.sol:L137-L140  uint tokenInRatio = bdiv(newTokenBalanceIn, tokenBalanceIn);  // uint newPoolSupply = (ratioTi ^ weightTi) * poolSupply;  uint poolRatio = bpow(tokenInRatio, normalizedWeight);  code/contracts/BMath.sol:L206-L209  uint normalizedWeight = bdiv(tokenWeightOut, totalWeight);  // charge exit fee on the pool token side  // pAiAfterExitFee = pAi*(1-exitFee)  uint poolAmountInAfterExitFee = bmul(poolAmountIn, bsub(BONE, EXIT_FEE));  And many more examples.  Recommendation  Remove the commented code, or address them properly. If the code is related to exit fee, which is considered to be 0 in this version, this style should be persistent in other contracts as well.  ", "labels": ["Consensys", "Minor"], "html_url": "https://consensys.io/diligence/audits/2020/05/balancer-finance/"}, {"title": "5.3 Max weight requirement in rebind is inaccurate ", "body": "  Description  BPool.rebind enforces MIN_WEIGHT and MAX_WEIGHT bounds on the passed-in denorm value:  code/contracts/BPool.sol:L262-L274  function rebind(address token, uint balance, uint denorm)  public  _logs_  _lock_  require(msg.sender == _controller, \"ERR_NOT_CONTROLLER\");  require(_records[token].bound, \"ERR_NOT_BOUND\");  require(!_finalized, \"ERR_IS_FINALIZED\");  require(denorm >= MIN_WEIGHT, \"ERR_MIN_WEIGHT\");  require(denorm <= MAX_WEIGHT, \"ERR_MAX_WEIGHT\");  require(balance >= MIN_BALANCE, \"ERR_MIN_BALANCE\");  MIN_WEIGHT is 1 BONE, and MAX_WEIGHT is 50 BONE.  Though a token weight of 50 BONE may make sense in a single-token system, BPool is intended to be used with two to eight tokens. The sum of the weights of all tokens must not be greater than 50 BONE.  This implies that a weight of 50 BONE for any single token is incorrect, given that at least one other token must be present.  Recommendation  MAX_WEIGHT for any single token should be MAX_WEIGHT - MIN_WEIGHT, or 49 BONE.  ", "labels": ["Consensys", "Minor"], "html_url": "https://consensys.io/diligence/audits/2020/05/balancer-finance/"}, {"title": "5.4 Switch modifier order in BPool ", "body": "  Description  BPool functions often use modifiers in the following order: _logs_, _lock_. Because _lock_ is a reentrancy guard, it should take precedence over _logs_. See example:  Recommendation  Place _lock_ before other modifiers; ensuring it is the very first and very last thing to run when a function is called.  6 Document Change Log  ", "labels": ["Consensys", "Minor"], "html_url": "https://consensys.io/diligence/audits/2020/05/balancer-finance/"}, {"title": "1.0", "body": "0000001x more tokens  2. tokenIn weight: 1 BONE  tokenOut weight: 49 BONE  tokenIn, tokenOut at equal balances (50 BONE)  tokenAmountIn: 1 BONE  swapExactAmountIn tokenAmountOut: 20202659955287800  joinswapExternAmountIn + exitSwapPoolAmountIn tokenAmountOut: 20202659970818843  Result: joinswap/exitswap gives 1.00000001x more tokens  3. tokenIn weight: 25 BONE  tokenOut weight: 25 BONE  tokenIn, tokenOut at equal balances (1 BONE)  tokenAmountIn: 0.5 BONE  swapExactAmountIn tokenAmountOut: 333333111111037037  joinswapExternAmountIn + exitSwapPoolAmountIn tokenAmountOut: 333333055579388951  Result: swapExactAmountIn gives 1.000000167x more tokens  4. tokenIn weight: 25 BONE  tokenOut weight: 25 BONE  tokenIn, tokenOut at equal balances (30 BONE)  tokenAmountIn: 15 BONE  swapExactAmountIn tokenAmountOut: 9999993333331111110  joinswapExternAmountIn + exitSwapPoolAmountIn tokenAmountOut: 9999991667381668530  Result: swapExactAmountIn gives 1.000000167x more tokens  The final test raised the swap fee from MIN_FEE (0.0001%) to MAX_FEE (10%):    tokenIn weight: 25 BONE  tokenOut weight: 25 BONE  tokenIn, tokenOut at equal balances (30 BONE)  tokenAmountIn: 15 BONE  swapExactAmountIn tokenAmountOut: 9310344827586206910  joinswapExternAmountIn + exitSwapPoolAmountIn tokenAmountOut: 9177966102628338740  Result: swapExactAmountIn gives 1.014423536x more tokens  Recommendation  Our final test showed that with equivalent balances and weights, raising the swap fee to 10% had a drastic effect on relative tokenAmountOut received, with swapExactAmountIn yielding >1.44% more tokens than the joinswap/exitswap method.  Reading through Balancer s provided documentation, our assumption was that these two swap methods were roughly equivalent. Discussion with Balancer clarified that the joinswap/exitswap method applied two swap fees: one for single asset deposit, and one for single asset withdrawal. With the minimum swap fee, this double application proved to have relatively little impact on the difference between the two methods. In fact, some parameters resulted in higher relative yield from the joinswap/exitswap method. With the maximum swap fee, the double application was distinctly noticeable.  Given the relative complexity of the math behind BPools, there is much that remains to be tested. There are alternative swap methods, as well as numerous additional permutations of parameters that could be used; these tests were relatively narrow in scope.  We recommend increasing the intensity of unit testing to cover a more broad range of interactions with BPool s various swap methods. In particular, the double application of the swap fee should be examined, as well as the differences between low and high swap fees.  Those using BPool should endeavor to understand as much of the underlying math as they can, ensuring awareness of the various options available for performing trades.  5.2 Commented code exists in BMath Minor  Description  There are some instances of code being commented out in the BMath.sol that should be removed. It seems that most of the commented code is related to exit fee, however this is in contrast to BPool.sol code base that still has the exit fee code flow, but uses 0 as the fee.  Examples  code/contracts/BMath.sol:L137-L140  uint tokenInRatio = bdiv(newTokenBalanceIn, tokenBalanceIn);  // uint newPoolSupply = (ratioTi ^ weightTi) * poolSupply;  uint poolRatio = bpow(tokenInRatio, normalizedWeight);  code/contracts/BMath.sol:L206-L209  uint normalizedWeight = bdiv(tokenWeightOut, totalWeight);  // charge exit fee on the pool token side  // pAiAfterExitFee = pAi*(1-exitFee)  uint poolAmountInAfterExitFee = bmul(poolAmountIn, bsub(BONE, EXIT_FEE));  And many more examples.  Recommendation  Remove the commented code, or address them properly. If the code is related to exit fee, which is considered to be 0 in this version, this style should be persistent in other contracts as well.  5.3 Max weight requirement in rebind is inaccurate Minor  Description  BPool.rebind enforces MIN_WEIGHT and MAX_WEIGHT bounds on the passed-in denorm value:  code/contracts/BPool.sol:L262-L274  function rebind(address token, uint balance, uint denorm)  public  _logs_  _lock_  require(msg.sender == _controller, \"ERR_NOT_CONTROLLER\");  require(_records[token].bound, \"ERR_NOT_BOUND\");  require(!_finalized, \"ERR_IS_FINALIZED\");  require(denorm >= MIN_WEIGHT, \"ERR_MIN_WEIGHT\");  require(denorm <= MAX_WEIGHT, \"ERR_MAX_WEIGHT\");  require(balance >= MIN_BALANCE, \"ERR_MIN_BALANCE\");  MIN_WEIGHT is 1 BONE, and MAX_WEIGHT is 50 BONE.  Though a token weight of 50 BONE may make sense in a single-token system, BPool is intended to be used with two to eight tokens. The sum of the weights of all tokens must not be greater than 50 BONE.  This implies that a weight of 50 BONE for any single token is incorrect, given that at least one other token must be present.  Recommendation  MAX_WEIGHT for any single token should be MAX_WEIGHT - MIN_WEIGHT, or 49 BONE.  5.4 Switch modifier order in BPool Minor  Description  BPool functions often use modifiers in the following order: _logs_, _lock_. Because _lock_ is a reentrancy guard, it should take precedence over _logs_. See example:  Recommendation  Place _lock_ before other modifiers; ensuring it is the very first and very last thing to run when a function is called.  6 Document Change Log  1.0  2020-05-15  Initial report  ", "labels": ["Consensys"], "html_url": "https://consensys.io/diligence/audits/2020/05/balancer-finance/"}, {"title": "5.1 ERC20 tokens with no return value will fail to transfer    ", "body": "  Resolution  This issue was addressed using OpenZeppelin s SafeERC20.  Description  Although the ERC20 standard suggests that a transfer should return true on success, many tokens are non-compliant in this regard.  In that case, the .transfer() call here will revert even if the transfer is successful, because solidity will check that the RETURNDATASIZE matches the ERC20 interface.  code/contracts/ExchangeDeposit.sol:L229-L231  if (!instance.transfer(getSendAddress(), forwarderBalance)) {  revert('Could not gather ERC20');  Recommendation  Consider using OpenZeppelin s SafeERC20.  ", "labels": ["Consensys", "Major", "Fixed"], "html_url": "https://consensys.io/diligence/audits/2020/11/bitbank/"}, {"title": "5.1 PeriodicPrizeStrategy - RNG failure can lock user funds ", "body": "  Description  To prevent manipulation of the SortitionSumTree after a requested random number enters the mempool, users are unable to withdraw funds while the strategy contract waits on a random number request between execution of startAward() and completeAward().  If an rng request fails, however, there is no way to exit this locked state. After an rng request times out, only startAward() can be called, which will make another rng request and re-enter the same locked state. The rng provider can also not be updated while the contract is in this state. If the rng provider fails permanently, user funds are permanently locked.  Examples  requireNotLocked() prevents transfers, deposits, or withdrawals when there is a pending award.  code/pool/contracts/prize-strategy/PeriodicPrizeStrategy.sol:L282-L285  function beforeTokenTransfer(address from, address to, uint256 amount, address controlledToken) external override onlyPrizePool {  if (controlledToken == address(ticket)) {  _requireNotLocked();  code/pool/contracts/prize-strategy/PeriodicPrizeStrategy.sol:L528-L531  function _requireNotLocked() internal view {  uint256 currentBlock = _currentBlock();  require(rngRequest.lockBlock == 0 || currentBlock < rngRequest.lockBlock, \"PeriodicPrizeStrategy/rng-in-flight\");  setRngService() reverts if there is a pending or timed-out rng request  code/pool/contracts/prize-strategy/PeriodicPrizeStrategy.sol:L413-L414  function setRngService(RNGInterface rngService) external onlyOwner {  require(!isRngRequested(), \"PeriodicPrizeStrategy/rng-in-flight\");  Recommendation  Instead of forcing the pending award phase to be re-entered in the event of an rng request time-out, provide an exitAwardPhase() function that ends the award phase without paying out the award. This will at least allow users to withdraw their funds in the event of a catastrophic failure of the rng service. It may also be prudent to allow the rng service to be updated in the event of an rng request time out.  ", "labels": ["Consensys", "Critical"], "html_url": "https://consensys.io/diligence/audits/2020/11/pooltogether-lootbox-and-multiplewinners-strategy/"}, {"title": "5.2 LootBox - Unprotected selfdestruct in proxy implementation ", "body": "  Description  When the LootBoxController is deployed, it also deploys an instance of LootBox. When someone calls LootBoxController.plunder() or LootBoxController.executeCall() the controller actually deploys a temporary proxy contract to a deterministic address using create2, then calls out to it to collect the loot.  The LootBox implementation contract is completely unprotected, exposing all its functionality to any actor on the blockchain. The most critical functionality is actually the LootBox.destroy() method that calls selfdestruct() on the implementation contract.  Therefore, an unauthenticated user can selfdestruct the LootBox proxy implementation and cause the complete system to become dysfunctional. As an effect, none of the AirDrops that were delivered based on this contract will be redeemable (Note: create2 deploy address is calculated from the current contract address and salt). Funds may be lost.  Examples  code/loot-box/contracts/LootBoxController.sol:L28-L31  constructor () public {  lootBoxActionInstance = new LootBox();  lootBoxActionBytecode = MinimalProxyLibrary.minimalProxy(address(lootBoxActionInstance));  code/loot-box/contracts/LootBox.sol:L86-L90  /// @notice Destroys this contract using `selfdestruct`  /// @param to The address to send remaining Ether to  function destroy(address payable to) external {  selfdestruct(to);  not in scope but listed for completeness  code/pool/contracts/counterfactual-action/CounterfactualAction.sol:L7-L21  contract CounterfactualAction {  function depositTo(address payable user, PrizePool prizePool, address output, address referrer) external {  IERC20 token = IERC20(prizePool.token());  uint256 amount = token.balanceOf(address(this));  token.approve(address(prizePool), amount);  prizePool.depositTo(user, amount, output, referrer);  selfdestruct(user);  function cancel(address payable user, PrizePool prizePool) external {  IERC20 token = IERC20(prizePool.token());  token.transfer(user, token.balanceOf(address(this)));  selfdestruct(user);  Recommendation  Enforce that only the deployer of the contract can call functionality in the contract. Make sure that nobody can destroy the implementation of proxy contracts.  ", "labels": ["Consensys", "Critical"], "html_url": "https://consensys.io/diligence/audits/2020/11/pooltogether-lootbox-and-multiplewinners-strategy/"}, {"title": "5.3 Ticket duplication ", "body": "  Description  Ticket._beforeTokenTransfer() contains logic to update the SortitionSumTree from which prize winners are drawn. In the case where the from address is the same as the to address, tickets are duplicated rather than left unchanged. This allows any attacker to duplicate their tickets with no limit and virtually guarantee that they will win all awarded prizes.  code/pool/contracts/token/Ticket.sol:L71-L79  if (from != address(0)) {  uint256 fromBalance = balanceOf(from).sub(amount);  sortitionSumTrees.set(TREE_KEY, fromBalance, bytes32(uint256(from)));  if (to != address(0)) {  uint256 toBalance = balanceOf(to).add(amount);  sortitionSumTrees.set(TREE_KEY, toBalance, bytes32(uint256(to)));  This code was outside the scope of our review but was live on mainnet at the time the issue was disovered. We immediately made the client aware of the issue and an effort was made to mitigate the impact on the existing deployment.  ", "labels": ["Consensys", "Major"], "html_url": "https://consensys.io/diligence/audits/2020/11/pooltogether-lootbox-and-multiplewinners-strategy/"}, {"title": "5.4 PeriodicPriceStrategy - trustedForwarder can impersonate any msg.sender ", "body": "  Description  The centralization of power to allow one account to impersonate other components and roles (owner, listener, prizePool) in the system is a concern by itself and may give users pause when deciding whether to trust the contract system. The fact that the trustedForwarder can spoof events for any msg.sender may also make it hard to keep an accurate log trail of events in case of a security incident.  Note: The same functionality seems to be used in ControlledToken and other contracts which allows the trustedForwarder to assume any tokenholder in ERC20UpgradeSafe. There is practically no guarantee to ControlledToken holders.  Note: The trustedForwarder/msgSender() pattern is used in multiple contracts, many of which are not in the scope of this assessment.  Examples  access control modifiers that can be impersonated  code/pool/contracts/prize-strategy/PeriodicPrizeStrategy.sol:L588-L591  modifier onlyPrizePool() {  require(_msgSender() == address(prizePool), \"PeriodicPrizeStrategy/only-prize-pool\");  _;  code/pool/contracts/prize-strategy/PeriodicPrizeStrategy.sol:L565-L568  modifier onlyOwnerOrListener() {  require(_msgSender() == owner() || _msgSender() == address(periodicPrizeStrategyListener), \"PeriodicPrizeStrategy/only-owner-or-listener\");  _;  event msg.sender that can be spoofed because the actual msg.sender can be trustedForwarder  code/pool/contracts/prize-strategy/PeriodicPrizeStrategy.sol:L164-L164  emit PrizePoolOpened(_msgSender(), prizePeriodStartedAt);  code/pool/contracts/prize-strategy/PeriodicPrizeStrategy.sol:L340-L340  emit PrizePoolAwardStarted(_msgSender(), address(prizePool), requestId, lockBlock);  code/pool/contracts/prize-strategy/PeriodicPrizeStrategy.sol:L356-L357  emit PrizePoolAwarded(_msgSender(), randomNumber);  emit PrizePoolOpened(_msgSender(), prizePeriodStartedAt);  _msgSender() implementation allows the trustedForwarder to impersonate any msg.sender address  code/pool/contracts/prize-strategy/PeriodicPrizeStrategy.sol:L541-L551  /// @dev Provides information about the current execution context for GSN Meta-Txs.  /// @return The payable address of the message sender  function _msgSender()  internal  override(BaseRelayRecipient, ContextUpgradeSafe)  virtual  view  returns (address payable)  return BaseRelayRecipient._msgSender();  // File: @opengsn/gsn/contracts/BaseRelayRecipient.sol  ...  /**  return the sender of this call.  if the call came through our trusted forwarder, return the original sender.  otherwise, return `msg.sender`.  should be used in the contract anywhere instead of msg.sender  /  function _msgSender() internal override virtual view returns (address payable ret) {  if (msg.data.length >= 24 && isTrustedForwarder(msg.sender)) {  // At this point we know that the sender is a trusted forwarder,  // so we trust that the last bytes of msg.data are the verified sender address.  // extract sender address from the end of msg.data  assembly {  ret := shr(96,calldataload(sub(calldatasize(),20)))  } else {  return msg.sender;  Recommendation  Remove the trustedForwarder or restrict the type of actions the forwarder can perform and don t allow it to impersonate other components in the system. Make sure users understand the trust assumptions and who has what powers in the system. Make sure to keep an accurate log trail of who performed which action on whom s behalf.  ", "labels": ["Consensys", "Major"], "html_url": "https://consensys.io/diligence/audits/2020/11/pooltogether-lootbox-and-multiplewinners-strategy/"}, {"title": "5.5 Unpredictable behavior for users due to admin front running or general bad timing ", "body": "  Description  In a number of cases, administrators of contracts can update or upgrade things in the system without warning. This has the potential to violate a security goal of the system.  Specifically, privileged roles could use front running to make malicious changes just ahead of incoming transactions, or purely accidental negative effects could occur due to unfortunate timing of changes.  In general users of the system should have assurances about the behavior of the action they re about to take.  Examples  An administrator (deployer) of MultipleWinners can change the number of winners in the system without warning. This has the potential to violate a security goal of the system.  admin can change the number of winners during a prize-draw period  code/pool/contracts/prize-strategy/multiple-winners/MultipleWinners.sol:L38-L42  function setNumberOfWinners(uint256 count) external onlyOwner {  __numberOfWinners = count;  emit NumberOfWinnersSet(count);  PeriodicPriceStrategy - admin may switch-out RNG service at any time (when RNG is not in inflight or timed-out)  code/pool/contracts/prize-strategy/PeriodicPrizeStrategy.sol:L413-L418  function setRngService(RNGInterface rngService) external onlyOwner {  require(!isRngRequested(), \"PeriodicPrizeStrategy/rng-in-flight\");  rng = rngService;  emit RngServiceUpdated(address(rngService));  PeriodicPriceStrategy - admin can effectively disable the rng request timeout by setting a high value during a prize-draw (e.g. to indefinitely block payouts)  code/pool/contracts/prize-strategy/PeriodicPrizeStrategy.sol:L420-L422  function setRngRequestTimeout(uint32 _rngRequestTimeout) external onlyOwner {  _setRngRequestTimeout(_rngRequestTimeout);  PeriodicPriceStrategy - admin may set new tokenListener which might intentionally block token-transfers  code/pool/contracts/prize-strategy/PeriodicPrizeStrategy.sol:L175-L179  function setTokenListener(TokenListenerInterface _tokenListener) external onlyOwner {  tokenListener = _tokenListener;  emit TokenListenerUpdated(address(tokenListener));  code/pool/contracts/prize-strategy/PeriodicPrizeStrategy.sol:L360-L364  function setPeriodicPrizeStrategyListener(address _periodicPrizeStrategyListener) external onlyOwner {  periodicPrizeStrategyListener = PeriodicPrizeStrategyListener(_periodicPrizeStrategyListener);  emit PeriodicPrizeStrategyListenerSet(_periodicPrizeStrategyListener);  out of scope but mentioned as a relevant example: PrizePool owner can set new PrizeStrategy at any time  code/pool/contracts/prize-pool/PrizePool.sol:L1003-L1008  /// @notice Sets the prize strategy of the prize pool.  Only callable by the owner.  /// @param _prizeStrategy The new prize strategy  function setPrizeStrategy(address _prizeStrategy) external override onlyOwner {  _setPrizeStrategy(TokenListenerInterface(_prizeStrategy));  a malicious admin may remove all external ERC20/ERC721 token awards prior to the user claiming them (admin front-running opportunity)  code/pool/contracts/prize-strategy/PeriodicPrizeStrategy.sol:L461-L464  function removeExternalErc20Award(address _externalErc20, address _prevExternalErc20) external onlyOwner {  externalErc20s.removeAddress(_prevExternalErc20, _externalErc20);  emit ExternalErc20AwardRemoved(_externalErc20);  code/pool/contracts/prize-strategy/PeriodicPrizeStrategy.sol:L506-L510  function removeExternalErc721Award(address _externalErc721, address _prevExternalErc721) external onlyOwner {  externalErc721s.removeAddress(_prevExternalErc721, _externalErc721);  delete externalErc721TokenIds[_externalErc721];  emit ExternalErc721AwardRemoved(_externalErc721);  the PeriodicPrizeStrategy owner (also see concerns outlined in issue 5.4) can transfer external ERC20 at any time to avoid them being awarded to users. there is no guarantee to the user.  code/pool/contracts/prize-strategy/PeriodicPrizeStrategy.sol:L517-L526  function transferExternalERC20(  address to,  address externalToken,  uint256 amount  external  onlyOwner  prizePool.transferExternalERC20(to, externalToken, amount);  Recommendation  The underlying issue is that users of the system can t be sure what the behavior of a function call will be, and this is because the behavior can change at any time.  We recommend giving the user advance notice of changes with a time lock. For example, make all system-parameter and upgrades require two steps with a mandatory time window between them. The first step merely broadcasts to users that a particular change is coming, and the second step commits that change after a suitable waiting period. This allows users that do not accept the change to withdraw immediately.  ", "labels": ["Consensys", "Major"], "html_url": "https://consensys.io/diligence/audits/2020/11/pooltogether-lootbox-and-multiplewinners-strategy/"}, {"title": "5.6 PeriodicPriceStrategy - addExternalErc721Award duplicate or invalid tokenIds may block award phase ", "body": "  Description  The prize-strategy owner (or a listener) can add ERC721 token awards by calling addExternalErc721Award providing the ERC721 token address and a list of tokenIds owned by the prizePool.  The method does not check if duplicate tokenIds or tokenIds that are not owned by the contract are provided. This may cause an exception when _awardExternalErc721s calls prizePool.awardExternalERC721 to transfer an invalid or previously transferred token, blocking the award phase.  Note: An admin can recover from this situation by removing and re-adding the ERC721 token from the awards list.  Examples  adding tokenIds  code/pool/contracts/prize-strategy/PeriodicPrizeStrategy.sol:L478-L499  /// @notice Adds an external ERC721 token as an additional prize that can be awarded  /// @dev Only the Prize-Strategy owner/creator can assign external tokens,  /// and they must be approved by the Prize-Pool  /// NOTE: The NFT must already be owned by the Prize-Pool  /// @param _externalErc721 The address of an ERC721 token to be awarded  /// @param _tokenIds An array of token IDs of the ERC721 to be awarded  function addExternalErc721Award(address _externalErc721, uint256[] calldata _tokenIds) external onlyOwnerOrListener {  // require(_externalErc721.isContract(), \"PeriodicPrizeStrategy/external-erc721-not-contract\");  require(prizePool.canAwardExternal(_externalErc721), \"PeriodicPrizeStrategy/cannot-award-external\");  if (!externalErc721s.contains(_externalErc721)) {  externalErc721s.addAddress(_externalErc721);  for (uint256 i = 0; i < _tokenIds.length; i++) {  uint256 tokenId = _tokenIds[i];  require(IERC721(_externalErc721).ownerOf(tokenId) == address(prizePool), \"PeriodicPrizeStrategy/unavailable-token\");  externalErc721TokenIds[_externalErc721].push(tokenId);  emit ExternalErc721AwardAdded(_externalErc721, _tokenIds);  awarding tokens  code/pool/contracts/prize-strategy/PeriodicPrizeStrategy.sol:L248-L263  /// @notice Awards all external ERC721 tokens to the given user.  /// The external tokens must be held by the PrizePool contract.  /// @dev The list of ERC721s is reset after every award  /// @param winner The user to transfer the tokens to  function _awardExternalErc721s(address winner) internal {  address currentToken = externalErc721s.start();  while (currentToken != address(0) && currentToken != externalErc721s.end()) {  uint256 balance = IERC721(currentToken).balanceOf(address(prizePool));  if (balance > 0) {  prizePool.awardExternalERC721(winner, currentToken, externalErc721TokenIds[currentToken]);  delete externalErc721TokenIds[currentToken];  currentToken = externalErc721s.next(currentToken);  externalErc721s.clearAll();  transferring the tokens  code/pool/contracts/prize-pool/PrizePool.sol:L582-L606  /// @notice Called by the prize strategy to award external ERC721 prizes  /// @dev Used to award any arbitrary NFTs held by the Prize Pool  /// @param to The address of the winner that receives the award  /// @param externalToken The address of the external NFT token being awarded  /// @param tokenIds An array of NFT Token IDs to be transferred  function awardExternalERC721(  address to,  address externalToken,  uint256[] calldata tokenIds  external override  onlyPrizeStrategy  require(_canAwardExternal(externalToken), \"PrizePool/invalid-external-token\");  if (tokenIds.length == 0) {  return;  for (uint256 i = 0; i < tokenIds.length; i++) {  IERC721(externalToken).transferFrom(address(this), to, tokenIds[i]);  emit AwardedExternalERC721(to, externalToken, tokenIds);  Recommendation  Ensure that no duplicate token-ids were provided or skip over token-ids that are not owned by prize-pool (anymore).  ", "labels": ["Consensys", "Medium"], "html_url": "https://consensys.io/diligence/audits/2020/11/pooltogether-lootbox-and-multiplewinners-strategy/"}, {"title": "5.7 PeriodicPrizeStrategy - Token with callback related warnings (ERC777 a.o.) ", "body": "  Description  This issue is highly dependent on the configuration of the system. If an admin decides to allow callback enabled token (e.g. ERC20 compliant ERC777 or other ERC721/ERC20 extensions) as awards then one recipient may be able to  block the payout for everyone by forcing a revert in the callback when accepting token awards  use the callback to siphon gas, mint gas token, or similar activities  potentially re-enter the PrizeStrategy contract in an attempt to manipulate the payout (e.g. by immediately withdrawing from the pool to manipulate the 2nd ticket.draw())  Examples  code/pool/contracts/prize-strategy/PeriodicPrizeStrategy.sol:L252-L263  function _awardExternalErc721s(address winner) internal {  address currentToken = externalErc721s.start();  while (currentToken != address(0) && currentToken != externalErc721s.end()) {  uint256 balance = IERC721(currentToken).balanceOf(address(prizePool));  if (balance > 0) {  prizePool.awardExternalERC721(winner, currentToken, externalErc721TokenIds[currentToken]);  delete externalErc721TokenIds[currentToken];  currentToken = externalErc721s.next(currentToken);  externalErc721s.clearAll();  Recommendation  It is highly recommended to not allow tokens with callback functionality into the system. Document and/or implement safeguards that disallow the use of callback enabled tokens. Consider implementing means for the  other winners  to withdraw their share of the rewards independently from others.  ", "labels": ["Consensys", "Medium"], "html_url": "https://consensys.io/diligence/audits/2020/11/pooltogether-lootbox-and-multiplewinners-strategy/"}, {"title": "5.8 PeriodicPrizeStrategy - unbounded external tokens linked list may be used to force a gas DoS ", "body": "  Description  The size of the linked list of ERC20/ERC721 token awards is not limited. This fact may be exploited by an administrative account by adding an excessive number of external token addresses.  The winning user might want to claim their win by calling completeAward() which fails in one of the _distribute() -> _awardAllExternalTokens() -> _awardExternalErc20s/_awardExternalErc721s while loops if too many token addresses are configured and gas consumption hits the block gas limit (or it just gets too expensive for the user to call).  Note: an admin can recover from this situation by removing items from the list.  Examples  code/pool/contracts/prize-strategy/PeriodicPrizeStrategy.sol:L436-L448  /// @notice Adds an external ERC20 token type as an additional prize that can be awarded  /// @dev Only the Prize-Strategy owner/creator can assign external tokens,  /// and they must be approved by the Prize-Pool  /// @param _externalErc20 The address of an ERC20 token to be awarded  function addExternalErc20Award(address _externalErc20) external onlyOwnerOrListener {  _addExternalErc20Award(_externalErc20);  function _addExternalErc20Award(address _externalErc20) internal {  require(prizePool.canAwardExternal(_externalErc20), \"PeriodicPrizeStrategy/cannot-award-external\");  externalErc20s.addAddress(_externalErc20);  emit ExternalErc20AwardAdded(_externalErc20);  code/pool/contracts/utils/MappedSinglyLinkedList.sol:L46-L53  /// @param newAddress The address to shift to the front of the list  function addAddress(Mapping storage self, address newAddress) internal {  require(newAddress != SENTINEL && newAddress != address(0), \"Invalid address\");  require(self.addressMap[newAddress] == address(0), \"Already added\");  self.addressMap[newAddress] = self.addressMap[SENTINEL];  self.addressMap[SENTINEL] = newAddress;  self.count = self.count + 1;  awarding the tokens loops through the linked list of configured tokens  code/pool/contracts/prize-strategy/PeriodicPrizeStrategy.sol:L248-L263  /// @notice Awards all external ERC721 tokens to the given user.  /// The external tokens must be held by the PrizePool contract.  /// @dev The list of ERC721s is reset after every award  /// @param winner The user to transfer the tokens to  function _awardExternalErc721s(address winner) internal {  address currentToken = externalErc721s.start();  while (currentToken != address(0) && currentToken != externalErc721s.end()) {  uint256 balance = IERC721(currentToken).balanceOf(address(prizePool));  if (balance > 0) {  prizePool.awardExternalERC721(winner, currentToken, externalErc721TokenIds[currentToken]);  delete externalErc721TokenIds[currentToken];  currentToken = externalErc721s.next(currentToken);  externalErc721s.clearAll();  Recommendation  Limit the number of tokens an admin can add. Consider implementing an interface that allows the user to claim tokens one-by-one or in user-configured batches.  ", "labels": ["Consensys", "Medium"], "html_url": "https://consensys.io/diligence/audits/2020/11/pooltogether-lootbox-and-multiplewinners-strategy/"}, {"title": "5.9 MultipleWinners - setNumberOfWinners does not enforce count>0 ", "body": "  Description  The constructor of MultipleWinners enforces that the argument _numberOfWinners > 0 while setNumberOfWinners does not. A careless or malicious admin might set __numberOfWinners to zero to cause the distribute() method to throw and not pay out any winners.  Examples  enforced in the constructor  code/pool/contracts/prize-strategy/multiple-winners/MultipleWinners.sol:L34-L34  require(_numberOfWinners > 0, \"MultipleWinners/num-gt-zero\");  not enforced when updating the value at a later stage  code/pool/contracts/prize-strategy/multiple-winners/MultipleWinners.sol:L38-L42  function setNumberOfWinners(uint256 count) external onlyOwner {  __numberOfWinners = count;  emit NumberOfWinnersSet(count);  Recommendation  Require that numberOfWinners > 0.  ", "labels": ["Consensys", "Medium"], "html_url": "https://consensys.io/diligence/audits/2020/11/pooltogether-lootbox-and-multiplewinners-strategy/"}, {"title": "5.10 LootBox - plunder should disallow plundering to address(0) ", "body": "  Description  Note:  Depending on the token implementation, transfers may or may not revert if the toAddress == address(0), while burning the ETH will succeed.  This might allow anyone to forcefully burn received ETH that would otherwise be available to the future beneficiary  If the airdrop and transfer of LootBox ownership are not done within one transaction, this might open up a front-running window that allows a third party to burn air-dropped ETH before it can be claimed by the owner.  consider one component issues the airdrop in one transaction (or block) and setting the owner in a later transaction (or block). The owner is unset for a short duration of time which might allow anyone to burn ETH held by the LootBox proxy instance.  Examples  plunder() receiving the owner of an ERC721.tokenId  code/loot-box/contracts/LootBoxController.sol:L49-L56  function plunder(  address erc721,  uint256 tokenId,  IERC20[] calldata erc20s,  LootBox.WithdrawERC721[] calldata erc721s,  LootBox.WithdrawERC1155[] calldata erc1155s  ) external {  address payable owner = payable(IERC721(erc721).ownerOf(tokenId));  The modified ERC721 returns address(0) if the owner is not known  code/loot-box/contracts/external/openzeppelin/ERC721.sol:L102-L107  While withdraw[ERC20|ERC721|ERC1155] fail with to == address(0), transferEther() succeeds and burns the eth by sending it to address(0)  @dev See {IERC721-ownerOf}.  /  function ownerOf(uint256 tokenId) public view override returns (address) {  return _tokenOwners[tokenId];  While withdraw[ERC20|ERC721|ERC1155] fail with to == address(0), transferEther() succeeds and burns the eth by sending it to address(0)  code/loot-box/contracts/LootBox.sol:L74-L84  function plunder(  IERC20[] memory erc20,  WithdrawERC721[] memory erc721,  WithdrawERC1155[] memory erc1155,  address payable to  ) external {  _withdrawERC20(erc20, to);  _withdrawERC721(erc721, to);  _withdrawERC1155(erc1155, to);  transferEther(to, address(this).balance);  Recommendation  Require that the destination address to in plunder() and transferEther() is not address(0).  ", "labels": ["Consensys", "Medium"], "html_url": "https://consensys.io/diligence/audits/2020/11/pooltogether-lootbox-and-multiplewinners-strategy/"}, {"title": "5.11 PeriodicPrizeStrategy - Inconsistent behavior between award-phase modifiers and view functions ", "body": "  Description  The logic in the canStartAward() function is inconsistent with that of the requireCanStartAward modifier, and the logic in the canCompleteAward() function is inconsistent with that of the requireCanCompleteAward modifier. Neither of these view functions appear to be used elsewhere in the codebase, but the similarities between the function names and the corresponding modifiers is highly misleading.  Examples  canStartAward() is inconsistent with requireCanStartAward  code/pool/contracts/prize-strategy/PeriodicPrizeStrategy.sol:L377-L379  function canStartAward() external view returns (bool) {  return _isPrizePeriodOver() && !isRngRequested();  code/pool/contracts/prize-strategy/PeriodicPrizeStrategy.sol:L575-L579  modifier requireCanStartAward() {  require(_isPrizePeriodOver(), \"PeriodicPrizeStrategy/prize-period-not-over\");  require(!isRngRequested() || isRngTimedOut(), \"PeriodicPrizeStrategy/rng-already-requested\");  _;  canCompleteAward() is inconsistent with requireCanCompleteAward  code/pool/contracts/prize-strategy/PeriodicPrizeStrategy.sol:L383-L385  function canCompleteAward() external view returns (bool) {  return isRngRequested() && isRngCompleted();  code/pool/contracts/prize-strategy/PeriodicPrizeStrategy.sol:L581-L586  modifier requireCanCompleteAward() {  require(_isPrizePeriodOver(), \"PeriodicPrizeStrategy/prize-period-not-over\");  require(isRngRequested(), \"PeriodicPrizeStrategy/rng-not-requested\");  require(isRngCompleted(), \"PeriodicPrizeStrategy/rng-not-complete\");  _;  Recommendation  Make the logic consistent between the view functions and the modifiers of the same name or remove the functions.  ", "labels": ["Consensys", "Minor"], "html_url": "https://consensys.io/diligence/audits/2020/11/pooltogether-lootbox-and-multiplewinners-strategy/"}, {"title": "5.12 MultipleWinners - Awards can be guaranteed with a set number of tickets ", "body": "  Description  Because additional award drawings are distributed at a constant interval in the SortitionSumTree by MultipleWinners._distribute(), any user that holds a number of tickets >= floor(totalSupply / __numberOfWinners) can guarantee at least one award regardless of the initial drawing.  MultipleWinners._distribute():  code/pool/contracts/prize-strategy/multiple-winners/MultipleWinners.sol:L59-L65  uint256 ticketSplit = totalSupply.div(__numberOfWinners);  uint256 nextRandom = randomNumber.add(ticketSplit);  // the other winners receive their prizeShares  for (uint256 winnerCount = 1; winnerCount < __numberOfWinners; winnerCount++) {  winners[winnerCount] = ticket.draw(nextRandom);  nextRandom = nextRandom.add(ticketSplit);  Recommendation  Do not distribute awards at fixed intervals from the initial drawing, but instead randomize the additional drawings as well.  ", "labels": ["Consensys", "Minor"], "html_url": "https://consensys.io/diligence/audits/2020/11/pooltogether-lootbox-and-multiplewinners-strategy/"}, {"title": "5.13 MultipleWinners - Inconsistent behavior compared to SingleRandomWinner ", "body": "  Description  The MultipleWinners strategy carries out award distribution to the zero address if ticket.draw() returns address(0) (indicating an error condition) while SingleRandomWinner does not.  Examples  SingleRandomWinner silently skips award distribution if ticket.draw() returns address(0).  code/pool/contracts/prize-strategy/single-random-winner/SingleRandomWinner.sol:L8-L17  contract SingleRandomWinner is PeriodicPrizeStrategy {  function _distribute(uint256 randomNumber) internal override {  uint256 prize = prizePool.captureAwardBalance();  address winner = ticket.draw(randomNumber);  if (winner != address(0)) {  _awardTickets(winner, prize);  _awardAllExternalTokens(winner);  MultipleWinners still attempts to distribute awards if ticket.draw() returns address(0). This may or may not succeed depending on the implementation of the tokens included in the externalErc20s and externalErc721s linked lists.  code/pool/contracts/prize-strategy/multiple-winners/MultipleWinners.sol:L48-L57  function _distribute(uint256 randomNumber) internal override {  uint256 prize = prizePool.captureAwardBalance();  // main winner gets all external tokens  address mainWinner = ticket.draw(randomNumber);  _awardAllExternalTokens(mainWinner);  address[] memory winners = new address[](__numberOfWinners);  winners[0] = mainWinner;  Recommendation  Implement consistent behavior. Avoid hiding error conditions and consider throwing an exception instead.  ", "labels": ["Consensys", "Minor"], "html_url": "https://consensys.io/diligence/audits/2020/11/pooltogether-lootbox-and-multiplewinners-strategy/"}, {"title": "5.14 Initialize implementations for proxy contracts and protect initialization methods ", "body": "  Description  Any situation where the implementation of proxy contracts can be initialized by third parties should be avoided. This can be the case if the initialize function is unprotected or not initialized immediately after deployment. Since the implementation contract is not meant to be used directly without a proxy delegate-calling to it, it is recommended to protect the initialization method of the implementation by initializing on deployment.  This affects all proxy implementations (the delegatecall target contract) deployed in the system.  Examples  The implementation for MultipleWinners is not initialized. Even though not directly used by the system it may be initialized by a third party.  code/pool/contracts/prize-strategy/multiple-winners/MultipleWinnersProxyFactory.sol:L13-L15  constructor () public {  instance = new MultipleWinners();  The deployed ERC721Contract is not initialized.  code/loot-box/contracts/ERC721ControlledFactory.sol:L25-L29  constructor () public {  erc721ControlledInstance = new ERC721Controlled();  erc721ControlledBytecode = MinimalProxyLibrary.minimalProxy(address(erc721ControlledInstance));  The deployed LootBox is not initialized.  code/loot-box/contracts/LootBoxController.sol:L28-L31  constructor () public {  lootBoxActionInstance = new LootBox();  lootBoxActionBytecode = MinimalProxyLibrary.minimalProxy(address(lootBoxActionInstance));  Recommendation  Initialize unprotected implementation contracts in the implementation s constructor. Protect initialization methods from being called by unauthorized parties or ensure that deployment of the proxy and initialization is performed in the same transaction.  ", "labels": ["Consensys", "Minor"], "html_url": "https://consensys.io/diligence/audits/2020/11/pooltogether-lootbox-and-multiplewinners-strategy/"}, {"title": "5.15 LootBox - transferEther should be internal ", "body": "  Description  LootBox.transferEther() can be internal as it is only called from LootBox.plunder() and the LootBox(proxy) instances are generally very short-living (created and destroyed within one transaction).  Examples  code/loot-box/contracts/LootBox.sol:L63-L67  function transferEther(address payable to, uint256 amount) public {  to.transfer(amount);  emit TransferredEther(to, amount);  Recommendation  Restrict transferEther() s visibility to internal.  ", "labels": ["Consensys", "Minor"], "html_url": "https://consensys.io/diligence/audits/2020/11/pooltogether-lootbox-and-multiplewinners-strategy/"}, {"title": "5.16 LootBox - executeCalls can be misused to relay calls ", "body": "  Description  Note: allows non-value and value calls (deposits can be forces via selfdestruct)  Examples  code/loot-box/contracts/LootBox.sol:L52-L58  function executeCalls(Call[] calldata calls) external returns (bytes[] memory) {  bytes[] memory response = new bytes[](calls.length);  for (uint256 i = 0; i < calls.length; i++) {  response[i] = _executeCall(calls[i].to, calls[i].value, calls[i].data);  return response;  Recommendation  Restrict access to call forwarding functionality to trusted entities. Consider implementing the Ownable pattern allowing access to functionality to the owner only.  ", "labels": ["Consensys", "Minor"], "html_url": "https://consensys.io/diligence/audits/2020/11/pooltogether-lootbox-and-multiplewinners-strategy/"}, {"title": "4.1 FlasherFTM - Unsolicited invocation of the callback (CREAM auth bypass) ", "body": "  Description  TL;DR: Anyone can call ICTokenFlashloan(crToken).flashLoan(address(FlasherFTM), address(FlasherFTM), info.amount, params) directly and pass validation checks in onFlashLoan(). This call forces it to accept unsolicited flash loans and execute the actions provided under the attacker s FlashLoan.Info.  receiver.onFlashLoan(initiator, token, amount, ...) is called when receiving a flash loan. According to EIP-3156, the initiator is msg.sender so that one can use it to check if the call to receiver.onFlashLoan() was unsolicited or not.  Third-party Flash Loan provider contracts are often upgradeable.  For example, the Geist lending contract configured with this system is upgradeable. Upgradeable contracts bear the risk that one cannot assume that the contract is always running the same code. In the worst case, for example, a malicious proxy admin (leaked keys, insider, \u2026) could upgrade the contract and perform unsolicited calls with arbitrary data to Flash Loan consumers in an attempt to exploit them. It, therefore, is highly recommended to verify that flash loan callbacks in the system can only be called if the contract was calling out to the provider to provide a Flash Loan and that the conditions of the flash loan (returned data, amount) are correct.  Not all Flash Loan providers implement EIP-3156 correctly.  Cream Finance, for example, allows users to set an arbitrary initiator when requesting a flash loan. This deviates from EIP-3156 and was reported to the Cream development team as a security issue. Hence, anyone can spoof that initiator and potentially bypass authentication checks in the consumers  receiver.onFlashLoan(). Depending on the third-party application consuming the flash loan is doing with the funds, the impact might range from medium to critical with funds at risk. For example, projects might assume that the flash loan always originates from their trusted components, e.g., because they use them to refinance switching funds between pools or protocols.  Examples  The FlasherFTM contract assumes that flash loans for the Flasher can only be initiated by authorized callers (isAuthorized) - for a reason - because it is vital that the FlashLoan.Info calldata info parameter only contains trusted data:  code/contracts/fantom/flashloans/FlasherFTM.sol:L66-L79  /**  @dev Routing Function for Flashloan Provider  @param info: struct information for flashLoan  @param _flashnum: integer identifier of flashloan provider  /  function initiateFlashloan(FlashLoan.Info calldata info, uint8 _flashnum) external isAuthorized override {  if (_flashnum == 0) {  _initiateGeistFlashLoan(info);  } else if (_flashnum == 2) {  _initiateCreamFlashLoan(info);  } else {  revert(Errors.VL_INVALID_FLASH_NUMBER);  code/contracts/fantom/flashloans/FlasherFTM.sol:L46-L55  modifier isAuthorized() {  require(  msg.sender == _fujiAdmin.getController() ||  msg.sender == _fujiAdmin.getFliquidator() ||  msg.sender == owner(),  Errors.VL_NOT_AUTHORIZED  );  _;  The Cream Flash Loan initiation code requests the flash loan via ICTokenFlashloan(crToken).flashLoan(receiver=address(this), initiator=address(this), ...):  code/contracts/fantom/flashloans/FlasherFTM.sol:L144-L158  /**  @dev Initiates an CreamFinance flashloan.  @param info: data to be passed between functions executing flashloan logic  /  function _initiateCreamFlashLoan(FlashLoan.Info calldata info) internal {  address crToken = info.asset == _FTM  ? 0xd528697008aC67A21818751A5e3c58C8daE54696  : _crMappings.addressMapping(info.asset);  // Prepara data for flashloan execution  bytes memory params = abi.encode(info);  // Initialize Instance of Cream crLendingContract  ICTokenFlashloan(crToken).flashLoan(address(this), address(this), info.amount, params);  contracts/CCollateralCapErc20.sol:L187  address initiator,  code/contracts/fantom/flashloans/FlasherFTM.sol:L162-L175  Recommendation  /  function onFlashLoan(  address sender,  address underlying,  uint256 amount,  uint256 fee,  bytes calldata params  ) external override returns (bytes32) {  // Check Msg. Sender is crToken Lending Contract  // from IronBank because ETH on Cream cannot perform a flashloan  address crToken = underlying == _WFTM  ? 0xd528697008aC67A21818751A5e3c58C8daE54696  : _crMappings.addressMapping(underlying);  require(msg.sender == crToken && address(this) == sender, Errors.VL_NOT_AUTHORIZED);  Recommendation  Cream Finance  We ve reached out to the Cream developer team, who have confirmed the issue. They are planning to implement countermeasures. Our recommendation can be summarized as follows:  Implement the EIP-3156 compliant version of flashLoan() with initiator hardcoded to msg.sender.  FujiDAO (and other flash loan consumers)  We recommend not assuming that FlashLoan.Info contains trusted or even validated data when a third-party flash loan provider provides it! Developers should ensure that the data received was provided when the flash loan was requested.  The contract should reject unsolicited flash loans. In the scenario where a flash loan provider is exploited, the risk of an exploited trust relationship is less likely to spread to the rest of the system.  The Cream initiator provided to the onFlashLoan() callback cannot be trusted until the Cream developers fix this issue. The initiator can easily be spoofed to perform unsolicited flash loans. We, therefore, suggest:  Validate that the initiator value is the flashLoan() caller. This conforms to the standard and is hopefully how the Cream team is fixing this, and  Ensure the implementation tracks its own calls to flashLoan() in a state-variable semaphore, i.e. store the flash loan data/hash in a temporary state-variable that is only set just before calling flashLoan() until being called back in onFlashLoan(). The received data can then be verified against the stored artifact. This is a safe way of authenticating and verifying callbacks.  Values received from untrusted third parties should always be validated with the utmost scrutiny.  Smart contract upgrades are risky, so we recommend implementing the means to pause certain flash loan providers.  Ensure that flash loan handler functions should never re-enter the system. This provides additional security guarantees in case a flash loan provider gets breached.  Note: The Fuji development team implemented a hotfix to prevent unsolicited calls from Cream by storing the hash(FlashLoan.info) in a state variable just before requesting the flash loan. Inside the onFlashLoan callback, this state is validated and cleared accordingly.  An improvement to this hotfix would be, to check _paramsHash before any external calls are made and clear it right after validation at the beginning of the function. Additionally, hash==0x0 should be explicitly disallowed. By doing so, the check also serves as a reentrancy guard and helps further reduce the risk of a potentially malicious flash loan re-entering the function.  ", "labels": ["Consensys", "Critical"], "html_url": "https://consensys.io/diligence/audits/2022/03/fuji-protocol/"}, {"title": "4.2 Lack of reentrancy protection in token interactions ", "body": "  Description  Therefore, it is crucial to strictly adhere to the checks-effects pattern and safeguard affected methods using a mutex.  Examples  code/contracts/fantom/libraries/LibUniversalERC20FTM.sol:L26-L40  function univTransfer(  IERC20 token,  address payable to,  uint256 amount  ) internal {  if (amount > 0) {  if (isFTM(token)) {  (bool sent, ) = to.call{ value: amount }(\"\");  require(sent, \"Failed to send Ether\");  } else {  token.safeTransfer(to, amount);  withdraw is nonReentrant while paybackAndWithdraw is not, which appears to be inconsistent  code/contracts/fantom/FujiVaultFTM.sol:L172-L182  /**  @dev Paybacks the underlying asset and withdraws collateral in a single function call from activeProvider  @param _paybackAmount: amount of underlying asset to be payback, pass -1 to pay full amount  @param _collateralAmount: amount of collateral to be withdrawn, pass -1 to withdraw maximum amount  /  function paybackAndWithdraw(int256 _paybackAmount, int256 _collateralAmount) external payable {  updateF1155Balances();  _internalPayback(_paybackAmount);  _internalWithdraw(_collateralAmount);  code/contracts/fantom/FujiVaultFTM.sol:L232-L241  /**  @dev Paybacks Vault's type underlying to activeProvider - called by users  @param _repayAmount: token amount of underlying to repay, or  pass any 'negative number' to repay full ammount  Emits a {Repay} event.  /  function payback(int256 _repayAmount) public payable override {  updateF1155Balances();  _internalPayback(_repayAmount);  depositAndBorrow is not nonReentrant while borrow() is which appears to be inconsistent  code/contracts/fantom/FujiVaultFTM.sol:L161-L171  /**  @dev Deposits collateral and borrows underlying in a single function call from activeProvider  @param _collateralAmount: amount to be deposited  @param _borrowAmount: amount to be borrowed  /  function depositAndBorrow(uint256 _collateralAmount, uint256 _borrowAmount) external payable {  updateF1155Balances();  _internalDeposit(_collateralAmount);  _internalBorrow(_borrowAmount);  code/contracts/fantom/FujiVaultFTM.sol:L222-L230  /**  @dev Borrows Vault's type underlying amount from activeProvider  @param _borrowAmount: token amount of underlying to borrow  Emits a {Borrow} event.  /  function borrow(uint256 _borrowAmount) public override nonReentrant {  updateF1155Balances();  _internalBorrow(_borrowAmount);  depositAndBorrow  updateBalances  internalDeposit ->  ERC777(collateralAsset).safeTransferFrom()  ---> calls back!  ---callback:beforeTokenTransfer---->  !! depositAndBorrow  updateBalances  internalDeposit  --> ERC777.safeTransferFrom()  <--  _deposit  mint  internalBorrow  mint  _borrow  ERC777(borrowAsset).univTransfer(msg.sender) --> might call back  <-------------------------------  _deposit  mint  internalBorrow  mint  _borrow  --> ERC777(borrowAsset).univTransfer(msg.sender) --> might call back  <--  Recommendation  Consider decorating methods that may call back to untrusted sources (i.e., native token transfers, callback token operations) as nonReentrant and strictly follow the checks-effects pattern for all contracts in the code-base.  ", "labels": ["Consensys", "Major"], "html_url": "https://consensys.io/diligence/audits/2022/03/fuji-protocol/"}, {"title": "4.3 Lack of segregation of duties, excessive owner permissions, misleading authentication modifiers ", "body": "  Descriptio  In the FujiERC1155 contract, the onlyPermit modifier should not include owner.  code/contracts/abstracts/fujiERC1155/F1155Manager.sol:L34-L37  modifier onlyPermit() {  require(addrPermit[_msgSender()] || msg.sender == owner(), Errors.VL_NOT_AUTHORIZED);  _;  However, the owner can also wholly mess up accounting as they are permitted to call updateState(), which should only be callable by vaults:  code/contracts/FujiERC1155.sol:L53-L59  function updateState(uint256 _assetID, uint256 newBalance) external override onlyPermit {  uint256 total = totalSupply(_assetID);  if (newBalance > 0 && total > 0 && newBalance > total) {  uint256 newIndex = (indexes[_assetID] * newBalance) / total;  indexes[_assetID] = uint128(newIndex);  The same is true for FujiERC1155.{mint|mintBatch|burn|burnBatch|addInitializeAsset} unless there is a reason to allow owner to freely burn/mint/initialize tokens and updateState for borrowed assets to arbitrary values.  FujiVault - owner is part of isAuthorized and can change the system out-of-band. controller does not implement means to call functions it has permissions to.  Multiple methods in FujiVault are decorated with the access control isAuthorized that grants the owner and the currently configured controller access. The controller, however, does not implement any means to call some of the methods on the Vault.  Furthermore, the owner is part of isAuthorized, too, and can switch out the debt-management token while one is already configured without any migration. This is likely to create an inconsistent state with the Vault, and no one will be able to withdraw their now non-existent token.  code/contracts/fantom/FujiVaultFTM.sol:L65-L74  /**  @dev Throws if caller is not the 'owner' or the '_controller' address stored in {FujiAdmin}  /  modifier isAuthorized() {  require(  msg.sender == owner() || msg.sender == _fujiAdmin.getController(),  Errors.VL_NOT_AUTHORIZED  );  _;  The owner can call methods  out of band,  bypassing steps the contract system would enforce otherwise, e.g. controller calling setActiveProvider.  It is assumed that setOracle, setFactor should probably be onlyOwner instead.  code/contracts/fantom/FujiVaultFTM.sol:L354-L367  function setFujiERC1155(address _fujiERC1155) external isAuthorized {  require(_fujiERC1155 != address(0), Errors.VL_ZERO_ADDR);  fujiERC1155 = _fujiERC1155;  vAssets.collateralID = IFujiERC1155(_fujiERC1155).addInitializeAsset(  IFujiERC1155.AssetType.collateralToken,  address(this)  );  vAssets.borrowID = IFujiERC1155(_fujiERC1155).addInitializeAsset(  IFujiERC1155.AssetType.debtToken,  address(this)  );  emit F1155Changed(_fujiERC1155);  Note ensure that setProviders can only ever be set by a trusted entity or multi-sig as the Vault delegatecalls the provider logic (via VaultControlUpgradeable) and, hence, the provider has total control over the Vault storage!  FliquidatorFTM - Unnecessary and confusing modifier FliquidatorFTM.isAuthorized  The contract is already Claimable; therefore, use the already existing modifier Claimable.onlyOwner instead.  code/contracts/fantom/FliquidatorFTM.sol:L86-L91  code/contracts/abstracts/claimable/Claimable.sol:L48-L51  /  modifier isAuthorized() {  require(msg.sender == owner(), Errors.VL_NOT_AUTHORIZED);  _;  code/contracts/abstracts/claimable/Claimable.sol:L48-L51  modifier onlyOwner() {  require(_msgSender() == owner(), \"Ownable: caller is not the owner\");  _;  Use Claimable.onlyOwner instead.  FlasherFTM - owner should not be able to call initiateFlashloan directly; misleading comment.  code/contracts/fantom/flashloans/FlasherFTM.sol:L42-L54  /**  @dev Throws if caller is not 'owner'.  /  modifier isAuthorized() {  require(  msg.sender == _fujiAdmin.getController() ||  msg.sender == _fujiAdmin.getFliquidator() ||  msg.sender == owner(),  Errors.VL_NOT_AUTHORIZED  );  _;  FujiERC1155 - All vaults have equal permission to mint/burn/initializeAssets for every vault  All vaults need to be in the onlyPermit ACL whitelist. No additional checks enforce that the calling vault can only modify its token balances. Furthermore, FujiVaultFTM is upgradeable; thus, the contract logic may be altered to allow the vault to modify any other token id s balance. To reduce this risk and the potential of an exploited contract affecting other token balances in the system, it is suggested to change the coarse onlyPermit ACL to one that checks that the calling vault can only manage their token IDs.  Recommendation  Reconsider the authentication concept and make it more transparent. Segregate duties and clearly define roles and capabilities. Avoid having overly powerful actors and reduce their capabilities to the bare minimum needed to segregate risk. If an actor is part of an ACL in a third-party contract, they also should have the means to call that method in a controlled way or else remove them from the ACL. To avoid conveying a false sense of trust towards certain actors within the smart contract system, it is suggested to use the centralized onlyOwner decorator for methods only the owner can call. This more accurately depicts  who can do what  in the system and makes it easier to trust the project team managing it.  Avoid excessively powerful owners that can change/mint/burn anything in the system as this is a risk for the general consistency.  Remove owner from methods/modifiers they don t need to be part of/have access to.  Ensure owner is a time-locked multi-sig or governance contract. Rename authentication modifiers to describe better what callers they allow.  ", "labels": ["Consensys", "Major"], "html_url": "https://consensys.io/diligence/audits/2022/03/fuji-protocol/"}, {"title": "4.4 Unchecked Return Values - ICErc20 repayBorrow ", "body": "  Description  ICErc20.repayBorrow returns a non-zero uint on error. Multiple providers do not check for this error condition and might return success even though repayBorrow failed, returning an error code.  This can potentially allow a malicious user to call paybackAndWithdraw() while not repaying by causing an error in the sub-call to Compound.repayBorrow(), which ends up being silently ignored. Due to the missing success condition check, execution continues normally with _internalWithdraw().  Also, see issue 4.5.  code/contracts/interfaces/compound/ICErc20.sol:L11-L12  function repayBorrow(uint256 repayAmount) external returns (uint256);  The method may return an error due to multiple reasons:  contracts/CToken.sol:L808-L816  function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint, uint) {  uint error = accrueInterest();  if (error != uint(Error.NO_ERROR)) {  // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed  return (fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED), 0);  // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to  return repayBorrowFresh(msg.sender, msg.sender, repayAmount);  contracts/CToken.sol:L855-L873  if (allowed != 0) {  return (failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed), 0);  /* Verify market's block number equals current block number */  if (accrualBlockNumber != getBlockNumber()) {  return (fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK), 0);  RepayBorrowLocalVars memory vars;  /* We remember the original borrowerIndex for verification purposes */  vars.borrowerIndex = accountBorrows[borrower].interestIndex;  /* We fetch the amount the borrower owes, with accumulated interest */  (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);  if (vars.mathErr != MathError.NO_ERROR) {  return (failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr)), 0);  Examples  Multiple providers, here are some examples:  code/contracts/fantom/providers/ProviderCream.sol:L168-L173  // Check there is enough balance to pay  require(erc20token.balanceOf(address(this)) >= _amount, \"Not-enough-token\");  erc20token.univApprove(address(cyTokenAddr), _amount);  cyToken.repayBorrow(_amount);  code/contracts/fantom/providers/ProviderScream.sol:L170-L172  require(erc20token.balanceOf(address(this)) >= _amount, \"Not-enough-token\");  erc20token.univApprove(address(cyTokenAddr), _amount);  cyToken.repayBorrow(_amount);  code/contracts/mainnet/providers/ProviderCompound.sol:L139-L155  if (_isETH(_asset)) {  // Create a reference to the corresponding cToken contract  ICEth cToken = ICEth(cTokenAddr);  cToken.repayBorrow{ value: msg.value }();  } else {  // Create reference to the ERC20 contract  IERC20 erc20token = IERC20(_asset);  // Create a reference to the corresponding cToken contract  ICErc20 cToken = ICErc20(cTokenAddr);  // Check there is enough balance to pay  require(erc20token.balanceOf(address(this)) >= _amount, \"Not-enough-token\");  erc20token.univApprove(address(cTokenAddr), _amount);  cToken.repayBorrow(_amount);  Recommendation  Check for cyToken.repayBorrow(_amount) != 0 or Error.NO_ERROR.  ", "labels": ["Consensys", "Major"], "html_url": "https://consensys.io/diligence/audits/2022/03/fuji-protocol/"}, {"title": "4.5 Unchecked Return Values - IComptroller exitMarket, enterMarket ", "body": "  Description  IComptroller.exitMarket(), IComptroller.enterMarkets() may return a non-zero uint on error but none of the Providers check for this error condition. Together with issue 4.10, this might suggest that unchecked return values may be a systemic problem.  Here s the upstream implementation:  contracts/Comptroller.sol:L179-L187  if (amountOwed != 0) {  return fail(Error.NONZERO_BORROW_BALANCE, FailureInfo.EXIT_MARKET_BALANCE_OWED);  /* Fail if the sender is not permitted to redeem all of their tokens */  uint allowed = redeemAllowedInternal(cTokenAddress, msg.sender, tokensHeld);  if (allowed != 0) {  return failOpaque(Error.REJECTION, FailureInfo.EXIT_MARKET_REJECTION, allowed);  /**  @notice Removes asset from sender's account liquidity calculation  @dev Sender must not have an outstanding borrow balance in the asset,  or be providing necessary collateral for an outstanding borrow.  @param cTokenAddress The address of the asset to be removed  @return Whether or not the account successfully exited the market  /  function exitMarket(address cTokenAddress) external returns (uint) {  CToken cToken = CToken(cTokenAddress);  /* Get sender tokensHeld and amountOwed underlying from the cToken */  (uint oErr, uint tokensHeld, uint amountOwed, ) = cToken.getAccountSnapshot(msg.sender);  require(oErr == 0, \"exitMarket: getAccountSnapshot failed\"); // semi-opaque error code  /* Fail if the sender has a borrow balance */  if (amountOwed != 0) {  return fail(Error.NONZERO_BORROW_BALANCE, FailureInfo.EXIT_MARKET_BALANCE_OWED);  /* Fail if the sender is not permitted to redeem all of their tokens */  uint allowed = redeemAllowedInternal(cTokenAddress, msg.sender, tokensHeld);  if (allowed != 0) {  return failOpaque(Error.REJECTION, FailureInfo.EXIT_MARKET_REJECTION, allowed);  Examples  Unchecked return value exitMarket  All Providers exhibit the same issue, probably due to code reuse. (also see https://github.com/ConsenSysDiligence/fuji-protocol-audit-2022-02/issues/19). Some examples:  code/contracts/fantom/providers/ProviderCream.sol:L52-L57  function _exitCollatMarket(address _cyTokenAddress) internal {  // Create a reference to the corresponding network Comptroller  IComptroller comptroller = IComptroller(_getComptrollerAddress());  comptroller.exitMarket(_cyTokenAddress);  code/contracts/fantom/providers/ProviderScream.sol:L52-L57  function _exitCollatMarket(address _cyTokenAddress) internal {  // Create a reference to the corresponding network Comptroller  IComptroller comptroller = IComptroller(_getComptrollerAddress());  comptroller.exitMarket(_cyTokenAddress);  code/contracts/mainnet/providers/ProviderCompound.sol:L46-L51  function _exitCollatMarket(address _cTokenAddress) internal {  // Create a reference to the corresponding network Comptroller  IComptroller comptroller = IComptroller(_getComptrollerAddress());  comptroller.exitMarket(_cTokenAddress);  code/contracts/mainnet/providers/ProviderIronBank.sol:L52-L57  function _exitCollatMarket(address _cyTokenAddress) internal {  // Create a reference to the corresponding network Comptroller  IComptroller comptroller = IComptroller(_getComptrollerAddress());  comptroller.exitMarket(_cyTokenAddress);  Unchecked return value enterMarkets (Note that IComptroller returns NO_ERROR when already joined to enterMarkets.  All Providers exhibit the same issue, probably due to code reuse. (also see https://github.com/ConsenSysDiligence/fuji-protocol-audit-2022-02/issues/19). For example:  code/contracts/fantom/providers/ProviderCream.sol:L39-L46  function _enterCollatMarket(address _cyTokenAddress) internal {  // Create a reference to the corresponding network Comptroller  IComptroller comptroller = IComptroller(_getComptrollerAddress());  address[] memory cyTokenMarkets = new address[](1);  cyTokenMarkets[0] = _cyTokenAddress;  comptroller.enterMarkets(cyTokenMarkets);  Recommendation  Require that return value is ERROR.NO_ERROR or 0.  ", "labels": ["Consensys", "Major"], "html_url": "https://consensys.io/diligence/audits/2022/03/fuji-protocol/"}, {"title": "4.6 Fliquidator - excess funds of native tokens are not returned ", "body": "  Description  Examples  code/contracts/fantom/FliquidatorFTM.sol:L148-L150  if (vAssets.borrowAsset == FTM) {  require(msg.value >= debtTotal, Errors.VL_AMOUNT_ERROR);  } else {  Recommendation  Consider returning excess funds. Consider making _constructParams public to allow the caller to pre-calculate the debtTotal that needs to be provided with the call.  Consider removing support for native token FTM entirely to reduce the overall code complexity. The wrapped equivalent can be used instead.  ", "labels": ["Consensys", "Medium"], "html_url": "https://consensys.io/diligence/audits/2022/03/fuji-protocol/"}, {"title": "4.7 Unsafe arithmetic casts ", "body": "  Description  The reason for using signed integers in some situations appears to be to use negative values as an indicator to withdraw everything. Using a whole bit of uint256 for this is quite a lot when using type(uint256).max would equal or better serve as a flag to withdraw everything.  Furthermore, even though the code uses solidity 0.8.x, which safeguards arithmetic operations against under/overflows, arithmetic typecast is not protected.  Also, see issue 4.9 for a related issue.  \u21d2  solidity-shell  \ud83d\ude80 Entering interactive Solidity ^0.8.11 shell. '.help' and '.exit' are your friends.  \u00bb  \u2139\ufe0f  ganache-mgr: starting temp. ganache instance ...  \u00bb  uint(int(-100))  115792089237316195423570985008687907853269984665640564039457584007913129639836  \u00bb  int256(uint(2**256-100))  100  Examples  code/contracts/fantom/FliquidatorFTM.sol:L167-L178  // Compute how much collateral needs to be swapt  uint256 collateralInPlay = _getCollateralInPlay(  vAssets.collateralAsset,  vAssets.borrowAsset,  debtTotal + bonus  );  // Burn f1155  _burnMulti(addrs, borrowBals, vAssets, _vault, f1155);  // Withdraw collateral  IVault(_vault).withdrawLiq(int256(collateralInPlay));  code/contracts/fantom/FliquidatorFTM.sol:L264-L276  // Compute how much collateral needs to be swapt for all liquidated users  uint256 collateralInPlay = _getCollateralInPlay(  vAssets.collateralAsset,  vAssets.borrowAsset,  _amount + _flashloanFee + bonus  );  // Burn f1155  _burnMulti(_addrs, _borrowBals, vAssets, _vault, f1155);  // Withdraw collateral  IVault(_vault).withdrawLiq(int256(collateralInPlay));  code/contracts/fantom/FliquidatorFTM.sol:L334-L334  uint256 amount = _amount < 0 ? debtTotal : uint256(_amount);  code/contracts/fantom/FujiVaultFTM.sol:L213-L220  function withdrawLiq(int256 _withdrawAmount) external override nonReentrant onlyFliquidator {  // Logic used when called by Fliquidator  _withdraw(uint256(_withdrawAmount), address(activeProvider));  IERC20Upgradeable(vAssets.collateralAsset).univTransfer(  payable(msg.sender),  uint256(_withdrawAmount)  );  pot. unsafe truncation (unlikely)  code/contracts/FujiERC1155.sol:L53-L59  function updateState(uint256 _assetID, uint256 newBalance) external override onlyPermit {  uint256 total = totalSupply(_assetID);  if (newBalance > 0 && total > 0 && newBalance > total) {  uint256 newIndex = (indexes[_assetID] * newBalance) / total;  indexes[_assetID] = uint128(newIndex);  Recommendation  If negative values are only used as a flag to indicate that all funds should be used for an operation, use type(uint256).max instead. It is wasting less value-space for a simple flag than using the uint256 high-bit range. Avoid typecast where possible. Use SafeCast instead or verify that the casts are safe because the values they operate on cannot under- or overflow. Add inline code comments if that s the case.  ", "labels": ["Consensys", "Medium"], "html_url": "https://consensys.io/diligence/audits/2022/03/fuji-protocol/"}, {"title": "4.8 Missing input validation on flash close fee factors ", "body": "  Description  The FliquidatorFTM contract allows authorized parties to set the flash close fee factor. The factor is provided as two integers denoting numerator and denominator. Due to a lack of boundary checks, it is possible to set unrealistically high factors, which go well above 1. This can have unexpected effects on internal accounting and the impact of flashloan balances.  Examples  code/contracts/fantom/FliquidatorFTM.sol:L657-L659  function setFlashCloseFee(uint64 _newFactorA, uint64 _newFactorB) external isAuthorized {  flashCloseF.a = _newFactorA;  flashCloseF.b = _newFactorB;  Recommendation  Add a requirement making sure that flashCloseF.a <= flashCloseF.b.  ", "labels": ["Consensys", "Medium"], "html_url": "https://consensys.io/diligence/audits/2022/03/fuji-protocol/"}, {"title": "4.9 Separation of concerns and consistency in vaults ", "body": "  Description  The FujiVaultFTM contract contains multiple balance-changing functions. Most notably, withdraw is passed an int256 denoted amount parameter. Negative values of this parameter are given to the _internalWithdraw function, where they trigger the withdrawal of all collateral. This approach can result in accounting mistakes in the future as beyond a certain point in the vault s accounting; amounts are expected to be only positive. Furthermore, the concerns of withdrawing and entirely withdrawing are not separated.  The above issue applies analogously to the payback function and its dependency on _internalPayback.  For consistency, withdrawLiq also takes an int256 amount parameter. This function is only accessible to the Fliquidator contract and withdraws collateral from the active provider. However, all occurrences of the _withdrawAmount parameter are cast to uint256.  Examples  The withdraw entry point:  code/contracts/fantom/FujiVaultFTM.sol:L201-L204  function withdraw(int256 _withdrawAmount) public override nonReentrant {  updateF1155Balances();  _internalWithdraw(_withdrawAmount);  _internalWithdraw s negative amount check:  code/contracts/fantom/FujiVaultFTM.sol:L654-L657  uint256 amountToWithdraw = _withdrawAmount < 0  ? providedCollateral - neededCollateral  : uint256(_withdrawAmount);  The withdrawLiq entry point for the Fliquidator:  code/contracts/fantom/FujiVaultFTM.sol:L213-L220  function withdrawLiq(int256 _withdrawAmount) external override nonReentrant onlyFliquidator {  // Logic used when called by Fliquidator  _withdraw(uint256(_withdrawAmount), address(activeProvider));  IERC20Upgradeable(vAssets.collateralAsset).univTransfer(  payable(msg.sender),  uint256(_withdrawAmount)  );  Recommendation  Similarly, withdrawLiq s parameter should be a uint256 to prevent unnecessary casts.  ", "labels": ["Consensys", "Medium"], "html_url": "https://consensys.io/diligence/audits/2022/03/fuji-protocol/"}, {"title": "4.10 Aave/Geist Interface declaration mismatch and unchecked return values ", "body": "  Description  The two lending providers, Geist & Aave, do not seem to be directly affiliated even though one is a fork of the other. However, the interfaces may likely diverge in the future. Using the same interface declaration for both protocols might become problematic with future upgrades to either protocol. The interface declaration does not seem to come from the original upstream project. The interface IAaveLendingPool does not declare any return values while some of the functions called in Geist or Aave return them.  Note: that we have not verified all interfaces for correctness. However, we urge the client to only use official interface declarations from the upstream projects and verify that all other interfaces match.  Examples  The ILendingPool configured in ProviderAave (0xB53C1a33016B2DC2fF3653530bfF1848a515c8c5 -> implementation: 0xc6845a5c768bf8d7681249f8927877efda425baf)  code/contracts/mainnet/providers/ProviderAave.sol:L19-L21  function _getAaveProvider() internal pure returns (IAaveLendingPoolProvider) {  return IAaveLendingPoolProvider(0xB53C1a33016B2DC2fF3653530bfF1848a515c8c5);  The IAaveLendingPool does not declare return values for any function, while upstream does.  code/contracts/interfaces/aave/IAaveLendingPool.sol:L1-L46  // SPDX-License-Identifier: MIT  pragma solidity ^0.8.0;  interface IAaveLendingPool {  function flashLoan(  address receiverAddress,  address[] calldata assets,  uint256[] calldata amounts,  uint256[] calldata modes,  address onBehalfOf,  bytes calldata params,  uint16 referralCode  ) external;  function deposit(  address _asset,  uint256 _amount,  address _onBehalfOf,  uint16 _referralCode  ) external;  function withdraw(  address _asset,  uint256 _amount,  address _to  ) external;  function borrow(  address _asset,  uint256 _amount,  uint256 _interestRateMode,  uint16 _referralCode,  address _onBehalfOf  ) external;  function repay(  address _asset,  uint256 _amount,  uint256 _rateMode,  address _onBehalfOf  ) external;  function setUserUseReserveAsCollateral(address _asset, bool _useAsCollateral) external;  Methods: withdraw(), repay() return uint256 in the original implementation for Aave, see:  https://etherscan.io/address/0xc6845a5c768bf8d7681249f8927877efda425baf#code  The ILendingPool configured for Geist:  Methods withdraw(), repay() return uint256 in the original implementation for Geist, see:  https://ftmscan.com/address/0x3104ad2aadb6fe9df166948a5e3a547004862f90#code  Note: that the actual amount withdrawn does not necessarily need to match the amount provided with the function argument. Here s an excerpt of the upstream LendingProvider.withdraw():  ...  if (amount == type(uint256).max) {  amountToWithdraw = userBalance;  ...  return amountToWithdraw;  And here s the code in Fuji that calls that method. This will break the withdrawAll functionality of LendingProvider if token isFTM.  code/contracts/fantom/providers/ProviderGeist.sol:L151-L165  function withdraw(address _asset, uint256 _amount) external payable override {  IAaveLendingPool aave = IAaveLendingPool(_getAaveProvider().getLendingPool());  bool isFtm = _asset == _getFtmAddr();  address _tokenAddr = isFtm ? _getWftmAddr() : _asset;  aave.withdraw(_tokenAddr, _amount, address(this));  // convert WFTM to FTM  if (isFtm)  {  address unwrapper = _getUnwrapper();  IERC20(_tokenAddr).univTransfer(payable(unwrapper), _amount);  IUnwrapper(unwrapper).withdraw(_amount);  Similar for repay(), which returns the actual amount repaid.  Recommendation  Always use the original interface unless only a minimal subset of functions is used.  Use the original upstream interfaces of the corresponding project (link via the respective npm packages if available).  Avoid omitting parts of the function declaration! Especially when it comes to return values.  Check return values. Use the value returned from withdraw() AND repay()  ", "labels": ["Consensys", "Medium"], "html_url": "https://consensys.io/diligence/audits/2022/03/fuji-protocol/"}, {"title": "4.11 Missing slippage protection for rewards swap ", "body": "  Description  In FujiVaultFTM.harvestRewards a swap transaction is generated using a call to SwapperFTM.getSwapTransaction. In all relevant scenarios, this call uses a minimum output amount of zero, which de-facto deactivates slippage checks. Most values from harvesting rewards can thus be siphoned off by sandwiching such calls.  Examples  amountOutMin is 0, effectively disabling slippage control in the swap method.  code/contracts/fantom/SwapperFTM.sol:L49-L55  transaction.data = abi.encodeWithSelector(  IUniswapV2Router01.swapExactETHForTokens.selector,  0,  path,  msg.sender,  type(uint256).max  );  Only success required  code/contracts/fantom/FujiVaultFTM.sol:L565-L567  // Swap rewards -> collateralAsset  (success, ) = swapTransaction.to.call{ value: swapTransaction.value }(swapTransaction.data);  require(success, \"failed to swap rewards\");  Recommendation  Use a slippage check such as for liquidator swaps:  code/contracts/fantom/FliquidatorFTM.sol:L476-L479  require(  (priceDelta * SLIPPAGE_LIMIT_DENOMINATOR) / priceFromOracle < SLIPPAGE_LIMIT_NUMERATOR,  Errors.VL_SWAP_SLIPPAGE_LIMIT_EXCEED  );  Or specify a non-zero amountOutMin argument in calls to IUniswapV2Router01.swapExactETHForTokens.  ", "labels": ["Consensys", "Medium"], "html_url": "https://consensys.io/diligence/audits/2022/03/fuji-protocol/"}, {"title": "4.12 Unpredictable behavior due to admin front running or general bad timing ", "body": "  Description  In several cases, the owner of deployed contracts can update or upgrade things in the system without warning. This has the potential to violate a security goal of the system.  Specifically, contract owners (a 2/3 EOA Gnosis Multisig) could use front running to make malicious changes just ahead of incoming transactions, or purely accidental adverse effects could occur due to unfortunate timing of changes.  Some instances of this are more important than others, but in general, users of the system should have assurances about the behavior of the action they re about to take.  Examples  FujiAdmin  The owner of FujiAdmin is 0x0e1484c9a9f9b31ff19300f082e843415a575f4f and this address is a proxy to a Gnosis Safe: Mastercopy 1.2.0 implementation, requiring 2/3 signatures to execute transactions. All three signees are EOA s.  code/artifacts/1-core.deploy:L958-L960  \"FujiAdmin\": {  \"address\": \"0x4cB46032e2790D8CA10be6d0001e8c6362a76adA\",  \"abi\": [  Controller, FujiOracle  The owner of controller seems to be a single EOA:  https://etherscan.io/address/0x3f366802F4e7576FC5DAA82890Cc6e04c85f3736#readContract  The owner of FujiOracle seems to be a single EOA:  https://etherscan.io/address/0xadF849079d415157CbBdb21BB7542b47077734A8#readContract  The owner of FujiERC1155 seems to be a single EOA:  https://etherscan.io/address/0xa2d62f8b02225fbFA1cf8bF206C8106bDF4c692b#readProxyContract  FujiAdmin (fantom)  Deployer is 0xb98d4D4e205afF4d4755E9Df19BD0B8BD4e0f148 which is an EOA.  code/artifacts/250-core.deploy:L1-L5  \"FujiAdmin\": {  \"address\": \"0xaAb2AAfBFf7419Ff85181d3A846bA9045803dd67\",  \"deployer\": \"0xb98d4D4e205afF4d4755E9Df19BD0B8BD4e0f148\",  \"abi\": [  FujiAdmin.owner is 0x40578f7902304e0e34d7069fb487ee57f841342e which is a GnosisSafeProxy  Recommendation  The underlying issue is that users of the system can t be sure what the behavior of a function call will be, and this is because the behavior can change at any time.  We recommend giving the user advance notice of changes with a time lock. For example, all onlyOwner functionality requires two steps with a mandatory time window between them. The first step merely tells users that a particular change is coming, and the second step commits that change after a reasonable waiting period.  ", "labels": ["Consensys", "Medium"], "html_url": "https://consensys.io/diligence/audits/2022/03/fuji-protocol/"}, {"title": "4.13 FujiOracle - _getUSDPrice does not detect stale oracle prices; General Oracle Risks ", "body": "  Description  The external Chainlink oracle, which provides index price information to the system, introduces risk inherent to any dependency on third-party data sources. For example, the oracle could fall behind or otherwise fail to be maintained, resulting in outdated data being fed to the index price calculations. Oracle reliance has historically resulted in crippled on-chain systems, and complications that lead to these outcomes can arise from things as simple as network congestion.  This is more extreme in lesser-known tokens with fewer ChainLink Price feeds to update the price frequently.  Ensuring that unexpected oracle return values are correctly handled will reduce reliance on off-chain components and increase the resiliency of the smart contract system that depends on them.  The codebase, as is, relies on chainLinkOracle.latestRoundData() and does not check the timestamp or answeredIn round of the returned price.  Examples  Here s how the oracle is consumed, skipping any fields that would allow checking for stale data:  code/contracts/FujiOracle.sol:L66-L77  /**  @dev Calculates the USD price of asset.  @param _asset: the asset address.  Returns the USD price of the given asset  /  function _getUSDPrice(address _asset) internal view returns (uint256 price) {  require(usdPriceFeeds[_asset] != address(0), Errors.ORACLE_NONE_PRICE_FEED);  (, int256 latestPrice, , , ) = AggregatorV3Interface(usdPriceFeeds[_asset]).latestRoundData();  price = uint256(latestPrice);  Here s the implementation of the v0.6 FluxAggregator Chainlink feed with a note that timestamps should be checked.  contracts/src/v0.6/FluxAggregator.sol:L489-L490  Recommendation  @return updatedAt is the timestamp when the round last was updated (i.e.  answer was last computed)  Recommendation  Perform sanity checks on the price returned by the oracle. If the price is older, not within configured limits, revert or handle in other means.  The oracle does not provide any means to remove a potentially broken price-feed (e.g., by updating its address to address(0) or by pausing specific feeds or the complete oracle). The only way to pause an oracle right now is to deploy a new oracle contract. Therefore, consider adding minimally invasive functionality to pause the price-feeds if the oracle becomes unreliable.  Monitor the oracle data off-chain and intervene if it becomes unreliable.  On-chain, realistically, both answeredInRound and updatedAt must be checked within acceptable bounds.  answeredInRound == latestRound - in this case, data may be assumed to be fresh while it might not be because the feed was entirely abandoned by nodes (no one starting a new round). Also, there s a good chance that many feeds won t always be super up-to-date (it might be acceptable to allow a threshold). A strict check might lead to transactions failing (race; e.g., round just timed out).  roundId + threshold >= answeredInRound - would allow a deviation of threshold rounds. This check alone might still result in stale data to be used if there are no more rounds. Therefore, this should be combined with updatedAt + threshold >= block.timestamp.  ", "labels": ["Consensys", "Medium"], "html_url": "https://consensys.io/diligence/audits/2022/03/fuji-protocol/"}, {"title": "4.14 Unclaimed or front-runnable proxy implementations ", "body": "  Description  Various smart contracts in the system require initialization functions to be called. The point when these calls happen is up to the deploying address. Deployment and initialization in one transaction are typically safe, but it can potentially be front-run if the initialization is done in a separate transaction.  A frontrunner can call these functions to silently take over the contracts and provide malicious parameters or plant a backdoor during the deployment.  Leaving proxy implementations uninitialized further aides potential phishing attacks where users might claim that - just because a contract address is listed in the official documentation/code-repo - a contract is a legitimate component of the system. At the same time, it is  only  a proxy implementation that an attacker claimed. For the end-user, it might be hard to distinguish whether this contract is part of the system or was a maliciously appropriated implementation.  Examples  code/contracts/mainnet/FujiVault.sol:L97-L102  function initialize(  address _fujiadmin,  address _oracle,  address _collateralAsset,  address _borrowAsset  ) external initializer {  FujiVault was initialized many days after deployment, and FujiVault inherits VaultBaseUpgradeable, which exposes a delegatecall that can be used to selfdestruct the contract s implementation.  Another FujiVault was deployed by deployer initialized in a 2-step approach that can theoretically silently be front-run.  code/artifacts/250-core.deploy:L2079-L2079  \"deployer\": \"0xb98d4D4e205afF4d4755E9Df19BD0B8BD4e0f148\",  Transactions of deployer:  https://ftmscan.com/txs?a=0xb98d4D4e205afF4d4755E9Df19BD0B8BD4e0f148&p=2  The specific contract was initialized 19 blocks after deployment.  https://ftmscan.com/address/0x8513c2db99df213887f63300b23c6dd31f1d14b0  FujiAdminFTM (and others) don t seem to be initialized. (low prior; no risk other than pot. reputational damage)  code/artifacts/250-core.deploy:L1-L7  \"FujiAdmin\": {  \"address\": \"0xaAb2AAfBFf7419Ff85181d3A846bA9045803dd67\",  \"deployer\": \"0xb98d4D4e205afF4d4755E9Df19BD0B8BD4e0f148\",  \"abi\": [  \"anonymous\": false,  Recommendation  It is recommended to use constructors wherever possible to immediately initialize proxy implementations during deploy-time. The code is only run when the implementation is deployed and affects the proxy initializations. If other initialization functions are used, we recommend enforcing deployer access restrictions or a standardized, top-level initialized boolean, set to true on the first deployment and used to prevent future initialization.  Using constructors and locked-down initialization functions will significantly reduce potential developer errors and the possibility of attackers re-initializing vital system components.  ", "labels": ["Consensys", "Medium"], "html_url": "https://consensys.io/diligence/audits/2022/03/fuji-protocol/"}, {"title": "4.15 Unused Import ", "body": "  Description  The following dependency is imported but never used:  code/contracts/mainnet/flashloans/Flasher.sol:L13-L13  import \"../../interfaces/IFujiMappings.sol\";  Recommendation  Remove the unused import.  ", "labels": ["Consensys", "Minor"], "html_url": "https://consensys.io/diligence/audits/2022/03/fuji-protocol/"}, {"title": "4.16 WFTM - Use of incorrect interface declarations ", "body": "  Description  WETH and  WFTM implementations are different.  code/contracts/fantom/WFTMUnwrapper.sol:L7-L23  contract WFTMUnwrapper {  address constant wftm = 0x21be370D5312f44cB42ce377BC9b8a0cEF1A4C83;  receive() external payable {}  /**  @notice Convert WFTM to FTM and transfer to msg.sender  @dev msg.sender needs to send WFTM before calling this withdraw  @param _amount amount to withdraw.  /  function withdraw(uint256 _amount) external {  IWETH(wftm).withdraw(_amount);  (bool sent, ) = msg.sender.call{ value: _amount }(\"\");  require(sent, \"Failed to send FTM\");  code/contracts/fantom/providers/ProviderGeist.sol:L115-L116  // convert FTM to WFTM  if (isFtm) IWETH(_tokenAddr).deposit{ value: _amount }();  Also see issues: issue 4.4, issue 4.5, issue 4.10  Recommendation  We recommend using the correct interfaces for all contracts instead of partial stubs. Do not modify the original function declarations, e.g., by omitting return value declarations. The codebase should also check return values where possible or explicitly state why values can safely be ignored in inline comments or the function s natspec documentation block.  ", "labels": ["Consensys", "Minor"], "html_url": "https://consensys.io/diligence/audits/2022/03/fuji-protocol/"}, {"title": "4.17 Inconsistent isFTM, isETH checks ", "body": "  Description  LibUniversalERC20FTM.isFTM() and LibUniversalERC20.isETH() identifies native assets by matching against two distinct addresses while some components only check for one.  Examples  The same is true for FTM.  Flasher only identifies a native asset transfer by matching asset against _ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE while univTransfer() identifies it using 0x0 || 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE  code/contracts/mainnet/flashloans/Flasher.sol:L122-L141  function callFunction(  address sender,  Account.Info calldata account,  bytes calldata data  ) external override {  require(msg.sender == _dydxSoloMargin && sender == address(this), Errors.VL_NOT_AUTHORIZED);  account;  FlashLoan.Info memory info = abi.decode(data, (FlashLoan.Info));  uint256 _value;  if (info.asset == _ETH) {  // Convert WETH to ETH and assign amount to be set as msg.value  _convertWethToEth(info.amount);  _value = info.amount;  } else {  // Transfer to Vault the flashloan Amount  // _value is 0  IERC20(info.asset).univTransfer(payable(info.vault), info.amount);  LibUniversalERC20  code/contracts/mainnet/libraries/LibUniversalERC20.sol:L8-L16  library LibUniversalERC20 {  using SafeERC20 for IERC20;  IERC20 private constant _ETH_ADDRESS = IERC20(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);  IERC20 private constant _ZERO_ADDRESS = IERC20(0x0000000000000000000000000000000000000000);  function isETH(IERC20 token) internal pure returns (bool) {  return (token == _ZERO_ADDRESS || token == _ETH_ADDRESS);  code/contracts/mainnet/libraries/LibUniversalERC20.sol:L26-L40  function univTransfer(  IERC20 token,  address payable to,  uint256 amount  ) internal {  if (amount > 0) {  if (isETH(token)) {  (bool sent, ) = to.call{ value: amount }(\"\");  require(sent, \"Failed to send Ether\");  } else {  token.safeTransfer(to, amount);  There are multiple other instances of this  code/contracts/mainnet/Fliquidator.sol:L162-L162  uint256 _value = vAssets.borrowAsset == ETH ? debtTotal : 0;  Recommendation  Consider using a consistent way to identify native asset transfers (i.e. ETH, FTM) by using LibUniversalERC20.isETH(). Alternatively, the system can be greatly simplified by expecting WFTM and only working with it. This simplification will remove all special cases where the library must handle non-ERC20 interfaces.  ", "labels": ["Consensys", "Minor"], "html_url": "https://consensys.io/diligence/audits/2022/03/fuji-protocol/"}, {"title": "4.18 FujiOracle - setPriceFeed should check asset and priceFeed decimals ", "body": "  Description  getPriceOf() assumes that all price feeds return prices with identical decimals, but setPriceFeed does not enforce this. Potential misconfigurations can have severe effects on the system s internal accounting.  Examples  code/contracts/FujiOracle.sol:L27-L36  /**  @dev Sets '_priceFeed' address for a '_asset'.  Can only be called by the contract owner.  Emits a {AssetPriceFeedChanged} event.  /  function setPriceFeed(address _asset, address _priceFeed) public onlyOwner {  require(_priceFeed != address(0), Errors.VL_ZERO_ADDR);  usdPriceFeeds[_asset] = _priceFeed;  emit AssetPriceFeedChanged(_asset, _priceFeed);  Recommendation  We recommend adding additional checks to detect unexpected changes in assets  properties. Safeguard price feeds by enforcing priceFeed == address(0) || priceFeed.decimals() == 8. This allows the owner to disable a priceFeed (setting it to zero) and otherwise ensure that the feed is compatible and indeed returns 8 decimals.  ", "labels": ["Consensys", "Minor"], "html_url": "https://consensys.io/diligence/audits/2022/03/fuji-protocol/"}, {"title": "4.19 Unchecked function return values for low-level calls", "body": "  Description  It should be noted that the swapping and harvesting transactions sometimes return values to the function caller. While the low-level call is checked for  success , the return values are not actively handled. This can be intentional but should be verified.  Before calling the external contract, there is no check whether a contract is deployed at that address. Since destinations seem to be hardcoded in the Swapper/Harvester modules, we assume this has been ensured before deploying the contract. However, we suggest checking that code is deployed at the destination address, especially for upgradeable contracts.  We raise this as an informational finding as both the Harvester and Swapper flows using token.balanceOf(this), which might make this check obsolete. However, potential future third-party Swapper/Harvester additions to the protocol might return error codes that need to be checked for.  Examples  Geist/Uniswap and WFTM methods may return amounts or error codes  code/contracts/fantom/FujiVaultFTM.sol:L549-L551  // Claim rewards  (bool success, ) = harvestTransaction.to.call(harvestTransaction.data);  require(success, \"failed to harvest rewards\");  code/contracts/fantom/FujiVaultFTM.sol:L565-L567  // Swap rewards -> collateralAsset  (success, ) = swapTransaction.to.call{ value: swapTransaction.value }(swapTransaction.data);  require(success, \"failed to swap rewards\");  ", "labels": ["Consensys"], "html_url": "https://consensys.io/diligence/audits/2022/03/fuji-protocol/"}, {"title": "4.20 Use the compiler to resolve function selectors for interfaces", "body": "  Description  Function signatures of known contract and interface types are available to the compiler. We recommend using abi.encodeWithSelector(IProvider.withdraw.selector, ...) instead of the more error prone abi.encodeWithSignature(\"withdraw(address,uint256)\", ...) equivalent. Using the former method avoids hard-to-detect errors stemming from typos, interface changes, etc.  Examples  code/contracts/abstracts/vault/VaultBaseUpgradeable.sol:L57-L84  /**  @dev Executes withdraw operation with delegatecall.  @param _amount: amount to be withdrawn  @param _provider: address of provider to be used  /  function _withdraw(uint256 _amount, address _provider) internal {  bytes memory data = abi.encodeWithSignature(  \"withdraw(address,uint256)\",  vAssets.collateralAsset,  _amount  );  _execute(_provider, data);  /**  @dev Executes borrow operation with delegatecall.  @param _amount: amount to be borrowed  @param _provider: address of provider to be used  /  function _borrow(uint256 _amount, address _provider) internal {  bytes memory data = abi.encodeWithSignature(  \"borrow(address,uint256)\",  vAssets.borrowAsset,  _amount  );  _execute(_provider, data);  ", "labels": ["Consensys"], "html_url": "https://consensys.io/diligence/audits/2022/03/fuji-protocol/"}, {"title": "4.21 Reduce code complexity", "body": "  Description  Throughout the codebase, snippets of code and whole functions have been copy-pasted. This duplication significantly increases code complexity and the potential for bugs. We recommend re-using code across modules or providing library contracts that implement re-usable code fragments.  Examples  Providers should use LibUniversalERC20FTM.isFTM instead of re-implementing Helper.isFTM.  code/contracts/fantom/providers/ProviderCream.sol:L17-L19  function _isFTM(address token) internal pure returns (bool) {  return (token == address(0) || token == address(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF));  code/contracts/fantom/providers/ProviderScream.sol:L17-L19  function _isFTM(address token) internal pure returns (bool) {  return (token == address(0) || token == address(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF));  ProviderGeist should provide an internal method instead of implementing multiple variants of the isFtm to token address mapping. E.g., both calls do the same thing. They select a different return value from the external call. Avoid re-implementing an inconsistent isFtm variant. Require that isFtm && amount != 0 on deposit/payback.  code/contracts/fantom/providers/ProviderGeist.sol:L57-L67  function getBorrowBalance(address _asset) external view override returns (uint256) {  IAaveDataProvider aaveData = _getAaveDataProvider();  bool isFtm = _asset == _getFtmAddr();  address _tokenAddr = isFtm ? _getWftmAddr() : _asset;  (, , uint256 variableDebt, , , , , , ) = aaveData.getUserReserveData(_tokenAddr, msg.sender);  return variableDebt;  code/contracts/fantom/providers/ProviderGeist.sol:L43-L52  function getBorrowRateFor(address _asset) external view override returns (uint256) {  IAaveDataProvider aaveData = _getAaveDataProvider();  (, , , , uint256 variableBorrowRate, , , , , ) = IAaveDataProvider(aaveData).getReserveData(  _asset == _getFtmAddr() ? _getWftmAddr() : _asset  );  return variableBorrowRate;  Also, note the unnecessary double cast IAaveDataProvider.  code/contracts/fantom/providers/ProviderGeist.sol:L73-L87  function getBorrowBalanceOf(address _asset, address _who)  external  view  override  returns (uint256)  IAaveDataProvider aaveData = _getAaveDataProvider();  bool isFtm = _asset == _getFtmAddr();  address _tokenAddr = isFtm ? _getWftmAddr() : _asset;  (, , uint256 variableDebt, , , , , , ) = aaveData.getUserReserveData(_tokenAddr, _who);  return variableDebt;  Consider removing support for the native currency altogether in favor of only accepting pre-wrapped WFTM (WETH). This should remove a lot of glue code currently implemented to auto-wrap/unwrap native currency.  Unused functionality  code/contracts/fantom/providers/ProviderCream.sol:L52-L57  function _exitCollatMarket(address _cyTokenAddress) internal {  // Create a reference to the corresponding network Comptroller  IComptroller comptroller = IComptroller(_getComptrollerAddress());  comptroller.exitMarket(_cyTokenAddress);  ", "labels": ["Consensys"], "html_url": "https://consensys.io/diligence/audits/2022/03/fuji-protocol/"}, {"title": "4.22 Unusable state variable in dYdX provider", "body": "  Description  Remove the state variable donothing . Providers are always called via staticcall or delegatecall and should not hold any state.  code/contracts/mainnet/providers/ProviderDYDX.sol:L93-L95  bool public donothing = true;  ", "labels": ["Consensys"], "html_url": "https://consensys.io/diligence/audits/2022/03/fuji-protocol/"}, {"title": "4.23 Use enums instead of hardcoded integer literals", "body": "  Description  Hardcoded integers are used throughout the codebase to denote states and distinguish between states. The code s complexity can be significantly reduced by using descriptive enum values.  Examples  2 should be InterestRateMode.VARIABLE  code/contracts/fantom/providers/ProviderGeist.sol:L184-L184  aave.repay(_tokenAddr, _amount, 2, address(this));  code/contracts/fantom/providers/ProviderGeist.sol:L136-L136  aave.borrow(_tokenAddr, _amount, 2, 0, address(this));  _farmProtocolNum and harvestType should be refactored to their enum equivalents:  code/contracts/mainnet/Harvester.sol:L20-L32  if (_farmProtocolNum == 0) {  transaction.to = 0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B;  transaction.data = abi.encodeWithSelector(  bytes4(keccak256(\"claimComp(address)\")),  msg.sender  );  claimedToken = 0xc00e94Cb662C3520282E6f5717214004A7f26888;  } else if (_farmProtocolNum == 1) {  uint256 harvestType = abi.decode(_data, (uint256));  if (harvestType == 0) {  // claim  (, address[] memory assets) = abi.decode(_data, (uint256, address[]));  label the flashloan providers with an enum representing their name  code/contracts/fantom/flashloans/FlasherFTM.sol:L72-L78  if (_flashnum == 0) {  _initiateGeistFlashLoan(info);  } else if (_flashnum == 2) {  _initiateCreamFlashLoan(info);  } else {  revert(Errors.VL_INVALID_FLASH_NUMBER);  ", "labels": ["Consensys"], "html_url": "https://consensys.io/diligence/audits/2022/03/fuji-protocol/"}, {"title": "4.24 Redundant harvest check in vault", "body": "  Description  In the FujiVaultFTM.harvestRewards function, the check for a returned token s address in the if condition and require statement overlap with tokenReturned != address(0).  Examples  code/contracts/mainnet/FujiVault.sol:L553-L555  if (tokenReturned != address(0)) {  uint256 tokenBal = IERC20Upgradeable(tokenReturned).univBalanceOf(address(this));  require(tokenReturned != address(0) && tokenBal > 0, Errors.VL_HARVESTING_FAILED);  Recommendation  We recommend removing one of the statements for gas savings and increased readability.  ", "labels": ["Consensys"], "html_url": "https://consensys.io/diligence/audits/2022/03/fuji-protocol/"}, {"title": "4.25 Redundant use of immutable for constants", "body": "  Description  The FlasherFTM contract declares immutable state variables even though they are never set in the constructor. Consider declaring them as constant instead unless they are to be set on construction time. See the Solidity Documentation for further details:  [\u2026] For constant variables, the value has to be fixed at compile-time, while for immutable, it can still be assigned at construction time. [\u2026]  Examples  code/contracts/mainnet/flashloans/Flasher.sol:L37-L44  address private immutable _aaveLendingPool = 0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9;  address private immutable _dydxSoloMargin = 0x1E0447b19BB6EcFdAe1e4AE1694b0C3659614e4e;  // IronBank  address private immutable _cyFlashloanLender = 0x1a21Ab52d1Ca1312232a72f4cf4389361A479829;  address private immutable _cyComptroller = 0xAB1c342C7bf5Ec5F02ADEA1c2270670bCa144CbB;  // need to be payable because of the conversion ETH <> WETH  code/contracts/fantom/flashloans/FlasherFTM.sol:L36-L39  address private immutable _geistLendingPool = 0x9FAD24f572045c7869117160A571B2e50b10d068;  IFujiMappings private immutable _crMappings =  IFujiMappings(0x1eEdE44b91750933C96d2125b6757C4F89e63E20);  ", "labels": ["Consensys"], "html_url": "https://consensys.io/diligence/audits/2022/03/fuji-protocol/"}, {"title": "4.26 Redeclaration of constant values in multiple contracts", "body": "  Description  Throughout the codebase, constant values are redeclared in various contracts. This duplication makes the code harder to maintain and increases the risk for bugs. A central contract, e.g., Constants.sol, ConstantsFTM.sol, and ConstantsETH.sol, to declare the constants used throughout the codebase instead of redeclaring them in multiple source units can fix this issue. Ideally, for example, an address constant for an external component is only configured in a single place but consumed by multiple contracts. This will significantly reduce the potential for misconfiguration.  Avoid hardcoded addresses and use meaningful, constant names for them.  Note that the solidity compiler is going to inline constants where possible.  Examples  code/contracts/mainnet/WETHUnwrapper.sol:L7-L9  contract WETHUnwrapper {  address constant weth = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;  code/contracts/mainnet/Swapper.sol:L16-L19  address public constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;  address public constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;  address public constant SUSHI_ROUTER_ADDR = 0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F;  code/contracts/mainnet/FujiVault.sol:L32-L34  address public constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;  code/contracts/mainnet/Fliquidator.sol:L31-L31  address public constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;  code/contracts/mainnet/providers/ProviderCompound.sol:L14-L18  contract HelperFunct {  function _isETH(address token) internal pure returns (bool) {  return (token == address(0) || token == address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE));  code/contracts/mainnet/libraries/LibUniversalERC20.sol:L10-L14  IERC20 private constant _ETH_ADDRESS = IERC20(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);  IERC20 private constant _ZERO_ADDRESS = IERC20(0x0000000000000000000000000000000000000000);  function isETH(IERC20 token) internal pure returns (bool) {  code/contracts/mainnet/flashloans/Flasher.sol:L34-L36  address private constant _ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;  address private constant _WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;  Use meaningful names instead of hardcoded addresses  code/contracts/mainnet/Harvester.sol:L20-L29  if (_farmProtocolNum == 0) {  transaction.to = 0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B;  transaction.data = abi.encodeWithSelector(  bytes4(keccak256(\"claimComp(address)\")),  msg.sender  );  claimedToken = 0xc00e94Cb662C3520282E6f5717214004A7f26888;  } else if (_farmProtocolNum == 1) {  uint256 harvestType = abi.decode(_data, (uint256));  Avoid unnamed hardcoded inlined addresses  code/contracts/fantom/providers/ProviderCream.sol:L157-L162  if (_isFTM(_asset)) {  // Transform FTM to WFTM  IWETH(0x21be370D5312f44cB42ce377BC9b8a0cEF1A4C83).deposit{ value: _amount }();  _asset = address(0x21be370D5312f44cB42ce377BC9b8a0cEF1A4C83);  comptroller address - can also be private constant state variables as the compiler/preprocessor will inline them.  code/contracts/fantom/providers/ProviderCream.sol:L21-L31  function _getMappingAddr() internal pure returns (address) {  return 0x1eEdE44b91750933C96d2125b6757C4F89e63E20; // Cream fantom mapper  function _getComptrollerAddress() internal pure returns (address) {  return 0x4250A6D3BD57455d7C6821eECb6206F507576cD2; // Cream fantom  function _getUnwrapper() internal pure returns(address) {  return 0xee94A39D185329d8c46dEA726E01F91641E57346;  WFTM multiple re-declarations  code/contracts/fantom/WFTMUnwrapper.sol:L7-L9  contract WFTMUnwrapper {  address constant wftm = 0x21be370D5312f44cB42ce377BC9b8a0cEF1A4C83;  code/contracts/fantom/providers/ProviderGeist.sol:L27-L29  function _getWftmAddr() internal pure returns (address) {  return 0x21be370D5312f44cB42ce377BC9b8a0cEF1A4C83;  code/contracts/fantom/providers/ProviderCream.sol:L79-L81  IWETH(0x21be370D5312f44cB42ce377BC9b8a0cEF1A4C83).deposit{ value: _amount }();  _asset = address(0x21be370D5312f44cB42ce377BC9b8a0cEF1A4C83);  ", "labels": ["Consensys"], "html_url": "https://consensys.io/diligence/audits/2022/03/fuji-protocol/"}, {"title": "4.27 Always use the best available type", "body": "  Description  Declare state variables with the best type available and downcast to address if needed. Typecasting inside the corpus of a function is unneeded when the parameter s type is known beforehand. Declare the best type in function arguments, state vars. Always return the best type available instead of falling back to address.  Examples  There are many more instances of this, but here s a list of samples:  Should be declared with the correct types/interfaces instead of address  code/contracts/FujiAdmin.sol:L14-L20  address private _flasher;  address private _fliquidator;  address payable private _ftreasury;  address private _controller;  address private _vaultHarvester;  Should return the correct type/interfaces instead of address  code/contracts/FujiAdmin.sol:L144-L147  Should declare the argument with the correct type instead of casting in the function body.  /  function getSwapper() external view override returns (address) {  return _swapper;  Should declare the argument with the correct type instead of casting in the function body.  code/contracts/Controller.sol:L73-L80  function doRefinancing(  address _vaultAddr,  address _newProvider,  uint8 _flashNum  ) external isValidVault(_vaultAddr) onlyOwnerOrExecutor {  IVault vault = IVault(_vaultAddr);  Should make the FujiVaultFTM.fujiERC1155 state variable of type IFujiERC1155  code/contracts/fantom/FujiVaultFTM.sol:L438-L445  IFujiERC1155(fujiERC1155).updateState(  vAssets.borrowID,  IProvider(activeProvider).getBorrowBalance(vAssets.borrowAsset)  );  IFujiERC1155(fujiERC1155).updateState(  vAssets.collateralID,  IProvider(activeProvider).getDepositBalance(vAssets.collateralAsset)  );  Return the best type available  code/contracts/fantom/providers/ProviderCream.sol:L25-L31  function _getComptrollerAddress() internal pure returns (address) {  return 0x4250A6D3BD57455d7C6821eECb6206F507576cD2; // Cream fantom  function _getUnwrapper() internal pure returns(address) {  return 0xee94A39D185329d8c46dEA726E01F91641E57346;  ", "labels": ["Consensys"], "html_url": "https://consensys.io/diligence/audits/2022/03/fuji-protocol/"}, {"title": "4.1 Unhandled return values of transfer and transferFrom    ", "body": "  Resolution   The issue was fixed by using OpenZeppelin s   ERC20 implementations are not always consistent. Some implementations of transfer and transferFrom could return  false  on failure instead of reverting. It is safer to wrap such calls into require() statements to these failures.  code/contracts/stake/StakedToken.sol:L92  IERC20(STAKED_TOKEN).transferFrom(msg.sender, address(this), amount);  code/contracts/stake/StakedToken.sol:L156  REWARD_TOKEN.transferFrom(REWARDS_VAULT, to, amountToWithdraw);  code/contracts/stake/StakedToken.sol:L125  IERC20(STAKED_TOKEN).transfer(to, amount);  ", "labels": ["Consensys", "Medium", "Fixed"], "html_url": "https://consensys.io/diligence/audits/2020/09/aave-safety-module/"}, {"title": "4.2 Staking cooldown can be avoided for a part of the funds    ", "body": "  Resolution  The cooldown window will be set to much higher value (to the order of days) in production. The mechanism is sufficient to prevent stakers from withdrawing if the cooldown window is long enough while also being larger than the withdrawal window.  Aave is planning to introduce a slashing mechanism for the staking system in the future. In order to prevent stakers from withdrawing their stake immediately, the team has added a  cooldown  mechanism. The idea is that whenever stakers want to redeem the stake, they should call the cooldown function and wait for COOLDOWN_SECONDS. After that, a time period called UNSTAKE_WINDOW starts during which the stake can be withdrawn.  However, depending on the settings ( COOLDOWN_SECONDS  and  UNSTAKE_WINDOW  values), various algorithms exist that would allow users to optimize their withdrawal tactics. By using such tactics, stakers may be able to withdraw at least a part of the stake immediately.  Let s assume that the values are the same as in tests: COOLDOWN_SECONDS == 1 hour and UNSTAKE_WINDOW == 30 minutes. Stakers can split their stake into 3 parts and call cooldown for one of them every 30 minutes. That would ensure that at least 1/3 of the stake can be withdrawn immediately at any time. And on average, more than 1/2 of the stake can be withdrawn immediately.  Remediation:  Make sure that the COOLDOWN_SECONDS value is much larger than the UNSTAKE_WINDOW. This will make any cooldown optimization techniques less effective.  ", "labels": ["Consensys", "Minor", "Fixed"], "html_url": "https://consensys.io/diligence/audits/2020/09/aave-safety-module/"}, {"title": "4.3  code quality issues    ", "body": "  Resolution  all issues have been fixed in production.  We recommend the following improvements:  Fix todos  Clean up all TODOs before going into production:  code/contracts/stake/AaveDistributionManager.sol:L44-L46  function configureAssets(DistributionTypes.AssetConfigInput[] calldata assetsConfigInput)  external  //    override TODO: create interface  Fix incorrect NatSpec comments  Clean up NatSpec comments to improve readability.  The function claimRewards() in StakedToken has the same description as the stake() function:  code/contracts/stake/StakedToken.sol:L141-L145  One function argument is missing from the docstrings for claimRewards() in AaveIncentivesController:  @dev Stakes tokens to start earning rewards  @param to Address to stake for  @param amount Amount to stake  **/  function claimRewards(address to, uint256 amount) external override {  One function argument is missing from the docstrings for claimRewards() in AaveIncentivesController:  code/contracts/stake/AaveIncentivesController.sol:L97-L107  /**  @dev Claims reward for an user, on all the assets of the lending pool, accumulating the pending rewards  @param amount Amount of rewards to claim  @param to Address that will be receiving the rewards  @return Rewards claimed  **/  function claimRewards(  uint256 amount,  address to,  bool stake  ) external override returns (uint256) {  ", "labels": ["Consensys", "Minor", "Fixed"], "html_url": "https://consensys.io/diligence/audits/2020/09/aave-safety-module/"}, {"title": "4.1 Token approvals can be stolen in DAOfiV1Router01.addLiquidity() ", "body": "  Description  DAOfiV1Router01.addLiquidity() creates the desired pair contract if it does not already exist, then transfers tokens into the pair and calls DAOfiV1Pair.deposit(). There is no validation of the address to transfer tokens from, so an attacker could pass in any address with nonzero token approvals to DAOfiV1Router. This could be used to add liquidity to a pair contract for which the attacker is the pairOwner, allowing the stolen funds to be retrieved using DAOfiV1Pair.withdraw().  code/daofi-v1-periphery/contracts/DAOfiV1Router01.sol:L57-L85  function addLiquidity(  LiquidityParams calldata lp,  uint deadline  ) external override ensure(deadline) returns (uint256 amountBase) {  if (IDAOfiV1Factory(factory).getPair(  lp.tokenBase,  lp.tokenQuote,  lp.slopeNumerator,  lp.n,  lp.fee  ) == address(0)) {  IDAOfiV1Factory(factory).createPair(  address(this),  lp.tokenBase,  lp.tokenQuote,  msg.sender,  lp.slopeNumerator,  lp.n,  lp.fee  );  address pair = DAOfiV1Library.pairFor(  factory, lp.tokenBase, lp.tokenQuote, lp.slopeNumerator, lp.n, lp.fee  );  TransferHelper.safeTransferFrom(lp.tokenBase, lp.sender, pair, lp.amountBase);  TransferHelper.safeTransferFrom(lp.tokenQuote, lp.sender, pair, lp.amountQuote);  amountBase = IDAOfiV1Pair(pair).deposit(lp.to);  Recommendation  Transfer tokens from msg.sender instead of lp.sender.  ", "labels": ["Consensys", "Critical"], "html_url": "https://consensys.io/diligence/audits/2021/02/daofi/"}, {"title": "4.2 The deposit of a new pair can be stolen ", "body": "  Description  To create a new pair, a user is expected to call the same addLiquidity() (or the addLiquidityETH()) function of the router contract seen above:  code/daofi-v1-periphery/contracts/DAOfiV1Router01.sol:L57-L85  function addLiquidity(  LiquidityParams calldata lp,  uint deadline  ) external override ensure(deadline) returns (uint256 amountBase) {  if (IDAOfiV1Factory(factory).getPair(  lp.tokenBase,  lp.tokenQuote,  lp.slopeNumerator,  lp.n,  lp.fee  ) == address(0)) {  IDAOfiV1Factory(factory).createPair(  address(this),  lp.tokenBase,  lp.tokenQuote,  msg.sender,  lp.slopeNumerator,  lp.n,  lp.fee  );  address pair = DAOfiV1Library.pairFor(  factory, lp.tokenBase, lp.tokenQuote, lp.slopeNumerator, lp.n, lp.fee  );  TransferHelper.safeTransferFrom(lp.tokenBase, lp.sender, pair, lp.amountBase);  TransferHelper.safeTransferFrom(lp.tokenQuote, lp.sender, pair, lp.amountQuote);  amountBase = IDAOfiV1Pair(pair).deposit(lp.to);  This function checks if the pair already exists and creates a new one if it does not. After that, the first and only deposit is made to that pair.  The attacker can front-run that call and create a pair with the same parameters (thus, with the same address) by calling the createPair function of the DAOfiV1Factory contract. By calling that function directly, the attacker does not have to make the deposit when creating a new pair. The initial user will make this deposit, whose funds can now be withdrawn by the attacker.  Recommendation  There are a few factors/bugs that allowed this attack. All or some of them should be fixed:  The createPair function of the DAOfiV1Factory contract can be called directly by anyone without depositing with any router address as the parameter. The solution could be to allow only the router to create a pair.  The addLiquidity function checks that the pair does not exist yet. If the pair exists already, a deposit should only be made by the owner of the pair. But in general, a new pair shouldn t be deployed without depositing in the same transaction.  The pair s address does not depend on the owner/creator. It might make sense to add that information to the salt.  ", "labels": ["Consensys", "Critical"], "html_url": "https://consensys.io/diligence/audits/2021/02/daofi/"}, {"title": "4.3 Incorrect token decimal conversions can lead to loss of funds ", "body": "  Description  The _convert() function in DAOfiV1Pair is used to accommodate tokens with varying decimals() values. There are three cases in which it implicitly returns 0 for any amount, the most notable of which is when token.decimals() == resolution.  As a result of this, getQuoteOut() reverts any time either baseToken or quoteToken have decimals == INTERNAL_DECIMALS (currently hardcoded to 8).  The result of this is that no swaps can be performed in one of these pools, and the deposit() function will return an incorrect amountBaseOut of baseToken to the depositor, the balance of which can then be withdrawn by the pairOwner.  code/daofi-v1-core/contracts/DAOfiV1Pair.sol:L108-L130  function _convert(address token, uint256 amount, uint8 resolution, bool to) private view returns (uint256 converted) {  uint8 decimals = IERC20(token).decimals();  uint256 diff = 0;  uint256 factor = 0;  converted = 0;  if (decimals > resolution) {  diff = uint256(decimals.sub(resolution));  factor = 10 ** diff;  if (to && amount >= factor) {  converted = amount.div(factor);  } else if (!to) {  converted = amount.mul(factor);  } else if (decimals < resolution) {  diff = uint256(resolution.sub(decimals));  factor = 10 ** diff;  if (to) {  converted = amount.mul(factor);  } else if (!to && amount >= factor) {  converted = amount.div(factor);  Recommendation  The _convert() function should return amount when token.decimals() == resolution. Additionally, implicit return values should be avoided whenever possible, especially in functions that implement complex mathematical operations.  BancorFormula.power(baseN, baseD, _, _) does not support baseN < baseD, and checks should be added to ensure that any call to the BancorFormula conforms to the expected input ranges.  ", "labels": ["Consensys", "Major"], "html_url": "https://consensys.io/diligence/audits/2021/02/daofi/"}, {"title": "4.4 The swapExactTokensForETH checks the wrong return value ", "body": "  Description  The following lines are intended to check that the amount of tokens received from a swap is greater than the minimum amount expected from this swap (sp.amountOut):  code/daofi-v1-periphery/contracts/DAOfiV1Router01.sol:L341-L345  uint amountOut = IWETH10(WETH).balanceOf(address(this));  require(  IWETH10(sp.tokenOut).balanceOf(address(this)).sub(balanceBefore) >= sp.amountOut,  'DAOfiV1Router: INSUFFICIENT_OUTPUT_AMOUNT'  );  Instead, it calculates the difference between the initial receiver s balance and the balance of the router.  Recommendation  Check the intended value.  ", "labels": ["Consensys", "Major"], "html_url": "https://consensys.io/diligence/audits/2021/02/daofi/"}, {"title": "4.5 DAOfiV1Pair.deposit() accepts deposits of zero, blocking the pool ", "body": "  Description  code/daofi-v1-core/contracts/DAOfiV1Pair.sol:L223-L239  function deposit(address to) external override lock returns (uint256 amountBaseOut) {  require(msg.sender == router, 'DAOfiV1: FORBIDDEN_DEPOSIT');  require(deposited == false, 'DAOfiV1: DOUBLE_DEPOSIT');  reserveBase = IERC20(baseToken).balanceOf(address(this));  reserveQuote = IERC20(quoteToken).balanceOf(address(this));  // this function is locked and the contract can not reset reserves  deposited = true;  if (reserveQuote > 0) {  // set initial supply from reserveQuote  supply = amountBaseOut = getBaseOut(reserveQuote);  if (amountBaseOut > 0) {  _safeTransfer(baseToken, to, amountBaseOut);  reserveBase = reserveBase.sub(amountBaseOut);  emit Deposit(msg.sender, reserveBase, reserveQuote, amountBaseOut, to);  Recommendation  Require a minimum deposit amount in both baseToken and quoteToken, and do not rely on any assumptions about the distribution of baseToken as part of the security model.  ", "labels": ["Consensys", "Medium"], "html_url": "https://consensys.io/diligence/audits/2021/02/daofi/"}, {"title": "4.6 Restricting DAOfiV1Pair functions to calls from router makes DAOfiV1Router01 security critical ", "body": "  Description  The DAOfiV1Pair functions deposit(), withdraw(), and swap() are all restricted to calls from the router in order to avoid losses from user error. However, this means that any unidentified issue in the Router could render all pair contracts unusable, potentially locking the pair owner s funds.  Additionally, DAOfiV1Factory.createPair() allows any nonzero address to be provided as the router, so pairs can be initialized with a malicious router that users would be forced to interact with to utilize the pair contract.  code/daofi-v1-core/contracts/DAOfiV1Pair.sol:L223-L224  function deposit(address to) external override lock returns (uint256 amountBaseOut) {  require(msg.sender == router, 'DAOfiV1: FORBIDDEN_DEPOSIT');  code/daofi-v1-core/contracts/DAOfiV1Pair.sol:L250-L251  function withdraw(address to) external override lock returns (uint256 amountBase, uint256 amountQuote) {  require(msg.sender == router, 'DAOfiV1: FORBIDDEN_WITHDRAW');  code/daofi-v1-core/contracts/DAOfiV1Pair.sol:L292-L293  function swap(address tokenIn, address tokenOut, uint256 amountIn, uint256 amountOut, address to) external override lock {  require(msg.sender == router, 'DAOfiV1: FORBIDDEN_SWAP');  Recommendation  Do not restrict DAOfiV1Pair functions to calls from router, but encourage users to use a trusted router to avoid losses from user error. If this restriction is kept, consider including the router address in the deployment salt for the pair or hardcoding the address of a trusted router in DAOfiV1Factory instead of taking the router as a parameter to createPair().  ", "labels": ["Consensys", "Medium"], "html_url": "https://consensys.io/diligence/audits/2021/02/daofi/"}, {"title": "4.7 Pair contracts can be easily blocked ", "body": "  Description  The existing mitigation for this issue is to create a new pool with slightly different parameters. This creates significant cost for the creator of a pair, forces them to deploy a pair with sub-optimal parameters, and could potentially block all interesting pools for a token pair.  The salt used to determine unique pair contracts in DAOfiV1Factory.createPair():  code/daofi-v1-core/contracts/DAOfiV1Factory.sol:L77-L84  require(getPair(baseToken, quoteToken, slopeNumerator, n, fee) == address(0), 'DAOfiV1: PAIR_EXISTS'); // single check is sufficient  bytes memory bytecode = type(DAOfiV1Pair).creationCode;  bytes32 salt = keccak256(abi.encodePacked(baseToken, quoteToken, slopeNumerator, n, fee));  assembly {  pair := create2(0, add(bytecode, 32), mload(bytecode), salt)  IDAOfiV1Pair(pair).initialize(router, baseToken, quoteToken, pairOwner, slopeNumerator, n, fee);  pairs[salt] = pair;  Recommendation  Consider adding additional parameters to the salt that defines a unique pair, such as the pairOwner. Modifying the parameters included in the salt can also be used to partially mitigate other security concerns raised in this report.  ", "labels": ["Consensys", "Minor"], "html_url": "https://consensys.io/diligence/audits/2021/02/daofi/"}, {"title": "4.8 DAOfiV1Router01.removeLiquidityETH() does not support tokens with no return value ", "body": "  Description  While the rest of the system uses the safeTransfer* pattern, allowing tokens that do not return a boolean value on transfer() or transferFrom(), DAOfiV1Router01.removeLiquidityETH() throws and consumes all remaining gas if the base token does not return true.  Note that the deposit in this case can still be withdrawn without unwrapping the Eth using removeLiquidity().  code/daofi-v1-periphery/contracts/DAOfiV1Router01.sol:L157-L167  function removeLiquidityETH(  LiquidityParams calldata lp,  uint deadline  ) external override ensure(deadline) returns (uint amountToken, uint amountETH) {  IDAOfiV1Pair pair = IDAOfiV1Pair(DAOfiV1Library.pairFor(factory, lp.tokenBase, WETH, lp.slopeNumerator, lp.n, lp.fee));  require(msg.sender == pair.pairOwner(), 'DAOfiV1Router: FORBIDDEN');  (amountToken, amountETH) = pair.withdraw(address(this));  assert(IERC20(lp.tokenBase).transfer(lp.to, amountToken));  IWETH10(WETH).withdraw(amountETH);  TransferHelper.safeTransferETH(lp.to, amountETH);  Recommendation  Be consistent with the use of safeTransfer*, and do not use assert() in cases where the condition can be false.  ", "labels": ["Consensys", "Minor"], "html_url": "https://consensys.io/diligence/audits/2021/02/daofi/"}, {"title": "5.1 [Out of Scope] ReferralFeeReceiver - anyone can steal all the funds that belong to ReferralFeeReceiver    Fix Unverified", "body": "  Resolution  According to the client, this issue is addressed in 1inch-exchange/1inch-liquidity-protocol#2 and the reentrancy in FeeReceiver in 1inch-exchange/1inch-liquidity-protocol@e9c6a03  (This fix is as reported by the developer team, but has not been verified by Diligence).  Description  Note: This issue was raised in components that were being affected by the scope reduction as outlined in the section  Scope  and are, therefore, only shallowly validated. Nevertheless, we find it important to communicate such potential findings and ask the client to further investigate.  The ReferralFeeReceiver receives pool shares when users swap() tokens in the pool. A ReferralFeeReceiver may be used with multiple pools and, therefore, be a lucrative target as it is holding pool shares.  Any token or ETH that belongs to the ReferralFeeReceiver is at risk and can be drained by any user by providing a custom mooniswap pool contract that references existing token holdings.  It should be noted that none of the functions in ReferralFeeReceiver verify that the user-provided mooniswap pool address was actually deployed by the linked MooniswapFactory. The factory provides certain security guarantees about mooniswap pool contracts (e.g. valid mooniswap contract, token deduplication, tokenA!=tokenB, enforced token sorting, \u2026), however, since the ReferralFeeReceiver does not verify the user-provided mooniswap address they are left unchecked.  Additional Notes  freezeEpoch - (callable by anyone) performs a pool.withdraw() with the minAmounts check being disabled. This may allow someone to call this function at a time where the contract actually gets a bad deal.  trade - (callable by anyone) can intentionally be used to perform bad trades (front-runnable)  trade - (callable by anyone) appears to implement inconsistent behavior when sending out availableBalance. ETH is sent to tx.origin (the caller) while tokens are sent to the user-provided mooniswap address.  code/contracts/ReferralFeeReceiver.sol:L91-L95  if (path[0].isETH()) {  tx.origin.transfer(availableBalance);  // solhint-disable-line avoid-tx-origin  } else {  path[0].safeTransfer(address(mooniswap), availableBalance);  multiple methods - since mooniswap is a user-provided address there are a lot of opportunities to reenter the contract. Consider adding reentrancy guards as another security layer (e.g. claimCurrentEpoch and others).  multiple methods - do not validate the amount of tokens that are returned, causing an evm assertion due to out of bounds index access.  code/contracts/ReferralFeeReceiver.sol:L57-L59  IERC20[] memory tokens = mooniswap.getTokens();  uint256 token0Balance = tokens[0].uniBalanceOf(address(this));  uint256 token1Balance = tokens[1].uniBalanceOf(address(this));  in GovernanceFeeReceiver anyone can intentionally force unwrapping of pool tokens or perform swaps in the worst time possible. e.g. The checks for withdraw(..., minAmounts) is disabled.  code/contracts/governance/GovernanceFeeReceiver.sol:L18-L26  function unwrapLPTokens(Mooniswap mooniswap) external validSpread(mooniswap) {  mooniswap.withdraw(mooniswap.balanceOf(address(this)), new uint256[](0));  function swap(IERC20[] memory path) external validPath(path) {  (uint256 amount,) = _maxAmountForSwap(path, path[0].uniBalanceOf(address(this)));  uint256 result = _swap(path, amount, payable(address(rewards)));  rewards.notifyRewardAmount(result);  Examples  Let s assume the following scenario:  ReferralFeeReceiver holds DAI token and we want to steal them.  An attacker may be able to drain the contract from DAI token via claimFrozenToken if  they control the mooniswap address argument and provide a malicious contract  user.share[mooniswap][firstUnprocessedEpoch] > 0 - this can be arbitrarily set in updateReward  token.epochBalance[currentEpoch].token0Balance > 0 - this can be manipulated in freezeEpoch by providing a malicious mooniswap contract  they own a worthless ERC20 token e.g. named ATTK  The following steps outline the attack:  The attacker calls into updateReward to set user.share[mooniswap][currentEpoch] to a value that is greater than zero to make sure that share in claimFrozenEpoch takes the _transferTokenShare path.  code/contracts/ReferralFeeReceiver.sol:L38-L50  function updateReward(address referral, uint256 amount) external override {  Mooniswap mooniswap = Mooniswap(msg.sender);  TokenInfo storage token = tokenInfo[mooniswap];  UserInfo storage user = userInfo[referral];  uint256 currentEpoch = token.currentEpoch;  // Add new reward to current epoch  user.share[mooniswap][currentEpoch] = user.share[mooniswap][currentEpoch].add(amount);  token.epochBalance[currentEpoch].totalSupply = token.epochBalance[currentEpoch].totalSupply.add(amount);  // Collect all processed epochs and advance user token epoch  _collectProcessedEpochs(user, token, mooniswap, currentEpoch);  The attacker then calls freezeEpoch() providing the malicious mooniswap contract address controlled by the attacker.  The malicious contract returns token that is controlled by the attacker (e.g. ATTK) in a call to mooniswap.getTokens();  The contract then stores the current balance of the attacker-controlled token in token0Balance/token1Balance. Note that the token being returned here by the malicious contract can be different from the one we re checking out in the last step (balance manipulation via ATTK, checkout of DAI in the last step).  Then the contract calls out to the malicious mooniswap contract. This gives the malicious contract an easy opportunity to send some attacker-controlled token (ATTK) to the ReferralFeeReceiver in order to freely manipulate the frozen tokenbalances (tokens[0].uniBalanceOf(address(this)).sub(token0Balance);).  Note that the used token addresses are never stored anywhere. The balances recorded here are for an attacker-controlled token (ATTK), not the actual one that we re about to steal (e.g. DAI)  The token balances are now set-up for checkout in the last step (claimFrozenEpoch).  code/contracts/ReferralFeeReceiver.sol:L52-L64  function freezeEpoch(Mooniswap mooniswap) external validSpread(mooniswap) {  TokenInfo storage token = tokenInfo[mooniswap];  uint256 currentEpoch = token.currentEpoch;  require(token.firstUnprocessedEpoch == currentEpoch, \"Previous epoch is not finalized\");  IERC20[] memory tokens = mooniswap.getTokens();  uint256 token0Balance = tokens[0].uniBalanceOf(address(this));  uint256 token1Balance = tokens[1].uniBalanceOf(address(this));  mooniswap.withdraw(mooniswap.balanceOf(address(this)), new uint256[](0));  token.epochBalance[currentEpoch].token0Balance = tokens[0].uniBalanceOf(address(this)).sub(token0Balance);  token.epochBalance[currentEpoch].token1Balance = tokens[1].uniBalanceOf(address(this)).sub(token1Balance);  token.currentEpoch = currentEpoch.add(1);  A call to claimFrozenEpoch checks-out the previously frozen token balance.  The claim > 0 requirement was fulfilled in step 1.  The token balance was prepared for the attacker-controlled token (ATTK) in step 2, but we re now checking out DAI.  When the contract calls out to the attackers mooniswap contract the call to IERC20[] memory tokens = mooniswap.getTokens(); returns the address of the token to be stolen (e.g. DAI) instead of the attacker-controlled token (ATTK) that was used to set-up the balance records.  Subsequently, the valuable target tokens (DAI) are sent out to the caller in _transferTokenShare.  code/contracts/ReferralFeeReceiver.sol:L153-L162  if (share > 0) {  EpochBalance storage epochBalance = token.epochBalance[firstUnprocessedEpoch];  uint256 totalSupply = epochBalance.totalSupply;  user.share[mooniswap][firstUnprocessedEpoch] = 0;  epochBalance.totalSupply = totalSupply.sub(share);  IERC20[] memory tokens = mooniswap.getTokens();  epochBalance.token0Balance = _transferTokenShare(tokens[0], epochBalance.token0Balance, share, totalSupply);  epochBalance.token1Balance = _transferTokenShare(tokens[1], epochBalance.token1Balance, share, totalSupply);  epochBalance.inchBalance = _transferTokenShare(inchToken, epochBalance.inchBalance, share, totalSupply);  Recommendation  Enforce that the user-provided mooniswap contract was actually deployed by the linked factory. Other contracts cannot be trusted. Consider implementing token sorting and de-duplication (tokenA!=tokenB) in the pool contract constructor as well. Consider employing a reentrancy guard to safeguard the contract from reentrancy attacks.  Improve testing. The methods mentioned here are not covered at all. Improve documentation and provide a specification that outlines how this contract is supposed to be used.  Review the  additional notes  provided with this issue.  ", "labels": ["Consensys", "Critical"], "html_url": "https://consensys.io/diligence/audits/2020/12/1inch-liquidity-protocol/"}, {"title": "5.2 GovernanceMothership - notifyFor allows to arbitrarily create new or override other users stake in governance modules    Fix Unverified", "body": "  Resolution  According to the client, this issue is addressed in 1inch-exchange/1inch-liquidity-protocol@2ce549d and added tests with 1inch-exchange/1inch-liquidity-protocol@e0dc46b  (This fix is as reported by the developer team, but has not been verified by Diligence).  Description  The notify* methods are called to update linked governance modules when an accounts stake changes in the Mothership. The linked modules then update their own balances of the user to accurately reflect the account s real stake in the Mothership.  Besides notify there s also a method named notifyFor which is publicly accessible. It is assumed that the method should be used similar to notify to force an update for another account s balance.  However, invoking the method forces an update in the linked modules for the provided address, but takes balanceOf(msg.sender) instead of balanceOf(account). This allows malicious actors to:  Arbitrarily change other accounts stake in linked governance modules (e.g. zeroing stake, increasing stake) based on the callers stake in the mothership  Duplicate stake out of thin air to arbitrary addresses (e.g. staking in mothership once and calling notifyFor many other account addresses)  Examples  publicly accessible method allows forcing stake updates for arbitrary users  code/contracts/inch/GovernanceMothership.sol:L48-L50  function notifyFor(address account) external {  _notifyFor(account, balanceOf(msg.sender));  the method calls the linked governance modules  code/contracts/inch/GovernanceMothership.sol:L73-L78  function _notifyFor(address account, uint256 balance) private {  uint256 modulesLength = _modules.length();  for (uint256 i = 0; i < modulesLength; ++i) {  IGovernanceModule(_modules.at(i)).notifyStakeChanged(account, balance);  which will arbitrarily mint or burn stake in the BalanceAccounting of Factory or Reward (or other linked governance modules)  code/contracts/governance/BaseGovernanceModule.sol:L29-L31  function notifyStakeChanged(address account, uint256 newBalance) external override onlyMothership {  _notifyStakeChanged(account, newBalance);  code/contracts/governance/MooniswapFactoryGovernance.sol:L144-L160  function _notifyStakeChanged(address account, uint256 newBalance) internal override {  uint256 balance = balanceOf(account);  if (newBalance > balance) {  _mint(account, newBalance.sub(balance));  } else if (newBalance < balance) {  _burn(account, balance.sub(newBalance));  } else {  return;  uint256 newTotalSupply = totalSupply();  _defaultFee.updateBalance(account, _defaultFee.votes[account], balance, newBalance, newTotalSupply, _DEFAULT_FEE, _emitDefaultFeeVoteUpdate);  _defaultSlippageFee.updateBalance(account, _defaultSlippageFee.votes[account], balance, newBalance, newTotalSupply, _DEFAULT_SLIPPAGE_FEE, _emitDefaultSlippageFeeVoteUpdate);  _defaultDecayPeriod.updateBalance(account, _defaultDecayPeriod.votes[account], balance, newBalance, newTotalSupply, _DEFAULT_DECAY_PERIOD, _emitDefaultDecayPeriodVoteUpdate);  _referralShare.updateBalance(account, _referralShare.votes[account], balance, newBalance, newTotalSupply, _DEFAULT_REFERRAL_SHARE, _emitReferralShareVoteUpdate);  _governanceShare.updateBalance(account, _governanceShare.votes[account], balance, newBalance, newTotalSupply, _DEFAULT_GOVERNANCE_SHARE, _emitGovernanceShareVoteUpdate);  code/contracts/governance/GovernanceRewards.sol:L72-L79  function _notifyStakeChanged(address account, uint256 newBalance) internal override updateReward(account) {  uint256 balance = balanceOf(account);  if (newBalance > balance) {  _mint(account, newBalance.sub(balance));  } else if (newBalance < balance) {  _burn(account, balance.sub(newBalance));  Recommendation  Remove notifyFor or change it to take the balance of the correct account _notifyFor(account, balanceOf(msg.sender)).  ", "labels": ["Consensys", "Critical"], "html_url": "https://consensys.io/diligence/audits/2020/12/1inch-liquidity-protocol/"}, {"title": "5.3 Users can  increase  their voting power by voting for the max/min values ", "body": "  Description  Many parameters in the system are determined by the complicated governance mechanism. These parameters are calculated as a result of the voting process and are equal to the weighted average of all the votes that stakeholders make. The idea is that every user is voting for the desired value. But if the result value is smaller (larger) than the desired, the user can change the vote for the max (min) possible value. That would shift the result towards the desired one and basically  increase  this stakeholder s voting power. So every user is more incentivized to vote for the min/max value than for the desired one.  The issue s severity is not high because all parameters have reasonable max value limitations, so it s hard to manipulate the system too much.  Recommendation  Reconsider the voting mechanism.  ", "labels": ["Consensys", "Medium"], "html_url": "https://consensys.io/diligence/audits/2020/12/1inch-liquidity-protocol/"}, {"title": "5.4 The uniTransferFrom function can potentially be used with invalid params    Fix Unverified", "body": "  Resolution  According to the client, this issue is addressed in 1inch-exchange/1inch-liquidity-protocol@d0ffb6f.  (This fix is as reported by the developer team, but has not been verified by Diligence).  Description  The system is using the UniERC20 contract to incapsulate transfers of both ERC-20 tokens and ETH. This contract has uniTransferFrom function that can be used for any ERC-20 or ETH:  code/contracts/libraries/UniERC20.sol:L36-L48  function uniTransferFrom(IERC20 token, address payable from, address to, uint256 amount) internal {  if (amount > 0) {  if (isETH(token)) {  require(msg.value >= amount, \"UniERC20: not enough value\");  if (msg.value > amount) {  // Return remainder if exist  from.transfer(msg.value.sub(amount));  } else {  token.safeTransferFrom(from, to, amount);  This issue s severity is not high because the function is always called with the proper parameters in the current codebase.  Recommendation  Make sure that the uniTransferFrom function is always called with expected parameters.  ", "labels": ["Consensys", "Medium"], "html_url": "https://consensys.io/diligence/audits/2020/12/1inch-liquidity-protocol/"}, {"title": "5.5 MooniswapGovernance - votingpower is not accurately reflected when minting pool tokens    Fix Unverified", "body": "  Resolution  According to the client, this issue is addressed in 1inch-exchange/1inch-liquidity-protocol@eb869fd  (This fix is as reported by the developer team, but has not been verified by Diligence).  Description  When a user provides liquidity to the pool, pool-tokens are minted. The minting event triggers the _beforeTokenTransfer callback in MooniswapGovernance which updates voting power reflecting the newly minted stake for the user.  There seems to be a copy-paste error in the way balanceTo is determined that sets balanceTo to zero if new token were minted (from==address(0)). This means, that in a later call to _updateOnTransfer only the newly minted amount is considered when adjusting voting power.  Examples  If tokens are newly minted from==address(0) and therefore balanceTo -> 0.  code/contracts/governance/MooniswapGovernance.sol:L100-L114  function _beforeTokenTransfer(address from, address to, uint256 amount) internal override {  uint256 balanceFrom = (from != address(0)) ? balanceOf(from) : 0;  uint256 balanceTo = (from != address(0)) ? balanceOf(to) : 0;  uint256 newTotalSupply = totalSupply()  .add(from == address(0) ? amount : 0)  .sub(to == address(0) ? amount : 0);  ParamsHelper memory params = ParamsHelper({  from: from,  to: to,  amount: amount,  balanceFrom: balanceFrom,  balanceTo: balanceTo,  newTotalSupply: newTotalSupply  });  now, balanceTo is zero which would adjust voting power to amount instead of the user s actual balance + the newly minted token.  code/contracts/governance/MooniswapGovernance.sol:L150-L153  if (params.to != address(0)) {  votingData.updateBalance(params.to, voteTo, params.balanceTo, params.balanceTo.add(params.amount), params.newTotalSupply, defaultValue, emitEvent);  Recommendation  balanceTo should be zero when burning (to == address(0)) and balanceOf(to) when minting.  e.g. like this:  uint256 balanceTo = (to != address(0)) ? balanceOf(to) : 0;  ", "labels": ["Consensys", "Medium"], "html_url": "https://consensys.io/diligence/audits/2020/12/1inch-liquidity-protocol/"}, {"title": "5.6 MooniswapGovernance - _beforeTokenTransfer should not update voting power on transfers to self    Fix Unverified", "body": "  Resolution  Addressed 1inch-exchange/1inch-liquidity-protocol@7c7126d  (This fix is as reported by the developer team, but has not been verified by Diligence).  Description  Mooniswap governance is based on the liquidity voting system that is also employed by the mothership or for factory governance. In contrast to traditional voting systems where users vote for discrete values, the liquidity voting system derives a continuous weighted averaged  consensus  value from all the votes. Thus it is required that whenever stake changes in the system, all the parameters that can be voted upon are updated with the new weights for a specific user.  The Mooniswap pool is governed by liquidity providers and liquidity tokens are the stake that gives voting rights in MooniswapGovernance. Thus whenever liquidity tokens are transferred to another address, stake and voting values need to be updated. This is handled by MooniswapGovernance._beforeTokenTransfer().  In the special case where someone triggers a token transfer where the from address equals the to address, effectively sending the token to themselves, no update on voting power should be performed. Instead, voting power is first updated with balance - amount and then with balance + amount which in the worst case means it is updating first to a zero balance and then to 2x the balance.  Ultimately this should not have an effect on the overall outcome but is unnecessary and wasting gas.  Examples  beforeTokenTransfer callback in Mooniswap does not check for the NOP case where from==to  code/contracts/governance/MooniswapGovernance.sol:L100-L119  function _beforeTokenTransfer(address from, address to, uint256 amount) internal override {  uint256 balanceFrom = (from != address(0)) ? balanceOf(from) : 0;  uint256 balanceTo = (from != address(0)) ? balanceOf(to) : 0;  uint256 newTotalSupply = totalSupply()  .add(from == address(0) ? amount : 0)  .sub(to == address(0) ? amount : 0);  ParamsHelper memory params = ParamsHelper({  from: from,  to: to,  amount: amount,  balanceFrom: balanceFrom,  balanceTo: balanceTo,  newTotalSupply: newTotalSupply  });  _updateOnTransfer(params, mooniswapFactoryGovernance.defaultFee, _emitFeeVoteUpdate, _fee);  _updateOnTransfer(params, mooniswapFactoryGovernance.defaultSlippageFee, _emitSlippageFeeVoteUpdate, _slippageFee);  _updateOnTransfer(params, mooniswapFactoryGovernance.defaultDecayPeriod, _emitDecayPeriodVoteUpdate, _decayPeriod);  which leads to updateBalance being called on the same address twice, first with currentBalance - amountTransferred and then with currentBalance + amountTransferred.  code/contracts/governance/MooniswapGovernance.sol:L147-L153  if (params.from != address(0)) {  votingData.updateBalance(params.from, voteFrom, params.balanceFrom, params.balanceFrom.sub(params.amount), params.newTotalSupply, defaultValue, emitEvent);  if (params.to != address(0)) {  votingData.updateBalance(params.to, voteTo, params.balanceTo, params.balanceTo.add(params.amount), params.newTotalSupply, defaultValue, emitEvent);  Recommendation  Do not update voting power on LP token transfers where from == to.  ", "labels": ["Consensys", "Medium"], "html_url": "https://consensys.io/diligence/audits/2020/12/1inch-liquidity-protocol/"}, {"title": "5.7 Unpredictable behavior for users due to admin front running or general bad timing ", "body": "  Description  In a number of cases, administrators of contracts can update or upgrade things in the system without warning. This has the potential to violate a security goal of the system.  Specifically, privileged roles could use front running to make malicious changes just ahead of incoming transactions, or purely accidental negative effects could occur due to the unfortunate timing of changes.  In general users of the system should have assurances about the behavior of the action they re about to take.  Examples  MooniswapFactoryGovernance - Admin opportunity to lock swapFor with a referral when setting an invalid referralFeeReceiver  setReferralFeeReceiver and setGovernanceFeeReceiver takes effect immediately.  code/contracts/governance/MooniswapFactoryGovernance.sol:L92-L95  function setReferralFeeReceiver(address newReferralFeeReceiver) external onlyOwner {  referralFeeReceiver = newReferralFeeReceiver;  emit ReferralFeeReceiverUpdate(newReferralFeeReceiver);  setReferralFeeReceiver can be used to set an invalid receiver address (or one that reverts on every call) effectively rendering Mooniswap.swapFor unusable if a referral was specified in the swap.  code/contracts/Mooniswap.sol:L281-L286  if (referral != address(0)) {  referralShare = invIncrease.mul(referralShare).div(_FEE_DENOMINATOR);  if (referralShare > 0) {  if (referralFeeReceiver != address(0)) {  _mint(referralFeeReceiver, referralShare);  IReferralFeeReceiver(referralFeeReceiver).updateReward(referral, referralShare);  Locking staked token  At any point in time and without prior notice to users an admin may accidentally or intentionally add a broken governance sub-module to the system that blocks all users from unstaking their 1INCH token. An admin can recover from this by removing the broken sub-module, however, with malicious intent tokens may be locked forever.  Since 1INCH token gives voting power in the system, tokens are considered to hold value for other users and may be traded on exchanges. This raises concerns if tokens can be locked in a contract by one actor.  An admin adds an invalid address or a malicious sub-module to the governance contract that always reverts on calls to notifyStakeChanged.  code/contracts/inch/GovernanceMothership.sol:L63-L66  function addModule(address module) external onlyOwner {  require(_modules.add(module), \"Module already registered\");  emit AddModule(module);  code/contracts/inch/GovernanceMothership.sol:L73-L78  function _notifyFor(address account, uint256 balance) private {  uint256 modulesLength = _modules.length();  for (uint256 i = 0; i < modulesLength; ++i) {  IGovernanceModule(_modules.at(i)).notifyStakeChanged(account, balance);  Admin front-running to prevent user stake sync  An admin may front-run users while staking in an attempt to prevent submodules from being notified of the stake update. This is unlikely to happen as it incurs costs for the attacker (front-back-running) to normal users but may be an interesting attack scenario to exclude a whale s stake from voting.  For example, an admin may front-run stake() or notoify*() by briefly removing all governance submodules from the mothership and re-adding them after the users call succeeded. The stake-update will not be propagated to the sub-modules. A user may only detect this when they are voting (if they had no stake before) or when they actually check their stake. Such an attack might likely stay unnoticed unless someone listens for addmodule removemodule events on the contract.  An admin front-runs a transaction by removing all modules and re-adding them afterwards to prevent the stake from propagating to the submodules.  code/contracts/inch/GovernanceMothership.sol:L68-L71  function removeModule(address module) external onlyOwner {  require(_modules.remove(module), \"Module was not registered\");  emit RemoveModule(module);  Admin front-running to prevent unstake from propagating  An admin may choose to front-run their own unstake(), temporarily removing all governance sub-modules, preventing unstake() from syncing the action to sub-modules while still getting their previously staked tokens out. The governance sub-modules can be re-added right after unstaking. Due to double-accounting of the stake (in governance and in every sub-module) their stake will still be exercisable in the sub-module even though it was removed from the mothership. Users can only prevent this by manually calling a state-sync on the affected account(s).  Recommendation  The underlying issue is that users of the system can t be sure what the behavior of a function call will be, and this is because the behavior can change at any time.  We recommend giving the user advance notice of changes with a time lock. For example, make all system-parameter and upgrades require two steps with a mandatory time window between them. The first step merely broadcasts to users that a particular change is coming, and the second step commits that change after a suitable waiting period. This allows users that do not accept the change to withdraw immediately.  Furthermore, users should be guaranteed to be able to redeem their staked tokens. An entity - even though trusted - in the system should not be able to lock tokens indefinitely.  ", "labels": ["Consensys", "Medium"], "html_url": "https://consensys.io/diligence/audits/2020/12/1inch-liquidity-protocol/"}, {"title": "5.8 The owner can borrow token0/token1 in the rescueFunds ", "body": "  Description  If some random tokens/funds are accidentally transferred to the pool, the owner can call the rescueFunds function to withdraw any funds manually:  code/contracts/Mooniswap.sol:L331-L340  function rescueFunds(IERC20 token, uint256 amount) external nonReentrant onlyOwner {  uint256 balance0 = token0.uniBalanceOf(address(this));  uint256 balance1 = token1.uniBalanceOf(address(this));  token.uniTransfer(msg.sender, amount);  require(token0.uniBalanceOf(address(this)) >= balance0, \"Mooniswap: access denied\");  require(token1.uniBalanceOf(address(this)) >= balance1, \"Mooniswap: access denied\");  require(balanceOf(address(this)) >= _BASE_SUPPLY, \"Mooniswap: access denied\");  There s no restriction on which funds the owner can try to withdraw and which token to call. It s theoretically possible to transfer pool tokens and then return them to the contract (e.g. in the case of ERC-777). That action would be similar to a free flash loan.  Recommendation  Explicitly check that the token is not equal to any of the pool tokens.  ", "labels": ["Consensys", "Minor"], "html_url": "https://consensys.io/diligence/audits/2020/12/1inch-liquidity-protocol/"}, {"title": "7.1 Permissionless nature of proxy factory might cause confusion when parsing events  ", "body": "  Resolution  Update from the iExec team:  The iExec offchain platform does not listen to GenericFactory. This factory is intended to be public and available to anyone and is just a tool used for deployment.  Description  The permissionless nature of the factory (the GenericFactory contract) meant to deploy the ERC1538Proxy and the instances of its several delegates might create confusion when parsing events.  Since there is no access control being enforced through the use of modifiers on said factory, any account can use its deployment public methods to deploy a contract. This means that the supporting off-chain infrastructure making use of the fired events to look for deployed instances of either the iExec proxies or its delegates might get hindered by an ill-intended actor that abuses its functions.  Recommendation  Use a modifier enforcing some sort of access control (easily done through the inherited Ownable contract) to make sure only iExec can deploy from the factory and, therefore, increase the readability of logged events.  This becomes more important as time goes by and updates to the architecture are performed or any past analysis needs to be done on deployed modules.  ", "labels": ["Consensys", "Acknowledged"], "html_url": "https://consensys.io/diligence/audits/2020/03/iexec-poco/"}, {"title": "7.2 System deployer is fully trusted in this version of the PoCo system   ", "body": "  Resolution  Update from the iExec team:  After deployment, ownership is planned to be transferred to a multisig. This is just the first step towards a more decentralised governance on the protocol. We will consider adding an intermediary contract that enforces the lock period. This would however, prevent us from any kind of  emergency  update. The long term goal is it involve the community in the process, using a DAO or a similar solution.  Description  The introduction of ERC1538-compliant proxies to construct the PoCo system has many benefits. It heightens modularity, reduces the number of external calls between the system s components and allows for easy expansion of the system s capabilities without disruption of the service or need for off-chain infrastructure upgrade. However, the last enumerated benefit is in fact a double-edged sword.  Even though ERC1538 enables easy upgradeability it also completely strips the PoCo system of all of its prior trustless nature. In this version the iExec development team should be entirely trusted by every actor in the system not to change the deployed on-chain delegates for new ones.  Also the deployer, owner, has permission to change some of the system variables, such as m_callbackgas for Oracle callback gas limit. This indirectly can lock the system, for example it could result in IexecPocoDelegate.executeCallback() reverting which prevents the finalization of corresponding task.  Recommendation  The best, easiest solution for the trust issue would be to immediately revoke ownership of the proxy right after deployment. This way the modular deployment would still be possible but no power to change the deployed on-chain code would exist.  A second best solution would be to force a timespan period before any change to the proxy methods (and its delegates) is made effective. This way any actor in the system can still monitor for possible changes and  leave  the system before they are implemented.  In this last option the  lock  period should, obviously, be greater than the amount of time it takes to verify a Task of the bigger category but it is advisable to decide on it by anthropomorphic rules and use a longer,  human-friendly  time lock of, for example, 72 hours.  ", "labels": ["Consensys", "Medium", "Acknowledged"], "html_url": "https://consensys.io/diligence/audits/2020/03/iexec-poco/"}, {"title": "7.3 importScore() in IexecMaintenanceDelegate can be used to wrongfully reset worker scores   ", "body": "  Resolution  Update from the iExec team:  In order to perform this attack, one would first have to gain reputation on the new version, and lose it. They would then be able to restore its score from the old version.  We feel the risk is acceptable for a few reasons:  It can only be done once per worker  Considering the score dynamics discussed in the  Trust in the PoCo  document, it is more interesting for a worker to import its reputation in the beginning rather then creating a new one, since bad contributions only remove part of the reputation  Only a handful of workers have reputation in the old system (180), and their score is low (average 7, max 22)  We might force the import all 180 workers with reputation >0. A script to identify the relevant addresses is already available.  Description  The import of worker scores from the previous PoCo system deployed on chain is made to be asynchronous. And, even though the pull pattern usually makes a system much more resilient, in this case, it opens up the possibility for an attack that undermines the trust-based game-theoretical balance the PoCo system relies on. As can be seen in the following function:  code/poco-dev/contracts/modules/delegates/IexecMaintenanceDelegate.sol:L51-L57  function importScore(address _worker)  external override  require(!m_v3_scoreImported[_worker], \"score-already-imported\");  m_workerScores[_worker] = m_workerScores[_worker].max(m_v3_iexecHub.viewScore(_worker));  m_v3_scoreImported[_worker] = true;  A motivated attacker could attack the system providing bogus results for computation tasks therefore reducing his own reputation (mirrored by the low worker score that would follow).  After the fact, the attacker could reset its score to the previous high value attained in the previously deployed PoCo system (v3) and undo all the wrongdoings he had done at no reputational cost.  Recommendation  Check that each worker interacting with the PoCo system has already imported his score. Otherwise import it synchronously with a call at the time of their first interaction.  ", "labels": ["Consensys", "Medium", "Acknowledged"], "html_url": "https://consensys.io/diligence/audits/2020/03/iexec-poco/"}, {"title": "7.4 Outdated documentation   ", "body": "  Resolution   Update from the iExec team:   Description  There are many changes within the system from the initial version that are not reflected in the documentation.  It is necessary to have updated documentation for the time of the audit, as the specification dictates the correct behaviour of the code base.  Examples  Entities such as iExecClerk are the main point of entry in the documentation, however they have been replaced by proxy implementation in the code base (V5).  Recommendation  Up date documentation to reflect the recent changes and design in the code base.  ", "labels": ["Consensys", "Medium", "Acknowledged"], "html_url": "https://consensys.io/diligence/audits/2020/03/iexec-poco/"}, {"title": "7.5 Domain separator in iExecMaintenanceDelegate has a wrong version field   ", "body": "  Resolution   Issue was fixed in   iExecBlockchainComputing/PoCo-dev@ebee370  Description  The domain separator used to comply with the EIP712 standard in iExecMaintenanceDelegate has a wrong version field.  code/poco-dev/contracts/modules/delegates/IexecMaintenanceDelegate.sol:L77-L86  function _domain()  internal view returns (IexecLibOrders_v5.EIP712Domain memory)  return IexecLibOrders_v5.EIP712Domain({  name:              \"iExecODB\"  , version:           \"3.0-alpha\"  , chainId:           _chainId()  , verifyingContract: address(this)  });  In the above snippet we can see the code is still using the version field from an old version of the PoCo protocol, \"3.0-alpha\".  Recommendation  Change the version field to: \"5.0-alpha\"  ", "labels": ["Consensys", "Medium", "Acknowledged"], "html_url": "https://consensys.io/diligence/audits/2020/03/iexec-poco/"}, {"title": "7.6 Limit the length of task.contributors to prevent reaching gasBlockLimit   ", "body": "  Resolution  Update from the iExec team:  Any hardcoded lock would be a restriction in the future if thee block size increases. In addition to that, workers are strongly incentivised to not contribute if it would result in a deadlocked task. Schedulers are incentivised to not authorise too many workers to contribute (they also lose stake if a task get deadlocked). So the development team has assessed the risk as low.  In the unlikely event the described flaw still happens, the task will get in a deadlocked state, until at some point the block size limit is increased and a claim becomes possible. Because in a world where block size increases are possible, deadlocks are not eternal.  Description  It is recommended to limit the length of arrays that the contract iterates through to prevent system halts. task.contributors is used within iExec contract in many functions, and main functions such as claim(), reOpen(), and most importantly contribute() (through calling checkConsensus()) iterate through this list.  Given that contributions are not free and they could only block the task they are contributing to, this is a low impact issue.  Recommendation  The fix is trivial to implement and only requires to limit the number of items in task.contributors to the maximum imagined for the system (based on client communication this number could be 20, although further testing should be done to make sure with this number does not reach the blockGasLimit, possibly with future changes in the opcode pricing).  ", "labels": ["Consensys", "Minor", "Acknowledged"], "html_url": "https://consensys.io/diligence/audits/2020/03/iexec-poco/"}, {"title": "7.7 The updateContract() method in ERC1538UpdateDelegate is incorrectly implemented ", "body": "  Resolution   Issue was fixed in   iExecBlockchainComputing/iexec-solidity@e6be083  Description  The updateContract() method in ERC1538UpdateDelegate does not behave as intended for some specific streams of bytes (meant to be parsed as function signatures).  The mentioned function takes as input, among other things, a string (which is, canonically, a dynamically-sized bytes array) and tries to parse it as a conjunction of function signatures.  As is evident in:  code/iexec-solidity/contracts/ERC1538/ERC1538Update.sol:L39  if (char == 0x3B) // 0x3B = ';'  Inside the function, ; is being used as a  reserved  character, serving as a delimiter between each function signature.  However, if two semicolons are used in succession, the second one will not be checked and will be made part of the function signature being sent into the _setFunc() method.  Example of faulty input  someFunc;;someOtherFuncWithSemiColon;  Recommendation  Replace the line that increases the pos counter at the end of the function:  code/iexec-solidity/contracts/ERC1538/ERC1538Update.sol:L47  start = ++pos;  WIth this line of code:  start = pos + 1;  ", "labels": ["Consensys", "Minor"], "html_url": "https://consensys.io/diligence/audits/2020/03/iexec-poco/"}]