[{"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-runes-findings/issues/36", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-runes-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-runes-findings/issues/35", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-runes-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-runes-findings/issues/29", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-runes-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-runes-findings/issues/28", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-runes-findings", "body": "QA Report"}, {"title": "Many unbounded and under-constrained variables in the system can lead to unfair price or DoS", "html_url": "https://github.com/code-423n4/2022-05-runes-findings/issues/27", "labels": ["bug", "2 (Med Risk)"], "target": "2022-05-runes-findings", "body": "Many unbounded and under-constrained variables in the system can lead to unfair price or DoS"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-runes-findings/issues/21", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-runes-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-runes-findings/issues/20", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-runes-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-runes-findings/issues/18", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-runes-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-runes-findings/issues/17", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-runes-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-runes-findings/issues/16", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-runes-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-runes-findings/issues/13", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-runes-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-runes-findings/issues/12", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-runes-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-runes-findings/issues/9", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-runes-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-runes-findings/issues/7", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-runes-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-runes-findings/issues/4", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-runes-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-runes-findings/issues/3", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-runes-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-runes-findings/issues/1", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-runes-findings", "body": "Gas Optimizations"}, {"title": "Agreements & Disclosures", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/230", "labels": [], "target": "2022-05-alchemix-findings", "body": "Agreements & Disclosures"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/228", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-alchemix-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/226", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-alchemix-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/225", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-alchemix-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/224", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-alchemix-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/223", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-alchemix-findings", "body": "QA Report"}, {"title": "TransmuterBuffer.sol calls depositUnderlying with no slippage bounds ", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/222", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-05-alchemix-findings", "body": "TransmuterBuffer.sol calls depositUnderlying with no slippage bounds "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/221", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-alchemix-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/220", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-alchemix-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/219", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-alchemix-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/218", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-alchemix-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/216", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-alchemix-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/215", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-alchemix-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/214", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-alchemix-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/213", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-alchemix-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/212", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-alchemix-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/211", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-alchemix-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/205", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-alchemix-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/204", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-alchemix-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/202", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-alchemix-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/201", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-alchemix-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/200", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-alchemix-findings", "body": "QA Report"}, {"title": "[gALCX.sol] Attacker can make the contract unusable when totalSupply is 0", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/198", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-05-alchemix-findings", "body": "[gALCX.sol] Attacker can make the contract unusable when totalSupply is 0"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/197", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-alchemix-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/196", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-alchemix-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/195", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-alchemix-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/193", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-alchemix-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/188", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-alchemix-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/179", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-alchemix-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/177", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-alchemix-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/176", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-alchemix-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/175", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-alchemix-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/174", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-alchemix-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/173", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-alchemix-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/172", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-alchemix-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/171", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-alchemix-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/170", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-alchemix-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/169", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-alchemix-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/168", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-alchemix-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/167", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-alchemix-findings", "body": "QA Report"}, {"title": "Alchemist can mint `AlTokens` above their assigned ceiling by calling `lowerHasMinted()`", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/166", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-alchemix-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/AlchemicTokenV2Base.sol#L111-L124 https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/AlchemicTokenV2Base.sol#L189-L191   # Vulnerability details  ## Impact An alchemist / user can mint more than their alloted amount of AlTokens by calling `lowerHasMinted()` before they reach their minting cap.  ## Proof of Concept Function `mint()` in `AlchemicTokenV2Base.sol`  ```solidity   function mint(address recipient, uint256 amount) external onlyWhitelisted {     if (paused[msg.sender]) {       revert IllegalState();     }      uint256 total = amount + totalMinted[msg.sender];     if (total > mintCeiling[msg.sender]) {       revert IllegalState();     }      totalMinted[msg.sender] = total;      _mint(recipient, amount);   } ``` Note the require conditional check that `total > mintCeiling[msg.sender]`.  In the same contract, there is the function `lowerHasMinted()` with the same permission level as mint and is thus callable by the same user as well. ```solidity   function lowerHasMinted(uint256 amount) external onlyWhitelisted {     totalMinted[msg.sender] = totalMinted[msg.sender] - amount;   } ```  It is clear that a user can accumulate an infinite (within supply) amount of AlTokens by calling `lowerHasMinted()` before any action that would make them exceed their minting cap.  ## Tools Used Manual review, VScode  ## Recommended Mitigation Steps Change the permissioning on `lowerHasMinted()` to be restricted to a higher permissioned role like `onlySentinel()` , or deprecate this function as I could not find any uses of it throughout the codebase or in tests.  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/165", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-alchemix-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/164", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-alchemix-findings", "body": "Gas Optimizations"}, {"title": "[WP-H1] Debt can be repaid with a depegged underlyingToken, which can be exploited by arbitrageurs and drives the market price of alToken to match the worst depegged underlyingToken", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/161", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor acknowledged"], "target": "2022-05-alchemix-findings", "body": "[WP-H1] Debt can be repaid with a depegged underlyingToken, which can be exploited by arbitrageurs and drives the market price of alToken to match the worst depegged underlyingToken"}, {"title": "DoS in wrap and unwrap", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/159", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-alchemix-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/adapters/fuse/FuseTokenAdapterV1.sol#L76 https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/adapters/fuse/FuseTokenAdapterV1.sol#L98   # Vulnerability details  ## Impact the code is doing wrong check, so when things will work it will revert.   ## Proof of Concept In the function `wrap()` there is this lines: ```    if ((error = ICERC20(token).mint(amount)) != NO_ERROR) {             revert FuseError(error);         } ``` but `mint` returns the amount that minted, so when `error = amount` the check will fail even though it worked good.  Same in `unwrap`: ``` if ((error = ICERC20(token).redeem(amount)) != NO_ERROR) {             revert FuseError(error);         } ``` the redeem returns the amount.   ## Recommended Mitigation Steps  I recommend to change the lines like this:     in wrap:     ```      if ((error = ICERC20(token).mint(amount)) != amount) {             revert FuseError(error);         }     ```     and in unwrap:     ```     if ((error = ICERC20(token).redeem(amount)) != amount) {             revert FuseError(error);         }     ```   "}, {"title": "A well financed attacker could prevent any other users from minting synthetic tokens", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/155", "labels": ["bug", "2 (Med Risk)"], "target": "2022-05-alchemix-findings", "body": "A well financed attacker could prevent any other users from minting synthetic tokens"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/154", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-alchemix-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/153", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-alchemix-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/152", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-alchemix-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/151", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-alchemix-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/148", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-alchemix-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/146", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-alchemix-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/145", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-alchemix-findings", "body": "Gas Optimizations"}, {"title": "AutoleverageBase: Must approve 0 first", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/144", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-alchemix-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-alchemix/blob/71abbe683dfd5c0686b7e594fb4f78a14b668d8b/contracts-full/AutoleverageBase.sol#L61-L63   # Vulnerability details  ## Impact Some tokens (like USDT) do not work when changing the allowance from an existing non-zero allowance value.They must first be approved by zero and then the actual allowance must be approved. ## Proof of Concept https://github.com/code-423n4/2022-05-alchemix/blob/71abbe683dfd5c0686b7e594fb4f78a14b668d8b/contracts-full/AutoleverageBase.sol#L61-L63 https://github.com/code-423n4/2022-05-alchemix/blob/71abbe683dfd5c0686b7e594fb4f78a14b668d8b/contracts-full/AutoleverageBase.sol#L147-L147 https://github.com/code-423n4/2022-05-alchemix/blob/71abbe683dfd5c0686b7e594fb4f78a14b668d8b/contracts-full/AutoleverageBase.sol#L178-L179 ## Tools Used None ## Recommended Mitigation Steps ```     function approve(address token, address spender) internal {     +  IERC20(token).approve(spender, 0);         IERC20(token).approve(spender, type(uint256).max);     } ```  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/143", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-alchemix-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/142", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-alchemix-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/139", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-alchemix-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/138", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-alchemix-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/137", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-alchemix-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/136", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-alchemix-findings", "body": "QA Report"}, {"title": "New gALCX token denomination can be depressed by the first depositor", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/135", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-05-alchemix-findings", "body": "New gALCX token denomination can be depressed by the first depositor"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/133", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-alchemix-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/130", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-alchemix-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/129", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-alchemix-findings", "body": "Gas Optimizations"}, {"title": "TransmuterBuffer's _alchemistWithdraw use hard coded slippage that can lead to user losses", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/127", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-05-alchemix-findings", "body": "TransmuterBuffer's _alchemistWithdraw use hard coded slippage that can lead to user losses"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/126", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-alchemix-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/125", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-alchemix-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/124", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-alchemix-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/119", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-alchemix-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/118", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-alchemix-findings", "body": "Gas Optimizations"}, {"title": "TransmuterBuffer's setAlchemist will freeze deposited funds", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/117", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-alchemix-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/TransmuterBuffer.sol#L230-L248   # Vulnerability details  Currently setAlchemist doesn't check whether there are any open positions left with the old Alchemist before switching to the new one.  As this require a number of checks the probability of operational mistake isn't low and it's prudent to introduce the main controls directly to the code to minimize it. In the case if the system go on with new Alchemist before realizing that there are some funds left in the old one, tedious and error prone manual recovery will be needed. There is also going to be a corresponding reputational damage.  Setting the severity to medium as while the function is admin only, the impact is up to massive user fund freeze, i.e. this is system breaking with external assumptions.  ## Proof of Concept  Alchemist implementation change can happen while there are open deposits remaining with the current contract. As there looks to be no process to transfer them in the code, such TransmuterBuffer's funds will be frozen with old alchemist:  https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-hardhat/TransmuterBuffer.sol#L230-L232  ```solidity     function setAlchemist(address _alchemist) external override onlyAdmin {         sources[alchemist] = false;         sources[_alchemist] = true; ```  ## Recommended Mitigation Steps  Consider requiring that all exposure to the old Alchemist is closed, for example both `getAvailableFlow` and `getTotalCredit` is zero.  https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/TransmuterBuffer.sol#L230-L231  ```solidity     function setAlchemist(address _alchemist) external override onlyAdmin { +    require(getTotalCredit() == 0, \"Credit exists with old Alchemist\"); +       for (uint256 j = 0; j < registeredUnderlyings.length; j++) { +           require(getTotalUnderlyingBuffered[registeredUnderlyings[j]] == 0, \"Buffer exists with old Alchemist\"); +       }         sources[alchemist] = false; ```  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/116", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-alchemix-findings", "body": "QA Report"}, {"title": "registerAsset misuse can permanently disable TransmuterBuffer and break the system", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/113", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-05-alchemix-findings", "body": "registerAsset misuse can permanently disable TransmuterBuffer and break the system"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/110", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-alchemix-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/105", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-alchemix-findings", "body": "Gas Optimizations"}, {"title": "If `totalShares` for a token falls to zero while there is `pendingCredit` the contract will become stuck", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/104", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-alchemix-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/AlchemistV2.sol#L1290-L1300 https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/AlchemistV2.sol#L1268 https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/AlchemistV2.sol#L1532 https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/AlchemistV2.sol#L899 https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/AlchemistV2.sol#L1625   # Vulnerability details  ## Impact  It is possible for the contract to become stuck and unable to perform any actions if the `totalShares` of a yield token fall to zero while there is some `pendingCredit` still to be paid.  It will then be impossible to call deposit or withdraw functions, mints, burns, repay, liquidate, donate or harvest due to division by zero reverts in:  - `_distributeCredit()` - `_distributeUnlockedCredit()` - `_calculateUnrealizedDebt()` - `_convertSharesToYieldTokens()` - `donate()`  Furthermore, any `pendingCredit` amount of tokens are still in the contract will become permanently stuck.  ## Proof of Concept  This case may arise under the follow steps a) `deposit()` is called by a user then time passes to earn some yield b) `harvest()` is called by the keeper which calls `_distributeCredit()` and increases `pendingCredit` c) `withdraw()` is called by the user to withdraw all funds  Since there is `pendingCredit` the following will have a non-zero balance for `unlockedCredit` however `yieldTokenParams.totalShares` is zero and thus we get a division by zero which reverts the entire transaction.  ```solidity     function _distributeUnlockedCredit(address yieldToken) internal {         YieldTokenParams storage yieldTokenParams = _yieldTokens[yieldToken];           uint256 unlockedCredit = _calculateUnlockedCredit(yieldToken);         if (unlockedCredit == 0) {             return;         }           yieldTokenParams.accruedWeight     += unlockedCredit * FIXED_POINT_SCALAR / yieldTokenParams.totalShares;         yieldTokenParams.distributedCredit += unlockedCredit;     } ```  Each of the other listed functions will reach the same issue by attempting to divide some numerator by the `totalShares` which is zero.  ## Recommended Mitigation Steps  Consider preventing `totalShares` from over becoming zero once it is set. That is enforce a user to leave at least 1 unit if they are the last user to withdraw.  Another option is to transfer the first 1000 shares to a \"burn\" account (e.g. 0x000...01), when the first user deposits.  Alternatively, when the last user withdraws, transfer all pending credit to this user and set the required variables to zero to replicate the state before any users have deposited.  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/103", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-05-alchemix-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/101", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-alchemix-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/100", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-alchemix-findings", "body": "Gas Optimizations"}, {"title": "YearnTokenAdapter's wrap can become stuck as it uses one step approval for an arbitrary underlying", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/99", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-alchemix-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/adapters/yearn/YearnTokenAdapter.sol#L30-L32   # Vulnerability details  Some tokens do not allow for approval of positive amount when allowance is positive already (to handle approval race condition, most known example is USDT).  This can cause the function to stuck whenever a combination of such a token and leftover approval be met. The latter can be possible if, for example, yearn vault is becoming full on a particular wrap() call and accepts only a part of amount, not utilizing the approval fully.  Then each next safeApprove will revert and wrap becomes permanently unavailable. Setting the severity to medium as depositing (wrapping) is core functionality for the contract and its availability is affected.  ## Proof of Concept  wrap use one step approve:  https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/adapters/yearn/YearnTokenAdapter.sol#L30-L32  ```solidity     function wrap(uint256 amount, address recipient) external override returns (uint256) {         TokenUtils.safeTransferFrom(underlyingToken, msg.sender, address(this), amount);         TokenUtils.safeApprove(underlyingToken, token, amount); ```  Some ERC20 forbid the approval of positive amount when the allowance is positive:  https://github.com/d-xo/weird-erc20#approval-race-protections  For example, USDT is supported by Yearn and can be the underlying asset:  https://yearn.finance/#/vault/0x7Da96a3891Add058AdA2E826306D812C638D87a7  ## Recommended Mitigation Steps  As the most general approach consider approving zero before doing so for the amount:  ```solidity     function wrap(uint256 amount, address recipient) external override returns (uint256) {         TokenUtils.safeTransferFrom(underlyingToken, msg.sender, address(this), amount); +      TokenUtils.safeApprove(underlyingToken, token, 0);         TokenUtils.safeApprove(underlyingToken, token, amount); ```  "}, {"title": "Lido adapter incorrectly calculates the price of the underlying token", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/97", "labels": ["bug", "2 (Med Risk)"], "target": "2022-05-alchemix-findings", "body": "Lido adapter incorrectly calculates the price of the underlying token"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/96", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-alchemix-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/95", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-alchemix-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/94", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-alchemix-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/93", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-alchemix-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/92", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-alchemix-findings", "body": "QA Report"}, {"title": "Gas Optimization", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/91", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-alchemix-findings", "body": "Gas Optimization"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/90", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-alchemix-findings", "body": "QA Report"}, {"title": "Gas Optimization", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/89", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-alchemix-findings", "body": "Gas Optimization"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/86", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-alchemix-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/85", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-alchemix-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/84", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-alchemix-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/83", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-alchemix-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/82", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-alchemix-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/81", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-alchemix-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/70", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-05-alchemix-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/66", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-alchemix-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/65", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-alchemix-findings", "body": "QA Report"}, {"title": "EthAssetManager and ThreePoolAssetManager don't control Meta tokens decimals", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/63", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-alchemix-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/ThreePoolAssetManager.sol#L896-L905 https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/EthAssetManager.sol#L566-L573   # Vulnerability details  Both contracts treat meta assets as if they have fixed decimals of 18. Minting logic breaks when it's not the case. However, meta tokens decimals aren't controlled.  If actual meta assets have any other decimals, minting slippage control logic of both contracts will break up as `total` is calculated as a plain sum of token amounts.  In the higher token decimals case `minTotalAmount` will be magnitudes higher than actual amount Curve can provide and minting becomes unavailable.  In the lower token decimals case `minTotalAmount` will lack value and slippage control will be rendered void, which opens up a possibility of a fund loss from the excess slippage.  Setting severity to medium as the contract can be used with various meta tokens (`_metaPoolAssetCache`  can be filled with any assets) and, whenever decimals differ from 18 `add_liquidity` uses, its logic be broken: the inability to mint violates the contract purpose, the lack of slippage control can lead to fund losses.  I.e. this is system breaking impact conditional on a low probability assumption of different meta token decimals.  ## Proof of Concept  Meta tokens decimals are de facto hard coded into the contract as plain amounts are used (L. 905):  https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/ThreePoolAssetManager.sol#L896-L905  ```solidity     function _mintMetaPoolTokens(         uint256[NUM_META_COINS] calldata amounts     ) internal returns (uint256 minted) {         IERC20[NUM_META_COINS] memory tokens = _metaPoolAssetCache;          uint256 total = 0;         for (uint256 i = 0; i < NUM_META_COINS; i++) {             if (amounts[i] == 0) continue;              total += amounts[i]; ```  https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/ThreePoolAssetManager.sol#L915-L919  ```solidity         uint256 expectedOutput    = total * CURVE_PRECISION / metaPool.get_virtual_price();         uint256 minimumMintAmount = expectedOutput * metaPoolSlippage / SLIPPAGE_PRECISION;          // Add the liquidity to the pool.         minted = metaPool.add_liquidity(amounts, minimumMintAmount); ```  The same plain sum approach is used in EthAssetManager._mintMetaPoolTokens:  https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/EthAssetManager.sol#L566-L573  ```solidity         uint256 total = 0;         for (uint256 i = 0; i < NUM_META_COINS; i++) {             // Skip over approving WETH since we are directly swapping ETH.             if (i == uint256(MetaPoolAsset.ETH)) continue;              if (amounts[i] == 0) continue;              total += amounts[i]; ```  When this decimals assumption doesn't hold, the slippage logic will not hold too: either the mint be blocked or slippage control disabled.  Notice, that ThreePoolAssetManager.calculateRebalance do query alUSD decimals (which is inconsistent with the above as it\u2019s either fix and control on inception or do not fix and accommodate the logic):  https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/ThreePoolAssetManager.sol#L338-L338  ```solidity decimals     = SafeERC20.expectDecimals(address(alUSD)); ```  ## Recommended Mitigation Steps  If meta assets are always supposed to have fixed decimals of 18, consider controlling it at the construction time.  I.e. the decimals can be controlled in constructors:  https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/EthAssetManager.sol#L214-L219  ```solidity         for (uint256 i = 0; i < NUM_META_COINS; i++) {             _metaPoolAssetCache[i] = params.metaPool.coins(i);             if (_metaPoolAssetCache[i] == IERC20(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)) {                 _metaPoolAssetCache[i] = weth; +           } else { +            // check the decimals     }         } ```  https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/ThreePoolAssetManager.sol#L254-L256  ```solidity         for (uint256 i = 0; i < NUM_META_COINS; i++) {             _metaPoolAssetCache[i] = params.metaPool.coins(i); +           // check the decimals                     } ```  In this case further decimals reading as it's done in calculateRebalance() is redundant.  Otherwise (which is less recommended as fixed decimals assumption is viable and simplify the logic) the meta token decimals can be added to calculations similarly to stables:  https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/ThreePoolAssetManager.sol#L779-L779  ```solidity normalizedTotal += amounts[i] * 10**missingDecimals; ```  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/62", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-alchemix-findings", "body": "QA Report"}, {"title": "YearnTokenAdapter allows a maximum loss of 100% when withdrawing", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/60", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-05-alchemix-findings", "body": "YearnTokenAdapter allows a maximum loss of 100% when withdrawing"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/57", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-alchemix-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/56", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-alchemix-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/50", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-alchemix-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/49", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-alchemix-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/46", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-alchemix-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/45", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-alchemix-findings", "body": "Gas Optimizations"}, {"title": "No Storage Gap for Upgradeable Contract Might Lead to Storage Slot Collision", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/44", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-alchemix-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/AlchemicTokenV2Base.sol#L20 https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/CrossChainCanonicalBase.sol#L12 https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/TransmuterV2.sol#L26 https://github.com/code-423n4/2022-05-alchemix/blob/de65c34c7b6e4e94662bf508e214dcbf327984f4/contracts-full/CrossChainCanonicalAlchemicTokenV2.sol#L7   # Vulnerability details  ## Impact  For upgradeable contracts, there must be storage gap to \"allow developers to freely add new state variables in the future without compromising the storage compatibility with existing deployments\" (quote OpenZeppelin). Otherwise it may be very difficult to write new implementation code. Without storage gap, the variable in child contract might be overwritten by the upgraded base contract if new variables are added to the base contract. This could have unintended and very serious consequences to the child contracts, potentially causing loss of user fund or cause the contract to malfunction completely.  Refer to the bottom part of this article: https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable   ## Proof of Concept  Several contracts are intended to be upgradeable contracts in the code base, including  - AlchemicTokenV2Base - CrossChainCanonicalBase - CrossChainCanonicalAlchemicTokenV2 - TransmuterV2  However, none of these contracts contain storage gap. The storage gap is essential for upgradeable contract because \"It allows us to freely add new state variables in the future without compromising the storage compatibility with existing deployments\". Refer to the bottom part of this article:  https://docs.openzeppelin.com/contracts/3.x/upgradeable  As an example, both the `AlchemicTokenV2Base` and the `CrossChainCanonicalBase` are intended to act as the base contracts in the project. If the contract inheriting the base contract contains additional variable, then the base contract cannot be upgraded to include any additional variable, because it would overwrite the variable declared in its child contract. This greatly limits contract upgradeability.    ## Tools Used  Manual review  ## Recommended Mitigation Steps  Recommend adding appropriate storage gap at the end of upgradeable contracts such as the below. Please reference OpenZeppelin upgradeable contract templates.  ```solidity uint256[50] private __gap; ```  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/32", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-alchemix-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-alchemix-findings/issues/28", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-alchemix-findings", "body": "Gas Optimizations"}, {"title": "Agreements & Disclosures", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/344", "labels": [], "target": "2022-05-cally-findings", "body": "Agreements & Disclosures"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/311", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-cally-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/307", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-cally-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/304", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-cally-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/303", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-cally-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/301", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-cally-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/296", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-cally-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/295", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-cally-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/294", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-cally-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/293", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-cally-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/292", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-cally-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/291", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-cally-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/290", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-cally-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/287", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-cally-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/286", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-cally-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/284", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-cally-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/283", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-cally-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/281", "labels": ["bug", "QA (Quality Assurance)", "QA - High quality report"], "target": "2022-05-cally-findings", "body": "QA Report"}, {"title": "Divide before multiply", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/280", "labels": ["bug", "disagree with severity", "QA (Quality Assurance)"], "target": "2022-05-cally-findings", "body": "Divide before multiply"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/279", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-cally-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/278", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-cally-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/276", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-cally-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/273", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-cally-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/268", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-cally-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/267", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-cally-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/266", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-cally-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/265", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-cally-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/264", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-cally-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/261", "labels": ["bug", "G (Gas Optimization)", "Gas Report - High quality report"], "target": "2022-05-cally-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/260", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-cally-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/259", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-cally-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/256", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-cally-findings", "body": "Gas Optimizations"}, {"title": "`createVault()` does not confirm whether `tokenType` and `token`\u2019s type are the same", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/243", "labels": ["bug", "2 (Med Risk)", "disagree with severity"], "target": "2022-05-cally-findings", "body": "`createVault()` does not confirm whether `tokenType` and `token`\u2019s type are the same"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/233", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-cally-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/232", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-cally-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/231", "labels": ["bug", "G (Gas Optimization)", "Gas Report - High quality report"], "target": "2022-05-cally-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/230", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-cally-findings", "body": "Gas Optimizations"}, {"title": "[WP-H0] Fake balances can be created for not-yet-existing ERC20 tokens, which allows attackers to set traps to steal funds from future users", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/225", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2022-05-cally-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L158-L201   # Vulnerability details  https://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L158-L201  ```solidity function createVault(     uint256 tokenIdOrAmount,     address token,     ... ) external returns (uint256 vaultId) {     ...     Vault memory vault = Vault({         ...     });      // vault index should always be odd     vaultIndex += 2;     vaultId = vaultIndex;     _vaults[vaultId] = vault;      // give msg.sender vault token     _mint(msg.sender, vaultId);      emit NewVault(vaultId, msg.sender, token);      // transfer the NFTs or ERC20s to the contract     vault.tokenType == TokenType.ERC721         ? ERC721(vault.token).transferFrom(msg.sender, address(this), vault.tokenIdOrAmount)         : ERC20(vault.token).safeTransferFrom(msg.sender, address(this), vault.tokenIdOrAmount); } ```  https://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L23-L34  ```solidity import \"solmate/utils/SafeTransferLib.sol\";  ...  contract Cally is CallyNft, ReentrancyGuard, Ownable {     using SafeTransferLib for ERC20;     ... ```  When creating a new vault, solmate's `SafeTransferLib` is used for pulling `vault.token` from the caller's account, this issue won't exist if OpenZeppelin's SafeERC20 is used instead.  That's because there is a subtle difference between the implementation of solmate's `SafeTransferLib` and OZ's `SafeERC20`:  OZ's `SafeERC20` checks if the token is a contract or not, solmate's `SafeTransferLib` does not.  See: https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeTransferLib.sol#L9  > Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.  As a result, when the token's address has no code, the transaction will just succeed with no error.  This attack vector was made well-known by the qBridge hack back in Jan 2022.  For our project, this alone still won't be a problem, a vault created and wrongfully accounted for a certain amount of balance for a non-existing token won't be much of a problem, there will be no fund loss as long as the token stays that way (being non-existing).  However, it's becoming popular for protocols to deploy their token across multiple networks and when they do so, a common practice is to deploy the token contract from the same deployer address and with the same nonce so that the token address can be the same for all the networks.  For example: $1INCH is using the same token address for both Ethereum and BSC; Gelato's $GEL token is using the same token address for Ethereum, Fantom and Polygon.  A sophisticated attacker can exploit it by taking advantage of that and setting traps on multiple potential tokens to steal from the future users that deposits with such tokens.  ### PoC  Given:  - ProjectA has TokenA on another network; - ProjectB has TokenB on another network; - ProjectC has TokenC on another network;  1. The attacker `createVault()` for `TokenA`, `TokenB`, and `TokenC` with `10000e18` as `tokenIdOrAmount` each; 2. A few months later, ProjectB lunched `TokenB` on the local network at the same address; 3. Alice created a vault with `11000e18 TokenB`; 4. The attacker called `initiateWithdraw()` and then `withdraw()` to receive `10000e18 TokenB`.  In summary, one of the traps set by the attacker was activated by the deployment of  `TokenB` and Alice was the victim. As a result, `10000e18 TokenB` was stolen by the attacker.  ### Recommendation  Consider using OZ's `SafeERC20` instead.  "}, {"title": "It shouldn\u2019t be possible to create a vault with Cally\u2019 own token", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/224", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2022-05-cally-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-cally/blob/main/contracts/src/Cally.sol#L193 https://github.com/code-423n4/2022-05-cally/blob/main/contracts/src/Cally.sol#L199   # Vulnerability details  ## Impact  Affected code:  - [https://github.com/code-423n4/2022-05-cally/blob/main/contracts/src/Cally.sol#L193](https://github.com/code-423n4/2022-05-cally/blob/main/contracts/src/Cally.sol#L193) - [https://github.com/code-423n4/2022-05-cally/blob/main/contracts/src/Cally.sol#L199](https://github.com/code-423n4/2022-05-cally/blob/main/contracts/src/Cally.sol#L199)  Currently it\u2019s possible to create an ERC-721 vault using Cally\u2019 own address as `token`, and using the freshly minted vault id as `tokenIdOrAmount`. This results in a new vault whose ownership is passed to Cally contract immediately upon creation.  The vault allows users to perform `buyOption` and increase the ETH balance of the Cally contract itself, which is still the vault beneficiary. As soon as an user calls `exercise`, she will receive the `vault.tokenIdOrAmount` in exchange, which in this case coincides with the vault nft. However this is of no good because the final user may just initiate a withdrawal, which will:  - always fail because the vault id is burned ([https://github.com/code-423n4/2022-05-cally/blob/main/contracts/src/Cally.sol#L335](https://github.com/code-423n4/2022-05-cally/blob/main/contracts/src/Cally.sol#L335)) and then transferred back to the user ([https://github.com/code-423n4/2022-05-cally/blob/main/contracts/src/Cally.sol#L344](https://github.com/code-423n4/2022-05-cally/blob/main/contracts/src/Cally.sol#L344)) - leave all the ETH unredemable in Cally contract  So the vault will be unusable and the ETH deposited by users to buy/exercise options will remain locked in Cally contract  ## Proof of Concept  - Current vault id is, let\u2019s say, 11 - User deploys a vault with Cally\u2019 address as `token` and `13` as `tokenIdOrAmount` - Since `createVault()` mints the vault token to the user, and then transfers the underlying address from the user, an user is able to create a vault with something she doesn\u2019t own at the moment of the `createVault()` function call, because it\u2019s created while the function runs - The vault `13` is pretty limited in functionality, because Cally\u2019 smart contract is the owner - However, users can still buy options: so Alice and Bob deposit their premiums - Whoever `exercise` the active option, becomes the vault owner now; this is of no good because no one can actually call `withdraw()` as it will always revert, and no one can recover the ETH deposited by Alice and Bob as they are locked forever  ## Tools Used  Editor  ## Recommended Mitigation Steps  Add the following check at the start of `createVault()`:  ```jsx require(token != address(this), \"Cant use Cally as token\"); ```  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/223", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-cally-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/220", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-cally-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/219", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-cally-findings", "body": "QA Report"}, {"title": "Gas Optimization", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/218", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-cally-findings", "body": "Gas Optimization"}, {"title": "incorrect calculation of fee", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/217", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-05-cally-findings", "body": "incorrect calculation of fee"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/216", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-cally-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/215", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-cally-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/209", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-cally-findings", "body": "Gas Optimizations"}, {"title": "Cally Protocol Does Not Support Cryptopunk or Cryptokitties Tokens", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/207", "labels": ["bug", "disagree with severity", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-05-cally-findings", "body": "Cally Protocol Does Not Support Cryptopunk or Cryptokitties Tokens"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/204", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-cally-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/202", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-cally-findings", "body": "QA Report"}, {"title": "Gas Optimization", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/201", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-cally-findings", "body": "Gas Optimization"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/197", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-cally-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/193", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-cally-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/192", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-cally-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/190", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-cally-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/189", "labels": ["bug", "G (Gas Optimization)", "Gas Report - High quality report"], "target": "2022-05-cally-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/185", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-cally-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/184", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-cally-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/183", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-cally-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/182", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-cally-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/181", "labels": ["bug", "G (Gas Optimization)", "Gas Report - High quality report"], "target": "2022-05-cally-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/175", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-cally-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/174", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-cally-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/173", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-cally-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/172", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-cally-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/164", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-cally-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/162", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-cally-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/159", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-cally-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/157", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-cally-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/156", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-cally-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/153", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-05-cally-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/152", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-cally-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/150", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-cally-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/148", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-cally-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/146", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-cally-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/144", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-cally-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/143", "labels": ["bug", "G (Gas Optimization)", "Gas Report - High quality report"], "target": "2022-05-cally-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/142", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-cally-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/141", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-cally-findings", "body": "Gas Optimizations"}, {"title": "Inefficiency in the Dutch Auction due to lower duration", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/138", "labels": ["bug", "3 (High Risk)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2022-05-cally-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L406-L423   # Vulnerability details   The vulnerability or bug is in the implementation of the function getDutchAuctionStrike() The AUCTION_DURATION is defined as 24 hours, and consider that the dutchAuctionReserveStrike (or reserveStrike) will never be set to 0 by user.  Now if a vault is created with startingStrike value of 55 and reserveStrike of 13.5 , the auction price will drop from 55 to 13.5 midway at ~12 hours. So, after 12 hours from start of auction, the rate will be constant at reserveStrike of 13.5, and remaining time of 12 hours of auction is a waste.   Some other examples : ``` startStrike, reserveStrike, time-to-reach-reserveStrike 55 , 13.5  , ~12 hours 55 , 5     , ~16.7 hours 55 , 1.5   , ~20 hours 5  , 1.5   , ~11 hours ``` ## Impact The impact is high wrt Usability, where users have reduced available time to participate in the auction (when price is expected to change). The vault-Creators or the option-Buyers may or may not be aware of this inefficiency, i.e., how much effective time is available for auction.  ## Proof of Concept Contract : Cally.sol Function : getDutchAuctionStrike ()  ## Recommended Mitigation Steps The function getDutchAuctionStrike() can be modified such that price drops to the reserveStrike exactly at 24 hours from start of auction. ```         /*             delta = max(auctionEnd - currentTimestamp, 0)             progress = delta / auctionDuration             auctionStrike = progress^2 * (startingStrike - reserveStrike)             << Changes here             strike = auctionStrike + reserveStrike                                    << Changes here         */         uint256 delta = auctionEndTimestamp > block.timestamp ? auctionEndTimestamp - block.timestamp : 0;         uint256 progress = (1e18 * delta) / AUCTION_DURATION;         uint256 auctionStrike = (progress * progress * (startingStrike-reserveStrike)) / (1e18 * 1e18);          strike = auctionStrike + reserveStrike; ```   "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/134", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-cally-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/133", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-cally-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/132", "labels": ["bug", "G (Gas Optimization)", "Gas Report - High quality report"], "target": "2022-05-cally-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/131", "labels": ["bug", "QA (Quality Assurance)", "QA - High quality report"], "target": "2022-05-cally-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/125", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-cally-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/124", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-cally-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/122", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-cally-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/119", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-cally-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/118", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-cally-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/117", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-cally-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/115", "labels": ["bug", "QA (Quality Assurance)", "QA - High quality report"], "target": "2022-05-cally-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/114", "labels": ["bug", "G (Gas Optimization)", "Gas Report - High quality report"], "target": "2022-05-cally-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/113", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-cally-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/109", "labels": ["bug", "G (Gas Optimization)", "Gas Report - High quality report"], "target": "2022-05-cally-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/108", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-cally-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/107", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-cally-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/105", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-cally-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/103", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-cally-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/102", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-cally-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/101", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-cally-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/98", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-cally-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/96", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-cally-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/95", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-cally-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/93", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-cally-findings", "body": "Gas Optimizations"}, {"title": "Lack of 0 amount check allows malicious user to create infinite vaults", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/91", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-05-cally-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L200   # Vulnerability details  ## Impact A griefer is able to create as many vaults as they want by simply calling `createVault()` with `tokenIdOrAmount = 0`. This will most likely pose problems on the front-end of the Cally protocol because there will be a ridiculously high number of malicious vaults displayed to actual users.  I define these vaults as malicious because it is possible that a user accidently buys a call on this vault which provides 0 value in return. Overall, the presence of zero-amount vaults is damaging to Cally's product image and functionality.  ## Proof of Concept - User calls `createVault(0,,,,);` with an ERC20 type. - There is no validation that `amount > 0` - Function will complete successfully, granting the new vault NFT to the caller. - Cally protocol is filled with unwanted 0 amount vaults.  ## Tools Used Manual review  ## Recommended Mitigation Steps Add the simple check `require(tokenIdOrAmount > 0, \"Amount must be greater than 0\");`  "}, {"title": "no-revert-on-transfer ERC20 tokens can be drained", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/89", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2022-05-cally-findings", "body": "# Lines of code\r \r https://github.com/code-423n4/2022-05-cally/blob/main/contracts/src/Cally.sol#L198-L200\r \r \r # Vulnerability details\r \r ## Impact\r Some ERC20 tokens don't throw but just return false when a transfer fails. This can be abused to trick the `createVault()` function to initialize the vault without providing any tokens. A good example of such a token is *ZRX*: [Etherscan code](https://etherscan.io/address/0xe41d2489571d322189246dafa5ebde1f4699f498#code#L64)\r \r When such a vault is initialized, another user can both buy and exercise the option without ever receiving any funds. The creator of the vault does receive the buyer's Ether tho. So it can cause a loss of funds.\r \r ## Proof of Concept\r The trick is to create a vault with an ERC20 token but use ERC721 as the vault's type. Then, instead of calling `safeTransferFrom()` the function calls `transferFrom()` which won't catch the token returning false.\r \r Here's a test that showcases the issue:\r \r ```solidity\r // CreateVault.t.sol\r     function testStealFunds() public {\r         // address of 0x on mainnet\r         address t = address(0xE41d2489571d322189246DaFA5ebDe1F4699F498);\r         vm.startPrank(babe);\r         require(ERC20(t).balanceOf(babe) == 0);\r         uint vaultId = c.createVault(100, t, 1, 1, 1, 0, Cally.TokenType.ERC721);\r         // check that neither the Cally contract nor the vault creator\r         // had any 0x tokens\r         require(ERC20(t).balanceOf(babe) == 0);\r         require(ERC20(t).balanceOf(address(c)) == 0);\r \r         // check whether vault was created properly\r         Cally.Vault memory v = c.vaults(vaultId);\r         require(v.token == t);\r         require(v.tokenIdOrAmount == 100);\r         vm.stopPrank();\r         // So now there's a vault for 100 0x tokens although the Cally contract doesn't\r         // have any.\r         // If someone buys & exercises the option they won't receive any tokens.\r         uint premium = 0.025 ether;\r         uint strike = 2 ether;\r         require(address(c).balance == 0, \"shouldn't have any balance at the beginning\");\r         require(payable(address(this)).balance > 0, \"not enough balance\");\r \r         uint optionId = c.buyOption{value: premium}(vaultId);\r         c.exercise{value: strike}(optionId);\r \r         // buyer of option (`address(this)`) got zero 0x tokens\r         // But buyer lost their Ether\r         require(ERC20(t).balanceOf(address(this)) == 0);\r         require(address(c).balance > 0, \"got some money\");\r     }\r ```\r \r To run it, you need to use forge's forking mode: `forge test --fork-url <alchemy/infura URL> --match testStealFunds`\r \r ## Tools Used\r none\r \r ## Recommended Mitigation Steps\r I think the easiest solution is to use `safeTransferFrom()` when the token is of type ERC721. Since the transfer is at the end of the function there shouldn't be any risk of reentrancy. If someone passes an ERC20 address with type ERC721, the `safeTransferFrom()` call would simply fail since that function signature shouldn't exist on ERC20 tokens.\r \r "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/86", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-cally-findings", "body": "Gas Optimizations"}, {"title": "User's may accidentally overpay in `buyOption()` and the excess will be paid to the vault creator", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/84", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-05-cally-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L223-L224   # Vulnerability details  ## Impact  It is possible for a user purchasing an option to accidentally overpay the premium during `buyOption()`.  Any excess funds paid for in excess of the premium will be transferred to the vault creator.  The premium is fixed at the time the vault is first created by `vault.premiumIndex`. Hence there is no need to allow users to overpay since there will be no benefit.   ## Proof of Concept  `buyOption()` allows `msg.value > premium`  ```solidity         uint256 premium = getPremium(vaultId);         require(msg.value >= premium, \"Incorrect ETH amount sent\"); ```  ## Recommended Mitigation Steps  Consider modifying the check such that the `msg.value` is exactly equal to the `premuim`. e.g.  ```solidity         uint256 premium = getPremium(vaultId);         require(msg.value == premium, \"Incorrect ETH amount sent\"); ```  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/79", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-cally-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/78", "labels": ["bug", "QA (Quality Assurance)", "QA - High quality report"], "target": "2022-05-cally-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/75", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-cally-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/74", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-cally-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/64", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-cally-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/62", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-cally-findings", "body": "QA Report"}, {"title": "Vault is Not Compatible with Fee Tokens and Vaults with Such Tokens Could Be Exploited", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/61", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-cally-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L198-L200 https://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L294-L296 https://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L343-L345   # Vulnerability details  ## Impact  Some ERC20 tokens charge a transaction fee for every transfer (used to encourage staking, add to liquidity pool, pay a fee to contract owner, etc.). If any such token is used in the `createVault()` function, either the token cannot be withdrawn from the contract (due to insufficient token balance), or it could be exploited by other such token holders and the `Cally` contract would lose economic value and some users would be unable to withdraw the underlying asset.    ## Proof of Concept  Plenty of ERC20 tokens charge a fee for every transfer (e.g. Safemoon and its forks), in which the amount of token received is less than the amount being sent. When a fee token is used as the `token` in the `createVault()` function, the amount received by the contract would be less than the amount being sent. To be more precise, the increase in the `cally` contract token balance would be less than `vault.tokenIdOrAmount` for such ERC20 token because of the fee.   ```         vault.tokenType == TokenType.ERC721             ? ERC721(vault.token).transferFrom(msg.sender, address(this), vault.tokenIdOrAmount)             : ERC20(vault.token).safeTransferFrom(msg.sender, address(this), vault.tokenIdOrAmount); ```  The implication is that both the `exercise()` function and the `withdraw()` function are guaranteed to revert if there's no other vault in the contract that contains the same fee tokens, due to insufficient token balance in the `Cally` contract.   When an attacker observes that a vault is being created that contains such fee tokens, the attacker could create a new vault himself that contains the same token, and then withdraw the same amount. Essentially the `Cally` contract would be paying the transfer fee for the attacker because of how the token amount is recorded. This causes loss of user fund and loss of value from the `Cally` contract. It would make economic sense for the attacker when the fee charged by the token accrue to the attacker. The attacker would essentially use the `Cally` contract as a conduit to generate fee income.    ## Tools Used  Manual review  ## Recommended Mitigation Steps  Recommend disallowing fee tokens from being used in the vault. This can be done by adding a `require()` statement to check that the amount increase of the `token` balance in the `Cally` contract is equal to the amount being sent by the caller of the `createVault()` function.   "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/59", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-cally-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/53", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-cally-findings", "body": "Gas Optimizations"}, {"title": "Vaults steal rebasing tokens' rewards", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/50", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-05-cally-findings", "body": "Vaults steal rebasing tokens' rewards"}, {"title": "Owner can set the feeRate to be greater than 100% and cause all future calls to `exercise` to revert", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/48", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-05-cally-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L288-L289   # Vulnerability details  ## Impact The owner can force options to be non-exercisable, collecting premium without risking the loss of their NFT/tokens  ## Proof of Concept After a buyer buys an option owned by the owner, the owner can change the fee rate to be close to `type(uint256).max`, which will cause the subtraction below to always underflow, preventing the exercise of the option. Once the option expires, the owner can change the fee back and wait for another buyer  ```solidity File: contracts/src/Cally.sol   #1  288           // increment vault beneficiary's ETH balance 289           ethBalance[getVaultBeneficiary(vaultId)] += msg.value - fee; ``` https://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L288-L289  ## Tools Used Code inspection  ## Recommended Mitigation Steps Add reasonable fee rate bounds checks in the `setFee()` function   "}, {"title": "Owner can modify the feeRate on existing vaults and steal the strike value on exercise", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/47", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-05-cally-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L117-L121   # Vulnerability details  ## Impact Owner can steal the exercise cost which should have gone to the option seller  ## Proof of Concept There are no restrictions on when the owner can set the `feeRate`: ```solidity File: contracts/src/Cally.sol   #1  117       /// @notice Sets the fee that is applied on exercise 118       /// @param feeRate_ The new fee rate: fee = 1% = (1 / 100) * 1e18 119       function setFee(uint256 feeRate_) external onlyOwner { 120           feeRate = feeRate_; 121       } ``` https://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L117-L121  By using a rate that consumes the exercise cost, the owner can steal Ether from the seller: ```solidity File: contracts/src/Cally.sol   #2  282           uint256 fee = 0; 283           if (feeRate > 0) { 284               fee = (msg.value * feeRate) / 1e18; 285               protocolUnclaimedFees += fee; 286           } 287    288           // increment vault beneficiary's ETH balance 289           ethBalance[getVaultBeneficiary(vaultId)] += msg.value - fee; ``` https://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L282-L289  The owner can wait for a particularly large-value NFT, snipe that one option, then retire  ## Tools Used Code inspection  ## Recommended Mitigation Steps Fix the fee rate per vault during vault creation   "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/46", "labels": ["bug", "QA (Quality Assurance)", "QA - High quality report"], "target": "2022-05-cally-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/45", "labels": ["bug", "G (Gas Optimization)", "Gas Report - High quality report"], "target": "2022-05-cally-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/43", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-cally-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/42", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-cally-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/41", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-cally-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/40", "labels": ["bug", "G (Gas Optimization)", "Gas Report - High quality report"], "target": "2022-05-cally-findings", "body": "Gas Optimizations"}, {"title": "Use safeTransferFrom instead of transferFrom for ERC721 transfers", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/38", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-05-cally-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L199 https://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L295 https://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L344   # Vulnerability details  ## Details & Impact  The `transferFrom()` method is used instead of `safeTransferFrom()`, presumably to save gas. I however argue that this isn\u2019t recommended because:  - [OpenZeppelin\u2019s documentation](https://docs.openzeppelin.com/contracts/4.x/api/token/erc721#IERC721-transferFrom-address-address-uint256-) discourages the use of `transferFrom()`, use `safeTransferFrom()` whenever possible - Given that any NFT can be used for the call option, there are a few NFTs (here\u2019s an [example](https://github.com/sz-piotr/eth-card-game/blob/master/src/ethereum/contracts/ERC721Market.sol#L20-L31)) that have logic in the `onERC721Received()` function, which is only triggered in the `safeTransferFrom()` function and not in `transferFrom()`  ## Recommended Mitigation Steps  Call the `safeTransferFrom()` method instead of `transferFrom()` for NFT transfers. Note that the `CallyNft` contract should inherit the `ERC721TokenReceiver` contract as a consequence.  ```solidity abstract contract CallyNft is ERC721(\"Cally\", \"CALL\"), ERC721TokenReceiver {...} ```  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/37", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-cally-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/33", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-cally-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/26", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-cally-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/21", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-cally-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/19", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-cally-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/18", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-cally-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/17", "labels": ["bug", "G (Gas Optimization)", "Gas Report - High quality report"], "target": "2022-05-cally-findings", "body": "Gas Optimizations"}, {"title": "Expiration calculation overflows if call option duration \u2265 195 days", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/16", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-05-cally-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/src/Cally.sol#L238   # Vulnerability details  ## Details & Impact  `vault.durationDays` is of type `uint8`, thus allowing a maximum value of 255. `1 days = 86400`, thus fitting into a `uint24`. Solc creates a temporary variable to hold the result of the intermittent multiplication\u00a0`vault.durationDays * 1 days` using the data type of the larger operand.  In this case, the intermittent data type used would be `uint24`, which has a maximum value of `2**24 - 1 = 16777215`. The maximum number allowable before overflow achieved is therefore `(2**24 - 1) / 86400 = 194`.  ## Proof of Concept  Insert this test case into [BuyOption.t.sol](https://github.com/code-423n4/2022-05-cally/blob/1849f9ee12434038aa80753266ce6a2f2b082c59/contracts/test/units/BuyOption.t.sol)  ```solidity  function testCannotBuyDueToOverflow() public {   vm.startPrank(babe);   bayc.mint(babe, 2);   // duration of 195 days   vaultId = c.createVault(2, address(bayc), premiumIndex, 195, strikeIndex, 0, Cally.TokenType.ERC721);   vm.stopPrank();    vm.expectRevert(stdError.arithmeticError);   c.buyOption{value: premium}(vaultId); } ```  Then run  ``` forge test --match-contract TestBuyOption --match-test testCannotBuyDueToOverflow ```  ## Tidbit  This was the 1 high-severity bug that I wanted to mention at the end of the [C4 TrustX showcase](https://youtu.be/up9eqFRLgMQ?t=5722) but unfortunately could not due to a lack of time :( It can be found in the [vulnerable lottery contract](https://gist.github.com/HickupHH3/d214cfe6e4d003f428a63ae7d127af2d) on L39. Credits to Pauliax / Thunder for the recommendation and raising awareness of this bug =p  ## Reference  [Article](https://muellerberndt.medium.com/building-a-secure-nft-gaming-experience-a-herdsmans-diary-1-91aab11139dc)  ## Recommended Mitigation Steps  Cast the multiplication into `uint32`.  ```solidity vault.currentExpiration = uint32(block.timestamp) + uint32(vault.durationDays) * 1 days; ```  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/11", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-cally-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/10", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-cally-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/7", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-cally-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/6", "labels": ["bug", "G (Gas Optimization)", "Gas Report - High quality report"], "target": "2022-05-cally-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-cally-findings/issues/1", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-cally-findings", "body": "QA Report"}, {"title": "Agreement & Disclosures", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/365", "labels": [], "target": "2022-05-aura-findings", "body": "Agreement & Disclosures"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/362", "labels": ["bug", "duplicate", "QA (Quality Assurance)", "resolved"], "target": "2022-05-aura-findings", "body": "QA Report"}, {"title": "Wrong update of feeManager, poolManager, or voteDelegate (Booster.sol) can lock its functionality", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/361", "labels": ["bug", "duplicate", "QA (Quality Assurance)"], "target": "2022-05-aura-findings", "body": "Wrong update of feeManager, poolManager, or voteDelegate (Booster.sol) can lock its functionality"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/359", "labels": ["bug", "duplicate", "G (Gas Optimization)"], "target": "2022-05-aura-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/356", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-aura-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/355", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-aura-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/352", "labels": ["bug", "duplicate", "G (Gas Optimization)"], "target": "2022-05-aura-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/349", "labels": ["bug", "duplicate", "G (Gas Optimization)"], "target": "2022-05-aura-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/348", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-aura-findings", "body": "QA Report"}, {"title": "`CrvDepositor.sol` Wrong implementation of the 2-week buffer for lock", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/343", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-05-aura-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/convex-platform/contracts/contracts/CrvDepositor.sol#L127-L134   # Vulnerability details  https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/convex-platform/contracts/contracts/CrvDepositor.sol#L127-L134  ```solidity uint256 unlockAt = block.timestamp + MAXTIME; uint256 unlockInWeeks = (unlockAt/WEEK)*WEEK;  //increase time too if over 2 week buffer if(unlockInWeeks.sub(unlockTime) > 2){     IStaker(staker).increaseTime(unlockAt);     unlockTime = unlockInWeeks; } ```  In `_lockCurve()`, `unlockInWeeks - unlockTime` is being used as a number in weeks, while it actually is a number in seconds.  Thus, comparing it with `2` actually means a 2 seconds buffer instead of a 2 weeks buffer.  The intention is to wait for 2 weeks before extending the lock time again, but the current implementation allows the extension of the lock once a new week begins.  ### Recommendation  Consider changing the name of `unlockTime` to `unlockTimeInWeeks`, and:  1. Change L94-102 to:  https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/convex-platform/contracts/contracts/CrvDepositor.sol#L94-L102  ```solidity uint256 unlockAt = block.timestamp + MAXTIME; uint256 unlockInWeeks = unlockAt / WEEK;  //release old lock if exists IStaker(staker).release(); //create new lock uint256 crvBalanceStaker = IERC20(crvBpt).balanceOf(staker); IStaker(staker).createLock(crvBalanceStaker, unlockAt); unlockTimeInWeeks = unlockInWeeks; ```  2. Change L127-L134 to:  ```solidity uint256 unlockAt = block.timestamp + MAXTIME; uint256 unlockInWeeks = unlockAt / WEEK;  //increase time too if over 2 week buffer if(unlockInWeeks.sub(unlockTime) > 2){     IStaker(staker).increaseTime(unlockAt);     unlockTimeInWeeks = unlockInWeeks; } ```  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/337", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-aura-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/336", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-aura-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/335", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-aura-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/333", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-aura-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/330", "labels": ["bug", "duplicate", "G (Gas Optimization)"], "target": "2022-05-aura-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/329", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-aura-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/328", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-aura-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/327", "labels": ["bug", "duplicate", "G (Gas Optimization)"], "target": "2022-05-aura-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/326", "labels": ["bug", "duplicate", "QA (Quality Assurance)"], "target": "2022-05-aura-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/325", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-aura-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/323", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-aura-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/321", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-aura-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/317", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-aura-findings", "body": "Gas Optimizations"}, {"title": "ConvexMasterChef's deposit and withdraw can be reentered drawing all reward funds from the contract if reward token allows for transfer flow control", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/313", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-05-aura-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/convex-platform/contracts/contracts/ConvexMasterChef.sol#L209-L221 https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/convex-platform/contracts/contracts/ConvexMasterChef.sol#L239-L250   # Vulnerability details  Reward token accounting update in deposit() and withdraw() happens after reward transfer. If reward token allows for the control of transfer call flow or can be upgraded to allow it in the future (i.e. have or can introduce the _beforetokentransfer, _afterTokenTransfer type of hooks; or, say, can be upgraded to ERC777), the current implementation makes it possible to drain all the reward token funds of the contract by directly reentering deposit() or withdraw() with tiny _amount.  Setting the severity to medium as this is conditional to transfer flow control assumption, but the impact is the full loss of contract reward token holdings.  ## Proof of Concept  Both withdraw() and deposit() have the issue, performing late accounting update and not controlling for reentrancy:  https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/convex-platform/contracts/contracts/ConvexMasterChef.sol#L209-L221  ```solidity     function deposit(uint256 _pid, uint256 _amount) public {         PoolInfo storage pool = poolInfo[_pid];         UserInfo storage user = userInfo[_pid][msg.sender];         updatePool(_pid);         if (user.amount > 0) {             uint256 pending = user                 .amount                 .mul(pool.accCvxPerShare)                 .div(1e12)                 .sub(user.rewardDebt);             safeRewardTransfer(msg.sender, pending);         }         pool.lpToken.safeTransferFrom( ```  https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/convex-platform/contracts/contracts/ConvexMasterChef.sol#L239-L250  ```solidity     function withdraw(uint256 _pid, uint256 _amount) public {         PoolInfo storage pool = poolInfo[_pid];         UserInfo storage user = userInfo[_pid][msg.sender];         require(user.amount >= _amount, \"withdraw: not good\");         updatePool(_pid);         uint256 pending = user.amount.mul(pool.accCvxPerShare).div(1e12).sub(             user.rewardDebt         );         safeRewardTransfer(msg.sender, pending);         user.amount = user.amount.sub(_amount);         user.rewardDebt = user.amount.mul(pool.accCvxPerShare).div(1e12);         pool.lpToken.safeTransfer(address(msg.sender), _amount); ```  ## Recommended Mitigation Steps  Consider adding a direct reentrancy control, e.g. nonReentrant modifier:  https://docs.openzeppelin.com/contracts/2.x/api/utils#ReentrancyGuard  Also, consider finishing all internal state updates prior to external calls:  https://consensys.github.io/smart-contract-best-practices/attacks/reentrancy/#pitfalls-in-reentrancy-solutions  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/312", "labels": ["bug", "duplicate", "QA (Quality Assurance)"], "target": "2022-05-aura-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/311", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-aura-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/310", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-aura-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/308", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-aura-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/307", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-aura-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/306", "labels": ["bug", "duplicate", "QA (Quality Assurance)"], "target": "2022-05-aura-findings", "body": "QA Report"}, {"title": "DOS+griefing  attack for AuraVestedEscrow contract by calling fund() because it does not have access control and anyone can call it and initialize contract with wrong parameters", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/305", "labels": ["bug", "disagree with severity", "G (Gas Optimization)"], "target": "2022-05-aura-findings", "body": "DOS+griefing  attack for AuraVestedEscrow contract by calling fund() because it does not have access control and anyone can call it and initialize contract with wrong parameters"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/304", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-aura-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/303", "labels": ["bug", "duplicate", "G (Gas Optimization)"], "target": "2022-05-aura-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/300", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-aura-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/299", "labels": ["bug", "duplicate", "G (Gas Optimization)"], "target": "2022-05-aura-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/298", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-05-aura-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/297", "labels": ["bug", "duplicate", "G (Gas Optimization)"], "target": "2022-05-aura-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/295", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-05-aura-findings", "body": "QA Report"}, {"title": "AuraBalRewardPool can be initiated multiple times by bypassing rewardRate==0 and rewardsAvailable>0 checks.", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/294", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-05-aura-findings", "body": "AuraBalRewardPool can be initiated multiple times by bypassing rewardRate==0 and rewardsAvailable>0 checks."}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/291", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-aura-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/287", "labels": ["bug", "duplicate", "QA (Quality Assurance)"], "target": "2022-05-aura-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/286", "labels": ["bug", "duplicate", "G (Gas Optimization)"], "target": "2022-05-aura-findings", "body": "Gas Optimizations"}, {"title": "DDOS in BalLiquidityProvider", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/285", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "resolved", "sponsor acknowledged"], "target": "2022-05-aura-findings", "body": "DDOS in BalLiquidityProvider"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/282", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-aura-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/281", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-aura-findings", "body": "Gas Optimizations"}, {"title": "Precision Error when calculating the penalty for not locking the reward", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/279", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-05-aura-findings", "body": "Precision Error when calculating the penalty for not locking the reward"}, {"title": "Increase voting power by tokenizing the address that locks the token  ", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/278", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "resolved", "sponsor acknowledged"], "target": "2022-05-aura-findings", "body": "Increase voting power by tokenizing the address that locks the token  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/276", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-aura-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/275", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-aura-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/274", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-aura-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/273", "labels": ["bug", "duplicate", "G (Gas Optimization)"], "target": "2022-05-aura-findings", "body": "Gas Optimizations"}, {"title": "ConvexMasterChef: safeRewardTransfer can cause loss of funds", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/272", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "resolved", "sponsor acknowledged"], "target": "2022-05-aura-findings", "body": "ConvexMasterChef: safeRewardTransfer can cause loss of funds"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/271", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-aura-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/270", "labels": ["bug", "duplicate", "G (Gas Optimization)"], "target": "2022-05-aura-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/269", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-aura-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/268", "labels": ["bug", "QA (Quality Assurance)", "resolved", "sponsor acknowledged"], "target": "2022-05-aura-findings", "body": "QA Report"}, {"title": "Lack of upperbound on iterated array `rewardTokens` in `AuraLocker`", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/265", "labels": ["bug", "duplicate", "QA (Quality Assurance)"], "target": "2022-05-aura-findings", "body": "Lack of upperbound on iterated array `rewardTokens` in `AuraLocker`"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/264", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-aura-findings", "body": "Gas Optimizations"}, {"title": "Integer overflow will lock all rewards in `AuraLocker`", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/261", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2022-05-aura-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/contracts/AuraLocker.sol#L176-L177 https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/contracts/AuraLocker.sol#L802-L814 https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/contracts/AuraLocker.sol#L864   # Vulnerability details  ## Impact  There is a potential overflow in the rewards calculations which would lead to `updateReward()` always reverting.  The impact of this overflow is that all reward tokens will be permanently locked in the contract. User's will be unable to call any of the functions which have the `updateReward()` modifier, that is:  - `lock()` - `getReward()` - `_processExpiredLocks()` - `_notifyReward()`  As a result the contract will need to call `shutdown()` and the users will only be able to receive their staked tokens via `emergencyWithdraw()`, which does not transfer the users the reward tokens.  Note that if one reward token overflows this will cause a revert on all reward tokens due to the loop over reward tokens.  ## Proof of Concept  The overflow may occur due to the base of values in `_rewardPerToken()`.   ```solidity     function _rewardPerToken(address _rewardsToken) internal view returns (uint256) {         if (lockedSupply == 0) {             return rewardData[_rewardsToken].rewardPerTokenStored;         }         return             uint256(rewardData[_rewardsToken].rewardPerTokenStored).add(                 _lastTimeRewardApplicable(rewardData[_rewardsToken].periodFinish)                     .sub(rewardData[_rewardsToken].lastUpdateTime)                     .mul(rewardData[_rewardsToken].rewardRate)                     .mul(1e18)                     .div(lockedSupply)             );     } ```  The return value of `_rewardPerToken()` is in terms of  ``` (now - lastUpdateTime) * rewardRate * 10**18 / totalSupply ```  Here `(now - lastUpdateTime)` has a maximum value of `rewardDuration = 6 * 10**5`.  Now `rewardRate` is the `_reward.div(rewardsDuration)` as seen in `_notifyRewardAmount()` on line #864. Note that `rewardDuration` is a constant 604,800.  `rewardDuration = 6 * 10**5`   Thus, if we have a rewards such as AURA or WETH (or most ERC20 tokens) which have units 10**18 we can transfer 1 WETH to the reward distributor which calls `_notifyRewardAmount()` and  sets the reward rate to,  `rewardRate = 10**18 / (6 * 10**5) ~= 10**12`  Finally, if this attack is run either by the first depositor they may `lock()` a single token which would set `totalSupply = 1`.  Therefore our equation in terms of units will become, ``` (now - lastUpdateTime) * rewardRate * 10**18 / totalSupply => 10**5 * 10**12 * 10**18 / 1 = 10**35 ```  In since `rewardPerTokenStored` is a `uint96` it has a maximum value of `2**96 ~= 7.9 * 10**28`. Hence there will be an overflow in `newRewardPerToken.to96()`. Since we are unable to add more total supply due to `lock()` reverting there will be no way to circumvent this revert except to `shutdown()`.  ```solidity                 uint256 newRewardPerToken = _rewardPerToken(token);                 rewardData[token].rewardPerTokenStored = newRewardPerToken.to96(); ```  Note this attack is described when we have a low `totalSupply`. However it is also possible to apply this attack on a larger `totalSupply` when there are reward tokens which have decimal places larger than 18 or tokens which such as SHIB which have small token value and so many of the tokens can be bought for cheap.   ## Recommended Mitigation Steps  To mitigation this issue it is recommended to increase the size of the `rewardPerTokenStored`. Since updating this value will require another slot to be used we recommend updating this to either `uint256` or to update both `rewardRate` and `rewardPerTokenStored` to be `uint224`.  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/260", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-aura-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/259", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-aura-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/257", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-05-aura-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/255", "labels": ["bug", "duplicate", "G (Gas Optimization)"], "target": "2022-05-aura-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/254", "labels": ["bug", "duplicate", "QA (Quality Assurance)"], "target": "2022-05-aura-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/253", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-aura-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/252", "labels": ["bug", "duplicate", "QA (Quality Assurance)"], "target": "2022-05-aura-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/251", "labels": ["bug", "duplicate", "G (Gas Optimization)"], "target": "2022-05-aura-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/249", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-aura-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/247", "labels": ["bug", "duplicate", "G (Gas Optimization)"], "target": "2022-05-aura-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/246", "labels": ["bug", "duplicate", "QA (Quality Assurance)"], "target": "2022-05-aura-findings", "body": "QA Report"}, {"title": "Reward may be locked forever if user doesn't claim reward for a very long time such that too many epochs have been passed", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/240", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "resolved", "sponsor acknowledged"], "target": "2022-05-aura-findings", "body": "Reward may be locked forever if user doesn't claim reward for a very long time such that too many epochs have been passed"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/235", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-aura-findings", "body": "QA Report"}, {"title": "Improperly Skewed Governance Mechanism", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/232", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor disputed"], "target": "2022-05-aura-findings", "body": "Improperly Skewed Governance Mechanism"}, {"title": "_getReward should not be public and you should add nonReentrant modifier to your _getReward function", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/230", "labels": ["bug", "disagree with severity", "QA (Quality Assurance)", "resolved", "sponsor acknowledged"], "target": "2022-05-aura-findings", "body": "_getReward should not be public and you should add nonReentrant modifier to your _getReward function"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/227", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-aura-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/226", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-aura-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/219", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-aura-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/218", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-aura-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/217", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-aura-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/216", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-aura-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/215", "labels": ["bug", "duplicate", "QA (Quality Assurance)"], "target": "2022-05-aura-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/214", "labels": ["bug", "duplicate", "G (Gas Optimization)"], "target": "2022-05-aura-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/213", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-aura-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/212", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor acknowledged"], "target": "2022-05-aura-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/208", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-aura-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/207", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-aura-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/206", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-aura-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/205", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-aura-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/204", "labels": ["bug", "duplicate", "G (Gas Optimization)"], "target": "2022-05-aura-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/203", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-aura-findings", "body": "QA Report"}, {"title": "massUpdatePools() is susceptible to DoS with block gas limit", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/197", "labels": ["bug", "duplicate", "2 (Med Risk)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2022-05-aura-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-aura/blob/main/convex-platform/contracts/contracts/ConvexMasterChef.sol#L178-L183   # Vulnerability details  ## Impact massUpdatePools() is a public function and it calls the updatePool() function for the length of poolInfo. Hence, it is an unbounded loop, depending on the length of poolInfo. If poolInfo.length is big enough, block gas limit may be hit.  ## Proof of Concept https://consensys.github.io/smart-contract-best-practices/attacks/denial-of-service/#dos-with-block-gas-limit  ## Tools Used Manual analysis  ## Recommended Mitigation Steps I suggest to limit the max number of loop iterations to prevent hitting block gas limit.   "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/194", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-05-aura-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/193", "labels": ["bug", "duplicate", "G (Gas Optimization)"], "target": "2022-05-aura-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/192", "labels": ["bug", "duplicate", "QA (Quality Assurance)"], "target": "2022-05-aura-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/191", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-aura-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/187", "labels": ["bug", "duplicate", "QA (Quality Assurance)"], "target": "2022-05-aura-findings", "body": "QA Report"}, {"title": "Locking up AURA Token does not increase voting power of individual", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/186", "labels": ["bug", "2 (Med Risk)", "sponsor disputed"], "target": "2022-05-aura-findings", "body": "Locking up AURA Token does not increase voting power of individual"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/184", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-05-aura-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/183", "labels": ["bug", "duplicate", "QA (Quality Assurance)"], "target": "2022-05-aura-findings", "body": "QA Report"}, {"title": "Users can grief reward distribution", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/180", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "resolved", "sponsor acknowledged"], "target": "2022-05-aura-findings", "body": "Users can grief reward distribution"}, {"title": "`AuraBalRewardPool` charges a penalty to all users in the pool if the `AuraLocker` has been shut down", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/179", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor acknowledged"], "target": "2022-05-aura-findings", "body": "`AuraBalRewardPool` charges a penalty to all users in the pool if the `AuraLocker` has been shut down"}, {"title": "Users may lose rewards to other users if rewards are given as fee-on-transfer tokens", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/176", "labels": ["bug", "2 (Med Risk)", "sponsor disputed"], "target": "2022-05-aura-findings", "body": "Users may lose rewards to other users if rewards are given as fee-on-transfer tokens"}, {"title": "AuraVestedEscrow's fund can be run with empty amounts", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/174", "labels": ["bug", "disagree with severity", "G (Gas Optimization)"], "target": "2022-05-aura-findings", "body": "AuraVestedEscrow's fund can be run with empty amounts"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/173", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-05-aura-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/172", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-05-aura-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/170", "labels": ["bug", "duplicate", "G (Gas Optimization)"], "target": "2022-05-aura-findings", "body": "Gas Optimizations"}, {"title": "Reused Interface names", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/169", "labels": ["bug", "disagree with severity", "QA (Quality Assurance)"], "target": "2022-05-aura-findings", "body": "Reused Interface names"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/167", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-aura-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/164", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-05-aura-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/161", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-05-aura-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/159", "labels": ["bug", "duplicate", "QA (Quality Assurance)"], "target": "2022-05-aura-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/158", "labels": ["bug", "duplicate", "G (Gas Optimization)"], "target": "2022-05-aura-findings", "body": "Gas Optimizations"}, {"title": "AuraLocker kick reward only takes last locked amount into consideration, instead of whole balance", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/156", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2022-05-aura-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-aura/blob/main/contracts/AuraLocker.sol#L404   # Vulnerability details  The issue occurs in AuraLocker, when expired locks are processed via kicking, and if all the user locks have expired. In this scenario, to calculate the kick reward, `_processExpiredLocks` multiplies the last locked amount by the number of epochs between the last lock's unlock time and the current epoch. A comment in this section mentions `\"wont have the exact reward rate that you would get if looped through\"`. However, there's no reason not to multiply *user's whole locked balance* by the number of epochs since the *last lock's* unlock time, *instead of only the last locked amount*. While this will still not be as accurate as looping through, this will give a more accurate kick reward result, which is still bounded by the full amount that would have been calculated if we had looped through.  ## Impact The reward calculation is inaccurate and lacking for no reason. Kickers receive less rewards than they should. Giving them a bigger, more accurate reward, will incentivize them better.  ## Proof of Concept [This](https://github.com/code-423n4/2022-05-aura/blob/main/contracts/AuraLocker.sol#L396:#L405) is the section that calculates the kick reward if all locks have expired: ```             //check for kick reward             //this wont have the exact reward rate that you would get if looped through             //but this section is supposed to be for quick and easy low gas processing of all locks             //we'll assume that if the reward was good enough someone would have processed at an earlier epoch             if (_checkDelay > 0) {                 uint256 currentEpoch = block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(rewardsDuration);                 uint256 epochsover = currentEpoch.sub(uint256(locks[length - 1].unlockTime)).div(rewardsDuration);                 uint256 rRate = AuraMath.min(kickRewardPerEpoch.mul(epochsover + 1), denominator);                 reward = uint256(locks[length - 1].amount).mul(rRate).div(denominator);             } ``` This flow is for low gas processing, so the function is not looping through all the locks (unlike the flow where some locks have not expired yet). In this flow, the function is just calculating the reward for the last lock.  Instead of doing this, it can multiply the *total amount locked by the user* (`locked`, already saved) by the *number of epochs between the last unlock time and current epoch*. The reward will still be smaller than if we had looped through all the rewards (since then each lock amount would be multiplied by more than just the last lock's number of expired epochs). But it would be more accurate and give better incentive for kicking.   ## Recommended Mitigation Steps Change the last line in the code above to: ```                 reward = uint256(locked).mul(rRate).div(denominator); ``` This will keep the low gas consumption of this flow, while giving a more accurate result.  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/154", "labels": ["bug", "duplicate", "QA (Quality Assurance)"], "target": "2022-05-aura-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/153", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-05-aura-findings", "body": "QA Report"}, {"title": "ConvexMasterChef: When _lpToken is cvx, reward calculation is incorrect", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/151", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-05-aura-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/convex-platform/contracts/contracts/ConvexMasterChef.sol#L96-L118   # Vulnerability details  ## Impact In the ConvexMasterChef contract, a new staking pool can be added using the add() function. The staking token for the new pool is defined using the _lpToken variable. However, there is no additional checking whether the _lpToken is the same as the reward token (cvx) or not. ```   function add(       uint256 _allocPoint,       IERC20 _lpToken,       IRewarder _rewarder,       bool _withUpdate   ) public onlyOwner {       if (_withUpdate) {           massUpdatePools();       }       uint256 lastRewardBlock = block.number > startBlock           ? block.number           : startBlock;       totalAllocPoint = totalAllocPoint.add(_allocPoint);       poolInfo.push(           PoolInfo({               lpToken: _lpToken,               allocPoint: _allocPoint,               lastRewardBlock: lastRewardBlock,               accCvxPerShare: 0,               rewarder: _rewarder           })       );   } ``` When the _lpToken is the same token as cvx, reward calculation for that pool in the updatePool() function can be incorrect. This is because the current balance of the _lpToken in the contract is used in the calculation of the reward. Since the _lpToken is the same token as the reward, the reward minted to the contract will inflate the value of lpSupply, causing the reward of that pool to be less than what it should be. ```   function updatePool(uint256 _pid) public {       PoolInfo storage pool = poolInfo[_pid];       if (block.number <= pool.lastRewardBlock) {           return;       }       uint256 lpSupply = pool.lpToken.balanceOf(address(this));       if (lpSupply == 0) {           pool.lastRewardBlock = block.number;           return;       }       uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number);       uint256 cvxReward = multiplier           .mul(rewardPerBlock)           .mul(pool.allocPoint)           .div(totalAllocPoint);       //cvx.mint(address(this), cvxReward);       pool.accCvxPerShare = pool.accCvxPerShare.add(           cvxReward.mul(1e12).div(lpSupply)       );       pool.lastRewardBlock = block.number;   } ``` ## Proof of Concept https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/convex-platform/contracts/contracts/ConvexMasterChef.sol#L96-L118 https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/convex-platform/contracts/contracts/ConvexMasterChef.sol#L186-L206 ## Tools Used None ## Recommended Mitigation Steps Add a check that _lpToken is not cvx in the add function or mint the reward token to another contract to prevent the amount of the staked token from being mixed up with the reward token.  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/150", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-aura-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/148", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-aura-findings", "body": "Gas Optimizations"}, {"title": " ConvexMasterChef: When using add() and set(), it should always call massUpdatePools() to update all pools", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/147", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-05-aura-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/convex-platform/contracts/contracts/ConvexMasterChef.sol#L96-L138   # Vulnerability details  ## Impact Same as IDX-003 in https://public-stg.inspex.co/report/Inspex_AUDIT2021024_LuckyLion_Farm_FullReport_v2.0.pdf The totalAllocPoint variable is used to determine the portion that each pool would get from the total reward, so it is one of the main factors used in the rewards calculation. Therefore, whenever the totalAllocPoint variable is modified without updating the pending reward first, the reward of each pool will be incorrectly calculated. For example, when  _withUpdate is false, in the add() shown below, the totalAllocPoint variable will be modified without updating the rewards (massUpdatePools()). ```     function add(         uint256 _allocPoint,         IERC20 _lpToken,         IRewarder _rewarder,         bool _withUpdate     ) public onlyOwner {         if (_withUpdate) {             massUpdatePools();         }         uint256 lastRewardBlock = block.number > startBlock             ? block.number             : startBlock;         totalAllocPoint = totalAllocPoint.add(_allocPoint);         poolInfo.push(             PoolInfo({                 lpToken: _lpToken,                 allocPoint: _allocPoint,                 lastRewardBlock: lastRewardBlock,                 accCvxPerShare: 0,                 rewarder: _rewarder             })         );     } ``` ## Proof of Concept https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/convex-platform/contracts/contracts/ConvexMasterChef.sol#L96-L138 ## Tools Used None ## Recommended Mitigation Steps Removing the _withUpdate variable in the add() and set() functions and always calling the massUpdatePools() function before updating totalAllocPoint variable  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/141", "labels": ["bug", "duplicate", "G (Gas Optimization)"], "target": "2022-05-aura-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/140", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-aura-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/134", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-aura-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/131", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-05-aura-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/130", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-05-aura-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/129", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-05-aura-findings", "body": "Gas Optimizations"}, {"title": "Reward can be vested even after endTime", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/126", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "resolved", "sponsor acknowledged"], "target": "2022-05-aura-findings", "body": "Reward can be vested even after endTime"}, {"title": "Duplicate LP token could lead to incorrect reward distribution", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/124", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor acknowledged"], "target": "2022-05-aura-findings", "body": "Duplicate LP token could lead to incorrect reward distribution"}, {"title": "CrvDepositorWrapper.sol relies on oracle that isn't frequently updated", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/115", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-05-aura-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-aura/blob/4989a2077546a5394e3650bf3c224669a0f7e690/contracts/CrvDepositorWrapper.sol#L56-L65   # Vulnerability details  ## Impact Unpredictable slippage, sandwich vulnerability or frequent failed transactions  ## Proof of Concept CrvDepostiorWrapper uses the TWAP provided by the 20/80 WETH/BAL. The issue is that this pool has only handled ~15 transactions per day in the last 30 days, which means that the oracle frequently goes more than an hour without updating. Each time a state changing operation is called, the following code in the balancer pool takes a snapshot of the pool state BEFORE any operation changes it:  https://github.com/balancer-labs/balancer-v2-monorepo/blob/80e1a5db7439069e2cb53e228bce0a8a51f5b23e/pkg/pool-weighted/contracts/oracle/OracleWeightedPool.sol#L156-L161  This could result in the price of the oracle frequently not reflecting the true value of the assets due to infrequency of update. Now also consider that the pool has a trading fee of 2%. Combine an inaccurate oracle with a high fee pool and trades can exhibit high levels of \"slippage\". To account for this outputBps in AuraStakingProxy needs to be set relatively low or risks frequent failed transactions when calling distribute due to slippage conditions not being met. The lower outputBps is set the more vulnerable distribute becomes to sandwich attacks.   ## Tools Used  ## Recommended Mitigation Steps Consider using chainlink oracles for both BAL and ETH to a realtime estimate of the LP value. A chainlink LP oracle implementation can be found in the link below: https://blog.alphaventuredao.io/fair-lp-token-pricing/  "}, {"title": " 256 to 112 could cause a wrong lock amount", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/114", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-05-aura-findings", "body": " 256 to 112 could cause a wrong lock amount"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/109", "labels": ["bug", "G (Gas Optimization)", "sponsor disputed"], "target": "2022-05-aura-findings", "body": "Gas Optimizations"}, {"title": "User will lose funds", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/108", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2022-05-aura-findings", "body": "# Lines of code\r \r https://github.com/code-423n4/2022-05-aura/blob/main/contracts/AuraClaimZap.sol#L224-L226\r \r \r # Vulnerability details\r \r ## Impact\r It was observed that User will lose funds due to missing else condition\r \r ## Proof of Concept\r \r 1. User call claimRewards at ClaimZap.sol#L103 with Options.LockCvx as false\r 2. claimRewards internally calls _claimExtras\r 3. Everything goes good until AuraClaimZap.sol#L218\r \r ```\r if (depositCvxMaxAmount > 0) {\r             uint256 cvxBalance = IERC20(cvx).balanceOf(msg.sender).sub(removeCvxBalance);\r             cvxBalance = AuraMath.min(cvxBalance, depositCvxMaxAmount);\r             if (cvxBalance > 0) {\r                 //pull cvx\r                 IERC20(cvx).safeTransferFrom(msg.sender, address(this), cvxBalance);\r                 if (_checkOption(options, uint256(Options.LockCvx))) {\r                     IAuraLocker(locker).lock(msg.sender, cvxBalance);\r                 }\r             }\r         }\r ```\r \r 4. Since user cvxBalance>0 so cvxBalance is transferred from user to the contract.\r 5. Now since Options.LockCvx was set to false in options so if (_checkOption(options, uint256(Options.LockCvx))) does not evaluate to true and does not execute\r 6. This means User cvx funds are stuck in contract\r \r ## Recommended Mitigation Steps\r The condition should check if user has enabled lock for cvx, otherwise cvx should not be transferred from user\r \r ```\r if (depositCvxMaxAmount > 0 && _checkOption(options, uint256(Options.LockCvx))) {\r           uint256 cvxBalance = IERC20(cvx).balanceOf(msg.sender).sub(removeCvxBalance);\r           cvxBalance = AuraMath.min(cvxBalance, depositCvxMaxAmount);\r           if (cvxBalance > 0) {\r               //pull cvx\r               IERC20(cvx).safeTransferFrom(msg.sender, address(this), cvxBalance);\r \r                   IAuraLocker(locker).lock(msg.sender, cvxBalance);\r           }\r       }\r ```\r \r "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/106", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-aura-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/100", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-05-aura-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/99", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-aura-findings", "body": "Gas Optimizations"}, {"title": "Minting is completely impossible due to wrongful forking of convex", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/97", "labels": ["bug", "duplicate", "disagree with severity", "G (Gas Optimization)"], "target": "2022-05-aura-findings", "body": "Minting is completely impossible due to wrongful forking of convex"}, {"title": "Penalty value lost if `penaltyForwarder` is address(0)", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/95", "labels": ["bug", "disagree with severity", "G (Gas Optimization)", "resolved", "sponsor acknowledged"], "target": "2022-05-aura-findings", "body": "Penalty value lost if `penaltyForwarder` is address(0)"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/92", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-05-aura-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/83", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-05-aura-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/82", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-05-aura-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/66", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-05-aura-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/59", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-05-aura-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/57", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-aura-findings", "body": "Gas Optimizations"}, {"title": "User can forfeit other user rewards", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/50", "labels": ["bug", "3 (High Risk)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2022-05-aura-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-aura/blob/main/contracts/ExtraRewardsDistributor.sol#L127   # Vulnerability details  ## Impact User can forfeit other user rewards by giving a higher _startIndex in getReward function  ## Proof of Concept 1. Assume User B has not received any reward yet so that his userClaims[_token][User B]=0 2. User A calls getReward function with _account as User B and _startIndex as 5 3. This eventually calls _allClaimableRewards at ExtraRewardsDistributor.sol#L213 which computes epochIndex =5>0?5:0 = 5 4. Assuming tokenEpochs is 10 and latestEpoch is 8, so reward will computed from epoch 5 till epoch index 7 and _allClaimableRewards will return index as 7 5. _getReward will simply update userClaims[_token][User B] with 7  6. This is incorrect because as per contract User B has received reward from epoch 0-7 even though he only received reward for epoch 5-7   ## Recommended Mitigation Steps Do not allow users to call getReward function for other users  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/47", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-05-aura-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/45", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-05-aura-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/44", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-05-aura-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/43", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-05-aura-findings", "body": "QA Report"}, {"title": "Gas Optimization", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/42", "labels": ["bug", "G (Gas Optimization)", "sponsor disputed"], "target": "2022-05-aura-findings", "body": "Gas Optimization"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/41", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-05-aura-findings", "body": "QA Report"}, {"title": "Gas Optimization", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/40", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-05-aura-findings", "body": "Gas Optimization"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/39", "labels": ["bug", "QA (Quality Assurance)", "resolved", "sponsor acknowledged"], "target": "2022-05-aura-findings", "body": "QA Report"}, {"title": "Gas Optimization", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/38", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-05-aura-findings", "body": "Gas Optimization"}, {"title": "Use of deprecated `safeApprove()` function ", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/35", "labels": ["bug", "disagree with severity", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-05-aura-findings", "body": "Use of deprecated `safeApprove()` function "}, {"title": "`updateOperator()` can be called before an operator is set in proxy", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/34", "labels": ["bug", "disagree with severity", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-05-aura-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-aura/blob/main/contracts/Aura.sol#L82   # Vulnerability details  ## Impact In `Aura.sol` the `updateOperator()` function can be called by anyone and it sets a new `operator` based on the address returned from `IStaker(vecrvProxy).operator()`.  The problem is that anyone can call this function even if the operator on `vecrvProxy` is not yet set.  If this is the case the operator in `Aura.sol` would be set to a zero address breaking the contract since functions like `init()` and `mint()` rely on the `msg.sender` being the `operator`. Even the `minterMint()` function relies on the `operator` since only the operator can set the `minter` which is the only one who can call `minterMinter()`.   ## Proof of Concept https://github.com/code-423n4/2022-05-aura/blob/main/contracts/Aura.sol#L82  ## Tools Used Manual code review   ## Recommended Mitigation Steps The `updateOperator()` function should not be a public function and should only be callable by an admin or the `operator` inside `Aura.sol`.  Also in the `updateOperator()` function,  there should be a check ensuring that the `newOperator` address is not a zero address to prevent breaking the contract by setting the `operator` to a zero address.   "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/33", "labels": ["bug", "duplicate", "G (Gas Optimization)"], "target": "2022-05-aura-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/28", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-05-aura-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/27", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-05-aura-findings", "body": "Gas Optimizations"}, {"title": "BaseRewardPool4626 is not IERC4626 compliant", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/26", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2022-05-aura-findings", "body": "# Lines of code  https://github.com/aurafinance/convex-platform/blob/9cae5eb5a77e73bbc1378ef213740c1889e2e8a3/contracts/contracts/BaseRewardPool4626.sol   # Vulnerability details  ## Impact   BaseRewardPool4626 is not IERC4626 compliant. This makes the BaseRewardPool4626 contract irrelevant as it is for now since projects won't be able to integrate with BaseRewardPool4626 using the[eip-4626](https://eips.ethereum.org/EIPS/eip-4626) standard.   ## Suggestion  You can choose to remove the BaseRewardPool4626 and save on some deployment gas or review the necessary` functions` and `emits` required on [eip-4626](https://eips.ethereum.org/EIPS/eip-4626)  and add it to BaseRewardPool4626.   "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/25", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-05-aura-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/24", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor acknowledged"], "target": "2022-05-aura-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/17", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-05-aura-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/16", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-05-aura-findings", "body": "Gas Optimizations"}, {"title": "Duplicate Contract Names", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/12", "labels": ["bug", "disagree with severity", "QA (Quality Assurance)", "resolved", "sponsor confirmed"], "target": "2022-05-aura-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-aura/blob/main/contracts/CrvDepositorWrapper.sol#L9 https://github.com/code-423n4/2022-05-aura/blob/main/contracts/AuraStakingProxy.sol#L10   # Vulnerability details  ## Impact If a codebase has two contracts with the same names, the compilation artifacts will not contain one of the contracts.  `ICrvDepositor` exists in both `AuraStakingProxy` and `CrvDepositorWrapper`  ## Tools Manual Review   ## Recommended Mitigation Steps Move the contract to an interface file and import it or if the interface differs rename one of the contracts.  "}, {"title": "Wrong inflationProtectionTime", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/10", "labels": ["bug", "disagree with severity", "QA (Quality Assurance)", "resolved", "sponsor acknowledged"], "target": "2022-05-aura-findings", "body": "Wrong inflationProtectionTime"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/5", "labels": ["bug", "QA (Quality Assurance)", "resolved", "sponsor confirmed"], "target": "2022-05-aura-findings", "body": "QA Report"}, {"title": "Rewards distribution can be delayed/never distributed on AuraLocker.sol#L848", "html_url": "https://github.com/code-423n4/2022-05-aura-findings/issues/1", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "resolved", "sponsor acknowledged", "sponsor confirmed"], "target": "2022-05-aura-findings", "body": "# Lines of code  https://github.com/aurafinance/aura-contracts-lite/blob/main/contracts/AuraLocker.sol#L848   # Vulnerability details    Rewards distribution can be delayed/never distributed on [AuraLocker.sol#L848 ](https://github.com/aurafinance/aura-contracts-lite/blob/main/contracts/AuraLocker.sol#L848)   ### Issue  Someone malicious can delay the rewards distribution for non `cvxCrv` tokens distributed on AuraLocker.sol.   1: Attacker will send one wei of token that are distributed on the [AuraLocker.sol ](https://github.com/aurafinance/aura-contracts-lite/blob/main/contracts/AuraLocker.sol) to [AuraStakingProxy](https://github.com/aurafinance/aura-contracts-lite/blob/6d60fca6f821dca1854a538807e7928ee582553a/contracts/AuraStakingProxy.sol).  2: Attacker will call [distributeOther](https://github.com/aurafinance/aura-contracts-lite/blob/6d60fca6f821dca1854a538807e7928ee582553a/contracts/AuraStakingProxy.sol#L203). The function will call notifyRewardAmount that calls [_notifyReward](https://github.com/aurafinance/aura-contracts-lite/blob/main/contracts/AuraLocker.sol#L860)   When calling [_notifyReward](https://github.com/aurafinance/aura-contracts-lite/blob/main/contracts/AuraLocker.sol#L860) the rewards left to distribute over the 7 days are redistributed throughout a new period starting immediately.  ``` uint256 remaining = uint256(rdata.periodFinish).sub(block.timestamp); uint256 leftover = remaining.mul(rdata.rewardRate); rdata.rewardRate = _reward.add(leftover).div(rewardsDuration).to96(); ```  _Example:_ If the reward rate is 1 token (10**18) per second and 3.5 days are left (302400 seconds), we get a leftover of 302400 tokens. this is then divided by 604800, the reward rate is now 0.5 and the user of the protocol will have to wait one week for tokens that were supposed to be distributed over 3.5 days. This can be repeated again and again so that some rewards are never distributed.    ### Suggestion I can see that [queueNewRewards](https://github.com/aurafinance/aura-contracts-lite/blob/main/contracts/AuraLocker.sol#L820) has some protective mechanism. A new period is started only if the token that is added on top of the already distributed tokens during the duration is over 120%.  I suggest adding a similar check to [queueNewRewards](https://github.com/aurafinance/aura-contracts-lite/blob/main/contracts/AuraLocker.sol#L820)   "}, {"title": "Upgraded Q -> M from 104 [1656258768065]", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/239", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "upgraded by judge"], "target": "2022-06-notional-coop-findings", "body": "Judge has assessed an item in Issue #104 as Medium risk. The relevant finding follows:\r \r ## L01: Silent overflow of `_fCashAmount`\r \r ### Line References\r \r [https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/index-coop-notional-trade-module/contracts/protocol/modules/v1/NotionalTradeModule.sol#L526](https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/index-coop-notional-trade-module/contracts/protocol/modules/v1/NotionalTradeModule.sol#L526)\r \r ### Description\r \r If a `_fCashAmount` value that is greater than uint88 is passed into the `_mint` function, downcasting it to uint88 will silently overflow. \r \r ### Recommended Mitigation Steps\r \r ```solidity\r // Use a safe downcast function e.g. wfCashLogic::_safeUint88\r function _safeUint88(uint256 x) internal pure returns (uint88) {hil\r     require(x <= uint256(type(uint88).max));\r     return uint88(x);\r }\r ```\r "}, {"title": "User can alter amount returned by redeem function due to control transfer", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/235", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-06-notional-coop-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/notional-wrapped-fcash/contracts/wfCashERC4626.sol#L212-L222   # Vulnerability details  ## Impact Control is transferred to the receiver when receiving the ERC777. They are able to transfer the ERC777 to another account, at which time the before and after balance calculation will be incorrect.  ```         uint256 balanceBefore = IERC20(asset()).balanceOf(receiver);           if (msg.sender != owner) {             _spendAllowance(owner, msg.sender, shares);         }         _redeemInternal(shares, receiver, owner); ///////////// Control is transferred to user. They can alter their balance here. ///////////          uint256 balanceAfter = IERC20(asset()).balanceOf(receiver);         uint256 assets = balanceAfter - balanceBefore;  ////////// Assets can be as low as 0 if they have transferred the same amount out as received. //////////          emit Withdraw(msg.sender, receiver, owner, assets, shares);         return assets; ```  ## Tools Used Manual review  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/234", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-notional-coop-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/233", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-notional-coop-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/232", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-notional-coop-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/231", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-notional-coop-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/230", "labels": ["bug", "G (Gas Optimization)", "Notional"], "target": "2022-06-notional-coop-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/228", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-notional-coop-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/227", "labels": ["bug", "QA (Quality Assurance)", "Notional"], "target": "2022-06-notional-coop-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/224", "labels": ["bug", "G (Gas Optimization)", "Notional"], "target": "2022-06-notional-coop-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/223", "labels": ["bug", "G (Gas Optimization)", "Index"], "target": "2022-06-notional-coop-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/222", "labels": ["bug", "QA (Quality Assurance)", "Notional"], "target": "2022-06-notional-coop-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/220", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-notional-coop-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/218", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-notional-coop-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/217", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-notional-coop-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/215", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-notional-coop-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/213", "labels": ["bug", "G (Gas Optimization)", "Notional"], "target": "2022-06-notional-coop-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/212", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-notional-coop-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/211", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-notional-coop-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/210", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-notional-coop-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/209", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-notional-coop-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/208", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-notional-coop-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/205", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-notional-coop-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/204", "labels": ["bug", "G (Gas Optimization)", "Notional"], "target": "2022-06-notional-coop-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/203", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-notional-coop-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/202", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-notional-coop-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/201", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-notional-coop-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/194", "labels": ["bug", "QA (Quality Assurance)", "Notional"], "target": "2022-06-notional-coop-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/192", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-notional-coop-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/191", "labels": ["bug", "G (Gas Optimization)", "Index"], "target": "2022-06-notional-coop-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/190", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-notional-coop-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/189", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-notional-coop-findings", "body": "QA Report"}, {"title": "`IsWrappedFcash` check is a gas bomb", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/188", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "Index"], "target": "2022-06-notional-coop-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-notional-coop/blob/main/index-coop-notional-trade-module/contracts/protocol/modules/v1/NotionalTradeModule.sol#L639-L647   # Vulnerability details  ## Impact In the `_isWrappedFCash` check, the `notionalTradeModule` check whether the component is a wrappedCash with the following logic.  ```soliditiy         try IWrappedfCash(_fCashPosition).getDecodedID() returns(uint16 _currencyId, uint40 _maturity){             try wrappedfCashFactory.computeAddress(_currencyId, _maturity) returns(address _computedAddress){                 return _fCashPosition == _computedAddress;             } catch {                 return false;             }         } catch {             return false;         } ```  The above logic is dangerous when `_fCashPosition` do not revert on `getDecodedID` but instead give a wrong format of return value. The contract would try to decode the return value into `returns(uint16 _currencyId, uint40 _maturity)` and revert. The revert would consume what ever gas it's provided.  [CETH](https://etherscan.io/address/0x4Ddc2D193948926D02f9B1fE9e1daa0718270ED5) is an exmple. There's a fallback function in `ceth` ```soliditiy     function () external payable {         requireNoError(mintInternal(msg.value), \"mint failed\");     } ``` As a result, calling `getDecodedID` would not revert. Instead, calling `getDecodedID` of `CETH` would consume all remaining gas. This creates so many issues. First, users would waste too much gas on a regular operation. Second, the transaction might fail if `ceth` is not the last position. Third, the wallet contract can not interact with set token with ceth as it consumes all gas.   ## Proof of Concept  The following contract may fail to redeem setTokens as it consumes too much gas (with 20M gas limit).    [Test.sol](https://gist.github.com/Jonah246/fad9e489fe84a6fb8b4894d7377fd8a2)  ```soliditiy     function test(uint256 _amount) external {         cToken.approve(address(issueModule), uint256(-1));         wfCash.approve(address(issueModule), uint256(-1));         issueModule.issue(setToken, _amount, address(this));         issueModule.redeem(setToken, _amount, address(this));     } ```  Also, we can check how much gas it consumes with the following function.  ```soliditiy     function TestWrappedFCash(address _fCashPosition) public view returns(bool){         if(!_fCashPosition.isContract()) {             return false;         }         try IWrappedfCash(_fCashPosition).getDecodedID() returns(uint16 _currencyId, uint40 _maturity){             try wrappedfCashFactory.computeAddress(_currencyId, _maturity) returns(address _computedAddress){                 return _fCashPosition == _computedAddress;             } catch {                 return false;             }         } catch {             return false;         }     } ```  Test this function with `cdai` and `ceth`, we can observe that there's huge difference of gas consumption here. ``` Gas used:            30376 of 130376 Gas used:            19479394 of 19788041 ``` ## Tools Used Manual inspection. Hardhat  ## Recommended Mitigation Steps  I recommend building a map in the notionalTradeModule and inserting the wrappeCash in the `mintFCashPosition` function.  ```soliditiy function addWrappedCash(uint16 _currencyId, uint40 _maturity) public {     address computedAddress = wrappedfCashFactory.computeAddress(_currencyId, _maturity);     wrappedFCash[computedAddress] = true; } ```  Or we could replace the try-catch pattern with a low-level function call and check the return value's length before decoding it.  Something like this might be a fix. ```soliditiy     (bool success, bytes memory returndata) = target.delegatecall(data);     if (!success || returndata.length != DECODED_ID_RETURN_LENGTH) {         return false;     }    // abi.decode .... ```  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/187", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-notional-coop-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/186", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-notional-coop-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/185", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-notional-coop-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/184", "labels": ["bug", "G (Gas Optimization)", "Notional"], "target": "2022-06-notional-coop-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/180", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-notional-coop-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/178", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-notional-coop-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/177", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-notional-coop-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/175", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-notional-coop-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/173", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-notional-coop-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/172", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-notional-coop-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/171", "labels": ["bug", "QA (Quality Assurance)", "Index"], "target": "2022-06-notional-coop-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/170", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-notional-coop-findings", "body": "QA Report"}, {"title": "wfCash4626 withdraw method can settle the account", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/169", "labels": ["bug", "disagree with severity", "QA (Quality Assurance)", "sponsor confirmed", "Notional"], "target": "2022-06-notional-coop-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-notional-coop/blob/main/notional-wrapped-fcash/contracts/wfCashERC4626.sol#L192   # Vulnerability details  `withdraw` will revert if the account has not been settled yet. This is just due to the implementation and can be avoided by, well, settling the account.  ## Impact `withdraw` reverts unnecessarily. Protocols and users which will use wfCash4626 will have to discover this and settle by themselves.  ## Proof of Concept `withdraw` [calls](https://github.com/code-423n4/2022-06-notional-coop/blob/main/notional-wrapped-fcash/contracts/wfCashERC4626.sol#L192) `previewWithdraw`, which ends up calling `_getMaturedValue`, which [will revert](https://github.com/code-423n4/2022-06-notional-coop/blob/main/notional-wrapped-fcash/contracts/wfCashERC4626.sol#L23) if the account is not settled yet.  ## Recommended Mitigation Steps Add to `withdraw`: ``` NotionalV2.settleAccount(address(this)); ``` This will ensure that the account is settled and `withdraw` will not revert.  "}, {"title": "DOS set token through erc777 hook", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/168", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "Notional"], "target": "2022-06-notional-coop-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-notional-coop/blob/main/index-coop-notional-trade-module/contracts/protocol/modules/v1/DebtIssuanceModule.sol#L131-L141 https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC777/ERC777.sol#L376-L380   # Vulnerability details  ## Impact The `wfCash` is an `erc777` token. [ERC777.sol#L376-L380](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC777/ERC777.sol#L376-L380) Users can get the control flow before sending token and after receiving tokens. This creates attack vectors that require extra caution in designing modules. Any combination of modules may lead to a possible exploit. To elaborate on the dangerousness of the re-entrancy attack, a possible scenario is presented.  Before the exploit, we first elaborate on three attack vectors:  1. [DebtIssuanceModule.sol#L131-L141](https://github.com/code-423n4/2022-06-notional-coop/blob/main/index-coop-notional-trade-module/contracts/protocol/modules/v1/DebtIssuanceModule.sol#L131-L141) The issuance module would pull tokens from the sender before minting setToken. Assume there are three compoenents in this set. 1. CDai. 2. wfCash  In the `_callTokensToSend`, the setToken has received `cdai` and the `totalSupply` is still the same.  2. `nonReentrant` does not protect cross-contract re-entrancy. This means, that during the `issue` of issuance module, users can trigger other modules' functions.  3. Restricted functions with `onlyManagerAndValidSet` modifier may be triggered by the exploiter as well. Manager of a setToken is usually a manager contract. Assume it's a multisig-wallet, the exploiter can front-run the execute transaction and replay the payload during his exploit. Note, a private transaction from flash-bot can still be front-run. Please refer to the [uncle bandit risk](https://docs.flashbots.net/flashbots-protect/rpc/uncle-bandits)   Given the above attack vectors, the exploiter have enough weapons to exploit the `setToken` at a propriate time. Note that different combination of modules may have different exploit paths. As long as the above attack vectors remain, the setToken is vulnerable.  Assume a setToken with `CompoundLeverageModule`, `NotionalTradeModule` and `BasicIssuanceModule` with the following positions: 1. CDAI: 100  2. wfCash-DAI 100  and totalSupply = 100. The community decides to remove the `compoundLeverageModule` from the set token. Since `notionalTradeModule` can handle cDAI, the community vote to just call `removeModule` to remove `compoundLeverageModule`. The exploiter has the time to build an exploit and wait the right timing to come.  0. The exploiter listen the manager multisig wallet. 1. Exploiter issue 10 setToken. 2. During the `_callTokensToSend` of `wfcash`, the totalSupply = 100, CDAI = 110, wfCash-DAI = 110. 3. Call `sync` of `CompoundLeverageModule`. `_getCollateralPosition` get  `_cToken.balanceOf(address(_setToken)) = 110` and `totalSupply = 100` and update the `DefaultUnit` of `CETH` 1,1X. 4. Replay multisig wallet's payload and remove `compoundLeverageModule`. 5. The `setToken` can no longer issue / redeem as it would raise `undercollateralized` error. Further, `setValuer` would give a pumped valuation that may cause harm to other protocols.   ## Proof of Concept  [POC](https://gist.github.com/Jonah246/13e58b59765c0334189c99a9f29c6dab) The exploit is quite lengthy. Please check the `Attack.sol` for the main exploit logic. ```soliditiy     function register() public {         _ERC1820_REGISTRY.setInterfaceImplementer(address(this), _TOKENS_SENDER_INTERFACE_HASH, address(this));         _ERC1820_REGISTRY.setInterfaceImplementer(address(this), _TOKENS_SENDER_INTERFACE_HASH, address(this));     }      function attack(uint256 _amount) external {         cToken.approve(address(issueModule), uint256(-1));         wfCash.approve(address(issueModule), uint256(-1));         issueModule.issue(setToken, _amount, address(this));     }      function tokensToSend(         address operator,         address from,         address to,         uint256 amount,         bytes calldata userData,         bytes calldata operatorData     ) external {         compoundModule.sync(setToken, false);         manager.removeModule(address(setToken));     } ```  ## Tools Used Manual inspection.  ## Recommended Mitigation Steps  The design choice of wfcash being an `ERC777` seems unnecessary to me. Over the past two years, ERC777 leads to so many exploits. [IMBTC-UNISWAP](https://defirate.com/imbtc-uniswap-hack/) [CREAM-AMP](https://twitter.com/CreamdotFinance/status/1432249771750686721?s=20) I recommend the team using ERC20 instead.  If the SetToken team considers supporting ERC777 necessary, I recommend implementing protocol-wide cross-contract reentrancy prevention. Please refer to Rari-Capital. [Comptroller.sol#L1978-L2002](https://github.com/Rari-Capital/fuse-v1/blob/development/src/core/Comptroller.sol#L1978-L2002)  Note that, `Rari` was [exploited](https://www.coindesk.com/business/2022/04/30/defi-lender-rari-capitalfei-loses-80m-in-hack/) given this reentrancy prevention. Simply making `nonReentrant` cross-contact prevention may not be enough. I recommend to setToken protocol going through every module and re-consider whether it's re-entrancy safe.  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/166", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-notional-coop-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/165", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-notional-coop-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/164", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-notional-coop-findings", "body": "QA Report"}, {"title": "Residual Allowance Might Allow Tokens In SetToken To Be Stolen", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/160", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "Index"], "target": "2022-06-notional-coop-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/index-coop-notional-trade-module/contracts/protocol/modules/v1/NotionalTradeModule.sol#L418 https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/index-coop-notional-trade-module/contracts/protocol/modules/v1/NotionalTradeModule.sol#L493   # Vulnerability details  ## Proof-of-Concept  Whenever `_mintFCashPosition` function is called to mint new fCash position, the contract will call the `_approve` function to set the allowance to `_maxSendAmount` so that the fCash Wrapper contact can pull the payment tokens from the SetToken contract during minting.  [https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/index-coop-notional-trade-module/contracts/protocol/modules/v1/NotionalTradeModule.sol#L418](https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/index-coop-notional-trade-module/contracts/protocol/modules/v1/NotionalTradeModule.sol#L418)  ```solidity function _mintFCashPosition(     ISetToken _setToken,     IWrappedfCashComplete _fCashPosition,     IERC20 _sendToken,     uint256 _fCashAmount,     uint256 _maxSendAmount ) internal returns(uint256 sentAmount) {     if(_fCashAmount == 0) return 0;     bool fromUnderlying = _isUnderlying(_fCashPosition, _sendToken);       _approve(_setToken, _fCashPosition, _sendToken, _maxSendAmount);      uint256 preTradeSendTokenBalance = _sendToken.balanceOf(address(_setToken));     uint256 preTradeReceiveTokenBalance = _fCashPosition.balanceOf(address(_setToken));      _mint(_setToken, _fCashPosition, _maxSendAmount, _fCashAmount, fromUnderlying)   ..SNIP.. } ```  Note that `_maxSendAmount` is the maximum amount of payment tokens that is allowed to be consumed during minting. This is not the actual amount of payment tokens consumed during the minting process. Thus, after the minting, there will definitely be some residual allowance since it is unlikely that the fCash wrapper contract will consume the exact maximum amount during minting.  The following piece of code shows that having some residual allowance is expected. The `_approve` function will not set the allowance unless there is insufficient allowance.  [https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/index-coop-notional-trade-module/contracts/protocol/modules/v1/NotionalTradeModule.sol#L493](https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/index-coop-notional-trade-module/contracts/protocol/modules/v1/NotionalTradeModule.sol#L493)  ```solidity /**  * @dev Approve the given wrappedFCash instance to spend the setToken's sendToken   */ function _approve(     ISetToken _setToken,     IWrappedfCashComplete _fCashPosition,     IERC20 _sendToken,     uint256 _maxAssetAmount ) internal {     if(IERC20(_sendToken).allowance(address(_setToken), address(_fCashPosition)) < _maxAssetAmount) {         bytes memory approveCallData = abi.encodeWithSelector(_sendToken.approve.selector, address(_fCashPosition), _maxAssetAmount);         _setToken.invoke(address(_sendToken), 0, approveCallData);     } } ```  ## Impact  Having residual allowance increases the risk of the asset tokens being stolen from the SetToken contract. SetToken contract is where all the tokens/assets are held. If the Notional's fCash wrapper contract is compromised, it will allow the compromised fCash wrapper contract to withdraw funds from the SetToken contract due to the residual allowance.   Note that Notional's fCash wrapper contract is not totally immutable, as it is a upgradeable contract. This is an additional risk factor to be considered. If the Notional's deployer account is compromised, the attacker could upgrade the Notional's fCash wrapper contract to a malicious one to withdraw funds from the Index Coop's SetToken contract due to the residual allowance.   Index Coop and Notional are two separate protocols and teams. Thus, it is a good security practice not to place any trust on external party wherever possible to ensure that if one party is compromised, it won't affect the another party. Thus, there should not be any residual allowance that allows Notional's contract to withdraw fund from Index Coop's contract in any circumstance.  In the worst case scenario, a \"lazy\" manager might simply set the `_maxAssetAmount` to `type(uint256).max`. Thus, this will result in large amount of residual allowance left, and expose the SetToken contract to significant risk.  ## Recommended Mitigation Steps  Approve the allowance on-demand whenever _`mintFCashPosition` is called, and reset the allowance back to zero after each minting process to eliminate any residual allowance.  ```diff function _mintFCashPosition(     ISetToken _setToken,     IWrappedfCashComplete _fCashPosition,     IERC20 _sendToken,     uint256 _fCashAmount,     uint256 _maxSendAmount ) internal returns(uint256 sentAmount) {     if(_fCashAmount == 0) return 0;     bool fromUnderlying = _isUnderlying(_fCashPosition, _sendToken);       _approve(_setToken, _fCashPosition, _sendToken, _maxSendAmount);      uint256 preTradeSendTokenBalance = _sendToken.balanceOf(address(_setToken));     uint256 preTradeReceiveTokenBalance = _fCashPosition.balanceOf(address(_setToken));      _mint(_setToken, _fCashPosition, _maxSendAmount, _fCashAmount, fromUnderlying)   ..SNIP..   + // Reset the allowance back to zero after minting + _approve(_setToken, _fCashPosition, _sendToken, 0); } ```  Update the `_approve` accordingly to remove the if-statement related to residual allowance.  ```diff function _approve(     ISetToken _setToken,     IWrappedfCashComplete _fCashPosition,     IERC20 _sendToken,     uint256 _maxAssetAmount ) internal { -    if(IERC20(_sendToken).allowance(address(_setToken), address(_fCashPosition)) < _maxAssetAmount) {         bytes memory approveCallData = abi.encodeWithSelector(_sendToken.approve.selector, address(_fCashPosition), _maxAssetAmount);         _setToken.invoke(address(_sendToken), 0, approveCallData); -    } } ```  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/158", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-notional-coop-findings", "body": "Gas Optimizations"}, {"title": "Rounding Issues In Certain Functions", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/155", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "Notional"], "target": "2022-06-notional-coop-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/notional-wrapped-fcash/contracts/wfCashERC4626.sol#L52 https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/notional-wrapped-fcash/contracts/wfCashERC4626.sol#L134   # Vulnerability details  ## Background  Per EIP 4626's Security Considerations (https://eips.ethereum.org/EIPS/eip-4626)  > Finally, ERC-4626 Vault implementers should be aware of the need for specific, opposing rounding directions across the different mutable and view methods, as it is considered most secure to favor the Vault itself during calculations over its users: > > - If (1) it\u2019s calculating how many shares to issue to a user for a certain amount of the underlying tokens they provide or (2) it\u2019s determining the amount of the underlying tokens to transfer to them for returning a certain amount of shares, it should round *down*. > - If (1) it\u2019s calculating the amount of shares a user has to supply to receive a given amount of the underlying tokens or (2) it\u2019s calculating the amount of underlying tokens a user has to provide to receive a certain amount of shares, it should round *up*.  Thus, the result of the `previewMint` and `previewWithdraw` should be rounded up.  ## Proof-of-Concept  The current implementation of `convertToShares` function will round down the number of shares returned due to how solidity handles Integer Division. ERC4626 expects the returned value of `convertToShares` to be rounded down. Thus, this function behaves as expected.  [https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/notional-wrapped-fcash/contracts/wfCashERC4626.sol#L52](https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/notional-wrapped-fcash/contracts/wfCashERC4626.sol#L52)  ```solidity function convertToShares(uint256 assets) public view override returns (uint256 shares) {     uint256 supply = totalSupply();     if (supply == 0) {         // Scales assets by the value of a single unit of fCash         uint256 unitfCashValue = _getPresentValue(uint256(Constants.INTERNAL_TOKEN_PRECISION));         return (assets * uint256(Constants.INTERNAL_TOKEN_PRECISION)) / unitfCashValue;     }      return (assets * totalSupply()) / totalAssets(); } ```  ERC 4626 expects the result returned from `previewWithdraw` function to be rounded up. However, within the `previewWithdraw` function, it calls the `convertToShares` function. Recall earlier that the `convertToShares` function returned a rounded down value,  thus `previewWithdraw` will return a rounded down value instead of round up value. Thus, this function does not behave as expected.  [https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/notional-wrapped-fcash/contracts/wfCashERC4626.sol#L134](https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/notional-wrapped-fcash/contracts/wfCashERC4626.sol#L134)  ```solidity function previewWithdraw(uint256 assets) public view override returns (uint256 shares) {     if (hasMatured()) {         shares = convertToShares(assets);     } else {         // If withdrawing non-matured assets, we sell them on the market (i.e. borrow)         (uint16 currencyId, uint40 maturity) = getDecodedID();         (shares, /* */, /* */) = NotionalV2.getfCashBorrowFromPrincipal(             currencyId,             assets,             maturity,             0,             block.timestamp,             true         );     } } ```  `previewWithdraw` and `previewMint` functions rely on `NotionalV2.getfCashBorrowFromPrincipal` and `NotionalV2.getDepositFromfCashLend` functions. Due to the nature of time-boxed contest, I was unable to verify if `NotionalV2.getfCashBorrowFromPrincipal` and `NotionalV2.getDepositFromfCashLend` functions return a rounded down or up value. If a rounded down value is returned from these functions, `previewWithdraw` and `previewMint` functions would not behave as expected.  ## Impact  Other protocols that integrate with Notional's fCash wrapper might wrongly assume that the functions handle rounding as per ERC4626 expectation. Thus, it might cause some intergration problem in the future that can lead to wide range of issues for both parties.  ## Recommended Mitigation Steps  Ensure that the rounding of vault's functions behave as expected. Following are the expected rounding direction for each vault function:  - previewMint(uint256 shares) - Round Up \u2b06  - previewWithdraw(uint256 assets) - Round Up \u2b06  - previewRedeem(uint256 shares) - Round Down \u2b07  - previewDeposit(uint256 assets) - Round Down \u2b07  - convertToAssets(uint256 shares) - Round Down \u2b07  - convertToShares(uint256 assets) - Round Down \u2b07  `previewMint` returns the  amount of assets that would be deposited to mint specific amount of shares. Thus, the amount of assets must be rounded up, so that the vault won't be shortchanged.  `previewWithdraw` returns the amount of shares that would be burned to withdraw specific amount of asset. Thus, the amount of shares must to be rounded up, so that the vault won't be shortchanged.  Following is the OpenZeppelin's vault implementation for rounding reference:  [https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/extensions/ERC20TokenizedVault.sol](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/extensions/ERC20TokenizedVault.sol)  Alternatively, if such alignment of rounding could not be achieved due to technical limitation, at the minimum, document this limitation in the comment so that the developer performing the integration is aware of this.  "}, {"title": "Users Might Not Be Able To Purchase Or Redeem SetToken", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/154", "labels": ["bug", "help wanted", "2 (Med Risk)", "disagree with severity", "sponsor confirmed", "Index"], "target": "2022-06-notional-coop-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/index-coop-notional-trade-module/contracts/protocol/modules/v1/NotionalTradeModule.sol#L309 https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/index-coop-notional-trade-module/contracts/protocol/modules/v1/NotionalTradeModule.sol#L385   # Vulnerability details  ## Proof-of-Concept  Whenever a setToken is issued or redeemed, the `moduleIssueHook` and `moduleRedeemHook` will be triggered. These two hooks will in turn call the `_redeemMaturedPositions` function to ensure that no matured fCash positions remain in the Set by redeeming any matured fCash position.  [https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/index-coop-notional-trade-module/contracts/protocol/modules/v1/NotionalTradeModule.sol#L309](https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/index-coop-notional-trade-module/contracts/protocol/modules/v1/NotionalTradeModule.sol#L309)  ```solidity /**  * @dev Hook called once before setToken issuance  * @dev Ensures that no matured fCash positions are in the set when it is issued  */ function moduleIssueHook(ISetToken _setToken, uint256 /* _setTokenAmount */) external override onlyModule(_setToken) {     _redeemMaturedPositions(_setToken); }  /**  * @dev Hook called once before setToken redemption  * @dev Ensures that no matured fCash positions are in the set when it is redeemed  */ function moduleRedeemHook(ISetToken _setToken, uint256 /* _setTokenAmount */) external override onlyModule(_setToken) {     _redeemMaturedPositions(_setToken); } ```  The `_redeemMaturedPositions` will loop through all its fCash positions and attempts to redeem any fCash position that has already matured. However, if one of the fCash redemptions fails, it will cause the entire function to revert. If this happens, no one could purchase or redeem the setToken because `moduleIssueHook` and `modileRedeemHook` hooks will revert every single time. Thus, the setToken issuance and redemption will stop working entirely and  this setToken can be considered \"bricked\".  [https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/index-coop-notional-trade-module/contracts/protocol/modules/v1/NotionalTradeModule.sol#L385](https://github.com/code-423n4/2022-06-notional-coop/blob/6f8c325f604e2576e2fe257b6b57892ca181509a/index-coop-notional-trade-module/contracts/protocol/modules/v1/NotionalTradeModule.sol#L385)  ```solidity /**  * @dev Redeem all matured fCash positions for the given SetToken  */ function _redeemMaturedPositions(ISetToken _setToken) internal {     ISetToken.Position[] memory positions = _setToken.getPositions();     uint positionsLength = positions.length;      bool toUnderlying = redeemToUnderlying[_setToken];      for(uint256 i = 0; i < positionsLength; i++) {         // Check that the given position is an equity position         if(positions[i].unit > 0) {             address component = positions[i].component;             if(_isWrappedFCash(component)) {                 IWrappedfCashComplete fCashPosition = IWrappedfCashComplete(component);                 if(fCashPosition.hasMatured()) {                     (IERC20 receiveToken,) = fCashPosition.getToken(toUnderlying);                     if(address(receiveToken) == ETH_ADDRESS) {                         receiveToken = weth;                     }                     uint256 fCashBalance = fCashPosition.balanceOf(address(_setToken));                     _redeemFCashPosition(_setToken, fCashPosition, receiveToken, fCashBalance, 0);                 }             }         }     } } ```  ## Impact  User will not be able to purchase or redeem the setToken. User's fund will stuck in the SetToken Contract. Unable to remove matured fCash positions from SetToken and update positions of its asset token.  ## Recommended Mitigation Steps  This is a problem commonly encountered whenever a method of a smart contract calls another contract \u2013 you cannot rely on the other contract to work 100% of the time, and it is dangerous to assume that the external call will always be successful.   It is recommended to:  - Consider alternate method of updating the asset position so that the SetToken's core functions (e.g. issuance and redemption) will not be locked if one of the matured fCash redemptions fails.  - Evaluate if `_redeemMaturedPositions` really need to be called during SetToken's issuance and redemption. If not, consider removing them from the hooks, so that any issue or revert within `_redeemMaturedPositions` won't cause the SetToken's issuance and redemption functions to stop working entirely. - Consider implementing additional function to give manager/user an option to specify a list of matured fCash positions to redeem instead of forcing them to redeem all matured fCash positions at one go.  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/152", "labels": ["bug", "QA (Quality Assurance)", "Notional"], "target": "2022-06-notional-coop-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/150", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-notional-coop-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/149", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-notional-coop-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/148", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-notional-coop-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/147", "labels": ["bug", "G (Gas Optimization)", "Notional"], "target": "2022-06-notional-coop-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/146", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-notional-coop-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/142", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-notional-coop-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/141", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-notional-coop-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/140", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-notional-coop-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/138", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-notional-coop-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/136", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-notional-coop-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/134", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-06-notional-coop-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-06-notional-coop-findings/issues/131", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-06-notional-coop-findings", "body": "QA Report"}]