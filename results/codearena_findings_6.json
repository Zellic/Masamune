[{"title": "Unnecessary checked arithmetic in for loops", "html_url": "https://github.com/code-423n4/2021-10-tally-findings/issues/73", "labels": ["bug", "G (Gas Optimization)", "sponsor disputed"], "target": "2021-10-tally-findings", "body": "Unnecessary checked arithmetic in for loops"}, {"title": "Unnecessary array boundaries check when loading an array element twice", "html_url": "https://github.com/code-423n4/2021-10-tally-findings/issues/72", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-10-tally-findings", "body": "# Handle  robee   # Vulnerability details  There are places in the code (especially in for-each loops) that loads the same array element more than once. In such cases, only one array boundaries check should take place, and the rest are unnecessary. Therefore, this array element should be cached in a local variable and then be loaded  again using this local variable, skipping the redundent second array boundaries check:           ConvexStakingWrapper.sol, variable name: _accounts times: 5 at: _calcRewardIntegral         ConvexStakingWrapper.sol, variable name: _accounts times: 5 at: _calcCvxIntegral  "}, {"title": "Prefix increaments are cheaper than postfix increaments", "html_url": "https://github.com/code-423n4/2021-10-tally-findings/issues/71", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-10-tally-findings", "body": "Prefix increaments are cheaper than postfix increaments"}, {"title": "`internal` functions can be `private`", "html_url": "https://github.com/code-423n4/2021-10-tally-findings/issues/70", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-10-tally-findings", "body": "`internal` functions can be `private`"}, {"title": "Users can avoid paying fees for ETH swaps", "html_url": "https://github.com/code-423n4/2021-10-tally-findings/issues/68", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2021-10-tally-findings", "body": "Users can avoid paying fees for ETH swaps"}, {"title": "`Swap.setFeeRecipient()` emits a `NewFeeRecipient` when the fee recipient hasn't changed", "html_url": "https://github.com/code-423n4/2021-10-tally-findings/issues/67", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor acknowledged"], "target": "2021-10-tally-findings", "body": "`Swap.setFeeRecipient()` emits a `NewFeeRecipient` when the fee recipient hasn't changed"}, {"title": "`Swap.setSwapFee()` emits a `NewSwapFee` when the swap fee hasn't changed", "html_url": "https://github.com/code-423n4/2021-10-tally-findings/issues/66", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor acknowledged"], "target": "2021-10-tally-findings", "body": "`Swap.setSwapFee()` emits a `NewSwapFee` when the swap fee hasn't changed"}, {"title": "Cache or use existing memory versions of state variables (feeRecipient, swapFee)", "html_url": "https://github.com/code-423n4/2021-10-tally-findings/issues/64", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-10-tally-findings", "body": "Cache or use existing memory versions of state variables (feeRecipient, swapFee)"}, {"title": "Unnecessary `SLOAD` in `Swap.setSwapFee()`", "html_url": "https://github.com/code-423n4/2021-10-tally-findings/issues/63", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-tally-findings", "body": "# Handle  pants   # Vulnerability details  This line in `Swap.setSwapFee()` perfoms an `SLOAD` operation for a value that is already stored in a local variable: ``` emit NewSwapFee(swapFee); ```  ## Impact Storage reads are much more expensive than reading local variables.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Use the already existing local variable instead of loading this value from storage: ``` emit NewSwapFee(swapFee_); ```  "}, {"title": "Unnecessary require statement in `Swap`'s constructor", "html_url": "https://github.com/code-423n4/2021-10-tally-findings/issues/62", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-10-tally-findings", "body": "Unnecessary require statement in `Swap`'s constructor"}, {"title": "Unnecessary `SLOAD`s in `EmergencyGovernable.onlyTimelockOrEmergencyGovernance()`", "html_url": "https://github.com/code-423n4/2021-10-tally-findings/issues/61", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-10-tally-findings", "body": "Unnecessary `SLOAD`s in `EmergencyGovernable.onlyTimelockOrEmergencyGovernance()`"}, {"title": "Inclusive check", "html_url": "https://github.com/code-423n4/2021-10-tally-findings/issues/49", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-10-tally-findings", "body": "Inclusive check"}, {"title": "use of floating pragma", "html_url": "https://github.com/code-423n4/2021-10-tally-findings/issues/46", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-10-tally-findings", "body": "use of floating pragma"}, {"title": "Gas: Math library could be \"unchecked\"", "html_url": "https://github.com/code-423n4/2021-10-tally-findings/issues/43", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-tally-findings", "body": "# Handle  cmichel   # Vulnerability details  The `Math` library uses Solidity version 0.8 which comes with built-in overflow checks which cost gas.  The code already checks for underflows (`a > b` before doing the division), and therefore the built-in checks can be disabled everywhere for improved gas cost.  ```solidity pragma solidity ^0.8.0;  library Math {     function subOrZero(uint256 a, uint256 b) internal pure returns (uint256) {       unchecked {         return a > b ? a - b : 0;       }     }      function subOrZero(uint128 a, uint128 b) internal pure returns (uint128) {       unchecked {         return a > b ? a - b : 0;       }     }      function subOrZero(uint64 a, uint64 b) internal pure returns (uint64) {       unchecked {         return a > b ? a - b : 0;       }     }      function subOrZero(uint32 a, uint32 b) internal pure returns (uint32) {       unchecked {         return a > b ? a - b : 0;       }     } } ```  "}, {"title": "Gas: SafeMath is not needed when using Solidity version 0.8", "html_url": "https://github.com/code-423n4/2021-10-tally-findings/issues/42", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-tally-findings", "body": "# Handle  cmichel   # Vulnerability details  The `Swap` contract uses Solidity version 0.8 which already implements overflow checks by default. At the same time, it uses the `SafeMath` library which is more gas expensive than the 0.8 overflow checks.  It should just use the built-in checks and remove `SafeMath` from the dependencies:  ```solidity // @audit can just normal arithmetic here uint256 toTransfer = SWAP_FEE_DIVISOR.sub(swapFee).mul(boughtERC20Amount).div(SWAP_FEE_DIVISOR);  // uint256 toTransfer = (SWAP_FEE_DIVISOR - swapFee) * boughtERC20Amount / SWAP_FEE_DIVISOR;  // same with many other computations ```  "}, {"title": "Gas: minReceived check can be simplified", "html_url": "https://github.com/code-423n4/2021-10-tally-findings/issues/41", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-tally-findings", "body": "# Handle  cmichel   # Vulnerability details  The `minimumAmountReceived` check in `Swap.swapByQuote` is implemented like this:  ```solidity require(     (         !signifiesETHOrZero(zrxBuyTokenAddress) &&         boughtERC20Amount >= minimumAmountReceived     ) ||     (         signifiesETHOrZero(zrxBuyTokenAddress) &&         boughtETHAmount >= minimumAmountReceived     ),     \"Swap::swapByQuote: Minimum swap proceeds requirement not met\" ); ```  It can be simplified to this which performs less calls to `signifiesETHOrZero` and less logical operators:  ```solidity require( (signifiesETHOrZero(zrxBuyTokenAddress) ? boughtETHAmount : boughtERC20Amount) >= minimumAmountReceived, \"...\"); ```   "}, {"title": "Contract does not work well with fee-on transfer tokens", "html_url": "https://github.com/code-423n4/2021-10-tally-findings/issues/40", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-10-tally-findings", "body": "Contract does not work well with fee-on transfer tokens"}, {"title": "Arbitrary contract call allows attackers to steal ERC20 from users' wallets", "html_url": "https://github.com/code-423n4/2021-10-tally-findings/issues/37", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-10-tally-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-10-tally/blob/c585c214edb58486e0564cb53d87e4831959c08b/contracts/swap/Swap.sol#L200-L212  ```solidity function fillZrxQuote(     IERC20 zrxBuyTokenAddress,     address payable zrxTo,     bytes calldata zrxData,     uint256 ethAmount ) internal returns (uint256, uint256) {     uint256 originalERC20Balance = 0;     if(!signifiesETHOrZero(address(zrxBuyTokenAddress))) {         originalERC20Balance = zrxBuyTokenAddress.balanceOf(address(this));     }     uint256 originalETHBalance = address(this).balance;      (bool success,) = zrxTo.call{value: ethAmount}(zrxData); ```  A call to an arbitrary contract with custom calldata is made in `fillZrxQuote()`, which means the contract can be an ERC20 token, and the calldata can be `transferFrom` a previously approved user.  ### Impact  The wallet balances (for the amount up to the allowance limit) of the tokens that users approved to the contract can be stolen.  ### PoC  Given:  - Alice has approved 1000 WETH to `Swap.sol`;  The attacker can:  ``` TallySwap.swapByQuote(     address(WETH),     0,     address(WETH),     0,     address(0),     address(WETH),     abi.encodeWithSignature(         \"transferFrom(address,address,uint256)\",         address(Alice),         address(this),         1000 ether     ) ) ```  As a result, 1000 WETH will be stolen from Alice and sent to the attacker.  This PoC has been tested on a forking network.  ### Recommendation  Consider adding a whitelist for `zrxTo` addresses.  "}, {"title": "Unused ERC20 tokens are not refunded", "html_url": "https://github.com/code-423n4/2021-10-tally-findings/issues/36", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor acknowledged"], "target": "2021-10-tally-findings", "body": "Unused ERC20 tokens are not refunded"}, {"title": "Consider removing `Math.sol`", "html_url": "https://github.com/code-423n4/2021-10-tally-findings/issues/35", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-10-tally-findings", "body": "Consider removing `Math.sol`"}, {"title": "Wrong calculation of `erc20Delta` and `ethDelta`", "html_url": "https://github.com/code-423n4/2021-10-tally-findings/issues/34", "labels": ["bug", "3 (High Risk)", "disagree with severity", "sponsor confirmed"], "target": "2021-10-tally-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-10-tally/blob/c585c214edb58486e0564cb53d87e4831959c08b/contracts/swap/Swap.sol#L200-L225  ```solidity function fillZrxQuote(     IERC20 zrxBuyTokenAddress,     address payable zrxTo,     bytes calldata zrxData,     uint256 ethAmount ) internal returns (uint256, uint256) {     uint256 originalERC20Balance = 0;     if(!signifiesETHOrZero(address(zrxBuyTokenAddress))) {         originalERC20Balance = zrxBuyTokenAddress.balanceOf(address(this));     }     uint256 originalETHBalance = address(this).balance;      (bool success,) = zrxTo.call{value: ethAmount}(zrxData);     require(success, \"Swap::fillZrxQuote: Failed to fill quote\");      uint256 ethDelta = address(this).balance.subOrZero(originalETHBalance);     uint256 erc20Delta;     if(!signifiesETHOrZero(address(zrxBuyTokenAddress))) {         erc20Delta = zrxBuyTokenAddress.balanceOf(address(this)).subOrZero(originalERC20Balance);         require(erc20Delta > 0, \"Swap::fillZrxQuote: Didn't receive bought token\");     } else {         require(ethDelta > 0, \"Swap::fillZrxQuote: Didn't receive bought ETH\");     }      return (erc20Delta, ethDelta); } ```  When a user tries to swap unwrapped ETH to ERC20, even if there is a certain amount of ETH refunded, at L215, `ethDelta` will always be `0`.   That's because `originalETHBalance` already includes the `msg.value` sent by the caller.  Let's say the ETH balance of the contract is `1 ETH` before the swap.  - A user swaps `10 ETH` to USDC; - `originalETHBalance` will be `11 ETH`; - If there is `1 ETH` of refund; - `ethDelta` will be `0` as the new balance is `2 ETH` and `subOrZero(2, 11)` is `0`.  Similarly, `erc20Delta` is also computed wrong.  Consider a special case of a user trying to arbitrage from `WBTC` to `WBTC`, the `originalERC20Balance` already includes the input amount, `erc20Delta` will always be much lower than the actual delta amount.  For example, for an arb swap from `1 WBTC` to `1.1 WBTC`, the `ethDelta` will be `0.1 WBTC` while it should be `1.1 WBTC`.  ### Impact  - User can not get ETH refund for swaps from ETH to ERC20 tokens; - Arb swap with the same input and output token will suffer the loss of almost all of their input amount unexpectedly.  ### Recommendation  Consider subtracting the input amount from the originalBalance.  "}, {"title": "Check if `boughtETHAmount > 0` can save gas", "html_url": "https://github.com/code-423n4/2021-10-tally-findings/issues/31", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-10-tally-findings", "body": "Check if `boughtETHAmount > 0` can save gas"}, {"title": "Wrong value for `SwappedTokens` event parameter", "html_url": "https://github.com/code-423n4/2021-10-tally-findings/issues/28", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-10-tally-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-10-tally/blob/c585c214edb58486e0564cb53d87e4831959c08b/contracts/swap/Swap.sol#L174-L180  ```solidity emit SwappedTokens(     zrxSellTokenAddress,     zrxBuyTokenAddress,     amountToSell,     boughtETHAmount,     boughtETHAmount.sub(toTransfer) ); ```  `amountToSell` will be 0 according to the comment: `If selling unwrapped ETH via msg.value, this should be 0.`, therefore, `msg.value` should be used instead.  ### Recommendation  Change to:  ```solidity emit SwappedTokens(     zrxSellTokenAddress,     zrxBuyTokenAddress,     msg.value,     boughtETHAmount,     boughtETHAmount.sub(toTransfer) ); ```  "}, {"title": "Insufficient input validation", "html_url": "https://github.com/code-423n4/2021-10-tally-findings/issues/25", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-10-tally-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/maple-labs/debt-locker/blob/81f55907db7b23d27e839b9f9f73282184ed4744/contracts/DebtLocker.sol#L85-L89  ```solidity=85 function setAllowedSlippage(uint256 allowedSlippage_) external override whenProtocolNotPaused {         require(msg.sender == _getPoolDelegate(), \"DL:SAS:NOT_PD\");          emit AllowedSlippageSet(_allowedSlippage = allowedSlippage_);     } ```  Considering that `_allowedSlippage` is a crucial settings for `getExpectedAmount()`, it's necessary to add `require(_allowedSlippage <  10000, \"...\")` to validate the input.  If `_allowedSlippage` is misconfigured to a value > `10000`, `getExpectedAmount()` will always revert.  ### Recommendation  Change to:  ```solidity=85 function setAllowedSlippage(uint256 allowedSlippage_) external override whenProtocolNotPaused {         require(msg.sender == _getPoolDelegate(), \"DL:SAS:NOT_PD\");         require(_allowedSlippage <  10000, \"!slippage\")          emit AllowedSlippageSet(_allowedSlippage = allowedSlippage_);     } ```  "}, {"title": "Upgrade pragma to at least 0.8.4", "html_url": "https://github.com/code-423n4/2021-10-tally-findings/issues/23", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-10-tally-findings", "body": "# Handle  robee   # Vulnerability details           Using newer compiler versions and the optimizer gives gas optimizations         and additional safety checks are available for free.                  The advantages of versions 0.8.* over <0.8.0 are:                  1. Safemath by default from 0.8.0 (can be more gas efficient than library based safemath.)         2. Low level inliner : from 0.8.2, leads to cheaper runtime gas. Especially relevant when the contract has small functions. For example, OpenZeppelin libraries typically have a lot of small helper functions and if they are not inlined, they cost an additional 20 to 40 gas because of 2 extra jump instructions and additional stack operations needed for function calls.         3. Optimizer improvements in packed structs: Before 0.8.3, storing packed structs, in some cases used an additional storage read operation. After EIP-2929, if the slot was already cold, this means unnecessary stack operations and extra deploy time costs. However, if the slot was already warm, this means additional cost of 100 gas alongside the same unnecessary stack operations and extra deploy time costs.         4. Custom errors from 0.8.4, leads to cheaper deploy time cost and run time cost. Note: the run time cost is only relevant when the revert condition is met. In short, replace revert strings by custom errors.              IController.sol         IManager.sol         Manager.sol         BridgeMinter.sol   "}, {"title": "Events not indexed", "html_url": "https://github.com/code-423n4/2021-10-tally-findings/issues/22", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-10-tally-findings", "body": "Events not indexed"}, {"title": "Incorrect FeesSwept amount being emitted in sweepFees function", "html_url": "https://github.com/code-423n4/2021-10-tally-findings/issues/21", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-10-tally-findings", "body": "# Handle  harleythedog   # Vulnerability details  ## Impact In the sweepFees function, address(this).balance is being used as the \"amount\" in the SweepFees event immediately after a transfer. So, the amount in the event on line 258 will always be 0, but it should be what address(this).balance was before the transfer. This has implications on overall functionality, tools that are monitoring this event will receive incorrect information. A fix is to store the value before calling the transfer.  ## Proof of Concept referenced lines in sweepFees function: https://github.com/code-423n4/2021-10-tally/blob/main/contracts/swap/Swap.sol#:~:text=feeRecipient.transfer(address,this).balance%2C%20feeRecipient)%3B  A more correct implementation would be:  uint256 amount = address(this).balance; feeRecipient.transfer(address(this).balance); emit FeesSwept(address(0), amount, feeRecipient);  ## Tools Used Manual inspection  ## Recommended Mitigation Steps Store balance before calling transfer, as above.  "}, {"title": "Swap.sol implements potentially dangerous transfer ", "html_url": "https://github.com/code-423n4/2021-10-tally-findings/issues/20", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2021-10-tally-findings", "body": "Swap.sol implements potentially dangerous transfer "}, {"title": "Emit feeRecipient_ (memory) instead of feeRecipient (storage)", "html_url": "https://github.com/code-423n4/2021-10-tally-findings/issues/19", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-10-tally-findings", "body": "Emit feeRecipient_ (memory) instead of feeRecipient (storage)"}, {"title": "Remove duplicate reads of storage variables", "html_url": "https://github.com/code-423n4/2021-10-tally-findings/issues/18", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-10-tally-findings", "body": "Remove duplicate reads of storage variables"}, {"title": "frontrun swapByQuote or abuse high allowance - replacement", "html_url": "https://github.com/code-423n4/2021-10-tally-findings/issues/17", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor acknowledged"], "target": "2021-10-tally-findings", "body": "frontrun swapByQuote or abuse high allowance - replacement"}, {"title": "double reading calldata variable inside a loop ", "html_url": "https://github.com/code-423n4/2021-10-tally-findings/issues/13", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-10-tally-findings", "body": "double reading calldata variable inside a loop "}, {"title": "Swap fee can be set to 100%", "html_url": "https://github.com/code-423n4/2021-10-tally-findings/issues/10", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-10-tally-findings", "body": "Swap fee can be set to 100%"}, {"title": "Use of uint8 for counter in for loop increases gas costs", "html_url": "https://github.com/code-423n4/2021-10-tally-findings/issues/7", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-10-tally-findings", "body": "Use of uint8 for counter in for loop increases gas costs"}, {"title": "Gas Optimization: Reduce the size of error messages.", "html_url": "https://github.com/code-423n4/2021-10-tally-findings/issues/5", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-10-tally-findings", "body": "Gas Optimization: Reduce the size of error messages."}, {"title": "Unnecessary conditions causing Over Gas consumption", "html_url": "https://github.com/code-423n4/2021-10-tally-findings/issues/3", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-10-tally-findings", "body": "Unnecessary conditions causing Over Gas consumption"}, {"title": "Unnecessary conditions cause Gas wastage", "html_url": "https://github.com/code-423n4/2021-10-tally-findings/issues/2", "labels": ["bug", "G (Gas Optimization)", "sponsor disputed"], "target": "2021-10-tally-findings", "body": "Unnecessary conditions cause Gas wastage"}, {"title": "`MochiVault.flashFee()` May Truncate Result", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/171", "labels": ["bug", "1 (Low Risk)"], "target": "2021-10-mochi-findings", "body": "`MochiVault.flashFee()` May Truncate Result"}, {"title": "`flashLoan()` is Lacking Protections Against Reentrancy", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/170", "labels": ["bug", "0 (Non-critical)"], "target": "2021-10-mochi-findings", "body": "`flashLoan()` is Lacking Protections Against Reentrancy"}, {"title": "`MochiTreasuryV0.sol` Is Unusable In Its Current State", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/168", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-10-mochi-findings", "body": "# Handle  leastwood   # Vulnerability details  ## Impact  `MochiTreasuryV0.sol` interacts with Curve's voting escrow contract to lock tokens for 90 days, where it can be later withdrawn by the governance role. However, `VotingEscrow.vy` does not allow contracts to call the following functions; `create_lock()`, `increase_amount()` and `increase_unlock_time()`. For these functions, `msg.sender` must be an EOA account or an approved smart wallet. As a result, any attempt to lock tokens will fail in `MochiTreasuryV0.sol`.  ## Proof of Concept  https://github.com/curvefi/curve-dao-contracts/blob/master/contracts/VotingEscrow.vy#L418 https://github.com/curvefi/curve-dao-contracts/blob/master/contracts/VotingEscrow.vy#L438 https://github.com/curvefi/curve-dao-contracts/blob/master/contracts/VotingEscrow.vy#L455  ## Tools Used  Manual code review Discussions with the Mochi team  ## Recommended Mitigation Steps  Consider updating this contract to potentially use another escrow service that enables `msg.sender` to be a contract. Alternatively, this escrow functionality can be replaced with an internal contract which holds `usdm` tokens instead, removing the need to convert half of the tokens to Curve tokens. Holding Curve tokens for a minimum of 90 days may overly expose the Mochi treasury to Curve token price fluctuations.  "}, {"title": "Mochi Protocol Is Lacking Extensive Test Coverage", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/167", "labels": ["0 (Non-critical)", "disagree with severity"], "target": "2021-10-mochi-findings", "body": "Mochi Protocol Is Lacking Extensive Test Coverage"}, {"title": "`MochiTreasuryV0.claimOperationCost()` Writes State Variable After An External Call Is Made", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/163", "labels": ["bug", "0 (Non-critical)"], "target": "2021-10-mochi-findings", "body": "`MochiTreasuryV0.claimOperationCost()` Writes State Variable After An External Call Is Made"}, {"title": "`MochiTreasuryV0.sol` Implements `receive()` Function With No Withdraw Mechanism", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/162", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor confirmed"], "target": "2021-10-mochi-findings", "body": "# Handle  leastwood   # Vulnerability details  ## Impact  The `MochiTreasuryV0.sol` contract freely receives ETH from users/other contracts. In the event this does happen, ETH is permanently locked and unrecoverable by the protocol's governance framework.  ## Proof of Concept  https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/treasury/MochiTreasuryV0.sol  ## Tools Used  Manual code review Slither  ## Recommended Mitigation Steps  Consider enabling ETH withdraws for the governance role.  "}, {"title": "`MochiTreasuryV0.withdrawLock()` Is Callable When Locking Has Been Toggled", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/161", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-10-mochi-findings", "body": "# Handle  leastwood   # Vulnerability details  ## Impact  `withdrawLock()` does not prevent users from calling this function when locking has been toggled. As a result, withdraws may be made unexpectedly.  ## Proof of Concept  https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/treasury/MochiTreasuryV0.sol#L40-L42  ## Tools Used  Manual code review  ## Recommended Mitigation Steps  Consider adding `require(lockCrv, \"!lock\");` to `withdrawLock()` to ensure this function is not called unexpectedly. Alternatively if this is intended behaviour, it should be rather checked that the lock has not been toggled, otherwise users could maliciously relock tokens.  "}, {"title": "debts <= _amount", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/159", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-10-mochi-findings", "body": "debts <= _amount"}, {"title": "Duplicate math operations", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/158", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-10-mochi-findings", "body": "Duplicate math operations"}, {"title": "Unchecked math", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/156", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-10-mochi-findings", "body": "Unchecked math"}, {"title": "Improper Validation Of `create2` Return Value", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/155", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-10-mochi-findings", "body": "# Handle  leastwood   # Vulnerability details  ## Impact  The `BeaconProxyDeployer.deploy()` function is used to deploy lightweight proxy contracts that act as each asset's vault. The function does not revert properly if there is a failed contract deployment or revert from the `create2` opcode as it does not properly check the returned address for bytecode. The `create2` opcode returns the expected address which will never be the zero address (as is what is currently checked).  ## Proof of Concept  https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-library/contracts/BeaconProxyDeployer.sol#L31  ## Tools Used  Manual code review Discussions with the Mochi team Discussions with library dev  ## Recommended Mitigation Steps  The recommended mitigation was to update `iszero(result)` to `iszero(extcodesize(result))` in the line mentioned above. This change has already been made in the corresponding library which can be found [here](https://github.com/Nipol/bean-contracts/pull/13), however, this needs to also be reflected in Mochi's contracts.  "}, {"title": "Useless imports", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/154", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-mochi-findings", "body": "# Handle  Jujic   # Vulnerability details  ## Impact contract WJLP does not need to import this contract in production ``` import \"hardhat/console.sol\"; ```  ## Proof of Concept https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/AssetWrappers/WJLP/WJLP.sol#L8  https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/AssetWrappers/WJLP/WJLP.sol#L152-L160  ## Tools Used Remix  ## Recommended Mitigation Steps Remove this contract  to reduce the size of the contract and thus save some deployment gas.  "}, {"title": "Pack structs tightly", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/153", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-mochi-findings", "body": "Pack structs tightly"}, {"title": "Cache the results of duplicate external calls", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/152", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-10-mochi-findings", "body": "Cache the results of duplicate external calls"}, {"title": "Improve precision and gas costs in_shareMochi", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/150", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-mochi-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact This not only loses some precision (cuz of multiplication and division) but also consumes more gas:     // send Mochi to vMochi Vault     mochi.transfer(         address(engine.vMochi()),         (mochiBalance * vMochiRatio) / 1e18     );     // send Mochi to veCRV Holders     mochi.transfer(         crvVoterRewardPool,         (mochiBalance * (1e18 - vMochiRatio)) / 1e18     );  ## Recommended Mitigation Steps Proposed improvement:   // send Mochi to vMochi Vault   uint toVault = (mochiBalance * vMochiRatio) / 1e18;   mochi.transfer(       address(engine.vMochi()),       toVault   );   // send Mochi to veCRV Holders   mochi.transfer(       crvVoterRewardPool,       mochiBalance - toVault;   );  This way you the whole mochiBalance will be transferred and it will cost less to do that as fewer math operations are performed.  "}, {"title": "Open TODOs/questions", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/139", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-10-mochi-findings", "body": "# Handle  ye0lde   # Vulnerability details  ## Impact Open TODOs can point to programming or other errors that still need to be fixed.  ## Proof of Concept  These are TODOs written as comments: https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-core/contracts/feePool/FeePoolV0.sol#L57 https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-core/contracts/vault/MochiVault.sol#L163  ## Tools Used VS Code  ## Recommended Mitigation Steps Resolve the TODOs/open questions.   "}, {"title": "UniswapV2/SushiwapLPAdapter update the wrong token", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/134", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-10-mochi-findings", "body": "# Handle  cmichel   # Vulnerability details  The `UniswapV2LPAdapter/SushiswapV2LPAdapter.update` function retrieves the `underlying` from the LP token pair (`_asset`) but then calls `router.update(_asset, _proof)` which is the LP token itself again. This will end up with the router calling this function again recursively.  ## Impact This function fails as there's an infinite recursion and eventually runs out of gas.  ## Recommendation The idea was most likely to update the `underlying` price which is used in `_getPrice` as `uint256 eAvg = cssr.getExchangeRatio(_underlying, weth);`.  Call `router.update(underlying, _proof)` instead. Note that the `_proof` does not necessarily update the `underlying <> WETH` pair, it could be any `underlying <> keyAsset` pair.   "}, {"title": "Changing engine.nft contract breaks vaults", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/130", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-10-mochi-findings", "body": "# Handle  cmichel   # Vulnerability details  Governance can change the `engine.nft` address which is used by vaults to represent collateralized debt positions (CDP). When minting a vault using `MochiVault.mint` the address returned ID will be used and overwrite the state of an existing debt position and set its status to `Idle`.  ## Impact Changing the NFT address will allow overwriting existing CDPs.  ## Recommended Mitigation Steps Disallow setting a new NFT address. or ensure that the new NFT's IDs start at the old NFT's IDs.  "}, {"title": "Debt accrual is path-dependant and inaccurate", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/129", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-10-mochi-findings", "body": "# Handle  cmichel   # Vulnerability details  The total `debt` in `MochiVault.accrueDebt` increases by the current `debt` times the debt index growth. This is correct but the total `debt` is then _reduced_ again by the calling _user's_ discounted debt, meaning, the total debt depends on which specific user performs the debt accrual.  This should not be the case.  ## POC Assume we have a total debt of `2000`, two users A and B, where A has a debt of 1000, and B has a debt of 100. The (previous) `debtIndex = 1.0` and accruing it now would increase it to `1.1`.  There's a difference if user A or B first does the accrual.  #### User A accrues first User A calls `accrueDebt`: `increased = 2000 * 1.1/1.0 - 2000 = 200`. Thus `debts` is first set to `2200`. The user's `increasedDebt = 1000 * 1.1 / 1.0 - 1000 = 100` and assume a discount of `10%`, thus `discountedDebt = 100 * 10% = 10`. Then `debts = 2200 - 10 = 2190`.  The next accrual will work with a total debt of `2190`.  #### User B accruess first User B calls `accrueDebt`: `increased = 2000 * 1.1/1.0 - 2000 = 200`. Thus `debts` is first set to `2200`. The user's `increasedDebt = 100 * 1.1 / 1.0 - 100 = 10` and assume a discount of `10%`, thus `discountedDebt = 10 * 10% = 1`. Then `debts = 2200 - 1 = 2199`.  The next accrual will work with a total debt of `2199`, leading to more debt overall.  ## Impact The total debt of a system depends on who performs the accruals which should ideally not be the case. The discrepancy compounds and can grow quite large if a whale always does the accrual compared to someone with almost no debt or no discount.  ## Recommended Mitigation Steps Don't use the discounts or track the weighted average discount across all users that is subtracted from the increased total debt each time, i.e., reduce it by the discount of **all users** (instead of current caller only) when accruing to correctly track the debt.   "}, {"title": "A malicious user can potentially escape liquidation by creating a dust amount position and trigger the liquidation by themself", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/127", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-10-mochi-findings", "body": "# Handle  WatchPug   # Vulnerability details  In the current implementation, a liquidated position can be used for depositing and borrowing again.  However, if there is a liquidation auction ongoing, even if the position is now `liquidatable`, the call of `triggerLiquidation()` will still fail.   The liquidator must `settleLiquidation` first.  If the current auction is not profitable for the liquidator, say the value of the collateral can not even cover the gas cost, the liquidator may be tricked and not liquidate the new loan at all.  Considering if the liquidator bot is not as small to handle this situation (take the profit of the new liquidation and the gas cost loss of the current auction into consideration), a malicious user can create a dust amount position trigger the liquidation by themself.  Since the collateral of this position is so small that it can not even cover the gas cost, liquidators will most certainly ignore this auction.  The malicious user will then deposit borrow the actual loan.  When this loan becomes `liquidatable`, liquidators may:  1. confuse the current dust auction with the `liquidatable` position; 2. unable to proceed with such a complex liquidation.  As a result, the malicious user can potentially escape liquidation.  ### Recommendation  Consider making liquidated positions unable to be used (for depositing and borrowing) again.  "}, {"title": "liquidation factor < collateral factor for Sigma type", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/126", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-10-mochi-findings", "body": "# Handle  cmichel   # Vulnerability details  The `MochiProfileV0` defines liquidation and collateral factors for different asset types. For the `AssetClass.Sigma` type, the liquidation factor is _less_ than the collateral factor:  ```solidity function liquidationFactor(address _asset)     public     view     override     returns (float memory) {     AssetClass class = assetClass(_asset);     if (class == AssetClass.Sigma) { // } else if (class == AssetClass.Sigma) {         return float({numerator: 40, denominator: 100});     } }  function maxCollateralFactor(address _asset)     public     view     override     returns (float memory) {     AssetClass class = assetClass(_asset);     if (class == AssetClass.Sigma) {         return float({numerator: 45, denominator: 100});     } } ```  This means that one can take a loan of up to 45% of their collateral but then immediately gets liquidated as the liquidation factor is only 40%. There should always be a buffer between these such that taking the max loan does not immediately lead to liquidations:  > A safety buffer is maintained between max CF and LF to protect users against liquidations due to normal volatility. [Docs](https://hackmd.io/@az-/mochi-whitepaper#Collateral-Factor-CF)   ## Recommended Mitigation Steps The max collateral factor for the Sigma type should be higher than its liquidation factor.   "}, {"title": "Flashloan fee griefing attack for existing approvals", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/124", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-10-mochi-findings", "body": "# Handle  cmichel   # Vulnerability details  If a flashloan contract does not properly authenticate the `USDM` flashloan contract callbacks, anyone can perform a griefing attack which will lead to the caller losing tokens equal to the fees.  This is because the flashloan `receiver` is not authenticated and anyone can start flashloans on behalf of another contract. They don't even need to approve the `usdm` contract as it uses internal `_burn` and `_transfer` functions instead of `burnFrom`/`transferFrom`.  #### POC  1. Call `FlashLoan.flashLoan(receiver=victim, ...)`. 2. Loan amount + fees will be burned/transferred from the `receiver` in `_loan`.  If fees are non-zero, it's possible to drain the victim's balance if their contract is implemented incorrectly without proper authentication checks.  #### Recommendation This is an inherent issue with EIP-3156 which defines the interface with an arbitrary `receiver`. Contracts should be aware to revert if the flashloan was not initiated by them.  To mitigate this issue one could use functions that work with explicit approvals from the victim, instead of using internal `_burn` and `_transfer` functions. This way, the victim must first have approved the tokens for transfer.   "}, {"title": "Key currencies can be double counted", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/122", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-10-mochi-findings", "body": "Key currencies can be double counted"}, {"title": "Declaring unnecessary immutable variables as constant can save gas", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/117", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-mochi-findings", "body": "# Handle  WatchPug   # Vulnerability details  In `MochiProfileV0.sol`, `secPerYear` is defined as an immutable variable while it's not configured as a parameter of the constructor. Thus, it can be declared as constant to save gas.  https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-core/contracts/profile/MochiProfileV0.sol#L23-L28  ```solidity=23 uint256 public immutable secPerYear;  uint256 public override delay;  constructor(address _engine) {     secPerYear = 31536000; ```  ### Recommendation  Change to:  ```solidity=23 uint256 public constant SEC_PER_YEAR = 31536000; ```  "}, {"title": "Simplify `sqrt()` can save gas", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/115", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-mochi-findings", "body": "# Handle  WatchPug   # Vulnerability details  The check of `x > 3` is unnecessary and most certainly adds more gas cost than it saves as the majority of use cases of this function will not be handling `x <= 3`.  https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-cssr/contracts/adapter/UniswapV2LPAdapter.sol#L106-L117  https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-cssr/contracts/adapter/SushiswapV2LPAdapter.sol#L106-L117  ```solidity=106 function sqrt(uint x) internal pure returns (uint y) {     if (x > 3) {         uint z = x / 2 + 1;         y = x;         while (z < y) {             y = z;             z = (x / z + z) / 2;         }     } else if (x != 0) {         y = 1;     } } ```  ### Recommendation  Change to:  ```solidity function sqrt(uint x) public pure returns (uint y) {     uint z = (x + 1) / 2;     y = x;     while (z < y) {         y = z;         z = (x / z + z) / 2;     } } ```  "}, {"title": "`FeePoolV0.sol#distributeMochi()` will unexpectedly flush `treasuryShare`, causing the protocol fee cannot be properly accounted for and collected", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/114", "labels": ["bug", "duplicate", "3 (High Risk)", "sponsor confirmed"], "target": "2021-10-mochi-findings", "body": "# Handle  WatchPug   # Vulnerability details  `distributeMochi()` will call `_buyMochi()` to convert `mochiShare` to Mochi token and call `_shareMochi()` to send Mochi to vMochi Vault and veCRV Holders. It wont touch the `treasuryShare`.  However, in the current implementation, `treasuryShare` will be reset to `0`. This is unexpected and will cause the protocol fee can not be properly accounted for and collected.  https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-core/contracts/feePool/FeePoolV0.sol#L79-L95  ```solidity=79 function _shareMochi() internal {     IMochi mochi = engine.mochi();     uint256 mochiBalance = mochi.balanceOf(address(this));     // send Mochi to vMochi Vault     mochi.transfer(         address(engine.vMochi()),         (mochiBalance * vMochiRatio) / 1e18     );     // send Mochi to veCRV Holders     mochi.transfer(         crvVoterRewardPool,         (mochiBalance * (1e18 - vMochiRatio)) / 1e18     );     // flush mochiShare     mochiShare = 0;     treasuryShare = 0; } ```  ### Impact  Anyone can call `distributeMochi()` and reset `treasuryShare` to `0`, and then call `updateReserve()` to allocate part of the wrongfuly resetted `treasuryShare` to `mochiShare` and call `distributeMochi()`.  Repeat the steps above and the `treasuryShare` will be consumed to near zero, profits the vMochi Vault holders and veCRV Holders. The protocol suffers the loss of funds.  ### Recommendation  Change to:  ```solidity=64 function _buyMochi() internal {     IUSDM usdm = engine.usdm();     address[] memory path = new address[](2);     path[0] = address(usdm);     path[1] = address(engine.mochi());     usdm.approve(address(uniswapRouter), mochiShare);     uniswapRouter.swapExactTokensForTokens(         mochiShare,         1,         path,         address(this),         type(uint256).max     );     // flush mochiShare     mochiShare = 0; }  function _shareMochi() internal {     IMochi mochi = engine.mochi();     uint256 mochiBalance = mochi.balanceOf(address(this));     // send Mochi to vMochi Vault     mochi.transfer(         address(engine.vMochi()),         (mochiBalance * vMochiRatio) / 1e18     );     // send Mochi to veCRV Holders     mochi.transfer(         crvVoterRewardPool,         (mochiBalance * (1e18 - vMochiRatio)) / 1e18     ); } ```  "}, {"title": "`FeePoolV0.sol` Lack of input validation", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/106", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-10-mochi-findings", "body": "# Handle  WatchPug   # Vulnerability details  `treasuryRatio` and `vMochiRatio` must be `<= 1e18` to make sure the contract works correctly. Therefore, the input should be checked in the setters.  https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-core/contracts/feePool/FeePoolV0.sol#L45-L53  ```solidity=45 function changeTreasuryRatio(uint256 _ratio) external {     require(msg.sender == engine.governance(), \"!gov\");     treasuryRatio = _ratio; }  function changevMochiRatio(uint256 _ratio) external {     require(msg.sender == engine.governance(), \"!gov\");     vMochiRatio = _ratio; } ```  ### Recommendation  Change to:  ```solidity=45 function changeTreasuryRatio(uint256 _ratio) external {     require(msg.sender == engine.governance(), \"!gov\");     require(_ratio <= 1e18, \">1e18\");     treasuryRatio = _ratio; }  function changevMochiRatio(uint256 _ratio) external {     require(msg.sender == engine.governance(), \"!gov\");     require(_ratio <= 1e18, \">1e18\");     vMochiRatio = _ratio; } ```  "}, {"title": "Minor precision loss", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/105", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-10-mochi-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-core/contracts/emission/VestedRewardPool.sol#L67-L68  ```solidity=67 mochi.transfer(msg.sender, _amount / 2); mochi.transfer(address(vMochi), _amount / 2); ```  Change to:  ```solidity=67 mochi.transfer(msg.sender, _amount / 2); mochi.transfer(address(vMochi), _amount - _amount / 2); ```  https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-core/contracts/treasury/MochiTreasuryV0.sol#L59-L65  ```solidity=63 operationShare += updatedFee / 2; veCRVShare += updatedFee / 2; ```  Change to:  ```solidity=63 operationShare += updatedFee / 2; veCRVShare += updatedFee - updatedFee / 2; ```  "}, {"title": "`DutchAuctionLiquidator.sol#triggerLiquidation()` Adding precondition check can save gas", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/104", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-mochi-findings", "body": "# Handle  WatchPug   # Vulnerability details  When liquidators race to liquidate a position, all other besides the first liquidator will be handling an empty (liquidated) position.  https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-core/contracts/liquidator/DutchAuctionLiquidator.sol#L69-L81  ```solidity=69 function triggerLiquidation(address _asset, uint256 _nftId)     external     override {     IMochiVault vault = engine.vaultFactory().getVault(_asset);     Auction storage auction = auctions[auctionId(_asset, _nftId)];     require(auction.startedAt == 0 || auction.boughtAt != 0, \"on going\");     uint256 debt = vault.currentDebt(_nftId);      (, uint256 collateral, , , ) = vault.details(_nftId);      vault.liquidate(_nftId, collateral, debt);     ... ```  In the current implementation, even if the position is liquidated, at L77 and L79, it still tries to get the details and call `vault.liquidate()`, until it reverts at L285-L288 on `MochiVault.sol#liquidate()`. That's going to cost a decent amount of gas due to these unnecessary external calls and code executions.  https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-core/contracts/vault/MochiVault.sol#L277-L288  ```solidity=277{285-288} function liquidate(     uint256 _id,     uint256 _collateral,     uint256 _usdm ) external override updateDebt(_id) {     require(msg.sender == address(engine.liquidator()), \"!liquidator\");     require(engine.nft().asset(_id) == address(asset), \"!asset\");     float memory price = engine.cssr().getPrice(address(asset));     require(         _liquidatable(details[_id].collateral, price, currentDebt(_id)),         \"healthy\"     );     ... ```  Therefore, adding a precondition check can save gas.    ### Recommendation  Change to:  ```solidity=69{77} function triggerLiquidation(address _asset, uint256 _nftId)     external     override {     IMochiVault vault = engine.vaultFactory().getVault(_asset);     Auction storage auction = auctions[auctionId(_asset, _nftId)];     require(auction.startedAt == 0 || auction.boughtAt != 0, \"on going\");     uint256 debt = vault.currentDebt(_nftId);     require(debt > 0, \"!debt\");     (, uint256 collateral, , , ) = vault.details(_nftId);      vault.liquidate(_nftId, collateral, debt);     ... ```  "}, {"title": "`VestedRewardPool.sol#checkClaimable()` Add `vesting[recipient].ends > 0` to the condition can save gas", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/102", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-mochi-findings", "body": "# Handle  WatchPug   # Vulnerability details  When the vesting ends, `vesting[recipient].ends` will be `0` which always passes the check of `vesting[recipient].ends < block.timestamp` and causes unnecessary code execution.  Adding a check of `vesting[recipient].ends > 0` can avoid unnecessary code execution and save gas.  https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-core/contracts/emission/VestedRewardPool.sol#L22-L29  ```solidity modifier checkClaimable(address recipient) {     if (vesting[recipient].ends < block.timestamp) {         vesting[recipient].claimable += vesting[recipient].vested;         vesting[recipient].vested = 0;         vesting[recipient].ends = 0;     }     _; } ```  ### Recommendation  Change to:  ```solidity modifier checkClaimable(address recipient) {     if (vesting[recipient].ends > 0 && vesting[recipient].ends < block.timestamp) {         vesting[recipient].claimable += vesting[recipient].vested;         vesting[recipient].vested = 0;         vesting[recipient].ends = 0;     }     _; } ```  "}, {"title": "`ReferralFeePoolV0.sol#claimRewardAsMochi()` Array out of bound exception", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/97", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-10-mochi-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-core/contracts/feePool/ReferralFeePoolV0.sol#L28-L42  ```solidity=28 function claimRewardAsMochi() external {     IUSDM usdm = engine.usdm();     address[] memory path = new address[](2);     path[0] = address(usdm);     path[1] = uniswapRouter.WETH();     path[2] = address(engine.mochi());     usdm.approve(address(uniswapRouter), reward[msg.sender]);     // we are going to ingore the slippages here     uniswapRouter.swapExactTokensForTokens(         reward[msg.sender],         1,         path,         address(this),         type(uint256).max     ); ```  In `ReferralFeePoolV0.sol#claimRewardAsMochi()`, `path` is defined as an array of length 2 while it should be length 3.  As a result, at L33, an out-of-bound exception will be thrown and revert the transaction.  ### Impact  `claimRewardAsMochi()` will not work as expected so that all the referral fees cannot be claimed but stuck in the contract.  "}, {"title": "Tokens Can Be Stolen By Frontrunning `VestedRewardPool.vest()` and `VestedRewardPool.lock()`", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/92", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-10-mochi-findings", "body": "# Handle  leastwood   # Vulnerability details  ## Impact  The `VestedRewardPool.sol` contract is a public facing contract aimed at vesting tokens for a minimum of 90 days before allowing the recipient to withdraw their `mochi`. The `vest()` function does not utilise `safeTransferFrom()` to ensure that vested tokens are correctly allocated to the recipient. As a result, it is possible to frontrun a call to `vest()` and effectively steal a recipient's vested tokens. The same issue applies to the `lock()` function.  ## Proof of Concept  https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/emission/VestedRewardPool.sol#L36-L46 https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/emission/VestedRewardPool.sol#L54-L64  ## Tools Used  Manual code review Discussions with the Mochi team  ## Recommended Mitigation Steps  Ensure that users understand that this function should not be interacted directly as this could result in lost `mochi` tokens. Additionally, it might be worthwhile creating a single externally facing function which calls `safeTransferFrom()`, `vest()` and `lock()` in a single transaction.   "}, {"title": "`treasuryShare` is Overwritten in `FeePoolV0._shareMochi()`", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/89", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-10-mochi-findings", "body": "# Handle  leastwood   # Vulnerability details  ## Impact  The `FeePoolV0.sol` contract accrues fees upon the liquidation of undercollaterised positions. These fees are split between treasury and `vMochi` contracts. However, when `distributeMochi()` is called to distribute `mochi` tokens to `veCRV` holders, both `mochiShare` and `treasuryShare` is flushed from the contract when there are still `usdm` tokens in the contract.   ## Proof of Concept  Consider the following scenario:   - The `FeePoolV0.sol` contract contains 100 `usdm` tokens at an exchange rate of 1:1 with `mochi` tokens.   - `updateReserve()` is called to set the split of `usdm` tokens such that `treasuryShare` has claim on 20 `usdm` tokens and `mochiShare` has claim on the other 80 tokens.   - A `veCRV` holder seeks to increase their earnings by calling `distributeMochi()` before `sendToTreasury()` has been called.   - As a result, 80 `usdm` tokens are converted to `mochi` tokens and  locked in a curve rewards pool.   - Consequently, `mochiShare` and `treasuryShare` is set to `0` (aka flushed).   - The same user calls `updateReserve()` to split the leftover 20 `usdm` tokens between `treasuryShare` and `mochiShare`.    - `mochiShare` is now set to 16 `usdm` tokens.   - The above process is repeated to distribute `mochi` tokens to `veCRV` holders again and again.   - The end result is that `veCRV` holders have been able to receive all tokens that were intended to be distributed to the treasury.  https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/feePool/FeePoolV0.sol#L94  ## Tools Used  Manual code review Discussions with the Mochi team.  ## Recommended Mitigation Steps  Consider removing the line in `FeePoolV0.sol` (mentioned above), where `treasuryShare` is flushed.   "}, {"title": "Variable `liquidated` in MochiVault is never used", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/88", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-10-mochi-findings", "body": "Variable `liquidated` in MochiVault is never used"}, {"title": "Chainlink's `latestRoundData` might return stale or incorrect results", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/87", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-10-mochi-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/oracle/ChainlinkOracle.sol#L50-L60  ```solidity=50 function sync() public {     (, int256 feedPrice, , uint256 timestamp, ) = feed.latestRoundData();     Fixed18 price = Fixed18Lib.ratio(feedPrice, SafeCast.toInt256(_decimalOffset));      if (priceAtVersion.length == 0 || timestamp > timestampAtVersion[currentVersion()] + minDelay) {         priceAtVersion.push(price);         timestampAtVersion.push(timestamp);          emit Version(currentVersion(), timestamp, price);     } } ```  On `ChainlinkOracle.sol`, we are using `latestRoundData`, but there is no check if the return value indicates stale data. This could lead to stale prices according to the Chainlink documentation:  - https://docs.chain.link/docs/historical-price-data/#historical-rounds - https://docs.chain.link/docs/faq/#how-can-i-check-if-the-answer-to-a-round-is-being-carried-over-from-a-previous-round  ### Recommendation  Consider adding missing checks for stale data.   For example:  ```solidity (uint80 roundID, int256 feedPrice, , uint256 timestamp, uint80 answeredInRound) = feed.latestRoundData(); require(feedPrice > 0, \"Chainlink price <= 0\");  require(answeredInRound >= roundID, \"Stale price\"); require(timestamp != 0, \"Round not complete\"); ```  "}, {"title": "Save Gas With The Unchecked Keyword (MochiVault.sol)", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/82", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged", "sponsor confirmed"], "target": "2021-10-mochi-findings", "body": "# Handle  ye0lde   # Vulnerability details  ## Impact  Redundant arithmetic underflow/overflow checks can be avoided when an underflow/overflow cannot happen.  ## Proof of Concept  The \"unchecked\" keyword can be applied here since there is an \"if\" statement before to ensure the arithmetic operations, would not cause an integer underflow or overflow. https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-core/contracts/vault/MochiVault.sol#L267  Change the code at 267 to: <code> unchecked {    debts -= _amount; } </code>  A similar change can be made here: https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-core/contracts/vault/MochiVault.sol#L269  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps Add the \"unchecked\" keyword as shown above.  "}, {"title": "anyone can create a vault by directly calling the factory", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/80", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-10-mochi-findings", "body": "# Handle  jonah1005   # Vulnerability details   ## Impact [MochiVaultFactory.sol#L26-L37](https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/vault/MochiVaultFactory.sol#L26-L37) There's no permission control in the vaultFactory. Anyone can create a vault. The transaction would be reverted when the government tries to deploy such an asset.  As the protocol checks whether the vault is a valid vault by comparing the contract's address with the computed address, the protocol would recognize the random vault as a valid one.    I consider this is a medium-risk issue.  ## Proof of Concept  Here's a web3.py script to trigger the bug. ```py vault_factory.functions.deployVault(usdt.address).transact() ## this tx would be reverted profile.functions.registerAssetByGov([usdt.address], [3]).transact() ```  ## Tools Used  None  ## Recommended Mitigation Steps Recommend to add a check. ```solidity require(msg.sender == engine, \"!engine\"); ```  "}, {"title": "Remove extra calls in updateReserve (FeePoolV0.sol)", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/79", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-mochi-findings", "body": "# Handle  ye0lde   # Vulnerability details  ## Impact  Cache the result of engine.usdm().balanceOf to simplify code and save gas.  ## Proof of Concept  engine.usdm().balanceOf is called twice in function updateReserve here: https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-core/contracts/feePool/FeePoolV0.sol#L32-L38  I suggest modifying the code as follows: <code> function updateReserve() external override {   uint256 balanceOf = engine.usdm().balanceOf(address(this));  treasuryShare += ((balanceOf - mochiShare - treasuryShare) * treasuryRatio) / 1e18;  mochiShare = balanceOf - treasuryShare; } </code>  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps See POC   "}, {"title": "Unchecked low level call", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/76", "labels": ["bug", "1 (Low Risk)"], "target": "2021-10-mochi-findings", "body": "Unchecked low level call"}, {"title": "Unlocked pragma version", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/74", "labels": ["bug", "0 (Non-critical)"], "target": "2021-10-mochi-findings", "body": "Unlocked pragma version"}, {"title": "Unnecessary require in settleLiquidation ", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/71", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-mochi-findings", "body": "# Handle  harleythedog   # Vulnerability details  ## Impact On line 100 of DutchAuctionLiquidator.sol (within settleLiquidation), there is a require statement for auction.boughtAt == 0. This is already checked on line 121 within the \"buy\" function, and this is the only function that can possibly call settleLiquidation, so this require statement always passes. Removing it would save gas.  ## Proof of Concept Link to require statement here: https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/liquidator/DutchAuctionLiquidator.sol#:~:text=require(auction.boughtAt%20%3D%3D%200%2C%20%22liquidated%22)%3B  ## Tools Used Manual inspection.  ## Recommended Mitigation Steps Remove unnecessary require statement described above to save gas.  "}, {"title": "Liquidation will never work with non-zero discounts", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/66", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-10-mochi-findings", "body": "# Handle  harleythedog   # Vulnerability details  ## Impact Right now, there is only one discount profile in the github repo: the \"NoDiscountProfile\" which does not discount the debt at all. This specific discount profile works correctly, but I claim that any other discount profile will result in liquidation never working.  Suppose that we instead have a discount profile where discount() returns any value strictly larger than 0. Now, suppose someone wants to trigger a liquidation on a position. First, triggerLiquidation will be called (within DutchAuctionLiquidator.sol). The variable \"debt\" is initialized as equal to vault.currentDebt(_nftId). Notice that currentDebt(_ndfId) (within MochiVault.sol) simply scales the current debt of the position using the liveDebtIndex() function, but there is no discounting being done within the function - this will be important. Back within the triggerLiquidation function, the variable \"collateral\" is  simply calculated as the total collateral of the position. Then, the function calls vault.liquidate(_nftId, collateral, debt), and I claim that this will never work due to underflow.  Indeed, the liquidate function will first update the debt of the position (due to the updateDebt(_id) modifier). The debt of the position is thus updated using lines 99-107 in MochiVault.sol. We can see that the details[_id].debt is updated in the exact same way as the calculations for currentDebt(_nftId), however, there is the extra subtraction of the discountedDebt on line 107.   Eventually we will reach line 293 in MochiVault.sol. However, since we discounted the debt in the calculation of details[_id].debt, but we did not discount the debt for the passed in parameter _usdm (and thus is strictly larger in value), line 293 will always error due to an underflow. In summary, any discount profile that actually discounts the debt of the position will result in all liquidations erroring out due to this underflow. Since no positions will be liquidatable, this represents a major flaw in the contract as then no collateral can be liquidated so the entire functionality of the contract is compromised.  ## Proof of Concept Liquidate function in MochiVault.sol: https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/vault/MochiVault.sol#:~:text=function-,liquidate,-(  triggerLiquidation function in DutchAuctionLiquidator.sol: https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/liquidator/DutchAuctionLiquidator.sol#:~:text=function-,triggerLiquidation,-(address%20_asset%2C%20uint256  Retracing the steps as I have described above, we can see that any call to triggerLiquidation will result in:  details[_id].debt -= _usdm;  throwing an error since _usdm will be larger than details[_id].debt.  ## Tools Used Manual inspection.  ## Recommended Mitigation Steps An easy fix is to simply change:  details[_id].debt -= _usdm;  to be:  details[_id].debt = 0;  as liquidating a position should probably just be equivalent to repaying all of the debt in the position.   Side Note: If there are no other discount profiles planned to be added other than \"NoDiscountProfile\", then I would recommend deleting all of the discount logic entirely, since NoDiscountProfile doesn't actually do anything  "}, {"title": "feePool is vulnerable to sandwich attack.", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/65", "labels": ["bug", "3 (High Risk)", "sponsor disputed"], "target": "2021-10-mochi-findings", "body": "feePool is vulnerable to sandwich attack."}, {"title": "Cached length of arrays to avoid loading them repeadetly", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/64", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-mochi-findings", "body": "# Handle  0x0x0x   # Vulnerability details   ## Impact Gas optimization.  ## Proof of Concept  ``` for (uint i = 0; i < arr.length; i++) {     //Operations not effecting the length of the array. } ``` Loading length for storage arrays cost 100 gas and for memory arrays it costs 3 gas. When arr.length is defined as the condition of for loop, at the start of every iteration the length is loaded from memory. If the length doesn't change during the loop, loading the length of arrays repeatedly can be avoided by saving the length to the stack. ``` uint length = arr.length; for (uint i = 0; i < length; i++) {     //Operations not effecting the length of the array. } ``` By doing so the length is only loaded once rather than loading it as many times as iterations (Therefore, less gas is spent).  ## Locations ``` ./mochi-core/contracts/profile/MochiProfileV0.sol:68:        for (uint256 i = 0; i < _asset.length; i++) { ./mochi-core/contracts/profile/MochiProfileV0.sol:86:        for (uint256 i = 0; i < _assets.length; i++) { ./mochi-core/contracts/profile/MochiProfileV0.sol:95:        for (uint256 i = 0; i < _assets.length; i++) { ./mochi-cssr/contracts/MochiCSSRv0.sol:41:        for(uint256 i = 0; i<_assets.length; i++){ ./mochi-cssr/contracts/MochiCSSRv0.sol:47:        for(uint256 i = 0; i<_assets.length; i++){ ./mochi-cssr/contracts/MochiCSSRv0.sol:66:        for(uint256 i = 0; i<_assets.length; i++){ ./mochi-cssr/contracts/MochiCSSRv0.sol:77:        for(uint256 i = 0; i<_assets.length; i++){ ./mochi-cssr/contracts/adapter/ChainlinkAdapter.sol:34:        for(uint256 i = 0; i<_assets.length; i++) { ./mochi-cssr/contracts/adapter/UniswapV2TokenAdapter.sol:63:        for (uint256 i = 0; i < keyCurrency.length; i++) { ./mochi-cssr/contracts/adapter/UniswapV2TokenAdapter.sol:122:        for (uint256 i = 0; i < keyCurrency.length; i++) { ./mochi-cssr/contracts/adapter/UniswapV2TokenAdapter.sol:175:        for (uint256 i = 0; i < keyCurrency.length; i++) { ./mochi-library/contracts/MerklePatriciaVerifier.sol:36:  for (uint i=0; i<parentNodes.length; i++) { ./mochi-library/contracts/MerklePatriciaVerifier.sol:78:  for(uint i=pathPtr; i<pathPtr+partialPath.length; i++) { ./mochi-library/contracts/MerklePatriciaVerifier.sol:108:  for(uint i=offset; i<nibbleArray.length; i++) { ./mochi-library/contracts/SushiswapV2Library.sol:66:        for (uint i; i < path.length - 1; i++) { ./mochi-library/contracts/SushiswapV2Library.sol:77:        for (uint i = path.length - 1; i > 0; i--) { ./mochi-library/contracts/UniswapV2Library.sol:66:        for (uint i; i < path.length - 1; i++) { ./mochi-library/contracts/UniswapV2Library.sol:77:        for (uint i = path.length - 1; i > 0; i--) { ``` ## A similar case  nibblePath.length is constant but it is read at every iteration for require statement.  ```./mochi-library/contracts/MerklePatriciaVerifier.sol:36: require(pathPtr <= nibblePath.length, \"Path overflow\");```    "}, {"title": "Changing NFT contract in the MochiEngine would break the protocol", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/63", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-10-mochi-findings", "body": "# Handle  jonah1005   # Vulnerability details  ## Impact MochiEngine allows the operator to change the NFT contract. [MochiEngine.sol#L91-L93](https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/MochiEngine.sol#L91-L93) All the vaults would point to a different NFT address. As a result, users would not be access their positions. The entire protocol would be broken.  IMHO, A function that would break the entire protocol shouldn't exist.  I consider this is a high-risk issue. ## Proof of Concept [MochiEngine.sol#L91-L93](https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/MochiEngine.sol#L91-L93)  ## Tools Used None ## Recommended Mitigation Steps Remove the function.   "}, {"title": "regerralFeePool is vulnerable to MEV searcher", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/62", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-10-mochi-findings", "body": "# Handle  jonah1005   # Vulnerability details  # regerralFeePool is vulnerable to MEV searcher  ## Impact `claimRewardAsMochi` in the `ReferralFeePoolV0` ignores slippage. This is not a desirable design. There are a lot of MEV searchers in the current network. Swapping assets with no slippage control would get rekted. Please refer to https://github.com/flashbots/pm.  Given the current state of the Ethereum network. Users would likely be sandwiched. I consider this is a high-risk issue.  ## Proof of Concept [ReferralFeePoolV0.sol#L28-L48](https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/feePool/ReferralFeePoolV0.sol#L28-L48)  Please refer to https://medium.com/immunefi/mushrooms-finance-theft-of-yield-bug-fix-postmortem-16bd6961388f  to see a possible attack pattern.   ## Tools Used  None  ## Recommended Mitigation Steps I recommend adding minReceivedAmount as a parameter.  ```solidity function claimRewardAsMochi(uint256 _minReceivedAmount) external {     // original logic here     require(engine.mochi().balanceOf(address(this)) > _minReceivedAmount, \"!min\");     engine.mochi().transfer(         msg.sender,         engine.mochi().balanceOf(address(this))     ); } ``` Also, the front-end should calculate the min amount with the current price.  "}, {"title": "treasury is vulnerable to sandwich attack", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/60", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-10-mochi-findings", "body": "# Handle  jonah1005   # Vulnerability details  # treasury is vulnerable to sandwich attack.   ## Impact There's a permissionless function `veCRVlock` in MochiTreasury. Since everyone can trigger this function, the attacker can launch a sandwich attack with flashloan to steal the funds. [MochiTreasuryV0.sol#L73-L94](https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/treasury/MochiTreasuryV0.sol#L73-L94)  Attackers can possibly steal all the funds in the treasury. I consider this is a high-risk issue.  ## Proof of Concept [MochiTreasuryV0.sol#L73-L94](https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/treasury/MochiTreasuryV0.sol#L73-L94)  Here's an exploit pattern 1. Flashloan and buy CRV the uniswap pool 2. Trigger `veCRVlock()` 3. The treasury buys CRV at a very high price. 4. Sell CRV and pay back the loan.  ## Tools Used  None  ## Recommended Mitigation Steps Recommend to add `onlyOwner` modifier.   "}, {"title": "borrow function will underflow when total debt > creditCap", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/56", "labels": ["bug", "0 (Non-critical)", "disagree with severity"], "target": "2021-10-mochi-findings", "body": "borrow function will underflow when total debt > creditCap"}, {"title": "Referrer can drain ReferralFeePoolV0", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/55", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-10-mochi-findings", "body": "# Handle  gzeon   # Vulnerability details  ## Impact function claimRewardAsMochi in ReferralFeePoolV0.sol did not reduce user reward balance, allowing referrer to claim the same reward repeatedly and thus draining the fee pool.  ## Proof of Concept https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/feePool/ReferralFeePoolV0.sol L28-47 did not reduce user reward balance  ## Tools Used None  ## Recommended Mitigation Steps Add the following lines > rewards -= reward[msg.sender]; > reward[msg.sender] = 0;   "}, {"title": "Gas optimization: Struct layout in DutchAuctionLiquidator.sol", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/54", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-mochi-findings", "body": "# Handle  gzeon   # Vulnerability details  ## Impact Auction struct in DutchAuctionLiquidator.sol can be optimized to reduce 2 storage slot  ## Proof of Concept https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/liquidator/DutchAuctionLiquidator.sol L18-L25: the struct can changed into struct Auction {         uint256 nftId;         address vault;         uint48 startedAt;         uint48 boughtAt;         uint256 collateral;         uint256 debt;     } startedAt and boughtAt store block numbers, and 2^48 is be enough for a very long time.  ## Tools Used None  ## Recommended Mitigation Steps Change the struct as suggested above, also need to cast whenever startedAt and boughtAt is used.  "}, {"title": "Vault status is not set to Liquidated after liquidation", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/51", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-10-mochi-findings", "body": "# Handle  gzeon   # Vulnerability details  ## Impact There is a status enum Liquidated but was not used anywhere in the code.   ## Proof of Concept https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/vault/MochiVault.sol L277-296 status was not set to Status.Liquidated after liquidation  ## Tools Used None  ## Recommended Mitigation Steps details[id].status = Status.Liquidated;  "}, {"title": "borrow function will borrow max cf when trying to borrow > cf", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/45", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2021-10-mochi-findings", "body": "borrow function will borrow max cf when trying to borrow > cf"}, {"title": "Reduce State Variable Use in VestedRewardPool.sol", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/43", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-mochi-findings", "body": "# Handle  ye0lde   # Vulnerability details  ## Impact  Caching the \"vesting\" state variable instead of repeatedly reading and writing it will decrease deployment and runtime gas.  This is especially true for the modifier \"checkClaimable\" which is used on every function in the contract.   ## Proof of Concept  The checkClaimable function is here: https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-core/contracts/emission/VestedRewardPool.sol#L22-L29  An example of its use is here along with many other accesses to the \"vesting\" state variable. https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-core/contracts/emission/VestedRewardPool.sol#L36-L46  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps  I suggest modifying \"checkClaimable as follows:     <code> function checkClaimable(Vesting memory v) internal pure returns(Vesting memory) {   if (v.ends < block.timestamp) {   v.claimable += v.vested;   v.vested = 0;   v.ends = 0;  }  return v; } </code>  and I suggest these changes to function \"vest\"   <code> function vest(address _recipient) external {  Vesting memory v = checkClaimable(vesting[_recipient]);  uint256 amount = mochi.balanceOf(address(this)) - mochiUnderManagement;  uint256 weightedEnd = (v.vested *   v.ends +   amount *   (block.timestamp + 90 days)) /   (v.vested + amount);  v.vested += amount;  v.ends = weightedEnd;  vesting[_recipient] = v;  mochiUnderManagement += amount; } </code>  These functions are also candidates for similar changes: https://github.com/code-423n4/2021-10-mochi/blob/8458209a52565875d8b2cefcb611c477cefb9253/projects/mochi-core/contracts/emission/VestedRewardPool.sol#L48-L71   "}, {"title": "Long Revert Strings", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/41", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-10-mochi-findings", "body": "Long Revert Strings"}, {"title": "Gas Optimization on the Public Function", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/38", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-mochi-findings", "body": "# Handle  defsec   # Vulnerability details  ## Impact  This does not directly impact the smart contract in anyway besides cost. This is a gas optimization to reduce cost of smart contract. Calling each function, we can see that the public function uses 496 gas, while the external function uses only 261.  ## Proof of Concept  According to Slither Analyzer documentation (https://github.com/crytic/slither/wiki/Detector-Documentation#public-function-that-could-be-declared-external), there are functions in the contract that are never called. These functions should be declared as external in order to save gas.  Slither Detector:  external-function:  https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/vault/MochiVault.sol#L75  ## Tools Used  Slither  ## Recommended Mitigation Steps  1. Clone repository for Mochi Smart Contracts. 2. Create a python virtual environment with a stable python version. 3. Install Slither Analyzer on the python VEM. 4. Run Slither against all contracts. 5. Define public functions as an external for the gas optimization.  "}, {"title": "FRONT-RUNNABLE INITIALIZERS", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/37", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-10-mochi-findings", "body": "FRONT-RUNNABLE INITIALIZERS"}, {"title": "ERC20 approve method missing return value check", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/36", "labels": ["bug", "0 (Non-critical)"], "target": "2021-10-mochi-findings", "body": "ERC20 approve method missing return value check"}, {"title": "Upgrade pragma to at least 0.8.4", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/34", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-10-mochi-findings", "body": "Upgrade pragma to at least 0.8.4"}, {"title": "Missing events for governor only functions that change critical parameters", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/32", "labels": ["bug", "0 (Non-critical)", "disagree with severity"], "target": "2021-10-mochi-findings", "body": "Missing events for governor only functions that change critical parameters"}, {"title": "Lack of input validation of arrays", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/31", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-10-mochi-findings", "body": "Lack of input validation of arrays"}, {"title": "Gas optimization: Struct layout", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/30", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-mochi-findings", "body": "# Handle  gzeon   # Vulnerability details  ## Impact Detailed description of the impact of this finding.  ## Proof of Concept https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/interfaces/IMochiVault.sol L6-L12: the struct can be reordered into struct Detail {     Status status;     address referrer;     uint256 collateral;     uint256 debt;     uint256 debtIndex; }  such that status and referrer are put into the same slot, should save ~2000 gas per borrow  ## Tools Used None  ## Recommended Mitigation Steps Reorder the struct as suggested, and modify impacted code at  IMochiVault.sol L28-L34 DutchAuctionLiquidator.sol L77  ## Extra Realistically, the range of debtIndex (start at 1e18 and increase by fee per year) probably fit in a uint88(11bytes) so you can pack (status(1byte), referrer(20bytes), debtIndex(11bytes)) all in 32 bytes, saving another storage slot.   "}, {"title": "Gas optimization: Placement of require statements in MochiVault.sol", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/27", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-mochi-findings", "body": "# Handle  gzeon   # Vulnerability details  ## Impact Some of the require statements in MochiVault.sol can be placed earlier to reduce gas usage on revert  ## Proof of Concept https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/vault/MochiVault.sol L226-227: can be placed at the very top of the function to avoid the expensive cssr call L237: can be placed before initialization of increasingDebt  ## Tools Used None  ## Recommended Mitigation Steps Relocate the said require statements  "}, {"title": "Not all functions of DutchAuctionLiquidator.sol check the auction state", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/26", "labels": ["bug", "0 (Non-critical)", "disagree with severity"], "target": "2021-10-mochi-findings", "body": "Not all functions of DutchAuctionLiquidator.sol check the auction state"}, {"title": "debts calculation is not accurate", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/25", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-10-mochi-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The value of the global variable debts in the contract MochiVault.sol is calculated in an inconsistent way.  In the function borrow() the variable debts is increased with a value excluding the fee. However in repay() and liquidate() it is decreased with the same value as details[_id].debt is decreased,, which is including the fee.  This would mean that debts will end up in a negative value when all debts are repay-ed. Luckily the function repay() prevents this from happening.  In the mean time the value of debts isn't accurate. This value is used directly or indirectly in:  - utilizationRatio(), stabilityFee() calculateFeeIndex() of MochiProfileV0.sol  - liveDebtIndex(), accrueDebt(), currentDebt() of MochiVault.sol  This means the entire debt and claimable calculations are slightly off.  ## Proof of Concept https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/vault/MochiVault.sol  function borrow(..)     details[_id].debt = totalDebt; // includes the fee     debts += _amount;     // excludes the fee   function repay(..)     debts -= _amount;       details[_id].debt -= _amount;  function liquidate(..)    debts -= _usdm;    details[_id].debt -= _usdm;  https://github.com/code-423n4/2021-10-mochi/blob/main/projects/mochi-core/contracts/vault/MochiVault.sol#L263-L268  https://github.com/code-423n4/2021-10-mochi/blob/806ebf2a364c01ff54d546b07d1bdb0e928f42c6/projects/mochi-core/contracts/profile/MochiProfileV0.sol#L272-L283  https://github.com/code-423n4/2021-10-mochi/blob/806ebf2a364c01ff54d546b07d1bdb0e928f42c6/projects/mochi-core/contracts/profile/MochiProfileV0.sol#L242-L256  https://github.com/code-423n4/2021-10-mochi/blob/806ebf2a364c01ff54d546b07d1bdb0e928f42c6/projects/mochi-core/contracts/profile/MochiProfileV0.sol#L258-L269  https://github.com/code-423n4/2021-10-mochi/blob/806ebf2a364c01ff54d546b07d1bdb0e928f42c6/projects/mochi-core/contracts/vault/MochiVault.sol#L66-L73  https://github.com/code-423n4/2021-10-mochi/blob/806ebf2a364c01ff54d546b07d1bdb0e928f42c6/projects/mochi-core/contracts/vault/MochiVault.sol#L79-L88  ## Tools Used  ## Recommended Mitigation Steps In function borrow(): replace     debts += _amount; with     debts += totalDebt  "}, {"title": "griefing attack to block withdraws", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/21", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-10-mochi-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact Every time you deposit some assets in the vault (via deposit() of MochiVault.sol) then \"lastDeposit[_id]\" is set to block.timestamp. The modifier wait() checks this value and makes sure you cannot withdraw for \"delay()\" blocks. The default value for delay() is 3 minutes.  Knowing this delay you can do a griefing attack: On chains with low gas fees: every 3 minutes deposit a tiny amount for a specific NFT-id (which has a large amount of assets). On chains with high gas fees: monitor the mempool for a withdraw() transaction and frontrun it with a deposit()  This way the owner of the NFT-id can never withdraw the funds.  ## Proof of Concept https://github.com/code-423n4/2021-10-mochi/blob/806ebf2a364c01ff54d546b07d1bdb0e928f42c6/projects/mochi-core/contracts/vault/MochiVault.sol#L47-L54  https://github.com/code-423n4/2021-10-mochi/blob/806ebf2a364c01ff54d546b07d1bdb0e928f42c6/projects/mochi-core/contracts/vault/MochiVault.sol#L171  https://github.com/code-423n4/2021-10-mochi/blob/806ebf2a364c01ff54d546b07d1bdb0e928f42c6/projects/mochi-core/contracts/profile/MochiProfileV0.sol#L33  ## Tools Used  ## Recommended Mitigation Steps Create a mechanism where you only block the withdraw of recently deposited funds   "}, {"title": "flashFee lack of precision", "html_url": "https://github.com/code-423n4/2021-10-mochi-findings/issues/2", "labels": ["bug", "0 (Non-critical)"], "target": "2021-10-mochi-findings", "body": "flashFee lack of precision"}, {"title": "Move Function _stake Validator Declaration", "html_url": "https://github.com/code-423n4/2021-10-covalent-findings/issues/89", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-10-covalent-findings", "body": "# Handle  ye0lde   # Vulnerability details  ## Impact  The variable v is declared after the first use of its contents.  Moving the declaration before the first use will save gas.  ## Proof of Concept  \"v\" is declared here: https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L180  But \"v\"s contents (validators[validatorId]) is used here first: https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L178  Move line 180 above line 178 and change line 178 to use \"v\".  I've run out of contest time to continue testing but I'd recommend looking through the following functions for how \"validators[validatorId]\" may be used more efficiently. https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L272 https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L346   ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps See Proof of Concept  "}, {"title": "Change lines to save gas", "html_url": "https://github.com/code-423n4/2021-10-covalent-findings/issues/75", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-10-covalent-findings", "body": "# Handle  pants   # Vulnerability details  Change lines 178 to 173. We know it's minor but it's still optimizing gas and more elegant :)  "}, {"title": "Change order of lines to save gas in setAllocatedTokensPerEpoch", "html_url": "https://github.com/code-423n4/2021-10-covalent-findings/issues/73", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-10-covalent-findings", "body": "Change order of lines to save gas in setAllocatedTokensPerEpoch"}, {"title": "Inconsistent definition of integer sizes in function `getDelegatorDetails()`", "html_url": "https://github.com/code-423n4/2021-10-covalent-findings/issues/70", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2021-10-covalent-findings", "body": "# Handle  pmerkleplant   # Vulnerability details  ## Impact The function `getDelegatorDetails()` declares three arrays of type `uint`  (alias for `uint256`).  The variables saved in the arrays are of type `uint128`.  See lines [451-453](https://github.com/code-423n4/2021-10-covalent/blob/main/contracts/DelegatedStaking.sol#L451).  The suggestion is to be consistent with the integer sizes.  "}, {"title": "Unclear definition of `validatorId`'s integer size", "html_url": "https://github.com/code-423n4/2021-10-covalent-findings/issues/68", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2021-10-covalent-findings", "body": "# Handle  pmerkleplant   # Vulnerability details  ## Impact The mapping `validators` is defined with `uint` (alias for `uint256`) as key  type.  In the functions receiving the `validatorId` as parameter however, the  `validatorId` is defined as `uint128`.  See lines [166](https://github.com/code-423n4/2021-10-covalent/blob/main/contracts/DelegatedStaking.sol#L166), [214](https://github.com/code-423n4/2021-10-covalent/blob/main/contracts/DelegatedStaking.sol#L214).  The suggestion is to be consistent with the integer size.  "}, {"title": "Declare variable `CQT` as constant", "html_url": "https://github.com/code-423n4/2021-10-covalent-findings/issues/67", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-10-covalent-findings", "body": "# Handle  pmerkleplant   # Vulnerability details  ## Impact The variable `CQT` is used as constant but not declared as such.  Declaring it as constant saves gas.  "}, {"title": "Validator can fail to receive commission reward in `redeemAllRewards`", "html_url": "https://github.com/code-423n4/2021-10-covalent-findings/issues/65", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2021-10-covalent-findings", "body": "Validator can fail to receive commission reward in `redeemAllRewards`"}, {"title": "unnecessary assert when dealing with CQT", "html_url": "https://github.com/code-423n4/2021-10-covalent-findings/issues/63", "labels": ["bug", "G (Gas Optimization)", "sponsor disputed"], "target": "2021-10-covalent-findings", "body": "unnecessary assert when dealing with CQT"}, {"title": "Misleading parameter name", "html_url": "https://github.com/code-423n4/2021-10-covalent-findings/issues/60", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2021-10-covalent-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L423-L433  ```solidity function transferUnstakedOut(uint128 amount, uint128 validatorId, uint128 stakingId) public {     Unstaking storage us = validators[validatorId].unstakings[msg.sender][stakingId];     require( uint128(block.number) > us.coolDownEnd, \"Cooldown period has not ended\" );     require(us.amount >= amount, \"Amount is too high\");     transferFromContract(msg.sender, amount);     us.amount -= amount;     // set cool down end to 0 to release gas if new unstaking amount is 0     if (us.amount == 0)         us.coolDownEnd = 0;     emit UnstakeRedeemed(validatorId, msg.sender, amount); } ```  The last parameter of `transferUnstakedOut()` is named `stakingId`, while other functions is using `unstakingId`. This is inconsistent and can be misleading.  ### Recommendation  Change from `stakingId` to `unstakingId`.  "}, {"title": "Unbounded iteration over validators array", "html_url": "https://github.com/code-423n4/2021-10-covalent-findings/issues/59", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-10-covalent-findings", "body": "Unbounded iteration over validators array"}, {"title": "`unstake` should update exchange rates first", "html_url": "https://github.com/code-423n4/2021-10-covalent-findings/issues/57", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2021-10-covalent-findings", "body": "# Handle  cmichel   # Vulnerability details  The `unstake` function does not immediately update the exchange rates. It first computes the `validatorSharesRemove = tokensToShares(amount, v.exchangeRate)` **with the old exchange rate**.  Only afterwards, it updates the exchange rates (if the validator is not disabled):  ```solidity // @audit shares are computed here with old rate uint128 validatorSharesRemove = tokensToShares(amount, v.exchangeRate); require(validatorSharesRemove > 0, \"Unstake amount is too small\");  if (v.disabledEpoch == 0) {     // @audit rates are updated here     updateGlobalExchangeRate();     updateValidator(v);     // ... } ```  ## Impact More shares for the amount are burned than required and users will lose rewards in the end.  ## POC Demonstrating that users will lose rewards:  1. Assume someone staked `1000 amount` and received `1000 shares`, and `v.exchangeRate = 1.0`. (This user is the single staker) 2. Several epochs pass, interest accrues, and `1000 tokens` accrue for the validator, `tokensGivenToValidator = 1000`. User should be entitled to 1000 in principal + 1000 in rewards = 2000 tokens. 3. But user calls `unstake(1000)`, which sets `validatorSharesRemove = tokensToShares(amount, v.exchangeRate) = 1000 / 1.0 = 1000`. **Afterwards**, the exchange rate is updated: `v.exchangeRate += tokensGivenToValidator / totalShares = 1.0 + 1.0 = 2.0`. The staker is updated with `s.shares -= validatorSharesRemove = 0` and `s.staked -= amount = 0`. And the user receives their 1000 tokens but notice how the user's shares are now at zero as well. 4. User tries to claim rewards calling `redeemAllRewards` which fails as the `rewards` are 0.  If the user had first called `redeemAllRewards` and `unstake` afterwards they'd have received their 2000 tokens.  ## Recommended Mitigation Steps The exchange rates always need to be updated first before doing anything. Move the `updateGlobalExchangeRate()` and `updateValidator(v)` calls to the beginning of the function.   "}, {"title": "Code Style: private/internal function names should be prefixed with `_`", "html_url": "https://github.com/code-423n4/2021-10-covalent-findings/issues/55", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2021-10-covalent-findings", "body": "# Handle  WatchPug   # Vulnerability details  Here are some examples that the code style of function names does not follow the best practices:  - MaltDAO#incrementEpoch()      https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/DAO.sol#L106-L119  ```solidity=106{107} /* Internal methods */ function incrementEpoch() internal {     epoch = epoch.add(1); }  function _setEpochLength(uint256 length) internal {     epochLength = length;     emit SetEpochLength(length); }  function _setMaltToken(address _malt) internal {     malt = IBurnMintableERC20(_malt);     emit SetMaltToken(_malt); } ```  "}, {"title": "Cache storage variables in the stack can save gas", "html_url": "https://github.com/code-423n4/2021-10-covalent-findings/issues/53", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-10-covalent-findings", "body": "Cache storage variables in the stack can save gas"}, {"title": "Adding unchecked directive can save gas", "html_url": "https://github.com/code-423n4/2021-10-covalent-findings/issues/52", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-10-covalent-findings", "body": "Adding unchecked directive can save gas"}, {"title": "Check `validatorId < validatorsN` can be done earlier", "html_url": "https://github.com/code-423n4/2021-10-covalent-findings/issues/51", "labels": ["bug", "G (Gas Optimization)", "sponsor disputed"], "target": "2021-10-covalent-findings", "body": "Check `validatorId < validatorsN` can be done earlier"}, {"title": "Avoid unnecessary storage read can save gas", "html_url": "https://github.com/code-423n4/2021-10-covalent-findings/issues/49", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-10-covalent-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L101-L115  ```solidity function takeOutRewardTokens(uint128 amount) public onlyOwner {     require(amount > 0, \"Amount is 0\");     uint128 currentEpoch = uint128(block.number);     uint128 epochs = amount / allocatedTokensPerEpoch;     if (endEpoch != 0){         require(endEpoch - epochs > currentEpoch, \"Cannot takeout rewards from past\");         endEpoch = endEpoch - epochs;     }     else{         require(rewardsLocked >= amount, \"Amount is greater than available\");         rewardsLocked -= amount;     }     transferFromContract(owner(), amount);     emit AllocatedTokensTaken(amount); } ```  Since the `takeOutRewardTokens()` function is `onlyOwner`, `transferFromContract(owner(), amount);` can be changed to `transferFromContract(msg.sender, amount);` to avoid unnecessary internal call and storage read to save some gas.  "}, {"title": "Code duplication", "html_url": "https://github.com/code-423n4/2021-10-covalent-findings/issues/46", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2021-10-covalent-findings", "body": "# Handle  WatchPug   # Vulnerability details  Duplicated or logically equivalent code can be hard to maintain. Avoiding code duplication is recommended when feasible.  For example, most of the business logic in `redeemAllRewards()` and `redeemRewards()` is the same.  Consider calculating the amount of the total rewards in `redeemAllRewards()` and call `redeemRewards()` with the amount to reduce code duplication.  "}, {"title": "Usage of an incorrect version of `Ownbale` library can potentially malfunction all `onlyOwner` functions", "html_url": "https://github.com/code-423n4/2021-10-covalent-findings/issues/45", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2021-10-covalent-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L62-L63  ```solidity // this is used to have the contract upgradeable function initialize(uint128 minStakedRequired) public initializer { ```  Based on the context and comments in the code, the `DelegatedStaking.sol` contract is designed to be deployed as an upgradeable proxy contract.  However, the current implementaion is using an non-upgradeable version of the `Ownbale` library: `@openzeppelin/contracts/access/Ownable.sol` instead of the upgradeable version: `@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol`.  A regular, non-upgradeable `Ownbale` library will make the deployer the default owner in the constructor. Due to a requirement of the proxy-based upgradeability system, no constructors can be used in upgradeable contracts. Therefore, there will be no owner when the contract is deployed as a proxy contract.  As a result, all the `onlyOwner` functions will be inaccessible.  ### Recommendation  Use `@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol` and `@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol` instead.  And change the `initialize()` function to:  ```solidity function initialize(uint128 minStakedRequired) public initializer {     __Ownable_init();     ... } ```  "}, {"title": "Typos", "html_url": "https://github.com/code-423n4/2021-10-covalent-findings/issues/42", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2021-10-covalent-findings", "body": "Typos"}, {"title": "getDelegatorDetails declaration inside a loop", "html_url": "https://github.com/code-423n4/2021-10-covalent-findings/issues/39", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-10-covalent-findings", "body": "# Handle  pants   # Vulnerability details  Declaration inside a loop is less gas efficient than before it. See line 462 for example.  "}, {"title": "++i is more gas efficient than i++ in loops forwarding", "html_url": "https://github.com/code-423n4/2021-10-covalent-findings/issues/37", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-10-covalent-findings", "body": "# Handle  defsec   # Vulnerability details  ## Impact  ++i is more gas efficient than i++ in loops forwarding.  ## Proof of Concept  1. Navigate to the following contracts.  \"https://github.com/code-423n4/2021-12-amun/blob/main/contracts/basket/contracts/callManagers/RebalanceManager.sol#L218\"  \"https://github.com/code-423n4/2021-12-amun/blob/main/contracts/basket/contracts/callManagers/RebalanceManager.sol#L234\"  \"https://github.com/code-423n4/2021-12-amun/blob/main/contracts/basket/contracts/callManagers/RebalanceManagerV2.sol#L155\"  \"https://github.com/code-423n4/2021-12-amun/blob/main/contracts/basket/contracts/callManagers/RebalanceManagerV3.sol#L166\"  \"https://github.com/code-423n4/2021-12-amun/blob/main/contracts/basket/contracts/factories/PieFactoryContract.sol#L88\"  \"https://github.com/code-423n4/2021-12-amun/blob/main/contracts/basket/contracts/facets/Call/CallFacet.sol#L55\"  \"https://github.com/code-423n4/2021-12-amun/blob/main/contracts/basket/contracts/facets/Basket/BasketFacet.sol#L50\"  \"https://github.com/code-423n4/2021-12-amun/blob/main/contracts/basket/contracts/facets/Basket/BasketFacet.sol#L160\"  \"https://github.com/code-423n4/2021-12-amun/blob/main/contracts/basket/contracts/facets/Basket/BasketFacet.sol#L321\"  \"https://github.com/code-423n4/2021-12-amun/blob/main/contracts/basket/contracts/facets/Basket/BasketFacet.sol#L348\"  \"https://github.com/code-423n4/2021-12-amun/blob/main/contracts/basket/contracts/facets/Basket/BasketFacet.sol#L381\"  \"https://github.com/code-423n4/2021-12-amun/blob/main/contracts/basket/contracts/singleJoinExit/SingleNativeTokenExit.sol#L69\"   ## Tools Used  Code Review  ## Recommended Mitigation Steps  It is  recommend to use unchecked{++i} and change i declaration to uint256.  "}, {"title": "Line 127 lack of precision", "html_url": "https://github.com/code-423n4/2021-10-covalent-findings/issues/36", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2021-10-covalent-findings", "body": "# Handle  pants   # Vulnerability details  The following calculation can be more numeric precise: uint128 perEpochRateIncrease =uint128(uint256(allocatedTokensPerEpoch)*divider/uint256(totalGlobalShares));  globalExchangeRate += perEpochRateIncrease * (currentEpoch - lastUpdateEpoch);   Change it to: uint128 perEpochRateIncrease =uint256(allocatedTokensPerEpoch)*divider; globalExchangeRate += perEpochRateIncrease * (currentEpoch - lastUpdateEpoch) / uint256(totalGlobalShares);  "}, {"title": "addValidatior doesn't check new validator address != 0", "html_url": "https://github.com/code-423n4/2021-10-covalent-findings/issues/35", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "sponsor acknowledged"], "target": "2021-10-covalent-findings", "body": "addValidatior doesn't check new validator address != 0"}, {"title": "emit staked should be at stake function and not _stake.", "html_url": "https://github.com/code-423n4/2021-10-covalent-findings/issues/34", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-10-covalent-findings", "body": "emit staked should be at stake function and not _stake."}, {"title": "emit initialize", "html_url": "https://github.com/code-423n4/2021-10-covalent-findings/issues/33", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2021-10-covalent-findings", "body": "# Handle  pants   # Vulnerability details  You forgot emit event at the end of initialize function.  "}, {"title": "delegatorCoolDown ", "html_url": "https://github.com/code-423n4/2021-10-covalent-findings/issues/29", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged", "sponsor disputed"], "target": "2021-10-covalent-findings", "body": "delegatorCoolDown "}, {"title": "state variable divider could be set immutable.", "html_url": "https://github.com/code-423n4/2021-10-covalent-findings/issues/27", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-10-covalent-findings", "body": "# Handle  pants   # Vulnerability details  state variable divider could be set immutable. At line 9.  "}, {"title": "takeOutRewardTokens(): Optimise epochs calculation and comparison ", "html_url": "https://github.com/code-423n4/2021-10-covalent-findings/issues/26", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-10-covalent-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ## Impact  The following lines in `takeOutRewardTokens()` are only needed in the case where `endEpoch != 0`.  ```jsx uint128 currentEpoch = uint128(block.number); uint128 epochs = amount / allocatedTokensPerEpoch; ```  Hence, they can be shifted inside the \"if\" block.  Furthermore, a double calculation of `endEpoch - epochs` can be avoided by saving the result into a new variable `newEpoch`.  ## Recommended Mitigation Steps  ```jsx if (endEpoch != 0) {   uint128 newEpoch = endEpoch - (amount / allocatedTokensPerEpoch);   require(newEpoch  > uint128(block.number), \"Cannot takeout rewards from past\");   endEpoch = newEpoch; } ```  "}, {"title": "Make more data accessible", "html_url": "https://github.com/code-423n4/2021-10-covalent-findings/issues/22", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-10-covalent-findings", "body": "Make more data accessible"}, {"title": "addValidator(): Validator's commission rate should be checked to not exceed divider", "html_url": "https://github.com/code-423n4/2021-10-covalent-findings/issues/20", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2021-10-covalent-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  The check `require(amount < divider, \"Rate must be less than 100%\");` exists in `setValidatorComissionRate()` but not in `addValidator()`.  ### Recommended Mitigation Steps  Add the check in `addValidator()` as well.  "}, {"title": "Long Revert Strings", "html_url": "https://github.com/code-423n4/2021-10-covalent-findings/issues/19", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-10-covalent-findings", "body": "Long Revert Strings"}, {"title": "Incorrect updateGlobalExchangeRate implementation", "html_url": "https://github.com/code-423n4/2021-10-covalent-findings/issues/17", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "resolved", "sponsor acknowledged", "sponsor confirmed"], "target": "2021-10-covalent-findings", "body": "# Handle  xYrYuYx   # Vulnerability details  ## Impact UpdateGlobalExchangeRate has incorrect implementation when `totalGlobalShares` is zero.  If any user didn't start stake, `totalGlobalShares` is 0, and every stake it will increase. but there is possibility that `totalGlobalShares` can be 0 amount later by unstake or disable validator.  ## Proof of Concept https://github.com/xYrYuYx/C4-2021-10-covalent/blob/main/test/c4-tests/C4_issues.js#L76 This is my test case to proof this issue.  In my test case, I disabled validator to make `totalGlobalShares` to zero. And in this case, some reward amount will be forever locked in the contract. After disable validator, I mined 10 blocks, and 4 more blocks mined due to other function calls, So total 14 CQT is forever locked in the contract.   ## Tools Used Hardhat test  ## Recommended Mitigation Steps Please think again when `totalGlobalShares` is zero.  "}, {"title": "reset rewardsLocked to 0 when no longer used", "html_url": "https://github.com/code-423n4/2021-10-covalent-findings/issues/13", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-10-covalent-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The function _stake() initializes endEpoch using the value of rewardsLocked. Afterwards rewardsLocked is no longer used (because now endEpoch !=0)  So you can set rewardsLocked to 0 save a bit of gas.  ## Proof of Concept https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L171-L176  ## Tools Used  ## Recommended Mitigation Steps Update to code of  _stake() to: if (endEpoch == 0) {            endEpoch = uint128(block.number) + rewardsLocked / allocatedTokensPerEpoch;            rewardsLocked = 0; // no longer used and saves a bit of gas }  "}, {"title": "reward tokens could get lost due to rounding down", "html_url": "https://github.com/code-423n4/2021-10-covalent-findings/issues/10", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2021-10-covalent-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The function depositRewardTokens divides the \"amount\" of tokens by allocatedTokensPerEpoch to calculate the endEpoch. When \"amount\" isn't a multiple of allocatedTokensPerEpoch the result of the division will be rounded down, effectively losing a number of tokens for the rewards.  For example if allocatedTokensPerEpoch is set to 3e18 and \"amount\" is 100e18 then endEpoch will be increased with 33e18 and the last 1e18 tokens are lost.  A similar problem occurs here: - in setAllocatedTokensPerEpoch(), with the recalculation of endEpoch  - in takeOutRewardTokens(), with the retrieval of tokens  - in _stake(), when initializing endEpoch (e.g. when endEpoch==0)   ## Proof of Concept https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L90-L98  https://github.com/code-423n4/2021-10-covalent/blob/ded3aeb2476da553e8bb1fe43358b73334434737/contracts/DelegatedStaking.sol#L368-L383  ## Tools Used  ## Recommended Mitigation Steps In depositRewardTokens() add, in the beginning of function, before the if statement: require(amount % allocatedTokensPerEpoch == 0,\"Not multiple\");  In takeOutRewardTokens() add: require(amount % allocatedTokensPerEpoch == 0,\"Not multiple\");  Update setAllocatedTokensPerEpoch() to something like:  if (endEpoch != 0) {       ...    uint128 futureRewards = ...    require(futureRewards % amount ==0,\"Not multiple\");    ...    } else { // to prevent issues with _stake()     require(rewardsLocked % allocatedTokensPerEpoch==0,\"Not multiple\"); }    "}, {"title": "getValidatorsDetails is getting disabled validators as well", "html_url": "https://github.com/code-423n4/2021-10-covalent-findings/issues/9", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor acknowledged"], "target": "2021-10-covalent-findings", "body": "getValidatorsDetails is getting disabled validators as well"}, {"title": "Unnecessary require checker", "html_url": "https://github.com/code-423n4/2021-10-covalent-findings/issues/3", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2021-10-covalent-findings", "body": "# Handle  xYrYuYx   # Vulnerability details  ## Impact In `disableValidator` function, validatorId checker is not required, or it is good to change require order for better contract.  ## Proof of Concept If `validatorId` is higher than `validatorsN`, it means, that validator is not initialized, so `validator._address` is always `address(0)`. so it will revert in Line 358. It means that Line 359 cannot be executed at all.  ## Tools Used  ## Recommended Mitigation Steps Move Line 359 (https://github.com/code-423n4/2021-10-covalent/blob/main/contracts/DelegatedStaking.sol#L359) at the top of function body, before get validator storage variable. This is good to track correct issue.  Or   You can remove that line. So if validatorId is invalid, the error message will be `Caller is not the owner or the validator`, because validator._address = address(0) which cannot be caller.  "}, {"title": "Update function access", "html_url": "https://github.com/code-423n4/2021-10-covalent-findings/issues/2", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-10-covalent-findings", "body": "Update function access"}, {"title": "Recommend to use OZ SafeERC20 library", "html_url": "https://github.com/code-423n4/2021-10-covalent-findings/issues/1", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-10-covalent-findings", "body": "# Handle  xYrYuYx   # Vulnerability details  ## Impact This is too complicated steps to transfer ERC20 token which could use more gas. You don't need to check balance before transfer. If there is no enough balance, it SafeERC20 will revert. Also you don't need to check balance after transfer, because CQT does not have transaction fee.  ## Proof of Concept https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/utils/SafeERC20.sol  ## Tools Used  ## Recommended Mitigation Steps Since there is no transaction fee in CQT token, you can use OZ SafeERC20 library to send or receive.  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/utils/SafeERC20.sol#L20 https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/utils/SafeERC20.sol#L28   "}, {"title": "WadRayMath state variables", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/110", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-10-union-findings", "body": "# Handle  pants   # Vulnerability details  WadRayMath state variables WAD, halfWAD could be set private.  "}, {"title": "Lack of precision in wadDiv ", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/109", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-10-union-findings", "body": "Lack of precision in wadDiv "}, {"title": "caching multiple used variables", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/106", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-union-findings", "body": "# Handle  pants   # Vulnerability details  In Treasury.editSchedule      function editSchedule(         uint256 dripStart_,         uint256 dripRate_,         address target_,         uint256 amount_     ) public onlyAdmin {         require(tokenSchedules[target_].target != address(0), \"Target schedule doesn't exist\");         tokenSchedules[target_].dripStart = dripStart_;         tokenSchedules[target_].dripRate = dripRate_;         tokenSchedules[target_].amount = amount_;     }   We suggest to cache  tokenSchedules[target_] at start and then use the cached value to save repeated access to a *storage* state variable.  "}, {"title": "Gas efficiency suggestions", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/105", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-10-union-findings", "body": "Gas efficiency suggestions"}, {"title": "double reading from memory inside a for loop.", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/103", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-union-findings", "body": "double reading from memory inside a for loop."}, {"title": "--j is more gas efficient than j--.", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/102", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-10-union-findings", "body": "--j is more gas efficient than j--."}, {"title": "More efficient loops", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/100", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-10-union-findings", "body": "More efficient loops"}, {"title": "UToken.uErc20 field could be immutable ", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/98", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-10-union-findings", "body": "UToken.uErc20 field could be immutable "}, {"title": "UToken.__UToken_init can be frontrun", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/97", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-10-union-findings", "body": "# Handle  pants   # Vulnerability details  The function __UToken_init can be frontrun. We recommend adding an initializer owner which only it allowed to call such functions, instead of the current _admin there.  Not sure whether frontrunning is Low / Medium risk.  "}, {"title": "UToken.sol _redeemFresh could be set private instead internal", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/95", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-union-findings", "body": "# Handle  pants   # Vulnerability details  This is one of many examples of the appearance of private instead of internal. Since we manually code reviewing and writing issues we don't list all the appearances. Calling a private function is more gas efficient than calling internal.   Here we refer to UToken.sol._redeemFresh function that is used only in UToken.sol file.   "}, {"title": "Open TODOs in `Treasury.sol`", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/94", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-10-union-findings", "body": "# Handle  pants   # Vulnerability details  Line 57  ## Impact Open TODOs can hint at programming or architectural errors that still need to be fixed.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Resolve the TODO and bubble up the error.  "}, {"title": "Unchecked math operations", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/93", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-10-union-findings", "body": "Unchecked math operations"}, {"title": ".length in a loop", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/92", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-union-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact .length in a loop can be extracted into a variable and used where necessary to reduce the number of storage reads. An example where this could be applied:   for (uint256 i = 0; i < moneyMarkets.length; i++) Solution:   uint moneyMarketsLength = moneyMarkets.length;   for (uint256 i = 0; i < moneyMarketsLength; i++) Cache the length of the array and use this local variable when iterating over the storage array.  "}, {"title": "Zero transfers", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/91", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-10-union-findings", "body": "Zero transfers"}, {"title": "Pre-calculate known values", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/90", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-union-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact This duration calculation does not change so can be pre-calculated to reduce gas costs:   // before   amount = (vestingAmount * (block.timestamp - lastUpdate)) / (vestingEnd - vestingBegin);    // after   uint256 public constant VESTING_DURATION; // constant state variable   VESTING_DURATION = vestingEnd - vestingBegin; // assign value in the constructor   amount = (vestingAmount * (block.timestamp - lastUpdate)) / VESTING_DURATION;  Same with this:   return (token.getPastTotalSupply(blockNumber) * 4e16) / 1e18; //4%   "}, {"title": "list of _admins", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/89", "labels": ["bug", "0 (Non-critical)"], "target": "2021-10-union-findings", "body": "list of _admins"}, {"title": "Struct with only 1 element", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/88", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-union-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact It is not efficient to have a struct with only 1 field as structs are meant for grouping related information together. A market struct can be replaced by directly pointing to a bool value:     //before     mapping(address => Market) public supportedMarkets;     struct Market {         bool isSupported;     }     //after    mapping(address => bool) public supportedMarkets;   "}, {"title": "Immutable variables", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/87", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-10-union-findings", "body": "Immutable variables"}, {"title": "getSupply and getSupplyView are identical", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/86", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-10-union-findings", "body": "getSupply and getSupplyView are identical"}, {"title": "Two-step change of a critical parameter", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/84", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-10-union-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact In Treasury function setAdmin allows an admin to change it to a different address. This function has no validations, even a simple check for zero-address is missing, and there is no validation of the new address being correct. If the admin accidentally uses an invalid address for which they do not have the private key, then the system gets locked because the swivel cannot be corrected and none of the other functions that require admin caller can be executed. A similar issue was reported in a previous contest and was assigned a severity of medium: https://github.com/code-423n4/2021-06-realitycards-findings/issues/105  ## Recommended Mitigation Steps Consider either introducing a two-step process or making a test call to the new admin before updating it.  "}, {"title": "deposit onlyAssetManager", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/83", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-10-union-findings", "body": "deposit onlyAssetManager"}, {"title": "Wrong implementation of `CreditLimitByMedian.sol#getLockedAmount()` will lock a much bigger total amount of staked tokens than expected", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/81", "labels": ["bug", "2 (Med Risk)"], "target": "2021-10-union-findings", "body": "Wrong implementation of `CreditLimitByMedian.sol#getLockedAmount()` will lock a much bigger total amount of staked tokens than expected"}, {"title": "Wrong implementation of `CreditLimitByMedian.sol#getLockedAmount()` makes it unable to unlock `lockedAmount` in `CreditLimitByMedian` model", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/80", "labels": ["bug", "3 (High Risk)", "sponsor acknowledged"], "target": "2021-10-union-findings", "body": "Wrong implementation of `CreditLimitByMedian.sol#getLockedAmount()` makes it unable to unlock `lockedAmount` in `CreditLimitByMedian` model"}, {"title": "Comptroller rewards can be artificially inflated and drained by manipulating [totalStaked - totalFrozen] (or: wrong rewards calculation)", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/78", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-10-union-findings", "body": "# Handle  kenzo   # Vulnerability details  By adding a small of amount of staking to a normal user scenario, and not approving this small amount as a loan for anybody, a staker can gain disproportionate amounts of comptroller rewards, even to the point of draining the contract. For example: Stakers A,B,C stake 100, 65, 20, approve it for borrower Z, then staker B stakes an additional 0.07 DAI, and borrower Z borrows 185. This will result in disproportionate amount of rewards.   As far as I see, this is the main line that causes the inflated amount (*deep breath*): In calculateRewardsByBlocks, you set: ``` userManagerData.totalStaked = userManagerContract.totalStaked() - userManagerData.totalFrozen; ``` https://github.com/code-423n4/2021-10-union/blob/main/contracts/token/Comptroller.sol#L140 Note that a staker can make this amount very small (depending of course on the current numbers of the protocol). (A more advanced attacker might diminish the effect of the current numbers of the protocol by initiating fake loans to himself and not paying them.) This field is then passed to calculateRewards, and passed further to _getInflationIndexNew, and further to _getInflationIndex. passed to calculateRewards : https://github.com/code-423n4/2021-10-union/blob/main/contracts/token/Comptroller.sol#L167 passed to _getInflationIndexNew : https://github.com/code-423n4/2021-10-union/blob/main/contracts/token/Comptroller.sol#L259 passed to _getInflationIndex : https://github.com/code-423n4/2021-10-union/blob/main/contracts/token/Comptroller.sol#L238 Now we actually use it in the following line (as effectiveAmount): ``` return blockDelta * inflationPerBlock(effectiveAmount).wadDiv(effectiveAmount) + inflationIndex; ``` https://github.com/code-423n4/2021-10-union/blob/main/contracts/token/Comptroller.sol#L315 So 2 things are happening here: 1. mul by ```inflationPerBlock(effectiveAmount)``` - uses the lookup table in Comptroller. This value gets bigger as effectiveAmount gets smaller, and if effectiveAmount is in the area of 10**18, we will get the maximum amount of the lookup. 2. div by ```effectiveAmount``` - as we saw, this can be made small, thereby enlarging the result. All together, this calculation will be set to ```curInflationIndex``` and then used in the following line: ``` return (curInflationIndex - startInflationIndex).wadMul(effectiveStakeAmount).wadMul(inflationIndex); ``` https://github.com/code-423n4/2021-10-union/blob/main/contracts/token/Comptroller.sol#L263 Note the ```curInflationIndex - startInflationIndex```: per my POC (see below), this can result in a curInflationIndex which is orders of magnitude larger (200x) than startInflationIndex. This creates a huge inflation of rewards.  ## Impact Comptroller rewards can be drained.  ## Proof of Concept See the following script for a POC of reward drainage. It is based on the scenario in test/integration/testUserManager: Stakers A,B,C stake 100, 65, 20, and borrower Z borrows 185. But the difference in my script is that just before borrower Z borrows 185, staker B stakes an additional 0.07 DAI. (This will be the small amount that is ```totalStaked - totalFrozen```). Then, we wait 11 blocks to make the loan overdue, call updateOverdueInfo so totalFrozen would be updated, and then staker B calls withdrawRewards. He ends up with 873 unionTokens out of the 1000 the Comptroller has been seeded with. And this number can be enlarged by changing the small additional amount that staker B staked. In this scenario, when calling withdrawRewards, the calculated ```curInflationIndex``` will be 215 WAD, while ```startInflationIndex``` is 1 WAD, and this is the main issue as I understand it.  File password: \"union\". https://pastebin.com/3bJF8mTe   ## Tools Used Manual analysis, hardhat  ## Recommended Mitigation Steps Are you sure that this line should deduct the totalFrozen? ``` userManagerData.totalStaked = userManagerContract.totalStaked() - userManagerData.totalFrozen; ``` https://github.com/code-423n4/2021-10-union/blob/main/contracts/token/Comptroller.sol#L140 Per my tests, if we change it to just  ``` userManagerData.totalStaked = userManagerContract.totalStaked(); ``` Then we are getting normal results again and no drainage. And the var _is_ called just totalStaked... So maybe this is the change that needs to be made? But maybe you have a reason to deduct the totalFrozen. If so, then a mitigation will perhaps be to limit curInflationIndex somehow, maybe by changing the lookup table, or limiting it to a percentage from startInflationIndex ; but even then, there is also the issue of dividing by ```userManagerData.totalStaked``` which can be made quite small as the user has control over that.  "}, {"title": "`UToken.sol` should inherits and complies with `IUToken.sol`", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/77", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-10-union-findings", "body": "# Handle  WatchPug   # Vulnerability details  In the current implementation, `UToken.sol` does not inherit and comply with `IUToken.sol`. This is against the best practices and inconsistent with other contracts in the codebase that do inherit and comply with their interfaces.  For example, the `repay()` function defined in `IUToken.sol` is implementated as `repayBorrowBehalf()` and `repayBorrow()`.  It makes the `IUToken.sol` unable to be used and misleading.  ### Recommendation  Make `UToken.sol` inherits and complies with `IUToken.sol`.  "}, {"title": "Gas: Explicit overflow checks even though solidity 0.8 is used (2)", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/75", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-union-findings", "body": "# Handle  cmichel   # Vulnerability details  The `UToken` contract uses solidity version 0.8 which already comes with implicit overflow checks. The explicit overflow checks in `removeReserves` can be removed:  ```solidity // We checked reduceAmount <= totalReserves above, so this should never revert. // @audit this overflow check already happened implicitly require(totalReservesNew <= totalReserves, \"reduce reserves unexpected underflow\"); ```  "}, {"title": "Gas: Explicit overflow checks even though solidity 0.8 is used (1)", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/74", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-union-findings", "body": "# Handle  cmichel   # Vulnerability details  The `UToken` contract uses solidity version 0.8 which already comes with implicit overflow checks. The explicit overflow checks in `addReserves` can be removed:  ```solidity /* Revert on overflow */ // @audit this overflow check already happened implicitly require(totalReservesNew >= totalReserves, \"add reserves unexpected overflow\"); totalReserves = totalReservesNew; ```  "}, {"title": "Gas: `AssetManager.getMoneyMarket` use assignment", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/72", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-10-union-findings", "body": "Gas: `AssetManager.getMoneyMarket` use assignment"}, {"title": "Gas: `AssetManager.rebalance` cache last market", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/71", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-10-union-findings", "body": "Gas: `AssetManager.rebalance` cache last market"}, {"title": "`UnionToken` should check whitelist on `from`?", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/69", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-10-union-findings", "body": "# Handle  cmichel   # Vulnerability details  The `UnionToken` can check for a whitelist on each transfer in `_beforeTokenTransfer`:  ```solidity if (whitelistEnabled) {     require(isWhitelisted(msg.sender) || to == address(0), \"Whitelistable: address not whitelisted\"); } ```  This whitelist is checked on `msg.sender` not on `from`, the token owner.  ## Impact A single whitelisted account can act as an operator (everyone calls `unionToken.allow(operator, max)` where the operator is a whitelisted trusted smart contract) for all other accounts. This essentially bypasses the whitelist.  ## Recommended Mitigation Steps Think about if the whitelist on `msg.sender` is correct or if it should be on `from`.  "}, {"title": "`withdrawRewards` should send remaining balance", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/68", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-10-union-findings", "body": "`withdrawRewards` should send remaining balance"}, {"title": "`repayBorrowWithPermit` is missing `nonReentrant`", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/67", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-10-union-findings", "body": "# Handle  cmichel   # Vulnerability details  The `UToken.repayBorrowWithPermit` function is missing the `repayBorrowWithPermit` modifier which the other repay functions (`repayBorrow`, `repayBorrowBehalf`) have.  ## Impact There's a possibility for re-entrancy. Even though I did not find a way to exploit it, it seems like this function should have the `nonReentrant` modifier as the other similar `repay*` functions have it as well.  ## Recommended Mitigation Steps Add `nonReentrant` to `repayBorrowWithPermit`.  "}, {"title": "`borrow` must `accrueInterest` first", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/66", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-10-union-findings", "body": "# Handle  cmichel   # Vulnerability details  The `UToken.borrow` function first checks the borrowed balance and the old credit limit _before_ accruing the actual interest on the market:  ```solidity // @audit this uses the old value require(borrowBalanceView(msg.sender) + amount + fee <= maxBorrow, \"UToken: amount large than borrow size max\");  require(     // @audit this calls uToken.calculateInterest(account) which returns old value     uint256(_getCreditLimit(msg.sender)) >= amount + fee,     \"UToken: The loan amount plus fee is greater than credit limit\" );  // @audit accrual only happens here require(accrueInterest(), \"UToken: accrue interest failed\"); ```  Thus the borrowed balance of the user does not include the latest interest as it uses the old global `borrowIndex` but the new `borrowIndex` is only set in `accrueInterest`.  ## Impact In low-activity markets, it could be that the `borrowIndex` accruals (`accrueInterest` calls) happen infrequently and a long time is between them. A borrower could borrow tokens, and borrow more tokens later at a different time without first having their latest debt accrued. This will lead to borrowers being able to borrow more than `maxBorrow` and **more than their credit limit** as these checks are performed before updating accruing interest.  ## Recommended Mitigation Steps The `require(accrueInterest(), \"UToken: accrue interest failed\");` call should happen at the beginning of the function.   "}, {"title": "Unbounded iteration in `deleteMarket`", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/65", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-10-union-findings", "body": "# Handle  cmichel   # Vulnerability details  The `MarketRegistry.deleteMarket` iterates over all `uTokenList` elements.  ## Impact The transactions can fail if the arrays get too big and the transaction would consume more gas than the block limit. This will then result in a denial of service for the desired functionality and break core functionality.  ## Recommended Mitigation Steps Keep the array small or use an [EnumerableSet])(https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/structs/EnumerableSet.sol) that can delete in constant time.  "}, {"title": "Rebalance will fail due to low precision of percentages", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/64", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-10-union-findings", "body": "# Handle  cmichel   # Vulnerability details  The `AssetManager.rebalance` function has a check at the end to ensure that all tokens are deposited again:  ```solidity require(token.balanceOf(address(this)) == 0, \"AssetManager: there are remaining funds in the fund pool\"); ```  The idea is that the last market deposits all `remainingTokens` but the last market does not have to support the token in which case the transaction will fail, or the `percentages` parameter needs to be chosen to distribute all tokens before the last one (they need to add up to `1e4`). However, these percentages have a low precision as they are in base points, i.e, the lowest unit is `1 = 0.01%`. This will leave dust in the contract in most cases as the tokens have much higher precision.  ## POC Assume the last market does not support the token and thus `percentages` are chosen as `[5000, 5000]` to rebalance the first two markets. Withdrawing all tokens form the markets leads to a `tokenSupply = token.balanceOf(address(this)) = 10,001`:  Then the deposited amount is `amountToDeposit = (tokenSupply * percentages[i]) / 10000 = 10,001 * 5,000 / 10,000 = 5,000`. The two deposits will leave dust of `10,001 - 2 * 5,000 = 1` in the contract and the `token.balanceOf(address(this)) == 0` balance check will revert.  ## Impact Rebalancing will fail in most cases if the last market does not support the token due to precision errors.  ## Recommended Mitigation Steps Remove the final zero balance check, or make sure that the last market that is actually deposited to receives all remaining tokens.   "}, {"title": "Rebalance will fail if a market has high utilization", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/63", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2021-10-union-findings", "body": "Rebalance will fail if a market has high utilization"}, {"title": "`withdrawSeq` might not be set", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/62", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-10-union-findings", "body": "# Handle  cmichel   # Vulnerability details  The `AssetManager.withdraw` function iterates through the markets based on the `withdrawSeq` array field. This field must be manually set to cover all markets on each new market addition.  ## Impact It could be that a market is added but this array is not updated. Thus not all markets are iterated and users might not be able to withdraw their entire `amount` as the new market is skipped  ## Recommended Mitigation Steps Ensure that `withdrawSeq` is always up-to-date when `addAdapter` is called, for example, `addAdapter` could add the new adapter as the last element to `withdrawSeq` until it's manually set through `changeWithdrawSequence`.   "}, {"title": "Code Style: constants should be named in all caps", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/61", "labels": ["bug", "0 (Non-critical)"], "target": "2021-10-union-findings", "body": "Code Style: constants should be named in all caps"}, {"title": "Cache array length in for loops can save gas", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/60", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-10-union-findings", "body": "Cache array length in for loops can save gas"}, {"title": "Adding unchecked directive can save gas", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/58", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-10-union-findings", "body": "Adding unchecked directive can save gas"}, {"title": "Cache and read storage variables from the stack can save gas", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/57", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-10-union-findings", "body": "# Handle  WatchPug   # Vulnerability details  For the storage variables that will be accessed multiple times, cache and read from the stack can save ~100 gas from each extra read (`SLOAD` after Berlin).  For example:  https://github.com/code-423n4/2022-01-elasticswap/blob/d107a198c0d10fbe254d69ffe5be3e40894ff078/elasticswap/src/contracts/Exchange.sol#L217-L233  ```solidity   uint256 baseTokenQtyToRemoveFromInternalAccounting =       (_liquidityTokenQty * internalBalances.baseTokenReserveQty) /           totalSupplyOfLiquidityTokens;    internalBalances       .baseTokenReserveQty -= baseTokenQtyToRemoveFromInternalAccounting;    // We should ensure no possible overflow here.   if (quoteTokenQtyToReturn > internalBalances.quoteTokenReserveQty) {       internalBalances.quoteTokenReserveQty = 0;   } else {       internalBalances.quoteTokenReserveQty -= quoteTokenQtyToReturn;   }    internalBalances.kLast =       internalBalances.baseTokenReserveQty *       internalBalances.quoteTokenReserveQty; ```  `internalBalances.baseTokenReserveQty` and `internalBalances.quoteTokenReserveQty` can be cached.  ### Recommendation  Change to:  ```solidity uint256 internalBaseTokenReserveQty = internalBalances.baseTokenReserveQty; uint256 baseTokenQtyToRemoveFromInternalAccounting =     (_liquidityTokenQty * internalBaseTokenReserveQty) /         totalSupplyOfLiquidityTokens;  internalBalances     .baseTokenReserveQty = internalBaseTokenReserveQty = internalBaseTokenReserveQty - baseTokenQtyToRemoveFromInternalAccounting;  // We should ensure no possible overflow here. uint256 internalQuoteTokenReserveQty = internalBalances.quoteTokenReserveQty; if (quoteTokenQtyToReturn > internalQuoteTokenReserveQty) {     internalBalances.quoteTokenReserveQty = internalQuoteTokenReserveQty = 0; } else {     internalBalances.quoteTokenReserveQty = internalQuoteTokenReserveQty = internalQuoteTokenReserveQty - quoteTokenQtyToReturn; }  internalBalances.kLast =     internalBaseTokenReserveQty *     internalQuoteTokenReserveQty; ```  "}, {"title": "Avoid unnecessary code execution can save some gas in edge cases", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/56", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-10-union-findings", "body": "Avoid unnecessary code execution can save some gas in edge cases"}, {"title": "Unused imports", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/55", "labels": ["bug", "0 (Non-critical)"], "target": "2021-10-union-findings", "body": "Unused imports"}, {"title": "Code Style: consistency", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/52", "labels": ["bug", "0 (Non-critical)"], "target": "2021-10-union-findings", "body": "# Handle  WatchPug   # Vulnerability details  The parameter names of event `RampTargetPrice` should be the same as the struct `TargetPrice` for consistency.  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L61-L78  ```solidity=61 event RampTargetPrice(     uint256 oldTargetPrice,     uint256 newTargetPrice,     uint256 initialTime,     uint256 futureTime ); ```  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L117-L124  ```solidity=117{120-121} struct TargetPrice {     uint256 initialTargetPrice;     uint256 futureTargetPrice;     uint256 initialTargetPriceTime;     uint256 futureTargetPriceTime;          uint256[2] originalPrecisionMultipliers; } ```  ### Recommendation  Consider changing to:  ```solidity event RampTargetPrice(     uint256 oldTargetPrice,     uint256 newTargetPrice,     uint256 initialTargetPriceTime,     uint256 futureTargetPriceTime ); ```  "}, {"title": "Use short circuiting can save gas", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/51", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-10-union-findings", "body": "Use short circuiting can save gas"}, {"title": "UserManager: totalStaked \u2265 totalFrozen should be checked before and after totalFrozen is updated", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/47", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-10-union-findings", "body": "# Handle  itsmeSTYJ   # Vulnerability details  ## Impact  The require statement in `updateTotalFrozen` and `batchUpdateTotalFrozen` to check that totalStaked \u2265 totalFrozen should be done both before and after `_updateTotalFrozen` is called to ensure that totalStake is still \u2265 totalFrozen. This will serve as a sanity check to ensure that the integrity of the system is not compromised.  "}, {"title": "UserManager: _getFrozenCoinAge is not used", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/46", "labels": ["bug", "0 (Non-critical)"], "target": "2021-10-union-findings", "body": "UserManager: _getFrozenCoinAge is not used"}, {"title": "AssetManager: getLoanableAmount() can be made more readable", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/45", "labels": ["bug", "0 (Non-critical)"], "target": "2021-10-union-findings", "body": "AssetManager: getLoanableAmount() can be made more readable"}, {"title": "UserManager: debtWriteOff() doesn't need if borrower has sufficient assets frozen before subtracting", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/44", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-10-union-findings", "body": "UserManager: debtWriteOff() doesn't need if borrower has sufficient assets frozen before subtracting"}, {"title": "UserManager: _updateTotalFrozen can be optimized further", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/43", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-10-union-findings", "body": "UserManager: _updateTotalFrozen can be optimized further"}, {"title": "UserManager: registerMember() can be optimized further", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/41", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-10-union-findings", "body": "UserManager: registerMember() can be optimized further"}, {"title": "UserManager: cancelVouch() should break from loop when address is found.", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/40", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-10-union-findings", "body": "UserManager: cancelVouch() should break from loop when address is found."}, {"title": "UserManager: use mapping to avoid iteration", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/39", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-10-union-findings", "body": "UserManager: use mapping to avoid iteration"}, {"title": "UserManager: addMember() contains redundant require check", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/38", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-10-union-findings", "body": "UserManager: addMember() contains redundant require check"}, {"title": "UserManager: getCreditLimit() can be optimized further", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/37", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-10-union-findings", "body": "UserManager: getCreditLimit() can be optimized further"}, {"title": "UserManager: getTotalLockedStake() redundant assignment", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/36", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-10-union-findings", "body": "UserManager: getTotalLockedStake() redundant assignment"}, {"title": "CreditLimitByMedian: getLockedAmount() can be optimized further.", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/34", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-10-union-findings", "body": "CreditLimitByMedian: getLockedAmount() can be optimized further."}, {"title": "UToken: revert on over/underflow checks in addReserve() and removeReserve() are unnecessary", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/33", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-10-union-findings", "body": "UToken: revert on over/underflow checks in addReserve() and removeReserve() are unnecessary"}, {"title": "UToken: _repayBorrowFresh() function can be optimized further", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/31", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-10-union-findings", "body": "UToken: _repayBorrowFresh() function can be optimized further"}, {"title": "AssetManager: Deposit() function has redundant continue statement.", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/29", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-10-union-findings", "body": "AssetManager: Deposit() function has redundant continue statement."}, {"title": "debtWriteOff updates totalFrozen immaturely, thereby losing staker rewards", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/28", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2021-10-union-findings", "body": "debtWriteOff updates totalFrozen immaturely, thereby losing staker rewards"}, {"title": "For Loops Need Break Statements (UserManager.sol)", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/27", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-union-findings", "body": "# Handle  ye0lde   # Vulnerability details  ## Impact  There is no need to keep iterating through a loop for the full length once the condition being searched for is met.  This will save gas.  ## Proof of Concept  The loops are here: https://github.com/code-423n4/2021-10-union/blob/4176c366986e6d1a6b3f6ec0079ba547b040ac0f/contracts/user/UserManager.sol#L436-L441 https://github.com/code-423n4/2021-10-union/blob/4176c366986e6d1a6b3f6ec0079ba547b040ac0f/contracts/user/UserManager.sol#L444-L449 https://github.com/code-423n4/2021-10-union/blob/4176c366986e6d1a6b3f6ec0079ba547b040ac0f/contracts/user/UserManager.sol#L479-L485 https://github.com/code-423n4/2021-10-union/blob/4176c366986e6d1a6b3f6ec0079ba547b040ac0f/contracts/user/UserManager.sol#L488-L495  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps  Add a \"break\" statement to the loops mentioned above. Note also that there are unnecessary default value initializations of variables associated with the loops.  "}, {"title": "Function getFrozenCoinAge Can Be Made More Efficient (UserManager.sol)", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/26", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-10-union-findings", "body": "Function getFrozenCoinAge Can Be Made More Efficient (UserManager.sol)"}, {"title": "stake function in UserManager checks for allowance, which is also done in ERC20 transferFrom", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/24", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-10-union-findings", "body": "stake function in UserManager checks for allowance, which is also done in ERC20 transferFrom"}, {"title": "Function checkIsOverDue Can Be Made More Efficient (UToken.sol)", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/23", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-10-union-findings", "body": "Function checkIsOverDue Can Be Made More Efficient (UToken.sol)"}, {"title": "Functions TotalSupplyView/TotalSupply Can Be Made More Efficient (AssetManager.sol)", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/22", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-10-union-findings", "body": "Functions TotalSupplyView/TotalSupply Can Be Made More Efficient (AssetManager.sol)"}, {"title": "Change in interest rate can disable repay of loan", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/21", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-10-union-findings", "body": "# Handle  pmerkleplant   # Vulnerability details  ## Impact The ability of a borrower to repay a loan is disabled if the interest rate is  set too high by the `InterestRateModel`.  However, there is neither a check when setting the interest rate nor an  indication in the `IInterestRateModel`'s specs of this behavior.  But this issue could also be used in an adversarial fashion by the  `FixedInterestRateModel`-owner if he/she would disable the repay functionality  for some time and enables it at a later point again with the demand of a  higher interest to be paid by the borrower.  ## Proof of Concept If an account wants to repay a loan, the function  `UToken::_repayBorrowFresh()` is used. This function calls  `UToken::accrueInterest()` ([line](https://github.com/code-423n4/2021-10-union/blob/main/contracts/market/UToken.sol#L465) 465)  which fetches the current borrow rate of the interest rate model  ([line](https://github.com/code-423n4/2021-10-union/blob/main/contracts/market/UToken.sol#L546) 546  and [line](https://github.com/code-423n4/2021-10-union/blob/main/contracts/market/UToken.sol#L330) 330).  The function `UToken::borrowRatePerBlock()` requires an not \"absurdly high\"  rate, or fails otherwise ([line](https://github.com/code-423n4/2021-10-union/blob/main/contracts/market/UToken.sol#L331) 331).  However, there is no check or indicator in `FixedInterestRateModel.sol` to  prevent the owner to set such a high rate that effectively disables repay of borrowed funds ([line](https://github.com/code-423n4/2021-10-union/blob/main/contracts/market/FixedInterestRateModel.sol#L36) 36).  ## Recommended Mitigation Steps Disallow setting the interest rate too high with a check in  `FixedInterestRateModel::setInterestRate()`.  "}, {"title": "Inconsistent use of `UToken::getLastRepay()`", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/20", "labels": ["bug", "0 (Non-critical)"], "target": "2021-10-union-findings", "body": "Inconsistent use of `UToken::getLastRepay()`"}, {"title": "Inconsistent use of `UToken::getBorrowed()`", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/19", "labels": ["bug", "0 (Non-critical)"], "target": "2021-10-union-findings", "body": "Inconsistent use of `UToken::getBorrowed()`"}, {"title": "Unneeded Named Returns (UToken.sol)", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/18", "labels": ["bug", "0 (Non-critical)"], "target": "2021-10-union-findings", "body": "Unneeded Named Returns (UToken.sol)"}, {"title": "Long Revert Strings", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/17", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-10-union-findings", "body": "Long Revert Strings"}, {"title": "Tautologies in require statements", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/16", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-10-union-findings", "body": "Tautologies in require statements"}, {"title": "Missing events for owner only functions that change critical parameters", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/14", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-10-union-findings", "body": "Missing events for owner only functions that change critical parameters"}, {"title": "Improper Upper Bound Definition on the New Member Fee ", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/13", "labels": ["bug", "1 (Low Risk)", "sponsor disputed"], "target": "2021-10-union-findings", "body": "Improper Upper Bound Definition on the New Member Fee "}, {"title": "User Fund loss in case of Unsupported Market token deposit", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/9", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor acknowledged"], "target": "2021-10-union-findings", "body": "User Fund loss in case of Unsupported Market token deposit"}, {"title": "Duplicate utoken and usermanager can be added which cannot be deleted", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/8", "labels": ["bug", "2 (Med Risk)"], "target": "2021-10-union-findings", "body": "Duplicate utoken and usermanager can be added which cannot be deleted"}, {"title": "Overusage of gas due to non needed loop", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/7", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-10-union-findings", "body": "Overusage of gas due to non needed loop"}, {"title": "setHalfDecayPoint check allowed values", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/6", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-10-union-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The function setHalfDecayPoint allows setting an arbitrary value of halfDecayPoint. However if halfDecayPoint == 0 then inflationPerBlock will have a division by 0.  Probably it is also useful to have an upper limit for halfDecayPoint.  ## Proof of Concept https://github.com/code-423n4/2021-10-union/blob/4176c366986e6d1a6b3f6ec0079ba547b040ac0f/contracts/token/Comptroller.sol#L67-L69  https://github.com/code-423n4/2021-10-union/blob/4176c366986e6d1a6b3f6ec0079ba547b040ac0f/contracts/token/Comptroller.sol#L275-L278   ## Tools Used  ## Recommended Mitigation Steps In the function setHalfDecayPoint: Verify that the new value of halfDecayPoint is within an allowable range ( certainly != 0)  "}, {"title": "MAX_TRUST_LIMIT might be too high", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/5", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2021-10-union-findings", "body": "MAX_TRUST_LIMIT might be too high"}, {"title": "Zero-address checks are missing", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/3", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-10-union-findings", "body": "Zero-address checks are missing"}, {"title": "Governor contract is not matching Contract source", "html_url": "https://github.com/code-423n4/2021-10-union-findings/issues/2", "labels": ["bug", "1 (Low Risk)", "disagree with severity"], "target": "2021-10-union-findings", "body": "Governor contract is not matching Contract source"}, {"title": "Use Minimal Interface for gas optimizations", "html_url": "https://github.com/code-423n4/2021-10-badgerdao-findings/issues/91", "labels": ["bug", "G (Gas Optimization)", "resolved"], "target": "2021-10-badgerdao-findings", "body": "Use Minimal Interface for gas optimizations"}, {"title": "Null check in pricePerShare", "html_url": "https://github.com/code-423n4/2021-10-badgerdao-findings/issues/90", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-10-badgerdao-findings", "body": "# Handle  hack3r-0m   # Vulnerability details  https://github.com/code-423n4/2021-10-badgerdao/blob/main/contracts/WrappedIbbtcEth.sol#L73  https://github.com/code-423n4/2021-10-badgerdao/blob/main/contracts/WrappedIbbtc.sol#L123  oracle can `0` as a price of the share, in that case, 0 will be the denominator in some calculations which can cause reverts from SafeMath (for e.g here: https://github.com/code-423n4/2021-10-badgerdao/blob/main/contracts/WrappedIbbtc.sol#L148 ) resulting in Denial Of Service.  Add a null check to ensure that on every update, the price is greater than 0.  "}, {"title": "WrappedIbbtc and WrappedIbbtcEth contracts do not filter out price feed outliers", "html_url": "https://github.com/code-423n4/2021-10-badgerdao-findings/issues/87", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-10-badgerdao-findings", "body": "# Handle  hyh   # Vulnerability details  ## Impact If price feed is manipulated in any way or there is any malfunction based volatility on the market, both contracts will pass it on a user. In the same time it's possible to construct mitigation mechanics for such cases, so user economics be affected by sustainable price movements only. As price outrages provide a substantial attack surface for the project it's worth adding some complexity to the implementation.  ## Proof of Concept In WrappedIbbtcEth pricePerShare variable is updated by externally run updatePricePerShare function, https://github.com/code-423n4/2021-10-badgerdao/blob/main/contracts/WrappedIbbtcEth.sol#L72, and then used in mint/burn/transfer functions without additional checks via balanceToShares function: https://github.com/code-423n4/2021-10-badgerdao/blob/main/contracts/WrappedIbbtcEth.sol#L155.  In WrappedIbbtc price is requested via pricePerShare function, https://github.com/code-423n4/2021-10-badgerdao/blob/main/contracts/WrappedIbbtc.sol#L123, and used in the same way without additional checks via balanceToShares function, https://github.com/code-423n4/2021-10-badgerdao/blob/main/contracts/WrappedIbbtc.sol#L147.   ## Recommended Mitigation Steps Introduce minting/burning query that runs on schedule, separating user funds contribution and actual mint/burn. With user deposit or burn the corresponding action to be added to commitment query, which execution for mint or redeem will later be sparked by off-chain script according to fixed schedule. This also can be open to public execution with gas compensation incentive, for example as it's done in Tracer protocol: https://github.com/tracer-protocol/perpetual-pools-contracts/blob/develop/contracts/implementation/PoolKeeper.sol#L131 Full code of an implementation is too big to include it in the report, but viable versions are available publicly (Tracer protocol version can be found at the same repo, https://github.com/tracer-protocol/perpetual-pools-contracts/blob/develop/contracts/implementation/PoolCommitter.sol).  Once the scheduled mint/redeem query is added, the additional logic to control for price outliers will become possible there, as in this case mint/redeem execution can be conditioned to happen on calm market only, where various definitions of calm can be implemented. One of the approaches is to keep track of recent prices and require that new price each time be within a threshold from median of their array.  Example:  // Introduce small price tracking arrays: uint256[] private times; uint256[] private prices;  // Current position in array uint8 curPos;  // Current length, grows from 0 to totalMaxPos as prices are being added uint8 curMaxPos;  // Maximum length, we track up to totalMaxPos prices uint8 totalMaxPos = 10;  // Price movement threshold uint256 moveThreshold = 0.1*1e18;  We omit the full implementation here as it is lengthy enough and can vary. The key steps are: * Run query for scheduled mint/redeem with logic: if next price is greater than median of currently recorded prices by threshold, add it to the records, but do not mint/redeem. * That is, when scheduled mint/redeem is run, on new price request, WrappedIbbtcEth.core.pricePerShare() or WrappedIbbtc.oracle.pricePerShare(), get newPrice and calculate current price array median, curMed * prices[curPos] = newPrice * if (curMaxPos < totalMaxPos) {curMaxPos += 1} * if (curPos == curMaxPos) {curPos = 0} else {curPos += 1} * if (absolute_value_of(newPrice - curMed) < moveThreshold * curMed / 1e18) {do_mint/redeem; return_0_status} * else {return_1_status}  Schedule should be frequent enough, say once per 30 minutes, which is kept while returned status is 0. While threshold condition isn't met and returned status is 1, it runs once per 10 minutes. The parameters here are subject to calibration. This way if the price movement is sustained the mint/redeem happens after price array median comes to a new equilibrium. If price reverts, the outbreak will not have material effect mint/burn operations. This way the contract vulnerability is considerably reduced as attacker would need to keep distorted price for period long enough, which will happen after the first part of deposit/withdraw cycle. I.e. deposit and mint, burn and redeem operations will happen not simultaneously, preventing flash loans to be used to elevate the quantities, and for price to be effectively distorted it would be needed to keep it so for substantial amount of time.  "}, {"title": "WrappedIbbtcEth contract will use stalled price for mint/burn if updatePricePerShare wasn't run properly", "html_url": "https://github.com/code-423n4/2021-10-badgerdao-findings/issues/86", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-10-badgerdao-findings", "body": "# Handle  hyh   # Vulnerability details  ## Impact Malicious user can monitor SetPricePerShare event and, if it was run long enough time ago and market moved, but, since there were no SetPricePerShare fired, the contract's pricePerShare is outdated, so a user can mint() with pricePerShare that is current for contract, but outdated for market, then wait for price update and burn() with updated pricePerShare, yielding risk-free profit at expense of contract holdings.  ## Proof of Concept WrappedIbbtcEth updates pricePerShare variable by externally run updatePricePerShare function. The variable is then used in mint/burn/transfer functions without any additional checks, even if outdated/stalled. This can happen if the external function wasn't run for any reason. The variable is used via balanceToShares function: https://github.com/code-423n4/2021-10-badgerdao/blob/main/contracts/WrappedIbbtcEth.sol#L155  This is feasible as updatePricePerShare to be run by off-chain script being a part of the system, and malfunction of this script leads to contract exposure by stalling the price. The malfunction can happen both by internal reasons (bugs) and by external ones (any system-level dependencies, network outrages). updatePricePerShare function: https://github.com/code-423n4/2021-10-badgerdao/blob/main/contracts/WrappedIbbtcEth.sol#L72  ## Recommended Mitigation Steps The risk comes with system design. Wrapping price updates with contract level variable for gas costs minimization is a viable approach, but it needs to be paired with corner cases handling. One of the ways to reduce the risk is as follows:  Introduce a threshold variable for maximum time elapsed since last pricePerShare update to WrappedIbbtcEth contract.  Then 2 variants of transferFrom and transfer functions can be introduced, both check condition {now - time since last price update < threshold}. If condition holds both variants do the transfer. If it doesn't the first variant reverts, while the second do costly price update. I.e. it will be cheap transfer, that works only if price is recent, and full transfer, that is similar to the first when price is recent, but do price update on its own when price is stalled. This way this full transfer is guaranteed to run and is usually cheap, costing more if price is stalled and it does the update.  After this whenever scheduled price update malfunctions (for example because of network conditions), the risk will be limited by market volatility during threshold time at maximum, i.e. capped.  Example code:    // Added threshold      uint256 public pricePerShare;     uint256 public lastPricePerShareUpdate;   uint256 public priceUpdateThreshold;      event SetPriceUpdateThreshold(uint256 priceUpdateThreshold);        /// ===== Permissioned: Price update threshold =====     function setPriceUpdateThreshold(uint256 _priceUpdateThreshold) external onlyGovernance {         priceUpdateThreshold = _priceUpdateThreshold;         emit SetPriceUpdateThreshold(priceUpdateThreshold);     }      // The only difference with current transfer code is that Full versions call balanceToSharesFull      function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {         uint256 amountInShares = balanceToShares(amount);          _transfer(sender, recipient, amountInShares);         _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amountInShares, \"ERC20: transfer amount exceeds allowance\"));         return true;     }      function transfer(address recipient, uint256 amount) public virtual override returns (bool) {         uint256 amountInShares = balanceToShares(amount);          _transfer(_msgSender(), recipient, amountInShares);         return true;     }        function transferFromFull(address sender, address recipient, uint256 amount) public virtual override returns (bool) {         uint256 amountInShares = balanceToSharesFull(amount);          _transfer(sender, recipient, amountInShares);         _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amountInShares, \"ERC20: transfer amount exceeds allowance\"));         return true;     }      function transferFull(address recipient, uint256 amount) public virtual override returns (bool) {         uint256 amountInShares = balanceToSharesFull(amount);          _transfer(_msgSender(), recipient, amountInShares);         return true;     }      // Now balanceToShares first checks if the price is stale   // And reverts if it is   // While balanceToSharesFull do the same check   // But asks for price instead of reverting   // Having guaranteed execution with increased costs sometimes   // Which is fully deterministic, as user can track SetPricePerShare event   // To understand whether it be usual or increased gas cost if the function be called now      function balanceToShares(uint256 balance) public view returns (uint256) {     require(block.timestamp < lastPricePerShareUpdate + priceUpdateThreshold, \"Price is stalled\");         return balance.mul(1e18).div(pricePerShare);     }        function balanceToSharesFull(uint256 balance) public view returns (uint256) {     if (block.timestamp >= lastPricePerShareUpdate + priceUpdateThreshold) {       updatePricePerShare();     }         return balance.mul(1e18).div(pricePerShare);     }  "}, {"title": "In updatePricePerShare() no value is returned", "html_url": "https://github.com/code-423n4/2021-10-badgerdao-findings/issues/85", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-10-badgerdao-findings", "body": "In updatePricePerShare() no value is returned"}, {"title": "use of depreciated \"now\" ", "html_url": "https://github.com/code-423n4/2021-10-badgerdao-findings/issues/83", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-10-badgerdao-findings", "body": "# Handle  JMukesh   # Vulnerability details  ## Impact In updatePricePerShare() instead of \"block.timestamp\" , \"now\"  is used which is deprciated.  \"block.timestamp\" is way more explicit in showing the intent while \"now\"  relates to the timestamp of the block controlled by the miner  more on this -> https://github.com/ethereum/solidity/issues/4020    ## Tools Used manual review  ## Recommended Mitigation Steps use block.timestamp  "}, {"title": "Check if amount is not zero", "html_url": "https://github.com/code-423n4/2021-10-badgerdao-findings/issues/82", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-badgerdao-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact functions mint, burn, transfer and transferFrom could skip other steps if the amount is 0.   "}, {"title": "Immutable variable", "html_url": "https://github.com/code-423n4/2021-10-badgerdao-findings/issues/81", "labels": ["bug", "duplicate", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-10-badgerdao-findings", "body": "Immutable variable"}, {"title": "onlyOracle never used", "html_url": "https://github.com/code-423n4/2021-10-badgerdao-findings/issues/80", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-badgerdao-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact modifier onlyOracle in WrappedIbbtc is never used, so can be removed to reduce deployment gas costs.   "}, {"title": "ICore import", "html_url": "https://github.com/code-423n4/2021-10-badgerdao-findings/issues/79", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-badgerdao-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact You import ICore interface but actually need only one function from it: pricePerShare(). Consider importing a minimal ICore interface with only the functions that you actually use to reduce deployment gas costs. Or you can just simply re-use ICoreOracle.   "}, {"title": " modified _balances in OZ contract ", "html_url": "https://github.com/code-423n4/2021-10-badgerdao-findings/issues/78", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-10-badgerdao-findings", "body": " modified _balances in OZ contract "}, {"title": "Consider making contracts Pausable", "html_url": "https://github.com/code-423n4/2021-10-badgerdao-findings/issues/76", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-10-badgerdao-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact There are many external risks (mentioned https://github.com/code-423n4/2021-10-badgerdao#risks) so my suggestion is that you should consider making the contracts pausable, so in case of an unexpected event, the governance can pause transfers.  ## Recommended Mitigation Steps Consider making contracts Pausable https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/Pausable.sol  "}, {"title": "pendingGovernance and  Governace address can be same", "html_url": "https://github.com/code-423n4/2021-10-badgerdao-findings/issues/74", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-10-badgerdao-findings", "body": "# Handle  JMukesh   # Vulnerability details  ## Impact when pendingGovernance  call acceptPendingGovernance() , governance value get updated  but pendingGovernance  remain same its not updated to address(0)   governance = pendingGovernance;  due to which pendingGovernace and Governace share same address which should not happen  ## Tools Used manual review  ## Recommended Mitigation Steps update pendingGovernance to address(0)  "}, {"title": "use of floating pragma", "html_url": "https://github.com/code-423n4/2021-10-badgerdao-findings/issues/71", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-10-badgerdao-findings", "body": "use of floating pragma"}, {"title": "PREVENT DIV BY 0", "html_url": "https://github.com/code-423n4/2021-10-badgerdao-findings/issues/70", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-10-badgerdao-findings", "body": "# Handle  defsec   # Vulnerability details  ## Impact  On several locations in the code precautions are taken not to divide by 0, because this will revert the code. However on some locations this isn\u2019t done.  Especially in the balanceToShares function div(pricePerShare) which isn\u2019t checked.   That will cause to revert on the transfer and transferFrom function. Oracle pricePerShare variable should be cheked on the balance calculation.  ## Proof of Concept  1. Navigate to the following contracts,  \"https://github.com/code-423n4/2021-10-badgerdao/blob/9d4734becebd729299f154c0cfa1d3a7f06cccfb/contracts/WrappedIbbtcEth.sol#L156\"  \"https://github.com/code-423n4/2021-10-badgerdao/blob/9d4734becebd729299f154c0cfa1d3a7f06cccfb/contracts/WrappedIbbtc.sol#L148\"  2. If oracle fails, the pricePerShare variable will be equal to zero therefore div by zero will occur.  ## Tools Used  Review  ## Recommended Mitigation Steps  Recommend making sure division by 0 won\u2019t occur by checking the variables beforehand and handling this edge case.  "}, {"title": "Deprecated Function Usage", "html_url": "https://github.com/code-423n4/2021-10-badgerdao-findings/issues/69", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-10-badgerdao-findings", "body": "# Handle  defsec   # Vulnerability details  ## Impact  After pragma version, 0.7.0, the contract should use block.timestamp.  ## Proof of Concept  1. Navigate to the following contract.  \"https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/DexHandlers/UniswapHandler.sol#L153\"  \"https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/DexHandlers/UniswapHandler.sol#L178\"  2. Now is used instead of block.timestamp.  ## Tools Used  None  ## Recommended Mitigation Steps  It is recommended to use block.timestamp instead of now.  "}, {"title": "No sanity check on pricePerShare might lead to lost value", "html_url": "https://github.com/code-423n4/2021-10-badgerdao-findings/issues/68", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-10-badgerdao-findings", "body": "# Handle  kenzo   # Vulnerability details  pricePerShare is read either from an oracle or from ibBTC's core.  If one of these is bugged or exploited, there are no safety checks to prevent loss of funds.  ## Impact As pricePerShare is used to calculate transfer amount, a bug or wrong data which returns smaller pricePerShare than it really is could result in drainage of wibbtc from Curve pool.  ## Proof of Concept Curve's swap and remove liquidity functions will both call wibbtc's `transfer` function: https://etherscan.io/address/0xFbdCA68601f835b27790D98bbb8eC7f05FDEaA9B#code%23L790 https://etherscan.io/address/0xFbdCA68601f835b27790D98bbb8eC7f05FDEaA9B#code%23L831 The `transfer` function calculates the amount to send by calling `balanceToShares`: https://github.com/code-423n4/2021-10-badgerdao/blob/main/contracts/WrappedIbbtcEth.sol#L127 `balanceToShares` calculates the shares (=amount to send) by dividing in `pricePerShare`: https://github.com/code-423n4/2021-10-badgerdao/blob/main/contracts/WrappedIbbtcEth.sol#L156 Therefore, if due to a bug or exploit in ibBTC core / the trusted oracle pricePerShare is smaller than it really is, the amount that will be sent will grow larger. So Curve will send to the user/exploiter doing swap/remove liquidity more tokens that he deserves.  ## Tools Used Manual analysis, hardhat  ## Recommended Mitigation Steps Add sanity check:  pricePerShare should never decrease but only increase with time (as ibbtc accrues interest) (validated with DefiDollar team). This means that on every pricePerShare read/update, if the new pricePerShare is smaller than the current one, we can discard the update as bad data.   This will prevent an exploiter from draining Curve pool's wibbtc reserves by decreasing pricePerShare.  "}, {"title": "The design of `wibBTC` is not fully compatible with the current Curve StableSwap pool", "html_url": "https://github.com/code-423n4/2021-10-badgerdao-findings/issues/65", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-10-badgerdao-findings", "body": "# Handle  WatchPug   # Vulnerability details  Per the documentation, `wibBTC` is designed for a Curve StableSwap pool. However, the design of `wibBTC` makes the balances change dynamically and automatically. This is unusual for an ERC20 token, and it's not fully compatible with the current Curve StableSwap pool.  Specifically, a Curve StableSwap pool will maintain the balances of its `coins` based on the amount of tokens added, removed, and exchanged each time. In another word, it can not adopt the dynamic changes of the balances that happened automatically.  The pool's actual dynamic balance of `wibBTC` will deviate from the recorded balance in the pool contract as the `pricePerShare` increases.  Furthermore, there is no such way in Curve StableSwap similar to the `sync()` function of UNI v2, which will force sync the stored `reserves` to match the balances.  ### PoC  Given:  - The current `pricePerShare` is: `1`; - The Curve pool is newly created with 0 liquidity;  1. Alice added `100 wibBTC` and `100 wBTC` to the Curve pool; Alice holds 100% of the pool; 2. After 1 month with no activity (no other users, no trading), and the `pricePerShare` of `ibBTC` increases to `1.2`; 3. Alice removes all the liquidity from the Curve pool.  While it's expected to receive `150 wibBTC` and `100 wBTC`, Alice actually can only receive `100 wibBTC` and `100 wBTC`.  ### Recommendation  Consider creating a revised version of the Curve StableSwap contract that can handle dynamic balances properly.  "}, {"title": "Redundant use of `virtual`", "html_url": "https://github.com/code-423n4/2021-10-badgerdao-findings/issues/64", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-10-badgerdao-findings", "body": "# Handle  WatchPug   # Vulnerability details  Based on the context, the functions listed below are not expected to be overridden, thus the use of the keyword `virtual` is redundant.  - transfer() - updatePricePerShare() - transferFrom() - pricePerShare()  ### Recommendation  Consider removing `virtual` for these functions.  "}, {"title": "The `value` parameter of the `Transfer` event is wrong", "html_url": "https://github.com/code-423n4/2021-10-badgerdao-findings/issues/62", "labels": ["bug", "1 (Low Risk)", "disagree with severity"], "target": "2021-10-badgerdao-findings", "body": "The `value` parameter of the `Transfer` event is wrong"}, {"title": "`updatePricePerShare` should be run atomically with `setCore()` to make sure `pricePerShare` is up-to-date with the new Core", "html_url": "https://github.com/code-423n4/2021-10-badgerdao-findings/issues/61", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-10-badgerdao-findings", "body": "# Handle  WatchPug   # Vulnerability details  Given that `setCore()` could potentially lead to a change of `pricePerShare`, and `pricePerShare` will not be updated until `updatePricePerShare()` is called separately.  To ensure `pricePerShare` is up-to-date, `updatePricePerShare` should be run atomically with `setCore()`.  ### Recommendation  Consider changing `setCore()` to:  ```solidity function setCore(address _core) external onlyGovernance {     core = ICore(_core);      updatePricePerShare();      emit SetCore(_core); } ```  "}, {"title": "Critical changes should use two-step procedure", "html_url": "https://github.com/code-423n4/2021-10-badgerdao-findings/issues/60", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-10-badgerdao-findings", "body": "Critical changes should use two-step procedure"}, {"title": "Avoid unnecessary external calls and storage writes can save gas", "html_url": "https://github.com/code-423n4/2021-10-badgerdao-findings/issues/58", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-badgerdao-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-10-badgerdao/blob/9c0ea7b3b02675211446f6c81750c5f3c0a86370/contracts/WrappedIbbtcEth.sol#L69-L77  ```solidity /// @dev Update live ibBTC price per share from core /// @dev We cache this to reduce gas costs of mint / burn / transfer operations. /// @dev Update function is permissionless, and must be updated at least once every X time as a sanity check to ensure value is up-to-date function updatePricePerShare() public virtual returns (uint256) {     pricePerShare = core.pricePerShare();     lastPricePerShareUpdate = now;      emit SetPricePerShare(pricePerShare, lastPricePerShareUpdate); } ```  Per the comment above `function updatePricePerShare()`, `updatePricePerShare()` may get called quite often when `wibBTC` token is being used more often.  There could potentially be multiple calls to `updatePricePerShare()` in one block. In that case, checking if `pricePerShare` was updated earlier in the same block can save some gas from unnecessary external calls and storage writes.  ### Recommendation  Change to:  ```solidity function updatePricePerShare() public virtual returns (uint256) {     if (lastPricePerShareUpdate < now) {         pricePerShare = core.pricePerShare();         lastPricePerShareUpdate = now;          emit SetPricePerShare(pricePerShare, lastPricePerShareUpdate);     } } ```  "}, {"title": "Constants are not explicitly declared", "html_url": "https://github.com/code-423n4/2021-10-badgerdao-findings/issues/57", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-10-badgerdao-findings", "body": "# Handle  WatchPug   # Vulnerability details  It's a best practice to use constant variables rather than literal values to make the code easier to understand and maintain.  Consider defining a constant variable for the literal value used and giving it a clear and self-explanatory name.  Instances include:  https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L82-L82  ```solidity require(duration <= uint256(18250 days), \"INVALID_DURATION\"); ```  Consider changing `uint256(18250 days)` to `MAX_DURATION` constant.   "}, {"title": "Consider removing `ICore.sol`", "html_url": "https://github.com/code-423n4/2021-10-badgerdao-findings/issues/56", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-10-badgerdao-findings", "body": "# Handle  WatchPug   # Vulnerability details  Most of the interfaces defined in `ICore.sol` are unused. The only method used is `pricePerShare()` which is identical to `ICoreOracle.sol#pricePerShare()`.  Therefore, `ICore.sol` can be removed and replaced by `ICoreOracle.sol`.  "}, {"title": "Consider caching `pricePerShare` for `WrappedIbbtc.sol` to save gas", "html_url": "https://github.com/code-423n4/2021-10-badgerdao-findings/issues/55", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-badgerdao-findings", "body": "# Handle  WatchPug   # Vulnerability details  The current implementation of `WrappedIbbtc.sol` will do an external call `oracle.pricePerShare()` every time `pricePerShare` is used, it can be gas consuming considering that the basic features include: `balanceOf()`, `transfer()`, `transferFrom()` will be used very often.  ### Recommendation  Consider caching `pricePerShare` in storage.  "}, {"title": "Inconsistent use of `_msgSender()`", "html_url": "https://github.com/code-423n4/2021-10-badgerdao-findings/issues/54", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-10-badgerdao-findings", "body": "# Handle  WatchPug   # Vulnerability details  `msg.sender` vs internal call of `_msgSender()`.  https://github.com/code-423n4/2021-10-badgerdao/blob/9c0ea7b3b02675211446f6c81750c5f3c0a86370/contracts/WrappedIbbtc.sol#L23-L36  ```solidity modifier onlyPendingGovernance() {     require(msg.sender == pendingGovernance, \"onlyPendingGovernance\");     _; }  modifier onlyGovernance() {     require(msg.sender == governance, \"onlyGovernance\");     _; }  modifier onlyOracle() {     require(msg.sender == address(oracle), \"onlyOracle\");     _; } ```  https://github.com/code-423n4/2021-10-badgerdao/blob/9c0ea7b3b02675211446f6c81750c5f3c0a86370/contracts/WrappedIbbtcEth.sol#L123-L131  ```solidity function transfer(address recipient, uint256 amount) public virtual override returns (bool) {     /// The _balances mapping represents the underlying ibBTC shares (\"non-rebased balances\")     /// Some naming confusion emerges due to maintaining original ERC20 var names      uint256 amountInShares = balanceToShares(amount);      _transfer(_msgSender(), recipient, amountInShares);     return true; } ```  "}, {"title": "Missing error messages in require statements", "html_url": "https://github.com/code-423n4/2021-10-badgerdao-findings/issues/52", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-10-badgerdao-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/vesting/contracts/AirdropDistribution.sol#L525-L525 ```solidity=525 require(airdrop[msg.sender].amount != 0); ```  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/vesting/contracts/AirdropDistribution.sol#L561-L561 ```solidity=561 require(airdrop[msg.sender].amount >= claimable); ```  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/vesting/contracts/InvestorDistribution.sol#L100-L100 ```solidity=100 require(investors[_investor].amount != 0); ```  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/vesting/contracts/InvestorDistribution.sol#L126-L126 ```solidity=126 require(investors[msg.sender].amount - claimable != 0); ```   "}, {"title": "Cache external call result in the stack can save gas", "html_url": "https://github.com/code-423n4/2021-10-badgerdao-findings/issues/51", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-badgerdao-findings", "body": "# Handle  WatchPug   # Vulnerability details  For the result of an external call being written into a storage variable, cache and read from the stack rather than read from the storage variable can save gas.  Instances include:  `IERC20Like(collateralAsset).decimals()` in `DebtLocker.sol#getExpectedAmount()` can be cached to avoid an extra external call.  https://github.com/maple-labs/debt-locker/blob/81f55907db7b23d27e839b9f9f73282184ed4744/contracts/DebtLocker.sol#L237-L253  ```solidity=231 function getExpectedAmount(uint256 swapAmount_) external view override whenProtocolNotPaused returns (uint256 returnAmount_) {     address collateralAsset = IMapleLoanLike(_loan).collateralAsset();     address fundsAsset      = IMapleLoanLike(_loan).fundsAsset();      uint256 oracleAmount =         swapAmount_             * IMapleGlobalsLike(_getGlobals()).getLatestPrice(collateralAsset)  // Convert from `fromAsset` value.             * 10 ** IERC20Like(fundsAsset).decimals()                           // Convert to `toAsset` decimal precision.             * (10_000 - _allowedSlippage)                                       // Multiply by allowed slippage basis points             / IMapleGlobalsLike(_getGlobals()).getLatestPrice(fundsAsset)       // Convert to `toAsset` value.             / 10 ** IERC20Like(collateralAsset).decimals()                      // Convert from `fromAsset` decimal precision.             / 10_000;                                                           // Divide basis points for slippage      uint256 minRatioAmount = swapAmount_ * _minRatio / 10 ** IERC20Like(collateralAsset).decimals();      return oracleAmount > minRatioAmount ? oracleAmount : minRatioAmount; } ```  ### Recommendation  Change to:  ```solidity=231 function getExpectedAmount(uint256 swapAmount_) external view override whenProtocolNotPaused returns (uint256 returnAmount_) {     address collateralAsset = IMapleLoanLike(_loan).collateralAsset();     address fundsAsset      = IMapleLoanLike(_loan).fundsAsset();      uint256 collateralAssetDecimals = IERC20Like(collateralAsset).decimals();      uint256 oracleAmount =         swapAmount_             * IMapleGlobalsLike(_getGlobals()).getLatestPrice(collateralAsset)  // Convert from `fromAsset` value.             * 10 ** IERC20Like(fundsAsset).decimals()                           // Convert to `toAsset` decimal precision.             * (10_000 - _allowedSlippage)                                       // Multiply by allowed slippage basis points             / IMapleGlobalsLike(_getGlobals()).getLatestPrice(fundsAsset)       // Convert to `toAsset` value.             / 10 ** collateralAssetDecimals                                     // Convert from `fromAsset` decimal precision.             / 10_000;                                                           // Divide basis points for slippage      uint256 minRatioAmount = swapAmount_ * _minRatio / 10 ** collateralAssetDecimals;      return oracleAmount > minRatioAmount ? oracleAmount : minRatioAmount; } ```  "}, {"title": "Outdated versions of OpenZeppelin library", "html_url": "https://github.com/code-423n4/2021-10-badgerdao-findings/issues/50", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-10-badgerdao-findings", "body": "Outdated versions of OpenZeppelin library"}, {"title": "Outdated compiler version", "html_url": "https://github.com/code-423n4/2021-10-badgerdao-findings/issues/49", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-10-badgerdao-findings", "body": "Outdated compiler version"}, {"title": "Avoid unnecessary storage read can save gas", "html_url": "https://github.com/code-423n4/2021-10-badgerdao-findings/issues/48", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-10-badgerdao-findings", "body": "Avoid unnecessary storage read can save gas"}, {"title": "Events are emitting storage vars instead of user/system values", "html_url": "https://github.com/code-423n4/2021-10-badgerdao-findings/issues/46", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-10-badgerdao-findings", "body": "Events are emitting storage vars instead of user/system values"}, {"title": "Gas: Event parameters read from storage", "html_url": "https://github.com/code-423n4/2021-10-badgerdao-findings/issues/45", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-10-badgerdao-findings", "body": "Gas: Event parameters read from storage"}, {"title": "Approved spender can spend too many tokens", "html_url": "https://github.com/code-423n4/2021-10-badgerdao-findings/issues/43", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-10-badgerdao-findings", "body": "# Handle  cmichel   # Vulnerability details  The `approve` function has not been overridden and therefore uses the internal _shares_, whereas `transfer(From)` uses the rebalanced amount.  ## Impact The approved spender may spend more tokens than desired. In fact, the approved amount that can be transferred keeps growing with `pricePerShare`.  Many contracts also use the same amount for the `approve` call as for the amount they want to have transferred in a subsequent `transferFrom` call, and in this case, they approve an amount that is too large (as the approved `shares` amount yields a higher rebalanced amount).  ## Recommended Mitigation Steps The `_allowances` field should track the rebalanced amounts such that the approval value does not grow. (This does not actually require overriding the `approve` function.) In `transferFrom`, the approvals should then be subtracted by the _transferred_ `amount`, not the `amountInShares`:  ```solidity // _allowances are in rebalanced amounts such that they don't grow // need to subtract the transferred amount _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\")); ```  "}, {"title": "Pending governance is not cleared", "html_url": "https://github.com/code-423n4/2021-10-badgerdao-findings/issues/42", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-10-badgerdao-findings", "body": "# Handle  cmichel   # Vulnerability details  The `acceptPendingGovernance` function does not reset `pendingGovernance` to zero.  ## Impact The pending governor can repeatedly accept the governance, emitting an `AcceptPendingGovernance` event each time, bloating listeners for this event with unnecessary data.  ## Recommended Mitigation Steps Validate the parameters.   "}, {"title": "Missing parameter validation", "html_url": "https://github.com/code-423n4/2021-10-badgerdao-findings/issues/41", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-10-badgerdao-findings", "body": "Missing parameter validation"}, {"title": "`initialize` functions can be frontrun", "html_url": "https://github.com/code-423n4/2021-10-badgerdao-findings/issues/40", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-10-badgerdao-findings", "body": "`initialize` functions can be frontrun"}, {"title": "Add zero address validation in the setPendingGovernance function", "html_url": "https://github.com/code-423n4/2021-10-badgerdao-findings/issues/35", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-10-badgerdao-findings", "body": "# Handle  defsec   # Vulnerability details  ## Impact  Since the _pendingGovernance parameter in the setPendingGovernance are used to add governance. In the state variable , proper check up should be done , other wise error in these state variable can lead to redeployment of contract.  ## Proof of Concept  1. Navigate to the following contract functions.  \"https://github.com/code-423n4/2021-10-badgerdao/blob/9d4734becebd729299f154c0cfa1d3a7f06cccfb/contracts/WrappedIbbtcEth.sol#L50\"  \"https://github.com/code-423n4/2021-10-badgerdao/blob/9d4734becebd729299f154c0cfa1d3a7f06cccfb/contracts/WrappedIbbtc.sol#L49\"  2. Adding zero address into the pending governance leads to failure of governor only functions.   ## Tools Used  Code Review  ## Recommended Mitigation Steps  Add proper zero address validation.   "}, {"title": "Upgrade pragma to at least 0.8.4", "html_url": "https://github.com/code-423n4/2021-10-badgerdao-findings/issues/34", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-10-badgerdao-findings", "body": "Upgrade pragma to at least 0.8.4"}, {"title": "`WrappedIbbtc.sol` implements, but does not inherit, the `ICoreOracle` interface", "html_url": "https://github.com/code-423n4/2021-10-badgerdao-findings/issues/28", "labels": ["bug", "0 (Non-critical)"], "target": "2021-10-badgerdao-findings", "body": "`WrappedIbbtc.sol` implements, but does not inherit, the `ICoreOracle` interface"}, {"title": "Remove unused functions in dependencys", "html_url": "https://github.com/code-423n4/2021-10-badgerdao-findings/issues/27", "labels": ["bug", "0 (Non-critical)"], "target": "2021-10-badgerdao-findings", "body": "Remove unused functions in dependencys"}, {"title": "Lack of `address(0)` check", "html_url": "https://github.com/code-423n4/2021-10-badgerdao-findings/issues/26", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-10-badgerdao-findings", "body": "# Handle  pmerkleplant   # Vulnerability details  The arguments of type `address` in the following functions miss a zero-check.  - `initialize()` - `setPendingGovernance()` - `setOracle()`  In the case of `setPendingGovernance()`, where a zero-address could be legitim, it should be stated as such in the docs, or forbidden otherwise.  ## Tools Used slither  "}, {"title": "hard to clear balance", "html_url": "https://github.com/code-423n4/2021-10-badgerdao-findings/issues/24", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-10-badgerdao-findings", "body": "# Handle  jonah1005   # Vulnerability details  ## Impact The contract does not allow users to transfer by share. It's hard for users to clear out all the shares. There will be users using this token with Metamask. There's likely the `pricePerShare` would increase after the user sends transactions. I consider this is a medium-risk issue.  ## Proof of Concept [WrappedIbbtc.sol#L110-L118](https://github.com/code-423n4/2021-10-badgerdao/blob/main/contracts/WrappedIbbtc.sol#L110-L118)  ## Tools Used  ## Recommended Mitigation Steps I consider a new `transferShares` beside the original `transfer()` would build a better UX. I consider sushi's bento box would be a good ref [BentoBox.sol](https://github.com/sushiswap/bentobox/blob/master/contracts/BentoBox.sol)  "}, {"title": "No Initial Ownership Event  (WrappedIbbtcEth.sol, WrappedIbbtcEth.sol)", "html_url": "https://github.com/code-423n4/2021-10-badgerdao-findings/issues/22", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-10-badgerdao-findings", "body": "# Handle  ye0lde   # Vulnerability details  For \"core\", which can be changed by the governance process, an event is emitted when it is changed from 0 to a hopefully valid value in the initialize function.  In the same initialize function the _governance address itself is not verified nor is there an event emitted showing that the governance address has changed from 0 to a different address.  ## Proof of Concept  https://github.com/code-423n4/2021-10-badgerdao/blob/9c0ea7b3b02675211446f6c81750c5f3c0a86370/contracts/WrappedIbbtcEth.sol#L37-L46  Similar but with Oracle instead of Core. https://github.com/code-423n4/2021-10-badgerdao/blob/9c0ea7b3b02675211446f6c81750c5f3c0a86370/contracts/WrappedIbbtc.sol#L38-L45  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps Emit an event reporting governance change or if it is not important to report these initialization events remove the emit for the core initialization.  "}, {"title": "Use existing memory value of state variable (setPendingGovernance)", "html_url": "https://github.com/code-423n4/2021-10-badgerdao-findings/issues/21", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-10-badgerdao-findings", "body": "Use existing memory value of state variable (setPendingGovernance)"}, {"title": "Unable to transfer WrappedIbbtc if Oracle go down", "html_url": "https://github.com/code-423n4/2021-10-badgerdao-findings/issues/20", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-10-badgerdao-findings", "body": "# Handle  gzeon   # Vulnerability details  ## Impact In WrappedIbbtc, user will not be able to transfer if oracle.pricePerShare() (L124) revert. This is because balanceToShares() is called in both transfer and transferFrom, which included a call to pricePerShare().   If this is the expected behavior, note that WrappedIbbtcEth is behaving the opposite as it use the cached value in a local variable pricePerShare which is only updated upon call to updatePricePerShare().  ## Recommended Mitigation Steps Depending on the specification, one of them need to be changed.  "}, {"title": "Gas Optimization: Retrieve internal variables directly ", "html_url": "https://github.com/code-423n4/2021-10-badgerdao-findings/issues/19", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-10-badgerdao-findings", "body": "Gas Optimization: Retrieve internal variables directly "}, {"title": "use safeTransfer instead of transfer of ibbtc", "html_url": "https://github.com/code-423n4/2021-10-badgerdao-findings/issues/11", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-10-badgerdao-findings", "body": "# Handle  pants   # Vulnerability details  ibbtc is ERC20Upgradeable. Not all ERC20 contracts supports \"blind\" transfer method - i.e transfer that you can ignore the return value. You should either check the return value or use openzeppilin safeTransfer   "}, {"title": "missing zero-address check ", "html_url": "https://github.com/code-423n4/2021-10-badgerdao-findings/issues/5", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-badgerdao-findings", "body": "# Handle  jah   # Vulnerability details  ## Impact The parameter that are used in initialize() function to initialize the state variable,these state variable are used in other function to perform operation. since it lacks zero address validation, it will be problematic if there is error in these state variable. some of the function will loss their functionality which can cause the redeployment of contract  ## Proof of Concept https://github.com/code-423n4/2021-10-badgerdao/blob/9c0ea7b3b02675211446f6c81750c5f3c0a86370/contracts/WrappedIbbtcEth.sol#L37  ## Tools Used Manual Analysis ## Recommended Mitigation Steps add require condition which check zero address validation   "}, {"title": "Gas Saving by changing the visibility of initialize function from public to external", "html_url": "https://github.com/code-423n4/2021-10-badgerdao-findings/issues/3", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-10-badgerdao-findings", "body": "Gas Saving by changing the visibility of initialize function from public to external"}, {"title": "receive function", "html_url": "https://github.com/code-423n4/2021-10-slingshot-findings/issues/94", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-10-slingshot-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact Slingshot contract does not need a 'receive' function as it is not supposed to receive ETH directly. Executioner has this function too and it needs to receive ETH from the WETH contract. Because it expects only WETH to send the native asset directly, it should check that the msg.sender is actually WETH contract.  ## Recommended Mitigation Steps receive() external payable {   require(msg.sender == wrappedNativeToken, \"...\"); }   "}, {"title": "Small gas improvement", "html_url": "https://github.com/code-423n4/2021-10-slingshot-findings/issues/90", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-10-slingshot-findings", "body": "Small gas improvement"}, {"title": "ConcatStrings prependNumber is not used", "html_url": "https://github.com/code-423n4/2021-10-slingshot-findings/issues/88", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-10-slingshot-findings", "body": "ConcatStrings prependNumber is not used"}, {"title": "Confusing comment in CurveModule", "html_url": "https://github.com/code-423n4/2021-10-slingshot-findings/issues/85", "labels": ["bug", "1 (Low Risk)", "disagree with severity"], "target": "2021-10-slingshot-findings", "body": "Confusing comment in CurveModule"}, {"title": "Confusing comment on IUniswapModule", "html_url": "https://github.com/code-423n4/2021-10-slingshot-findings/issues/84", "labels": ["bug", "1 (Low Risk)", "disagree with severity"], "target": "2021-10-slingshot-findings", "body": "Confusing comment on IUniswapModule"}, {"title": "Gas: Use a constant instead of `block.timestamp` for the deadline", "html_url": "https://github.com/code-423n4/2021-10-slingshot-findings/issues/83", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-10-slingshot-findings", "body": "Gas: Use a constant instead of `block.timestamp` for the deadline"}, {"title": "Left-over tokens can be stolen", "html_url": "https://github.com/code-423n4/2021-10-slingshot-findings/issues/82", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-10-slingshot-findings", "body": "Left-over tokens can be stolen"}, {"title": "`LibERC20Token.approveIfBelow` should approve(0) first", "html_url": "https://github.com/code-423n4/2021-10-slingshot-findings/issues/81", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-10-slingshot-findings", "body": "`LibERC20Token.approveIfBelow` should approve(0) first"}, {"title": "`Slingshot._sendFunds` function not used and wrong", "html_url": "https://github.com/code-423n4/2021-10-slingshot-findings/issues/80", "labels": ["bug", "0 (Non-critical)"], "target": "2021-10-slingshot-findings", "body": "`Slingshot._sendFunds` function not used and wrong"}, {"title": "Trades where toToken is feeOnTransferToken might send user less tokens than finalAmountMin", "html_url": "https://github.com/code-423n4/2021-10-slingshot-findings/issues/77", "labels": ["bug", "2 (Med Risk)", "disagree with severity"], "target": "2021-10-slingshot-findings", "body": "Trades where toToken is feeOnTransferToken might send user less tokens than finalAmountMin"}, {"title": "Combine external calls into one can save gas", "html_url": "https://github.com/code-423n4/2021-10-slingshot-findings/issues/73", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-slingshot-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-10-slingshot/blob/9c0432cca2e43731d5a0ae9c151dacf7835b8719/contracts/Slingshot.sol#L76-L79  ```solidity=76 for(uint256 i = 0; i < trades.length; i++) {     // Checks to make sure that module exists and is correct     require(moduleRegistry.isModule(trades[i].moduleAddress), \"Slingshot: not a module\"); } ```  An external call to `moduleRegistry.isModule()` will be called each time in this for loop. They can be combined into one external call by creating an `moduleRegistry.isModuleBatch(address[] memory _moduleAddresses)` function and call that function instead.  ### Recommendation  Change to:  ```solidity address[] memory moduleAddresses = new address[](trades.length); for(uint256 i = 0; i < trades.length; i++) {     moduleAddresses[i] = trades[i].moduleAddress; } require(moduleRegistry.isModuleBatch(moduleAddresses), \"Slingshot: not a module\"); ```  "}, {"title": "Typos", "html_url": "https://github.com/code-423n4/2021-10-slingshot-findings/issues/71", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-10-slingshot-findings", "body": "Typos"}, {"title": "Outdated compiler version", "html_url": "https://github.com/code-423n4/2021-10-slingshot-findings/issues/70", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-10-slingshot-findings", "body": "Outdated compiler version"}, {"title": "Avoid unnecessary storage read can save gas", "html_url": "https://github.com/code-423n4/2021-10-slingshot-findings/issues/69", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-10-slingshot-findings", "body": "Avoid unnecessary storage read can save gas"}, {"title": "Adding unchecked directive can save gas", "html_url": "https://github.com/code-423n4/2021-10-slingshot-findings/issues/68", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-10-slingshot-findings", "body": "Adding unchecked directive can save gas"}, {"title": "Code Style: consistency", "html_url": "https://github.com/code-423n4/2021-10-slingshot-findings/issues/67", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-10-slingshot-findings", "body": "Code Style: consistency"}, {"title": "`SlingshotI` is unnecessary", "html_url": "https://github.com/code-423n4/2021-10-slingshot-findings/issues/66", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-10-slingshot-findings", "body": "`SlingshotI` is unnecessary"}, {"title": "Code Style: Abstract contracts should not be prefixed by `I`", "html_url": "https://github.com/code-423n4/2021-10-slingshot-findings/issues/65", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-10-slingshot-findings", "body": "Code Style: Abstract contracts should not be prefixed by `I`"}, {"title": "Cache array length in for loops can save gas", "html_url": "https://github.com/code-423n4/2021-10-slingshot-findings/issues/63", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-slingshot-findings", "body": "Cache array length in for loops can save gas"}, {"title": "Remove redundant access control checks can save gas", "html_url": "https://github.com/code-423n4/2021-10-slingshot-findings/issues/62", "labels": ["bug", "duplicate", "G (Gas Optimization)"], "target": "2021-10-slingshot-findings", "body": "Remove redundant access control checks can save gas"}, {"title": "`IUniswapModule.sol` use an immutable variable `router` can save gas and simplify implementation", "html_url": "https://github.com/code-423n4/2021-10-slingshot-findings/issues/61", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-10-slingshot-findings", "body": "`IUniswapModule.sol` use an immutable variable `router` can save gas and simplify implementation"}, {"title": "`initialBalance` for native token is wrong", "html_url": "https://github.com/code-423n4/2021-10-slingshot-findings/issues/59", "labels": ["bug", "2 (Med Risk)", "disagree with severity"], "target": "2021-10-slingshot-findings", "body": "`initialBalance` for native token is wrong"}, {"title": "Avoid unnecessary code execution can save gas", "html_url": "https://github.com/code-423n4/2021-10-slingshot-findings/issues/57", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-10-slingshot-findings", "body": "# Handle  Jujic   # Vulnerability details  ## Impact ``` function rate() external view returns (uint256) {         if (totalSupply() > 0) {             return (totalLiquidity() * MAGIC_SCALE_1E6) / totalSupply();         } else {             return 0;         }     } ```  ## Proof of Concept https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/IndexTemplate.sol#L512-L518  ## Tools Used Remix  ## Recommended Mitigation Steps Change to: ``` function rate() external view returns (uint256) {         if (totalSupply() != 0) {             return (totalLiquidity() * MAGIC_SCALE_1E6) / totalSupply();              }  ```  "}, {"title": "`CurveModule.sol#swap()` Unused parameter", "html_url": "https://github.com/code-423n4/2021-10-slingshot-findings/issues/56", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor acknowledged"], "target": "2021-10-slingshot-findings", "body": "`CurveModule.sol#swap()` Unused parameter"}, {"title": "Redundant code", "html_url": "https://github.com/code-423n4/2021-10-slingshot-findings/issues/55", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor acknowledged"], "target": "2021-10-slingshot-findings", "body": "# Handle  wuwe1   # Vulnerability details  ## Proof of Concept redundant code  https://github.com/code-423n4/2022-01-elasticswap/blob/main/elasticswap/src/contracts/Exchange.sol#L266-L269  https://github.com/code-423n4/2022-01-elasticswap/blob/main/elasticswap/src/libraries/MathLib.sol#L663-L666  ## Tools Used  remove Exchange.sol#L266-L269  "}, {"title": "Function documentation incorrect for `Slingshot::_transferFromOrWrap`", "html_url": "https://github.com/code-423n4/2021-10-slingshot-findings/issues/53", "labels": ["bug", "1 (Low Risk)", "disagree with severity"], "target": "2021-10-slingshot-findings", "body": "Function documentation incorrect for `Slingshot::_transferFromOrWrap`"}, {"title": "`Adminable::setupAdmin` uses deprecated function", "html_url": "https://github.com/code-423n4/2021-10-slingshot-findings/issues/50", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-10-slingshot-findings", "body": "# Handle  pmerkleplant   # Vulnerability details  The `setupAdmin` function in `Adminable.sol` uses the `_setupRole` function from OpenZeppelin's `AccessControl.sol`.  This function is marked as deprecated in favor of `AccessControl::_grantRole`.  See [line 21 in Adminable.sol](https://github.com/code-423n4/2021-10-slingshot/blob/main/contracts/Adminable.sol#L21) and [line 183 in OpenZeppelin's AccessControl.sol](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/AccessControl.sol#L183)  "}, {"title": "Error messages in `ModuleRegistry.sol` inconsistent to the rest of the project", "html_url": "https://github.com/code-423n4/2021-10-slingshot-findings/issues/49", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-10-slingshot-findings", "body": "Error messages in `ModuleRegistry.sol` inconsistent to the rest of the project"}, {"title": "Inconsistent naming for functions in `ConcatStrings.sol`", "html_url": "https://github.com/code-423n4/2021-10-slingshot-findings/issues/48", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-10-slingshot-findings", "body": "Inconsistent naming for functions in `ConcatStrings.sol`"}, {"title": "Function documentation incorrect for `ConcatStrings::appendUint`", "html_url": "https://github.com/code-423n4/2021-10-slingshot-findings/issues/47", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "sponsor confirmed"], "target": "2021-10-slingshot-findings", "body": "# Handle  pmerkleplant   # Vulnerability details  The documentation for the function `appendUint` in `ConcatStrings.sol` is incorrect. It states: \"Concat two strings\". However, the function concats a string and a uint256.  See: [line 19 in ConcatStrings.sol](https://github.com/code-423n4/2021-10-slingshot/blob/main/contracts/lib/ConcatStrings.sol#L19)  "}, {"title": "Slingshot: Unnecessary receive()", "html_url": "https://github.com/code-423n4/2021-10-slingshot-findings/issues/46", "labels": ["bug", "1 (Low Risk)", "disagree with severity"], "target": "2021-10-slingshot-findings", "body": "Slingshot: Unnecessary receive()"}, {"title": "Slingshot: Index fromToken and toToken for Trade event", "html_url": "https://github.com/code-423n4/2021-10-slingshot-findings/issues/45", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-10-slingshot-findings", "body": "Slingshot: Index fromToken and toToken for Trade event"}, {"title": "Slingshot: Incorrect comment for rescueTokensFromExecutioner()", "html_url": "https://github.com/code-423n4/2021-10-slingshot-findings/issues/43", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-10-slingshot-findings", "body": "Slingshot: Incorrect comment for rescueTokensFromExecutioner()"}, {"title": "ModuleRegistry: Rename modulesIndex \u2192 isModule", "html_url": "https://github.com/code-423n4/2021-10-slingshot-findings/issues/41", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-10-slingshot-findings", "body": "ModuleRegistry: Rename modulesIndex \u2192 isModule"}, {"title": "Executioner: Restrict funds receivable to be only from wrapped native token", "html_url": "https://github.com/code-423n4/2021-10-slingshot-findings/issues/40", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-10-slingshot-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ## Impact  Native fund transfers into the executioner contract are only expected from the wrapped token contract. Hence, it would be good to restrict incoming fund transfers to prevent accidental native fund transfers from other sources.  ## Recommended Mitigation Steps  Modify the `receive()` function to only accept transfers from the wrapped token contract.  ```jsx receive() external payable {   require(msg.sender == address(wrappedNativeToken), 'only wrapped native token'); } ```  "}, {"title": "CurveModule: Redundant jToken", "html_url": "https://github.com/code-423n4/2021-10-slingshot-findings/issues/39", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-10-slingshot-findings", "body": "CurveModule: Redundant jToken"}, {"title": "BalancerV2ModuleMatic: Ensure tokenOut is not native token", "html_url": "https://github.com/code-423n4/2021-10-slingshot-findings/issues/38", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-10-slingshot-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ## Impact  The executioner is designed to handle only ERC20-ERC20 token trades by modules. The balancer V2 vault is able to [automatically unwrap the wrapped native token](https://dev.balancer.fi/helpers/using-native-eth#overview). Hence, it is recommended to ensure that the `tokenOut` parameter passed into the `swap()` function is not the sentinel value.  The [sentinel value used is the null address.](https://dev.balancer.fi/helpers/using-native-eth#sentinel-value)  ## Recommended Mitigation Steps  Consider adding the following check in the function.  `require(tokenOut != address(0), 'native token swap not supported');`  "}, {"title": "String concatenation in revert messages results in increased gas costs + code complexity", "html_url": "https://github.com/code-423n4/2021-10-slingshot-findings/issues/37", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-10-slingshot-findings", "body": "# Handle  TomFrench   # Vulnerability details  ## Impact  Switching to custom errors results in reduced deployment/runtime gas cost + ease of decoding revert message  ## Proof of Concept  https://github.com/code-423n4/2021-10-slingshot/blob/9c0432cca2e43731d5a0ae9c151dacf7835b8719/contracts/Executioner.sol#L38  Should any of the calls to individual modules fail an error message of the form \"<ERROR> Executioner: swap failed: <STEP>\" where ERROR is the underlying error message and STEP displays which trade failed  This requires the inclusion of the `ConcatStrings` library and in order to isolate ERROR, knowledge of the string format is necessary. If instead [custom errors](https://blog.soliditylang.org/2021/04/21/custom-errors/) were used, `ConcatStrings` could be removed which results in reduced deployment + runtime costs along with simplifying the codebase. (see [\"Errors in Depth\"](https://blog.soliditylang.org/2021/04/21/custom-errors/))  ``` // old require(success, appendString(string(data), appendUint(string(\"Executioner: swap failed: \"), i)));  // new error SwapFailed(uint256 step, bytes errorMessage); // at top of file if (!success) revert SwapFailed(i, data); ```  If this is done the Executioner's error messages can then be decoded with a standard abi decoder giving greater compatibility with other tools (helpful should you want to filter for certain error strings at some point) without them having to understand the format of your error messages.  Example of a decoded error message with arguments https://rinkeby.etherscan.io/tx/0x37004044a0a55cce13e2f1dd1813a5f21531cd875fed87ec23ae193e0bb96876  ## Recommended Mitigation Steps  Replace `ConcatStrings` library with custom errors.  "}, {"title": "`> 0` can be replaced with ` != 0` for gas optimisation", "html_url": "https://github.com/code-423n4/2021-10-slingshot-findings/issues/35", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-10-slingshot-findings", "body": "`> 0` can be replaced with ` != 0` for gas optimisation"}, {"title": "Long Revert Strings", "html_url": "https://github.com/code-423n4/2021-10-slingshot-findings/issues/32", "labels": ["bug", "duplicate", "G (Gas Optimization)"], "target": "2021-10-slingshot-findings", "body": "Long Revert Strings"}, {"title": "Unused Named Returns (ConcatStrings.sol)", "html_url": "https://github.com/code-423n4/2021-10-slingshot-findings/issues/31", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-10-slingshot-findings", "body": "Unused Named Returns (ConcatStrings.sol)"}, {"title": "Inaccurate comment (rescueTokensFromExecutioner)", "html_url": "https://github.com/code-423n4/2021-10-slingshot-findings/issues/30", "labels": ["bug", "1 (Low Risk)", "disagree with severity"], "target": "2021-10-slingshot-findings", "body": "Inaccurate comment (rescueTokensFromExecutioner)"}, {"title": "Redundant Code Statement", "html_url": "https://github.com/code-423n4/2021-10-slingshot-findings/issues/27", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-slingshot-findings", "body": "# Handle  defsec   # Vulnerability details  ## Impact  From Pragma 0.8.0, ABI coder v2 is activated by default. The pragma abicoder v2 can be deleted from the repository. That will provide gas optimization.  ## Proof of Concept  1. Navigate to the following code sections.   https://github.com/code-423n4/2021-10-slingshot/blob/main/contracts/Adminable.sol#L3  https://github.com/code-423n4/2021-10-slingshot/blob/main/contracts/ApprovalHandler.sol#L3  https://github.com/code-423n4/2021-10-slingshot/blob/main/contracts/Executioner.sol#L3  https://github.com/code-423n4/2021-10-slingshot/blob/main/contracts/Slingshot.sol#L3  ## Tools Used  None  ## Recommended Mitigation Steps  ABI coder v2 is activated by default. It is recommended to delete redundant codes.   From Solidity v0.8.0 Breaking Changes https://docs.soliditylang.org/en/v0.8.0/080-breaking-changes.html  "}, {"title": "Unnecessary and risky `payable` annotation in swap() functions", "html_url": "https://github.com/code-423n4/2021-10-slingshot-findings/issues/25", "labels": ["bug", "1 (Low Risk)"], "target": "2021-10-slingshot-findings", "body": "Unnecessary and risky `payable` annotation in swap() functions"}, {"title": "Flaws in Slingshot._sendFunds()", "html_url": "https://github.com/code-423n4/2021-10-slingshot-findings/issues/24", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-10-slingshot-findings", "body": "Flaws in Slingshot._sendFunds()"}, {"title": "Unnecessary Use of _msgSender()", "html_url": "https://github.com/code-423n4/2021-10-slingshot-findings/issues/22", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-10-slingshot-findings", "body": "# Handle  defsec   # Vulnerability details  ## Impact The use of _msgSender() when there is no implementation of a meta transaction mechanism that uses it, such as EIP-2771, very slightly increases gas consumption.   ## Proof of Concept  1. Navigate to the following contracts.  \"https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/FeeSplitter.sol#L135\" \"https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/NestedFactory.sol#L111\" \"https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/NestedReserve.sol#L32\"  ## Tools Used  Code review  ## Recommended Mitigation Steps  Replace _msgSender() with msg.sender if there is no mechanism to support meta-transactions like EIP-2771 implemented.    "}, {"title": "getRouter methods could be set external instead public", "html_url": "https://github.com/code-423n4/2021-10-slingshot-findings/issues/16", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-10-slingshot-findings", "body": "getRouter methods could be set external instead public"}, {"title": "nonReentrant modifier isn't necessary for executeTrades function", "html_url": "https://github.com/code-423n4/2021-10-slingshot-findings/issues/15", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-10-slingshot-findings", "body": "nonReentrant modifier isn't necessary for executeTrades function"}, {"title": "A more efficient for loop index proceeding", "html_url": "https://github.com/code-423n4/2021-10-slingshot-findings/issues/9", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-10-slingshot-findings", "body": "# Handle  Jujic   # Vulnerability details  ## Impact Here you could use unchecked{++i} to save gas since it is more efficient then i++.  ``` for (uint256 i; i < ids.length; i++) {  ```  ## Proof of Concept https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L359  ## Tools Used Remix  ## Recommended Mitigation Steps  "}, {"title": "The function _sendFunds could be set private to save gas", "html_url": "https://github.com/code-423n4/2021-10-slingshot-findings/issues/7", "labels": ["bug", "question", "G (Gas Optimization)"], "target": "2021-10-slingshot-findings", "body": "The function _sendFunds could be set private to save gas"}, {"title": "The function _getTokenBalance could be set private to save gas", "html_url": "https://github.com/code-423n4/2021-10-slingshot-findings/issues/6", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-10-slingshot-findings", "body": "The function _getTokenBalance could be set private to save gas"}, {"title": "_transferFromOrWrap could be set private to save gas", "html_url": "https://github.com/code-423n4/2021-10-slingshot-findings/issues/5", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-10-slingshot-findings", "body": "_transferFromOrWrap could be set private to save gas"}, {"title": "Use of constant `keccak` variables results in extra hashing (and so gas).", "html_url": "https://github.com/code-423n4/2021-10-slingshot-findings/issues/3", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-slingshot-findings", "body": "# Handle  TomFrench   # Vulnerability details  ## Impact Increase gas costs on all `onlyAdmin` operations  ## Proof of Concept  The `SLINGSHOT_ADMIN_ROLE` variable is marked as `constant`: https://github.com/code-423n4/2021-10-slingshot/blob/f6e7a0a39e3267bbe3c7fe60d6074cbf54f5750f/contracts/Adminable.sol#L11  This results in the `keccak` operation being performed whenever the variable is used, increasing gas costs relative to just storing the output hash. Changing to `immutable` will only perform hashing on contract deployment which will save gas.  See: https://github.com/ethereum/solidity/issues/9232#issuecomment-646131646  ## Recommended Mitigation Steps  Change the variable to be `immutable` rather than `constant`  "}, {"title": "Malicious governance can abuse approvals to ApprovalHandler", "html_url": "https://github.com/code-423n4/2021-10-slingshot-findings/issues/2", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-10-slingshot-findings", "body": "Malicious governance can abuse approvals to ApprovalHandler"}, {"title": "ModuleRegistry doesn't need to know address of Slingshot.sol", "html_url": "https://github.com/code-423n4/2021-10-slingshot-findings/issues/1", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-10-slingshot-findings", "body": "ModuleRegistry doesn't need to know address of Slingshot.sol"}, {"title": "OverlayV1Governance.setEverything does unnecessary function calls", "html_url": "https://github.com/code-423n4/2021-11-overlay-findings/issues/141", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-11-overlay-findings", "body": "OverlayV1Governance.setEverything does unnecessary function calls"}, {"title": "OverlayV1OVLCollateral.liquidate storage pos.market variable is read up to three times, can be saved to memory", "html_url": "https://github.com/code-423n4/2021-11-overlay-findings/issues/138", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-overlay-findings", "body": "# Handle  hyh   # Vulnerability details  ## Impact  Gas is overspent on storage access.  ## Proof of Concept  ```pos.market``` variable is being read up to three times from storage: https://github.com/code-423n4/2021-11-overlay/blob/main/contracts/collateral/OverlayV1OVLCollateral.sol#L371  ## Recommended Mitigation Steps  Save the needed storage variable to memory and use it.  Now: ``` Position.Info storage pos = positions[_positionId]; ...  (   uint _oi,   uint _oiShares,   uint _priceFrame ) = IOverlayV1Market(pos.market)     .exitData(       _isLong,       pos.pricePoint     );  MarketInfo memory _marketInfo = marketInfo[pos.market]; ... IOverlayV1Market(pos.market).exitOI(... ```  To be: ``` Position.Info storage pos = positions[_positionId]; address memory pos_market = pos.market; ...  (   uint _oi,   uint _oiShares,   uint _priceFrame ) = IOverlayV1Market(pos_market)     .exitData(       _isLong,       pos.pricePoint     );  MarketInfo memory _marketInfo = marketInfo[pos_market]; ... IOverlayV1Market(pos_market).exitOI(... ```  "}, {"title": "OVL token shouldn't be available for substitution, needs to be set only once", "html_url": "https://github.com/code-423n4/2021-11-overlay-findings/issues/135", "labels": ["bug", "1 (Low Risk)", "sponsor disputed"], "target": "2021-11-overlay-findings", "body": "OVL token shouldn't be available for substitution, needs to be set only once"}, {"title": "Fee double counting for underwater positions", "html_url": "https://github.com/code-423n4/2021-11-overlay-findings/issues/134", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-11-overlay-findings", "body": "# Handle  hyh   # Vulnerability details  ## Impact  Actual available fees are less than recorded. That's because a part of them corresponds to underwater positions, and will not have the correct amount stored with the contract: when calculation happens the fee is recorded first, then there is a check for position health, and the funds are channeled to cover the debt firsthand. This way in a case of unfunded position the fee is recorded, but cannot be allocated, so the fees accounted can be greater than value of fees stored.  This can lead to fee withdrawal malfunction, i.e. disburse() will burn more and attempt to transfer more than needed. This leads either to inability to withdraw fees when disburse be failing due to lack of funds, or funds leakage to fees and then inability to perform other withdrawals because of lack of funds.  ## Proof of Concept  The fees are accounted for before position health check and aren't corrected thereafter when there is a shortage of funds.  https://github.com/code-423n4/2021-11-overlay/blob/main/contracts/collateral/OverlayV1OVLCollateral.sol#L311  ## Recommended Mitigation Steps  Adjust fees after position health check: accrue fees only on a remaining part of position that is available after taking debt into account.  Now: ``` uint _feeAmount = _userNotional.mulUp(mothership.fee());  uint _userValueAdjusted = _userNotional - _feeAmount; if (_userValueAdjusted > _userDebt) _userValueAdjusted -= _userDebt; else _userValueAdjusted = 0; ```  To be: ``` uint _feeAmount = _userNotional.mulUp(mothership.fee());  uint _userValueAdjusted = _userNotional - _feeAmount; if (_userValueAdjusted > _userDebt) {  _userValueAdjusted -= _userDebt; } else {  _userValueAdjusted = 0;  _feeAmount = _userNotional > _userDebt ? _userNotional - _userDebt : 0; } ```   "}, {"title": "_rewardsTo not empty", "html_url": "https://github.com/code-423n4/2021-11-overlay-findings/issues/133", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-11-overlay-findings", "body": "_rewardsTo not empty"}, {"title": "Cached version of ovl may be outdated", "html_url": "https://github.com/code-423n4/2021-11-overlay-findings/issues/129", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed"], "target": "2021-11-overlay-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact contract OverlayV1OVLCollateral and OverlayV1Governance cache ovl address: ```solidity  IOverlayTokenNew immutable public ovl; ``` This variable is initialized in the constructor and fetched from the mothership contract: ```solidity   mothership = IOverlayV1Mothership(_mothership);   ovl = IOverlayV1Mothership(_mothership).ovl(); ``` ovl is declared as immutable and later contract interacts with this cached version. However, mothership contains a setter function, so the governor can point it to a new address: ```solidity function setOVL (address _ovl) external onlyGovernor {     ovl = _ovl; } ```  OverlayV1OVLCollateral and OverlayV1Governance will still use this old cached value.  ## Recommended Mitigation Steps Consider if this was intended, or you want to remove this cached version and always fetch on the go (this will increase the gas costs though).  "}, {"title": "OZ ERC1155Supply vulnerability", "html_url": "https://github.com/code-423n4/2021-11-overlay-findings/issues/127", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-11-overlay-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact Overlay uses OZ contracts version 4.3.2: ```yaml   dependencies:     - OpenZeppelin/openzeppelin-contracts@4.3.2 ``` and has a contract that inherits from ERC1155Supply: ```solidity   contract OverlayV1OVLCollateral is ERC1155Supply ``` This version has a recently discovered vulnerability: https://github.com/OpenZeppelin/openzeppelin-contracts/security/advisories/GHSA-wmpv-c2jp-j2xg  In your case, function unwind relies on totalSupply when calculating _userNotional, _userDebt, _userCost, and _userOi, so a malicious actor can exploit this vulnerability by first calling 'build' and then on callback 'unwind' in the same transaction before the total supply is updated.  ## Recommended Mitigation Steps Consider updating to a patched version of 4.3.3.  "}, {"title": "Pack structs tightly", "html_url": "https://github.com/code-423n4/2021-11-overlay-findings/issues/126", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-11-overlay-findings", "body": "Pack structs tightly"}, {"title": "Eliminate subtraction", "html_url": "https://github.com/code-423n4/2021-11-overlay-findings/issues/125", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-11-overlay-findings", "body": "Eliminate subtraction"}, {"title": "Eliminate duplicate math operations", "html_url": "https://github.com/code-423n4/2021-11-overlay-findings/issues/124", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-11-overlay-findings", "body": "Eliminate duplicate math operations"}, {"title": "Cache storage access", "html_url": "https://github.com/code-423n4/2021-11-overlay-findings/issues/123", "labels": ["bug", "G (Gas Optimization)", "sponsor disputed"], "target": "2021-11-overlay-findings", "body": "Cache storage access"}, {"title": "Dead code", "html_url": "https://github.com/code-423n4/2021-11-overlay-findings/issues/122", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-11-overlay-findings", "body": "Dead code"}, {"title": "Timelock and events for governor functions", "html_url": "https://github.com/code-423n4/2021-11-overlay-findings/issues/120", "labels": ["bug", "2 (Med Risk)"], "target": "2021-11-overlay-findings", "body": "Timelock and events for governor functions"}, {"title": "Discrepancies between the interface and implementation", "html_url": "https://github.com/code-423n4/2021-11-overlay-findings/issues/119", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-11-overlay-findings", "body": "Discrepancies between the interface and implementation"}, {"title": "Context and msg.sender", "html_url": "https://github.com/code-423n4/2021-11-overlay-findings/issues/118", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-overlay-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact Contract Transmuter inherits a functionality of the Context contract of OpenZeppelin: ```solidity   contract Transmuter is Context ``` https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Context.sol Context is designed to be used with Ethereum Gas Station Network (GSN), thus it encourages to use _msgSender() instead of msg.sender.  ## Recommended Mitigation Steps Consider replacing msg.sender with _msgSender() or getting rid of Context inheritance to save some gas if you don't actually need it.   "}, {"title": "Open TODOs in Codebase", "html_url": "https://github.com/code-423n4/2021-11-overlay-findings/issues/116", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-overlay-findings", "body": "Open TODOs in Codebase"}, {"title": "`> 0` can be replaced with `!= 0` for gas optimization", "html_url": "https://github.com/code-423n4/2021-11-overlay-findings/issues/113", "labels": ["bug", "G (Gas Optimization)", "sponsor disputed"], "target": "2021-11-overlay-findings", "body": "`> 0` can be replaced with `!= 0` for gas optimization"}, {"title": "Use of constant keccak variables results in extra hashing (and so gas).", "html_url": "https://github.com/code-423n4/2021-11-overlay-findings/issues/111", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-11-overlay-findings", "body": "Use of constant keccak variables results in extra hashing (and so gas)."}, {"title": "At `OverlayV1Comptroller.sol`, `_roller.time` shouldn't be cached", "html_url": "https://github.com/code-423n4/2021-11-overlay-findings/issues/105", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-11-overlay-findings", "body": "At `OverlayV1Comptroller.sol`, `_roller.time` shouldn't be cached"}, {"title": "State variables can be `immutable`s", "html_url": "https://github.com/code-423n4/2021-11-overlay-findings/issues/95", "labels": ["bug", "G (Gas Optimization)", "sponsor disputed"], "target": "2021-11-overlay-findings", "body": "State variables can be `immutable`s"}, {"title": " approve function is vulnerable", "html_url": "https://github.com/code-423n4/2021-11-overlay-findings/issues/94", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-11-overlay-findings", "body": " approve function is vulnerable"}, {"title": " require should come first", "html_url": "https://github.com/code-423n4/2021-11-overlay-findings/issues/93", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-11-overlay-findings", "body": " require should come first"}, {"title": "Unnecessary castings in `OverlayV1UniswapV3Market.fetchPricePoint()`", "html_url": "https://github.com/code-423n4/2021-11-overlay-findings/issues/91", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-11-overlay-findings", "body": "Unnecessary castings in `OverlayV1UniswapV3Market.fetchPricePoint()`"}, {"title": "Cache storage variables in the stack can save gas", "html_url": "https://github.com/code-423n4/2021-11-overlay-findings/issues/88", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-11-overlay-findings", "body": "Cache storage variables in the stack can save gas"}, {"title": "`OverlayV1Market.sol#lock()` Switching between 1, 2 instead of 0, 1 is more gas efficient", "html_url": "https://github.com/code-423n4/2021-11-overlay-findings/issues/86", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-11-overlay-findings", "body": "`OverlayV1Market.sol#lock()` Switching between 1, 2 instead of 0, 1 is more gas efficient"}, {"title": "Change unnecessary storage variables to constants can save gas", "html_url": "https://github.com/code-423n4/2021-11-overlay-findings/issues/85", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-overlay-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-overlay/blob/1833b792caf3eb8756b1ba5f50f9c2ce085e54d0/contracts/OverlayV1UniswapV3Market.sol#L14-L14  ```solidity=14 uint256 internal X96 = 0x1000000000000000000000000; ```  Some storage variables include `X96` will not never be changed and they should not be.  Changing them to `constant` can save gas.  "}, {"title": "Missing setter function for `OverlayV1Mothership#marginBurnRate`", "html_url": "https://github.com/code-423n4/2021-11-overlay-findings/issues/84", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-overlay-findings", "body": "# Handle  WatchPug   # Vulnerability details  Based on the context, `marginBurnRate` should be able to be updated after deployment. However, there is no function to update it.  ### Recommendation  Change to:  https://github.com/code-423n4/2021-11-overlay/blob/1833b792caf3eb8756b1ba5f50f9c2ce085e54d0/contracts/mothership/OverlayV1Mothership.sol#L158-L166  ```solidity=158 function adjustGlobalParams(     uint16 _fee,     uint16 _feeBurnRate,     address _feeTo,     uint _marginBurnRate ) external onlyGovernor {     fee = _fee;     feeBurnRate = _feeBurnRate;     feeTo = _feeTo;     marginBurnRate = _marginBurnRate; } ```  Or change `marginBurnRate` to immutable if it's not supposed to be updated later (for gas saving).  "}, {"title": "`OverlayV1UniswapV3Market` computes wrong market liquidity", "html_url": "https://github.com/code-423n4/2021-11-overlay-findings/issues/83", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-11-overlay-findings", "body": "# Handle  cmichel   # Vulnerability details  The `OverlayV1UniswapV3Market.fetchPricePoint` tries to compute the market depth in OVL terms as `marketLiquidity (in ETH) / ovlPrice (in ETH per OVL)`. To get the market liquidity _in ETH_ (and not the other token pair), it uses the `ethIs0` boolean.  ```solidity _marketLiquidity = ethIs0     ? ( uint256(_liquidity) << 96 ) / _sqrtPrice     : FullMath.mulDiv(uint256(_liquidity), _sqrtPrice, X96); ```  However, `ethIs0` boolean refers to the `ovlFeed`, whereas the `_liquidity` refers to the `marketFeed`, and therefore the `ethIs0` boolean has nothing to do with the _market_ feed where the liquidity is taken from:  ```solidity // in constructor, if token0 is eth refers to ovlFeed ethIs0 = IUniswapV3Pool(_ovlFeed).token0() == _eth;  // in fetchPricePoint, _liquidity comes from different market feed ( _ticks, _liqs ) = IUniswapV3Pool(marketFeed).observe(_secondsAgo); _marketLiquidity = ethIs0     ? ( uint256(_liquidity) << 96 ) / _sqrtPrice     : FullMath.mulDiv(uint256(_liquidity), _sqrtPrice, X96); ```  ## Impact If the `ovlFeed` and `marketFeed` do not have the same token position for the ETH pair (ETH is either token 0 or token 1 for **both** pairs), then the market liquidity & depth is computed wrong (inverted). For example, the `OverlayV1Market.depth()` function will return a wrong depth which is used in the market cap computation.  ## Recommended Mitigation Steps It seems that `marketFeed.token0() == WETH` should be used in `fetchPricePoint` to compute the liquidity instead of `ovlFeed.token0() == WETH`.   "}, {"title": "Missing `macroWindow > microWindow` check", "html_url": "https://github.com/code-423n4/2021-11-overlay-findings/issues/80", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-overlay-findings", "body": "# Handle  cmichel   # Vulnerability details  The `OverlayV1UniswapV3Market.constructor` does not verify that the `marcoWindow > microWindow` but the code implicitly uses this assumption when computing the TWAPs.  ## Recommended Mitigation Steps Validate that `macroWindow > microWindow` in the constructor.   "}, {"title": "`OverlayV1UniswapV3Market` assumes one of the tokens is ETH", "html_url": "https://github.com/code-423n4/2021-11-overlay-findings/issues/79", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-overlay-findings", "body": "# Handle  cmichel   # Vulnerability details  The `OverlayV1UniswapV3Market` contract assumes that one of the tokens of `_ovlFeed` is ETH but does not check it in the constructor:  ```solidity constructor(     address _mothership,     address _ovlFeed,     address _marketFeed,     address _quote,     address _eth,     uint128 _baseAmount,     uint256 _macroWindow,     uint256 _microWindow,     uint256 _priceFrameCap ) OverlayV1Market (     _mothership ) OverlayV1Comptroller (     _microWindow ) OverlayV1OI (     _microWindow ) OverlayV1PricePoint (     _priceFrameCap ) {      // immutables     eth = _eth;     // could be that token1 is not ETH either     ethIs0 = IUniswapV3Pool(_ovlFeed).token0() == _eth;     // ... } ```  ## Impact If `token0` is _not_ ETH, then it assumes `token1` is ETH but never validates this assumption. This could lead to wrong market liquidity and prices calculations if an `_ovlFeed` is supplied that is not actually the OVL/ETH feed.  ## Recommended Mitigation Steps Check that `(token0 == OVL && token1 == WETH) || (token1 == OVL && token0 == WETH)` for `_ovlFeed`.  "}, {"title": "Use _userOiShares everywhere in unwind()", "html_url": "https://github.com/code-423n4/2021-11-overlay-findings/issues/78", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-overlay-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact In the function unwind() of OverlayV1OVLCollateral.sol a tmp variable _userOiShares is used the store the value of _shares. However _shares is still uses multiple times in the function.  Using _userOiShares everywhere would save gas.  ## Proof of Concept https://github.com/code-423n4/2021-11-overlay/blob/914bed22f190ebe7088194453bab08c424c3f70c/contracts/collateral/OverlayV1OVLCollateral.sol#L273-L336  ```JS  function unwind (  uint256 _positionId,  uint256 _shares ) external {         require( 0 < _shares && _shares <= balanceOf(msg.sender, _positionId), \"OVLV1:!shares\");    // uses _shares         ...         uint _userOiShares = _shares; // move to start of the function         uint _userNotional = _shares * pos.notional(_oi, _oiShares, _priceFrame) / _totalPosShares;    // uses _shares         uint _userDebt = _shares * pos.debt / _totalPosShares;                                                          // uses _shares         uint _userCost = _shares * pos.cost / _totalPosShares;                                                           // uses _shares         uint _userOi = _shares * pos.oi(_oi, _oiShares) / _totalPosShares;                                          // uses _shares ...         _burn(msg.sender, _positionId, _shares);   // uses _shares ```  ## Tools Used  ## Recommended Mitigation Steps Move \"uint _userOiShares = _shares;\" to the start of function unwind() Replace all other instances of \"_shares\" with \"_userOiShares\"    "}, {"title": "Improper Upper Bound Definition on the Fee", "html_url": "https://github.com/code-423n4/2021-11-overlay-findings/issues/77", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-11-overlay-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-biconomy/blob/db8a1fdddd02e8cc209a4c73ffbb3de210e4a81a/contracts/hyphen/token/TokenManager.sol#L51 https://github.com/code-423n4/2022-03-biconomy/blob/db8a1fdddd02e8cc209a4c73ffbb3de210e4a81a/contracts/hyphen/token/TokenManager.sol#L52   # Vulnerability details  ## Impact  The **equilibriumFee** and **maxFee** does not have any upper or lower bounds. Values that are too large will lead to reversions in several critical functions or the LP user will lost all funds when paying the fee.  ## Proof of Concept  1. Navigate to the following contract.  https://github.com/code-423n4/2022-03-biconomy/blob/db8a1fdddd02e8cc209a4c73ffbb3de210e4a81a/contracts/hyphen/token/TokenManager.sol#L52  2. Owner can identify fee amount. That directly affect to LP management. (https://github.com/code-423n4/2022-03-biconomy/blob/db8a1fdddd02e8cc209a4c73ffbb3de210e4a81a/contracts/hyphen/LiquidityPool.sol#L352)  3. Here you can see there is no upper bound has been defined.   ```     function changeFee(         address tokenAddress,         uint256 _equilibriumFee,         uint256 _maxFee     ) external override onlyOwner whenNotPaused {         require(_equilibriumFee != 0, \"Equilibrium Fee cannot be 0\");         require(_maxFee != 0, \"Max Fee cannot be 0\");         tokensInfo[tokenAddress].equilibriumFee = _equilibriumFee;         tokensInfo[tokenAddress].maxFee = _maxFee;         emit FeeChanged(tokenAddress, tokensInfo[tokenAddress].equilibriumFee, tokensInfo[tokenAddress].maxFee);     }  ```  ## Tools Used  Code Review  ## Recommended Mitigation Steps  Consider defining upper and lower bounds on the **equilibriumFee** and **maxFee**.  "}, {"title": "Check for liquidation in value() ", "html_url": "https://github.com/code-423n4/2021-11-overlay-findings/issues/76", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-overlay-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The function value() of OverlayV1OVLCollateral.sol doesn't explicitly check for liquidated positions. However because oiShares and debt are set to 0 during liquidation the resulting value will still be 0.  It seems more logical to check for liquidation in the beginning of the function and immediately return 0. This saves gas for the situation where the function value() is called from another smart contract.  ## Proof of Concept  https://github.com/code-423n4/2021-11-overlay/blob/914bed22f190ebe7088194453bab08c424c3f70c/contracts/collateral/OverlayV1OVLCollateral.sol#L424-L448 ``` function value (  uint _positionId ) public view returns ( uint256 value_) {         Position.Info storage pos = positions[_positionId];         IOverlayV1Market _market = IOverlayV1Market(pos.market);         (   uint _oi,  uint _oiShares,   uint _priceFrame ) = _market.positionInfo( pos.isLong, pos.pricePoint );         value_ = pos.value(  _oi, _oiShares,  _priceFrame ); } ```   ## Tools Used  ## Recommended Mitigation Steps Add something like the following to function value(): ```JS         if (pos.oiShares == 0) return 0; // liquidated ```    "}, {"title": "Avoiding external calls can save gas", "html_url": "https://github.com/code-423n4/2021-11-overlay-findings/issues/74", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-overlay-findings", "body": "# Handle  WatchPug   # Vulnerability details  Every call to an external contract costs a decent amount of gas. In `OverlayV1OVLCollateral.sol`, `mothership.fee()` can be cached as a storage variable and save ~21000 gas each time.  https://github.com/code-423n4/2021-11-overlay/blob/1833b792caf3eb8756b1ba5f50f9c2ce085e54d0/contracts/collateral/OverlayV1OVLCollateral.sol#L305-L305  ```solidity=305 uint _feeAmount = _userNotional.mulUp(mothership.fee()); ```  ## Recommendation  - Add a storage variable in `OverlayV1OVLCollateral.sol`; - Add a function `updateFee()` - Call `updateFee()` after `OverlayV1Mothership.sol#adjustGlobalParams()`  "}, {"title": "`OverlayToken.sol` Insufficient input validation", "html_url": "https://github.com/code-423n4/2021-11-overlay-findings/issues/73", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-11-overlay-findings", "body": "`OverlayToken.sol` Insufficient input validation"}, {"title": "No user friendly error message when _leverage==0", "html_url": "https://github.com/code-423n4/2021-11-overlay-findings/issues/71", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-overlay-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact Suppose you try to build a position and have set the _leverage accidentally to 0  (which can be done if you call the smart contract directly). Then the function build() will call enterOI() which will revert when trying to calculate debtAdjusted_ .  However no user friendly error message is given.  ## Proof of Concept https://github.com/code-423n4/2021-11-overlay/blob/914bed22f190ebe7088194453bab08c424c3f70c/contracts/market/OverlayV1Market.sol ```JS function enterOI ( bool _isLong,  uint _collateral,  uint _leverage ) external onlyCollateral returns (...) {  ...         collateralAdjusted_ = _collateral - _impact - fee_;       // will be > 0         oiAdjusted_ = collateralAdjusted_ * _leverage;            // if _leverage==0 then oiAdjusted_  == 0         debtAdjusted_ = oiAdjusted_ - collateralAdjusted_;   // will be negative and thus will revert ```     ## Tools Used  ## Recommended Mitigation Steps Add something like the following to the function build() require(_leverage != 0, \"OVLV1:leverage==0\")  "}, {"title": "Use _brrrrdExpected everywhere in oiCap() ", "html_url": "https://github.com/code-423n4/2021-11-overlay-findings/issues/69", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-overlay-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The function oiCap() of OverlayV1Comptroller.sol save the value of brrrrdExpected in a tmp variable _brrrrdExpected. Lateron brrrrdExpected is still used while _brrrrdExpected could also be used. This saves a bit of gas.  ## Proof of Concept https://github.com/code-423n4/2021-11-overlay/blob/914bed22f190ebe7088194453bab08c424c3f70c/contracts/market/OverlayV1Comptroller.sol#L255-L279  ```JS  function oiCap() public virtual view returns (  uint cap_ ) {     ...         uint _brrrrdExpected = brrrrdExpected;     ...         cap_ = _surpassed ? 0 : _burnt || _expected             ? _oiCap(false, depth(), staticCap, 0, 0)             : _oiCap(true, depth(), staticCap, _brrrrd, brrrrdExpected);  // can also use _brrrrdExpected  ``` ## Tools Used  ## Recommended Mitigation Steps Replace ```JS      : _oiCap(true, depth(), staticCap, _brrrrd, brrrrdExpected); ``` with ```JS      : _oiCap(true, depth(), staticCap, _brrrrd, _brrrrdExpected); ```  "}, {"title": "Simplify function roll()", "html_url": "https://github.com/code-423n4/2021-11-overlay-findings/issues/68", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-overlay-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The function roll() of OverlayV1Comptroller.sol can be simplified. This saves some gas and also makes the function easier to read.  See below at \"Recommended Mitigation Steps\"  ## Proof of Concept https://github.com/code-423n4/2021-11-overlay/blob/914bed22f190ebe7088194453bab08c424c3f70c/contracts/market/OverlayV1Comptroller.sol#L352-L385 ```JS function roll( Roller[60] storage rollers, Roller memory _roller, uint _lastMoment, uint _cycloid ) internal returns ( uint cycloid_) {         if (_roller.time != _lastMoment) {             _cycloid += 1;             if (_cycloid < CHORD) {                 rollers[_cycloid] = _roller;             } else {                 _cycloid = 0;                 rollers[_cycloid] = _roller;             }         } else {             rollers[_cycloid] = _roller;         }         cycloid_ = _cycloid;     } ```  ## Tools Used  ## Recommended Mitigation Steps Change the function to: ```JS     function roll (Roller[60] storage rollers,Roller memory _roller,uint _lastMoment,uint _cycloid) internal returns (uint cycloid_) {         if (_roller.time != _lastMoment)               _cycloid = (_cycloid + 1) % CHORD;                                       rollers[_cycloid] = _roller;         cycloid_ = _cycloid;     } ```    "}, {"title": "`OverlayToken.sol` Check of allowance can be done earlier to save gas", "html_url": "https://github.com/code-423n4/2021-11-overlay-findings/issues/66", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-overlay-findings", "body": "# Handle  WatchPug   # Vulnerability details  Check of allowance can be done earlier to save some gas for failure transactions.  https://github.com/code-423n4/2021-11-overlay/blob/1833b792caf3eb8756b1ba5f50f9c2ce085e54d0/contracts/ovl/OverlayToken.sol#L118-L137  ```solidity=119 function transferFrom(     address sender,     address recipient,     uint256 amount ) public virtual override returns (     bool success_ ) {      _transfer(sender, recipient, amount);      uint256 currentAllowance = _allowances[sender][_msgSender()];      require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");      unchecked { _approve(sender, _msgSender(), currentAllowance - amount); }      success_ = true;  } ```  https://github.com/code-423n4/2021-11-overlay/blob/1833b792caf3eb8756b1ba5f50f9c2ce085e54d0/contracts/ovl/OverlayToken.sol#L167-L186 ```solidity=167 function transferFromBurn(     address sender,     address recipient,     uint256 amount,     uint256 burnt ) public override onlyBurner returns (     bool success ) {      _transferBurn(sender, recipient, amount, burnt);      uint256 currentAllowance = _allowances[sender][msg.sender];      require(currentAllowance >= amount + burnt, \"OVL:allowance<amount+burnt\");      unchecked { _approve(sender, msg.sender, currentAllowance - amount - burnt); }      success = true;  } ```  https://github.com/code-423n4/2021-11-overlay/blob/1833b792caf3eb8756b1ba5f50f9c2ce085e54d0/contracts/ovl/OverlayToken.sol#L241-L260 ```solidity=241 function transferFromMint(     address sender,     address recipient,     uint256 amount,     uint256 minted ) public override onlyMinter returns (     bool ) {      _transferMint(sender, recipient, amount, minted);      uint256 currentAllowance = _allowances[sender][msg.sender];      require(currentAllowance >= amount, \"OVL:allowance<amount\");      unchecked { _approve(sender, msg.sender, currentAllowance - amount); }      return true;  } ```  "}, {"title": "Use short reason strings can save gas", "html_url": "https://github.com/code-423n4/2021-11-overlay-findings/issues/65", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-11-overlay-findings", "body": "# Handle  WatchPug   # Vulnerability details  Every reason string takes at least 32 bytes.  Use short reason strings that fits in 32 bytes or it will become more expensive.  Instances include:  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/base/ERC721.sol#L55-L58  ```solidity require(     owner == msg.sender || isApprovedForAll[owner][msg.sender],     'ERC721 :: approve : Approve caller is not owner nor approved for all' ); ```  https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/base/ERC721.sol#L96-L99  ```solidity require(     _checkOnERC721Received(address(0), to, id, ''),     'ERC721 :: _safeMint : Transfer to non ERC721Receiver implementer' ); ```  "}, {"title": "Missing events for critical operations", "html_url": "https://github.com/code-423n4/2021-11-overlay-findings/issues/64", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor confirmed"], "target": "2021-11-overlay-findings", "body": "# Handle  WatchPug   # Vulnerability details  Across the contracts, there are certain critical operations that change critical values that affect the users of the protocol.  It's a best practice for these setter functions to emit events to record these changes on-chain for off-chain monitors/tools/interfaces to register the updates and react if necessary.  Instances include:  https://github.com/Badger-Finance/ibbtc/blob/d8b95e8d145eb196ba20033267a9ba43a17be02c/contracts/Zap.sol#L322-L324 ```solidity=322 function setGovernance(address _governance) external onlyGovernance {     _setGovernance(_governance); } ```  https://github.com/Badger-Finance/ibbtc/blob/d8b95e8d145eb196ba20033267a9ba43a17be02c/contracts/Zap.sol#L331-L333 ```solidity=331 function approveContractAccess(address account) external onlyGovernance {     _approveContractAccess(account); } ```  https://github.com/Badger-Finance/ibbtc/blob/d8b95e8d145eb196ba20033267a9ba43a17be02c/contracts/Zap.sol#L335-L337 ```solidity=335 function revokeContractAccess(address account) external onlyGovernance {     _revokeContractAccess(account); } ```   https://github.com/Badger-Finance/badger-ibbtc-utility-zaps/blob/6f700995129182fec81b772f97abab9977b46026/contracts/IbbtcVaultZap.sol#L116-L119 ```solidity=116 function setGuardian(address _guardian) external {     _onlyGovernance();     governance = _guardian; } ```   https://github.com/Badger-Finance/badger-ibbtc-utility-zaps/blob/6f700995129182fec81b772f97abab9977b46026/contracts/IbbtcVaultZap.sol#L121-L124 ```solidity=121 function setGovernance(address _governance) external {     _onlyGovernance();     governance = _governance; } ```    https://github.com/Badger-Finance/badger-ibbtc-utility-zaps/blob/a5c71b72222d84b6414ca0339ed1761dc79fe56e/contracts/SettToRenIbbtcZap.sol#L130-L133 ```solidity=130 function setGuardian(address _guardian) external {     _onlyGovernance();     governance = _guardian; } ```  https://github.com/Badger-Finance/badger-ibbtc-utility-zaps/blob/a5c71b72222d84b6414ca0339ed1761dc79fe56e/contracts/SettToRenIbbtcZap.sol#L135-L138 ```solidity=135 function setGovernance(address _governance) external {     _onlyGovernance();     governance = _governance; } ```   "}, {"title": "contract OverlayV1OI isn't abstract", "html_url": "https://github.com/code-423n4/2021-11-overlay-findings/issues/62", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-11-overlay-findings", "body": "contract OverlayV1OI isn't abstract"}, {"title": "Use `transferBurn` can save gas", "html_url": "https://github.com/code-423n4/2021-11-overlay-findings/issues/61", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-11-overlay-findings", "body": "Use `transferBurn` can save gas"}, {"title": "Redundant code", "html_url": "https://github.com/code-423n4/2021-11-overlay-findings/issues/60", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-11-overlay-findings", "body": "Redundant code"}, {"title": "_totalSupply not updated in _transferMint() and _transferBurn() ", "html_url": "https://github.com/code-423n4/2021-11-overlay-findings/issues/59", "labels": ["bug", "question", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-11-overlay-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The functions _transferMint() and _transferBurn() of OverlayToken.sol don't update _totalSupply. Whereas the similar functions _mint() and _burn() do update _totalSupply.  This means that _totalSupply and totalSupply() will not show a realistic view of the total OVL tokens.  For the protocol itself it isn't such a problem because this value isn't used in the protocol (as far as I can see). But other protocols building on Overlay may use it, as well as user interfaces and analytic platforms.  ## Proof of Concept https://github.com/code-423n4/2021-11-overlay/blob/914bed22f190ebe7088194453bab08c424c3f70c/contracts/ovl/OverlayToken.sol#L349-L364 ```JS function _mint( address account, uint256 amount) internal virtual {    ...       _totalSupply += amount;  https://github.com/code-423n4/2021-11-overlay/blob/914bed22f190ebe7088194453bab08c424c3f70c/contracts/ovl/OverlayToken.sol#L376-L395 ```JS function _burn(address account, uint256 amount) internal virtual {    ...         _totalSupply -= amount;  https://github.com/code-423n4/2021-11-overlay/blob/914bed22f190ebe7088194453bab08c424c3f70c/contracts/ovl/OverlayToken.sol#L194-L212  https://github.com/code-423n4/2021-11-overlay/blob/914bed22f190ebe7088194453bab08c424c3f70c/contracts/ovl/OverlayToken.sol#L268-L286  ## Tools Used  ## Recommended Mitigation Steps Update _totalSupply  in _transferMint() and _transferBurn()   "}, {"title": "Adding unchecked directive can save gas", "html_url": "https://github.com/code-423n4/2021-11-overlay-findings/issues/56", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-11-overlay-findings", "body": "Adding unchecked directive can save gas"}, {"title": "Can't enableCollateral after a disableCollateral ", "html_url": "https://github.com/code-423n4/2021-11-overlay-findings/issues/55", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-11-overlay-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The function disableCollateral of OverlayV1Mothership.sol doesn't set collateralActive[_collateral] = false; But it does revoke the roles.  Now enableCollateral  can never be used because collateralActive[_collateral] ==true  and it will never pass the second require. So you can never grant the roles again.  Note: enableCollateral also doesn't set collateralActive[_collateral] = true  ## Proof of Concept https://github.com/code-423n4/2021-11-overlay/blob/914bed22f190ebe7088194453bab08c424c3f70c/contracts/mothership/OverlayV1Mothership.sol#L133-L153  ```JS  function enableCollateral (address _collateral) external onlyGovernor {         require(collateralExists[_collateral], \"OVLV1:!exists\");         require(!collateralActive[_collateral], \"OVLV1:!disabled\");         OverlayToken(ovl).grantRole(OverlayToken(ovl).MINTER_ROLE(), _collateral);         OverlayToken(ovl).grantRole(OverlayToken(ovl).BURNER_ROLE(), _collateral);     }      function disableCollateral (address _collateral) external onlyGovernor {         require(collateralActive[_collateral], \"OVLV1:!enabled\");         OverlayToken(ovl).revokeRole(OverlayToken(ovl).MINTER_ROLE(), _collateral);         OverlayToken(ovl).revokeRole(OverlayToken(ovl).BURNER_ROLE(), _collateral);     } ```  ## Tools Used  ## Recommended Mitigation Steps In function enableCollateral() add the following (after the require): collateralActive[_collateral] = true;  In function disableCollateral add the following (after the require): collateralActive[_collateral] = false;  "}, {"title": "pow() is missing check on input parameters with 0 value", "html_url": "https://github.com/code-423n4/2021-11-overlay-findings/issues/54", "labels": ["bug", "2 (Med Risk)", "sponsor disputed"], "target": "2021-11-overlay-findings", "body": "pow() is missing check on input parameters with 0 value"}, {"title": "isUnderwater returns opposite boolean for short positions", "html_url": "https://github.com/code-423n4/2021-11-overlay-findings/issues/53", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed"], "target": "2021-11-overlay-findings", "body": "# Handle  harleythedog   # Vulnerability details  ## Impact The function isUnderwater should return true iff the position value is < 0. In the case of a short position, this is when oi * (2 - priceFrame) - debt < 0 (based on the logic given in the _value function). Rearranging this equation, a short position is underwater iff oi * 2 < oi * priceFrame + debt. However, in the function _isUnderwater in Position.sol, the left and right side of this equation is flipped, meaning that the function will return the opposite of what it should when called on short positions.  Fortunately, the V1 implementation of OverlayOVLCollateral does not directly use the isUnderwater function in major control flow changes. However, line 304 of OverlayV1OVLCollateral.sol is a comment that says:  // TODO: think through edge case of underwater position ... and fee adjustments ...  which hints that this function is going to be used to deal with underwater positions. As a result, this issue would have a huge impact if not properly dealt with.  ## Proof of Concept See code for _isUnderwater here: https://github.com/code-423n4/2021-11-overlay/blob/1833b792caf3eb8756b1ba5f50f9c2ce085e54d0/contracts/libraries/Position.sol#L70  Notice that for short positions the inequality is flipped from what it should be (indeed, when self.debt is higher it is more likely that isUnder will be false, which is obviously incorrect).  Also, see the TODO comment here that shows isUndewater is important: https://github.com/code-423n4/2021-11-overlay/blob/1833b792caf3eb8756b1ba5f50f9c2ce085e54d0/contracts/collateral/OverlayV1OVLCollateral.sol#L304   ## Tools Used Inspection  ## Recommended Mitigation Steps Flip the left and right side of the inequality for short positions in _isUnderwater.  "}, {"title": "Commented out code (no explanation) ", "html_url": "https://github.com/code-423n4/2021-11-overlay-findings/issues/51", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-overlay-findings", "body": "# Handle  ye0lde   # Vulnerability details  ## Impact Code clarity  ## Proof of Concept  https://github.com/code-423n4/2021-11-overlay/blob/1833b792caf3eb8756b1ba5f50f9c2ce085e54d0/contracts/collateral/OverlayV1OVLCollateral.sol#L261 https://github.com/code-423n4/2021-11-overlay/blob/1833b792caf3eb8756b1ba5f50f9c2ce085e54d0/contracts/collateral/OverlayV1OVLCollateral.sol#L317  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps I suggest removing the commented-out code or adding an explanation.  "}, {"title": "Typos ", "html_url": "https://github.com/code-423n4/2021-11-overlay-findings/issues/50", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-11-overlay-findings", "body": "Typos "}, {"title": "Incorrect comments ", "html_url": "https://github.com/code-423n4/2021-11-overlay-findings/issues/49", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-overlay-findings", "body": "# Handle  ye0lde   # Vulnerability details  ## Impact Code clarity  ## Proof of Concept  \"@param\" should be \"@return\" https://github.com/code-423n4/2021-11-overlay/blob/1833b792caf3eb8756b1ba5f50f9c2ce085e54d0/contracts/market/OverlayV1Market.sol#L83-L85  Not sure what this comment is for maybe just needs to be deleted. https://github.com/code-423n4/2021-11-overlay/blob/1833b792caf3eb8756b1ba5f50f9c2ce085e54d0/contracts/mothership/OverlayV1Mothership.sol#L155  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps Correct the comments if the suggestions are valid.  "}, {"title": "All overflow/underflow checks are automatic in Solidity 0.8", "html_url": "https://github.com/code-423n4/2021-11-overlay-findings/issues/48", "labels": ["bug", "G (Gas Optimization)", "sponsor disputed"], "target": "2021-11-overlay-findings", "body": "All overflow/underflow checks are automatic in Solidity 0.8"}, {"title": "Unneeded variable and code in enterOI (OverlayV1Market.sol)", "html_url": "https://github.com/code-423n4/2021-11-overlay-findings/issues/44", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-11-overlay-findings", "body": "Unneeded variable and code in enterOI (OverlayV1Market.sol)"}, {"title": "Unused Named Returns", "html_url": "https://github.com/code-423n4/2021-11-overlay-findings/issues/43", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-11-overlay-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact Removing unused named return variables can reduce gas usage and improve code clarity.  ## Proof of Concept In `TimeswapPair:constantProduct()`, you return using both named return and actual return statement. To save gas and improve code quality consider using only one of those.  ```     /// @inheritdoc IPair     function constantProduct(uint256 maturity)         external         view         override         returns (             uint112 x,             uint112 y,             uint112 z         )     {         State memory state = pools[maturity].state;         return (state.x, state.y, state.z);     } ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Remove the unused named returns  "}, {"title": "Use msg.sender Rather Than _msgSender() to Save Gas", "html_url": "https://github.com/code-423n4/2021-11-overlay-findings/issues/38", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-overlay-findings", "body": "Use msg.sender Rather Than _msgSender() to Save Gas"}, {"title": "Constructor Lack of Input Validation for _compoundingPeriod", "html_url": "https://github.com/code-423n4/2021-11-overlay-findings/issues/33", "labels": ["bug", "1 (Low Risk)", "sponsor disputed"], "target": "2021-11-overlay-findings", "body": "Constructor Lack of Input Validation for _compoundingPeriod"}, {"title": "Constructor Does Not Check for Zero Addresses", "html_url": "https://github.com/code-423n4/2021-11-overlay-findings/issues/32", "labels": ["bug", "G (Gas Optimization)", "sponsor disputed"], "target": "2021-11-overlay-findings", "body": "Constructor Does Not Check for Zero Addresses"}, {"title": "OverlayV1Market.update function is public function", "html_url": "https://github.com/code-423n4/2021-11-overlay-findings/issues/30", "labels": ["bug", "1 (Low Risk)", "sponsor disputed"], "target": "2021-11-overlay-findings", "body": "OverlayV1Market.update function is public function"}, {"title": "Incorrect position indexing", "html_url": "https://github.com/code-423n4/2021-11-overlay-findings/issues/28", "labels": ["bug", "1 (Low Risk)", "sponsor disputed"], "target": "2021-11-overlay-findings", "body": "Incorrect position indexing"}, {"title": "Incorrect naming issue", "html_url": "https://github.com/code-423n4/2021-11-overlay-findings/issues/26", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-overlay-findings", "body": "# Handle  xYrYuYx   # Vulnerability details  ## Impact https://github.com/code-423n4/2021-11-overlay/blob/main/contracts/OverlayV1UniswapV3Market.sol#L171  _tickToPrice function has underscore even it is public function. Underscore is used to indicate internal or private functions.   ## Tools Used Manual  ## Recommended Mitigation Steps Change function to internal or private, or remove underscore if you want to keep it as public function.  "}, {"title": "Use `external` keyword instead of `public` for some functions", "html_url": "https://github.com/code-423n4/2021-11-overlay-findings/issues/25", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-overlay-findings", "body": "Use `external` keyword instead of `public` for some functions"}, {"title": "_beforeTokenTransfer and _afterTokenTransfer functions are empty", "html_url": "https://github.com/code-423n4/2021-11-overlay-findings/issues/23", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-11-overlay-findings", "body": "_beforeTokenTransfer and _afterTokenTransfer functions are empty"}, {"title": "OverlayToken.burn function could burn tokens of any user", "html_url": "https://github.com/code-423n4/2021-11-overlay-findings/issues/22", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2021-11-overlay-findings", "body": "OverlayToken.burn function could burn tokens of any user"}, {"title": "`OverlayV1PricePoint.sol#pricePoints` can be implemented more efficiently", "html_url": "https://github.com/code-423n4/2021-11-overlay-findings/issues/18", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-11-overlay-findings", "body": "`OverlayV1PricePoint.sol#pricePoints` can be implemented more efficiently"}, {"title": "`_fundingFactor` at `OverlayV1Ol#computeFunding` can be calculated cheaper", "html_url": "https://github.com/code-423n4/2021-11-overlay-findings/issues/17", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-11-overlay-findings", "body": "`_fundingFactor` at `OverlayV1Ol#computeFunding` can be calculated cheaper"}, {"title": "Optimize `OverlayV10l#_oi`", "html_url": "https://github.com/code-423n4/2021-11-overlay-findings/issues/16", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-11-overlay-findings", "body": "Optimize `OverlayV10l#_oi`"}, {"title": "Should add reentrancy guard modifiers ", "html_url": "https://github.com/code-423n4/2021-11-overlay-findings/issues/3", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-11-overlay-findings", "body": "Should add reentrancy guard modifiers "}, {"title": "Improper Validation Of Chainlink `latestRoundData()` Function", "html_url": "https://github.com/code-423n4/2021-11-fairside-findings/issues/106", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged", "sponsor disputed"], "target": "2021-11-fairside-findings", "body": "Improper Validation Of Chainlink `latestRoundData()` Function"}, {"title": "`FSDNetwork.getFSDPrice()` Is Vulnerable To Flash Loan Attacks", "html_url": "https://github.com/code-423n4/2021-11-fairside-findings/issues/105", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged", "sponsor disputed"], "target": "2021-11-fairside-findings", "body": "`FSDNetwork.getFSDPrice()` Is Vulnerable To Flash Loan Attacks"}, {"title": "`TributeAccrual.availableTribute()` & `TributeAccrual.availableGovernanceTribute()` Distributes Tributes Unfairly", "html_url": "https://github.com/code-423n4/2021-11-fairside-findings/issues/104", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor acknowledged", "sponsor disputed"], "target": "2021-11-fairside-findings", "body": "`TributeAccrual.availableTribute()` & `TributeAccrual.availableGovernanceTribute()` Distributes Tributes Unfairly"}, {"title": "Anyone Can Arbitrarily Call `FSDVesting.updateVestedTokens()`", "html_url": "https://github.com/code-423n4/2021-11-fairside-findings/issues/101", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-11-fairside-findings", "body": "# Handle  leastwood   # Vulnerability details  ## Impact  The `updateVestedTokens()` function is intended to be called by the `FSD.sol` contract when updating a user's vested token amount. A check is performed to ensure that `_user == beneficiary`, however, as `_user` is a user controlled argument, it is possible to spoof calls to `updateVestedTokens()` such that anyone can arbitrarily add any amount to the vested contract. Additionally, there is no check to ensure that the call originated from a trusted/whitelisted source.  There are two main reasons as to why the beneficiary or an attacker would want to call this function: - To increase the vested amount such that `calculateVestingClaim()` allows them to withdraw their entire vested amount without waiting the entire duration. - An attacker wishes to block withdrawals from other vested contracts by preventing successful calls to `claimVestedTokens()` by the beneficiary account. This can be done by increasing the vested amount such that `safeTransfer()` calls fail due to insufficient token balance within the contract.  ## Proof of Concept  https://github.com/code-423n4/2021-11-fairside/blob/main/contracts/token/FSDVesting.sol#L147-L161 https://github.com/code-423n4/2021-11-fairside/blob/main/contracts/token/FSDVesting.sol#L100-L115 https://github.com/code-423n4/2021-11-fairside/blob/main/contracts/token/FSDVesting.sol#L125 https://github.com/code-423n4/2021-11-fairside/blob/main/contracts/token/FSDVesting.sol#L134  ## Tools Used  Manual code review. Discussions with dev.  ## Recommended Mitigation Steps  Ensure that the `updateVestedTokens()` function is only callable from the `FSD.sol` contract. This can be done by implementing an `onlyFSD` role.  "}, {"title": "Various typos", "html_url": "https://github.com/code-423n4/2021-11-fairside-findings/issues/99", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-fairside-findings", "body": "# Handle  ye0lde   # Vulnerability details  ## Impact  None/Code clarity  ## Proof of Concept  \"is\" to \"in\"   https://github.com/code-423n4/2021-11-fairside/blob/20c68793f48ee2678508b9d3a1bae917c007b712/contracts/network/FSDNetwork.sol#L347  \"the\" not needed https://github.com/code-423n4/2021-11-fairside/blob/20c68793f48ee2678508b9d3a1bae917c007b712/contracts/timelock/Timelock.sol#L16  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps Correct the typos.  "}, {"title": "Incorrect comment in function rmul (DSMath.sol)", "html_url": "https://github.com/code-423n4/2021-11-fairside-findings/issues/98", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor acknowledged"], "target": "2021-11-fairside-findings", "body": "Incorrect comment in function rmul (DSMath.sol)"}, {"title": "FSD.mintBeta function has potentially blocking condition unrelated with documented logic", "html_url": "https://github.com/code-423n4/2021-11-fairside-findings/issues/96", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-fairside-findings", "body": "# Handle  hyh   # Vulnerability details  ## Impact  As funding pool should be filled with Hatch phase deposits, the phase advance should happen only after it is filled, but when this happen the minting in Beta phase would be frozen by 'fundingPool.balance < 2000 ether' condition. As mintBeta is the only logic for Beta phase the contract will be frozen until phase change.  If there is a setup when Hatch phase advances to Beta before funding pool is filled, mintBeta will work only while it has below 2000 ether, i.e. mintBeta behavior will not be controlled explicitly: anyone can end the Beta phase by sending enough ether directly to funding pool and the contract mint will be frozen until next phase advance.   ## Proof of Concept  'fundingPool.balance < 2000 ether' condition for minting in Beta phase can be blocking as funding pool transfers happen only in mintHatch function during Hatch phase, while subsequent phases do not have any funding pool related logic neither in code, nor in documentation. https://github.com/code-423n4/2021-11-fairside/blob/main/contracts/token/FSD.sol#L204 https://fairside-network.gitbook.io/fairside-network/white-paper/augmented-bonding-curve  ## Recommended Mitigation Steps  Remove 'fundingPool.balance < 2000 ether' condition from mintBeta  "}, {"title": "Possible DOS by 1 of 3 assessors by replay attack", "html_url": "https://github.com/code-423n4/2021-11-fairside-findings/issues/94", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged", "sponsor disputed"], "target": "2021-11-fairside-findings", "body": "Possible DOS by 1 of 3 assessors by replay attack"}, {"title": "Using ++i consumes less gas than i++", "html_url": "https://github.com/code-423n4/2021-11-fairside-findings/issues/89", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-11-fairside-findings", "body": "Using ++i consumes less gas than i++"}, {"title": "Several public functions can be declared as external", "html_url": "https://github.com/code-423n4/2021-11-fairside-findings/issues/88", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-11-fairside-findings", "body": "Several public functions can be declared as external"}, {"title": "does not check the existence of address while using it in low level call", "html_url": "https://github.com/code-423n4/2021-11-fairside-findings/issues/86", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged", "sponsor disputed"], "target": "2021-11-fairside-findings", "body": "does not check the existence of address while using it in low level call"}, {"title": "The function `propose(FairSideDAO.sol)` can be optimized", "html_url": "https://github.com/code-423n4/2021-11-fairside-findings/issues/81", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-11-fairside-findings", "body": "The function `propose(FairSideDAO.sol)` can be optimized"}, {"title": "`_calculateDeltaOfFSD(ABC.sol)` can be optimized", "html_url": "https://github.com/code-423n4/2021-11-fairside-findings/issues/79", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-11-fairside-findings", "body": "`_calculateDeltaOfFSD(ABC.sol)` can be optimized"}, {"title": "Calling require on a tautology", "html_url": "https://github.com/code-423n4/2021-11-fairside-findings/issues/78", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-fairside-findings", "body": "# Handle  0x0x0x   # Vulnerability details  ## Impact Gas optimization  ## Finding ```  contracts/token/FSD.sol:174: require(bonded > 0, \"FSD::mintHatch: Insufficient Deposit\"); ``` On L170, we check whether `bonded` is bigger than 5 ETH. After multiplying with `HATCH_CURVE_RATIO`, it is still over 0. Therefore, it is a tautology and not needed.  ## Proof of Concept Provide direct links to all referenced code in GitHub. Add screenshots, logs, or any other relevant proof that illustrates the concept.  ## Tools Used  Manual analysis  "}, {"title": "`!= 0` costs less gass compared to ` > 0` for unsigned integer", "html_url": "https://github.com/code-423n4/2021-11-fairside-findings/issues/77", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-11-fairside-findings", "body": "`!= 0` costs less gass compared to ` > 0` for unsigned integer"}, {"title": "Gas: Reorder conditions in `claimGovernanceTribute`", "html_url": "https://github.com/code-423n4/2021-11-fairside-findings/issues/76", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-fairside-findings", "body": "# Handle  cmichel   # Vulnerability details  The `FSD.claimGovernanceTribute` function first performs the expensive `getPriorConvictionScore` instead of the cheap `isGovernance[msg.sender]` check.  ```solidity function claimGovernanceTribute(uint256 num) external {     require(         governanceThreshold <=             getPriorConvictionScore(                 msg.sender,                 governanceTributes[num].blockNumber             ) &&             // @audit gas: rearrange this to be first for short circuiting             isGovernance[msg.sender],         \"FSD::claimGovernanceTribute: Not a governance member\"     );     _claimGovernanceTribute(num); } ```  Reordering the conditions to first do the cheap governance check would allow this function to short-circuit if the user is not a governor, which will save gas on average. The last assignment `membership[msg.sender] = user;` is not required.   "}, {"title": "Missing SafeMath & SafeCasts", "html_url": "https://github.com/code-423n4/2021-11-fairside-findings/issues/71", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-11-fairside-findings", "body": "Missing SafeMath & SafeCasts"}, {"title": "Underflow in `ERC20ConvictionScore._writeCheckpoint`", "html_url": "https://github.com/code-423n4/2021-11-fairside-findings/issues/70", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor acknowledged"], "target": "2021-11-fairside-findings", "body": "Underflow in `ERC20ConvictionScore._writeCheckpoint`"}, {"title": "ERC20ConvictionScore._writeCheckpoint` does not write to storage on same block", "html_url": "https://github.com/code-423n4/2021-11-fairside-findings/issues/69", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-11-fairside-findings", "body": "# Handle  cmichel   # Vulnerability details  In `ERC20ConvictionScore._writeCheckpoint`, when the checkpoint is overwritten (`checkpoint.fromBlock == blockNumber`), the new value is set to the `memory checkpoint` structure and never written to storage.  ```solidity // @audit this is MEMORY, setting new convictionScore doesn't write to storage Checkpoint memory checkpoint = checkpoints[user][nCheckpoints - 1];  if (nCheckpoints > 0 && checkpoint.fromBlock == blockNumber) {     checkpoint.convictionScore = newCS; } ```  Users that have their conviction score updated several times in the same block will only have their first score persisted.  #### POC - User updates their conviction with `updateConvictionScore(user)` - **In the same block**, the user now redeems an NFT conviction using `acquireConviction(id)`. This calls `_increaseConvictionScore(user, amount)` which calls `_writeCheckpoint(..., prevConvictionScore + amount)`. The updated checkpoint is **not** written to storage, and the user lost their conviction NFT. (The conviction/governance totals might still be updated though, leading to a discrepancy.)  ## Impact Users that have their conviction score updated several times in the same block will only have their first score persisted.  This also applies to the total conviction scores `TOTAL_CONVICTION_SCORE` and `TOTAL_GOVERNANCE_SCORE` (see `_updateConvictionTotals`) which is a big issue as these are updated a lot of times each block.  It can also be used for inflating a user's conviction by first calling `updateConvictionScore` and then creating conviction tokens with `tokenizeConviction`. The `_resetConviction` will not actually reset the user's conviction.  ## Recommended Mitigation Steps Define the `checkpoint` variable as a `storage` pointer:  ```solidity Checkpoint storage checkpoint = checkpoints[user][nCheckpoints - 1]; ```  "}, {"title": "`FairSideDAO.SECS_PER_BLOCK` is inaccurate", "html_url": "https://github.com/code-423n4/2021-11-fairside-findings/issues/68", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor acknowledged"], "target": "2021-11-fairside-findings", "body": "`FairSideDAO.SECS_PER_BLOCK` is inaccurate"}, {"title": "Missing parameter validation", "html_url": "https://github.com/code-423n4/2021-11-fairside-findings/issues/67", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-11-fairside-findings", "body": "Missing parameter validation"}, {"title": "Avoid unnecessary storage reads in for loops can save gas", "html_url": "https://github.com/code-423n4/2021-11-fairside-findings/issues/66", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-fairside-findings", "body": "# Handle  WatchPug   # Vulnerability details  For the storage variables that will be accessed multiple times, especially in for loops, cache and read from the stack can save ~100 gas from each extra read (`SLOAD` after Berlin).  For example:  https://github.com/code-423n4/2021-11-fairside/blob/20c68793f48ee2678508b9d3a1bae917c007b712/contracts/dependencies/TributeAccrual.sol#L77-L88  ```solidity=77     function totalAvailableTribute(uint256 offset)         external         view         override         returns (uint256 total)     {         for (uint256 i = offset; i < totalTributes; i++)             total = total.add(availableTribute(i));          for (uint256 i = offset; i < totalGovernanceTributes; i++)             total = total.add(availableGovernanceTribute(i));     } ```  `totalTributes` and `totalGovernanceTributes` can be cached.  "}, {"title": "Beneficiary cant get `fairSideConviction` NFT unless they only claim once, and only after it's fully vested", "html_url": "https://github.com/code-423n4/2021-11-fairside-findings/issues/62", "labels": ["bug", "3 (High Risk)", "disagree with severity", "sponsor confirmed"], "target": "2021-11-fairside-findings", "body": "# Handle  WatchPug   # Vulnerability details  Based on the context, once the beneficiary claimed all their vesting tokens, they should get the `fairSideConviction` NFT.  However, in the current implementation, if the beneficiary has claimed any amounts before it's fully vested, then they will never be able to get the `fairSideConviction` NFT, because at L138, it requires the `tokenbClaim` to be equal to the initial vesting amount.  https://github.com/code-423n4/2021-11-fairside/blob/20c68793f48ee2678508b9d3a1bae917c007b712/contracts/token/FSDVesting.sol#L124-L142  ```solidity=124 function claimVestedTokens() external override onlyBeneficiary {     uint256 tokenClaim = calculateVestingClaim();     require(         tokenClaim > 0,         \"FSDVesting::claimVestedTokens: Zero claimable tokens\"     );      totalClaimed = totalClaimed.add(tokenClaim);     lastClaimAt = block.timestamp;      fsd.safeTransfer(msg.sender, tokenClaim);      emit TokensClaimed(msg.sender, tokenClaim, block.timestamp);      if (amount == tokenClaim) {         uint256 tokenId = fsd.tokenizeConviction(0);         fairSideConviction.transferFrom(address(this), msg.sender, tokenId);     } } ```  ### Recommendation  Change to:  ```solidity=124 function claimVestedTokens() external override onlyBeneficiary {     uint256 tokenClaim = calculateVestingClaim();     require(         tokenClaim > 0,         \"FSDVesting::claimVestedTokens: Zero claimable tokens\"     );      totalClaimed = totalClaimed.add(tokenClaim);     lastClaimAt = block.timestamp;      fsd.safeTransfer(msg.sender, tokenClaim);      emit TokensClaimed(msg.sender, tokenClaim, block.timestamp);      if (amount == totalClaimed) {         uint256 tokenId = fsd.tokenizeConviction(0);         fairSideConviction.transferFrom(address(this), msg.sender, tokenId);     } } ```  "}, {"title": "`user.creation` is updated incorrectly when the user tries to extend membership", "html_url": "https://github.com/code-423n4/2021-11-fairside-findings/issues/61", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed"], "target": "2021-11-fairside-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-fairside/blob/20c68793f48ee2678508b9d3a1bae917c007b712/contracts/network/FSDNetwork.sol#L274-L291  ```solidity=274 if (user.creation == 0) {     user.creation = block.timestamp;     user.gracePeriod =         membership[msg.sender].creation +         MEMBERSHIP_DURATION +         60 days; } else {     uint256 elapsedDurationPercentage = ((block.timestamp -         user.creation) * 1 ether) / MEMBERSHIP_DURATION;     if (elapsedDurationPercentage < 1 ether) {         uint256 durationIncrease = (costShareBenefit.mul(1 ether) /             (totalCostShareBenefit - costShareBenefit)).mul(                 MEMBERSHIP_DURATION             ) / 1 ether;         user.creation += durationIncrease;         user.gracePeriod += durationIncrease;     } } ```  ### PoC  1. Alice calls `function purchaseMembership()` and adds 20 ether of `costShareBenefit` on day 1:  ``` alice.creation = day 1 timestamp; alice.gracePeriod = day 791 timestamp; ```  2. Alice calls `function purchaseMembership()` again and adds 20 ether of `costShareBenefit` on day 2:  ``` elapsedDurationPercentage = 1/720 durationIncrease = 730 day  alice.creation = day 731 timestamp; alice.gracePeriod = day 1521 timestamp; ```  Making Alice unable to use any membership features until two years later.  "}, {"title": "Use `else if` in for loops can save gas and simplify code", "html_url": "https://github.com/code-423n4/2021-11-fairside-findings/issues/60", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-fairside-findings", "body": "# Handle  WatchPug   # Vulnerability details  The checks in the for loop can be changed to `else if` to save gas and make sure `msg.sender != sigAssessor`.  https://github.com/code-423n4/2021-11-fairside/blob/20c68793f48ee2678508b9d3a1bae917c007b712/contracts/network/FSDNetwork.sol#L616-L649  ```solidity=616 function _isApprovedByAssessors(         bytes memory sig,         uint256 id,         Action action     ) private view returns (bool) {         bytes32 digest = _hashTypedDataV4(             keccak256(abi.encode(CSR_ACTION, id, action))         );          address sigAssessor = ECDSA.recover(digest, sig);         uint256 assessorsLength = assessors.length;         bool assessorOne;         bool assessorTwo;          for (uint256 i = 0; i < assessorsLength; i++) {             if (msg.sender == assessors[i]) {                 assessorOne = true;             }             if (sigAssessor == assessors[i]) {                 assessorTwo = true;             }         }          require(             assessorOne && assessorTwo,             \"FSDNetwork::_isApprovedByAssessors: Not an Assessor\"         );         require(             msg.sender != sigAssessor,             \"FSDNetwork::_isApprovedByAssessors: Cannot be the single Assessor\"         );          return true;     } ```   ### Recommendation  Change to:  ```solidity=616 function _isApprovedByAssessors(         bytes memory sig,         uint256 id,         Action action     ) private view returns (bool) {         bytes32 digest = _hashTypedDataV4(             keccak256(abi.encode(CSR_ACTION, id, action))         );          address sigAssessor = ECDSA.recover(digest, sig);         uint256 assessorsLength = assessors.length;         bool assessorOne;         bool assessorTwo;          for (uint256 i = 0; i < assessorsLength; i++) {             if (msg.sender == assessors[i]) {                 assessorOne = true;             } else if (sigAssessor == assessors[i]) {                 assessorTwo = true;             }         }          require(             assessorOne && assessorTwo,             \"FSDNetwork::_isApprovedByAssessors: Not an Assessor\"         );          return true;     } ```  "}, {"title": "Using fixed length array as parameter type can avoid checks to save gas and improve consistency", "html_url": "https://github.com/code-423n4/2021-11-fairside-findings/issues/59", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-fairside-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-fairside/blob/20c68793f48ee2678508b9d3a1bae917c007b712/contracts/network/FSDNetwork.sol#L482-L495  ```solidity=482 function setAssessors(address[] calldata _assessors) external {         require(             msg.sender == GOVERNANCE_ADDRESS,             \"FSDNetwork::setAssessors: Insufficient Privileges\"         );          uint256 assessorsLength = _assessors.length;         require(             assessorsLength == 3,             \"FSDNetwork::setAssessors: Number of assessors must be three\"         );          assessors = _assessors;     } ```  ### Recommendation  Change to:  ```solidity=482 function setAssessors(address[3] calldata _assessors) external {         require(             msg.sender == GOVERNANCE_ADDRESS,             \"FSDNetwork::setAssessors: Insufficient Privileges\"         );          assessors = _assessors;     } ```  "}, {"title": "Missing events for critical operations", "html_url": "https://github.com/code-423n4/2021-11-fairside-findings/issues/57", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor acknowledged"], "target": "2021-11-fairside-findings", "body": "Missing events for critical operations"}, {"title": "Remove redundant check can save gas", "html_url": "https://github.com/code-423n4/2021-11-fairside-findings/issues/56", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-fairside-findings", "body": "# Handle  WatchPug   # Vulnerability details  The check if `_wallets.length <= 2` is redundant as the length of `_wallets` parameter must be 2.  https://github.com/code-423n4/2021-11-fairside/blob/20c68793f48ee2678508b9d3a1bae917c007b712/contracts/network/FSDNetwork.sol#L520-L533  ```solidity=520 function setMembershipWallets(address[2] calldata _wallets) external {     //todo internal     require(         membership[msg.sender].wallets[0] == address(0) &&             membership[msg.sender].wallets[1] == address(0),         \"FSDNetwork::setMembershipWallets: Cannot have more than three wallets per membership\"     );     require(         _wallets.length <= 2,         \"FSDNetwork::setMembershipWallets: Too many wallets\"     );     membership[msg.sender].wallets = _wallets; } ```  ### Recommendation  Remove the redundant check.  "}, {"title": "Avoid unnecessary external calls can save gas", "html_url": "https://github.com/code-423n4/2021-11-fairside-findings/issues/55", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-fairside-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/oracle/ChainlinkOracle.sol#L50-L60  ```solidity=50 function sync() public {     (, int256 feedPrice, , uint256 timestamp, ) = feed.latestRoundData();     Fixed18 price = Fixed18Lib.ratio(feedPrice, SafeCast.toInt256(_decimalOffset));      if (priceAtVersion.length == 0 || timestamp > timestampAtVersion[currentVersion()] + minDelay) {         priceAtVersion.push(price);         timestampAtVersion.push(timestamp);          emit Version(currentVersion(), timestamp, price);     } } ```  If `block.timestamp - timestampAtVersion[currentVersion()] < minDelay`, there is no need to call `feed.latestRoundData()`.  ### Recommendation  Change to:  ```solidity=50 function sync() public {     if (priceAtVersion.length == 0 || block.timestamp - timestampAtVersion[currentVersion()] >= minDelay ) {         (, int256 feedPrice, , uint256 timestamp, ) = feed.latestRoundData();         Fixed18 price = Fixed18Lib.ratio(feedPrice, SafeCast.toInt256(_decimalOffset));          if (priceAtVersion.length == 0 || timestamp > timestampAtVersion[currentVersion()] + minDelay) {             priceAtVersion.push(price);             timestampAtVersion.push(timestamp);              emit Version(currentVersion(), timestamp, price);         }     } } ```  "}, {"title": "Faulty comments in `dao/FairSideDAO.sol` ", "html_url": "https://github.com/code-423n4/2021-11-fairside-findings/issues/54", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor acknowledged"], "target": "2021-11-fairside-findings", "body": "Faulty comments in `dao/FairSideDAO.sol` "}, {"title": "`FSDNetwork` should inherit from interface `IFSDNetwork`", "html_url": "https://github.com/code-423n4/2021-11-fairside-findings/issues/52", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-11-fairside-findings", "body": "`FSDNetwork` should inherit from interface `IFSDNetwork`"}, {"title": "Use of transfer function for transferring NFTs", "html_url": "https://github.com/code-423n4/2021-11-fairside-findings/issues/48", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged", "sponsor disputed"], "target": "2021-11-fairside-findings", "body": "Use of transfer function for transferring NFTs"}, {"title": "FSD.sol does not implement transfer-accept ownership pattern", "html_url": "https://github.com/code-423n4/2021-11-fairside-findings/issues/47", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor acknowledged"], "target": "2021-11-fairside-findings", "body": "FSD.sol does not implement transfer-accept ownership pattern"}, {"title": "Use existing memory version of state variables (Timelock.sol)", "html_url": "https://github.com/code-423n4/2021-11-fairside-findings/issues/44", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-11-fairside-findings", "body": "Use existing memory version of state variables (Timelock.sol)"}, {"title": "Long revert strings", "html_url": "https://github.com/code-423n4/2021-11-fairside-findings/issues/43", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-11-fairside-findings", "body": "Long revert strings"}, {"title": "Open TODOs", "html_url": "https://github.com/code-423n4/2021-11-fairside-findings/issues/41", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "sponsor confirmed"], "target": "2021-11-fairside-findings", "body": "Open TODOs"}, {"title": "Double update on storage pointer can lead to massive gas consumption", "html_url": "https://github.com/code-423n4/2021-11-fairside-findings/issues/34", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-fairside-findings", "body": "# Handle  rfa   # Vulnerability details  ## Impact When you are reading a value from a storage and using a storage pointer instead of memory, you write directly to the storage instead of the memory.  In the https://github.com/code-423n4/2021-11-fairside/blob/main/contracts/network/FSDNetwork.sol#L234 this line is reading membership[msg.sender] with a storage pointer,  this means any changes to the user variable, is updating directly to the membership[msg.sender],  therefore https://github.com/code-423n4/2021-11-fairside/blob/main/contracts/network/FSDNetwork.sol#L294 this line update, makes it useless since the data already written to the membership[msg.sender]  ## Proof of Concept  https://github.com/code-423n4/2021-11-fairside/blob/main/contracts/network/FSDNetwork.sol#L234-L294   ## Tools Used  ## Recommended Mitigation Steps  https://github.com/code-423n4/2021-11-fairside/blob/main/contracts/network/FSDNetwork.sol#L294 membership[msg.sender] = user;  "}, {"title": "FSDVesting: Redundant _start input parameter in initiateVesting()", "html_url": "https://github.com/code-423n4/2021-11-fairside-findings/issues/33", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-fairside-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ## Impact  Tracing the function calls, the `_start` parameter in `initiateVesting()` will always be `block.timestamp`. Hence, this input parameter can be removed from the function.  ## Recommended Mitigation Steps  ```jsx // TODO: Modify relevant function calls function initiateVesting(   address _beneficiary,   uint256 _amount ) external onlyFactory {  require(     start == 0,     \"FSDVesting::initiateVesting: Vesting is already initialized\"   );  beneficiary = _beneficiary;  start = block.timestamp;  amount = _amount; } ```  "}, {"title": "FSDVesting: Optimise updateVestedTokens()", "html_url": "https://github.com/code-423n4/2021-11-fairside-findings/issues/31", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-fairside-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ## Impact  1. The `_user` input in `updateVestedTokens()` is redundant because each user will have at most 1 vesting contract, and this function should be restricted to the FSD token contract only (kindly refer to related submitted issue), which stores and retrieves the mapping of users to vesting contracts. 2. The zero amount check is redundant because it is already checked in `FSD._createVesting()`.  ## Recommended Mitigation Steps  ```jsx /** * @dev Allows a vesting beneficiary to extend their vested token amount. */ function updateVestedTokens(uint256 _amount)   external   override  onlyFsd {   amount = amount.add(_amount); } ```  "}, {"title": "FSDVesting: Define new constant LINEAR_VEST_AFTER_CLIFF", "html_url": "https://github.com/code-423n4/2021-11-fairside-findings/issues/30", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-fairside-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ## Impact  `DURATION.sub(CLIFF)` is calculated in `calculateVestingClaim()`. Since both are constants, it would be better to define a new constant `LINEAR_VEST_AFTER_CLIFF` that refers to the vest duration after the cliff.  ## Recommended Mitigation Steps  `uint256 private constant LINEAR_VEST_AFTER_CLIFF = 18 * ONE_MONTH;`  "}, {"title": "FSDVesting: Constants can be made internal / private", "html_url": "https://github.com/code-423n4/2021-11-fairside-findings/issues/29", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-fairside-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ## Impact  Since the defined constants are unneeded elsewhere, it can be defined to be `internal` or `private` to save gas.  ## Recommended Mitigation Steps  ```jsx // One month in seconds uint256 internal constant ONE_MONTH = 30 days; // Cliff period for a vest uint256 internal constant CLIFF = 12 * ONE_MONTH; // Duration of a vest uint256 internal constant DURATION = 30 * ONE_MONTH; ```  "}, {"title": "FSDVesting: Claiming tributes should call FSD token's corresponding functions", "html_url": "https://github.com/code-423n4/2021-11-fairside-findings/issues/28", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-11-fairside-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ## Impact  The claiming of staking and governance tributes for the a beneficiary's vested tokens should be no different than other users / EOAs. However, the `claimTribute()` and `claimGovernanceTribute()` are missing the actual claiming calls to the corresponding functions of the FSD token contract. As a result, the accrued rewards are taken from the beneficiary's vested token while not claiming (replenishing) from the FSD token contract.  ## Recommended Mitigation Steps  In addition to what has been mentioned above, the internal accounting for claimedTribute states can be removed because they are already performed in the FSD token contract.  ```jsx // TODO: Remove _claimedTribute and _claimedGovernanceTribute mappings  /** * @dev Allows claiming of staking tribute by `msg.sender` during their vesting period. * It updates the claimed status of the vest against the tribute * being claimed. * * Requirements: * - claiming amount must not be 0. */ function claimTribute(uint256 num) external onlyBeneficiary {     uint256 tribute = fsd.availableTribute(num);     require(tribute != 0, \"FSDVesting::claimTribute: No tribute to claim\");   fsd.claimTribute(num);     fsd.safeTransfer(msg.sender, tribute);     emit TributeClaimed(msg.sender, tribute); }  /** * @dev Allows claiming of governance tribute by `msg.sender` during their vesting period. * It updates the claimed status of the vest against the tribute * being claimed. * * Requirements: * - claiming amount must not be 0. */ function claimGovernanceTribute(uint256 num) external onlyBeneficiary {   uint256 tribute = fsd.availableGovernanceTribute(num);   require(     tribute != 0,     \"FSDVesting::claimGovernanceTribute: No governance tribute to claim\"   );   fsd.claimGovernanceTribute(num);   fsd.safeTransfer(msg.sender, tribute);   emit GovernanceTributeClaimed(msg.sender, tribute); } ```  "}, {"title": "redundant named return issue", "html_url": "https://github.com/code-423n4/2021-11-fairside-findings/issues/21", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-11-fairside-findings", "body": "redundant named return issue"}, {"title": "safeApprove is deprecated.", "html_url": "https://github.com/code-423n4/2021-11-fairside-findings/issues/16", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged", "sponsor disputed"], "target": "2021-11-fairside-findings", "body": "safeApprove is deprecated."}, {"title": "Offchain voting can't be renabled in DAO", "html_url": "https://github.com/code-423n4/2021-11-fairside-findings/issues/6", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-fairside-findings", "body": "# Handle  Ruhum   # Vulnerability details  ## Impact The comment for the `disableOffchainVoting()` function specifies that the feature can be reenabled in the future through a proposal. But, there seems to be no function to do that in the DAO contract.  ## Proof of Concept Function with the comment: https://github.com/code-423n4/2021-11-fairside/blob/main/contracts/dao/FairSideDAO.sol#L619  No way to reassign the value: `grep offchain`  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Either remove the comment if the feature is not intended or add a function to reassign the `offchain` and `guardian` state variable  "}, {"title": "Assigning keccak operations to constant variables results in extra gas costs", "html_url": "https://github.com/code-423n4/2021-11-fairside-findings/issues/3", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-fairside-findings", "body": "# Handle  TomFrench   # Vulnerability details  ## Impact  Increased gas costs  ## Proof of Concept  In a number of places a `keccak(\"string\")` expression is assigned to a `constant` variable. Due to how `constant` variables are implemented this results in the hash being recomputed each time that the variable is used, spending the gas necessary to perform this action.  https://github.com/code-423n4/2021-11-fairside/blob/20c68793f48ee2678508b9d3a1bae917c007b712/contracts/dao/FairSideDAO.sol#L43-L49  If these variables were to be `immutable` this hash is calculated once at deploy time and then the result is saved to be used directly at runtime rather than recalculating, saving the cost of hashing.  See: https://github.com/ethereum/solidity/issues/9232  ## Recommended Mitigation Steps  Change all `constant` hashes to be `immutable`  "}, {"title": "Unused imported contract in xVader", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/269", "labels": ["bug", "G (Gas Optimization)", "sponsor disputed", "XVader"], "target": "2021-11-vader-findings", "body": "Unused imported contract in xVader"}, {"title": "inconsistent use of msg.sender and _msgSender()", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/267", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "Vader"], "target": "2021-11-vader-findings", "body": "inconsistent use of msg.sender and _msgSender()"}, {"title": "setComponents function specs and logic mismatch", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/262", "labels": ["bug", "1 (Low Risk)", "disagree with severity"], "target": "2021-11-vader-findings", "body": "setComponents function specs and logic mismatch"}, {"title": "Users Can Reset Bond Depositor's Vesting Period", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/259", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged", "VaderBond"], "target": "2021-11-vader-findings", "body": "Users Can Reset Bond Depositor's Vesting Period"}, {"title": "Mixing different types of LP shares can lead to losses for Synth holders", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/257", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "VaderPoolV2", "BasePoolV2"], "target": "2021-11-vader-findings", "body": "# Handle  hyh   # Vulnerability details   ## Impact  Users that mint Synths do not get pool shares, so exiting of normal LP can lead to their losses as no funds can be left for retrieval.  ## Proof of Concept  3 types of mint/burn: NFT, Fungible and Synths. Synths are most vilnerable as they do not have share: LP own the pool, so Synth's funds are lost in scenarios similar to: 1. LP deposit both sides to a pool 2. Synth deposit and mint a Synth 3. LP withdraws all as she owns all the pool liquidity, even when provided only part of it 4. Synth can't withdraw as no assets left  burn NFT LP: https://github.com/code-423n4/2021-11-vader/blob/main/contracts/dex-v2/pool/BasePoolV2.sol#L270  burn fungible LP: https://github.com/code-423n4/2021-11-vader/blob/main/contracts/dex-v2/pool/VaderPoolV2.sol#L374  ## Recommended Mitigation Steps  Take into account liquidity that was provided by Synth minting.  "}, {"title": "Covering impermanent loss allows profiting off asymmetric liquidity provision at expense of reserve holdings", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/255", "labels": ["bug", "duplicate", "3 (High Risk)", "VaderPoolV2", "BasePoolV2", "VaderRouterV2", "VaderReserve", "VaderMath"], "target": "2021-11-vader-findings", "body": "Covering impermanent loss allows profiting off asymmetric liquidity provision at expense of reserve holdings"}, {"title": "Unused slippage params", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/253", "labels": ["bug", "3 (High Risk)", "sponsor disputed", "VaderRouter"], "target": "2021-11-vader-findings", "body": "Unused slippage params"}, {"title": "VaderPoolV2.rescue results in loss of funds rather than recoverability", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/251", "labels": ["bug", "2 (Med Risk)", "VaderPoolV2"], "target": "2021-11-vader-findings", "body": "VaderPoolV2.rescue results in loss of funds rather than recoverability"}, {"title": "Add method to migrate from fungible to nonfungible liquidity", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/237", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged", "VaderPoolV2"], "target": "2021-11-vader-findings", "body": "Add method to migrate from fungible to nonfungible liquidity"}, {"title": "safe transfer of tokens", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/234", "labels": ["bug", "0 (Non-critical)", "disagree with severity"], "target": "2021-11-vader-findings", "body": "safe transfer of tokens"}, {"title": "block times 13s -> 12s", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/231", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged", "VaderBond"], "target": "2021-11-vader-findings", "body": "block times 13s -> 12s"}, {"title": "Unsupported tokens can be given fungible LP support", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/230", "labels": ["bug", "0 (Non-critical)", "sponsor disputed", "VaderPoolV2"], "target": "2021-11-vader-findings", "body": "Unsupported tokens can be given fungible LP support"}, {"title": "Contracts VaderPoolFactory and VaderReserve can be initialized multiple times", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/228", "labels": ["bug", "1 (Low Risk)", "disagree with severity"], "target": "2021-11-vader-findings", "body": "Contracts VaderPoolFactory and VaderReserve can be initialized multiple times"}, {"title": "`LinearVesting` missing events", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/225", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "LinearVesting"], "target": "2021-11-vader-findings", "body": "`LinearVesting` missing events"}, {"title": "Store VaderPoolV2 address as immutable in LPWrapper", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/224", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged", "LPWrapper"], "target": "2021-11-vader-findings", "body": "Store VaderPoolV2 address as immutable in LPWrapper"}, {"title": "Disregarding Check Effects in `VaderBond.redeem()` ", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/219", "labels": ["bug", "0 (Non-critical)", "sponsor disputed", "VaderBond"], "target": "2021-11-vader-findings", "body": "Disregarding Check Effects in `VaderBond.redeem()` "}, {"title": "Missing events for critical operations", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/214", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "VaderPoolV2"], "target": "2021-11-vader-findings", "body": "Missing events for critical operations"}, {"title": "Wrong design of `swap()` results in unexpected and unfavorable outputs", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/213", "labels": ["bug", "question", "3 (High Risk)", "sponsor disputed", "VaderMath"], "target": "2021-11-vader-findings", "body": "Wrong design of `swap()` results in unexpected and unfavorable outputs"}, {"title": "Wrong design/implementation of `addLiquidity()` allows attacker to steal funds from the liquidity pool", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/212", "labels": ["bug", "question", "3 (High Risk)", "sponsor disputed", "VaderPoolV2"], "target": "2021-11-vader-findings", "body": "Wrong design/implementation of `addLiquidity()` allows attacker to steal funds from the liquidity pool"}, {"title": "`mintSynth()` and `burnSynth()` can be front run", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/209", "labels": ["bug", "3 (High Risk)", "VaderPoolV2"], "target": "2021-11-vader-findings", "body": "`mintSynth()` and `burnSynth()` can be front run"}, {"title": "Changing function visibility from public to external can save gas", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/207", "labels": ["bug", "G (Gas Optimization)", "Timelock"], "target": "2021-11-vader-findings", "body": "Changing function visibility from public to external can save gas"}, {"title": "`SwapQueue.sol` Incomplete implementation", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/206", "labels": ["bug", "0 (Non-critical)", "SwapQueue"], "target": "2021-11-vader-findings", "body": "`SwapQueue.sol` Incomplete implementation"}, {"title": "`USDV.sol` Incomplete implementation", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/205", "labels": ["bug", "0 (Non-critical)", "USDV"], "target": "2021-11-vader-findings", "body": "`USDV.sol` Incomplete implementation"}, {"title": "Lack of access control allow attacker to `mintFungible()` and `mintSynth()` with other user's wallet balance", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/204", "labels": ["bug", "3 (High Risk)", "VaderPoolV2"], "target": "2021-11-vader-findings", "body": "Lack of access control allow attacker to `mintFungible()` and `mintSynth()` with other user's wallet balance"}, {"title": "VaderBond insufficient validation of max payout may prevent redeeming valid payout ", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/202", "labels": ["bug", "0 (Non-critical)", "sponsor disputed", "VaderBond"], "target": "2021-11-vader-findings", "body": "VaderBond insufficient validation of max payout may prevent redeeming valid payout "}, {"title": "`Router#initialize()` Lack of input validation for `reserve` asset", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/199", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged", "VaderReserve"], "target": "2021-11-vader-findings", "body": "`Router#initialize()` Lack of input validation for `reserve` asset"}, {"title": "Possibility of reducing the maxSupply of Vader", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/198", "labels": ["bug", "1 (Low Risk)", "sponsor disputed", "Vader"], "target": "2021-11-vader-findings", "body": "Possibility of reducing the maxSupply of Vader"}, {"title": "Unsafe type casting", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/195", "labels": ["bug", "1 (Low Risk)", "sponsor disputed", "LinearVesting"], "target": "2021-11-vader-findings", "body": "Unsafe type casting"}, {"title": "Tokens with fee on transfer are not supported", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/193", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "BasePoolV2"], "target": "2021-11-vader-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-phuture/tree/main/contracts/IndexLogic.sol#L115   # Vulnerability details   There are ERC20 tokens that charge fee for every transfer() / transferFrom().  Vault.sol#addValue() assumes that the received amount is the same as the transfer amount,  and uses it to calculate attributions, balance amounts, etc.  But, the actual transferred amount can be lower for those tokens. Therefore it's recommended to use the balance change before and after the transfer instead of the amount. This way you also support the tokens with transfer fee - that are popular.           https://github.com/code-423n4/2022-04-phuture/tree/main/contracts/IndexLogic.sol#L115  "}, {"title": "`BasePoolV2#rescue()` should be `nonReentrant`", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/191", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "BasePoolV2"], "target": "2021-11-vader-findings", "body": "`BasePoolV2#rescue()` should be `nonReentrant`"}, {"title": "`VaderRouterV2#addLiquidity()` is not compatible with the interface of UniswapV2Router02#addliquidity()", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/190", "labels": ["bug", "1 (Low Risk)", "VaderRouterV2"], "target": "2021-11-vader-findings", "body": "`VaderRouterV2#addLiquidity()` is not compatible with the interface of UniswapV2Router02#addliquidity()"}, {"title": "Early user can break `addLiquidity`", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/189", "labels": ["bug", "3 (High Risk)", "sponsor acknowledged", "BasePool"], "target": "2021-11-vader-findings", "body": "Early user can break `addLiquidity`"}, {"title": "Governance veto can be bypassed", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/186", "labels": ["bug", "3 (High Risk)", "GovernorAlpha"], "target": "2021-11-vader-findings", "body": "Governance veto can be bypassed"}, {"title": "Gas Optimization: Simplify Math", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/184", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged", "VaderMath"], "target": "2021-11-vader-findings", "body": "Gas Optimization: Simplify Math"}, {"title": "Gas Optimization: Inline instead of modifier", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/183", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-11-vader-findings", "body": "# Handle  gzeon   # Vulnerability details  ## Impact `onlyAdmin` of YaxisVaultAdapter.sol is only used in `withdraw`, it is advised to inline the function to save some gas without losing readability.   ## Proof of Concept https://github.com/code-423n4/2021-11-yaxis/blob/146febcb61ae7fe20b0920849c4f4bbe111c6ba7/contracts/v3/alchemix/adapters/YaxisVaultAdapter.sol#L37  "}, {"title": "Attacker can claim more IL by manipulating pool price then `removeLiquidity` ", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/182", "labels": ["bug", "3 (High Risk)", "VaderRouterV2"], "target": "2021-11-vader-findings", "body": "Attacker can claim more IL by manipulating pool price then `removeLiquidity` "}, {"title": "Use safeTransfer instead of transfer", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/181", "labels": ["bug", "duplicate", "0 (Non-critical)", "sponsor disputed", "VaderBond"], "target": "2021-11-vader-findings", "body": "Use safeTransfer instead of transfer"}, {"title": "block.chainid may change in case of a hardfork", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/178", "labels": ["bug", "1 (Low Risk)", "sponsor disputed", "UniswapV2ERC20"], "target": "2021-11-vader-findings", "body": "block.chainid may change in case of a hardfork"}, {"title": "No Transfer Ownership Pattern", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/175", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged", "VaderReserve", "VaderPoolFactory", "Treasury"], "target": "2021-11-vader-findings", "body": "No Transfer Ownership Pattern"}, {"title": "Governor's veto protection can be exploited", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/167", "labels": ["bug", "2 (Med Risk)", "GovernorAlpha"], "target": "2021-11-vader-findings", "body": "Governor's veto protection can be exploited"}, {"title": "Governor average block time is not up-to-date", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/166", "labels": ["bug", "1 (Low Risk)", "sponsor disputed", "GovernorAlpha"], "target": "2021-11-vader-findings", "body": "Governor average block time is not up-to-date"}, {"title": "`VaderRouter.calculateOutGivenIn` calculates wrong swap", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/162", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "VaderRouter"], "target": "2021-11-vader-findings", "body": "# Handle  cmichel   # Vulnerability details  The 3-path hop in `VaderRouter.calculateOutGivenIn` is supposed to first swap **foreign** assets to native assets **in pool0**, and then the received native assets to different foreign assets again **in pool1**.  The first argument of `VaderMath.calculateSwap(amountIn, reserveIn, reserveOut)` must refer to the same token as the second argument `reserveIn`. The code however mixes these positions up and first performs a swap in `pool1` instead of `pool0`:  ```solidity function calculateOutGivenIn(uint256 amountIn, address[] calldata path)     external     view     returns (uint256 amountOut) {   if(...) {   } else {     return         VaderMath.calculateSwap(             VaderMath.calculateSwap(                 // @audit the inner trade should not be in pool1 for a forward swap. amountIn foreign => next param should be foreignReserve0                 amountIn,                 nativeReserve1,                 foreignReserve1             ),             foreignReserve0,             nativeReserve0         );   }   /** @audit instead should first be trading in pool0!     VaderMath.calculateSwap(         VaderMath.calculateSwap(             amountIn,             foreignReserve0,             nativeReserve0         ),         nativeReserve1,         foreignReserve1     );   */ ```  ## Impact All 3-path swaps computations through `VaderRouter.calculateOutGivenIn` will return the wrong result. Smart contracts or off-chain scripts/frontends that rely on this value to trade will have their transaction reverted, or in the worst case lose funds.  ## Recommended Mitigation Steps Return the following code instead which first trades in pool0 and then in pool1:  ```solidity return   VaderMath.calculateSwap(       VaderMath.calculateSwap(           amountIn,           foreignReserve0,           nativeReserve0       ),       nativeReserve1,       foreignReserve1   ); ```   "}, {"title": "`VaderRouter._swap` performs wrong swap", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/161", "labels": ["bug", "3 (High Risk)", "sponsor confirmed", "VaderRouter"], "target": "2021-11-vader-findings", "body": "# Handle  cmichel   # Vulnerability details  The 3-path hop in `VaderRouter._swap` is supposed to first swap **foreign** assets to native assets, and then the received native assets to different foreign assets again.  The `pool.swap(nativeAmountIn, foreignAmountIn)` accepts the foreign amount as the **second** argument. The code however mixes these positional arguments up and tries to perform a `pool0` foreign -> native swap by using the **foreign** amount as the **native amount**:  ```solidity function _swap(     uint256 amountIn,     address[] calldata path,     address to ) private returns (uint256 amountOut) {     if (path.length == 3) {       // ...       // @audit calls this with nativeAmountIn = amountIn. but should be foreignAmountIn (second arg)       return pool1.swap(0, pool0.swap(amountIn, 0, address(pool1)), to);     } }  // @audit should be this instead return pool1.swap(pool0.swap(0, amountIn, address(pool1)), 0, to); ```  ## Impact All 3-path swaps through the `VaderRouter` fail in the pool check when `require(nativeAmountIn = amountIn <= nativeBalance - nativeReserve = 0)` is checked, as foreign amount is sent but _native_ amount is specified.  ## Recommended Mitigation Steps Use `return pool1.swap(pool0.swap(0, amountIn, address(pool1)), 0, to);` instead.  "}, {"title": "setRewardsDuration() Lack of Input Validation May Break notifyRewardAmount()", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/156", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged", "StakingRewards"], "target": "2021-11-vader-findings", "body": "setRewardsDuration() Lack of Input Validation May Break notifyRewardAmount()"}, {"title": "Use bytes32 Rather Than String", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/153", "labels": ["bug", "G (Gas Optimization)", "GovernorAlpha"], "target": "2021-11-vader-findings", "body": "Use bytes32 Rather Than String"}, {"title": "`Converter.convert()` Proofs Can Be Replayed On Other Chains", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/150", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "Converter"], "target": "2021-11-vader-findings", "body": "`Converter.convert()` Proofs Can Be Replayed On Other Chains"}, {"title": "`BasePool.swap()` Is Callable By Anyone", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/149", "labels": ["bug", "2 (Med Risk)", "sponsor disputed", "VaderRouter", "BasePool"], "target": "2021-11-vader-findings", "body": "`BasePool.swap()` Is Callable By Anyone"}, {"title": "`BasePool.mint()` Is Callable By Anyone", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/148", "labels": ["bug", "2 (Med Risk)", "sponsor disputed", "VaderRouter", "BasePool"], "target": "2021-11-vader-findings", "body": "`BasePool.mint()` Is Callable By Anyone"}, {"title": "Anyone Can Arbitrarily Mint Synthetic Assets In `VaderPoolV2.mintSynth()`", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/146", "labels": ["bug", "3 (High Risk)", "VaderPoolV2"], "target": "2021-11-vader-findings", "body": "Anyone Can Arbitrarily Mint Synthetic Assets In `VaderPoolV2.mintSynth()`"}, {"title": "`Converter::constructor` ignores return value from function call", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/145", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "Converter"], "target": "2021-11-vader-findings", "body": "`Converter::constructor` ignores return value from function call"}, {"title": "Use constant `_INITIAL_EMISSION_CURVE` in `Vader.sol`", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/144", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged", "Vader"], "target": "2021-11-vader-findings", "body": "Use constant `_INITIAL_EMISSION_CURVE` in `Vader.sol`"}, {"title": "Function AdjustMaxSupply is incorrect (or at least confusing)", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/143", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "Vader"], "target": "2021-11-vader-findings", "body": "Function AdjustMaxSupply is incorrect (or at least confusing)"}, {"title": "Incorrect comments (technical issues)", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/141", "labels": ["bug", "1 (Low Risk)", "GovernorAlpha"], "target": "2021-11-vader-findings", "body": "Incorrect comments (technical issues)"}, {"title": "`StakingRewards.sol#updateReward` can be split to two modifiers to save gas", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/139", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged", "StakingRewards"], "target": "2021-11-vader-findings", "body": "`StakingRewards.sol#updateReward` can be split to two modifiers to save gas"}, {"title": "Missing duplicate veto check", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/137", "labels": ["bug", "duplicate", "2 (Med Risk)", "GovernorAlpha"], "target": "2021-11-vader-findings", "body": "Missing duplicate veto check"}, {"title": "might not check current block when casting vote", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/135", "labels": ["bug", "0 (Non-critical)", "sponsor disputed", "XVader", "GovernorAlpha"], "target": "2021-11-vader-findings", "body": "might not check current block when casting vote"}, {"title": "calldata vs memory in solidity gas usage", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/131", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged", "LinearVesting"], "target": "2021-11-vader-findings", "body": "calldata vs memory in solidity gas usage"}, {"title": "unessesary safe math in UniSwapV2Pair.sol line 120", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/127", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged", "UniswapV2Pair"], "target": "2021-11-vader-findings", "body": "unessesary safe math in UniSwapV2Pair.sol line 120"}]