[{"title": "4. Improper validation of Chainlink data ", "html_url": "https://github.com/trailofbits/publications/tree/master/reviews/2022-10-fraxfinance-fraxlend-fraxferry-securityreview.pdf", "body": "The current validation of the values returned by Chainlinks latestRoundData function could result in the use of stale data. The latestRoundData function returns the following values: the answer , the roundId (which represents the current round), the answeredInRound value (which corresponds to the round in which the answer was computed), and the updatedAt value (which is the timestamp of when the round was updated). An updatedAt value of zero means that the round is not complete and should not be used. An answeredInRound value that is less than the roundId could indicate stale data. However, the _updateExchangeRate function does not check for these conditions. function _updateExchangeRate () internal returns ( uint256 _exchangeRate ) { // [...] uint256 _price = uint256 (1e36); if (oracleMultiply != address ( 0 )) { (, int256 _answer , , , ) = AggregatorV3Interface(oracleMultiply).latestRoundData(); if (_answer <= 0 ) { revert OracleLTEZero(oracleMultiply); } _price = _price * uint256 (_answer); } if (oracleDivide != address ( 0 )) { (, int256 _answer , , , ) = AggregatorV3Interface(oracleDivide).latestRoundData(); if (_answer <= 0 ) { revert OracleLTEZero(oracleDivide); } _price = _price / uint256 (_answer); } // [...] } Figure 4.1: The _updateExchangeRate function in FraxlendPairCore.sol#L513-L544 Exploit Scenario Chainlink is not updated correctly in the current round, and Eve, who should be liquidated with the real collateral asset price, is not liquidated because the price reported is outdated and is higher than it is in reality. Recommendations Short term, have _updateExchangeRate perform the following sanity check: require(updatedAt != 0 && answeredInRound == roundId) . This check will ensure that the round has nished and that the pricing data is from the current round. Long term, when integrating with third-party protocols, make sure to accurately read their documentation and implement the appropriate sanity checks.", "labels": ["Trail of Bits", "Severity: Low", "Difficulty: Low"]}, {"title": "5. Risk of oracle outages ", "html_url": "https://github.com/trailofbits/publications/tree/master/reviews/2022-10-fraxfinance-fraxlend-fraxferry-securityreview.pdf", "body": "Under extreme market conditions, the Chainlink oracle may cease to work as expected, causing unexpected behavior in the Fraxlend protocol. Such oracle issues have occurred in the past. For example, during the LUNA market crash, the Venus protocol was exploited because Chainlink stopped providing up-to-date prices. The interruption occurred because the price of LUNA dropped below the minimum price ( minAnswer ) allowed by the LUNA/USD price feed on the BNB chain. As a result, all oracle updates reverted. Chainlinks automatic circuit breakers , which will pause price feeds during extreme market conditions, could pose similar problems. Note that these kinds of events cannot be tracked on-chain. If a price feed is paused, updatedAt will still be greater than zero, and answeredInRound will still be equal to roundId . Therefore, the Frax Finance team should implement an o-chain monitoring solution to detect any anomalous behavior exhibited by Chainlink oracles. Recommendations Short term, implement an o-chain monitoring solution that checks for the following conditions and issues alerts if they occur, as they may be indicative of abnormal market events:    An asset price that is approaching the minAnswer or maxAnswer value The suspension of a price feed by an automatic circuit breaker Any large deviations in the price of an asset", "labels": ["Trail of Bits", "Severity: Informational", "Difficulty: High"]}, {"title": "6. Unapproved lenders could receive fTokens ", "html_url": "https://github.com/trailofbits/publications/tree/master/reviews/2022-10-fraxfinance-fraxlend-fraxferry-securityreview.pdf", "body": "A Fraxlend custom pair can include a list of approved lenders; these are the only lenders who can deposit the underlying asset into the given pair and receive the corresponding fTokens. However, the system does not perform checks when users transfer fTokens; as a result, approved lenders could send fTokens to unapproved addresses. Although unapproved addresses can only redeem fTokens sent to themmeaning this issue is not security-criticalthe ability for approved lenders to send fTokens to unapproved addresses conicts with the currently documented behavior. function deposit ( uint256 _amount , address _receiver ) external nonReentrant isNotPastMaturity whenNotPaused approvedLender(_receiver) returns ( uint256 _sharesReceived ) {...} Figure 6.1: The deposit function in FraxlendPairCore.sol#L587-L594 Exploit Scenario Bob, an approved lender, deposits 100 asset tokens and receives 90 fTokens. He then sends the fTokens to an unapproved address, causing other users to worry about the state of the protocol. Recommendations Short term, override the _beforeTokenTransfer function by applying the approvedLender modier to it. Alternatively, document the ability for approved lenders to send fTokens to unapproved addresses. Long term, when applying access controls to token owners, make sure to evaluate all the possible ways in which a token can be transferred and document the expected behavior.", "labels": ["Trail of Bits", "Severity: Informational", "Difficulty: Low"]}, {"title": "7. FraxlendPairDeployer cannot deploy contracts of fewer than 13,000 bytes ", "html_url": "https://github.com/trailofbits/publications/tree/master/reviews/2022-10-fraxfinance-fraxlend-fraxferry-securityreview.pdf", "body": "The FraxlendPairDeployer contract, which is used to deploy new pairs, does not allow contracts that contain less than 13,000 bytes of code to be deployed. To deploy new pairs, users call the deploy or deployCustom function, which then internally calls _deployFirst . This function uses the create2 opcode to create a contract for the pair by concatenating the bytecode stored in contractAddress1 and contractAddress2 . The setCreationCode function, which uses solmates SSTORE2 library to store the bytecode for use by create2 , splits the bytecode into two separate contracts ( contractAddress1 and contractAddress2 ) if the _creationCode size is greater than 13,000. function setCreationCode ( bytes calldata _creationCode) external onlyOwner { bytes memory _firstHalf = BytesLib.slice(_creationCode, 0 , 13000 ); contractAddress1 = SSTORE2.write(_firstHalf); if (_creationCode.length > 13000 ) { bytes memory _secondHalf = BytesLib.slice(_creationCode, 13000 , _creationCode.length - 13000 ); contractAddress2 = SSTORE2.write(_secondHalf); } } Figure 7.1: The setCreationCode function in FraxlendPairDeployer.sol#L173-L180 The rst problem is that if the _creationCode size is less than 13,000, BytesLib.slice will revert with the slice_outOfBounds error, as shown in gure 7.2. function slice ( bytes memory _bytes, uint256 _start , uint256 _length ) internal pure returns ( bytes memory ) { require (_length + 31 >= _length, \"slice_overflow\" ); require (_bytes.length >= _start + _length, \"slice_outOfBounds\" ); Figure 7.2: The BytesLib.slice function from the solidity-bytes-utils library Assuming that the rst problem does not exist, another problem arises from the use of SSTORE2.read in the _deployFirst function (gure 7.3). If the creation code was less than 13,000 bytes, contractAddress2 would be set to address(0) . This would cause the SSTORE2.read functions pointer.code.length - DATA_OFFSET computation, shown in gure 7.4, to underow, causing the SSTORE2.read operation to panic. function _deployFirst ( // [...] ) private returns ( address _pairAddress ) { { // [...] bytes memory _creationCode = BytesLib.concat( SSTORE2.read(contractAddress1), SSTORE2.read(contractAddress2) ); Figure 7.3: The _deployFirst function in FraxlendPairDeployer.sol#L212-L231 uint256 internal constant DATA_OFFSET = 1 ; function read ( address pointer ) internal view returns ( bytes memory ) { return readBytecode(pointer, DATA_OFFSET, pointer.code.length - DATA_OFFSET ); } Figure 7.4: The SSTORE2.read function from the solmate library Exploit Scenario Bob, the FraxlendPairDeployer contracts owner, wants to set the creation code to be a contract with fewer than 13,000 bytes. When he calls setCreationCode , it reverts. Recommendations Short term, make the following changes:   In setCreationCode , in the line that sets the _firstHalf variable, replace 13000 in the third argument of BytesLib.slice with min(13000, _creationCode.length) . In _deployFirst , add a check to ensure that the SSTORE2.read(contractAddress2) operation executes only if contractAddress2 is not address(0) . Alternatively, document the fact that it is not possible to deploy contracts with fewer than 13,000 bytes. Long term, improve the projects unit tests and fuzz tests to check that the functions behave as expected and cannot unexpectedly revert.", "labels": ["Trail of Bits", "Severity: Informational", "Difficulty: Undetermined"]}, {"title": "8. setCreationCode fails to overwrite _secondHalf slice if updated code size is less than 13,000 bytes ", "html_url": "https://github.com/trailofbits/publications/tree/master/reviews/2022-10-fraxfinance-fraxlend-fraxferry-securityreview.pdf", "body": "The setCreationCode function permits the owner of FraxlendPairDeployer to set the bytecode that will be used to create contracts for newly deployed pairs. If the _creationCode size is greater than 13,000 bytes, it will be split into two separate contracts ( contractAddress1 and contractAddress2 ). However (assuming that TOB-FXLEND-7 were xed), if a FraxlendPairDeployer owner were to change the creation code from one of greater than 13,000 bytes to one of fewer than 13,000 bytes, contractAddress2 would not be reset to address(0) ; therefore, contractAddress2 would still contain the second half of the previous creation code. function setCreationCode ( bytes calldata _creationCode) external onlyOwner { bytes memory _firstHalf = BytesLib.slice(_creationCode, 0 , 13000 ); contractAddress1 = SSTORE2.write(_firstHalf); if (_creationCode.length > 13000 ) { bytes memory _secondHalf = BytesLib.slice(_creationCode, 13000 , _creationCode.length - 13000 ); contractAddress2 = SSTORE2.write(_secondHalf); } } Figure 8.1: The setCreationCode function in FraxlendPairDeployer.sol#L173-L180 Exploit Scenario Bob, FraxlendPairDeployer s owner, changes the creation code from one of more than 13,000 bytes to one of less than 13,000 bytes. As a result, deploy and deployCustom deploy contracts with unexpected bytecode. Recommendations Short term, modify the setCreationCode function so that it sets contractAddress2 to address(0) at the beginning of the function . Long term, improve the projects unit tests and fuzz tests to check that the functions behave as expected and cannot unexpectedly revert.", "labels": ["Trail of Bits", "Severity: Informational", "Difficulty: High"]}, {"title": "9. Missing checks in setter functions ", "html_url": "https://github.com/trailofbits/publications/tree/master/reviews/2022-10-fraxfinance-fraxlend-fraxferry-securityreview.pdf", "body": "The setFee and setMinWaitPeriods functions do not have appropriate checks. First, the setFee function does not have an upper limit, which means that the Fraxferry owner can set enormous fees. Second, the setMinWaitPeriods function does not require the new value to be at least one hour. A minimum waiting time of less than one hour would invalidate important safety assumptions. For example, in the event of a reorganization on the source chain, the minimum one-hour waiting time ensures that only transactions after the reorganization are ferried (as described in the code comment in gure 9.1). ** - Reorgs on the source chain. Avoided, by only returning the transactions on the source chain that are at least one hour old. ** - Rollbacks of optimistic rollups. Avoided by running a node. ** - Operators do not have enough time to pause the chain after a fake proposal. Avoided by requiring a minimal amount of time between sending the proposal and executing it. // [...] function setFee ( uint _FEE ) external isOwner { FEE=_FEE; emit SetFee(_FEE); } function setMinWaitPeriods ( uint _MIN_WAIT_PERIOD_ADD , uint _MIN_WAIT_PERIOD_EXECUTE ) external isOwner { MIN_WAIT_PERIOD_ADD=_MIN_WAIT_PERIOD_ADD; MIN_WAIT_PERIOD_EXECUTE=_MIN_WAIT_PERIOD_EXECUTE; emit SetMinWaitPeriods(_MIN_WAIT_PERIOD_ADD, _MIN_WAIT_PERIOD_EXECUTE); } Figure 9.1: The setFee and setMinWaitPeriods functions in Fraxferry.sol#L226-L235 Exploit Scenario Bob, Fraxferry s owner, calls setMinWaitPeriods with a _MIN_WAIT_PERIOD_ADD value lower than 3,600 (one hour) , invalidating the waiting periods protection regarding chain reorganizations. Recommendations Short term, add an upper limit check to the setFee function; add a check to the setMinWaitPeriods function to ensure that _MIN_WAIT_PERIOD_ADD and _MIN_WAIT_PERIOD_EXECUTE are at least 3,600 (one hour). Long term, make sure that conguration variables can be set only to valid values.", "labels": ["Trail of Bits", "Severity: Informational", "Difficulty: Low"]}, {"title": "10. Risk of invalid batches due to unsafe cast in depart function ", "html_url": "https://github.com/trailofbits/publications/tree/master/reviews/2022-10-fraxfinance-fraxlend-fraxferry-securityreview.pdf", "body": "The depart function performs an unsafe cast operation that could result in an invalid batch. Users who want to send tokens to a certain chain use the various embark* functions. These functions eventually call embarkWithRecipient , which adds the relevant transactions to the transactions array. function embarkWithRecipient ( uint amount , address recipient ) public notPaused { // [...] transactions.push(Transaction(recipient,amountAfterFee, uint32 ( block.timestamp ))); } Figure 10.1: The embarkWithRecipient function in Fraxferry.sol#L127-L135 At a certain point, the captain role calls depart with the start and end indices within transactions to specify the transactions inside of a batch. However, the depart function performs an unsafe cast operation when creating the new batch; because of this unsafe cast operation, an end value greater than 2 ** 64 would be cast to a value lower than the start value, breaking the invariant that end is greater than or equal to start . function depart ( uint start , uint end , bytes32 hash ) external notPaused isCaptain { require ((batches.length== 0 && start== 0 ) || (batches.length> 0 && start==batches[batches.length- 1 ].end+ 1 ), \"Wrong start\" ); require (end>=start, \"Wrong end\" ); batches.push(Batch( uint64 (start), uint64 (end), uint64 ( block.timestamp ), 0 , hash )); emit Depart(batches.length- 1 ,start,end, hash ); } Figure 10.2: The depart function in Fraxferry.sol#L155-L160 If the resulting incorrect batch is not disputed by the crew member roles, which would cause the system to enter a paused state, the rst ocer role will call disembark to actually execute the transactions on the target chain. However, the disembark functions third check, highlighted in gure 10.3, on the invalid transaction will fail, causing the transaction to revert and the system to stop working until the incorrect batch is removed with a call to removeBatches . function disembark (BatchData calldata batchData) external notPaused isFirstOfficer { Batch memory batch = batches[executeIndex++]; require (batch.status== 0 , \"Batch disputed\" ); require (batch.start==batchData.startTransactionNo, \"Wrong start\" ); require (batch.start+batchData.transactions.length- 1 ==batch.end, \"Wrong size\" ); require ( block.timestamp -batch.departureTime>=MIN_WAIT_PERIOD_EXECUTE, \"Too soon\" ); // [...] } Figure 10.3: The disembark function in Fraxferry.sol#L162-L178 Exploit Scenario Bob, Fraxferry s captain, calls depart with an end value greater than 2 ** 64 , which is cast to a value less than start . As a consequence, the system becomes unavailable either because the crew members called disputeBatch or because the disembark function reverts. Recommendations Short term, replace the unsafe cast operation in the depart function with a safe cast operation to ensure that the end >= start invariant holds. Long term, implement robust unit tests and fuzz tests to check that important invariants hold.", "labels": ["Trail of Bits", "Severity: Informational", "Difficulty: Undetermined"]}, {"title": "11. Transactions that were already executed can be canceled ", "html_url": "https://github.com/trailofbits/publications/tree/master/reviews/2022-10-fraxfinance-fraxlend-fraxferry-securityreview.pdf", "body": "The Fraxferry contracts owner can call the jettison or jettisonGroup functions to cancel a transaction or a series of transactions, respectively. However, these functions incorrectly use the executeIndex variable to determine whether the given transaction has already been executed. As a result, it is possible to cancel an already executed transaction. The problem is that executeIndex tracks executed batches, not executed transactions. Because a batch can contain more than one transaction, the check in the _jettison function (gure 11.1) does not work correctly. function _jettison ( uint index , bool cancel ) internal { require (index>=executeIndex, \"Transaction already executed\" ); cancelled[index]=cancel; emit Cancelled(index,cancel); } function jettison ( uint index , bool cancel ) external isOwner { _jettison(index,cancel); } function jettisonGroup ( uint [] calldata indexes, bool cancel ) external isOwner { for ( uint i = 0 ;i<indexes.length;++i) { _jettison(indexes[i],cancel); } } Figure 11.1: The _jettison , jettison , and jettisonGroup functions in Fraxferry.sol#L208-L222 Note that canceling a transaction that has already been executed does not cancel its eects (i.e., the tokens were already sent to the receiver). Exploit Scenario Two batches of 10 transactions are executed; executeIndex is now 2 . Bob, Fraxferry s owner, calls jettison with an index value of 13 to cancel one of these transactions. The call to jettison should revert, but it is executed correctly. The emitted Cancelled event shows that a transaction that had already been executed was canceled, confusing the o-chain monitoring system. Recommendations Short term, use a dierent index in the jettison and jettisonGroup functions to track executed transactions. Long term, implement robust unit tests and fuzz tests to check that important invariants hold.", "labels": ["Trail of Bits", "Severity: Informational", "Difficulty: Undetermined"]}, {"title": "1. Project contains vulnerable dependencies ", "html_url": "https://github.com/trailofbits/publications/tree/master/reviews/2022-07-mobilecoin-securityreview.pdf", "body": "Running cargo-audit over the codebase revealed that the system under audit uses crates with Rust Security (RustSec) advisories and crates that are no longer maintained. RustSec ID", "labels": ["Trail of Bits", "Severity: Undetermined", "Difficulty: High"]}, {"title": "12. Lack of contract existence check on low-level call ", "html_url": "https://github.com/trailofbits/publications/tree/master/reviews/2022-10-fraxfinance-fraxlend-fraxferry-securityreview.pdf", "body": "The execute function includes a low-level call operation without a contract existence check; call operations return true even if the _to address is not a contract, so it is important to include contract existence checks alongside such operations. // Generic proxy function execute ( address _to , uint256 _value , bytes calldata _data) external isOwner returns ( bool , bytes memory ) { ( bool success , bytes memory result) = _to.call{value:_value}(_data); return (success, result); } Figure 12.1: The execute function in Fraxferry.sol#L274-L278 The Solidity documentation includes the following warning: The low-level functions call, delegatecall and staticcall return true as their first return value if the account called is non-existent, as part of the design of the EVM. Account existence must be checked prior to calling if needed. Figure 12.2: A snippet of the Solidity documentation detailing unexpected behavior related to call Exploit Scenario Bob, Fraxferry s owner, calls execute with _to set to an address that should be a contract; however, the contract was self-destructed. Even though the contract at this address no longer exists, the operation still succeeds. Recommendations Short term, implement a contract existence check before the call operation in the execute function. If the call operation is expected to send ETH to an externally owned address, ensure that the check is performed only if the _data.length is not zero. Long term, carefully review the Solidity documentation , especially the Warnings section.", "labels": ["Trail of Bits", "Severity: Informational", "Difficulty: High"]}, {"title": "13. Events could be improved ", "html_url": "https://github.com/trailofbits/publications/tree/master/reviews/2022-10-fraxfinance-fraxlend-fraxferry-securityreview.pdf", "body": "The events declared in the Fraxferry contract could be improved to be more useful to users and monitoring systems. Certain events could be more useful if they used the indexed keyword. For example, in the Embark event, the indexed keyword could be applied to the sender parameter. Additionally, SetCaptain , SetFirstOfficier , SetFee , and SetMinWaitPeriods could be more useful if they emitted the previous value in addition to the newly set one. event Embark ( address sender , uint index , uint amount , uint amountAfterFee , uint timestamp ); event Disembark ( uint start , uint end , bytes32 hash ); event Depart ( uint batchNo , uint start , uint end , bytes32 hash ); event RemoveBatch ( uint batchNo ); event DisputeBatch ( uint batchNo , bytes32 hash ); event Cancelled ( uint index , bool cancel ); event Pause ( bool paused ); event OwnerNominated ( address newOwner ); event OwnerChanged ( address previousOwner , address newOwner ); event SetCaptain ( address newCaptain ); event SetFirstOfficer ( address newFirstOfficer ); event SetCrewmember ( address crewmember , bool set ); event SetFee ( uint fee ); event SetMinWaitPeriods ( uint minWaitAdd , uint minWaitExecute ); Figure 13.1: Events declared in Fraxferry.sol#L83-L96 Recommendations Short term, add the indexed keyword to any events that could benet from it; modify events that report on setter operations so that they report the previous values in addition to the newly set values.", "labels": ["Trail of Bits", "Severity: Informational", "Difficulty: High"]}, {"title": "1. Hash collisions in untyped signatures Status: Resolved ", "html_url": "https://github.com/trailofbits/publications/tree/master/reviews/MesonProtocolFixReview.pdf", "body": "To post or execute a swap, a user must provide an ECDSA signature on a message containing the encoded swap information. The Meson protocol supports both typed (EIP-712) and legacy untyped (EIP-191) messages. The format of a message is determined by a bit in the encoded swap information itself. The Meson protocol denes two message types, a request message containing only an encoded swap and a release message containing the hash of an encoded swap concatenated with the recipients address. Figure 1.1 shows the relevant signature-verication code. 213 ... 237 238 239 function _checkRequestSignature( if (nonTyped) { bytes32 digest = keccak256(abi.encodePacked( bytes28(0x19457468657265756d205369676e6564204d6573736167653a0a3332), // HEX of \"\\x19Ethereum Signed Message:\\n32\" 240 241 242 243 244 ... 266 ... 293 294 295 encodedSwap )); require(signer == ecrecover(digest, v, r, s), \"Invalid signature\"); return; } function _checkReleaseSignature( if (nonTyped) { digest = keccak256(abi.encodePacked( bytes28(0x19457468657265756d205369676e6564204d6573736167653a0a3332), // HEX of \"\\x19Ethereum Signed Message:\\n32\" 296 297 ... keccak256(abi.encodePacked(encodedSwap, recipient)) )); Figure 1.1: contracts/utils/MesonHelpers.sol 11 Meson Protocol Fix Review Note that the form of both the request and release messages in the gure is \"\\x19Ethereum Signed Message:\\n32\" + msg, where msg is a 32-byte string. If an attacker could nd a message that would be interpreted as valid in both contexts, the attacker could use the signature on that message to both request and release funds, facilitating a number of potential attacks. Specically, the attacker would need to identify swap1, swap2, and recipient values such that swap1 = keccak256(swap2, recipient). The attacker could do that by choosing a valid swap2 value and then iterating through recipient values until nding one for which keccak256(swap2, recipient) would be interpreted as a valid message. With the current restrictions on the swap amount, chain, and token elds, we estimate that this would take between 260 and 270 tries. Fix Analysis This issue has been resolved. Untyped release messages are now prexed by the string \"\\x19Ethereum Signed Message:\\n52\", while request messages are prexed by \"\\x19Ethereum Signed Message:\\n32\". However, if Meson ever introduces new message types with a length of 32 or 53 bytes, their encodings may collide with the encodings of the existing message types. 12 Meson Protocol Fix Review", "labels": ["Trail of Bits", "Severity: Low", "Difficulty: High"]}, {"title": "2. Typed signatures implement insecure nonstandard encodings Status: Unresolved ", "html_url": "https://github.com/trailofbits/publications/tree/master/reviews/MesonProtocolFixReview.pdf", "body": "EIP-712 species standard encodings for the hashing and signing of typed structured data. The goal of typed structured signing standards is twofold: ensuring a unique injective encoding for structured data in order to prevent collisions (like that detailed in TOB-MES-1) and allowing wallets to display complex structured messages unambiguously in human-readable form. The images in gure 2.1 demonstrate the dierence between a complex untyped unstructured message (left) and its EIP-712 equivalent (right), both in MetaMask: Figure 2.1: A reproduction of images from the EIP-712 standard Meson currently uses a form of typed message encoding that does not conform to EIP-712. Specically, the encoding is not EIP-191 compliant and thus could theoretically collide with 13 Meson Protocol Fix Review the encoding of personal messages (Ethereum signed messages) or Recursive Length Prex (RLP)-encoded transactions. The digest format for swap requests is included in gure 2.2, in which REQUEST_TYPE_HASH corresponds to keccak256(\"bytes32 Sign to request a swap on Meson (Testnet)\"). bytes32 typehash = REQUEST_TYPE_HASH; bytes32 digest; 246 247 248 assembly { 249 250 251 252 253 } mstore(0, encodedSwap) mstore(32, keccak256(0, 32)) mstore(0, typehash) digest := keccak256(0, 64) Figure 2.2: contracts/utils/MesonHelpers.sol#246253 While the message types currently used in the protocol do not appear to have any dangerous interactions with each other, message types added to future versions of the protocol could theoretically introduce such issues. Fix Analysis This issue has not been resolved. Although the issue is not currently exploitable, we recommend that Meson exercise caution when adding new message types to prevent unexpected collisions between those message types and message types used by other protocols. 14 Meson Protocol Fix Review", "labels": ["Trail of Bits", "Severity: Informational", "Difficulty: High"]}, {"title": "3. Missing validation in the _addSupportToken function Status: Resolved ", "html_url": "https://github.com/trailofbits/publications/tree/master/reviews/MesonProtocolFixReview.pdf", "body": "Insucient input validation in the _addSupportToken function makes it possible to register the same token as supported multiple times. This does not cause a problem, because if there are duplicate entries for a token in the token list, the last one added will be the one that is used. However, it does mean that multiple indexes could point to the same token, while the token would point to only one of those indexes. function _addSupportToken(address token, uint8 index) internal { require(index != 0, \"Cannot use 0 as token index\"); _indexOfToken[token] = index; _tokenList[index] = token; 47 48 49 50 51 } Figure 3.1: contracts/utils/MesonTokens.sol Fix Analysis This issue has been resolved. The _addSupportToken function now validates that the token has not previously been registered, that the associated list index has not previously been used, and that the tokens address is not zero. The Meson team has also added tests to validate this behavior. 15 Meson Protocol Fix Review 4. Insu\u0000cient event generation Status: Resolved Severity: Informational Diculty: Low Type: Auditing and Logging Finding ID: TOB-MES-4 Target: contracts/Pools/MesonPools.sol", "labels": ["Trail of Bits", "Severity: Informational", "Difficulty: High"]}, {"title": "5. Use of an uninitialized state variable in functions Status: Resolved ", "html_url": "https://github.com/trailofbits/publications/tree/master/reviews/MesonProtocolFixReview.pdf", "body": "The _mesonContract address is not set in the UCTUpgradeable contracts initialize function during the contracts initialization. As a result, the value of _mesonContract defaults to the zero address. The UCTUpgradeable.allowance and UCTUpgradeable.transferFrom functions perform checks that rely on the value of the _mesonContract state variable, which may lead to unexpected behavior. address private _mesonContract; function initialize(address minter) public initializer { __ERC20_init(\"USD Coupon Token (https://meson.fi)\", \"UCT\"); _owner = _msgSender(); _minter = minter; // _mesonContract = ; 18 19 20 21 22 23 24 25 } Figure 5.1: contracts/Token/UCTUpgradeable.sol:1825 54 function allowance(address owner, address spender) public view override returns (uint256) { 55 if (spender == _mesonContract) { Figure 5.2: contracts/Token/UCTUpgradeable.sol:5455 65 if (msgSender == _mesonContract && ERC20Upgradeable.allowance(sender, msgSender) < amount) { Figure 5.3: contracts/Token/UCTUpgradeable.sol:65 Fix Analysis This issue has been resolved. The _mesonContract address is now populated by the initialize function. 17 Meson Protocol Fix Review", "labels": ["Trail of Bits", "Severity: Medium", "Difficulty: High"]}, {"title": "6. Risk of upgrade issues due to missing __gap variable Status: Resolved ", "html_url": "https://github.com/trailofbits/publications/tree/master/reviews/MesonProtocolFixReview.pdf", "body": "None of the Meson protocol contracts include a __gap variable. Without this variable, it is not possible to add any new variables to the inherited contracts without causing storage slot issues. Specically, if variables are added to an inherited contract, the storage slots of all subsequent variables in the contract will shift by the number of variables added. Such a shift would likely break the contract. All upgradeable OpenZeppelin contracts contain a __gap variable, as shown in gure 6.1. 89 90 /** * @dev This empty reserved space is put in place to allow future versions to add new 91 92 93 94 * variables without shifting down storage in the inheritance chain. * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps */ uint256[49] private __gap; Figure 6.1: openzeppelin-contracts-upgradeable/OwnerUpgradeable.sol Fix Analysis This issue has been resolved. All stateful contracts inherited by UpgradableMeson now contain gap slots. Thus, new state variables can be added in future upgrades. 18 Meson Protocol Fix Review", "labels": ["Trail of Bits", "Severity: High", "Difficulty: Low"]}, {"title": "7. Lack of a zero-value check on the initialize function Status: Partially Resolved ", "html_url": "https://github.com/trailofbits/publications/tree/master/reviews/MesonProtocolFixReview.pdf", "body": "The UCTUpgradeable contracts initialize function fails to validate the address of the incoming minter argument. This means that the caller can accidentally set the minter variable to the zero address. function initialize(address minter) public initializer { __ERC20_init(\"USD Coupon Token (https://meson.fi)\", \"UCT\"); _owner = _msgSender(); _minter = minter; // _mesonContract = ; 20 21 22 23 24 25 } Figure 7.1: contracts/Token/UCTUpgradeable.sol:2025 If the minter address is set to the zero address, the admin must immediately redeploy the contract and set the address to the correct value; a failure to do so could result in unexpected behavior. Fix Analysis This issue has been partially resolved. The _mesonContract address, added as a parameter in the resolution of TOB-MES-5, is now checked against the zero value. However, the initialize function does not validate that the minter address is non-zero. 19 Meson Protocol Fix Review", "labels": ["Trail of Bits", "Severity: Informational", "Difficulty: Low"]}, {"title": "8. Solidity compiler optimizations can be problematic Status: Resolved ", "html_url": "https://github.com/trailofbits/publications/tree/master/reviews/MesonProtocolFixReview.pdf", "body": "The Meson protocol has enabled optional compiler optimizations in Solidity. There have been several optimization bugs with security implications. Moreover, optimizations are actively being developed. Solidity compiler optimizations are disabled by default, and it is unclear how many contracts in the wild actually use them. Therefore, it is unclear how well they are being tested and exercised. High-severity security issues due to optimization bugs have occurred in the past. A high-severity bug in the emscripten-generated solc-js compiler used by True and Remix persisted until late 2018. The x for this bug was not reported in the Solidity CHANGELOG. Another high-severity optimization bug resulting in incorrect bit shift results was patched in Solidity 0.5.6. More recently, another bug due to the incorrect caching of keccak256 was reported. A compiler audit of Solidity from November 2018 concluded that the optional optimizations may not be safe. It is likely that there are latent bugs related to optimization and that new bugs will be introduced due to future optimizations. Fix Analysis This issue has been resolved. The Solidity optimizer in the commit evaluated in this x review has been disabled. However, the Meson team indicated that this change causes the deployment gas amount to exceed the block gas limit. We recommend that Meson closely follow Solidity compiler releases and CHANGELOGs in order to quickly resolve any compiler optimization bugs. 20 Meson Protocol Fix Review", "labels": ["Trail of Bits", "Severity: Medium", "Difficulty: Low"]}, {"title": "9. Service fees cannot be withdrawn Status: Resolved ", "html_url": "https://github.com/trailofbits/publications/tree/master/reviews/MesonProtocolFixReview.pdf", "body": "If the service fee charged for a swap is waived, the fee collected for the swap is stored at index zero of the _balanceOfPoolToken mapping. However, because the fee withdrawal function does not allow withdrawals from index zero of the mapping, the fee can never be withdrawn. Although this limitation may be purposeful, the code appears to indicate that it is a mistake. 198 if (!feeWaived) { // If the swap should pay service fee (charged by Meson protocol) 199 200 201 202 uint256 serviceFee = _serviceFee(encodedSwap); // Subtract service fee from the release amount releaseAmount -= serviceFee; // The collected service fee will be stored in `_balanceOfPoolToken` with `poolIndex = 0` 203 _balanceOfPoolToken[_poolTokenIndexForOutToken(encodedSwap, 0)] += serviceFee; Figure 9.1: contracts/Pools/MesonPools.sol:198203 70 71 72 73 74 function withdraw(uint256 amount, uint48 poolTokenIndex) external { require(amount > 0, \"Amount must be positive\"); uint40 poolIndex = _poolIndexFrom(poolTokenIndex); require(poolIndex != 0, \"Cannot use 0 as pool index\"); Figure 9.2: contracts/Pools/MesonPools.sol:7074 Moreover, even if the function allowed the withdrawal of tokens stored at poolIndex 0, a withdrawal would still not be possible. This is because the owner of poolIndex 0 is not set during initialization, and it is not possible to register a pool with index 0. 13 14 function initialize(address[] memory supportedTokens) public { require(!_initialized, \"Contract instance has already been initialized\"); 21 Meson Protocol Fix Review _initialized = true; _owner = _msgSender(); _premiumManager = _msgSender(); for (uint8 i = 0; i < supportedTokens.length; i++) { _addSupportToken(supportedTokens[i], i + 1); 15 16 17 18 19 20 21 22 } } Figure 9.3: contracts/UpgradableMeson.sol:1322 Fix Analysis This issue has been resolved. The source code now includes comments explaining that the service fee will not be withdrawable until the contract is updated. 22 Meson Protocol Fix Review", "labels": ["Trail of Bits", "Severity: Medium", "Difficulty: High"]}, {"title": "10. Lack of contract existence check on transfer / transferFrom calls Status: Resolved ", "html_url": "https://github.com/trailofbits/publications/tree/master/reviews/MesonProtocolFixReview.pdf", "body": "The MesonHelpers contract uses the low-level call function to execute the transfer / transferFrom function of an ERC20 token. However, it does not rst perform a contract existence check. Thus, if there is no contract at the token address, the low-level call will still return success. This means that if a supported token is subsequently self-destructed (which is unlikely to happen), it will be possible for a posted swap involving that token to succeed without actually depositing any tokens. function _unsafeDepositToken( address token, address sender, uint256 amount, bool isUCT 53 54 55 56 57 58 ) internal { 59 60 61 62 require(token != address(0), \"Token not supported\"); require(amount > 0, \"Amount must be greater than zero\"); (bool success, bytes memory data) = token.call(abi.encodeWithSelector( bytes4(0x23b872dd), // bytes4(keccak256(bytes(\"transferFrom(address,address,uint256)\"))) 63 64 65 66 sender, address(this), amount // isUCT ? amount : amount * 1e12 // need to switch to this line if deploying to BNB Chain or Conflux 67 68 )); require(success && (data.length == 0 || abi.decode(data, (bool))), \"transferFrom failed\"); 69 } Figure 10.1: contracts/util/MesonHelpers.sol:5369 The Solidity documentation includes the following warning: The low-level functions call, delegatecall and staticcall return true as their first 23 Meson Protocol Fix Review return value if the account called is non-existent, as part of the design of the EVM. Account existence must be checked prior to calling if needed. Figure 10.2: A snippet of the Solidity documentation detailing unexpected behavior related to call Fix Analysis This issue has been resolved. The low-level call is now paired with OpenZeppelins Address.isContract function, which ensures that the contract at the target address is populated as expected. This makes the deposit mechanism robust against self-destructs. 24 Meson Protocol Fix Review", "labels": ["Trail of Bits", "Severity: Low", "Difficulty: Medium"]}, {"title": "11. USDT transfers to third-party contracts will fail Status: Resolved ", "html_url": "https://github.com/trailofbits/publications/tree/master/reviews/MesonProtocolFixReview.pdf", "body": "To allow a user to release funds to a smart contract, the Meson protocol increases the contracts allowance (via a call to increaseAllowance) and then calls the contract, as shown in gure 11.1. 66 IERC20Minimal(token).increaseAllowance(contractAddr, adjustedAmount); 67 ITransferWithBeneficiary(contractAddr).transferWithBeneficiary(token, adjustedAmount, beneficiary, data); Figure 11.1: contracts/utils/MesonHelpers.sol#6667 The increaseAllowance method, which is part of OpenZeppelins ERC20 library, was introduced to prevent race conditions when token allowances are changed via top-level calls. However, this method is not in the ERC20 specication, and not all tokens implement it. In particular, USDT does not implement the method on the Ethereum mainnet. Thus, any attempt to release USDT to a smart contract wallet during a swap will fail, trapping the users funds. Fix Analysis This issue has been resolved. The protocol now uses the standard ERC20 approve function to increase allowances. The team also made subtle changes to the allowance behavior: instead of incrementing an allowance when executing a transfer, the Meson contract now sets the allowance to the most recent transfer amount. If a third-party contract has an outstanding allowance from a previous swap release, it will forfeit those tokens upon the next transfer. Meson has conrmed that this is the intended behavior. 25 Meson Protocol Fix Review", "labels": ["Trail of Bits", "Severity: High", "Difficulty: Low"]}, {"title": "12. SDK function _randomHex returns low-quality randomness Status: Partially Resolved ", "html_url": "https://github.com/trailofbits/publications/tree/master/reviews/MesonProtocolFixReview.pdf", "body": "The Meson protocol software development kit (SDK) uses the _randomHex function to generate random salts for new swaps. This function accepts a string length as input and produces a random hexadecimal string of that length. To do that, _randomHex uses the JavaScript Math.random function to generate a 32-bit integer and then encodes the integer as a zero-padded hexadecimal string. The result is eight random hexadecimal characters, padded with zeros to the desired length. However, the function is called with an argument of 16, so half of the characters in the salt it produces will be zero. } 95 96 97 98 99 100 101 102 103 104 } 105 106 107 108 109 110 111 112 113 } private _makeFullSalt(salt?: string): string { if (salt) { if (!isHexString(salt) || salt.length > 22) { throw new Error('The given salt is invalid') } return `${salt}${this._randomHex(22 - salt.length)}` return `0x0000${this._randomHex(16)}` private _randomHex(strLength: number) { if (strLength === 0) { return '' } const max = 2 ** Math.min((strLength * 4), 32) const rnd = BigNumber.from(Math.floor(Math.random() * max)) return hexZeroPad(rnd.toHexString(), strLength / 2).replace('0x', '') Figure 12.1: packages/sdk/src/Swap.ts#95113 Furthermore, the Math.random function is not suitable for uses in which the output of the random number generator should be unpredictable. While the protocols current use of the function does not pose a security risk, future implementers and library users may assume that the function produces the requested amount of high-quality entropy. 26 Meson Protocol Fix Review Fix Analysis This issue has been partially resolved. While the _randomHex function now uses cryptographic randomness to generate random hexadecimal characters, the function continues to silently output leading zeros when more than eight characters are requested or when an odd number of characters is requested. To prevent future misuse of this function, we recommend having it return a uniformly random string with the exact number of characters requested. 27 Meson Protocol Fix Review", "labels": ["Trail of Bits", "Severity: Undetermined", "Difficulty: Undetermined"]}, {"title": "13. encodedSwap values are used as primary swap identier Status: Unresolved ", "html_url": "https://github.com/trailofbits/publications/tree/master/reviews/MesonProtocolFixReview.pdf", "body": "The primary identier of swaps in the MesonSwap contract is the encodedSwap structure. This structure does not contain the address of a swaps initiator, which is recorded, along with the poolIndex of the bonded liquidity provider (LP), as the postingValue. If a malicious actor or maximal extractable value (MEV) bot were able to front-run a users transaction and post an identical encodedSwap, the original initiators transaction would fail, and the initiators swap would not be posted. 48 function postSwap(uint256 encodedSwap, bytes32 r, bytes32 s, uint8 v, uint200 postingValue) external forInitialChain(encodedSwap) 49 50 { 51 require(_postedSwaps[encodedSwap] == 0, \"Swap already exists\"); ... Figure 13.1: contracts/Swap/MesonSwap.sol#4852 Because the Meson protocol supports only 1-to-1 stablecoin swaps, transaction front-running is unlikely to be protable. However, a bad actor could dramatically aect a specic users ability to transact within the system. Fix Analysis This issue has not been resolved. Meson acknowledged that user transactions can be blocked from execution by malicious actors. However, blocking a swap transaction would require an adversary to post a corresponding swap, and to thus burn gas and have his or her funds temporarily locked; these disincentives limit the impact of this issue. 28 Meson Protocol Fix Review", "labels": ["Trail of Bits", "Severity: Low", "Difficulty: High"]}, {"title": "14. Unnecessary _releasing mutex increases gas costs Status: Resolved ", "html_url": "https://github.com/trailofbits/publications/tree/master/reviews/MesonProtocolFixReview.pdf", "body": "When executing a swap in the third-party dApp integration release mode, the Meson protocol makes a call to an untrusted user-specied smart contract. To prevent reentrancy attacks, a ag is set before and cleared after the untrusted contract call. 181 ... require(!_releasing, \"Another release is running\"); 219 220 _transferToContract(_tokenList[tokenIndex], recipient, initiator, amount, _releasing = true; tokenIndex == 255, _saltDataFrom(encodedSwap)); 221 _releasing = false; Figure 14.1: contracts/Pools/MesonPools.sol#181221 This ag is not strictly necessary, as by the time the contract reaches the untrusted call, it has already cleared the _lockSwaps entry corresponding to the release, preventing duplicate releases via reentrancy. uint80 lockedSwap = _lockedSwaps[swapId]; require(lockedSwap != 0, \"Swap does not exist\"); 191 192 ... 196 _checkReleaseSignature(encodedSwap, recipient, r, s, v, initiator); 197 ... 211 _release(encodedSwap, tokenIndex, initiator, recipient, releaseAmount); _lockedSwaps[swapId] = 0; Figure 14.2: contracts/Pools/MesonPools.sol#191197 Fix Analysis This issue has been resolved. The redundant _releasing ag has been removed. The call to the external contract is the last step in the transaction, which prevents reentrancy attacks. 29 Meson Protocol Fix Review", "labels": ["Trail of Bits", "Severity: Informational", "Difficulty: Low"]}, {"title": "3. Missing validation in the _addSupportToken function Status: Resolved ", "html_url": "https://github.com/trailofbits/publications/tree/master/reviews/MesonProtocolFixReview.pdf", "body": "Insucient input validation in the _addSupportToken function makes it possible to register the same token as supported multiple times. This does not cause a problem, because if there are duplicate entries for a token in the token list, the last one added will be the one that is used. However, it does mean that multiple indexes could point to the same token, while the token would point to only one of those indexes. function _addSupportToken(address token, uint8 index) internal { require(index != 0, \"Cannot use 0 as token index\"); _indexOfToken[token] = index; _tokenList[index] = token; 47 48 49 50 51 } Figure 3.1: contracts/utils/MesonTokens.sol Fix Analysis This issue has been resolved. The _addSupportToken function now validates that the token has not previously been registered, that the associated list index has not previously been used, and that the tokens address is not zero. The Meson team has also added tests to validate this behavior. 15 Meson Protocol Fix Review", "labels": ["Trail of Bits", "Severity: High", "Difficulty: High"]}, {"title": "4. Insu\u0000cient event generation Status: Resolved ", "html_url": "https://github.com/trailofbits/publications/tree/master/reviews/MesonProtocolFixReview.pdf", "body": "Several critical operations in the MesonPools contract do not emit events. As a result, it will be dicult to review the correct behavior of the contract once it has been deployed. The following operations should trigger events:  MesonPools.depositAndRegister  MesonPools.deposit  MesonPools.withdraw  MesonPools.addAuthorizedAddr  MesonPools.removeAuthorizedAddr  MesonPools.unlock Without events, users and blockchain-monitoring systems cannot easily detect suspicious behavior and may therefore overlook attacks or malfunctioning contracts. Fix Analysis This issue has been resolved. All of the functions listed in this nding now emit events, enabling Meson and protocol users to easily track all contract operations. 16 Meson Protocol Fix Review", "labels": ["Trail of Bits", "Severity: High", "Difficulty: High"]}, {"title": "15. Misleading result returned by view function getPostedSwap Status: Resolved ", "html_url": "https://github.com/trailofbits/publications/tree/master/reviews/MesonProtocolFixReview.pdf", "body": "The value returned by the getPostedSwap function to indicate whether a swap has been executed can be misleading. Once a swap has been executed, the value of the swap is reset to either 0 or 1. However, the getPostedSwap function returns a result indicating that a swap has been executed only if the swaps value is 1. if (_expireTsFrom(encodedSwap) < block.timestamp + MIN_BOND_TIME_PERIOD) { // The swap cannot be posted again and therefore safe to remove it. // LPs who execute in this mode can save ~5000 gas. _postedSwaps[encodedSwap] = 0; 141 142 143 144 145 } else { 146 // The same swap information can be posted again, so set `_postedSwaps` value to 1 to prevent that. 147 148 } _postedSwaps[encodedSwap] = 1; Figure 15.1: contracts/Swap/MesonSwap.sol:140148 161 162 163 164 { 165 166 167 168 169 170 171 172 173 } /// @notice Read information for a posted swap function getPostedSwap(uint256 encodedSwap) external view returns (address initiator, address poolOwner, bool executed) uint200 postedSwap = _postedSwaps[encodedSwap]; initiator = _initiatorFromPosted(postedSwap); executed = postedSwap == 1; if (initiator == address(0)) { poolOwner = address(0); } else { } poolOwner = ownerOfPool[_poolIndexFromPosted(postedSwap)]; Figure 15.2: contracts/Swap/MesonSwap.sol:162173 30 Meson Protocol Fix Review Front-end services (or any other service interacting with this function) may be misled by the return value, reacting as though a swap has not been executed when it actually has. Fix Analysis This issue has been resolved. The getPostedSwap functions return value has been renamed to exist, which more accurately reects the meaning of the value. 31 Meson Protocol Fix Review A. Status Categories The following table describes the statuses used to indicate whether an issue has been suciently addressed. Fix Status Status", "labels": ["Trail of Bits", "Severity: Low", "Difficulty: Low"]}, {"title": "1. Attackers can prevent lenders from funding or renancing loans ", "html_url": "https://github.com/trailofbits/publications/tree/master/reviews/MapleFinance.pdf", "body": "For the MapleLoan contracts fundLoan method to fund a new loan, the balance of fundsAsset in the contract must be equal to the requested principal. // Amount funded and principal are as requested. amount_ = _principal = _principalRequested; // Cannot under/over fund loan, so that accounting works in context of PoolV1 require (_getUnaccountedAmount(_fundsAsset) == amount_, \"MLI:FL:WRONG_FUND_AMOUNT\" ); Figure 1.1: An excerpt of the fundLoan function ( contracts/MapleLoanInternals.sol#240244 ) An attacker could prevent a lender from funding a loan by making a small transfer of fundsAsset every time the lender tried to fund it (front-running the transaction). However, transaction fees would make the attack expensive. A similar issue exists in the Refinancer contract: If the terms of a loan were changed to increase the borrowed amount, an attacker could prevent a lender from accepting the new terms by making a small transfer of fundsAsset . The underlying call to increasePrincipal from within the acceptNewTerms function would then cause the transaction to revert. function increasePrincipal ( uint256 amount_ ) external override { require (_getUnaccountedAmount(_fundsAsset) == amount_, \"R:IP:WRONG_AMOUNT\" ); _principal += amount_; _principalRequested += amount_; _drawableFunds += amount_; emit PrincipalIncreased(amount_); 13 Maple Labs } Figure 1.2: The vulnerable method in the Refinancer contract ( contracts/Refinancer.sol#2330 ) Exploit Scenario A borrower tries to quickly increase the principal of a loan to take advantage of a short-term high-revenue opportunity. The borrower proposes new terms, and the lender tries to accept them. However, an attacker blocks the process and performs the protable operation himself. Recommendations Short term, allow the lender to withdraw funds in excess of the expected value (by calling getUnaccountedAmount(fundsAsset) ) before a loan is funded and between the proposal and acceptance of new terms. Alternatively, have fundLoan and increasePrincipal use greater-than-or-equal-to comparisons, rather than strict equality comparisons, to check whether enough tokens have been transferred to the contract; if there are excess tokens, use the same function to transfer them to the lender. Long term, avoid using exact comparisons for ether and token balances, as users can increase those balances by executing transfers, making the comparisons evaluate to false . 14 Maple Labs", "labels": ["Trail of Bits", "Severity: High", "Difficulty: High"]}, {"title": "2. Reentrancies can lead to misordered events ", "html_url": "https://github.com/trailofbits/publications/tree/master/reviews/MapleFinance.pdf", "body": "Several functions in the codebase do not use the checks-eects-interactions pattern, lack reentrancy guards, or emit events after interactions. These functions interact with external and third-party contracts that can execute callbacks and call the functions again (reentering them). The event for a reentrant call will be emitted before the event for the rst call, meaning that o-chain event monitors will observe incorrectly ordered events. function liquidatePortion ( uint256 swapAmount_ , bytes calldata data_) external override { ERC20Helper.transfer(collateralAsset, msg.sender , swapAmount_); msg.sender .call(data_); uint256 returnAmount = getExpectedAmount(swapAmount_); require (ERC20Helper.transferFrom(fundsAsset, msg.sender , destination, returnAmount), \"LIQ:LP:TRANSFER_FROM\" ); emit PortionLiquidated(swapAmount_, returnAmount); } Figure 2.1: The liquidatePortion function ( contracts/Liquidator.sol#4151 ) We identied this issue in the following functions:  DebtLocker  setAuctioneer  _handleClaim  _handleClaimOfReposessed  acceptNewTerms  Liquidator  liquidatePortion  pullFunds  MapleLoan 15 Maple Labs  acceptNewTerms  closeLoan  fundLoan  makePayment  postCollateral  returnFunds  skim  upgrade Exploit Scenario Alice calls Liquidator.liquidatePortion (gure 2.1). Since fundsAsset is an ERC777 token (or another token that allows callbacks), a callback function that Alice has registered on ERC20Helper.transfer is called. Alice calls Liquidator.liquidatePortion again from within that callback function. The event for the second liquidation is emitted before the event for the rst liquidation. As a result, the events observed by o-chain event monitors are incorrectly ordered. Recommendations Short term, follow the checks-eects-interactions pattern and ensure that all functions emit events before interacting with other contracts that may allow reentrancies. Long term, integrate Slither into the CI pipeline. Slither can detect low-severity reentrancies like those mentioned in this nding as well as high-severity reentrancies. Use reentrancy guards on all functions that interact with other contracts. 16 Maple Labs", "labels": ["Trail of Bits", "Severity: Low", "Difficulty: Medium"]}, {"title": "3. Lack of two-step process for critical operations ", "html_url": "https://github.com/trailofbits/publications/tree/master/reviews/MapleFinance.pdf", "body": "The MapleLoan contracts setBorrower and setLender functions transfer the privileged borrower and lender roles to new addresses. If, because of a bug or a mistake, one of those functions is called with an address inaccessible to the Maple Labs team, the transferred role will be permanently inaccessible. It may be possible to restore access to the lender role by upgrading the loan contract to a new implementation. However, only the borrower can upgrade a loan contract, so no such bailout option exists for a transfer of the borrower role to an inaccessible address. Using a two-step process for role transfers would prevent such issues. Exploit Scenario Alice, the borrower of a Maple loan, notices that her borrower address key might have been compromised. To be safe, she calls MapleLoan.setBorrower with a new address. Because of a bug in the script that she uses to set the new borrower, the new borrower is set to an address for which Alice does not have the private key. As a result, she is no longer able to access her loan contract. Recommendations Short term, perform role transfers through a two-step process in which the borrower or lender proposes a new address and the transfer is completed once the new address has executed a call to accept the role. Long term, investigate whether implementing additional two-step processes could prevent any other accidental lockouts. 17 Maple Labs", "labels": ["Trail of Bits", "Severity: Low", "Difficulty: High"]}, {"title": "4. IERC20Like.decimals returns non-standard uint256 ", "html_url": "https://github.com/trailofbits/publications/tree/master/reviews/MapleFinance.pdf", "body": "IERC20Like.decimal s declares uint256 as its return type, whereas the ERC20 standard species that it must return a uint8 . As a result, functions that use the IERC20Like interface interpret the values returned by decimals as uint256 values; this can cause values greater than 255 to enter the protocol, which could lead to undened behavior. If the return type were uint8 , only the last byte of the return value would be used. Exploit Scenario A non-standard token with a decimals function that returns values greater than 255 is integrated into the protocol. The code is not prepared to handle decimals values greater than 255. As a result of the large value, the arithmetic becomes unstable, enabling an attacker to drain funds from the protocol. Recommendations Short term, change the return type of IERC20.decimals to uint8 . Long term, ensure that all interactions with ERC20 tokens follow the standard. 18 Maple Labs", "labels": ["Trail of Bits", "Severity: Informational", "Difficulty: High"]}, {"title": "5. Transfers in Liquidator.liquidatePortion can fail silently ", "html_url": "https://github.com/trailofbits/publications/tree/master/reviews/MapleFinance.pdf", "body": "Calls to ERC20Helper.transfer in the codebase are wrapped in require statements, except for the rst such call in the liquidatePortion function of the Liquidator contract (gure 5.1). As such, a token transfer executed through this call can fail silently, meaning that liquidatePortion can take a user's funds without providing any collateral in return. This contravenes the expected behavior of the function and the behavior outlined in the docstring of ILiquidator.liquidatePortion (gure 5.2). function liquidatePortion ( uint256 swapAmount_ , bytes calldata data_) external override { ERC20Helper.transfer (collateralAsset, msg.sender , swapAmount_); msg.sender .call(data_); uint256 returnAmount = getExpectedAmount(swapAmount_); require (ERC20Helper.transferFrom(fundsAsset, msg.sender , destination, returnAmount), \"LIQ:LP:TRANSFER_FROM\" ); emit PortionLiquidated(swapAmount_, returnAmount); } Figure 5.1: The liquidatePortion function ( contracts/Liquidator.sol#4151 ) * @dev Flash loan function that : * @dev 1 . Transfers a specified amount of `collateralAsset` to ` msg.sender `. * @dev 2 . Performs an arbitrary call to ` msg.sender `, to trigger logic necessary to get `fundsAsset` (e.g., AMM swap). * @dev 3 . Perfroms a `transferFrom`, taking the corresponding amount of `fundsAsset` from the user. * @dev If the required amount of `fundsAsset` is not returned in step 3 , the entire transaction reverts. * @param swapAmount_ Amount of `collateralAsset` that is to be borrowed in the flashloan. * @param data_ 2 . ABI-encoded arguments to be used in the low-level call to perform step 19 Maple Labs */ Figure 5.2: Docstring of liquidatePortion ( contracts/interfaces/ILiquidator.sol#7683 ) Exploit Scenario A loan is liquidated, and its liquidator contract has a collateral balance of 300 ether. The current ether price is 4,200 USDC. Alice wants to prot o of the liquidation by taking out a ash loan of 300 ether. Having checked that the contract holds enough collateral to cover the transaction, she calls liquidatePortion(1260000, ) in the liquidator contract. At the same time, Bob decides to buy 10 ether from the liquidator contract. Bob calls Liquidator.liquidatePortion(42000) . Because his transaction is mined rst, the liquidator does not have enough collateral to complete the transfer of collateral to Alice. As a result, the liquidator receives a transfer of 1,260,000 USDC from Alice but does not provide any ether in return, leaving her with a $1,260,000 loss. Recommendations Short term, wrap ERC20Helper.transfer in a require statement to ensure that a failed transfer causes the entire transaction to revert. Long term, ensure that a failed transfer of tokens to or from a user always causes the entire transaction to revert. To do that, follow the recommendations outlined in TOB-MAPLE-006 and have the ERC20Helper.transfer and ERC20Helper.transferFrom functions revert on a failure. Ensure that all functions behave as expected , that their behavior remains predictable when transactions are reordered, and that the code does not contain any footguns or surprises. 20 Maple Labs", "labels": ["Trail of Bits", "Severity: Informational", "Difficulty: Low"]}, {"title": "6. ERC20Helpers functions do not revert on a failure ", "html_url": "https://github.com/trailofbits/publications/tree/master/reviews/MapleFinance.pdf", "body": "The ERC20Helper contracts transfer , transferFrom , and approve functions do not revert on a failure. This makes it necessary for the developer to always check their return values. A failure to perform these checks can result in the introduction of high-severity bugs that can lead to a loss of funds. There are no uses of ERC20Helper.transfer for which not reverting on a failure is the best option. Making this standard behavior the default would make the code more robust and therefore more secure by default, as it would take less additional eort to make it secure. In the rare edge cases in which a transfer is allowed to fail or a failure status should be captured in a boolean, a try / catch statement can be used. Exploit Scenario Bob, a developer, writes a new function. He calls ERC20Helper.transfer but forgets to wrap the call in a require statement. As a result, token transfers can fail silently and lead to a loss of funds if that failure behavior is not accounted for. Recommendations Short term, have ERC20Helper.transfer , ERC20Helper.transferFrom , and ERC20Helper.approve revert on a failure. Long term, have all functions revert on a failure instead of returning false . Aim to make code secure by default so that less additional work will be required to make it secure. Additionally, whenever possible, avoid using optimizations that are detrimental to security. 21 Maple Labs", "labels": ["Trail of Bits", "Severity: Informational", "Difficulty: High"]}, {"title": "7. Lack of contract existence checks before low-level calls ", "html_url": "https://github.com/trailofbits/publications/tree/master/reviews/MapleFinance.pdf", "body": "The ERC20Helper contract lls a purpose similar to that of OpenZeppelin's SafeERC20 contract. However, while OpenZeppelin's SafeERC20 transfer and approve functions will revert when called on an address that is not a token contract address (i.e., one with zero-length bytecode), ERC20Helper s functions will appear to silently succeed without transferring or approving any tokens. If the address of an externally owned account (EOA) is used as a token address in the protocol, all transfers to it will appear to succeed without any tokens being transferred. This will result in undened behavior. Contract existence checks are usually performed via the EXTCODESIZE opcode. Since the EXTCODESIZE opcode would precede a CALL to a token address, adding EXTCODESIZE would make the CALL a warm access. As a result, adding the EXTCODESIZE check would increase the gas cost by only a little more than 100. Assuming a high gas price of 200 gwei and a current ether price of $4,200, that equates to an additional cost of 10 cents for each call to the functions of ERC20Helper , which is a low price to pay for increased security. The following functions lack contract existence checks:  ERC20Helper  call in _call  ProxyFactory  call in _initializeInstance  call in _upgradeInstance (line 66)  call in _upgradeInstance (line 72)  Proxied  delegatecall in _migrate  Proxy  delegatecall in _ fallback 22 Maple Labs  MapleLoanInternals  delegatecall in _acceptNewTerms Exploit Scenario A token contract is destroyed. However, since all transfers of the destroyed token will succeed, all Maple protocol users can transact as though they have an unlimited balance of that token. If contract existence checks were executed before those transfers, all transfers of the destroyed token would revert. Recommendations Short term, add a contract existence check before each of the low-level calls mentioned above. Long term, add contract existence checks before all low-level CALL s, DELEGATECALL s, and STATICCALL s. These checks are inexpensive and add an important layer of defense. 23 Maple Labs", "labels": ["Trail of Bits", "Severity: Informational", "Difficulty: High"]}, {"title": "8. Missing zero checks ", "html_url": "https://github.com/trailofbits/publications/tree/master/reviews/MapleFinance.pdf", "body": "A number of constructors and functions in the codebase do not revert if zero is passed in for a parameter that should not be set to zero. The following parameters are not checked for the zero value:  Liquidator contract  constructor()  owner_  collateralAsset_  fundsAsset_  auctioneer_  destination_  setAuctioneer()  auctioneer_  MapleLoan contract  setBorrower()  borrower_  setLender()  lender_  MapleProxyFactory contract  constructor()  mapleGlobals_ If zero is passed in for one of those parameters, it will render the contract unusable, leaving its funds locked (and therefore eectively lost) and necessitating an expensive redeployment. For example, if there were a bug in the front end, MapleLoan.setBorrower could be called with address(0) , rendering the contract unusable and locking its funds in it. 24 Maple Labs The gas cost of checking a parameter for the zero value is negligible. Since the parameter is usually already on the stack, a zero check consists of a DUP opcode (3 gas) and an ISZERO opcode (3 gas). Given a high gas price of 200 gwei and an ether price of $4,200, a zero check would cost half a cent. Exploit Scenario A new version of the front end is deployed. A borrower suspects that the address currently used for his or her loan might have been compromised. As a precautionary measure, the borrower decides to transfer ownership of the loan to a new address. However, the new version of the front end contains a bug: the value of an uninitialized variable is used to construct the transaction. As a result, the borrower loses access to the loan contract, and to the collateral, forever. If zero checks had been in place, the transaction would have reverted instead. Recommendations Short term, add zero checks for the parameters mentioned above and for all other parameters for which zero is not an acceptable value. Long term, comprehensively validate all parameters. Avoid relying solely on the validation performed by front-end code, scripts, or other contracts, as a bug in any of those components could prevent it from performing that validation. Additionally, integrate Slither into the CI pipeline to automatically detect functions that lack zero checks. 25 Maple Labs", "labels": ["Trail of Bits", "Severity: Informational", "Difficulty: High"]}, {"title": "9. Lack of user-controlled limits for input amount in Liquidator.liquidatePortion ", "html_url": "https://github.com/trailofbits/publications/tree/master/reviews/MapleFinance.pdf", "body": "The liquidatePortion function of the Liquidator contract computes the amount of funds that will be transferred from the caller to the liquidator contract. The computation uses an asset price retrieved from an oracle. There is no guarantee that the amount paid by the caller will correspond to the current market price, as a transaction that updates the price feed could be mined before the call to liquidatePortion in the liquidator contract. EOAs that call the function cannot predict the return value of the oracle. If the caller is a contract, though, it can check the return value, with some eort. Adding an upper limit to the amount paid by the caller would enable the caller to explicitly state his or her assumptions about the execution of the contract and to avoid paying too much. It would also provide additional protection against the misreporting of oracle prices. Since such a scenario is unlikely, we set the diculty level of this nding to high. Using caller-controlled limits for the amount of a transfer is a best practice commonly employed by large DeFi protocols such as Uniswap. Exploit Scenario Alice calls liquidatePortion in the liquidator contract. Due to an oracle malfunction, the amount of her transfer to the liquidator contract is much higher than the amount she would pay for the collateral on another market. Recommendations Short term, introduce a maxReturnAmount parameter and add a require statement require(returnAmount <= maxReturnAmount) to enforce that parameter. 26 Maple Labs Long term, always allow the caller to control the amount of a transfer. This is especially important for transfer amounts that depend on factors that can change between transactions. Enable the caller to add a lower limit for a transfer from a contract and an upper limit for a transfer of the callers funds to a contract. 27 Maple Labs A. Vulnerability Categories The following tables describe the vulnerability categories, severity levels, and diculty levels used in this document. Vulnerability Categories Category", "labels": ["Trail of Bits", "Severity: Informational", "Difficulty: High"]}]