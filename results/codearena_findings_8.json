[{"title": "`ChiefTrader.sol` Wrong implementation of `swapExactInput()` and `swapExactOutput()`", "html_url": "https://github.com/code-423n4/2021-12-mellow-findings/issues/108", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-12-mellow-findings", "body": "# Handle  WatchPug   # Vulnerability details  When a caller calls `ChiefTrader.sol#swapExactInput()`, it will call `ITrader(traderAddress).swapExactInput()`.  https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/trader/ChiefTrader.sol#L59-L59  ```solidity=59 return ITrader(traderAddress).swapExactInput(0, amount, recipient, path, options); ```  However, in the current implementation, inputToken is not approved to the `traderAddress`.  For example, in `UniV3Trader.sol#_swapExactInputSingle`, at L89, it tries to transfer inputToken from `msg.sender` (which is `ChiefTrader`), since it's not approved, this will revert.  Plus, the inputToken should also be transferred from the caller before calling the subtrader.  https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/trader/UniV3Trader.sol#L89-L89  ```solidity=89     IERC20(input).safeTransferFrom(msg.sender, address(this), amount); ```  The same problem exits in `swapExactOutput()`:  https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/trader/ChiefTrader.sol#L63-L75  ```solidity=63 function swapExactOutput(         uint256 traderId,         uint256 amount,         address,         PathItem[] calldata path,         bytes calldata options     ) external returns (uint256) {         require(traderId < _traders.length, TraderExceptionsLibrary.TRADER_NOT_FOUND_EXCEPTION);         _requireAllowedTokens(path);         address traderAddress = _traders[traderId];         address recipient = msg.sender;         return ITrader(traderAddress).swapExactOutput(0, amount, recipient, path, options);     } ```  ### Recommendation  Approve the inputToken to the subtrader and transfer from the caller before calling `ITrader.swapExactInput()` and `ITrader.swapExactOutput()`.  Or maybe just remove support of `swapExactInput()` and `swapExactOutput()` in `ChiefTrader`.  "}, {"title": "These functions can be made modifier", "html_url": "https://github.com/code-423n4/2021-12-mellow-findings/issues/106", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-12-mellow-findings", "body": "These functions can be made modifier"}, {"title": "Guard for initialization function of VaultGovernance", "html_url": "https://github.com/code-423n4/2021-12-mellow-findings/issues/105", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2021-12-mellow-findings", "body": "# Handle  cuong_qnom   # Vulnerability details  ### Impact There should be a guard to initialize the factory in the VaultGovernance. Otherwise, some guys (e.g. miners) can front-run the initialization transaction with fake Factory address.  ### Proof of Concept https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/VaultGovernance.sol#L77 ### Tools used Manual Analysis ### Recommendation steps Maybe can put some requirements at the start: _requireProtocolAdmin()   "}, {"title": "Use literal `2` instead of read from storage for `_vaultTokens.length` can save gas", "html_url": "https://github.com/code-423n4/2021-12-mellow-findings/issues/104", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-mellow-findings", "body": "# Handle  WatchPug   # Vulnerability details  The current design requires the number of `_vaultTokens` to be 2 in `UniV3Vault`, therefore `_vaultTokens.length` can be replaced with literal `2` to save ~800 gas from storage read (`SLOAD` after Berlin).  Instances include:  https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/UniV3Vault.sol#L101-L101  ```solidity=101 tokenAmounts = new uint256[](_vaultTokens.length); ```  "}, {"title": "Declaring unnecessary immutable variables as constant can save gas", "html_url": "https://github.com/code-423n4/2021-12-mellow-findings/issues/103", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-12-mellow-findings", "body": "Declaring unnecessary immutable variables as constant can save gas"}, {"title": "Adding unchecked directive can save gas", "html_url": "https://github.com/code-423n4/2021-12-mellow-findings/issues/102", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-12-mellow-findings", "body": "Adding unchecked directive can save gas"}, {"title": "Unnecessary checked arithmetic in for loops", "html_url": "https://github.com/code-423n4/2021-12-mellow-findings/issues/101", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-12-mellow-findings", "body": "Unnecessary checked arithmetic in for loops"}, {"title": "Outdated compiler version", "html_url": "https://github.com/code-423n4/2021-12-mellow-findings/issues/100", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-12-mellow-findings", "body": "Outdated compiler version"}, {"title": "`UniV3Vault.sol#collectEarnings()` can be front run", "html_url": "https://github.com/code-423n4/2021-12-mellow-findings/issues/98", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2021-12-mellow-findings", "body": "# Handle  WatchPug   # Vulnerability details  For `UniV3Vault`, it seems that lp fees are collected through `collectEarnings()` callable by the `strategy` and reinvested (rebalanced).  However, in the current implementation, unharvested yields are not included in `tvl()`, making it vulnerable to front-run attacks that steal pending yields.  https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/UniV3Vault.sol#L100-L122  https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/UniV3Vault.sol#L80-L97  ### POC  Given:  - Current `tvl()` is `10 ETH` and `40,000 USDC`; - Current unclaimed yields (trading fees) is `1 ETH` and `4,000 USDC`;  1. `strategy` calls `collectEarnings()` to collect fees and reinvest; 2. The attacker sends a deposit tx with a higher gas price to deposit `10 ETH` and `40,000 USDC`, take 50% share of the pool; 3. After the transaction in step 1 is packed, the attacker calls `withdraw()` and retrieves `10.5 ETH` and `42,000 USDC`.  As a result, the attacker has stolen half of the pending yields in about 1 block of time.  ### Recommendation  Consider including fees in `tvl()`.  For the code to calculate fees earned, please reference `_computeFeesEarned()` in G-UNI project:  https://github.com/gelatodigital/g-uni-v1-core/blob/master/contracts/GUniPool.sol#L762-L806  "}, {"title": "Cache storage variables in the stack can save gas", "html_url": "https://github.com/code-423n4/2021-12-mellow-findings/issues/96", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-12-mellow-findings", "body": "Cache storage variables in the stack can save gas"}, {"title": "Remove unnecessary function can make the code simpler and save some gas", "html_url": "https://github.com/code-423n4/2021-12-mellow-findings/issues/95", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-12-mellow-findings", "body": "Remove unnecessary function can make the code simpler and save some gas"}, {"title": "Remove unnecessary variables can make the code simpler and save some gas", "html_url": "https://github.com/code-423n4/2021-12-mellow-findings/issues/93", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-12-mellow-findings", "body": "Remove unnecessary variables can make the code simpler and save some gas"}, {"title": "Use immutable variables can save gas", "html_url": "https://github.com/code-423n4/2021-12-mellow-findings/issues/92", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-12-mellow-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/oracle/ChainlinkOracle.sol#L20-L20 ```solidity=20 IChainlinkFeed public feed; ```  https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/oracle/ChainlinkOracle.sol#L29-L29 ```solidity=29 uint256 private _decimalOffset; ```  In `ChainlinkOracle.sol`, `feed` and `_decimalOffset` will never change, use immutable variables instead of storage variables can save gas.   https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/product/ProductProviderBase.sol#L13-L13  ```solidity=13 IOracle public oracle; ```  In `ProductProviderBase.sol`, `oracle` will never change, use immutable variables instead of storage variables can save gas.  "}, {"title": "Wrong implementation of `performanceFee` can cause users to lose 50% to 100% of their funds", "html_url": "https://github.com/code-423n4/2021-12-mellow-findings/issues/91", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-12-mellow-findings", "body": "# Handle  WatchPug   # Vulnerability details  A certain amount of lp tokens (shares of the vault) will be minted to the `strategyPerformanceTreasury` as `performanceFee`, the amount is calculated based on the `minLpPriceFactor`.  However, the current formula for `toMint` is wrong, which issues more than 100% of the current totalSupply of the lp token to the `strategyPerformanceTreasury` each time. Causing users to lose 50% to 100% of their funds after a few times.  https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/LpIssuer.sol#L269-L271  ```solidity=269 address treasury = strategyParams.strategyPerformanceTreasury; uint256 toMint = (baseSupply * minLpPriceFactor) / CommonLibrary.DENOMINATOR; _mint(treasury, toMint); ```  ### PoC  Given:  - `strategyParams.performanceFee`: `10e7` (1%)  1. Alice deposited `1,000 USDC`, received `1000` lpToken; the totalSupply of the lpToken is now: `1000`; 2. 3 days later, `baseTvl` increased to `1,001 USDC`, Bob deposited `1 USDC` and trigegred `_chargeFees()`:  - Expected Result: `strategyPerformanceTreasury` to receive about `0.01` lpToken (1% of 1 USDC); - Actual Result: `minLpPriceFactor` is about `1.001`, and `strategyPerformanceTreasury` will received `1001` lpToken as performanceFee; Alice lose 50% of deposited funds.  ### Recommendation  Change to:  ```solidity address treasury = strategyParams.strategyPerformanceTreasury; uint256 toMint = (baseSupply * (minLpPriceFactor - CommonLibrary.DENOMINATOR) * performanceFee  / CommonLibrary.DENOMINATOR) / CommonLibrary.DENOMINATOR; _mint(treasury, toMint); ```  "}, {"title": "`LpIssuer.sol#_chargeFees()` Check `if (performanceFee > 0)` can be done earlier to save gas", "html_url": "https://github.com/code-423n4/2021-12-mellow-findings/issues/90", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-12-mellow-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/LpIssuer.sol#L249-L252  ```solidity=249 uint256 performanceFee = strategyParams.performanceFee; uint256[] memory hwms = _lpPriceHighWaterMarks; if (performanceFee > 0) {     uint256 minLpPriceFactor = type(uint256).max;     ... ```  Check `if (performanceFee > 0)` at L251 can be done earlier to avoid unnecessary code execution (read `_lpPriceHighWaterMarks` and copy to memory) at L250 and save some gas when performanceFee == 0.  "}, {"title": "Cache external call results can save gas", "html_url": "https://github.com/code-423n4/2021-12-mellow-findings/issues/89", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-mellow-findings", "body": "Cache external call results can save gas"}, {"title": "Unsafe token transfer", "html_url": "https://github.com/code-423n4/2021-12-mellow-findings/issues/88", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2021-12-mellow-findings", "body": "# Handle  WatchPug   # Vulnerability details  Calling `ERC20.transfer()` without handling the returned value is unsafe.  https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/ERC20Vault.sol#L81-L90  ```solidity=81 function _pull(         address to,         uint256[] memory tokenAmounts,         bytes memory     ) internal override returns (uint256[] memory actualTokenAmounts) {         for (uint256 i = 0; i < tokenAmounts.length; i++) {             IERC20(_vaultTokens[i]).transfer(to, tokenAmounts[i]);         }         actualTokenAmounts = tokenAmounts;     } ```  ### Recommendation  Consider using OpenZeppelin's `SafeERC20` library with safe versions of transfer functions.  "}, {"title": "Setting `uint256` variables to `0` is redundant", "html_url": "https://github.com/code-423n4/2021-12-mellow-findings/issues/86", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-12-mellow-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L1/gateway/L1Migrator.sol#L471-L471  ```solidity uint256 total = 0; ```  https://github.com/livepeer/arbitrum-lpt-bridge/blob/ebf68d11879c2798c5ec0735411b08d0bea4f287/contracts/L1/gateway/L1Migrator.sol#L472-L472  ```solidity for (uint256 i = 0; i < _unbondingLockIds.length; i++) ```  Setting `uint256` variables to `0` is redundant as they default to `0`.  "}, {"title": "`YearnVault` did not cache tvl as comment described", "html_url": "https://github.com/code-423n4/2021-12-mellow-findings/issues/84", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-12-mellow-findings", "body": "# Handle  gzeon   # Vulnerability details  ## Impact The comment in https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/YearnVault.sol#L14 > The TVL of the vault is cached and updated after each deposit withdraw.  But it actually does not cache tvl. This behavior is desired or otherwise would have same issue as `AaveVault`.  ## Recommended Mitigation Steps Remove the cache description in comment.   "}, {"title": "Withdraw from `AaveVault` will receive less than actual share", "html_url": "https://github.com/code-423n4/2021-12-mellow-findings/issues/82", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2021-12-mellow-findings", "body": "# Handle  gzeon   # Vulnerability details  ## Impact `AaveVault` cache `tvl` and update it at the end of each `_push` and `_pull`. When withdrawing from `LpIssuer`,  `tokenAmounts` is calculated using the cached `tvl` to be pulled from `AaveVault`. This will lead to user missing out their share of the accrued interest / donations to Aave since the last `updateTvls`.  ## Proof of Concept https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/LpIssuer.sol#L150 https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/AaveVault.sol#L13  ## Recommended Mitigation Steps Call `updateTvls` at the beginning of `withdraw` function if the `_subvault` will cache tvl  "}, {"title": "Use of _msgSender()", "html_url": "https://github.com/code-423n4/2021-12-mellow-findings/issues/81", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-12-mellow-findings", "body": "# Handle  defsec   # Vulnerability details  ## Impact  The use of _msgSender() when there is no implementation of a meta transaction mechanism that uses it, such as EIP-2771, very slightly increases gas consumption.   ## Proof of Concept  _msgSender() is utilized three times where msg.sender could have been used in the following function.   \"\"\" https://github.com/code-423n4/2021-12-sublime/blob/e688bd6cd3df7fefa3be092529b4e2d013219625/contracts/yield/YearnYield.sol#L42  https://github.com/code-423n4/2021-12-sublime/blob/e688bd6cd3df7fefa3be092529b4e2d013219625/contracts/yield/CompoundYield.sol#L43  https://github.com/code-423n4/2021-12-sublime/blob/e688bd6cd3df7fefa3be092529b4e2d013219625/contracts/yield/AaveYield.sol#L71  https://github.com/code-423n4/2021-12-sublime/blob/e688bd6cd3df7fefa3be092529b4e2d013219625/contracts/yield/NoYield.sol#L31  \"\"\"   ## Tools Used  None  ## Recommended Mitigation Steps  Replace _msgSender() with msg.sender if there is no mechanism to support meta-transactions like EIP-2771 implemented.  "}, {"title": "Use `calldata` instead of `memory` for function parameters", "html_url": "https://github.com/code-423n4/2021-12-mellow-findings/issues/78", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-12-mellow-findings", "body": "Use `calldata` instead of `memory` for function parameters"}, {"title": "Initialization with empty `_symbol`", "html_url": "https://github.com/code-423n4/2021-12-mellow-findings/issues/76", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-12-mellow-findings", "body": "Initialization with empty `_symbol`"}, {"title": "Loops can be implemented more efficiently", "html_url": "https://github.com/code-423n4/2021-12-mellow-findings/issues/73", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-12-mellow-findings", "body": "# Handle  0x0x0x   # Vulnerability details  ## Proof of Concept  Example:  ```  for (uint i = 0; i < arr.length; i++) {  //Operations not effecting the length of the array.  }  ```  Loading length of array costs gas. Therefore, the length should be cached, if the length of the array doesn't change inside the loop. Furthermore, there is no need to assign the initial value 0. This costs extra gas.  Recommended implementation:  ```  uint length = arr.length;  for (uint i; i < length; ++i) {  //Operations not effecting the length of the array.  }  ```  By doing so the length is only loaded once rather than loading it as many times as iterations (Therefore, less gas is spent).  ## Occurences  ```  ./CreditLine/CreditLine.sol:484:        for (uint256 _index = 0; _index < _strategyList.length; _index++) { ./CreditLine/CreditLine.sol:662:        for (uint256 _index = 0; _index < _strategyList.length; _index++) { ./CreditLine/CreditLine.sol:738:        for (uint256 _index = 0; _index < _strategyList.length; _index++) { ./CreditLine/CreditLine.sol:892:        for (uint256 index = 0; index < _strategyList.length; index++) { ./CreditLine/CreditLine.sol:959:        for (uint256 index = 0; index < _strategyList.length; index++) { ./SavingsAccount/SavingsAccount.sol:289:        for (uint256 i = 0; i < _strategyList.length; i++) { ./SavingsAccount/SavingsAccount.sol:467:        for (uint256 i = 0; i < _strategyList.length; i++) {  ```  "}, {"title": "There is no need to assign default values to variables", "html_url": "https://github.com/code-423n4/2021-12-mellow-findings/issues/71", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-12-mellow-findings", "body": "There is no need to assign default values to variables"}, {"title": "Don't cache variables used only once", "html_url": "https://github.com/code-423n4/2021-12-mellow-findings/issues/66", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-12-mellow-findings", "body": "Don't cache variables used only once"}, {"title": "`maxTokensPerVault` is not used", "html_url": "https://github.com/code-423n4/2021-12-mellow-findings/issues/65", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-12-mellow-findings", "body": "# Handle  0x0x0x   # Vulnerability details  In `protocolGovernance.sol`, there is parameter `maxTokensPerVault`. This parameter is never utilized, therefore does not provide the functionality stated in comments.  "}, {"title": "Optimize `baseSupply` calculation in `_chargeFee`", "html_url": "https://github.com/code-423n4/2021-12-mellow-findings/issues/64", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-12-mellow-findings", "body": "Optimize `baseSupply` calculation in `_chargeFee`"}, {"title": "`+= 1` costs extra gas", "html_url": "https://github.com/code-423n4/2021-12-mellow-findings/issues/63", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-12-mellow-findings", "body": "`+= 1` costs extra gas"}, {"title": "Gas Optimization: Use != 0 instead of > 0", "html_url": "https://github.com/code-423n4/2021-12-mellow-findings/issues/60", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-12-mellow-findings", "body": "Gas Optimization: Use != 0 instead of > 0"}, {"title": "Gas Optimization: Pack `Params` struct in `IProtocolGovernance`", "html_url": "https://github.com/code-423n4/2021-12-mellow-findings/issues/59", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-12-mellow-findings", "body": "# Handle  gzeon   # Vulnerability details  ## Impact Reduce 1 storage slot by reordering from https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/interfaces/IProtocolGovernance.sol#L13 ```     struct Params {         bool permissionless;         uint256 maxTokensPerVault;         uint256 governanceDelay;         address protocolTreasury;     } ``` to ```     struct Params {         bool permissionless;         address protocolTreasury;         uint256 maxTokensPerVault;         uint256 governanceDelay;     } ```   "}, {"title": "A more efficient for loop index proceeding", "html_url": "https://github.com/code-423n4/2021-12-mellow-findings/issues/54", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-12-mellow-findings", "body": "A more efficient for loop index proceeding"}, {"title": "Gas: Unnecessary zero writes", "html_url": "https://github.com/code-423n4/2021-12-mellow-findings/issues/53", "labels": ["bug", "G (Gas Optimization)", "sponsor disputed"], "target": "2021-12-mellow-findings", "body": "Gas: Unnecessary zero writes"}, {"title": "Gas: Cache `_pendingTokenWhitelistAdd[i]`", "html_url": "https://github.com/code-423n4/2021-12-mellow-findings/issues/52", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-12-mellow-findings", "body": "Gas: Cache `_pendingTokenWhitelistAdd[i]`"}, {"title": "Gas: `GatewayVault._pull` can skip redirected", "html_url": "https://github.com/code-423n4/2021-12-mellow-findings/issues/51", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-12-mellow-findings", "body": "Gas: `GatewayVault._pull` can skip redirected"}, {"title": "UniswapV3's path issue for `swapExactOutput`", "html_url": "https://github.com/code-423n4/2021-12-mellow-findings/issues/50", "labels": ["bug", "2 (Med Risk)"], "target": "2021-12-mellow-findings", "body": "UniswapV3's path issue for `swapExactOutput`"}, {"title": "Admin can break `_numberOfValidTokens`", "html_url": "https://github.com/code-423n4/2021-12-mellow-findings/issues/49", "labels": ["bug", "2 (Med Risk)"], "target": "2021-12-mellow-findings", "body": "Admin can break `_numberOfValidTokens`"}, {"title": "Wrong logic in `tokenWhitelist()`?", "html_url": "https://github.com/code-423n4/2021-12-mellow-findings/issues/48", "labels": ["bug", "1 (Low Risk)"], "target": "2021-12-mellow-findings", "body": "Wrong logic in `tokenWhitelist()`?"}, {"title": "Users can avoid paying vault fees", "html_url": "https://github.com/code-423n4/2021-12-mellow-findings/issues/47", "labels": ["bug", "2 (Med Risk)", "sponsor disputed"], "target": "2021-12-mellow-findings", "body": "Users can avoid paying vault fees"}, {"title": "User deposits don't have min. return checks", "html_url": "https://github.com/code-423n4/2021-12-mellow-findings/issues/46", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-12-mellow-findings", "body": "# Handle  cmichel   # Vulnerability details  The `LPIssuer.deposit` first computes _balanced amounts_ on the user's defined `tokenAmounts`. The idea is that LP tokens give the same percentage share of each vault tokens' tvl, therefore the provided amounts should be _balanced_, meaning, the `depositAmount / tvl` ratio should be equal for all vault tokens.  But the strategist can frontrun the user's deposit and rebalance the vault tokens, changing the tvl for each vault token which changes the rebalance. This frontrun can happen accidentally whenever the strategist rebalances  ## POC There's a vault with two tokens A and B, tvls are `[500, 1500]`  - The user provides `[500, 1500]`, expecting to get 50% of the share supply (is minted 100% of old total supply). - The strategist rebalances to `[1000, 1000]` - The user's balanceFactor is `min(500/1000, 1500/1000) = 1/2`, their balancedAmounts are thus `tvl * balanceFactor = [500, 500]`, the `1000` excess token B are refunded. In the end, they only received `500/(1000+500) = 33.3%` of the total supply but used up all of their token A which they might have wanted to hold on to if they had known they'd only get 33.3% of the supply.  ## Impact Users can get rekt when depositing as the received LP amount is unpredictable and lead to a trade using a very different balanced token mix that they never intended.  ## Recommended Mitigation Steps Add minimum return amount checks. Accept a function parameter that can be chosen by the user indicating their _expected LP amount_ for their deposit `tokenAmounts`, then check that the actually minted LP token amount is above this parameter.   "}, {"title": "`GatewayVault` events not used", "html_url": "https://github.com/code-423n4/2021-12-mellow-findings/issues/45", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor confirmed"], "target": "2021-12-mellow-findings", "body": "# Handle  cmichel   # Vulnerability details  The `CollectProtocolFees` and `CollectStrategyFees` events in `GatewayVault` are not used.  ## Impact Unused code can hint at programming or architectural errors.  ## Recommended Mitigation Steps Use it or remove it.  "}, {"title": "Bad redirects can make it impossible to deposit & withdraw", "html_url": "https://github.com/code-423n4/2021-12-mellow-findings/issues/44", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-12-mellow-findings", "body": "# Handle  cmichel   # Vulnerability details  The `GatewayVault._push()` function gets `redirects` from the `strategyParams`. If `redirects[i] = j`, vault index `i`'s deposits are redirected to vault index `j`.  Note that the deposits for vault index `i` are cleared, as they are redirected:  ```solidity for (uint256 j = 0; j < _vaultTokens.length; j++) {     uint256 vaultIndex = _subvaultNftsIndex[strategyParams.redirects[i]];     amountsByVault[vaultIndex][j] += amountsByVault[i][j];     amountsByVault[i][j] = 0; } ```  > The same is true for withdrawals in the `_pull` function. Users might not be able to withdraw this way.  If the `redirects` array is misconfigured, it's possible that all `amountsByVault` are set to zero. For example, if `0` redirects to `1` and `1` redirects to `0`. Or `0` redirects to itself, etc. There are many misconfigurations that can lead to not being able to deposit to the pool anymore.   ## Recommended Mitigation Steps The `redirects[i] = j` matrix needs to be restricted. If `i` is redirected to `j`, `j` may not redirect itself. Check for this when setting the `redirects` array.  "}, {"title": "AaveVault does not update TVL on deposit/withdraw", "html_url": "https://github.com/code-423n4/2021-12-mellow-findings/issues/41", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2021-12-mellow-findings", "body": "# Handle  cmichel   # Vulnerability details  Aave uses **rebasing** tokens which means the token balance `aToken.balanceOf(this)` increases over time with the accrued interest. The `AaveVault.tvl` uses a cached value that needs to be updated using a `updateTvls` call. This call is not done when depositing tokens which allows an attacker to deposit tokens, get a fair share _of the old tvl_, update the tvl to include the interest, and then withdraw the LP tokens receiving a larger share of the _new tvl_, receiving back their initial deposit + the share of the interest. This can be done risk-free in a single transaction.  ## POC - Imagine an Aave Vault with a single vault token, and current TVL = `1,000 aTokens` - Attacker calls `LPIssuer.push([1000])`. This loads the old, cached `tvl`. No `updateTvl` is called. - The `1000` underlying tokens are already balanced as there's only one aToken, then the entire amount is pushed: `aaveVault.transferAndPush([1000])`. This deposists `1000` underlying tokens to the Aave lending pool and returns `actualTokenAmounts = [1000]`. **After that** the internal `_tvls` variable is updated with the latest aTokens. This includes the 1000 aTokens just deposited **but also the new rebased aToken amounts**, the interest the vault received from supplying the tokens since last `updateTvls` call. `_tvls = _tvls + interest + 1000` - The LP amount to mint `amountToMint` is still calculated on the old cached `tvl` memory variable, i.e., attacker receives `amount / oldTvl = 1000/1000 = 100%` of existing LP supply - Attacker withdraws the LP tokens for 50% of the new TVL (it has been updated in `deposit`'s `transferAndPush` call). Attacker receives `50% * _newTvl = 50% * (2,000 + interest) = 1000 + 0.5 * interest`. - Attacker makes a profit of `0.5 * interest`  ## Impact The interest since the last TVL storage update can be stolen as Aave uses rebasing tokens but the tvl is not first recomputed when depositing. If the vaults experience low activity a significant amount of interest can accrue which can all be captured by taking a flashloan and depositing and withdrawing a large amount to capture a large share of this interest  ## Recommended Mitigation Steps Update the tvl when depositing and withdrawing before doing anything else.   "}, {"title": "withdraw() Validate lpTokenAmount At Beginning of Function Can Save Gas", "html_url": "https://github.com/code-423n4/2021-12-mellow-findings/issues/38", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-12-mellow-findings", "body": "withdraw() Validate lpTokenAmount At Beginning of Function Can Save Gas"}, {"title": "Remove ADMIN_DELEGATE_ROLE to Save Gas", "html_url": "https://github.com/code-423n4/2021-12-mellow-findings/issues/34", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-12-mellow-findings", "body": "Remove ADMIN_DELEGATE_ROLE to Save Gas"}, {"title": "ExceptionsLibrary.sol Shorten Revert Strings to Save Gas", "html_url": "https://github.com/code-423n4/2021-12-mellow-findings/issues/32", "labels": ["bug", "G (Gas Optimization)", "sponsor disputed"], "target": "2021-12-mellow-findings", "body": "ExceptionsLibrary.sol Shorten Revert Strings to Save Gas"}, {"title": "Potential DOS with Division By Zero on `LpIssuer`", "html_url": "https://github.com/code-423n4/2021-12-mellow-findings/issues/27", "labels": ["bug", "1 (Low Risk)", "disagree with severity"], "target": "2021-12-mellow-findings", "body": "Potential DOS with Division By Zero on `LpIssuer`"}, {"title": "Don't check contains before remove II", "html_url": "https://github.com/code-423n4/2021-12-mellow-findings/issues/26", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-mellow-findings", "body": "# Handle  0x1f8b   # Vulnerability details  # Vulnerability details  ## Impact Gas optimization.  ## Proof of Concept The method remove of the library AddressSet doesn't fail if the entry was not found (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/a05312f1b72acca6904ffe32ef83ccdbad20cb4f/contracts/utils/structs/EnumerableSet.sol#L72), this method return true or false if was removed, so it's not needed to check if _vaultGovernances.contains(addr) in the method removeFromVaultGovernances from ProtocolGovernance contract.  ## Tools Used Manual review  ## Recommended Mitigation Steps Remove the contains conditional  "}, {"title": "Wrong logic in UniV3Trader", "html_url": "https://github.com/code-423n4/2021-12-mellow-findings/issues/22", "labels": ["bug", "1 (Low Risk)", "disagree with severity"], "target": "2021-12-mellow-findings", "body": "Wrong logic in UniV3Trader"}, {"title": "Store Interface instead of address", "html_url": "https://github.com/code-423n4/2021-12-mellow-findings/issues/21", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-12-mellow-findings", "body": "# Handle  0x1f8b   # Vulnerability details  ## Impact Gas saving.  ## Proof of Concept Inside the contract `ChiefTrader` It's better to store the variable `protocolGovernance` as `IProtocolGovernance` because otherwise you need to cast it everytime.  ## Tools Used Manual review  ## Recommended Mitigation Steps Use `IProtocolGovernance` instead of address for store `protocolGovernance`  "}, {"title": "Learn from the past", "html_url": "https://github.com/code-423n4/2021-12-mellow-findings/issues/20", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-12-mellow-findings", "body": "# Handle  0x1f8b   # Vulnerability details  ## Impact Mandatory check that could produce undesired results.  ## Proof of Concept The smart contract ChiefTrader was in charge of the swaps, and the method _requireAllowedTokens is in charge to know that all paths are valid, it's mandatory to check that token0 and token1 are not equal, you can see a previous hack in the following link, where the hacker use the same from and to for change the price of the token https://twitter.com/mudit__gupta/status/1465726874974187524?s=12 .  ## Tools Used Manual review  ## Recommended Mitigation Steps Add require for check that token0 and token1 are different.  "}, {"title": "Missing zero-address checks on contract construction", "html_url": "https://github.com/code-423n4/2021-12-mellow-findings/issues/19", "labels": ["bug", "0 (Non-critical)", "disagree with severity"], "target": "2021-12-mellow-findings", "body": "Missing zero-address checks on contract construction"}, {"title": "Solidity compiler versions mismatch", "html_url": "https://github.com/code-423n4/2021-12-mellow-findings/issues/17", "labels": ["bug", "0 (Non-critical)"], "target": "2021-12-mellow-findings", "body": "# Handle  robee   # Vulnerability details  The project is compiled with different versions of solidity, which is not recommended due ti  undefined behaviors as a result of it.           "}, {"title": "Open TODOs", "html_url": "https://github.com/code-423n4/2021-12-mellow-findings/issues/16", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-12-mellow-findings", "body": "Open TODOs"}, {"title": "safeApprove of openZeppelin is deprecated", "html_url": "https://github.com/code-423n4/2021-12-mellow-findings/issues/15", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-12-mellow-findings", "body": "# Handle  robee   # Vulnerability details  You use safeApprove of openZeppelin although it's deprecated.  (see https://github.com/OpenZeppelin/openzeppelin-contracts/blob/566a774222707e424896c0c390a84dc3c13bdcb2/contracts/token/ERC20/utils/SafeERC20.sol#L38) You should change it to increase/decrease Allowance as OpenZeppilin says. This appears in the following locations in the code base:          Deprecated safeApprove in AaveV2Strategy.sol line 70: want.safeApprove(address(lp), type(uint256).max);          Deprecated safeApprove in SherlockClaimManager.sol line 421: TOKEN.safeApprove(address(UMA), _amount);          Deprecated safeApprove in SherlockClaimManager.sol line 464: TOKEN.safeApprove(address(UMA), 0);          Deprecated safeApprove in SherBuy.sol line 99: usdc.approve(address(sherlockPosition), type(uint256).max);          Deprecated safeApprove in SherBuy.sol line 169: sher.approve(address(sherClaim), sherAmount);    "}, {"title": "Require with empty message", "html_url": "https://github.com/code-423n4/2021-12-mellow-findings/issues/11", "labels": ["bug", "0 (Non-critical)", "disagree with severity"], "target": "2021-12-mellow-findings", "body": "# Handle  robee   # Vulnerability details  The following requires are with empty messages.  This is very important to add a message for any require. Such that the user has enough  information to know the reason of failure:           Solidity file: CDSTemplate.sol, In line 253 with Empty Require message.         Solidity file: Factory.sol, In line 100 with Empty Require message.         Solidity file: IndexTemplate.sol, In line 477 with Empty Require message.         Solidity file: PoolTemplate.sol, In line 929 with Empty Require message.         Solidity file: Vault.sol, In line 66 with Empty Require message.         Solidity file: Vault.sol, In line 67 with Empty Require message.         Solidity file: Vault.sol, In line 68 with Empty Require message.   "}, {"title": "Unnecessary array boundaries check when loading an array element twice", "html_url": "https://github.com/code-423n4/2021-12-mellow-findings/issues/10", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-12-mellow-findings", "body": "Unnecessary array boundaries check when loading an array element twice"}, {"title": "Public functions to external", "html_url": "https://github.com/code-423n4/2021-12-mellow-findings/issues/8", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-12-mellow-findings", "body": "# Handle  robee   # Vulnerability details   The following functions could be set external to save gas and improve code quality.  External call cost is less expensive than of public functions.           The function withdrawableOf in XDEFIDistribution.sol could be set external         The function tokenURI in XDEFIDistribution.sol could be set external         The function getAllTokensForAccount in XDEFIDistributionHelper.sol could be set external         The function getAllLockedPositionsForAccount in XDEFIDistributionHelper.sol could be set external    "}, {"title": "Internal functions to private", "html_url": "https://github.com/code-423n4/2021-12-mellow-findings/issues/7", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-12-mellow-findings", "body": "# Handle  robee   # Vulnerability details  The following functions could be set private to save gas and improve code quality:         The function takeFrom in PegExchanger.sol could be set internal         The function giveTo in PegExchanger.sol could be set internal         The function verifyProof in TRIBERagequit.sol could be set internal         The function takeFrom in TRIBERagequit.sol could be set internal         The function processProof in TRIBERagequit.sol could be set internal         The function giveTo in TRIBERagequit.sol could be set internal         The function _startCountdown in TRIBERagequit.sol could be set internal  "}, {"title": "Storage double reading. Could save SLOAD", "html_url": "https://github.com/code-423n4/2021-12-mellow-findings/issues/6", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-12-mellow-findings", "body": "Storage double reading. Could save SLOAD"}, {"title": "Unused imports", "html_url": "https://github.com/code-423n4/2021-12-mellow-findings/issues/1", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-12-mellow-findings", "body": "Unused imports"}, {"title": "several functions can be marked external", "html_url": "https://github.com/code-423n4/2021-11-yaxis-findings/issues/119", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged", "fix later"], "target": "2021-11-yaxis-findings", "body": "several functions can be marked external"}, {"title": "Incorrect comment or code in runPhasedDistribution (Transmuter.sol)", "html_url": "https://github.com/code-423n4/2021-11-yaxis-findings/issues/117", "labels": ["bug", "1 (Low Risk)", "sponsor disputed", "wont fix"], "target": "2021-11-yaxis-findings", "body": "Incorrect comment or code in runPhasedDistribution (Transmuter.sol)"}, {"title": "TRANSMUTATION_PERIOD Issues", "html_url": "https://github.com/code-423n4/2021-11-yaxis-findings/issues/116", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-11-yaxis-findings", "body": "# Handle  ye0lde   # Vulnerability details  ## Impact  Using existing local variables instead of reading state variables will save gas by converting SLOADs to MLOADs.   ## Proof of Concept  newTransmutationPeriod can be used here instead of TRANSMUTATION_PERIOD : https://github.com/code-423n4/2021-11-yaxis/blob/146febcb61ae7fe20b0920849c4f4bbe111c6ba7/contracts/v3/alchemix/Transmuter.sol#L194  TRANSMUTATION_PERIOD is named like a constant when it is actually an updatable state variable.  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps  Use the local variable instead of the state variable. Rename TRANSMUTATION_PERIOD appropriately.  "}, {"title": "Unused Named Returns", "html_url": "https://github.com/code-423n4/2021-11-yaxis-findings/issues/115", "labels": ["bug", "G (Gas Optimization)", "sponsor disputed", "wont fix"], "target": "2021-11-yaxis-findings", "body": "Unused Named Returns"}, {"title": "Assigned operations to constant variables", "html_url": "https://github.com/code-423n4/2021-11-yaxis-findings/issues/111", "labels": ["bug", "G (Gas Optimization)", "sponsor disputed", "wont fix"], "target": "2021-11-yaxis-findings", "body": "Assigned operations to constant variables"}, {"title": "Constant expressions", "html_url": "https://github.com/code-423n4/2021-11-yaxis-findings/issues/110", "labels": ["bug", "G (Gas Optimization)", "sponsor disputed", "wont fix"], "target": "2021-11-yaxis-findings", "body": "Constant expressions"}, {"title": "setSentinel actually adds sentinel", "html_url": "https://github.com/code-423n4/2021-11-yaxis-findings/issues/108", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor disputed"], "target": "2021-11-yaxis-findings", "body": "setSentinel actually adds sentinel"}, {"title": "_setupRole not in constructor", "html_url": "https://github.com/code-423n4/2021-11-yaxis-findings/issues/107", "labels": ["bug", "invalid", "1 (Low Risk)", "sponsor disputed"], "target": "2021-11-yaxis-findings", "body": "_setupRole not in constructor"}, {"title": "Context and msg.sender", "html_url": "https://github.com/code-423n4/2021-11-yaxis-findings/issues/105", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2021-11-yaxis-findings", "body": "Context and msg.sender"}, {"title": "anyone can deposit to adapters directly", "html_url": "https://github.com/code-423n4/2021-11-yaxis-findings/issues/103", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged", "wont fix"], "target": "2021-11-yaxis-findings", "body": "anyone can deposit to adapters directly"}, {"title": "Optimize `Alchemist.sol#_withdrawFundsTo`", "html_url": "https://github.com/code-423n4/2021-11-yaxis-findings/issues/102", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-11-yaxis-findings", "body": "# Handle  0x0x0x   # Vulnerability details  ## Proof of Concept `L839-L843` is as follow: ```             AlchemistVault.Data storage _activeVault = _vaults.last();             (uint256 _withdrawAmount, uint256 _decreasedValue) = _activeVault.withdraw(                 _recipient,                 _remainingAmount             ); ``` It can be replaced by following code block, since there is no reason to save it to memory. ```             (uint256 _withdrawAmount, uint256 _decreasedValue) = _vaults.last().withdraw(                 _recipient,                 _remainingAmount             ); ``` ## Tools Used Manual analysis  "}, {"title": "`AlchemistVault.sol` can be optimised", "html_url": "https://github.com/code-423n4/2021-11-yaxis-findings/issues/100", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-11-yaxis-findings", "body": "# Handle  0x0x0x   # Vulnerability details  ## Proof of Concept There is no need to cache calculation steps between the return values. `L98-L122` is as follows: ```         uint256 _endingBalance = _token.balanceOf(_recipient);         uint256 _withdrawnAmount = _token.balanceOf(_recipient).sub(_startingBalance);          uint256 _endingTotalValue = _self.totalValue();         uint256 _decreasedValue = _startingTotalValue.sub(_endingTotalValue); ```  Which can be replaced by following code to save gas:  ```         uint256 _withdrawnAmount = _token.balanceOf(_recipient).sub(_startingBalance);          uint256 _decreasedValue = _startingTotalValue.sub(_self.totalValue()); ```  ## Tools Used  Manual analysis  "}, {"title": "Gas optimization: Reduce storage write", "html_url": "https://github.com/code-423n4/2021-11-yaxis-findings/issues/97", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-11-yaxis-findings", "body": "# Handle  gzeon   # Vulnerability details  ## Proof of Concept https://github.com/code-423n4/2021-11-yaxis/blob/146febcb61ae7fe20b0920849c4f4bbe111c6ba7/contracts/v3/alchemix/Alchemist.sol#L630 The line can be rewritten as  `_remainingAmount = _remainingAmount.add(_borrowFeeAmount);`  to reduce a storage write. Alternatively use a memory variable to preserve code readability.   "}, {"title": "Removing the unnecessary function", "html_url": "https://github.com/code-423n4/2021-11-yaxis-findings/issues/96", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-11-yaxis-findings", "body": "# Handle  xxxxx   # Vulnerability details  ## Impact The unnecessary code can be removed to reduce contract size.  ## Proof of Concept In the contract \"Alchemist.sol\" the function \"_expectCaller\" is never used.   ## Tools Used Remix solidity 0.6.12 ## Recommended Mitigation Steps The function \"_expectCaller(address _expectedCaller)\" can be removed.  "}, {"title": "`CDP.sol#getUpdatedTotalDebt` can be optimized", "html_url": "https://github.com/code-423n4/2021-11-yaxis-findings/issues/92", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-11-yaxis-findings", "body": "# Handle  0x0x0x   # Vulnerability details  ## Proof of Concept Current implementation has two if statements, but actually the same logic can be coded with only one if statement. Since `_unclaimedYield == 0` is a special case of `_unclaimedYield < _currentTotalDebt` and does not require any extra code.  ```   function getUpdatedTotalDebt(Data storage _self, Context storage _ctx) internal view returns (uint256) {     uint256 _unclaimedYield = _self.getEarnedYield(_ctx);     uint256 _currentTotalDebt = _self.totalDebt;      if (_unclaimedYield < _currentTotalDebt) {       return _currentTotalDebt - _unclaimedYield;     }     else {       return 0;     }   } ``` ## Tools Used Manual analysis  "}, {"title": "`CDP.sol#update.sol` can be optimized", "html_url": "https://github.com/code-423n4/2021-11-yaxis-findings/issues/91", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-11-yaxis-findings", "body": "# Handle  0x0x0x   # Vulnerability details  ## Concept The current code is: ```   function update(Data storage _self, Context storage _ctx) internal {     uint256 _earnedYield = _self.getEarnedYield(_ctx);     if (_earnedYield > _self.totalDebt) {       uint256 _currentTotalDebt = _self.totalDebt;       _self.totalDebt = 0;       _self.totalCredit = _earnedYield.sub(_currentTotalDebt);     } else {       _self.totalDebt = _self.totalDebt.sub(_earnedYield);     }     _self.lastAccumulatedYieldWeight = _ctx.accumulatedYieldWeight;   } ``` We cache _self.totalDebt, but it is not required, since we can use it before we change it. This code block can be replaced with: ```   function update(Data storage _self, Context storage _ctx) internal {     uint256 _earnedYield = _self.getEarnedYield(_ctx);     if (_earnedYield > _self.totalDebt) {       _self.totalCredit = _earnedYield.sub(_self.totalDebt);       _self.totalDebt = 0;     } else {       _self.totalDebt = _self.totalDebt.sub(_earnedYield);     }     _self.lastAccumulatedYieldWeight = _ctx.accumulatedYieldWeight;   } ``` By doing so, we don't cache `_self.totalDebt` just to use it once.  "}, {"title": "Require statements without messages", "html_url": "https://github.com/code-423n4/2021-11-yaxis-findings/issues/88", "labels": ["bug", "0 (Non-critical)", "wont fix"], "target": "2021-11-yaxis-findings", "body": "Require statements without messages"}, {"title": "Open TODOs", "html_url": "https://github.com/code-423n4/2021-11-yaxis-findings/issues/87", "labels": ["bug", "invalid", "0 (Non-critical)"], "target": "2021-11-yaxis-findings", "body": "Open TODOs"}, {"title": "State variables can be `immutable`s", "html_url": "https://github.com/code-423n4/2021-11-yaxis-findings/issues/83", "labels": ["bug", "invalid", "G (Gas Optimization)"], "target": "2021-11-yaxis-findings", "body": "State variables can be `immutable`s"}, {"title": "Incorrect Comment", "html_url": "https://github.com/code-423n4/2021-11-yaxis-findings/issues/77", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor disputed"], "target": "2021-11-yaxis-findings", "body": "Incorrect Comment"}, {"title": "No Event Emitted on Minting", "html_url": "https://github.com/code-423n4/2021-11-yaxis-findings/issues/76", "labels": ["bug", "0 (Non-critical)", "sponsor disputed", "wont fix"], "target": "2021-11-yaxis-findings", "body": "No Event Emitted on Minting"}, {"title": "Lack of Input Validation", "html_url": "https://github.com/code-423n4/2021-11-yaxis-findings/issues/75", "labels": ["bug", "0 (Non-critical)", "sponsor disputed", "wont fix"], "target": "2021-11-yaxis-findings", "body": "Lack of Input Validation"}, {"title": "Gas Optimization: Inline instead of modifier", "html_url": "https://github.com/code-423n4/2021-11-yaxis-findings/issues/72", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-11-yaxis-findings", "body": "Gas Optimization: Inline instead of modifier"}, {"title": "No incentive to call `transmute()` instead of `forceTransmute(self)`", "html_url": "https://github.com/code-423n4/2021-11-yaxis-findings/issues/68", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged", "wont fix"], "target": "2021-11-yaxis-findings", "body": "No incentive to call `transmute()` instead of `forceTransmute(self)`"}, {"title": "`Transmuter.unstake` updates user without first updating distributing yield", "html_url": "https://github.com/code-423n4/2021-11-yaxis-findings/issues/66", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2021-11-yaxis-findings", "body": "# Handle  cmichel   # Vulnerability details  The `updateAccount` function should capture the latest distributed yield to the Transmuter (stored in `buffer`) and therefore work with the latest `totalDividendPoints` variable. This variable is updated when running a phase distribution with `runPhasedDistribution`.  Unlike all other function that call `updateAccount`, the `unstake` function does not first run a `runPhasedDistribution` modifer to distribute the latest yield.  ## Impact Users that unstake lose out on some yield by not having their alTokens transmuted.  ## Recommended Mitigation Steps Call `runPhasedDistribution` in `unstake` before the `updateAccount` call, as in `stake` or `transmute`.  "}, {"title": "`Alchemist.migrate` can push duplicate adapters to `_vaults`", "html_url": "https://github.com/code-423n4/2021-11-yaxis-findings/issues/65", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged", "wont fix"], "target": "2021-11-yaxis-findings", "body": "`Alchemist.migrate` can push duplicate adapters to `_vaults`"}, {"title": "Pending governance is not cleared", "html_url": "https://github.com/code-423n4/2021-11-yaxis-findings/issues/63", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged", "wont fix"], "target": "2021-11-yaxis-findings", "body": "Pending governance is not cleared"}, {"title": "Gas optimization: Caching variables", "html_url": "https://github.com/code-423n4/2021-11-yaxis-findings/issues/62", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged", "fix later"], "target": "2021-11-yaxis-findings", "body": "Gas optimization: Caching variables"}, {"title": "Constructor Lack of Zero Address Check for Tokens", "html_url": "https://github.com/code-423n4/2021-11-yaxis-findings/issues/60", "labels": ["bug", "0 (Non-critical)", "sponsor disputed", "wont fix"], "target": "2021-11-yaxis-findings", "body": "Constructor Lack of Zero Address Check for Tokens"}, {"title": "No Transfer Ownership Pattern in AlToken.sol", "html_url": "https://github.com/code-423n4/2021-11-yaxis-findings/issues/56", "labels": ["bug", "0 (Non-critical)", "sponsor disputed", "wont fix"], "target": "2021-11-yaxis-findings", "body": "No Transfer Ownership Pattern in AlToken.sol"}, {"title": "Inline internal functions that are being used only once can save gas", "html_url": "https://github.com/code-423n4/2021-11-yaxis-findings/issues/54", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor acknowledged"], "target": "2021-11-yaxis-findings", "body": "Inline internal functions that are being used only once can save gas"}, {"title": "`Alchemist.sol#mint()` Two storage writes can be combined into one", "html_url": "https://github.com/code-423n4/2021-11-yaxis-findings/issues/53", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-11-yaxis-findings", "body": "# Handle  WatchPug   # Vulnerability details  In `Alchemist.sol#mint()`, when `borrowFee > 0`, `_cdp.totalDebt` will be written 2 times. Combing them into one storage write can save gas.  https://github.com/code-423n4/2021-11-yaxis/blob/146febcb61ae7fe20b0920849c4f4bbe111c6ba7/contracts/v3/alchemix/Alchemist.sol#L611-L645  ```solidity function mint(uint256 _amount)     external     nonReentrant     noContractAllowed     onPriceCheck     expectInitialized {     CDP.Data storage _cdp = _cdps[msg.sender];     _cdp.update(_ctx);      uint256 _totalCredit = _cdp.totalCredit;      if (_totalCredit < _amount) {         uint256 _remainingAmount = _amount.sub(_totalCredit);          if (borrowFee > 0) {             uint256 _borrowFeeAmount = _remainingAmount.mul(borrowFee).div(                 PERCENT_RESOLUTION             );             _cdp.totalDebt = _cdp.totalDebt.add(_borrowFeeAmount);             xtoken.mint(rewards, _borrowFeeAmount);         }         _cdp.totalDebt = _cdp.totalDebt.add(_remainingAmount);         _cdp.totalCredit = 0;          _cdp.checkHealth(_ctx, 'Alchemist: Loan-to-value ratio breached');     } else {         _cdp.totalCredit = _totalCredit.sub(_amount);     }      xtoken.mint(msg.sender, _amount);     if (_amount >= flushActivator) {         flushActiveVault();     } } ```  ### Recommendation  Change to:  ```solidity function mint(uint256 _amount)     external     nonReentrant     noContractAllowed     onPriceCheck     expectInitialized {     CDP.Data storage _cdp = _cdps[msg.sender];     _cdp.update(_ctx);      uint256 _totalCredit = _cdp.totalCredit;     uint256 _totalDebt = _cdp.totalDebt;      if (_totalCredit < _amount) {         uint256 _remainingAmount = _amount.sub(_totalCredit);          if (borrowFee > 0) {             uint256 _borrowFeeAmount = _remainingAmount.mul(borrowFee).div(                 PERCENT_RESOLUTION             );             _totalDebt = _totalDebt.add(_borrowFeeAmount);             xtoken.mint(rewards, _borrowFeeAmount);         }         _cdp.totalDebt = _totalDebt.add(_remainingAmount);         _cdp.totalCredit = 0;          _cdp.checkHealth(_ctx, 'Alchemist: Loan-to-value ratio breached');     } else {         _cdp.totalCredit = _totalCredit.sub(_amount);     }      xtoken.mint(msg.sender, _amount);     if (_amount >= flushActivator) {         flushActiveVault();     } } ```  "}, {"title": "Save `vault.getToken()` as an immutable variable in `YaxisVaultAdapter.sol` contract can save gas", "html_url": "https://github.com/code-423n4/2021-11-yaxis-findings/issues/52", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-11-yaxis-findings", "body": "# Handle  WatchPug   # Vulnerability details  Across the functions in `YaxisVaultAdapter.sol`, `vault.getToken()` is called many times, each one will cost a significant amount of gas due to external call.  Given that the result of `vault.getToken()` will never change, create an immutable variable named `token` in the contract and replace `vault.getToken()` with `token` can save gas.  `vault.getLPToken()` is a similar situation, it can also be cached as an immutable variable.  https://github.com/code-423n4/2021-11-yaxis/blob/146febcb61ae7fe20b0920849c4f4bbe111c6ba7/contracts/v3/alchemix/adapters/YaxisVaultAdapter.sol#L45-L45  https://github.com/code-423n4/2021-11-yaxis/blob/146febcb61ae7fe20b0920849c4f4bbe111c6ba7/contracts/v3/alchemix/adapters/YaxisVaultAdapter.sol#L70-L70  https://github.com/code-423n4/2021-11-yaxis/blob/146febcb61ae7fe20b0920849c4f4bbe111c6ba7/contracts/v3/alchemix/adapters/YaxisVaultAdapter.sol#L76-L76  "}, {"title": "Change unnecessary storage variables to constants can save gas", "html_url": "https://github.com/code-423n4/2021-11-yaxis-findings/issues/51", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor acknowledged"], "target": "2021-11-yaxis-findings", "body": "Change unnecessary storage variables to constants can save gas"}, {"title": "Use short reason strings can save gas", "html_url": "https://github.com/code-423n4/2021-11-yaxis-findings/issues/50", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged", "fix later"], "target": "2021-11-yaxis-findings", "body": "Use short reason strings can save gas"}, {"title": "Tokens with fee on transfer are not supported", "html_url": "https://github.com/code-423n4/2021-11-yaxis-findings/issues/49", "labels": ["bug", "0 (Non-critical)", "sponsor disputed", "wont fix"], "target": "2021-11-yaxis-findings", "body": "Tokens with fee on transfer are not supported"}, {"title": "Should `safeApprove(0)` first", "html_url": "https://github.com/code-423n4/2021-11-yaxis-findings/issues/48", "labels": ["bug", "0 (Non-critical)", "resolved"], "target": "2021-11-yaxis-findings", "body": "Should `safeApprove(0)` first"}, {"title": "Use of deprecated `safeApprove`", "html_url": "https://github.com/code-423n4/2021-11-yaxis-findings/issues/47", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged", "wont fix"], "target": "2021-11-yaxis-findings", "body": "Use of deprecated `safeApprove`"}, {"title": "`YaxisVaultAdapter.sol#withdraw()` will most certainly fail", "html_url": "https://github.com/code-423n4/2021-11-yaxis-findings/issues/46", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2021-11-yaxis-findings", "body": "# Handle  WatchPug   # Vulnerability details  The actual token withdrawn from `vault.withdraw()` will most certainly less than the `_amount`, due to precision loss in `_tokensToShares()` and `vault.withdraw()`.  As a result, `IDetailedERC20(_token).safeTransfer(_recipient, _amount)` will revert due to insufficant balance.  Based on the simulation we ran, it will fail `99.99%` of the time unless the pps == 1e18.  https://github.com/code-423n4/2021-11-yaxis/blob/146febcb61ae7fe20b0920849c4f4bbe111c6ba7/contracts/v3/alchemix/adapters/YaxisVaultAdapter.sol#L68-L72  ```solidity=68 function withdraw(address _recipient, uint256 _amount) external override onlyAdmin {     vault.withdraw(_tokensToShares(_amount));     address _token = vault.getToken();     IDetailedERC20(_token).safeTransfer(_recipient, _amount); } ```  https://github.com/code-423n4/2021-11-yaxis/blob/146febcb61ae7fe20b0920849c4f4bbe111c6ba7/contracts/v3/Vault.sol#L181-L187  ```solidity function withdraw(     uint256 _shares )     public     override {     uint256 _amount = (balance().mul(_shares)).div(IERC20(address(vaultToken)).totalSupply()); ```  ### Recommendation  Change to:  ```solidity=68 function withdraw(address _recipient, uint256 _amount) external override onlyAdmin {     address _token = vault.getToken();     uint256 beforeBalance = IDetailedERC20(_token).balanceOf(address(this));          vault.withdraw(_tokensToShares(_amount));      IDetailedERC20(_token).safeTransfer(         _recipient,         IDetailedERC20(_token).balanceOf(address(this)) - beforeBalance     ); } ```  "}, {"title": "`YaxisVaultAdapter.sol` Use inline expression can save gas", "html_url": "https://github.com/code-423n4/2021-11-yaxis-findings/issues/45", "labels": ["bug", "G (Gas Optimization)", "resolved"], "target": "2021-11-yaxis-findings", "body": "`YaxisVaultAdapter.sol` Use inline expression can save gas"}, {"title": "Cache and read storage variables from the stack can save gas", "html_url": "https://github.com/code-423n4/2021-11-yaxis-findings/issues/44", "labels": ["bug", "G (Gas Optimization)", "resolved"], "target": "2021-11-yaxis-findings", "body": "Cache and read storage variables from the stack can save gas"}, {"title": "Only using `SafeMath` when necessary can save gas", "html_url": "https://github.com/code-423n4/2021-11-yaxis-findings/issues/41", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-11-yaxis-findings", "body": "# Handle  WatchPug   # Vulnerability details  For the arithmetic operations that will never over/underflow, using SafeMath will cost more gas.  For example:  https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/BorrowerOperations.sol#L791-L795  ```solidity=791 if (_debtChange > _variableYUSDFee) { // if debt decrease, and greater than variable fee, decrease      newDebt = _troveManager.decreaseTroveDebt(_borrower, _debtChange.sub(_variableYUSDFee)); } else { // otherwise increase by opposite subtraction     newDebt = _troveManager.increaseTroveDebt(_borrower, _variableYUSDFee.sub(_debtChange)); } ```  `_debtChange - _variableYUSDFee` at L792 and `_variableYUSDFee - _debtChange` at L794 will never underflow.   https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/YUSDToken.sol#L240-L241  ```solidity=240 _totalSupply = _totalSupply.add(amount); _balances[account] = _balances[account].add(amount); ```  `_balances[account] + amount` will not overflow if `_totalSupply.add(amount)` dose not overflow.    https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/YUSDToken.sol#L248-L249  ```solidity=248 _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\"); _totalSupply = _totalSupply.sub(amount); ```  `_totalSupply - amount` will not underflow if `_balances[account].sub(amount)` dose not underflow.   "}, {"title": "Use immutable variable can save gas", "html_url": "https://github.com/code-423n4/2021-11-yaxis-findings/issues/37", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-11-yaxis-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-yaxis/blob/0311dd421fb78f4f174aca034e8239d1e80075fe/contracts/v3/alchemix/adapters/YaxisVaultAdapter.sol#L23-L27  ```solidity=23 /// @dev The vault that the adapter is wrapping.     IVault public vault;      /// @dev The address which has admin control over this contract.     address public admin; ```  `vault` and `admin` will never change, use immutable variable instead of storage variable can save gas.  https://github.com/code-423n4/2021-11-yaxis/blob/146febcb61ae7fe20b0920849c4f4bbe111c6ba7/contracts/v3/alchemix/Transmuter.sol#L55-L56  ```solidity address public AlToken; address public Token; ```  `AlToken` and `Token` can also be changed to `immutable`.  https://github.com/code-423n4/2021-11-yaxis/blob/0311dd421fb78f4f174aca034e8239d1e80075fe/contracts/v3/alchemix/Alchemist.sol#L114-L122  ```solidity=114 /// @dev The token that this contract is using as the parent asset. IMintableERC20 public token;  /// @dev The token that this contract is using as the child asset. IMintableERC20 public xtoken; ```  `token` and `xtoken` can also be changed to `immutable`.  ### Recommendation  Change to:  ```solidity /// @dev The vault that the adapter is wrapping. IVault public immutable vault;  /// @dev The address which has admin control over this contract. address public immutable admin;  constructor(IVault _vault, address _admin) public {     vault = _vault;     admin = _admin;     address _token = _vault.getToken();     IDetailedERC20(_token).safeApprove(address(_vault), uint256(-1)); } ```  "}, {"title": "Unnecessary libraries", "html_url": "https://github.com/code-423n4/2021-11-yaxis-findings/issues/36", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor disputed"], "target": "2021-11-yaxis-findings", "body": "Unnecessary libraries"}, {"title": "Incorrect function docs", "html_url": "https://github.com/code-423n4/2021-11-yaxis-findings/issues/35", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2021-11-yaxis-findings", "body": "# Handle  pmerkleplant   # Vulnerability details  The functions `AlToken::setBlacklist` and `AlToken::pauseAlchemist` in `v3/alchemix` state in their docs: \"This function reverts, if the caller does not have the admin role\".  However, the functions revert if the caller does not have the **sentinel** role.  See [lines 93-98](https://github.com/code-423n4/2021-11-yaxis/blob/main/contracts/v3/alchemix/AlToken.sol#L93).  "}, {"title": "Missing events for owner only functions that change critical parameters", "html_url": "https://github.com/code-423n4/2021-11-yaxis-findings/issues/34", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged", "fix later"], "target": "2021-11-yaxis-findings", "body": "Missing events for owner only functions that change critical parameters"}, {"title": "`Alchemist.sol` does not use safeApprove", "html_url": "https://github.com/code-423n4/2021-11-yaxis-findings/issues/33", "labels": ["bug", "1 (Low Risk)", "sponsor disputed", "wont fix"], "target": "2021-11-yaxis-findings", "body": "`Alchemist.sol` does not use safeApprove"}, {"title": "CDP.sol update overwrites user's credit on every positive increment", "html_url": "https://github.com/code-423n4/2021-11-yaxis-findings/issues/31", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor disputed"], "target": "2021-11-yaxis-findings", "body": "CDP.sol update overwrites user's credit on every positive increment"}, {"title": "Redundant Import", "html_url": "https://github.com/code-423n4/2021-11-yaxis-findings/issues/28", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor acknowledged"], "target": "2021-11-yaxis-findings", "body": "Redundant Import"}, {"title": "Upgrade pragma to at least 0.8.4", "html_url": "https://github.com/code-423n4/2021-11-yaxis-findings/issues/26", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged", "fix later"], "target": "2021-11-yaxis-findings", "body": "Upgrade pragma to at least 0.8.4"}, {"title": "No event for `Alchemist.sol#setPegMinimum`", "html_url": "https://github.com/code-423n4/2021-11-yaxis-findings/issues/24", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor confirmed", "wont fix"], "target": "2021-11-yaxis-findings", "body": "# Handle  0x0x0x   # Vulnerability details  ## Impact The change of `pegMinimum` is crucial for the funcionality of the contract. Users should be informed about the changes. Furthermore, when `pegMinimum` is set to be maximum of `uin256`, functions such as `mint`, `liquidate` and `repay` cannot be used. Therefore, the change of `pegMinimum` should be emitted to create a safe environment for users.   ## Tools Used Manual analysis ## Recommended Mitigation Steps Emit the changes. Furthermore, it would be better if for such a change users get notified beforehand with a mechanism such as Timelock.  "}, {"title": "At `Alchemist.sol#acceptGovernance`, cache `pendingGovernance` earlier to save gas", "html_url": "https://github.com/code-423n4/2021-11-yaxis-findings/issues/23", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-11-yaxis-findings", "body": "# Handle  0x0x0x   # Vulnerability details  ## Impact `Alchemist.sol#acceptGovernance`(L216-225) is: ```     function acceptGovernance() external {         require(msg.sender == _pendingGovernance, 'sender is not pendingGovernance');         address _pendingGovernance = pendingGovernance;         governance = _pendingGovernance;          emit GovernanceUpdated(_pendingGovernance);     } ``` It can be replaced with following code to save gas: ```     function acceptGovernance() external {         address _pendingGovernance = pendingGovernance;         require(msg.sender == _pendingGovernance, 'sender is not pendingGovernance');         governance = _pendingGovernance;          emit GovernanceUpdated(_pendingGovernance);     } ``` ## Tools Used  Manual analysis  "}, {"title": "For uint `> 0` can be replaced with ` != 0` for gas optimisation", "html_url": "https://github.com/code-423n4/2021-11-yaxis-findings/issues/22", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged", "fix later"], "target": "2021-11-yaxis-findings", "body": "# Handle  0x0x0x   # Vulnerability details  ## Impact  `!= 0` is a cheaper operation compared to `> 0`, when dealing with `uint`.  ## Occurences  ```  ./AbstractRewardMine.sol:147:    if (rewardDenominator > 0) { ./Auction.sol:219:    require(amountTokens > 0, \"No claimable Arb tokens\"); ./Auction.sol:265:    return auction.endingTime > 0 && (now >= auction.endingTime || auction.finalPrice > 0 || auction.commitments >= auction.maxCommitments); ./Auction.sol:385:    return auction.startingTime > 0; ./Auction.sol:639:    if (realBurnBudget > 0) { ./Auction.sol:659:    require(auction.startingTime > 0, \"No auction available for the given id\"); ./Auction.sol:663:    if (auction.maltPurchased > 0) { ./Auction.sol:861:          if (auction.commitments > 0 || !auction.finalized) { ./Auction.sol:894:    require(_length > 0, \"Length must be larger than 0\"); ./Auction.sol:972:    require(_split > 0 && _split <= 10000, \"Must be between 0-100%\"); ./Auction.sol:980:    require(_maxEnd > 0 && _maxEnd <= 1000, \"Must be between 0-100%\"); ./Auction.sol:988:    require(_lookback > 0, \"Must be above 0\"); ./Auction.sol:996:    require(_lookback > 0, \"Must be above 0\"); ./Auction.sol:1004:    require(_bps > 0 && _bps < 1000, \"Must be between 0-100%\"); ./Auction.sol:1012:    require(_threshold > 0, \"Must be between greater than 0\"); ./AuctionBurnReserveSkew.sol:109:    if (aggregate.maxCommitments > 0) { ./AuctionBurnReserveSkew.sol:190:    require(_lookback > 0, \"Cannot have zero lookback period\"); ./AuctionEscapeHatch.sol:191:    require(amount > 0, \"Nothing to claim\"); ./AuctionEscapeHatch.sol:222:    require(_earlyExitBps > 0 && _earlyExitBps <= 1000, \"Must be between 0-100%\"); ./AuctionEscapeHatch.sol:230:    require(_period > 0, \"Cannot have 0 lookback period\"); ./AuctionPool.sol:118:    if (globalRewarded > 0 && userReward > 0) { ./AuctionPool.sol:125:    if (forfeitAmount > 0) { ./AuctionPool.sol:129:    if (declaredRewardDecrease > 0) { ./AuctionPool.sol:141:    if (forfeitedRewards > 0) { ./Bonding.sol:87:    require(amount > 0, \"Cannot bond 0\"); ./Bonding.sol:97:    require(amount > 0, \"Cannot unbond 0\"); ./Bonding.sol:101:    require(bondedBalance > 0, \"< bonded balance\"); ./Bonding.sol:117:    require(amount > 0, \"Cannot unbond 0\"); ./Bonding.sol:121:    require(bondedBalance > 0, \"< bonded balance\"); ./Bonding.sol:283:      if (diff > 0) { ./DAO.sol:47:    if (offeringMint > 0) { ./DAO.sol:78:    require(amount > 0, \"Cannot have zero amount\"); ./DAO.sol:94:    require(_length > 0, \"Cannot have zero length epochs\"); ./ERC20VestedMine.sol:93:    if (globalRewarded > 0 && userReward > 0) { ./ERC20VestedMine.sol:115:    if (forfeitReward > 0) { ./ERC20VestedMine.sol:119:    if (declaredRewardDecrease > 0) { ./ForfeitHandler.sol:49:    if (swingTraderCut > 0) { ./ForfeitHandler.sol:53:    if (treasuryCut > 0) { ./ImpliedCollateralService.sol:64:    if (maxAmount > 0) { ./ImpliedCollateralService.sol:68:    if (maxAmount > 0) { ./ImpliedCollateralService.sol:71:      // if (maxAmount > 0) { ./ImpliedCollateralService.sol:74:      //   if (maxAmount > 0) { ./LiquidityExtension.sol:161:    require(_ratio > 0 && _ratio <= 100, \"Must be between 0 and 100\"); ./MaltDataLab.sol:234:    require(_price > 0, \"Cannot have 0 price\"); ./MaltDataLab.sol:242:    require(_lookback > 0, \"Cannot have 0 lookback\"); ./MaltDataLab.sol:250:    require(_lookback > 0, \"Cannot have 0 lookback\"); ./MaltDataLab.sol:258:    require(_lookback > 0, \"Cannot have 0 lookback\"); ./MovingAverage.sol:385:    if (oldSample.timestamp > 0 && activeSamples > 1) { ./MovingAverage.sol:412:    require(_sampleLength > 0, \"Cannot have 0 second sample length\"); ./MovingAverage.sol:428:    require(_sampleMemory > 0, \"Cannot have sample memroy of 0\"); ./PoolTransferVerification.sol:76:    require(newThreshold > 0 && newThreshold < 10000, \"Threshold must be between 0-100%\"); ./PoolTransferVerification.sol:85:    require(lookback > 0, \"Cannot have 0 lookback\"); ./RewardReinvestor.sol:93:    require(rewardLiquidity > 0, \"Cannot reinvest 0\"); ./RewardReinvestor.sol:115:    if (maltBalance > 0) { ./RewardReinvestor.sol:119:    if (rewardTokenBalance > 0) { ./RewardSystem/RewardDistributor.sol:144:    require(reward > 0, \"Cannot declare 0 reward\"); ./RewardSystem/RewardDistributor.sol:266:    if (amount > 0) { ./RewardSystem/RewardDistributor.sol:277:    if (amount > 0) { ./RewardSystem/RewardOverflowPool.sol:76:    require(_maxFulfillment > 0, \"Can't have 0 max fulfillment\"); ./RewardSystem/RewardThrottle.sol:85:    if (aprTarget > 0 && _epochAprGivenReward(epoch, balance) > aprTarget) { ./RewardSystem/RewardThrottle.sol:89:      if (remainder > 0) { ./RewardSystem/RewardThrottle.sol:271:          if (underflow > 0) { ./RewardSystem/RewardThrottle.sol:323:    require(_smoothingPeriod > 0, \"No zero smoothing period\"); ./StabilizerNode.sol:270:    if (callerCut > 0) { ./StabilizerNode.sol:274:    if (auctionPoolCut > 0) { ./StabilizerNode.sol:278:    if (swingTraderCut > 0) { ./StabilizerNode.sol:282:    if (treasuryCut > 0) { ./StabilizerNode.sol:286:    if (daoCut > 0) { ./StabilizerNode.sol:290:    if (lpCut > 0) { ./StabilizerNode.sol:359:    require(_period > 0, \"Must be greater than 0\"); ./StabilizerNode.sol:406:    require(_incentive > 0, \"No negative incentive\"); ./StabilizerNode.sol:417:    require(amount > 0, \"No negative damping\"); ./StabilizerNode.sol:449:    require(_upper > 0 && _lower > 0, \"Must be above 0\"); ./StabilizerNode.sol:488:    require(_maxContribution > 0 && _maxContribution <= 100, \"Must be between 0 and 100\"); ./StabilizerNode.sol:552:    require(_period > 0, \"Cannot have 0 period\"); ./StabilizerNode.sol:561:    require(_distance > 0 && _distance < 1000, \"Override must be between 0-100%\"); ./StabilizerNode.sol:570:    require(_period > 0, \"Cannot have 0 period\"); ./SwingTrader.sol:136:    if (profit > 0) { ./libraries/SafeBurnMintableERC20.sol:70:        if (returndata.length > 0) { // Return data is optional ./libraries/UniswapV2Library.sol:37:        require(amountA > 0, 'UniswapV2Library: INSUFFICIENT_AMOUNT'); ./libraries/UniswapV2Library.sol:38:        require(reserveA > 0 && reserveB > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'); ./libraries/UniswapV2Library.sol:44:        require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'); ./libraries/UniswapV2Library.sol:45:        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'); ./libraries/UniswapV2Library.sol:54:        require(amountOut > 0, 'UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT'); ./libraries/UniswapV2Library.sol:55:        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'); ./libraries/UniswapV2Library.sol:77:        for (uint i = path.length - 1; i > 0; i--) {  ```  "}, {"title": "Lack of Proper Tests?", "html_url": "https://github.com/code-423n4/2021-11-yaxis-findings/issues/20", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "fix later"], "target": "2021-11-yaxis-findings", "body": "Lack of Proper Tests?"}, {"title": "Remove FixedPointMath ", "html_url": "https://github.com/code-423n4/2021-11-yaxis-findings/issues/18", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-11-yaxis-findings", "body": "# Handle  TimmyToes   # Vulnerability details  ## Impact Including unused libraries could potentially use up gas and certainly makes the code more difficult to understand, hindering developer integrations/poor confused security auditors.  ## Proof of Concept https://github.com/code-423n4/2021-11-yaxis/blob/0311dd421fb78f4f174aca034e8239d1e80075fe/contracts/v3/alchemix/adapters/YaxisVaultAdapter.sol#L19 https://github.com/code-423n4/2021-11-yaxis/blob/0311dd421fb78f4f174aca034e8239d1e80075fe/contracts/v3/alchemix/adapters/YearnVaultAdapter.sol#L19 The contract does not use FixedPointMath and compiles with these lines removed.  ## Recommended Mitigation Steps Remove line 10,19 from each contract (FixedPointMath lines). I'd also prefer the removal of  import \"hardhat/console.sol\"; but this is not having any impact and is just to tidy and shorten the files.  "}, {"title": "Cache length of array when looping", "html_url": "https://github.com/code-423n4/2021-11-yaxis-findings/issues/17", "labels": ["bug", "invalid", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-11-yaxis-findings", "body": "Cache length of array when looping"}, {"title": "admin Variable is High Risk", "html_url": "https://github.com/code-423n4/2021-11-yaxis-findings/issues/15", "labels": ["bug", "0 (Non-critical)", "sponsor disputed", "wont fix"], "target": "2021-11-yaxis-findings", "body": "admin Variable is High Risk"}, {"title": "Prevent Minting During Emergency Exit", "html_url": "https://github.com/code-423n4/2021-11-yaxis-findings/issues/12", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2021-11-yaxis-findings", "body": "# Handle  TimmyToes   # Vulnerability details  ## Impact Potential increased financial loss during security incident.  ## Proof of Concept https://github.com/code-423n4/2021-11-yaxis/blob/0311dd421fb78f4f174aca034e8239d1e80075fe/contracts/v3/alchemix/Alchemist.sol#L611 Consider a critical incident where a vault is being drained or in danger of being drained due to a vulnerability within the vault or its strategies. At this stage, you want to trigger emergency exit and users want to withdraw their funds and repay/liquidate to enable the withdrawal of funds. However, minting against debt does not seem like a desirable behaviour at this time. It only seems to enable unaware users to get themselves into trouble by locking up their funds, or allow an attacker to do more damage.  ## Recommended Mitigation Steps Convert emergency exit check to a modifier, award wardens who made that suggestion, and then apply that modifier here.  Alternatively, it is possible that the team might want to allow minting against credit: users minting against credit would effectively be cashing out their rewards. This might be seen as desirable during emergency exit, or it might be seen as a potential extra source of risk. If this is desired, then the emergency exit check could be placed at line 624 with a modified message, instructing users to only use credit.  "}, {"title": "Convert Emergency Exit Check to Modifier.", "html_url": "https://github.com/code-423n4/2021-11-yaxis-findings/issues/11", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2021-11-yaxis-findings", "body": "# Handle  TimmyToes   # Vulnerability details  ## Impact Gas saving on deployment. Guaranteed consistency, especially if making the same check across multiple functions (and I'm about to suggest that you might want to check this more). Increased functionality of inheriting contracts. Improved readability and code organisation. Basically, every reason that modifiers exist in the first place.  ## Proof of Concept https://github.com/code-423n4/2021-11-yaxis/blob/0311dd421fb78f4f174aca034e8239d1e80075fe/contracts/v3/alchemix/Alchemist.sol#L457 https://github.com/code-423n4/2021-11-yaxis/blob/0311dd421fb78f4f174aca034e8239d1e80075fe/contracts/v3/alchemix/Alchemist.sol#L489  ## Tools Used  ## Recommended Mitigation Steps Convert emergency exit check to modifier.   "}, {"title": "Effects and Interactions Before Check", "html_url": "https://github.com/code-423n4/2021-11-yaxis-findings/issues/10", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged", "fix later"], "target": "2021-11-yaxis-findings", "body": "Effects and Interactions Before Check"}, {"title": "Multiple Assignments to Storage Variable", "html_url": "https://github.com/code-423n4/2021-11-yaxis-findings/issues/9", "labels": ["bug", "G (Gas Optimization)", "sponsor disputed", "wont fix"], "target": "2021-11-yaxis-findings", "body": "Multiple Assignments to Storage Variable"}, {"title": "Incorrect Event Emitted in Alchemist.sol", "html_url": "https://github.com/code-423n4/2021-11-yaxis-findings/issues/7", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2021-11-yaxis-findings", "body": "# Handle  TimmyToes   # Vulnerability details  ## Impact The event emitted is for the updating of a different fee (the harvest fee). This could cause potential issues for any system wishing to integrate with yAxis and wishing to monitor changes to the system and potentially react to them. Such a system could record the wrong harvest  fee and would be unaware of updates to the borrow fee.  ## Proof of Concept https://github.com/code-423n4/2021-11-yaxis/blob/0311dd421fb78f4f174aca034e8239d1e80075fe/contracts/v3/alchemix/Alchemist.sol#L299 Is the same as line 284  ## Recommended Mitigation Steps Create a new event: event BorrowFeeUpdated(uint256 borrowfee); and call it on line 299 instead of HarvestFeeUpdated   "}, {"title": "Incorrect Info in Comment in Alchemist.sol (138)", "html_url": "https://github.com/code-423n4/2021-11-yaxis-findings/issues/6", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2021-11-yaxis-findings", "body": "# Handle  TimmyToes   # Vulnerability details  ## Impact Developers wishing to interact with yAxis will find it harder to do so.  ## Proof of Concept Lines 138 of Alchemist.sol /// @dev The percent of each profitable harvest that will go to the rewards contract. This comment is incorrect. The borrow fee is charged on mint against debt, not harvest.  ## Recommended Mitigation Steps Edit the comment.   "}, {"title": "Incorrect Info in Comment in Alchemist.sol", "html_url": "https://github.com/code-423n4/2021-11-yaxis-findings/issues/5", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2021-11-yaxis-findings", "body": "# Handle  TimmyToes   # Vulnerability details  ## Impact Developers wishing to interact with yAxis will find it harder to do so.  ## Proof of Concept Lines 157-8 of Alchemist.sol    /// @dev A mapping of all of the user CDPs. If a user wishes to have multiple CDPs they will have to either     /// create a new address or set up a proxy contract that interfaces with this contract. A proxy contract is not an option as most of the functions in the Alchemist contract have a noContractAllowed  modifier.  ## Recommended Mitigation Steps Edit the comment to remove the proxy suggestion.   "}, {"title": "Lack of 'emit' keyword in AlToken.sol", "html_url": "https://github.com/code-423n4/2021-11-yaxis-findings/issues/4", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2021-11-yaxis-findings", "body": "# Handle  tqts   # Vulnerability details  ## Impact An event is called without the emit keyword  ## Proof of Concept https://github.com/code-423n4/2021-11-yaxis/blob/0311dd421fb78f4f174aca034e8239d1e80075fe/contracts/v3/alchemix/AlToken.sol#L100  ## Tools Used Manual review  ## Recommended Mitigation Steps Add the 'emit' keyword in the event emission.  "}, {"title": "Gas optimization in AlToken.sol", "html_url": "https://github.com/code-423n4/2021-11-yaxis-findings/issues/3", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-11-yaxis-findings", "body": "# Handle  tqts   # Vulnerability details  ## Impact Double calculation of the same value in mint()  ## Proof of Concept https://github.com/code-423n4/2021-11-yaxis/blob/0311dd421fb78f4f174aca034e8239d1e80075fe/contracts/v3/alchemix/AlToken.sol#L69  ## Tools Used Manual review  ## Recommended Mitigation Steps The _total variable in line 66 is defined as _amount + hasMinted(msg.sender). Line 69 needs that value again but recalculates it again instead of using the stored one. Replace line 69 with hasMinted(msg.sender) = _total  "}, {"title": "Gas optimization when a paused user calls mint() in AlToken.sol", "html_url": "https://github.com/code-423n4/2021-11-yaxis-findings/issues/2", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-11-yaxis-findings", "body": "# Handle  tqts   # Vulnerability details  ## Impact Gas saved when a paused user calls mint()  ## Proof of Concept https://github.com/code-423n4/2021-11-yaxis/blob/0311dd421fb78f4f174aca034e8239d1e80075fe/contracts/v3/alchemix/AlToken.sol#L68  ## Tools Used Manual review  ## Recommended Mitigation Steps Check for the paused condition before checking for the ceiling condition. If the user is paused, the function reverts earlier, saving gas.  "}, {"title": "Gas Optimization on the Public Function", "html_url": "https://github.com/code-423n4/2021-11-badgerzaps-findings/issues/79", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-badgerzaps-findings", "body": "Gas Optimization on the Public Function"}, {"title": "Gas optimization: Unnecessary ops", "html_url": "https://github.com/code-423n4/2021-11-badgerzaps-findings/issues/78", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-badgerzaps-findings", "body": "Gas optimization: Unnecessary ops"}, {"title": "Gas optimization: Unreachable code in Zap.sol", "html_url": "https://github.com/code-423n4/2021-11-badgerzaps-findings/issues/77", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-badgerzaps-findings", "body": "Gas optimization: Unreachable code in Zap.sol"}, {"title": "Gas optimization: Use else if for mutually exclusive conditions", "html_url": "https://github.com/code-423n4/2021-11-badgerzaps-findings/issues/76", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-badgerzaps-findings", "body": "Gas optimization: Use else if for mutually exclusive conditions"}, {"title": "`calcMint` always return poolId=0 and idx=0", "html_url": "https://github.com/code-423n4/2021-11-badgerzaps-findings/issues/72", "labels": ["bug", "2 (Med Risk)"], "target": "2021-11-badgerzaps-findings", "body": "`calcMint` always return poolId=0 and idx=0"}, {"title": "No slippage control on `deposit` of IbbtcVaultZap.sol", "html_url": "https://github.com/code-423n4/2021-11-badgerzaps-findings/issues/71", "labels": ["bug", "2 (Med Risk)"], "target": "2021-11-badgerzaps-findings", "body": "No slippage control on `deposit` of IbbtcVaultZap.sol"}, {"title": "Open TODOs", "html_url": "https://github.com/code-423n4/2021-11-badgerzaps-findings/issues/67", "labels": ["bug", "0 (Non-critical)"], "target": "2021-11-badgerzaps-findings", "body": "Open TODOs"}, {"title": "public function that could be set external instead", "html_url": "https://github.com/code-423n4/2021-11-badgerzaps-findings/issues/61", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-badgerzaps-findings", "body": "public function that could be set external instead"}, {"title": "Zap.sol init for loop - uint default value is 0", "html_url": "https://github.com/code-423n4/2021-11-badgerzaps-findings/issues/60", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-badgerzaps-findings", "body": "Zap.sol init for loop - uint default value is 0"}, {"title": "named return issue - Zap.sol calcMint", "html_url": "https://github.com/code-423n4/2021-11-badgerzaps-findings/issues/59", "labels": ["bug", "disagree with severity", "sponsor disputed", "0 (Non-critical)"], "target": "2021-11-badgerzaps-findings", "body": "named return issue - Zap.sol calcMint"}, {"title": " Unnecessary `SLOAD`s / `MLOAD`s / `CALLDATALOAD`s in for-each loops", "html_url": "https://github.com/code-423n4/2021-11-badgerzaps-findings/issues/58", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-badgerzaps-findings", "body": " Unnecessary `SLOAD`s / `MLOAD`s / `CALLDATALOAD`s in for-each loops"}, {"title": "Critical changes should use two-step procedure", "html_url": "https://github.com/code-423n4/2021-11-badgerzaps-findings/issues/56", "labels": ["bug", "sponsor acknowledged", "0 (Non-critical)"], "target": "2021-11-badgerzaps-findings", "body": "Critical changes should use two-step procedure"}, {"title": "Missing events for critical operations", "html_url": "https://github.com/code-423n4/2021-11-badgerzaps-findings/issues/55", "labels": ["bug", "disagree with severity", "sponsor confirmed", "0 (Non-critical)"], "target": "2021-11-badgerzaps-findings", "body": "Missing events for critical operations"}, {"title": "Missing `_token.approve()` to `curvePool` in `setZapConfig`", "html_url": "https://github.com/code-423n4/2021-11-badgerzaps-findings/issues/53", "labels": ["bug", "sponsor confirmed", "2 (Med Risk)"], "target": "2021-11-badgerzaps-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/Badger-Finance/badger-ibbtc-utility-zaps/blob/8d265aacb905d30bd95dcd54505fb26dc1f9b0b6/contracts/SettToRenIbbtcZap.sol#L162-L183  ```solidity=162 function setZapConfig(         uint256 _idx,         address _sett,         address _token,         address _curvePool,         address _withdrawToken,         int128 _withdrawTokenIndex     ) external {         _onlyGovernance();          require(_sett != address(0));         require(_token != address(0));         require(             _withdrawToken == address(WBTC) || _withdrawToken == address(RENBTC)         );          zapConfigs[_idx].sett = ISett(_sett);         zapConfigs[_idx].token = IERC20Upgradeable(_token);         zapConfigs[_idx].curvePool = ICurveFi(_curvePool);         zapConfigs[_idx].withdrawToken = IERC20Upgradeable(_withdrawToken);         zapConfigs[_idx].withdrawTokenIndex = _withdrawTokenIndex;     } ```  In the current implementation, when `curvePool` or `token` got updated, `token` is not approved to `curvePool`, which will malfunction the contract and break minting.  ### Recommendation  Change to:  ```solidity=162 function setZapConfig(         uint256 _idx,         address _sett,         address _token,         address _curvePool,         address _withdrawToken,         int128 _withdrawTokenIndex     ) external {         _onlyGovernance();          require(_sett != address(0));         require(_token != address(0));         require(             _withdrawToken == address(WBTC) || _withdrawToken == address(RENBTC)         );          if (zapConfigs[_idx].curvePool != _curvePool && _curvePool != address(0)) {             IERC20Upgradeable(_token).safeApprove(                 _curvePool,                 type(uint256).max             );         }          zapConfigs[_idx].sett = ISett(_sett);         zapConfigs[_idx].token = IERC20Upgradeable(_token);         zapConfigs[_idx].curvePool = ICurveFi(_curvePool);         zapConfigs[_idx].withdrawToken = IERC20Upgradeable(_withdrawToken);         zapConfigs[_idx].withdrawTokenIndex = _withdrawTokenIndex;     } ```  "}, {"title": "`blockLock` of `RENCRV_SETT` makes transactions likely to fail as only 1 transaction is allowed in 1 block", "html_url": "https://github.com/code-423n4/2021-11-badgerzaps-findings/issues/52", "labels": ["bug", "disagree with severity", "1 (Low Risk)"], "target": "2021-11-badgerzaps-findings", "body": "`blockLock` of `RENCRV_SETT` makes transactions likely to fail as only 1 transaction is allowed in 1 block"}, {"title": "`setGuardian()` Wrong implementation", "html_url": "https://github.com/code-423n4/2021-11-badgerzaps-findings/issues/51", "labels": ["bug", "3 (High Risk)"], "target": "2021-11-badgerzaps-findings", "body": "`setGuardian()` Wrong implementation"}, {"title": "Excessive `require` makes the transaction fail unexpectedly", "html_url": "https://github.com/code-423n4/2021-11-badgerzaps-findings/issues/50", "labels": ["bug", "sponsor confirmed", "2 (Med Risk)"], "target": "2021-11-badgerzaps-findings", "body": "# Handle  WatchPug   # Vulnerability details  The check for `RENCRV_VAULT.blockLock` is only needed when `if (_amounts[1] > 0 || _amounts[2] > 0)`.   However, in the current implementation, the check is done at the very first, making transactions unrelated to `RENCRV_VAULT` fail unexpectedly if there is a prior transaction involved with `RENCRV_VAULT` in the same block.  https://github.com/Badger-Finance/badger-ibbtc-utility-zaps/blob/8d265aacb905d30bd95dcd54505fb26dc1f9b0b6/contracts/IbbtcVaultZap.sol#L149-L199  ```solidity=149{154-157,182} function deposit(uint256[4] calldata _amounts, uint256 _minOut)     public     whenNotPaused {     // Not block locked by setts     require(         RENCRV_VAULT.blockLock(address(this)) < block.number,         \"blockLocked\"     );     require(         IBBTC_VAULT.blockLock(address(this)) < block.number,         \"blockLocked\"     );      uint256[4] memory depositAmounts;      for (uint256 i = 0; i < 4; i++) {         if (_amounts[i] > 0) {             ASSETS[i].safeTransferFrom(                 msg.sender,                 address(this),                 _amounts[i]             );             if (i == 0 || i == 3) {                 // ibbtc and sbtc                 depositAmounts[i] += _amounts[i];             }         }     }      if (_amounts[1] > 0 || _amounts[2] > 0) {         // Use renbtc and wbtc to mint ibbtc         // NOTE: Can change to external zap if implemented         depositAmounts[0] += _renZapToIbbtc([_amounts[1], _amounts[2]]);     }     // ... } ```   "}, {"title": "`Zap.sol#mint()` Check `blockLock` earlier can save gas", "html_url": "https://github.com/code-423n4/2021-11-badgerzaps-findings/issues/49", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-badgerzaps-findings", "body": "`Zap.sol#mint()` Check `blockLock` earlier can save gas"}, {"title": "Improper implementation of slippage check", "html_url": "https://github.com/code-423n4/2021-11-badgerzaps-findings/issues/47", "labels": ["bug", "2 (Med Risk)"], "target": "2021-11-badgerzaps-findings", "body": "Improper implementation of slippage check"}, {"title": "Avoid unnecessary arithmetic operations can save gas", "html_url": "https://github.com/code-423n4/2021-11-badgerzaps-findings/issues/45", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-badgerzaps-findings", "body": "Avoid unnecessary arithmetic operations can save gas"}, {"title": "Arithmetic operations without using SafeMath may over/underflow", "html_url": "https://github.com/code-423n4/2021-11-badgerzaps-findings/issues/44", "labels": ["bug", "1 (Low Risk)"], "target": "2021-11-badgerzaps-findings", "body": "Arithmetic operations without using SafeMath may over/underflow"}, {"title": "Redundant type casting", "html_url": "https://github.com/code-423n4/2021-11-badgerzaps-findings/issues/42", "labels": ["bug", "0 (Non-critical)"], "target": "2021-11-badgerzaps-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/LaunchEvent.sol#L82-L82  ```solidity IJoeFactory private factory; ```  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/LaunchEvent.sol#L385-L385  ```solidity IJoeFactory(factory).getPair(wavaxAddress, tokenAddress) ```  `factory` is defined as `IJoeFactory` already, the type casting is redundant.  "}, {"title": "Avoid unnecessary code execution can save gas", "html_url": "https://github.com/code-423n4/2021-11-badgerzaps-findings/issues/41", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-badgerzaps-findings", "body": "Avoid unnecessary code execution can save gas"}, {"title": "Unused local variables", "html_url": "https://github.com/code-423n4/2021-11-badgerzaps-findings/issues/39", "labels": ["bug", "sponsor confirmed", "G (Gas Optimization)"], "target": "2021-11-badgerzaps-findings", "body": "# Handle  WatchPug   # Vulnerability details  Unused local variables in contracts increase contract size and gas usage at deployment.  Instances include:  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXStakingZap.sol#L187-L187  ```solidity=187 uint256 xTokensMinted = inventoryStaking.timelockMintFor(vaultId, count*BASE, msg.sender, inventoryLockTime); ```  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXStakingZap.sol#L207-L207  ```solidity=207 uint256 xTokensMinted = inventoryStaking.timelockMintFor(vaultId, count*BASE, msg.sender, inventoryLockTime); ```  "}, {"title": "`Zap.sol#redeem()` Lack of input validation", "html_url": "https://github.com/code-423n4/2021-11-badgerzaps-findings/issues/37", "labels": ["bug", "1 (Low Risk)"], "target": "2021-11-badgerzaps-findings", "body": "`Zap.sol#redeem()` Lack of input validation"}, {"title": "Avoid unnecessary read of array length in for loops can save gas", "html_url": "https://github.com/code-423n4/2021-11-badgerzaps-findings/issues/36", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-badgerzaps-findings", "body": "Avoid unnecessary read of array length in for loops can save gas"}, {"title": "`Zap.sol#mint()` Validation of `poolId` can be done earlier to save gas", "html_url": "https://github.com/code-423n4/2021-11-badgerzaps-findings/issues/35", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-badgerzaps-findings", "body": "`Zap.sol#mint()` Validation of `poolId` can be done earlier to save gas"}, {"title": "Adding `recipient` parameter to mint functions can help avoid unnecessary token transfers and save gas", "html_url": "https://github.com/code-423n4/2021-11-badgerzaps-findings/issues/34", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-badgerzaps-findings", "body": "Adding `recipient` parameter to mint functions can help avoid unnecessary token transfers and save gas"}, {"title": "Avoiding Initialization of Loop Index If It Is 0", "html_url": "https://github.com/code-423n4/2021-11-badgerzaps-findings/issues/29", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-badgerzaps-findings", "body": "Avoiding Initialization of Loop Index If It Is 0"}, {"title": "SLOAD pools.length for Every Loop is Waste of Gas ", "html_url": "https://github.com/code-423n4/2021-11-badgerzaps-findings/issues/28", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-badgerzaps-findings", "body": "SLOAD pools.length for Every Loop is Waste of Gas "}, {"title": "use modifier keyword to write modifier not function In SettToRenIbbtcZap.sol line no - 105 and 109", "html_url": "https://github.com/code-423n4/2021-11-badgerzaps-findings/issues/27", "labels": ["bug", "sponsor acknowledged", "0 (Non-critical)"], "target": "2021-11-badgerzaps-findings", "body": "use modifier keyword to write modifier not function In SettToRenIbbtcZap.sol line no - 105 and 109"}, {"title": "Modifier should be used instead of functions to write modifier in ibBTC VaultZap.sol", "html_url": "https://github.com/code-423n4/2021-11-badgerzaps-findings/issues/26", "labels": ["bug", "sponsor acknowledged", "0 (Non-critical)"], "target": "2021-11-badgerzaps-findings", "body": "Modifier should be used instead of functions to write modifier in ibBTC VaultZap.sol"}, {"title": "ibbtcCurveLP can be simplified", "html_url": "https://github.com/code-423n4/2021-11-badgerzaps-findings/issues/21", "labels": ["bug", "sponsor confirmed", "G (Gas Optimization)", "resolved"], "target": "2021-11-badgerzaps-findings", "body": "# Handle  ye0lde   # Vulnerability details  ## Impact  Removing unneeded branches and returns can reduce gas usage and improve code clarity.  ## Proof of Concept  This code https://github.com/Badger-Finance/ibbtc/blob/d8b95e8d145eb196ba20033267a9ba43a17be02c/contracts/Zap.sol#L309-L317 can be refactored to:  ```  if (bBtc <= max) {   // pesimistically charge 0.5% on the withdrawal.   // Actual fee might be lesser if the vault keeps keeps a buffer   uint strategyFee = sett.mul(controller.strategies(pool.lpToken).withdrawalFee()).div(10000);   lp = sett.sub(strategyFee).mul(pool.sett.getPricePerFullShare()).div(1e18);   fee = fee.add(strategyFee);  } ```  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps See POC  "}, {"title": "For `uint` use ` != 0` instead of ` > 0`", "html_url": "https://github.com/code-423n4/2021-11-badgerzaps-findings/issues/18", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-badgerzaps-findings", "body": "For `uint` use ` != 0` instead of ` > 0`"}, {"title": "Wrong comment on `SettToRenIbbtcZap.sol` and `IbbtcVaultZap.sol`", "html_url": "https://github.com/code-423n4/2021-11-badgerzaps-findings/issues/16", "labels": ["bug", "disagree with severity", "1 (Low Risk)"], "target": "2021-11-badgerzaps-findings", "body": "Wrong comment on `SettToRenIbbtcZap.sol` and `IbbtcVaultZap.sol`"}, {"title": "Missing overflow protection", "html_url": "https://github.com/code-423n4/2021-11-badgerzaps-findings/issues/13", "labels": ["bug", "sponsor confirmed", "1 (Low Risk)"], "target": "2021-11-badgerzaps-findings", "body": "# Handle  pmerkleplant   # Vulnerability details  ## Impact Function `deposit` in `IbbtcVaultZap.sol` computes two additions without overflow protection, see lines [158](https://github.com/Badger-Finance/badger-ibbtc-utility-zaps/blob/6f700995129182fec81b772f97abab9977b46026/contracts/IbbtcVaultZap.sol#L158) and [166](https://github.com/Badger-Finance/badger-ibbtc-utility-zaps/blob/6f700995129182fec81b772f97abab9977b46026/contracts/IbbtcVaultZap.sol#L166).  In the first case, i.e. line 158, the addition can be changed to an assignment, as `depositAmount[i]` is always 0.  In the second case, i.e. line 166, an overflow would lead to a wrong amount of funds deposited into Curve and from there to a wrong amount of LP tokens send to the `msg.sender`.  ## Recommended Steps of Mitigation As OpenZeppelin's `SafeMathUpgradeable` library is already imported, use their `add` function instead of the native `+` operator.  "}, {"title": "Use safeTransfer/safeTransferFrom consistently instead of transfer/transferFrom", "html_url": "https://github.com/code-423n4/2021-11-badgerzaps-findings/issues/8", "labels": ["bug", "sponsor acknowledged", "1 (Low Risk)"], "target": "2021-11-badgerzaps-findings", "body": "Use safeTransfer/safeTransferFrom consistently instead of transfer/transferFrom"}, {"title": "Zap.sol declares unused variable `_ren` in `calcRedeemInRen` among other functions", "html_url": "https://github.com/code-423n4/2021-11-badgerzaps-findings/issues/4", "labels": ["bug", "sponsor confirmed", "G (Gas Optimization)", "resolved"], "target": "2021-11-badgerzaps-findings", "body": "# Handle  TomFrench   # Vulnerability details  ## Impact  Gas costs  ## Proof of Concept  The variable `_ren` in `Zap.calcRedeemInRen` is declared but unused. This increases gas costs for no benefit.  https://github.com/Badger-Finance/ibbtc/blob/d8b95e8d145eb196ba20033267a9ba43a17be02c/contracts/Zap.sol#L272-L280  This also happens in other functions.  ## Recommended Mitigation Steps  Remove unused variable  "}, {"title": "Zap contract's redeem() function doesn't check which token the user wants to receive", "html_url": "https://github.com/code-423n4/2021-11-badgerzaps-findings/issues/2", "labels": ["bug", "2 (Med Risk)"], "target": "2021-11-badgerzaps-findings", "body": "Zap contract's redeem() function doesn't check which token the user wants to receive"}, {"title": "Zap contract's mint() allows minting ibbtc tokens for free", "html_url": "https://github.com/code-423n4/2021-11-badgerzaps-findings/issues/1", "labels": ["bug", "disagree with severity", "sponsor disputed", "1 (Low Risk)"], "target": "2021-11-badgerzaps-findings", "body": "Zap contract's mint() allows minting ibbtc tokens for free"}, {"title": "`withdrawTo` Does Not Sync Before Checking A Position's Margin Requirements", "html_url": "https://github.com/code-423n4/2021-12-perennial-findings/issues/74", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2021-12-perennial-findings", "body": "# Handle  leastwood   # Vulnerability details  ## Impact  The `maintenanceInvariant` modifier in `Collateral` aims to check if a user meets the margin requirements to withdraw collateral by checking its current and next maintenance. `maintenanceInvariant` inevitably calls `AccountPosition.maintenance` which uses the oracle's price to calculate the margin requirements for a given position. Hence, if the oracle has not synced in a long time, `maintenanceInvariant` may end up utilising an outdated price for a withdrawal. This may allow a user to withdraw collateral on an undercollaterized position.  ## Proof of Concept  https://github.com/code-423n4/2021-12-perennial/blob/main/protocol/contracts/collateral/Collateral.sol#L67-L76 ``` function withdrawTo(address account, IProduct product, UFixed18 amount) notPaused collateralInvariant(msg.sender, product) maintenanceInvariant(msg.sender, product) external {     _products[product].debitAccount(msg.sender, amount);     token.push(account, amount);      emit Withdrawal(msg.sender, product, amount); } ```  https://github.com/code-423n4/2021-12-perennial/blob/main/protocol/contracts/collateral/Collateral.sol#L233-L241 ``` modifier maintenanceInvariant(address account, IProduct product) {     _;      UFixed18 maintenance = product.maintenance(account);     UFixed18 maintenanceNext = product.maintenanceNext(account);      if (UFixed18Lib.max(maintenance, maintenanceNext).gt(collateral(account, product)))         revert CollateralInsufficientCollateralError(); } ```  https://github.com/code-423n4/2021-12-perennial/blob/main/protocol/contracts/product/types/position/AccountPosition.sol#L71-L75 ```     function maintenanceInternal(Position memory position, IProductProvider provider) private view returns (UFixed18) {         Fixed18 oraclePrice = provider.priceAtVersion(provider.currentVersion());         UFixed18 notionalMax = Fixed18Lib.from(position.max()).mul(oraclePrice).abs();         return notionalMax.mul(provider.maintenance());     } ```  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider adding `settleForAccount(msg.sender)` to the `Collateral.withdrawTo` function to ensure the most up to date oracle price is used when assessing an account's margin requirements.  "}, {"title": "On updating the Incentive fee greater than UFixedLib18.ONE, new Programs can not be created", "html_url": "https://github.com/code-423n4/2021-12-perennial-findings/issues/72", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2021-12-perennial-findings", "body": "# Handle  hubble   # Vulnerability details  ## Impact Incentivizer.updateFee expects a value between UFixed18Lib.ZERO and UFixed18Lib.ONE. When the incentive fee is updated outside of this range, the program creation fails and the product owners would not be able to add new Programs to the Product.  ## Proof of Concept Step 1. Update incentive fee File: /protocol/contracts/incentivizer/Incentivizer.sol Line 368     function updateFee(UFixed18 newFee) onlyOwner external { Line 369             fee = newFee; ...  Step 2. Create new Program File: /protocol/contracts/incentivizer/Incentivizer.sol Line 59    function create(ProgramInfo calldata info)  File: /protocol/contracts/incentivizer/types/ProgramInfo.sol Line 55         Position memory amountAfterFee = info.amount.mul(UFixed18Lib.ONE.sub(fee)); ...  Note: Fails at line 55, whenever fee is greater than UFixedLive.ONE  ## Tools Used Manual code review  ## Recommended Mitigation Steps Implement Range check   File: /protocol/contracts/incentivizer/Incentivizer.sol Line 368     function updateFee(UFixed18 newFee) onlyOwner external { Line 369          if(newFee.gte(UFixed18Lib.ONE)) revert NewError(\"newFee should be less than UFixed18Lib.ONE\"); Line 370          fee = newFee;  Note: Range check at line 369  "}, {"title": "Initialization functions can be front-run", "html_url": "https://github.com/code-423n4/2021-12-perennial-findings/issues/71", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "resolved"], "target": "2021-12-perennial-findings", "body": "Initialization functions can be front-run"}, {"title": "`Collateral.sol#maintananceInvariant` can be combined with `collateralnvarant` to save gas", "html_url": "https://github.com/code-423n4/2021-12-perennial-findings/issues/70", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-12-perennial-findings", "body": "`Collateral.sol#maintananceInvariant` can be combined with `collateralnvarant` to save gas"}, {"title": "At settleAccountInternal, check whether the position can be changeable to pre more efficiently", "html_url": "https://github.com/code-423n4/2021-12-perennial-findings/issues/66", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-12-perennial-findings", "body": "# Handle  0x0x0x   # Vulnerability details  In case `oracleVersionCurrent != oracleVersionPreSettle`,  the following line  `accumulated = accumulated.sub(Fixed18Lib.from(_positions[account].settle(provider, oracleVersionPreSettle)));` ([https://github.com/code-423n4/2021-12-perennial/blob/main/protocol/contracts/product/Product.sol#L136](https://github.com/code-423n4/2021-12-perennial/blob/main/protocol/contracts/product/Product.sol#L136))  doesn't make any change. This line can be at the beginning of the `if` statement below to save gas.  "}, {"title": "At `Product.sol#closeAll`, cache `_position[account]`", "html_url": "https://github.com/code-423n4/2021-12-perennial-findings/issues/65", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-12-perennial-findings", "body": "# Handle  0x0x0x   # Vulnerability details  At `Product.sol#closeAll` cache `_position[account]` to save gas.   In the first line of the function `_position[account]` is used twice and gas can be saved by caching it.  "}, {"title": "No checks if given product is created by the factory", "html_url": "https://github.com/code-423n4/2021-12-perennial-findings/issues/63", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "resolved"], "target": "2021-12-perennial-findings", "body": "No checks if given product is created by the factory"}, {"title": "Adding unchecked directive can save gas", "html_url": "https://github.com/code-423n4/2021-12-perennial-findings/issues/57", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-12-perennial-findings", "body": "Adding unchecked directive can save gas"}, {"title": "Fixed18 conversions don't work for all values", "html_url": "https://github.com/code-423n4/2021-12-perennial-findings/issues/54", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2021-12-perennial-findings", "body": "# Handle  cmichel   # Vulnerability details  Certain functions in the `Fixed18` contract perform multiplications by `ONE` or `NEG_ONE` before diving by it again which leads to issues that these functions revert for all values `> MAX_UINT256 / ONE`, but they should not.  ```solidity function from(int256 s, UFixed18 m) internal pure returns (Fixed18) {     if (s > 0) return from(m);     // @audit cannot convert large values because (m * NEG_ONE) might overflow     if (s < 0) return mul(from(m), NEG_ONE);     return ZERO; }  function abs(Fixed18 a) internal pure returns (UFixed18) {     // @audit cannot get abs value if multiplication of a * -1e18 /1e18 overflows. why not unwrap => unary minus     return sign(a) == -1 ? UFixed18Lib.from(mul(a, NEG_ONE)) : UFixed18Lib.from(a); } ```  ## Recommendation Change the implementation to not perform the useless `* 1e18 / 1e18` computations to cover the entire input range. Consider using a typecast `int256(UFixed18.unwrap(m))` after checking the range instead of doing `* NEG_ONE / 1e18`   "}, {"title": "`NotControllerOwnerError` error not used", "html_url": "https://github.com/code-423n4/2021-12-perennial-findings/issues/52", "labels": ["bug", "disagree with severity", "G (Gas Optimization)", "resolved"], "target": "2021-12-perennial-findings", "body": "`NotControllerOwnerError` error not used"}, {"title": "Missing fee parameter validation", "html_url": "https://github.com/code-423n4/2021-12-perennial-findings/issues/50", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2021-12-perennial-findings", "body": "# Handle  cmichel   # Vulnerability details  Some fee parameters of functions are not checked for invalid values: - `Collateral.updateLiquidationFee`: The `newLiquidationFee` should be less than 100% - `Factory.updateFee`: The `newFee` should be less than 100%  ## Recommended Mitigation Steps Validate the parameters.  "}, {"title": "claimFee loop does not check for zero transfer amount (Incentivizer.sol) ", "html_url": "https://github.com/code-423n4/2021-12-perennial-findings/issues/43", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-12-perennial-findings", "body": "# Handle  ye0lde   # Vulnerability details  ## Impact Transfer amount can be checked for > 0 before calling `push' which makes a call to `safeTransfer`. This can save gas by avoiding the external call.  ## Proof of Concept  The transfer is here: https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/incentivizer/Incentivizer.sol#L237-L238   ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps Check that transfer amount > 0 before L#237-238 are executed.  Consider checking for `amount` > 0 in these functions: https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/utils/types/Token18.sol#L51 https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/utils/types/Token18.sol#L68 https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/utils/types/Token18.sol#L85  "}, {"title": " Removing redundant code can save gas (Collateral, Factory, Incentivizer, ChainlinkOracle)", "html_url": "https://github.com/code-423n4/2021-12-perennial-findings/issues/41", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-12-perennial-findings", "body": " Removing redundant code can save gas (Collateral, Factory, Incentivizer, ChainlinkOracle)"}, {"title": "Cache storage variables in the stack can save gas", "html_url": "https://github.com/code-423n4/2021-12-perennial-findings/issues/40", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-12-perennial-findings", "body": "Cache storage variables in the stack can save gas"}, {"title": "Remove unnecessary variables can make the code simpler and save some gas", "html_url": "https://github.com/code-423n4/2021-12-perennial-findings/issues/39", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-12-perennial-findings", "body": "Remove unnecessary variables can make the code simpler and save some gas"}, {"title": "Inline unnecessary function can make the code simpler and save some gas", "html_url": "https://github.com/code-423n4/2021-12-perennial-findings/issues/38", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-12-perennial-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXLPStaking.sol#L285-L290  ```solidity=285     function _deposit(StakingPool memory pool, uint256 amount) internal {         require(pool.stakingToken != address(0), \"LPStaking: Nonexistent pool\");         IERC20Upgradeable(pool.stakingToken).safeTransferFrom(msg.sender, address(this), amount);         // Timelock for 2 seconds to prevent flash loans.         _rewardDistributionTokenAddr(pool).timelockMint(msg.sender, amount, 2);     } ```  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXLPStaking.sol#L124-L130  ```solidity=124     function deposit(uint256 vaultId, uint256 amount) external {         onlyOwnerIfPaused(10);         // Check the pool in case its been updated.         updatePoolForVault(vaultId);         StakingPool memory pool = vaultStakingInfo[vaultId];         _deposit(pool, amount);     } ```   `_deposit()` is unnecessary as it's being used only once. Therefore it can be inlined in `deposit()` to make the code simpler and save gas.  ## Recommendation  Change to:  ```solidity=124     function deposit(uint256 vaultId, uint256 amount) external {         onlyOwnerIfPaused(10);         // Check the pool in case its been updated.         updatePoolForVault(vaultId);         StakingPool memory pool = vaultStakingInfo[vaultId];          require(pool.stakingToken != address(0), \"LPStaking: Nonexistent pool\");         IERC20Upgradeable(pool.stakingToken).safeTransferFrom(msg.sender, address(this), amount);         // Timelock for 2 seconds to prevent flash loans.         _rewardDistributionTokenAddr(pool).timelockMint(msg.sender, amount, 2);     } ```  Other examples include:  -   `NFTXFlashSwipe.sol#flashRedeem()`, `NFTXFlashSwipe.sol#flashMint()` can be inlined in `NFTXFlashSwipe.sol#onFlashLoan()` -   `UniswapV3SparkleEligibility.sol#isRare()` can be inlined in `UniswapV3SparkleEligibility.sol#_checkIfEligible()`   "}, {"title": "Best Practice: public functions not used by current contract should be external", "html_url": "https://github.com/code-423n4/2021-12-perennial-findings/issues/37", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-12-perennial-findings", "body": "# Handle  WatchPug   # Vulnerability details  Here are some examples that the code style does not follow the best practices:  https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/collateral/Collateral.sol#L171-L173  ```solidity=171 function shortfall(IProduct product) public view returns (UFixed18) {     return _products[product].shortfall; } ```  https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/product/Product.sol#L256-L258  ```solidity=256 function maintenance(address account) public view returns (UFixed18) {     return _positions[account].maintenance(provider); } ```  https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/product/Product.sol#L266-L268  ```solidity=266 function maintenanceNext(address account) public view returns (UFixed18) {     return _positions[account].maintenanceNext(provider); } ```  https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/factory/Factory.sol#L259-L261  ```solidity=259 function treasury() public view returns (address) {     return treasury(0); } ```  "}, {"title": "`Incentivizer.sol` Tokens with fee on transfer are not supported", "html_url": "https://github.com/code-423n4/2021-12-perennial-findings/issues/36", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "resolved"], "target": "2021-12-perennial-findings", "body": "`Incentivizer.sol` Tokens with fee on transfer are not supported"}, {"title": "`Factory.sol#updateController()` Lack of input validation", "html_url": "https://github.com/code-423n4/2021-12-perennial-findings/issues/35", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2021-12-perennial-findings", "body": "# Handle  WatchPug   # Vulnerability details  `newController.owner` should be validated to make sure the new owner's address is not `address(0)`.  Otherwise, if the owner mistakenly calls `updateController()` with improper inputs can result in all the `onlyOwner(controllerId)` methods being unaccessible.  https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/factory/Factory.sol#L103-L106  ```solidity=103 function updateController(uint256 controllerId, Controller memory newController) onlyOwner(controllerId) external {     _controllers[controllerId] = newController;     emit ControllerUpdated(controllerId, newController.owner, newController.treasury); } ```  "}, {"title": "Unnecessary checked arithmetic in for loops", "html_url": "https://github.com/code-423n4/2021-12-perennial-findings/issues/34", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-12-perennial-findings", "body": "Unnecessary checked arithmetic in for loops"}, {"title": "Cache storage read and call results in the stack can save gas", "html_url": "https://github.com/code-423n4/2021-12-perennial-findings/issues/33", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-12-perennial-findings", "body": "# Handle  WatchPug   # Vulnerability details  Caching the result of `_registry[product].length()` can save gas from unnecessary extra SLOAD, function call, and code execution, especially in for loops.  Instances include:  https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/incentivizer/Incentivizer.sol#L144-L144  ```solidity=144 for (uint256 i; i < _registry[product].length(); i++) { ```   https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/incentivizer/Incentivizer.sol#L174-L174  ```solidity=174 for (uint256 i; i < _registry[product].length(); i++) { ```   https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/incentivizer/Incentivizer.sol#L190-L190  ```solidity=190 for (uint256 i; i < _registry[product].length(); i++) { ```  "}, {"title": "Reuse operation results can save gas", "html_url": "https://github.com/code-423n4/2021-12-perennial-findings/issues/32", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-12-perennial-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/incentivizer/Incentivizer.sol#L232-L242  ```solidity=232{234,238} function claimFee(Token18[] calldata tokens) notPaused external {     for(uint256 i; i < tokens.length; i++) {         Token18 token = tokens[i];         UFixed18 amount = fees[token];          fees[token] = UFixed18Lib.ZERO;         tokens[i].push(factory().treasury(), amount);          emit FeeClaim(token, amount);     } } ```  `tokens[i]` at L238 is already cached in the local variable `token` at L234, resuing the result instead of doing the subscript operation again can save gas.  ### Recommendation  Change  ```solidity tokens[i].push(factory().treasury(), amount); ```  to:  ```solidity token.push(factory().treasury(), amount); ```  "}, {"title": "Cache array length in for loops can save gas", "html_url": "https://github.com/code-423n4/2021-12-perennial-findings/issues/31", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-12-perennial-findings", "body": "Cache array length in for loops can save gas"}, {"title": "Avoid unnecessary `SafeCast.toInt256()` can save gas", "html_url": "https://github.com/code-423n4/2021-12-perennial-findings/issues/30", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-12-perennial-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/oracle/ChainlinkOracle.sol#L29-L29  ```solidity=29 uint256 private _decimalOffset; ```  https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/oracle/ChainlinkOracle.sol#L50-L60  ```solidity=50{52} function sync() public {     (, int256 feedPrice, , uint256 timestamp, ) = feed.latestRoundData();     Fixed18 price = Fixed18Lib.ratio(feedPrice, SafeCast.toInt256(_decimalOffset));      if (priceAtVersion.length == 0 || timestamp > timestampAtVersion[currentVersion()] + minDelay) {         priceAtVersion.push(price);         timestampAtVersion.push(timestamp);          emit Version(currentVersion(), timestamp, price);     } } ```  `_decimalOffset` is only used at L52\u3002  Therefore `_decimalOffset` can be defined as `int256` and avoid unnecessary `SafeCast.toInt256()`.  "}, {"title": "Use immutable variables can save gas", "html_url": "https://github.com/code-423n4/2021-12-perennial-findings/issues/29", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-12-perennial-findings", "body": "Use immutable variables can save gas"}, {"title": "Adding a new method `provider.currentPrice()` can save gas", "html_url": "https://github.com/code-423n4/2021-12-perennial-findings/issues/27", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-12-perennial-findings", "body": "# Handle  WatchPug   # Vulnerability details  Every call to an external contract costs a decent amount of gas.  There are many times across the codebase that will perform two external calls to the provider to query the current `oraclePrice`:  https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/product/types/position/AccountPosition.sol#L72-L72  ```solidity=72 Fixed18 oraclePrice = provider.priceAtVersion(provider.currentVersion()); ```  Consider adding a new method to the provider and return the current `oraclePrice` directly can combine two external calls into one and save some gas.  "}, {"title": "Avoid unnecessary external calls can save gas", "html_url": "https://github.com/code-423n4/2021-12-perennial-findings/issues/26", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-12-perennial-findings", "body": "Avoid unnecessary external calls can save gas"}, {"title": "Chainlink's `latestRoundData` might return stale or incorrect results", "html_url": "https://github.com/code-423n4/2021-12-perennial-findings/issues/24", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2021-12-perennial-findings", "body": "Chainlink's `latestRoundData` might return stale or incorrect results"}, {"title": "`Token18.sol#balanceOf()` When `isEther()`, `fromTokenAmount()` is unnecessary", "html_url": "https://github.com/code-423n4/2021-12-perennial-findings/issues/23", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-12-perennial-findings", "body": "# Handle  WatchPug   # Vulnerability details  When `isEther()`, `decimals` must be `18`:  https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/utils/types/Token18.sol#L118-L120  ```solidity=118 function decimals(Token18 self) internal view returns (uint8) {     return isEther(self) ? 18 : IERC20Metadata(Token18.unwrap(self)).decimals(); } ```  Therefore, in `Token18.sol#balanceOf()`, `fromTokenAmount()` is unnecessary when `isEther()`.  https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/utils/types/Token18.sol#L137-L142  ```solidity=137 function balanceOf(Token18 self, address account) internal view returns (UFixed18) {     uint256 tokenAmount = isEther(self) ?         account.balance :         IERC20(Token18.unwrap(self)).balanceOf(account);     return fromTokenAmount(self, tokenAmount); } ```  Can be changed to:  ```solidity=137 function balanceOf(Token18 self, address account) internal view returns (UFixed18) {     return isEther(self) ?         UFixed18.wrap(account.balance) :         fromTokenAmount(self, IERC20(Token18.unwrap(self)).balanceOf(account)); } ```  "}, {"title": "`Token18.sol#push()` When `isEther()`, `toTokenAmount()` is unnecessary", "html_url": "https://github.com/code-423n4/2021-12-perennial-findings/issues/22", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-12-perennial-findings", "body": "# Handle  WatchPug   # Vulnerability details  When `isEther()`, `decimals` must be `18`:  https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/utils/types/Token18.sol#L118-L120  ```solidity=118     function decimals(Token18 self) internal view returns (uint8) {         return isEther(self) ? 18 : IERC20Metadata(Token18.unwrap(self)).decimals();     } ```  Therefore, in `Token18.sol#push()`, `toTokenAmount()` is unnecessary when `isEther()`.  https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/utils/types/Token18.sol#L51-L59  ```solidity=51 function push(     Token18 self,     address recipient,     UFixed18 amount ) internal {     isEther(self)         ? Address.sendValue(payable(recipient), toTokenAmount(self, amount))         : IERC20(Token18.unwrap(self)).safeTransfer(recipient, toTokenAmount(self, amount)); } ```  Can be changed to:  ```solidity=51 function push(     Token18 self,     address recipient,     UFixed18 amount ) internal {     isEther(self)         ? Address.sendValue(payable(recipient), UFixed18.unwrap(amount))         : IERC20(Token18.unwrap(self)).safeTransfer(recipient, toTokenAmount(self, amount)); } ```  "}, {"title": "`10 ** 18` can be changed to `1e18` and save some gas", "html_url": "https://github.com/code-423n4/2021-12-perennial-findings/issues/21", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-12-perennial-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/utils/types/Token18.sol#L151-L154  ```solidity=151 function toTokenAmount(Token18 self, UFixed18 amount) private view returns (uint256) {     UFixed18 conversion = UFixed18Lib.ratio(10 ** uint256(decimals(self)), 10 ** 18);     return UFixed18.unwrap(amount.mul(conversion)); } ```  Can be changed to:  ```solidity=151 function toTokenAmount(Token18 self, UFixed18 amount) private view returns (uint256) {     UFixed18 conversion = UFixed18Lib.ratio(10 ** uint256(decimals(self)), 1e18);     return UFixed18.unwrap(amount.mul(conversion)); } ```   https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/utils/types/Token18.sol#L163-L166  ```solidity=163 function fromTokenAmount(Token18 self, uint256 amount) private view returns (UFixed18) {     UFixed18 conversion = UFixed18Lib.ratio(10 ** 18, 10 ** uint256(decimals(self)));     return UFixed18.wrap(amount).mul(conversion); } ```  Can be changed to:  ```solidity=163 function fromTokenAmount(Token18 self, uint256 amount) private view returns (UFixed18) {     UFixed18 conversion = UFixed18Lib.ratio(1e18, 10 ** uint256(decimals(self)));     return UFixed18.wrap(amount).mul(conversion); } ```   "}, {"title": "Avoid unnecessary arithmetic operations can save gas", "html_url": "https://github.com/code-423n4/2021-12-perennial-findings/issues/20", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-12-perennial-findings", "body": "Avoid unnecessary arithmetic operations can save gas"}, {"title": "Wrong shortfall calculation", "html_url": "https://github.com/code-423n4/2021-12-perennial-findings/issues/18", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2021-12-perennial-findings", "body": "# Handle  kenzo   # Vulnerability details  Every time an account is settled, if shortfall is created, due to a wrong calculation shortfall will double in size and add the new shortfall.  ## Impact Loss of funds: users won't be able to withdraw the correct amount of funds. Somebody would have to donate funds to resolve the wrong shortfall.  ## Proof of Concept We can see in the `settleAccount` of `OptimisticLedger` that self.shortfall ends up being self.shortfall+self.shortfall+newShortfall: [(Code ref)](https://github.com/code-423n4/2021-12-perennial/blob/main/protocol/contracts/collateral/types/OptimisticLedger.sol#L63:#L74) ```     function settleAccount(OptimisticLedger storage self, address account, Fixed18 amount)     internal returns (UFixed18 shortfall) {         Fixed18 newBalance = Fixed18Lib.from(self.balances[account]).add(amount);          if (newBalance.sign() == -1) {             shortfall = self.shortfall.add(newBalance.abs());             newBalance = Fixed18Lib.ZERO;         }          self.balances[account] = newBalance.abs();         self.shortfall = self.shortfall.add(shortfall);     } ```  Additionally, you can add the following line to the \"shortfall reverts if depleted\" test in Collateral.test.js, line 190: ``` await collateral.connect(productSigner).settleAccount(userB.address, -50) ``` Previously the test product had 50 shortfall. Now we added 50 more, but the test will print that the actual shortfall is 150, and not 100 as it should be.  ## Recommended Mitigation Steps Move the setting of `self.shortfall` to inside the if function and change the line to: ``` self.shortfall = shortfall ```  "}, {"title": "Multiple initialization of Collateral contract", "html_url": "https://github.com/code-423n4/2021-12-perennial-findings/issues/13", "labels": ["bug", "2 (Med Risk)", "resolved"], "target": "2021-12-perennial-findings", "body": "Multiple initialization of Collateral contract"}, {"title": "Unsecure Ownership Transfer", "html_url": "https://github.com/code-423n4/2021-12-perennial-findings/issues/12", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2021-12-perennial-findings", "body": "# Handle  0x1f8b   # Vulnerability details  ## Impact Lost the owner by human error.  ## Proof of Concept The modification process of an owner is a delicate process, since the governance of our contract and therefore of the project may be at risk, for this reason it is recommended to adjust the owner\u2019s modification logic, to a logic that allows to verify that the new owner is in fact valid and does exist.  It's mandatory to create a logic of the owner\u2019s modification where a new owner is proposed first, the owner accepts the proposal and, in this way, we make sure that there are no errors when writing the address of the new owner.   Source reference: - UOwnable.transferOwnership  ## Tools Used Manual review  ## Recommended Mitigation Steps Use an ACK method for approve the new owner.  "}, {"title": "Not verified function inputs of public / external functions", "html_url": "https://github.com/code-423n4/2021-12-perennial-findings/issues/11", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2021-12-perennial-findings", "body": "# Handle  robee   # Vulnerability details  Not verified address arguments of external/public functions is a low risk issue.  It's less severe for onlyOwner methods but for any other method it's crucial since the default address is 0.          Argument account of Collateral.depositTo is not verified to be != 0         Argument account of Collateral.withdrawTo is not verified to be != 0         Argument account of Collateral.liquidate is not verified to be != 0         Argument account of Collateral.settleAccount is not verified to be != 0         Argument account of Collateral.collateral is not verified to be != 0         Argument account of Collateral.liquidatable is not verified to be != 0         Argument account of Collateral.liquidatableNext is not verified to be != 0         Argument treasury_ of Factory.initialize is not verified to be != 0         Argument controllerTreasury of Factory.createController is not verified to be != 0         Argument newPauser of Factory.updatePauser is not verified to be != 0         Argument account of Incentivizer.syncAccount is not verified to be != 0         Argument account of Incentivizer.unclaimed is not verified to be != 0         Argument account of Incentivizer.latestVersion is not verified to be != 0         Argument account of Incentivizer.settled is not verified to be != 0         Argument account of Product.settleAccount is not verified to be != 0         Argument account of Product.closeAll is not verified to be != 0         Argument account of Product.maintenance is not verified to be != 0         Argument account of Product.maintenanceNext is not verified to be != 0         Argument account of Product.isClosed is not verified to be != 0         Argument account of Product.isLiquidating is not verified to be != 0         Argument account of Product.position is not verified to be != 0         Argument account of Product.pre is not verified to be != 0         Argument account of Product.latestVersion is not verified to be != 0         Argument recipient of MockToken18.push is not verified to be != 0         Argument recipient of MockToken18.push is not verified to be != 0         Argument benefactor of MockToken18.pull is not verified to be != 0         Argument benefactor of MockToken18.pullTo is not verified to be != 0         Argument recipient of MockToken18.pullTo is not verified to be != 0         Argument account of MockToken18.balanceOf is not verified to be != 0         Argument newOwner of UOwnable.transferOwnership is not verified to be != 0   "}, {"title": "Solidity compiler versions mismatch", "html_url": "https://github.com/code-423n4/2021-12-perennial-findings/issues/10", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor disputed"], "target": "2021-12-perennial-findings", "body": "Solidity compiler versions mismatch"}, {"title": "Unused imports", "html_url": "https://github.com/code-423n4/2021-12-perennial-findings/issues/1", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2021-12-perennial-findings", "body": "Unused imports"}, {"title": "balance(dust) rewardsTokens may be unclaimable after endRewardLock", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/271", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-11-streaming-findings", "body": "balance(dust) rewardsTokens may be unclaimable after endRewardLock"}, {"title": "Remove unnecessary function can make the code simpler and save some gas", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/265", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-streaming-findings", "body": "Remove unnecessary function can make the code simpler and save some gas"}, {"title": "`++currStreamId` is more gas efficient than `currStreamId += 1`", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/263", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-streaming-findings", "body": "`++currStreamId` is more gas efficient than `currStreamId += 1`"}, {"title": "Avoid unnecessary external calls can save gas", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/262", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-streaming-findings", "body": "Avoid unnecessary external calls can save gas"}, {"title": "Code Style: public functions not used by current contract should be external", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/260", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-streaming-findings", "body": "Code Style: public functions not used by current contract should be external"}, {"title": "`Stream#claimReward()` storage writes and reads of `ts.rewards` can be combined into one", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/259", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-streaming-findings", "body": "`Stream#claimReward()` storage writes and reads of `ts.rewards` can be combined into one"}, {"title": "Improper implementation of `arbitraryCall()` allows protocol gov to steal funds from users' wallets", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/258", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-11-streaming-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L733-L735  ```solidity function arbitraryCall(address who, bytes memory data) public lock externallyGoverned {     // cannot have an active incentive for the callee     require(incentives[who] == 0, \"inc\");     ... ```  When an incentiveToken is claimed after `endStream`, `incentives[who]` will be `0` for that `incentiveToken`.  If the protocol gov is malicious or compromised, they can call `arbitraryCall()` with the address of the incentiveToken as `who` and `transferFrom()` as calldata and steal all the incentiveToken in the victim's wallet balance up to the allowance amount.  ### PoC  1. Alice approved `USDC` to the streaming contract; 2. Alice called `createIncentive()` and added `1,000 USDC` of incentive; 3. After the stream is done, the stream creator called `claimIncentive()` and claimed `1,000 USDC`;  The compromised protocol gov can call `arbitraryCall()` and steal all the USDC in Alice's wallet balance.  ### Recommendation  Consider adding a mapping: `isIncentiveToken`, setting `isIncentiveToken[incentiveToken] = true` in `createIncentive()`, and `require(!isIncentiveToken[who], ...)` in `arbitraryCall()`.  "}, {"title": "Gas Optimization On The 2^256-1", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/255", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-streaming-findings", "body": "Gas Optimization On The 2^256-1"}, {"title": "Incompatibility With Rebasing/Deflationary/Inflationary tokens", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/252", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-11-streaming-findings", "body": "Incompatibility With Rebasing/Deflationary/Inflationary tokens"}, {"title": "Redundant code", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/250", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-streaming-findings", "body": "Redundant code"}, {"title": "Inconsistent check of token balance", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/249", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-streaming-findings", "body": "# Handle  WatchPug   # Vulnerability details  `require(newBal <= type(uint112).max ...)` vs `require(newBal < type(uint112).max...)`.  https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L386-L386 ```solidity=386 require(newBal < type(uint112).max && newBal > prevBal, \"erc\"); ```  https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L427-L427 ```solidity=427 require(newBal <= type(uint112).max && newBal > prevBal, \"erc\"); ```  https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L506-L506 ```solidity=506 require(newBal <= type(uint112).max && newBal > prevBal, \"erc\"); ```  "}, {"title": "`10**6` can be changed to `1e6` and save some gas", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/248", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-streaming-findings", "body": "`10**6` can be changed to `1e6` and save some gas"}, {"title": "Incorrect Validation of feePercent", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/246", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "sponsor acknowledged"], "target": "2021-11-streaming-findings", "body": "Incorrect Validation of feePercent"}, {"title": "Avoid unnecessary storage reads can save gas", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/245", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-streaming-findings", "body": "Avoid unnecessary storage reads can save gas"}, {"title": "Insufficient input validation", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/243", "labels": ["bug", "0 (Non-critical)"], "target": "2021-11-streaming-findings", "body": "Insufficient input validation"}, {"title": "Wrong calculation of excess depositToken allows stream creator to retrieve `depositTokenFlashloanFeeAmount`, which may cause fund loss to users", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/241", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-11-streaming-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L654-L654  ```solidity=654 uint256 excess = ERC20(token).balanceOf(address(this)) - (depositTokenAmount - redeemedDepositTokens); ```  In the current implementation, `depositTokenFlashloanFeeAmount` is not excluded when calculating `excess` depositToken. Therefore, the stream creator can call `recoverTokens(depositToken, recipient)` and retrieve `depositTokenFlashloanFeeAmount` if there are any.  As a result:  - When the protocol `governance` calls `claimFees()` and claim accumulated `depositTokenFlashloanFeeAmount`, it may fail due to insufficient balance of depositToken. - Or, part of users' funds (depositToken) will be transferred to the protocol `governance` as fees, causing some users unable to withdraw or can only withdraw part of their deposits.  ### PoC  Given:  - `feeEnabled`: true - `feePercent`: 10 (0.1%)  1. Alice deposited `1,000,000` depositToken; 2. Bob called `flashloan()` and borrowed `1,000,000` depositToken, then repaid `1,001,000`; 3. Charlie deposited `1,000` depositToken; 4. After `endDepositLock`, Alice called `claimDepositTokens()` and withdrawn `1,000,000` depositToken; 5. `streamCreator` called `recoverTokens(depositToken, recipient)` and retrieved `1,000` depositToken `(2,000 - (1,001,000 - 1,000,000))`; 6. `governance` called `claimFees()` and retrieved another `1,000` depositToken; 7. Charlie tries to `claimDepositTokens()` but since the current balanceOf depositToken is `0`, the transcation always fails, and Charlie loses all the depositToken.  ### Recommendation  Change to:  ```solidity=654 uint256 excess = ERC20(token).balanceOf(address(this)) - (depositTokenAmount - redeemedDepositTokens) - depositTokenFlashloanFeeAmount; ```  "}, {"title": "`LockeERC20.sol#toString()` Implementation can be simpler and save some gas", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/239", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-streaming-findings", "body": "`LockeERC20.sol#toString()` Implementation can be simpler and save some gas"}, {"title": "Adding unchecked directive can save gas", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/238", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-streaming-findings", "body": "Adding unchecked directive can save gas"}, {"title": "Constructors should not have visibility", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/236", "labels": ["bug", "0 (Non-critical)"], "target": "2021-11-streaming-findings", "body": "Constructors should not have visibility"}, {"title": "Slot packing increases runtime gas consumption due to masking", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/235", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-streaming-findings", "body": "Slot packing increases runtime gas consumption due to masking"}, {"title": "Implementations should inherit their interface", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/234", "labels": ["bug", "0 (Non-critical)"], "target": "2021-11-streaming-findings", "body": "# Handle  WatchPug   # Vulnerability details  It's a best practice for the contract implementations to inherit their interface definition.  Doing so would improve the contract's clarity, and force the implementation to comply with the defined interface.  Instances include:  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/TransferService.sol#L14-L14 ```solidity=14 contract TransferService is Initializable, Permissions { ```  `TransferService` should inherit `ITransferService`.  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/DexHandlers/UniswapHandler.sol#L20-L20  ```solidity=20 contract UniswapHandler is Initializable, Permissions { ```  `UniswapHandler` should inherit `IDexHandler`.  "}, {"title": "Remove unnecessary variables can make the code simpler and save some gas", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/233", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-streaming-findings", "body": "Remove unnecessary variables can make the code simpler and save some gas"}, {"title": "Cache and read storage variables from the stack can save gas", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/232", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-streaming-findings", "body": "Cache and read storage variables from the stack can save gas"}, {"title": "Use immutable variables can save gas", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/231", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-streaming-findings", "body": "Use immutable variables can save gas"}, {"title": "DOS while dealing with erc20 when value(i.e amount*decimals)  is high but less than type(uint112).max", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/228", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-11-streaming-findings", "body": "# Handle\r \r hack3r-0m\r \r \r # Vulnerability details\r \r ## Impact\r \r https://github.com/code-423n4/2021-11-streaming/blob/main/Streaming/src/Locke.sol#L229\r \r reverts due to overflow for higher values (but strictly less than type(uint112).max) and hence when user calls `exit` or `withdraw` function it will revert and that user will not able to withdraw funds permanentaly.\r \r ## Proof of Concept\r \r Attaching diff to modify tests to reproduce behaviour:\r \r ```\r diff --git a/Streaming/src/test/Locke.t.sol b/Streaming/src/test/Locke.t.sol\r index 2be8db0..aba19ce 100644\r --- a/Streaming/src/test/Locke.t.sol\r +++ b/Streaming/src/test/Locke.t.sol\r @@ -166,14 +166,14 @@ contract StreamTest is LockeTest {\r          );\r  \r          testTokenA.approve(address(stream), type(uint256).max);\r -        stream.fundStream((10**14)*10**18);\r +        stream.fundStream(1000);\r  \r -        alice.doStake(stream, address(testTokenB), (10**13)*10**18);\r +        alice.doStake(stream, address(testTokenB), 100);\r  \r  \r          hevm.warp(startTime + minStreamDuration / 2); // move to half done\r          \r -        bob.doStake(stream, address(testTokenB), (10**13)*10**18);\r +        bob.doStake(stream, address(testTokenB), 100);\r  \r          hevm.warp(startTime + minStreamDuration / 2 + minStreamDuration / 10);\r  \r @@ -182,10 +182,10 @@ contract StreamTest is LockeTest {\r          hevm.warp(startTime + minStreamDuration + 1); // warp to end of stream\r  \r  \r -        // alice.doClaimReward(stream);\r -        // assertEq(testTokenA.balanceOf(address(alice)), 533*(10**15));\r -        // bob.doClaimReward(stream);\r -        // assertEq(testTokenA.balanceOf(address(bob)), 466*(10**15));\r +        alice.doClaimReward(stream);\r +        assertEq(testTokenA.balanceOf(address(alice)), 533);\r +        bob.doClaimReward(stream);\r +        assertEq(testTokenA.balanceOf(address(bob)), 466);\r      }\r  \r      function test_stake() public {\r diff --git a/Streaming/src/test/utils/LockeTest.sol b/Streaming/src/test/utils/LockeTest.sol\r index eb38060..a479875 100644\r --- a/Streaming/src/test/utils/LockeTest.sol\r +++ b/Streaming/src/test/utils/LockeTest.sol\r @@ -90,11 +90,11 @@ abstract contract LockeTest is TestHelpers {\r          testTokenA = ERC20(address(new TestToken(\"Test Token A\", \"TTA\", 18)));\r          testTokenB = ERC20(address(new TestToken(\"Test Token B\", \"TTB\", 18)));\r          testTokenC = ERC20(address(new TestToken(\"Test Token C\", \"TTC\", 18)));\r -        write_balanceOf_ts(address(testTokenA), address(this), (10**14)*10**18);\r -        write_balanceOf_ts(address(testTokenB), address(this), (10**14)*10**18);\r -        write_balanceOf_ts(address(testTokenC), address(this), (10**14)*10**18);\r -        assertEq(testTokenA.balanceOf(address(this)), (10**14)*10**18);\r -        assertEq(testTokenB.balanceOf(address(this)), (10**14)*10**18);\r +        write_balanceOf_ts(address(testTokenA), address(this), 100*10**18);\r +        write_balanceOf_ts(address(testTokenB), address(this), 100*10**18);\r +        write_balanceOf_ts(address(testTokenC), address(this), 100*10**18);\r +        assertEq(testTokenA.balanceOf(address(this)), 100*10**18);\r +        assertEq(testTokenB.balanceOf(address(this)), 100*10**18);\r  \r          defaultStreamFactory = new StreamFactory(address(this), address(this));\r  \r ```\r \r ## Tools Used\r \r Manual Review\r \r ## Recommended Mitigation Steps\r \r Consider doing arithmetic operations in two steps or upcasting to u256 and then downcasting. Alternatively, find a threshold where it breaks and add require condition to not allow total stake per user greater than threshhold.\r \r "}, {"title": "Emergency gov is never used", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/226", "labels": ["bug", "0 (Non-critical)"], "target": "2021-11-streaming-findings", "body": "Emergency gov is never used"}, {"title": "Loss of precision causing incorrect flashloan & creator fee calculation", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/221", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "sponsor acknowledged"], "target": "2021-11-streaming-findings", "body": "Loss of precision causing incorrect flashloan & creator fee calculation"}, {"title": "Gas: Check `_feePercent` instead", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/217", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-streaming-findings", "body": "Gas: Check `_feePercent` instead"}, {"title": "Gas: `unstreamed` not needed", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/216", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-streaming-findings", "body": "Gas: `unstreamed` not needed"}, {"title": "Tokens can be stolen when `depositToken == rewardToken`", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/215", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-11-streaming-findings", "body": "# Handle  cmichel   # Vulnerability details  The `Streaming` contract allows the `deposit` and `reward` tokens to be the same token.  > I believe this is intended, think Sushi reward on Sushi as is the case with `xSushi`.  The reward and deposit balances are also correctly tracked independently in `depositTokenAmount` and `rewardTokenAmount`. However, when recovering tokens this leads to issues as the token is recovered twice, once for deposits and another time for rewards:  ```solidity function recoverTokens(address token, address recipient) public lock {     // NOTE: it is the stream creators responsibility to save     // tokens on behalf of their users.     require(msg.sender == streamCreator, \"!creator\");     if (token == depositToken) {         require(block.timestamp > endDepositLock, \"time\");         // get the balance of this contract         // check what isnt claimable by either party         // @audit-info depositTokenAmount updated on stake/withdraw/exit, redeemedDepositTokens increased on claimDepositTokens         uint256 excess = ERC20(token).balanceOf(address(this)) - (depositTokenAmount - redeemedDepositTokens);         // allow saving of the token         ERC20(token).safeTransfer(recipient, excess);          emit RecoveredTokens(token, recipient, excess);         return;     }          if (token == rewardToken) {         require(block.timestamp > endRewardLock, \"time\");         // check current balance vs internal balance         //         // NOTE: if a token rebases, i.e. changes balance out from under us,         // most of this contract breaks and rugs depositors. this isn't exclusive         // to this function but this function would in theory allow someone to rug         // and recover the excess (if it is worth anything)          // check what isnt claimable by depositors and governance         // @audit-info rewardTokenAmount increased on fundStream         uint256 excess = ERC20(token).balanceOf(address(this)) - (rewardTokenAmount + rewardTokenFeeAmount);         ERC20(token).safeTransfer(recipient, excess);          emit RecoveredTokens(token, recipient, excess);         return;     }     // ... ```  #### POC Given `recoverTokens == depositToken`, `Stream` creator calls `recoverTokens(token = depositToken, creator)`.  - The `token` balance is the sum of deposited tokens (minus reclaimed) plus the reward token amount. `ERC20(token).balanceOf(address(this)) >= (depositTokenAmount - redeemedDepositTokens) + (rewardTokenAmount + rewardTokenFeeAmount)` - `if (token == depositToken)` executes, the `excess` from the deposit amount will be the reward amount (`excess >= rewardTokenAmount + rewardTokenFeeAmount`). This will be transferred. - `if (token == rewardToken)` executes, the new token balance is just the deposit token amount now (because the reward token amount has been transferred out in the step before). Therefore, `ERC20(token).balanceOf(address(this)) >= depositTokenAmount - redeemedDepositTokens`. If this is non-negative, the transaction does not revert and the creator makes a profit.  Example: - outstanding redeemable deposit token amount: `depositTokenAmount - redeemedDepositTokens = 1000` - funded `rewardTokenAmount` (plus `rewardTokenFeeAmount` fees): `rewardTokenAmount + rewardTokenFeeAmount = 500`  Creator receives `1500 - 1000 = 500` excess deposit and `1000 - 500 = 500` excess reward.  ## Impact When using the same deposit and reward token, the stream creator can steal tokens from the users who will be unable to withdraw their profit or claim their rewards.  ## Recommended Mitigation Steps One needs to be careful with using `.balanceOf` in this special case as it includes both deposit and reward balances.  Add a special case for `recoverTokens` when `token == depositToken == rewardToken` and then the excess should be `ERC20(token).balanceOf(address(this)) - (depositTokenAmount - redeemedDepositTokens) - (rewardTokenAmount + rewardTokenFeeAmount);`  "}, {"title": "Reward token not correctly recovered", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/214", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-11-streaming-findings", "body": "# Handle  cmichel   # Vulnerability details  The `Streaming` contract allows recovering the reward token by calling `recoverTokens(rewardToken, recipient)`.  However, the excess amount is computed incorrectly as `ERC20(token).balanceOf(address(this)) - (rewardTokenAmount + rewardTokenFeeAmount)`:  ```solidity function recoverTokens(address token, address recipient) public lock {     if (token == rewardToken) {         require(block.timestamp > endRewardLock, \"time\");          // check what isnt claimable by depositors and governance         // @audit-issue rewardTokenAmount increased on fundStream, but never decreased! this excess underflows         uint256 excess = ERC20(token).balanceOf(address(this)) - (rewardTokenAmount + rewardTokenFeeAmount);         ERC20(token).safeTransfer(recipient, excess);          emit RecoveredTokens(token, recipient, excess);         return;     }     // ... ```  Note that `rewardTokenAmount` only ever _increases_ (when calling `fundStream`) but it never decreases when claiming the rewards through `claimReward`. However, `claimReward` transfers out the reward token.  Therefore, the `rewardTokenAmount` never tracks the contract's reward balance and the excess cannot be computed that way.  #### POC Assume no reward fees for simplicity and only a single user staking.  - Someone funds `1000` reward tokens through `fundStream(1000)`. Then `rewardTokenAmount = 1000`  - The stream and reward lock period is over, i.e. `block.timestamp > endRewardLock` - The user claims their full reward and receives `1000` reward tokens by calling `claimReward()`. The reward contract balance is now `0` but `rewardTokenAmount = 1000` - Some fool sends 1000 reward tokens to the contract by accident. These cannot be recovered as the `excess = balance - rewardTokenAmount = 0`  ## Impact Reward token recovery does not work.  ## Recommended Mitigation Steps The claimed rewards need to be tracked as well, just like the claimed deposits are tracked. I think you can even decrease `rewardTokenAmount` in `claimReward` because at this point `rewardTokenAmount` is not used to update the `cumulativeRewardPerToken` anymore.  "}, {"title": "Inaccurate comment in `recoverTokens`", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/213", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-streaming-findings", "body": "# Handle  cmichel   # Vulnerability details  The `recoverTokens` function's comment states that the excess deposit tokens are `balance - depositTokenAmount`:  >     *      1. if its deposit token: >     *          - DepositLock is fully done >     *          - There are excess deposit tokens (balance - depositTokenAmount)  But it is `balance - (depositTokenAmount - redeemedDepositTokens)` where `(depositTokenAmount - redeemedDepositTokens)` is the outstanding redeemable amount.  ## Impact The code is correct.  ## Recommended Mitigation Steps Fix the comment.  "}, {"title": "Token owner cannot claim rewardToken if they are not the original depositor", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/204", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "sponsor confirmed"], "target": "2021-11-streaming-findings", "body": "# Handle  gzeon   # Vulnerability details  ## Impact The comment in https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L553 stated that:  > Allows a receipt token holder (or original depositor in case of a sale) to claim their rewardTokens but the reward is only tracked to the original depositor in both case, see https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L558 ```         TokenStream storage ts = tokensNotYetStreamed[msg.sender]; ``` Transferring the LockeERC20 token does not transfer the TokenStream state.   "}, {"title": "Incentives paid to creator instead of depositor", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/201", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor confirmed"], "target": "2021-11-streaming-findings", "body": "# Handle  gzeon   # Vulnerability details  ## Impact The documentation is unclear, but it make little sense that incentives are only paid to the stream creator instead of depositors. This make the incentives more like donation to the creator but not actually incentivizing the stream.  https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L518  "}, {"title": "Possible incentive theft through the arbitraryCall() function", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/199", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-11-streaming-findings", "body": "# Handle  toastedsteaksandwich   # Vulnerability details  ## Impact The Locke.arbitraryCall() function allows the inherited governance contract to perform arbitrary contract calls within certain constraints. Contract calls to tokens provided as incentives through the createIncentive() function are not allowed if there is some still some balance according to the incentives mapping (See line 735 referenced below).   However, the token can still be called prior any user creating an incentive, so it's possible for the arbitraryCall() function to be used to set an allowance on an incentive token before the contract has actually received any of the token through createIncentive().   In summary:  1) If some possible incentive tokens are known prior to being provided, the arbitraryCall() function can be used to pre-approve a token allowance for a malicious recipient.  2) Once a user calls createIncentive() and provides one of the pre-approved tokens, the malicious recipient can call transferFrom on the provided incentive token and withdraw the tokens.  ## Proof of Concept https://github.com/code-423n4/2021-11-streaming/blob/main/Streaming/src/Locke.sol#L735  ## Recommended Mitigation Steps  ### Recommendation 1 Limit the types of incentive tokens so it can be checked that it's not the target contract for the arbitraryCall().  ### Recommendation 2 Validate that the allowance of the target contract (if available) has not changed.  "}, {"title": "This protocol doesn't support all fee on transfer tokens", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/192", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2021-11-streaming-findings", "body": "This protocol doesn't support all fee on transfer tokens"}, {"title": "In claimReward, reward can be cached more efficiently.", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/190", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-streaming-findings", "body": "In claimReward, reward can be cached more efficiently."}, {"title": "Not needed lastApplicableTime call in claimReward", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/189", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-streaming-findings", "body": "Not needed lastApplicableTime call in claimReward"}, {"title": "Directly calculate fee in flash loan", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/188", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-streaming-findings", "body": "Directly calculate fee in flash loan"}, {"title": "When exit is called, updateStream is called twice", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/187", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-streaming-findings", "body": "When exit is called, updateStream is called twice"}, {"title": "fundStream can be implemented more efficiently", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/186", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-streaming-findings", "body": "fundStream can be implemented more efficiently"}, {"title": "No need to check fee inside factories constructor", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/185", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-streaming-findings", "body": "No need to check fee inside factories constructor"}, {"title": "Gas Optimization: Use minimal proxy", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/183", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-streaming-findings", "body": "Gas Optimization: Use minimal proxy"}, {"title": "Gas Optimization: Move common logic out of if block", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/181", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-streaming-findings", "body": "Gas Optimization: Move common logic out of if block"}, {"title": "Eliminate amt in fundStream", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/179", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-streaming-findings", "body": "Eliminate amt in fundStream"}, {"title": "`arbitraryCall` does not need to check returned byte", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/168", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-streaming-findings", "body": "`arbitraryCall` does not need to check returned byte"}, {"title": "Creating rewardTokens without streaming depositTokens", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/166", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-11-streaming-findings", "body": "# Handle  bitbopper   # Vulnerability details  ## Impact  `stake` and `withdraws` can generate rewardTokens without streaming depositTokens.  It does not matter whether the stream is a sale or not.  The following lines can increase the reward balance on a `withdraw` some time after `stake`: https://github.com/code-423n4/2021-11-streaming/blob/main/Streaming/src/Locke.sol#L219:L222 ``` // accumulate reward per token info cumulativeRewardPerToken = rewardPerToken();  // update user rewards ts.rewards = earned(ts, cumulativeRewardPerToken); ```   While the following line can be gamed in order to not stream any tokens (same withdraw tx).  Specifically an attacker can arrange to create a fraction less than zero thereby substracting zero. https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L229 ``` ts.tokens -= uint112(acctTimeDelta * ts.tokens / (endStream - ts.lastUpdate)); // WARDEN TRANSLATION: (elapsedSecondsSinceStake * stakeAmount) / (endStreamTimestamp - stakeTimestamp) ```  A succesful attack increases the share of rewardTokens of the attacker. The attack can be repeated every block increasing the share further. The attack could be done from multiple EOA increasing the share further. In short: Attackers can create loss of funds for (honest) stakers.  The economic feasability of the attack depends on: - staked amount (times number of attacks) vs total staked amount - relative value of rewardToken to gasprice    ## Proof of Concept  ### code   The following was added to `Locke.t.sol` for the `StreamTest` Contract to simulate the attack from one EOA.  ```     function test_quickDepositAndWithdraw() public {         //// SETUP         // accounting (to proof attack): save the rewardBalance of alice.         uint StartBalanceA = testTokenA.balanceOf(address(alice));         uint112 stakeAmount = 10_000;          // start stream and fill it         (             uint32 maxDepositLockDuration,             uint32 maxRewardLockDuration,             uint32 maxStreamDuration,             uint32 minStreamDuration         ) = defaultStreamFactory.streamParams();          uint64 nextStream = defaultStreamFactory.currStreamId();         Stream stream = defaultStreamFactory.createStream(             address(testTokenA),             address(testTokenB),             uint32(block.timestamp + 10),              maxStreamDuration,             maxDepositLockDuration,             0,             false             // false,             // bytes32(0)         );                  testTokenA.approve(address(stream), type(uint256).max);         stream.fundStream(1_000_000_000);          // wait till the stream starts         hevm.warp(block.timestamp + 16);         hevm.roll(block.number + 1);          // just interact with contract to fill \"lastUpdate\" and \"ts.lastUpdate\"   // without changing balances inside of Streaming contract         alice.doStake(stream, address(testTokenB), stakeAmount);         alice.doWithdraw(stream, stakeAmount);           ///// ATTACK COMES HERE         // stake         alice.doStake(stream, address(testTokenB), stakeAmount);          // wait a block         hevm.roll(block.number + 1);         hevm.warp(block.timestamp + 16);          // withdraw soon thereafter         alice.doWithdraw(stream, stakeAmount);          // finish the stream         hevm.roll(block.number + 9999);         hevm.warp(block.timestamp + maxDepositLockDuration);          // get reward         alice.doClaimReward(stream);            // accounting (to proof attack): save the rewardBalance of alice / save balance of stakeToken         uint EndBalanceA = testTokenA.balanceOf(address(alice));         uint EndBalanceB = testTokenB.balanceOf(address(alice));          // Stream returned everything we gave it         // (doStake sets balance of alice out of thin air => we compare end balance against our (thin air) balance)         assert(stakeAmount == EndBalanceB);          // we gained reward token without risk         assert(StartBalanceA == 0);         assert(StartBalanceA < EndBalanceA);         emit log_named_uint(\"alice gained\", EndBalanceA);     } ```  ### commandline  ``` dapp test --verbosity=2 --match \"test_quickDepositAndWithdraw\" 2> /dev/null Running 1 tests for src/test/Locke.t.sol:StreamTest [PASS] test_quickDepositAndWithdraw() (gas: 4501209)  Success: test_quickDepositAndWithdraw    alice gained: 13227 ```  ## Tools Used  dapptools  ## Recommended Mitigation Steps Ensure staked tokens can not generate reward tokens without streaming deposit tokens. First idea that comes to mind is making following line `https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L220` dependable on a positive amount > 0 of: `https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L229`  "}, {"title": "Any arbitraryCall gathered airdrop can be stolen with recoverTokens", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/162", "labels": ["bug", "2 (Med Risk)", "sponsor disputed"], "target": "2021-11-streaming-findings", "body": "Any arbitraryCall gathered airdrop can be stolen with recoverTokens"}, {"title": "`Governed` doesn't implement the `IGoverned` interface", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/161", "labels": ["bug", "0 (Non-critical)", "disagree with severity"], "target": "2021-11-streaming-findings", "body": "`Governed` doesn't implement the `IGoverned` interface"}, {"title": "`Governed`'s constructor doesn't emit an initial `NewGov` event", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/159", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-11-streaming-findings", "body": "`Governed`'s constructor doesn't emit an initial `NewGov` event"}, {"title": "`Governed.acceptGov()` emits `NewGov` events when the governor hasn't changed", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/158", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor acknowledged"], "target": "2021-11-streaming-findings", "body": "`Governed.acceptGov()` emits `NewGov` events when the governor hasn't changed"}, {"title": "`Governed.setPendingGov()` emits `NewPendingGov` events when the pending governor hasn't changed", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/157", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor acknowledged"], "target": "2021-11-streaming-findings", "body": "`Governed.setPendingGov()` emits `NewPendingGov` events when the pending governor hasn't changed"}, {"title": "`LockeERC20.approve()` and `LockeERC20.permit()` emit `Approval` events when the allowence hasn't changed", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/153", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor disputed"], "target": "2021-11-streaming-findings", "body": "`LockeERC20.approve()` and `LockeERC20.permit()` emit `Approval` events when the allowence hasn't changed"}, {"title": "`LockeERC20.transferFrom()` emits `Transfer` events when `from` equals `to`", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/151", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor disputed"], "target": "2021-11-streaming-findings", "body": "`LockeERC20.transferFrom()` emits `Transfer` events when `from` equals `to`"}, {"title": "`LockeERC20.transfer()` and `LockeERC20.transferFrom()` emit `Transfer` events when the transferred amount is zero", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/150", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-11-streaming-findings", "body": "`LockeERC20.transfer()` and `LockeERC20.transferFrom()` emit `Transfer` events when the transferred amount is zero"}, {"title": "`rewardPerToken()` reverts before start time.", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/147", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-streaming-findings", "body": "# Handle  jonah1005   # Vulnerability details  ## Impact `rewardPerToken()` is calculated according to `lastApplicableTime`and `lastUpdate`. [Locke.sol#L343-L353](https://github.com/code-423n4/2021-11-streaming/blob/main/Streaming/src/Locke.sol#L343-L353) Since `lastUpdate` is set to `startTime` before the start time. [Locke.sol#L203-L250](https://github.com/code-423n4/2021-11-streaming/blob/main/Streaming/src/Locke.sol#L203-L250), it reverts before the start time.  `lastApplicableTime()) - lastUpdate` would revert when `lastUpdate` is bigger than `lastApplicableTime()`.  ## Proof of Concept This is the web3.py script: ```python     stream.functions.stake(deposit_amount).transact()     stream.functions.rewardPerToken().call() ``` Since `rewardPerToken` returns zero when totalVirtualBalance equals zero, we have to stake a few funds to trigger this bug.  ## Tools Used hardhat ## Recommended Mitigation Steps Recommend to return zero before startTime. ```solidity     function rewardPerToken() public view returns (uint256) {         if (totalVirtualBalance == 0 || lastApplicableTime() < startTime) {             return cumulativeRewardPerToken;         } else {             // \u2206time*rewardTokensPerSecond*oneDepositToken / totalVirtualBalance             return cumulativeRewardPerToken + (                 // NOTE: depositDecimalsOne                 ((uint256(lastApplicableTime()) - lastUpdate) * rewardTokenAmount * depositDecimalsOne/streamDuration)                  / totalVirtualBalance             );         }     } ```  "}, {"title": "Avoid fee ", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/145", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "sponsor acknowledged"], "target": "2021-11-streaming-findings", "body": "Avoid fee "}, {"title": "\"> 0\" is less efficient than \"!= 0\" for unsigned integers", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/143", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-streaming-findings", "body": "\"> 0\" is less efficient than \"!= 0\" for unsigned integers"}, {"title": "Use existing memory version of state variables (Locke.sol)", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/142", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-streaming-findings", "body": "Use existing memory version of state variables (Locke.sol)"}, {"title": "Missing contract check on `rewardtoken`", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/140", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor acknowledged"], "target": "2021-11-streaming-findings", "body": "Missing contract check on `rewardtoken`"}, {"title": "[Gas optimization] remove command less else in an if else", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/137", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-streaming-findings", "body": "# Handle  Omik   # Vulnerability details  ## Impact In the https://github.com/code-423n4/2021-11-streaming/blob/main/Streaming/src/Locke.sol#L472 the withdraw and stake function there is unnecessary else statement which didnt have any command inside it, this can lead to gas consumption more expensive then using only if statement for isSale check.  ## Proof of Concept pragma solidity ^0.8.0;   contract testing {      uint public counter;      function test()public {         if(true){             counter += 1;         }else{          }     }//43582 gas      function test2()public {         if(true){             counter += 1;         }     }//26449 gas      }  "}, {"title": "Missing address(0) check can, lead to user transfering token to the burn address, and doesnt reduce the total supply", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/136", "labels": ["bug", "1 (Low Risk)", "sponsor disputed"], "target": "2021-11-streaming-findings", "body": "Missing address(0) check can, lead to user transfering token to the burn address, and doesnt reduce the total supply"}, {"title": "Missing address(0) check, can crippled the governed functions", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/135", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-11-streaming-findings", "body": "Missing address(0) check, can crippled the governed functions"}, {"title": "Business logic bug in __abdicate() function - 2 Bugs", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/132", "labels": ["bug", "3 (High Risk)", "disagree with severity", "sponsor confirmed"], "target": "2021-11-streaming-findings", "body": "# Handle  cyberboy   # Vulnerability details  ## Impact The __abdicate() function at https://github.com/code-423n4/2021-11-streaming/blob/main/Streaming/src/Locke.sol#L46-L50 is the logic to remove the governance i.e., to renounce governance. However, the function logic does not consider emergency governor and pending governor, which can be a backdoor as only the \"gov\" is set to zero address while the emergency and pending gov remains. A pending gov can just claim and become the gov again, replacing the zero address.  ## Proof of Concept 1. Compile the contract and set the _GOVERNOR and _EMERGENCY_GOVERNOR. 2. Now set a pendingGov but do not call acceptGov()  Bug 1 3. Call the __abdicate() function and we will notice only \"gov\" is set to zero address while emergency gov remains.  Bug2 4. Now use the address used in \"pendingGov\" to call acceptGov() function. 5. We will notice the new gov has been updated to the new address from the zero address.   Hence the __abdicate() functionality can be used as a backdoor using emergency governor or leaving a pending governor to claim later.     ## Tools Used Remix to test the poC  ## Recommended Mitigation Steps The __abdicate() function should set emergency_gov and pendingGov as well to zero address.   "}, {"title": "Structs can be rearranged to save gas", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/131", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-streaming-findings", "body": "Structs can be rearranged to save gas"}, {"title": "Flash loan mechanics do not implement any standard", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/130", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor acknowledged"], "target": "2021-11-streaming-findings", "body": "Flash loan mechanics do not implement any standard"}, {"title": "Use local variable in fundStream()", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/127", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-streaming-findings", "body": "Use local variable in fundStream()"}, {"title": "parameter \"who\" not used", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/125", "labels": ["bug", "1 (Low Risk)"], "target": "2021-11-streaming-findings", "body": "parameter \"who\" not used"}, {"title": "prevent rounding error", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/124", "labels": ["bug", "1 (Low Risk)"], "target": "2021-11-streaming-findings", "body": "prevent rounding error"}, {"title": "ts.tokens sometimes calculated incorrectly", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/123", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-11-streaming-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact Suppose someone stakes some tokens and then withdraws all of his tokens (he can still withdraw). This will result in ts.tokens being 0.  Now after some time he stakes some tokens again. At the second stake updateStream() is called and the following if condition is false because ts.tokens==0 ```JS   if (acctTimeDelta > 0 && ts.tokens > 0) { ``` Thus ts.lastUpdate is not updated and stays at the value from the first withdraw. Now he does a second withdraw. updateStream() is called an calculates the updated value of ts.tokens. However it uses ts.lastUpdate, which is the time from the first withdraw and not from the second stake. So the value of ts.token is calculated incorrectly. Thus more tokens can be withdrawn than you are supposed to be able to withdraw.  ## Proof of Concept https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L417-L447  ```JS function stake(uint112 amount) public lock updateStream(msg.sender) {       ...                  uint112 trueDepositAmt = uint112(newBal - prevBal);        ...          ts.tokens += trueDepositAmt; ```  https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L455-L479  ```JS function withdraw(uint112 amount) public lock updateStream(msg.sender) {         ...         ts.tokens -= amount; ```  https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L203-L250  ```JS function updateStreamInternal(address who) internal { ...  uint32 acctTimeDelta = uint32(block.timestamp) - ts.lastUpdate;             if (acctTimeDelta > 0 && ts.tokens > 0) {                 // some time has passed since this user last interacted                 // update ts not yet streamed                 ts.tokens -= uint112(acctTimeDelta * ts.tokens / (endStream - ts.lastUpdate));                 ts.lastUpdate = uint32(block.timestamp);             } ```  ## Tools Used  ## Recommended Mitigation Steps Change the code in updateStream()  to:  ```JS     if (acctTimeDelta > 0 ) {                 // some time has passed since this user last interacted                 // update ts not yet streamed                 if (ts.tokens > 0)                        ts.tokens -= uint112(acctTimeDelta * ts.tokens / (endStream - ts.lastUpdate));                 ts.lastUpdate = uint32(block.timestamp);  // always update ts.lastUpdate (if time has elapsed)             } ```  Note: the next if statement with unstreamed and lastUpdate can be changed in a similar way to save some gas   "}, {"title": "recoverTokens doesn't work when isSale is true", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/121", "labels": ["bug", "3 (High Risk)"], "target": "2021-11-streaming-findings", "body": "recoverTokens doesn't work when isSale is true"}, {"title": "claimReward unnessary logic", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/119", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-streaming-findings", "body": "claimReward unnessary logic"}, {"title": "Storage variable unstreamed can be artificially inflated", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/118", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-11-streaming-findings", "body": "# Handle  harleythedog   # Vulnerability details  ## Impact The storage variable `unstreamed` keeps track of the global amount of deposit token in the contract that have not been streamed yet. This variable is a public variable, and users that read this variable likely want to use its value to determine whether or not they want to stake in the stream.  The issue here is that `unstreamed` is incremented on calls to `stake`, but it is not being decremented on calls to `withdraw`. As a result, a malicious user could simply stake, immediately withdraw their staked amount, and they will have increased `unstreamed`. They could do this repeatedly or with large amounts to intentionally inflate `unstreamed` to be as large as they want.  Other users would see this large amount and be deterred to stake in the stream, since they would get very little reward relative to the large amount of unstreamed deposit tokens that *appear* to be in the contract. This benefits the attacker as less users will want to stake in the stream, which leaves more rewards for them.  ## Proof of Concept See `stake` here: https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L417  See `withdraw` here: https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L455  Notice that `stake` increments `unstreamed` but `withdraw` does not affect `unstreamed` at all, even though `withdraw` is indeed removing unstreamed deposit tokens from the contract.  ## Tools Used Inspection  ## Recommended Mitigation Steps Add the following line to `withdraw` to fix this issue: ``` unstreamed -= amount; ```  "}, {"title": "Use of ecrecover is susceptible to signature malleability", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/117", "labels": ["bug", "1 (Low Risk)"], "target": "2021-11-streaming-findings", "body": "Use of ecrecover is susceptible to signature malleability"}, {"title": "flashLoan does not have a return statement", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/114", "labels": ["bug", "1 (Low Risk)"], "target": "2021-11-streaming-findings", "body": "flashLoan does not have a return statement"}, {"title": "Governance has the ability to withdraw tokens the stream doesn't know about", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/112", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "sponsor acknowledged"], "target": "2021-11-streaming-findings", "body": "Governance has the ability to withdraw tokens the stream doesn't know about"}, {"title": "LockeERC20 name is not implemented as comment imply", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/110", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-streaming-findings", "body": "# Handle  wuwe1   # Vulnerability details  ```solidity // locke + depositTokenName + streamId = lockeUSD Coin-1 name = string(abi.encodePacked(\"locke\", ERC20(depositToken).name(), \": \", toString(streamId))); ```  As the comment imply, the `\": \"` should be `\"-\"`  ## Recommended Mitigation Steps  Consider change the comment or the code.  "}, {"title": "Caching variables", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/104", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-streaming-findings", "body": "# Handle  Jujic   # Vulnerability details  ## Impact Some of the variables can be cached to slightly reduce gas usage  ## Proof of Concept https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/PoolTemplate.sol#L343  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L406-L407  https://github.com/code-423n4/2022-01-insure/blob/19d1a7819fe7ce795e6d4814e7ddf8b8e1323df3/contracts/Vault.sol#L461-L479  ``` function withdrawRedundant(address _token, address _to)         external         override         onlyOwner     {         if (             _token == address(token) &&             balance < IERC20(token).balanceOf(address(this))         ) {             uint256 _redundant = IERC20(token).balanceOf(address(this)) -                 balance;             IERC20(token).safeTransfer(_to, _redundant);         } else if (IERC20(_token).balanceOf(address(this)) > 0) {             IERC20(_token).safeTransfer(                 _to,                 IERC20(_token).balanceOf(address(this))             );         }     } ```  ## Tools Used Remix ## Recommended Mitigation Steps Consider caching those variable for read and make sure write back to storage Example: ``` bal =  IERC20(_token).balanceOf(address(this); ```  "}, {"title": "Wrong comment in claimReward", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/102", "labels": ["bug", "1 (Low Risk)"], "target": "2021-11-streaming-findings", "body": "Wrong comment in claimReward"}, {"title": "Unnecessary call to lastApplicableTime() in claimReward()", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/100", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-streaming-findings", "body": "# Handle  kenzo   # Vulnerability details  Since `claimReward` can only be called after `endRewardLock`, `lastApplicableTime` will always return `endStream`.  ## Impact Some gas can be saved.  ## Proof of Concept `claimReward` will only run if time > endRewardLock (which is >= endStream): ``` require(block.timestamp > endRewardLock, \"lock\"); ``` https://github.com/code-423n4/2021-11-streaming/blob/main/Streaming/src/Locke.sol#L556 `claimReward` is calling `lastApplicableTime`: ``` lastUpdate = lastApplicableTime(); ``` https://github.com/code-423n4/2021-11-streaming/blob/main/Streaming/src/Locke.sol#L567 And this is `lastApplicableTime`: ``` return block.timestamp <= endStream ? uint32(block.timestamp) : endStream; ``` https://github.com/code-423n4/2021-11-streaming/blob/main/Streaming/src/Locke.sol#L340 Therefore, it will always return `endStream`.   ## Recommended Mitigation Steps In `claimReward`, change this line: ``` lastUpdate = lastApplicableTime(); ``` https://github.com/code-423n4/2021-11-streaming/blob/main/Streaming/src/Locke.sol#L340 To: ``` lastUpdate = endStream; ```  "}, {"title": "No need to temporarily save old values when updating settings", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/99", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-streaming-findings", "body": "No need to temporarily save old values when updating settings"}, {"title": "Global unstreamed variable not kept up to date", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/98", "labels": ["bug", "1 (Low Risk)"], "target": "2021-11-streaming-findings", "body": "Global unstreamed variable not kept up to date"}, {"title": "Use one require instead of  several", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/96", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-11-streaming-findings", "body": "Use one require instead of  several"}, {"title": "Inaccuate comment about claimFees()", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/94", "labels": ["bug", "1 (Low Risk)"], "target": "2021-11-streaming-findings", "body": "Inaccuate comment about claimFees()"}, {"title": "Remove unneeded variable in creatorClaimSoldTokens() to save gas", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/93", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-streaming-findings", "body": "Remove unneeded variable in creatorClaimSoldTokens() to save gas"}, {"title": "Remove redundant math to save gas in dilutedBalance()", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/89", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-streaming-findings", "body": "Remove redundant math to save gas in dilutedBalance()"}, {"title": "TODOs List May Leak Important Info & Errors", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/78", "labels": ["bug", "1 (Low Risk)", "disagree with severity"], "target": "2021-11-streaming-findings", "body": "TODOs List May Leak Important Info & Errors"}, {"title": "creatorClaimSoldTokens() Does Not Check Destination Address", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/77", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-11-streaming-findings", "body": "creatorClaimSoldTokens() Does Not Check Destination Address"}, {"title": "Stream.sol: possible tx.origin attack vector via recoverTokens()", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/73", "labels": ["bug", "1 (Low Risk)", "sponsor disputed"], "target": "2021-11-streaming-findings", "body": "Stream.sol: possible tx.origin attack vector via recoverTokens()"}, {"title": "Governed.sol: setPendingGov() should use the emergency_governed modifier.", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/72", "labels": ["bug", "0 (Non-critical)", "2 (Med Risk)", "sponsor disputed"], "target": "2021-11-streaming-findings", "body": "Governed.sol: setPendingGov() should use the emergency_governed modifier."}, {"title": "Stream.claimReward can be simplified", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/70", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-streaming-findings", "body": "Stream.claimReward can be simplified"}, {"title": "Missing zero-address checks on LockeERC20 and Stream construction", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/68", "labels": ["bug", "1 (Low Risk)"], "target": "2021-11-streaming-findings", "body": "Missing zero-address checks on LockeERC20 and Stream construction"}, {"title": "Stream.updateStreamInternal performs extra storage reads", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/67", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-streaming-findings", "body": "Stream.updateStreamInternal performs extra storage reads"}, {"title": "Free flashloan for governance", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/66", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-11-streaming-findings", "body": "Free flashloan for governance"}, {"title": "Deny of service because integer overflow", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/65", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-11-streaming-findings", "body": "Deny of service because integer overflow"}, {"title": "Use _notSameBlock", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/62", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-11-streaming-findings", "body": "Use _notSameBlock"}, {"title": "Delete unnecessary variable", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/58", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-streaming-findings", "body": "# Handle  0x1f8b   # Vulnerability details  ## Impact Gas optimization.  ## Proof of Concept In the method exit of Locke contract, ts.tokens was stored in a local variable, amount, and then this variable was used for call withdraw method, is better to call directly like `withdraw(ts.tokens)`  Source reference: - https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L492-L493  ## Tools Used Manual review.  ## Recommended Mitigation Steps Remove the amount variable.  "}, {"title": "Remove dead code", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/57", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-streaming-findings", "body": "Remove dead code"}, {"title": "LockeERC20 is vulnerable to frontrun attack", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/55", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor acknowledged"], "target": "2021-11-streaming-findings", "body": "LockeERC20 is vulnerable to frontrun attack"}, {"title": "Avoid multiple cast", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/54", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-streaming-findings", "body": "Avoid multiple cast"}, {"title": "Flashloan is given for 1 token but checks balances for both reward and deposit token", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/50", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-streaming-findings", "body": "# Handle  pedroais   # Vulnerability details  ## Impact Useless checks that cost gas ## Proof of Concept Since the Flashloan function has the lock modifier reentrancy is not possible so checking both tokens is useless.  ## Recommended Mitigation Steps   Proposed new function with less code :               function flashloan(address token, address to, uint112 amount, bytes memory data) public lock {         require(token == depositToken || token == rewardToken, \"erc\");          uint256 preTokenBalance = ERC20(token).balanceOf(address(this));          ERC20(token).safeTransfer(to, amount);          // the `to` contract should have a public function with the signature:         // function lockeCall(address initiator, address token, uint256 amount, bytes memory data);         LockeCallee(to).lockeCall(msg.sender, token, amount, data);          uint256 postTokenBalance = ERC20(token).balanceOf(address(this));          uint112 feeAmt = amount * 10 / 10000; // 10bps fee         require(preTokenBalance + feeAmt <= postTokenBalance, \"f1\");          if (token == depositToken) {             depositTokenFlashloanFeeAmount += feeAmt;         } else {             rewardTokenFeeAmount += feeAmt;         }          emit Flashloaned(token, msg.sender, amount, feeAmt);     }   "}, {"title": "arbitraryCall() can get blocked by an attacker", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/47", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2021-11-streaming-findings", "body": "arbitraryCall() can get blocked by an attacker"}, {"title": "Subtraction can be done unchecked because the require statement checks for underflow", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/46", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-streaming-findings", "body": "Subtraction can be done unchecked because the require statement checks for underflow"}, {"title": "Stream constructor reuse the function arguments instead storage variables", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/45", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-streaming-findings", "body": "Stream constructor reuse the function arguments instead storage variables"}, {"title": "Cache the return value from rewardPerToken()", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/44", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-streaming-findings", "body": "# Handle  GiveMeTestEther   # Vulnerability details  ## Impact Save gas by caching the return value from rewardPerToken() in a local variable and use the local variable L220 and L222. This saves us two storage reads (1 cold = 800 gas, and 1 warm= 100 gas). It is way cheaper to read from a local variable (push/pop operations 2-3 gas each + cheap others)  Note: same for the claimReward() function on L555  ## Proof of Concept https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L203  https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L555 ## Tools Used  ## Recommended Mitigation Steps - cache in a  local variable: uint256 _rewardPerToken = rewardPerToken(); - write the value to the storage variable: cumulativeRewardPerToken =  _rewardPerToken; - replace the occurrences of cumulativeRewardPerToken on L220/222 with _rewardPerToken   "}, {"title": "Struct TokenStream remove unused variable merkleAccess", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/42", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-streaming-findings", "body": "# Handle  GiveMeTestEther   # Vulnerability details  ## Impact Remove the unused merkleAccess variable in the TokenStream struct. According to the struct packing it uses a single storage slot.  ## Proof of Concept https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L106  ## Tools Used  ## Recommended Mitigation Steps - remove the unused merkleAccess variable in the TokenStream struct  "}, {"title": "depositTokens need to have a decimals() function", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/41", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-streaming-findings", "body": "# Handle  GiveMeTestEther   # Vulnerability details  ## Impact Only ERC20 tokens with a decimals() function can be used as a depositToken. A stream creator maybe not be aware of this restriction and the creation of a stream would revert.  ## Proof of Concept In the constructor of the Stream contract the decimals() (L310) functions of the depositToken is called. But according to EIP20 (https://eips.ethereum.org/EIPS/eip-20) the decimals() function is optional.   https://github.com/code-423n4/2021-11-streaming/blob/56d81204a00fc949d29ddd277169690318b36821/Streaming/src/Locke.sol#L310  ## Tools Used  ## Recommended Mitigation Steps - clearly inform the stream creator that the depositToken needs to have the decimals() function implemented  "}, {"title": "Dead code", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/36", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-11-streaming-findings", "body": "Dead code"}, {"title": "Missing Emit in critical function", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/35", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-streaming-findings", "body": "# Handle  cyberboy   # Vulnerability details  ## Impact Events for critical state changes (e.g., owner and other critical parameters) should be emitted for tracking this off-chain.   ## Proof of Concept https://github.com/code-423n4/2021-11-streaming/blob/main/Streaming/src/Locke.sol#L41-L43 The function \"setEmergencyGov\" is missing event emit, and it is a critical function used for setting emergency governer.    ## Tools Used Slither  ## Recommended Mitigation Steps Add an event and emit it as a new emergency governor is set.   "}, {"title": "Use const instead of storage", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/33", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-11-streaming-findings", "body": "Use const instead of storage"}, {"title": "Missing NatSpec comments", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/32", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-11-streaming-findings", "body": "Missing NatSpec comments"}, {"title": "Use inmutable keyword", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/31", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-streaming-findings", "body": "Use inmutable keyword"}, {"title": "Typos", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/30", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor confirmed"], "target": "2021-11-streaming-findings", "body": "Typos"}, {"title": "Division before multiple can lead to precision errors", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/28", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-streaming-findings", "body": "# Handle  cyberboy   # Vulnerability details  ## Impact Performing multiplication before division is generally better to avoid loss of precision because Solidity integer division might truncate  ## Proof of Concept https://github.com/code-423n4/2021-11-streaming/blob/main/Streaming/src/Locke.sol#L237-L238 globalStreamingSpeedPerSecond is later used for unstreamed for multiplication after performing division while calculation of globalStreamingSpeedPerSecond   ## Tools Used Slither   ## Recommended Mitigation Steps The code can be optimized to use uint112((uint256(tdelta) * (uint256(unstreamed) * 10**6) / (endStream - lastUpdate) * 10**6 Or maybe just  (uint112((uint256(tdelta) * (uint256(unstreamed)) / (endStream - lastUpdate)     "}, {"title": "Missing zero Address check ", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/26", "labels": ["bug", "1 (Low Risk)", "disagree with severity"], "target": "2021-11-streaming-findings", "body": "Missing zero Address check "}, {"title": "constructor should guard against zero addresses", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/20", "labels": ["bug", "1 (Low Risk)", "disagree with severity"], "target": "2021-11-streaming-findings", "body": "constructor should guard against zero addresses"}, {"title": "Floating Pragma is set.", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/19", "labels": ["bug", "1 (Low Risk)"], "target": "2021-11-streaming-findings", "body": "Floating Pragma is set."}, {"title": "Internal functions to private", "html_url": "https://github.com/code-423n4/2021-11-streaming-findings/issues/7", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-streaming-findings", "body": "Internal functions to private"}, {"title": "Gas optimization: Unnecessary return string", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/385", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  gzeon   # Vulnerability details  ## Impact https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/PoolTransferVerification.sol#L61 ```     return (       maltDataLab.maltPriceAverage(priceLookback) > priceTarget * (10000 - thresholdBps) / 10000,       \"The price of Malt is below peg. Wait for peg to be regained or purchase arbitrage tokens.\"     ); ``` when the condition is true (which should be the majority of time), the reason string is unnecessary. Only return the string when the condition is false.  "}, {"title": " Unnecessary intermediate variables (MovingAverage.sol)", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/382", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-11-malt-findings", "body": " Unnecessary intermediate variables (MovingAverage.sol)"}, {"title": "DOS with unbounded loop", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/380", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  Koustre   # Vulnerability details  ## Impact In UniswapHandler, in the function ```removeBuyer``` there is a for loop over an unbounded Buyers array, which if the buyers array gets too large can cause a denial of service and prevents the contract from being able to remove buyer roles from users/contracts. This would allow users/contracts to circumvent recovery mode and to continue to purchase and sell tokens using the contract.  ## Proof of Concept Provide direct links to all referenced code in GitHub. Add screenshots, logs, or any other relevant proof that illustrates the concept.  ## Tools Used - Manual Study ## Recommended Mitigation Steps - remove unbounded for loop  "}, {"title": "Can remove treasuryRewardCut from ForfeitHandler.sol", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/379", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  harleythedog   # Vulnerability details  ## Impact In ForfeitHandler.sol, there are two values `swingTraderRewardCut ` and `treasuryRewardCut `, and these values always sum to 1000. Instead of having to go through all of the logic of setting these values independently and always ensuring that they sum to 1000, it would be simpler (and definitely save a lot of gas) if you simply removed everything related to `treasuryRewardCut` and always just used `1000-swingTraderRewardCut` in its place.  This also is more similar to what is done in StabilizerNode.sol where `treasuryCut` is simply what is left over after other components have taken their cut.  ## Proof of Concept See ForfeitHandler.sol here: https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/ForfeitHandler.sol  ## Tools Used Inspection  ## Recommended Mitigation Steps Simplify logic and save gas by removing `treasuryRewardCut`.  "}, {"title": "Unncessary statement in UniswapHandler.sol removeBuyer", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/377", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  harleythedog   # Vulnerability details  ## Impact In UniswapHandler.sol within the `removeBuyer` function, there is a statement on line 308: ``` address buyer; ```  This variable is not used at all in the rest of the function, so this statement can be removed to save gas.  ## Proof of Concept See statement here: https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/DexHandlers/UniswapHandler.sol#L308  ## Tools Used Inspection  ## Recommended Mitigation Steps Remove unnecessary line to save gas  "}, {"title": "Dutch auction can be manipulated", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/375", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  gzeon   # Vulnerability details  ## Impact When malt is under-peg and the swing trader module do not have enough capital to buy back to peg, a Dutch auction is triggered to sell arb token. The price of the Dutch auction decrease linearly toward endprice until _endAuction() is called. https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L589  _endAuction() is called in   1. When auction.commitments >= auction.maxCommitments https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L212  2. On stabilize() -> checkAuctionFinalization() -> _checkAuctionFinalization() https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/StabilizerNode.sol#L146 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L754  3. On stabilize() ->_startAuction() -> triggerAuction() -> _checkAuctionFinalization() https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/StabilizerNode.sol#L170 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L754  It is possible manipulate the dutch auction by preventing _endAuction() being called.  ## Proof of Concept Consider someone call purchaseArbitrageTokens with auction.maxCommitments minus 1 wei, `_endAuction` won't be called because auction.commitments < auction.maxCommitments. Further purchase would revert because `purchaseAndBurn` (https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L184) would likely revert since swapping 1 wei in most AMM will fail due to rounding error. Even if it does not revert, there is no incentive to waste gas to purchase 1 wei of token.  As such, the only way for the auction to finalize is to call stabilize().  However, this is not immediately possible because it require  `block.timestamp >= stabilizeWindowEnd` where `stabilizeWindowEnd = block.timestamp + stabilizeBackoffPeriod` stabilizeBackoffPeriod is initially set to 5 minutes in the contract  After 5 minute, stabilize() can be called by anyone. By using this exploit, an attacker can guarantee he can purchase at (startingPrice+endingPrice)/2 or lower, given the default 10 minute auctionLength and 5 minute stabilizeBackoffPeriod. (unless a privileged user call stabilize() which override the stability window)  Also note that stabilize() might not be called since there is no incentive.  ## Recommended Mitigation Steps 1. Incentivize stabilize() or incentivize a permission-less call to _endAuction() 2. Lock-in auction price when user commit purchase  "}, {"title": "Malt Protocol Uses Stale Results From `MaltDataLab` Which Can Be Abused By Users", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/373", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  leastwood   # Vulnerability details  ## Impact  `MaltDataLab` integrates several `MovingAverage` contracts to fetch sensitive data for the Malt protocol. Primary data used by the protocol consists of the real value for LP tokens, the average price for Malt and average reserve ratios. `trackMaltPrice`, `trackPoolReserves` and `trackPool` are called by a restricted role denoted as the `UPDATER_ROLE` and represented by an EOA account and not another contract. Hence, the EOA account must consistently update the aforementioned functions to ensure the most up-to-date values. However, miners can censor calls to `MaltDataLab` and effectively extract value from other areas of the protocol which use stale values.  ## Proof of Concept  Consider the following attack vector: - The price of Malt exceeds the lower bound threshold and hence `stabilize` can be called by any user. - The `_stabilityWindowOverride` function is satisfied, hence the function will execute. - The state variable, `exchangeRate`, queries `maltPriceAverage` which may use an outdated exchange rate. - `_startAuction` is executed which rewards `msg.sender` with 100 Malt as an incentive for triggering an auction. - As the price is not subsequently updated, a malicious attacker could collude with a miner to censor further pool updates and continue calling `stabilize` on every `fastAveragePeriod` interval to extract incentive payments. - If the payments exceed what the `UPDATER_ROLE` is willing to pay to call `trackMaltPrice`, a user is able to sustain this attack.  This threatens the overall stability of the protocol and should be properly handled to prevent such attacks. However, the fact that `MaltDataLab` uses a series of spot price data points to calculate the `MovingAverage` also creates an area of concern as well-funded actors could still manipulate the `MovingAverage` contract by sandwiching calls to `trackMaltPrice`, `trackPool` and `trackPoolReserves`.  `trackMaltPrice`, `trackPool`, and `trackPoolReserves` should be added to the following areas of the code where applicable. https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Bonding.sol#L159 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Bonding.sol#L173 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Bonding.sol#L177 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L881 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L710 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/StabilizerNode.sol#L156 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/StabilizerNode.sol#L190 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/ImpliedCollateralService.sol#L105  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider adding calls to `trackMaltPrice`, `trackPoolReserves` and `trackPool` wherever the values are impacted by the protocol. This should ensure the protocol is tracking the most up-to-date values. Assuming the cumulative values are used in the `MovingAverage` contracts, then sensitive calls utilising `MaltDataLab` should be protected from flashloan attacks. However, currently this is not the case, rather `MovingAverage` consists of a series of spot price data points which can be manipulated by well-funded actors or via a flashloan. Therefore, there needs to be necessary changes made to `MaltDataLab` to use cumulative price updates as its moving average instead of spot price.  "}, {"title": "AMM pool can be drained using a flashloan and calling `stabilize`", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/372", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  stonesandtrees   # Vulnerability details  ## Impact All of the `rewardToken` in a given AMM pool can be removed from the AMM pool and distributed as LP rewards.  ## Proof of Concept In the `stabilize` method in the `StabilizerNode` the initial check to see if the Malt price needs to be stabilized it uses a short period TWAP: https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/StabilizerNode.sol#L156  However, if the price is above the threshold for stabilization then the trade size required to stabilize looks at the AMM pool directly which is vulnerable to flashloan manipulation.  https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L250-L275  Attack: 1. Wait for TWAP to rise above the stabilization threshold 2. Flashloan remove all but a tiny amount of Malt from the pool. 3. Call `stabilize`. This will pass the TWAP check and execute `_distributeSupply` which in turn ultimately calls `_calculateTradeSize` in the `UniswapHandler`. This calculation will determine that almost all of the `rewardToken` needs to be removed from the pool to return the price to peg.  4. Malt will mint enough Malt to remove a lot of the `rewardToken` from the pool. 5. The protocol will now distribute that received `rewardToken` as rewards. 0.3% of which goes directly to the attacker and the rest goes to LP rewards, swing trader and the treasury.  The amount of money that can be directly stolen by a malicious actor is small but it can cause a lot of pain for the protocol as the pool will be destroyed and confusion around rewards will be created.  ## Tools Used Manual review  ## Recommended Mitigation Steps Use a short TWAP to calculate the trade size instead of reading directly from the pool.  "}, {"title": "Cache decimals", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/371", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact Consider caching decimals when initializing malt and collateralToken to avoid repeated external calls, as they are not supposed to change unless initialized again: ```solidity   uint256 maltDecimals = malt.decimals();   uint256 decimals = collateralToken.decimals(); ```   "}, {"title": "MiningService.setBonding should use BONDING role instead of REINVESTOR one", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/370", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  hyh   # Vulnerability details  ## Impact  BONDING_ROLE cannot be managed after it was initialized.  ## Proof of Concept  ```setBonding``` set the wrong role via _swapRole:  https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/MiningService.sol#L116  ## Recommended Mitigation Steps  Set ```BONDING_ROLE``` instead of ```REINVESTOR_ROLE``` in ```setBonding``` function:  Now: ``` function setBonding(address _bonding)  public  onlyRole(ADMIN_ROLE, \"Must have admin privs\") {  require(_bonding != address(0), \"Cannot use address 0\");  _swapRole(_bonding, bonding, REINVESTOR_ROLE);  bonding = _bonding; } ```  To be: ``` function setBonding(address _bonding)  public  onlyRole(ADMIN_ROLE, \"Must have admin privs\") {  require(_bonding != address(0), \"Cannot use address 0\");  _swapRole(_bonding, bonding, BONDING_ROLE);  bonding = _bonding; } ```  "}, {"title": "(10000 - thresholdBps) can be pre-calculated", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/369", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact contract PoolTransferVerification sets thresholdBps but in calculations uses only ```(10000 - thresholdBps)```. Consider pre-calculating to avoid re-evaluation again and again when this function is invoked.  "}, {"title": "ERC20 import", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/364", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-malt-findings", "body": "ERC20 import"}, {"title": "purchaseArbitrageTokens 0 amount", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/359", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact Function purchaseArbitrageTokens should validate that amount > 0, otherwise it may be possible to spam accountCommitmentEpochs with 0 amounts: ```solidity   if (auction.accountCommitments[msg.sender].commitment == 0) {     accountCommitmentEpochs[msg.sender].push(currentAuctionId);   } ```  ## Recommended Mitigation Steps require amount > 0  "}, {"title": "Unbounded loops", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/358", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact There are several loops in the contract which can eventually grow so large as to make future operations of the contract cost too much gas to fit in a block, e.g.: ```solidity   for (uint256 i = replenishingIndex; i < auctionIds.length; i = i + 1) // function outstandingArbTokens()   while (true) // function allocateArbRewards ```  ## Recommended Mitigation Steps Consider introducing a reasonable upper limit based on block gas limits. Also, you can consider using EnumerableSet (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/structs/EnumerableSet.sol) where possible, e.g. 'buyers' or 'verifierList'.  "}, {"title": "maxAmount and balance", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/357", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact I think this if check is incorrect, because in theory maxAmount parameter can be greater than totalMaltBalance: ```solidity     if (rewards <= deployedCapital && maxAmount != totalMaltBalance) {       // If all malt is spent we want to reset deployed capital       deployedCapital = deployedCapital - rewards;     } else {       deployedCapital = 0;     } ```  ## Recommended Mitigation Steps If my assumption is correct, the check should use balance, not maxAmount: ``solidity   balance != totalMaltBalance ``` Another possible solution: ``solidity   maxAmount <= totalMaltBalance ``` However, I think the best approach would be to eliminate 'balance' altogether: ```solidity   uint256 totalMaltBalance = malt.balanceOf(address(this));    if (totalMaltBalance == 0) {     return 0;   }    (uint256 basis,) = costBasis();    if (maxAmount > totalMaltBalance) {     maxAmount = totalMaltBalance;   }    malt.safeTransfer(address(dexHandler), maxAmount);   uint256 rewards = dexHandler.sellMalt();    if (rewards <= deployedCapital && maxAmount < totalMaltBalance) {     // If all malt is spent we want to reset deployed capital     deployedCapital = deployedCapital - rewards;   } else {     deployedCapital = 0;   }   ```  "}, {"title": "Inclusive checks", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/356", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "Inclusive checks"}, {"title": "Auction.claimArbitrage: if calculated claimable amount is too big, the remaining committed amount cannot be retrieved", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/353", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  hyh   # Vulnerability details  ## Impact  A condition requires that calculated retrievable amount shouldn't be too big. If it is the function fails and the remaining portion of commitment is frozen.  As the amount is calculated by the system a user cannot do anything to retrieve remaining part of commitment, if any.  ## Proof of Concept  ```claimArbitrage``` fails if calculated redemption is higher than remaining commitment: https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L230  ```userClaimableArbTokens``` calculated amount can be bigger than remaining user funds: https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L279  ## Recommended Mitigation Steps  If the freezing of remainder amount is not intentional then substitute require with ceiling the amount to be retrieved with the remaining part.  Now: ``` require(redemption <= remaining.add(1), \"Cannot claim more tokens than available\"); ```  To be: ``` if (redemption > remaining) {  redemption = remaining; } ```   "}, {"title": "Inconsistencies when checking if the auction is active", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/352", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact When auction.endingTime == now, function purchaseArbitrageTokens thinks that auction is still active, while isAuctionFinished and earlyExitReturn think that it has ended: purchaseArbitrageTokens: ```solidity   require(auction.endingTime >= now, \"Auction is already over\"); ``` isAuctionFinished: ```solidity   return auction.endingTime > 0 && (now >= auction.endingTime || ...); ``` earlyExitReturn: ```solidity   if(active || block.timestamp < auctionEndTime) {     return 0;   } ```  ## Recommended Mitigation Steps Consider unifying it across the functions.  "}, {"title": "Validation of 'to' in transferAndCall and transferWithPermit", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/350", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact In functions transferAndCall and transferWithPermit the condition should be AND, not OR: ```solidity   require(to != address(0) || to != address(this)); ```  ## Recommended Mitigation Steps ```solidity   require(to != address(0) && to != address(this)); ```   "}, {"title": "DOMAIN_SEPARATOR can change", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/349", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact The variable DOMAIN_SEPARATOR in contract ERC20Permit is assigned in the constructor and will not change after being initialized. However, if a hard fork happens after the contract deployment, the domain would become invalid on one of the forked chains due to the block.chainid has changed.  Also, you don't need an assmebly to retrieve chainid, you can get it from a built in variable block.chainid.  Similar issues were reported in a previous contest and were assigned a severity of low:  https://github.com/code-423n4/2021-06-realitycards-findings/issues/166  https://github.com/code-423n4/2021-09-swivel-findings/issues/98  ## Recommended Mitigation Steps An elegant solution that you may consider applying is from Sushi Trident: https://github.com/sushiswap/trident/blob/concentrated/contracts/pool/concentrated/TridentNFT.sol#L47-L62  "}, {"title": "Create2Deployer", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/348", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-11-malt-findings", "body": "Create2Deployer"}, {"title": "Inaccurate revert messages", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/343", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact Inaccurate revert messages: ```solidity           _delay >= 0 && _delay < gracePeriod,   \"Timelock::setDelay: Delay must not be greater equal to zero and less than gracePeriod\"    require(startEpoch < endEpoch, \"Start cannot be before the end\");   require(rewardAmount <= rewardEarned, \"< earned\");   require(bondedBalance > 0, \"< bonded balance\");   require(amount <= bondedBalance, \"< bonded balance\"); ```   "}, {"title": "RewardReinvestor - safeTransfer used unnecessarily on Malt token", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/339", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  ScopeLift   # Vulnerability details  ## Impact  Inside `provideReinvest` and `_bondAccount` gas can be saved by using the standard transfer method on the Malt token, since we know its implementation is correct and will return true/false.  ## Proof of Concept  N/A  ## Tools Used  N/A  ## Recommended Mitigation Steps  Replace `malt.safeTransfer(address(dexHandler), balance);` with something like:  ```solidity require(malt.transfer(address(dexHandler), balance), 'malt transfer failed'); ```   "}, {"title": "AbstractRewardMine - Re-entrancy attack during withdrawal", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/333", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  ScopeLift   # Vulnerability details  ## Impact  The internal `_withdraw` method does not follow the checks-effects-interactions pattern. A malicious token, or one that implemented transfer hooks, could re-enter the public calling function (such as `withdraw()`) before proper internal accounting was completed. Because the `earned` function looks up the `_userWithdrawn` mapping, which is not yet updated when the transfer occurs, it would be possible for a malicious contract to re-enter `_withdraw` repeatedly and drain the pool.  ## Proof of Concept  N/A  ## Tools Used  N/A  ## Recommended Mitigation Steps  The internal accounting should be done before the transfer occurs:  ```solidity function _withdraw(address account, uint256 amountReward, address to) internal {     _userWithdrawn[account] += amountReward;     _globalWithdrawn += amountReward;f     rewardToken.safeTransfer(to, amountReward);      emit Withdraw(account, amountReward, to);   } ```   "}, {"title": "Various contracts - remove unused function parameters to save gas ", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/331", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-11-malt-findings", "body": "Various contracts - remove unused function parameters to save gas "}, {"title": "Various contracts - stricter function mutability for gas savings", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/330", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  ScopeLift   # Vulnerability details  ## Impact  There are four functions that can have stricter function mutability declarations. Using a stricter declaration can help the compiler save gas when it knows whether reads and writes will occur in a function  ## Proof of Concept  N/A  ## Tools Used  solc  ## Recommended Mitigation Steps  Implement the changes suggested by the Solidity compiler. For examples like `AbstractTransferVerification`, the solidity compiler is wrong because it doesn't know you plan to override this function declaration. Instead, `AbstractTransferVerification` could be an interface without a function definition  ``` contracts/AbstractTransferVerification.sol:9:3: Warning: Function state mutability can be restricted to pure   function verifyTransfer(address from, address to, uint256 amount) public view virtual returns (bool, string memory) {   ^ (Relevant source part starts here and spans across multiple lines).  contracts/AuctionEscapeHatch.sol:168:3: Warning: Function state mutability can be restricted to view   function _calculateMaltRequiredForExit(uint256 _auctionId, uint256 amount) internal returns(uint256) {   ^ (Relevant source part starts here and spans across multiple lines).  contracts/AuctionParticipant.sol:127:3: Warning: Function state mutability can be restricted to pure   function _handleRewardDistribution(uint256 rewarded) virtual internal {   ^ (Relevant source part starts here and spans across multiple lines).  contracts/MaltDataLab.sol:202:3: Warning: Function state mutability can be restricted to pure   function _normalizedPrice(   ^ (Relevant source part starts here and spans across multiple lines). ```  "}, {"title": "Permissions - return values not checked when sending ETH", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/329", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  ScopeLift   # Vulnerability details  ## Impact  On lines 85 and 101, ETH is transferred using a `.call` to an address provided as an input, but there is no verification that the call call succeeded. This can result in a call to `emergencyWithdrawGAS` or `partialWithdrawGAS` appearing successful but in reality it failed. This can happen when the provided `destination` address is a contract that cannot receive ETH, or if the `amount` provided is larger than the contract's balance  ## Proof of Concept  Enter the following in remix, deploy the `Receiver` contract, and send 1 ETH when deploying the `Permissions` contract. Call `emergencyWithdrawGAS` with the receiver address and you'll see it reverts. This would not be caught in the current code  ```solidity pragma solidity ^0.8.0;  contract Receivier{}  contract Permissions {     constructor() payable {}      function emergencyWithdrawGAS(address payable destination) external {         (bool ok, ) = destination.call{value: address(this).balance}('');         require(ok, \"call failed\");     } } ```  ## Tools Used  Remix  ## Recommended Mitigation Steps  In `emergencyWithdrawGAS`:  ```diff - destination.call{value: address(this).balance}(''); + (bool ok, ) = destination.call{value: address(this).balance}(''); + require(ok, \"call failed\"); ```  And similar for `partialWithdrawGAS`  "}, {"title": "AuctionBurnReserveSkew - remove `for` loop from initializer", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/326", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  ScopeLift   # Vulnerability details  ## Estimated risk level Gas Optimization  ## Impact Instantiating an array of length n is better than `push(0)`  n times and saves 20k gas in tests.  ## Proof of Concept  ## Tools Used   ## Recommended Mitigation Steps change the initializer  ```diff ## Saves ~20,000 gas on initialize  diff --git a/src/contracts/AuctionBurnReserveSkew.sol b/src/contracts/AuctionBurnReserveSkew.sol index 4ed6fa6..87d5959 100644 --- a/src/contracts/AuctionBurnReserveSkew.sol +++ b/src/contracts/AuctionBurnReserveSkew.sol @@ -51,9 +51,7 @@ contract AuctionBurnReserveSkew is Initializable, Permissions {      auction = IAuction(_auction);      auctionAverageLookback = _period;   -    for (uint i = 0; i < _period; i++) { -      pegObservations.push(0); -    } +    pegObservations = new uint256[](_period);    }      function consult(uint256 excess) public view returns (uint256) { ```  "}, {"title": "User can bypass Recovery Mode via UniswapHandler to buy Malt ", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/325", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  gzeon   # Vulnerability details  ## Impact One of the innovative feature of Malt is to block buying while under peg. The buy block can be bypassed by swapping to the whitelisted UniswapHandler, and then extract the token by abusing the add and remove liquidity function. This is considered a high severity issue because it undermine to protocol's ability to generate profit by the privileged role as designed and allow potential risk-free MEV.  ## Proof of Concept 1) User swap dai into malt and send malt directly to uniswapHandler, this is possible becuase uniswapHandler is whitelisted `swapExactTokensForTokens(amountDai, 0, [dai.address, malt.address], uniswapHandler.address, new Date().getTime() + 10000);` 2) User send matching amount of dai to uniswapHandler 3) User call addLiquidity() and get back LP token 4) User call removeLiquidity() and get back both dai and malt  ## Recommended Mitigation Steps According to documentation in https://github.com/code-423n4/2021-11-malt#high-level-overview-of-the-malt-protocol > Users wanting to remove liquidity can still do so via the UniswapHandler contract that is whitelisted in recovery mode. , this should be exploitable. Meanwhile the current implementation did not actually allow remove liquidity during recovery mode (refer to issue \"Unable to remove liquidity in Recovery Mode\") This exploit can be mitigated by disabling addLiquidity() when the protocol is in recovery mode  "}, {"title": "Unable to remove liquidity in Recovery Mode", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/323", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  gzeon   # Vulnerability details  ## Impact According to https://github.com/code-423n4/2021-11-malt#high-level-overview-of-the-malt-protocol > When the Malt price TWAP drops below a specified threshold (eg 2% below peg) then the protocol will revert any transaction that tries to remove Malt from the AMM pool (ie buying Malt or removing liquidity). Users wanting to remove liquidity can still do so via the UniswapHandler contract that is whitelisted in recovery mode.  However, in https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/DexHandlers/UniswapHandler.sol#L236 liquidity removed is directly sent to msg.sender, which would revert if it is not whitelisted https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/PoolTransferVerification.sol#L53  ## Recommended Mitigation Steps Liquidity should be removed to UniswapHandler contract, then the proceed is sent to msg.sender  "}, {"title": "Missing `maltDataLab.trackReserveRatio()` in some cases after `swingTrader.sellMalt()`", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/320", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  WatchPug   # Vulnerability details  Based on the context, `maltDataLab.trackReserveRatio()` should be called once a market buy/sell is made.  However, in `_distributeSupply()` when `swingAmount >= tradeSize`, after a market sell, the function returned without `maltDataLab.trackReserveRatio()`.  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/StabilizerNode.sol#L145-L174  ```solidity=145{168,170,172}   function stabilize() external notSameBlock {     auction.checkAuctionFinalization();      require(       block.timestamp >= stabilizeWindowEnd || _stabilityWindowOverride(),       \"Can't call stabilize\"     );     stabilizeWindowEnd = block.timestamp + stabilizeBackoffPeriod;      rewardThrottle.checkRewardUnderflow();      uint256 exchangeRate = maltDataLab.maltPriceAverage(priceAveragePeriod);      if (!_shouldAdjustSupply(exchangeRate)) {       maltDataLab.trackReserveRatio();        lastStabilize = block.timestamp;       return;     }      emit Stabilize(block.timestamp, exchangeRate);      if (exchangeRate > maltDataLab.priceTarget()) {       _distributeSupply();     } else {       _startAuction();     }      lastStabilize = block.timestamp;   } ```  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/StabilizerNode.sol#L211-L246  ```solidity=211{228-230,244}   function _distributeSupply() internal {     if (supplyDistributionController != address(0)) {       bool success = ISupplyDistributionController(supplyDistributionController).check();       if (!success) {         return;       }     }      uint256 priceTarget = maltDataLab.priceTarget();     uint256 tradeSize = dexHandler.calculateMintingTradeSize(priceTarget).div(expansionDampingFactor);      if (tradeSize == 0) {       return;     }      uint256 swingAmount = swingTrader.sellMalt(tradeSize); // @Auditor: At this time, a market operation occurred, affecting the reserveRatio      if (swingAmount >= tradeSize) {       return;     }      tradeSize = tradeSize - swingAmount;      malt.mint(address(dexHandler), tradeSize);     emit MintMalt(tradeSize);     uint256 rewards = dexHandler.sellMalt();      auctionBurnReserveSkew.addAbovePegObservation(tradeSize);      uint256 remaining = _replenishLiquidityExtension(rewards);      _distributeRewards(remaining);      maltDataLab.trackReserveRatio();     impliedCollateralService.claim();   } ```  ### Recommendation  Consider moving `maltDataLab.trackReserveRatio()` from `_distributeSupply()`, `_startAuction()` to `stabilize()` before L173.  "}, {"title": "Use short reason strings can save gas", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/317", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "Use short reason strings can save gas"}, {"title": "Redundant checks", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/316", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Bonding.sol#L114-L132  ```solidity=114 function unbondAndBreak(uint256 amount)     external   {     require(amount > 0, \"Cannot unbond 0\");      uint256 bondedBalance = balanceOfBonded(msg.sender);      require(bondedBalance > 0, \"< bonded balance\");     require(amount <= bondedBalance, \"< bonded balance\");      // Avoid leaving dust behind     if (amount.add(1e16) > bondedBalance) {       amount = bondedBalance;     }      miningService.onUnbond(msg.sender, amount);      _unbondAndBreak(amount);   } ```  L121, the check of `bondedBalance > 0` is unnecessary, since the L122 already included the same check.  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/ERC20Permit.sol#L118-L127  ```solidity=118{121-122, 124}   function transferAndCall(address to, uint value, bytes calldata data) external returns (bool) {     require(to != address(0) || to != address(this));      uint256 balance = balanceOf(msg.sender);     require(balance >= value, \"ERC20Permit: transfer amount exceeds balance\");      _transfer(msg.sender, to, value);      return ITransferReceiver(to).onTokenTransfer(msg.sender, value, data);   } ```  L121-L122, the check of `balance >= value` is unnecessary, since the L124 already included the same check.  "}, {"title": "Outdated versions of OpenZeppelin library", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/315", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-11-malt-findings", "body": "Outdated versions of OpenZeppelin library"}, {"title": "`MovingAverage.setSampleMemory()` may broke MovingAverage, making the value of `exchangeRate` in `StabilizerNode.stabilize()` being extremely wrong", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/313", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/MovingAverage.sol#L424-L442  ```solidity=424   function setSampleMemory(uint256 _sampleMemory)     external     onlyRole(ADMIN_ROLE, \"Must have admin privs\")   {     require(_sampleMemory > 0, \"Cannot have sample memroy of 0\");      if (_sampleMemory > sampleMemory) {       for (uint i = sampleMemory; i < _sampleMemory; i++) {         samples.push();       }       counter = counter % _sampleMemory;     } else {       activeSamples = _sampleMemory;        // TODO handle when list is smaller Tue 21 Sep 2021 22:29:41 BST     }      sampleMemory = _sampleMemory;   } ```  In the current implementation, when `sampleMemory` is updated, the samples index will be malposition, making `getValueWithLookback()` get the wrong samples, so that returns the wrong value.  ## PoC  -  When initial sampleMemory is `10` -  After `movingAverage.update(1e18)` being called for 120 times -  The admin calls `movingAverage.setSampleMemory(118)` and set sampleMemory to `118`  The current `movingAverage.getValueWithLookback(sampleLength * 10)` returns `0.00000203312 e18`, while it's expeceted to be `1e18`  After `setSampleMemory()`, `getValueWithLookback()` may also return `0`or revert FullMath: FULLDIV_OVERFLOW at L134.  ### Recommendation  Consider removing `setSampleMemory` function.  "}, {"title": "Checking if `lpProfitCut > 0` can save gas", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/310", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/SwingTrader.sol#L136-L141  ```solidity if (profit > 0) {     uint256 lpCut = profit.mul(lpProfitCut).div(1000);      collateralToken.safeTransfer(address(rewardThrottle), lpCut);     rewardThrottle.handleReward();   } ```  Given that `lpProfitCut` can be `0`, checking if `lpProfitCut > 0` can avoid unnecessary code execution (including external calls) and save some gas.  "}, {"title": "Checking `uint256` variables `>= 0` is redundant", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/309", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  WatchPug   # Vulnerability details  Checking `uint256` variables >= 0 is redundant as they always >= 0.  Instances include:  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/SwingTrader.sol#L169-L172  ```solidity function setLpProfitCut(uint256 _profitCut) public onlyRole(ADMIN_ROLE, \"Must have admin privs\") {     require(_profitCut >= 0 && _profitCut <= 1000, \"Must be between 0 and 100%\");     lpProfitCut = _profitCut;     } ```  `_profitCut >= 0` at L170.  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Timelock.sol#L66-L77  ```solidity function setDelay(uint256 _delay)     public     onlyRole(GOVERNOR_ROLE, \"Must have timelock role\")   {     require(       _delay >= 0 && _delay < gracePeriod,       \"Timelock::setDelay: Delay must not be greater equal to zero and less than gracePeriod\"     );     delay = _delay;      emit NewDelay(delay);   } ```  `_delay >= 0` at L71.  "}, {"title": "`MovingAverage.sol#_getFirstSample()` Implementation can be simpler and save some gas", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/308", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-11-malt-findings", "body": "`MovingAverage.sol#_getFirstSample()` Implementation can be simpler and save some gas"}, {"title": "Only use `SafeMath` when necessary can save gas", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/307", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  WatchPug   # Vulnerability details  For the arithmetic operations that will never over/underflow, using SafeMath will cost more gas.  For example:  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L238-L242  ```solidity=238     if (amountTokens > unclaimedArbTokens) {       unclaimedArbTokens = 0;     } else {       unclaimedArbTokens = unclaimedArbTokens.sub(amountTokens);     } ```  `unclaimedArbTokens - amountTokens` will never underflow.  ### Recommendation  Change to:  ```solidity=238     if (amountTokens >= unclaimedArbTokens) {       unclaimedArbTokens = 0;     } else {       unclaimedArbTokens -= amountTokens;     } ```    https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionBurnReserveSkew.sol#L76-L80  ```solidity=76 if (premiumExcess > maxBurnSpend) {   return premiumExcess; }  uint256 usableExcess = maxBurnSpend.sub(premiumExcess); ```  `maxBurnSpend - premiumExcess` will never underflow.  ### Recommendation  Change to:  ```solidity=76 if (premiumExcess > maxBurnSpend) {   return premiumExcess; }  uint256 usableExcess = maxBurnSpend - premiumExcess; ```  "}, {"title": "`AuctionBurnReserveSkew.sol#getRealBurnBudget()` Implementation can be simpler and save some gas", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/306", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionBurnReserveSkew.sol#L69-L89  ```solidity=69{76,82-84}   function getRealBurnBudget(     uint256 maxBurnSpend,     uint256 premiumExcess   ) public view returns(uint256) {     // Returning maxBurnSpend = maximum supply burn with no reserve ratio improvement     // Returning premiumExcess = maximum reserve ratio improvement with no real supply burn      if (premiumExcess > maxBurnSpend) {       return premiumExcess;     }      uint256 usableExcess = maxBurnSpend.sub(premiumExcess);      if (usableExcess == 0) {       return premiumExcess;     }      uint256 burnable = consult(usableExcess);      return premiumExcess + burnable;   } ```  L82-84 `if (maxBurnSpend == premiumExcess)` can be combined with L76-78.  ### Recommendation  Change to:  ```solidity=69{76}   function getRealBurnBudget(     uint256 maxBurnSpend,     uint256 premiumExcess   ) public view returns(uint256) {     // Returning maxBurnSpend = maximum supply burn with no reserve ratio improvement     // Returning premiumExcess = maximum reserve ratio improvement with no real supply burn      if (premiumExcess >= maxBurnSpend) {       return premiumExcess;     }      uint256 usableExcess = maxBurnSpend.sub(premiumExcess);      uint256 burnable = consult(usableExcess);      return premiumExcess + burnable;   } ```  "}, {"title": "Users may lose a small portion of promised returns due to precision loss", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/305", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionEscapeHatch.sol#L131-L140  ```solidity=131     uint256 progressionBps = (block.timestamp - auctionEndTime) * 10000 / cooloffPeriod;     if (progressionBps > 10000) {         progressionBps = 10000;     }      if (fullReturn > amount) {         // Allow a % of profit to be realised         uint256 maxProfit = (fullReturn - amount) * (maxEarlyExitBps * progressionBps / 10000) / 1000;         return amount + maxProfit;     } ```  If we assume that `maxEarlyExitBps` is 200 and `cooloffPeriod` is 1 day, when `progressionBps` less than 50, `(maxEarlyExitBps * progressionBps / 10000)` will be 0 due to precision loss, which resulted in `maxProfit` is 0.  When `maxEarlyExitBps` is set smaller, the margin of error will be even larger.  # POC  Given:  - Current price of arb token is 0.8 DAI  1. Alice calls `purchaseArbitrageTokens()` and purchase with 8,000 DAI; 2. 7 mins later, the market price of MALT become 0.9 DAI; Alice calls `exitEarly()`, it will mint 8,888.88 Malt and receive 8,000 DAI, while it's expected to 8,890 MALT and 8,000.96 DAI.  ### Recommendation  Change to:  ```solidity if (fullReturn > amount) {     // Allow a % of profit to be realised     uint256 maxProfit = (fullReturn - amount) * (maxEarlyExitBps * 1000 * progressionBps / 10000) / 1000 / 1000;     return amount + maxProfit; } ```  "}, {"title": "Returning the named returns is redundant", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/304", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-11-malt-findings", "body": "Returning the named returns is redundant"}, {"title": "Misleading variable names", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/302", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-11-malt-findings", "body": "Misleading variable names"}, {"title": "`AuctionBurnReserveSkew.sol#getPegDeltaFrequency()` Implementation can be simpler and save some gas", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/301", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionBurnReserveSkew.sol#L116-L132  ```solidity=116   function getPegDeltaFrequency() public view returns (uint256) {     uint256 initialIndex = 0;     uint256 index;      if (count > auctionAverageLookback) {       initialIndex = count - auctionAverageLookback;     }      uint256 total = 0;      for (uint256 i = initialIndex; i < count; ++i) {       index = _getIndexOfObservation(i);       total = total + pegObservations[index];     }      return total * 10000 / auctionAverageLookback;   } ```  ### Recommendation  Change to:  ```solidity=116   function getPegDeltaFrequency() public view returns (uint256) {     uint256 availablePegObservationsCount;     {       uint256 auctionAverageLookback_ = auctionAverageLookback;       uint256 count_ = count;       availablePegObservationsCount = count_ > auctionAverageLookback_ ? auctionAverageLookback_ : count_;     }      uint256 total = 0;     for (uint256 i = 0; i < availablePegObservationsCount; ++i) {       total += pegObservations[i];     }     return total * 10000 / availablePegObservationsCount;   } ```  "}, {"title": "Cache external call results can save gas", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/300", "labels": ["bug", "duplicate", "G (Gas Optimization)"], "target": "2021-11-malt-findings", "body": "Cache external call results can save gas"}, {"title": "Unnecessary internal function calls", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/296", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-11-malt-findings", "body": "Unnecessary internal function calls"}, {"title": "`++i` is more gas efficient than `i++`", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/295", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  WatchPug   # Vulnerability details  Using `++i` is more gas efficient than `i++`, especially in a loop.  For example:  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionBurnReserveSkew.sol#L54-L56 ```solidity=54 for (uint i = 0; i < _period; i++) {   pegObservations.push(0); } ```  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionBurnReserveSkew.sol#L193-L195 ```solidity=193 for (uint i = auctionAverageLookback; i < _lookback; i++) {   pegObservations.push(0); } ```  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/MovingAverage.sol#L60-L62 ```solidity=60 for (uint i = 0; i < sampleMemory; i++) {   samples.push(); } ```  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/MovingAverage.sol#L187-L195  ```solidity=187 for (uint256 i = 0; i < sampleMemory; i++ ) {   tempCount += 1;   liveSample = samples[_getIndexOfSample(tempCount)];   liveSample.timestamp = currentTimestamp;   liveSample.cumulativeValue = currentCumulative;    currentCumulative += addition;   currentTimestamp += uint64(sampleLength); } ```  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/MovingAverage.sol#L292-L300 ```solidity=292 for (uint256 i = 0; i < sampleMemory; i++ ) {   tempCount += 1;   liveSample = samples[_getIndexOfSample(tempCount)];   liveSample.timestamp = currentTimestamp;   liveSample.cumulativeValue = currentCumulative;    currentCumulative += addition;   currentTimestamp += uint64(sampleLength); } ```  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/MovingAverage.sol#L431-L433 ```solidity=431 for (uint i = sampleMemory; i < _sampleMemory; i++) {   samples.push(); } ```  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/libraries/UniswapV2Library.sol#L66-L69 ```solidity=66 for (uint i; i < path.length - 1; i++) {     (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]);     amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut); } ```  "}, {"title": "`AuctionBurnReserveSkew.getPegDeltaFrequency()` Wrong implementation can result in an improper amount of excess Liquidity Extension balance to be used at the end of an auction ", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/294", "labels": ["bug", "3 (High Risk)", "disagree with severity", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionBurnReserveSkew.sol#L116-L132  ```solidity=116{131}   function getPegDeltaFrequency() public view returns (uint256) {     uint256 initialIndex = 0;     uint256 index;      if (count > auctionAverageLookback) {       initialIndex = count - auctionAverageLookback;     }      uint256 total = 0;      for (uint256 i = initialIndex; i < count; ++i) {       index = _getIndexOfObservation(i);       total = total + pegObservations[index];     }      return total * 10000 / auctionAverageLookback;   } ```  When `count < auctionAverageLookback`, at L131, it should be `return total * 10000 / count;`. The current implementation will return a smaller value than expected.  The result of `getPegDeltaFrequency()` will be used for calculating `realBurnBudget` for auctions. With the result of `getPegDeltaFrequency()` being inaccurate, can result in an improper amount of excess Liquidity Extension balance to be used at the end of an auction.  "}, {"title": "`StabilizerNode.sol` The current implementation is misconfiguration-prone for rewardToken with non-18 decimals", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/293", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  WatchPug   # Vulnerability details  The default `upperStabilityThreshold` and `lowerStabilityThreshold` assumes that `rewardToken.decimals()` is 18.  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/StabilizerNode.sol#L32-L33  ```solidity=32   uint256 public upperStabilityThreshold = (10**18) / 100; // 1%   uint256 public lowerStabilityThreshold = (10**18) / 100; ```  When the `StabilizerNode.sol` contract is initialized with a rewardToken with decimals of 8 (eg. USDC). `upperThreshold` and `lowerThreshold` will be much larger than expected.  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/StabilizerNode.sol#L198-L206 ```solidity   function _shouldAdjustSupply(uint256 exchangeRate) internal view returns (bool) {     uint256 decimals = rewardToken.decimals();     uint256 priceTarget = maltDataLab.priceTarget();      uint256 upperThreshold = priceTarget.mul(upperStabilityThreshold).div(10**decimals);     uint256 lowerThreshold = priceTarget.mul(lowerStabilityThreshold).div(10**decimals); ```  ### Recommendation  Consider changing to:  ```solidity   uint256 public upperStabilityThresholdBps = 100; // 1%   uint256 public lowerStabilityThresholdBps = 100; ```  ```solidity   function _shouldAdjustSupply(uint256 exchangeRate) internal view returns (bool) {     uint256 decimals = rewardToken.decimals();     uint256 priceTarget = maltDataLab.priceTarget();      uint256 upperThreshold = priceTarget.mul(upperStabilityThreshold).div(10000);     uint256 lowerThreshold = priceTarget.mul(lowerStabilityThreshold).div(10000); ```  "}, {"title": "The value of `reward` parameter of the `ProvideReinvest` event can be wrong", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/292", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/RewardReinvestor.sol#L62-L76  ```solidity=62 function provideReinvest(uint256 rewardLiquidity) external {     _retrieveReward(rewardLiquidity);      uint256 rewardBalance = rewardToken.balanceOf(address(this));      // This is how much malt is required     uint256 maltLiquidity = dexHandler.getOptimalLiquidity(address(malt), address(rewardToken), rewardBalance);      // Transfer the remaining Malt required     malt.safeTransferFrom(msg.sender, address(this), maltLiquidity);      _bondAccount(msg.sender);      emit ProvideReinvest(msg.sender, rewardLiquidity);   } ```  `_retrieveReward` will call `MiningService.sol#withdrawRewardsForAccount()` which uses `amount` as max withdrawnAmount, if there are no enough rewards, the actual rewarded amount will be less than `amount`.  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/MiningService.sol#L155-L179  ```solidity=155 function withdrawRewardsForAccount(address account, uint256 amount)     public     onlyRole(REINVESTOR_ROLE, \"Must have reinvestor privs\")   {     _withdrawMultiple(account, amount);   }    /*    * INTERNAL FUNCTIONS    */   function _withdrawMultiple(address account, uint256 amount) internal {     for (uint i = 0; i < mines.length; i = i + 1) {       if (!mineActive[mines[i]]) {         continue;       }        uint256 withdrawnAmount = IRewardMine(mines[i]).withdrawForAccount(account, amount, msg.sender);        amount = amount.sub(withdrawnAmount);        if (amount == 0) {         break;       }     }   } ```  ### Recommendation  Consider using `rewardBalance` as the value of the `reward` parameter.  "}, {"title": "Permissions.sol#_swapRole is named wrongly", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/290", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor acknowledged"], "target": "2021-11-malt-findings", "body": "Permissions.sol#_swapRole is named wrongly"}, {"title": "Custom size uint is not more efficient than uint256", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/289", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  0x0x0x   # Vulnerability details  ## Concept  In `MovingAverage.sol`, `uint64` is used for computation of time etc. But computations with `uint64` does cost more gas and furthermore `block.timestamp` is `uint256`, which is additionally casted to `uint64`. `uint32` is used for indexes, but this can also be changed with `uint256`.  Same applies for `RewardDistributer.sol.`  ## Recommendation  Use `uint256` rather than custom `uint`.  "}, {"title": "Dont calculate progressionBps, when not needed", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/288", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  0x0x0x   # Vulnerability details  ## Concept  [https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionEscapeHatch.sol#L200-L212](https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionEscapeHatch.sol#L200-L212):  ```   uint256 progressionBps = (block.timestamp - auctionEndTime) * 10000 / cooloffPeriod;     if (progressionBps > 10000) {       progressionBps = 10000;     }      if (fullReturn > amount) {       // Allow a % of profit to be realised       uint256 maxProfit = (fullReturn - amount) * (maxEarlyExitBps * progressionBps / 10000) / 1000;       uint256 desiredReturn = amount + maxProfit;       maltQuantity = desiredReturn.mul(pegPrice) / currentPrice;     }       return maltQuantity; ```  `progressionBps` is only used, if there is a profit. Calculations of this parameter should be under if statement checking whether there is a profit to save gas and increase readability as follows:  ```      if (fullReturn > amount) {       // Allow a % of profit to be realised    uint256 progressionBps = (block.timestamp - auctionEndTime) * 10000 / cooloffPeriod;      if (progressionBps > 10000) {        progressionBps = 10000;      }       uint256 maxProfit = (fullReturn - amount) * (maxEarlyExitBps * progressionBps / 10000) / 1000;       uint256 desiredReturn = amount + maxProfit;       maltQuantity = desiredReturn.mul(pegPrice) / currentPrice;     }       return maltQuantity; ```  "}, {"title": "Unused storage variables", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/287", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "Unused storage variables"}, {"title": "Misleading error message", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/286", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "Misleading error message"}, {"title": "AbstractRewardMine.sol#setRewardToken is dangerous", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/285", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  0x0x0x   # Vulnerability details  ## Impact  In case the reward token is changed, `totalDeclaredReward` will be changed and likely equal to `0`.  Since `_userStakePadding` and `_globalStakePadding` are accumulated, changing the reward token will not reset those values. Thus, it will create problems.  ## Recommendation  I think it would be the best to remove this function.   If you want to keep it, then it must have an event and it should be used by a timelock contract. Furthermore, it has to be used carefully and the new token should be distributed such that padding variables still make sense.  "}, {"title": "AbstractRewardMine.sol#_removeFromStakePadding can be implemented more efficiently", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/284", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-11-malt-findings", "body": "AbstractRewardMine.sol#_removeFromStakePadding can be implemented more efficiently"}, {"title": "Use immutable variable can save gas", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/280", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-malt-findings", "body": "Use immutable variable can save gas"}, {"title": "Race condition on ERC20 approval", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/276", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "Race condition on ERC20 approval"}, {"title": "`uint64(block.timestamp % 2**64)` can be simpler and save some gas", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/273", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/MovingAverage.sol#L154-L154  ```solidity=154 uint64 blockTimestamp = uint64(block.timestamp % 2**64);  ```  Use `uint64(n)` can cut off higher-order bits already, `n % 2**64` is redundant.  See: https://docs.soliditylang.org/en/v0.8.10/types.html#explicit-conversions  ### Recommendation  Change to:  ```solidity=154 uint64 blockTimestamp = uint64(block.timestamp);  ```  "}, {"title": "For uint `> 0` can be replaced with ` != 0` for gas optimisation", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/271", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "For uint `> 0` can be replaced with ` != 0` for gas optimisation"}, {"title": "`MovingAverage.sol` Use inline expression can save gas", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/269", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/MovingAverage.sol#L356-L360  ```solidity=356   function _getCurrentSample() private view returns (Sample storage currentSample) {     // Active sample is always counter - 1. Counter is the in progress sample     uint32 currentSampleIndex = _getIndexOfSample(counter - 1);     currentSample = samples[currentSampleIndex];   } ```  The local variable `currentSampleIndex` is used only once. Making the expression inline can save gas.  Similar issue exists in `_getFirstSample()`, `_getNthSample()`, `AuctionBurnReserveSkew.sol#getRealBurnBudget()`, `MovingAverage.sol#_getFirstSample()`.  ### Recommendation  Change to:  ```solidity=356   function _getCurrentSample() private view returns (Sample storage currentSample) {     // Active sample is always counter - 1. Counter is the in progress sample     currentSample = samples[_getIndexOfSample(counter - 1)];   } ```  "}, {"title": "AuctionEschapeHatch.sol#exitEarly updates state of the auction wrongly", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/268", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  0x0x0x   # Vulnerability details  ## Vulnerability  `AuctionEschapeHatch.sol#exitEarly` takes as input `amount` to represent how much of the   When the user exits an auction with profit, to apply the profit penalty less `maltQuantity` is liquidated compared to how much malt token the liquidated amount corresponds to. The problem is `auction.amendAccountParticipation()` simply subtracts the malt quantity with penalty and full `amount` from users auction stats. This causes a major problem, since in `_calculateMaltRequiredForExit` those values are used for calculation by calculating maltQuantity as follow:  `uint256 maltQuantity = userMaltPurchased.mul(amount).div(userCommitment);`   The ratio of `userMaltPurchased / userCommitment` gets higher after each profit taking (since penalty is applied to substracted `maltQuantity` from `userMaltPurchased`), by doing so a user can earn more than it should. Since after each profit taking users commitment corresponds to proportionally more malt, the user can even reduce profit penalties by dividing `exitEarly` calls in several calls.  In other words, the ratio of `userMaltPurchased / userCommitment` gets higher after each profit taking and user can claim more malt with less commitment. Furthermore after all `userMaltPurchased` is claimed the user can have `userCommitment` left over, which can be used to `claimArbitrage`, when possible.  ## Mitigation Step  Make sure which values are used for what and update values which doesn't create problems like this. Rethink about how to track values of an auction correctly.  "}, {"title": "Code Style: private/internal function names should be prefixed with `_`", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/265", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "Code Style: private/internal function names should be prefixed with `_`"}, {"title": "Timelock can be bypassed", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/263", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  WatchPug   # Vulnerability details  The purpose of a Timelock contract is to put a limit on the privileges of the `governor`, by forcing a two step process with a preset delay time.  However, we found that the current implementation actually won't serve that purpose as it allows the `governor` to execute any transactions without any constraints.  To do that, the current governor can call `Timelock#setGovernor(address _governor)` and set a new `governor` effective immediately.  And the new `governor` can then call `Timelock#setDelay()` and change the delay to `0`, also effective immediately.  The new `governor` can now use all the privileges without a delay, including granting minter role to any address and mint unlimited amount of MALT.  In conclusion, a Timelock contract is supposed to guard the protocol from lost private key or malicious actions. The current implementation won't fulfill that mission.  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Timelock.sol#L98-L105 ```solidity=98{100,102-103}   function setGovernor(address _governor)     public     onlyRole(GOVERNOR_ROLE, \"Must have timelock role\")   {     _swapRole(_governor, governor, GOVERNOR_ROLE);     governor = _governor;     emit NewGovernor(_governor);   } ```  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Timelock.sol#L66-L77 ```solidity=66{71,74}   function setDelay(uint256 _delay)     public     onlyRole(GOVERNOR_ROLE, \"Must have timelock role\")   {     require(       _delay >= 0 && _delay < gracePeriod,       \"Timelock::setDelay: Delay must not be greater equal to zero and less than gracePeriod\"     );     delay = _delay;      emit NewDelay(delay);   } ```   ## Recommendation  Consider making `setGovernor` and `setDelay` only callable from the Timelock contract itself.  Specificaly, changing from `onlyRole(GOVERNOR_ROLE, \"Must have timelock role\")` to `require(msg.sender == address(this), \"...\")`.  Also, consider changing `_adminSetup(_admin)` in `Timelock#initialize()` to `_adminSetup(address(this))`, so that all roles are managed by the timelock itself as well.  "}, {"title": "Remove liquidity never ends up with left-over LP tokens", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/259", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-11-malt-findings", "body": "Remove liquidity never ends up with left-over LP tokens"}, {"title": "Wrong comment in `removeLiquidity`", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/258", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-11-malt-findings", "body": "Wrong comment in `removeLiquidity`"}, {"title": "Slippage checks when adding liquidity are too strict", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/257", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  cmichel   # Vulnerability details  When adding liquidity through `UniswapHandler.addLiquidity`, the entire contract balances are used to add liquidity and the min amounts are set to 95% of these balances. If the balances in this contract are unbalanced (the ratio is not similar to the current Uniswap pool reserve ratios) then this function will revert and no liquidity is added.  See `UniswapHandler.buyMalt`:  ```solidity (maltUsed, rewardUsed, liquidityCreated) = router.addLiquidity(   address(malt),   address(rewardToken),   maltBalance, // @audit-info amountADesired   rewardBalance,   // @audit assumes that whatever is in this contract is already balanced. good assumption?   maltBalance.mul(95).div(100), // @audit-info amountAMin   rewardBalance.mul(95).div(100),   msg.sender, // transfer LP tokens to sender   now ); ```  ## Impact If the contract has unbalanced balances, then the `router.addLiquidity` call will revert. Note that an attacker could even send tokens to this contract to make them unbalanced and revert, resulting in a griefing attack.  ## Recommended Mitigation Steps It needs to be ensured that the balances in the contract are always balanced and match the current reserve ratio. It might be better to avoid directly using the balances which can be manipulated by transferring tokens to the contract and accepting parameters instead of how many tokens to provide liquidity with from the caller side.  "}, {"title": "`UniswapHandler.maltMarketPrice` returns wrong decimals", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/255", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  cmichel   # Vulnerability details  The `UniswapHandler.maltMarketPrice` function returns a tuple of the `price` and the `decimals` of the price. However, the returned `decimals` do not match the computed `price` for the `else if (rewardDecimals < maltDecimals)` branch:  ```solidity else if (rewardDecimals < maltDecimals) {   uint256 diff = maltDecimals - rewardDecimals;   price = (rewardReserves.mul(10**diff)).mul(10**rewardDecimals).div(maltReserves);   decimals = maltDecimals; } ```  Note that `rewardReserves` are in reward token decimals, `maltReserves` is a malt balance amount (18 decimals). Then, the returned amount is in `rewardDecimals + diffDecimals + rewardDecimals - maltDecimals = maltDecimals + rewardDecimals - maltDecimals = rewardDecimals`. However `decimals = maltDecimals` is wrongly returned.  ## Impact Callers to this function will receive a price in unexpected decimals and might inflate or deflate the actual amount. Luckily, the `AuctionEscapeHatch` decides to completely ignore the returned `decimals` and as all prices are effectively in `rewardDecimals`, even if stated in `maltDecimals`, it currently does not seem to lead to an issue.  ## Recommendation Fix the function by returning `rewardDecimals` instead of `maltDecimals` in the `rewardDecimals < maltDecimals` branch.  "}, {"title": "`splitReinvest` does not provide liquidity at optimal ratio", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/253", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-11-malt-findings", "body": "`splitReinvest` does not provide liquidity at optimal ratio"}, {"title": "`_getFirstSample` returns wrong sample if count < sampleMemory", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/252", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  cmichel   # Vulnerability details  The `MovingAverage.sol` contract defines several variables that in the end make the `samples` array act as a ring buffer: - `sampleMemory`: The total length (buffer size) of the `samples` array. `samples` is initialized with `sampleMemory` zero observations. - `counter`: The pending sample index (modulo `sampleMemory`)  The `_getFirstSample` function computes the first sample as `(counter + 1) % sampleMemory` which returns the correct index only _if the ring buffer is full_, i.e., it wraps around. (in the `counter + 1 >= sampleMemory`).  If the `samples` array does not wrap around yet, the zero index should be returned instead.  ## Impact Returning `counter + 1` if `counter + 1 < sampleMemory` returns a zero initialized `samples` observation index. This then leads to a wrong computation of the TWAP.  ## Recommended Mitigation Steps Add an additional check for `if (counter + 1 < sampleMemory) return 0` in `_getFirstSample`.  "}, {"title": "Bonding doesn't work with fee-on transfer tokens", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/251", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  cmichel   # Vulnerability details  Certain ERC20 tokens make modifications to their ERC20's `transfer` or `balanceOf` functions. One type of these tokens is deflationary tokens that charge a certain fee for every `transfer()` or `transferFrom()`.  ## Impact The `Bonding._bond()` function will revert in the `_balanceCheck` when transferring a fee-on-transfer token as it assumes the entire `amount` was received.  ## Recommended Mitigation Steps To support fee-on-transfer tokens, measure the asset change right before and after the asset-transferring calls and use the difference as the actual bonded amount.  "}, {"title": "Wrong permissions on `reassignGlobalAdmin`", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/250", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  cmichel   # Vulnerability details  The `Permissions.reassignGlobalAdmin` function is supposed to only be run with the `TIMELOCK_ROLE` role, see `onlyRole(TIMELOCK_ROLE, \"Only timelock can assign roles\")`.  However, the `TIMELOCK_ROLE` is not the admin of all the reassigned roles and the `revokeRole(role, oldAccount)` calls will fail as it requires the `ADMIN_ROLE`.  ## Recommended Mitigation Steps The idea might have been that only the `TIMELOCK` should be able to call this function, and usually it is also an admin, but the function strictly does not work if the caller _only_ has the `TIMELOCK` roll and will revert in this case. Maybe governance decided to remove the admin role from the Timelock, which makes it impossible to call `reassignGlobalAdmin` anymore as both the timelock and admin are locked out.  "}, {"title": "Initial `SetTransferService` event not emitted", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/249", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  cmichel   # Vulnerability details  The initial `SetTransferService` event in `Malt.initialize` is not emitted.  ## Impact Off-chain programs might not correctly track the initial `transferService` variable as the initial event is missing.  ## Recommended Mitigation Steps Emit it in `initialize`.  "}, {"title": "`approve` return values not checked & unsafe", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/247", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  cmichel   # Vulnerability details  The `ERC20.approve()` function returns a boolean value indicating success. This parameter needs to be checked for success. Some tokens do **not** revert if the transfer failed but return `false` instead.  In addition, some tokens (like [USDT L199](https://etherscan.io/address/0xdac17f958d2ee523a2206206994597c13d831ec7#code)) do not work when changing the allowance from an existing non-zero allowance value. They must first be approved by zero and then the actual allowance must be approved.  ```solidity IERC20(token).safeApprove(address(operator), 0); IERC20(token).safeApprove(address(operator), amount); ```  This issue exists for example in `AuctionParticipant.purchaseArbitrageTokens`:  ```solidity auctionRewardToken.approve(address(auction), balance); ```  As well as in `UniswapHandler.buyMalt`:  ```solidity rewardToken.approve(address(router), rewardBalance); ```  ## Impact Tokens that don't correctly implement the latest EIP20 spec, by either returning `false` on failure or reverting if approved from a non-zero value, will be unusable in the protocol as they revert the transaction because of the missing return value.  ## Recommended Mitigation Steps We recommend using OpenZeppelin\u2019s `SafeERC20` versions with the `safeApprove(0)` functions that handle the return value check as well as non-standard-compliant tokens.  "}, {"title": "`totalDeclaredReward >= totalReleasedReward` not true in `AbstractRewardMine`", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/246", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-11-malt-findings", "body": "`totalDeclaredReward >= totalReleasedReward` not true in `AbstractRewardMine`"}, {"title": "`initialize` functions can be frontrun", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/245", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "`initialize` functions can be frontrun"}, {"title": "Implementations should inherit their interface", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/242", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "Implementations should inherit their interface"}, {"title": "Missing Overflow Protection On the DeployedCapital", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/238", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-11-malt-findings", "body": "Missing Overflow Protection On the DeployedCapital"}, {"title": "Auction.sol amendAccountParticipation has no zero division check", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/235", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "sponsor acknowledged"], "target": "2021-11-malt-findings", "body": "Auction.sol amendAccountParticipation has no zero division check"}, {"title": "Bonding.sol _unbondAndBreak does not account for edge case where no tokens are returned", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/234", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  harleythedog   # Vulnerability details  ## Impact In Bonding.sol, the internal function `_unbondAndBreak` transfers a user's stake tokens to the dexHandler and then calls `removeLiquidity` on the dexHandler. Within the Uniswap handler (which is the only handler so far) `removeLiquidity` takes special care in the edge case where `router.removeLiquidity` returns zero tokens. Specifically, the Uniswap handler has this code: ``` if (amountMalt == 0 || amountReward == 0) {  liquidityBalance = lpToken.balanceOf(address(this));  lpToken.safeTransfer(msg.sender, liquidityBalance);  return (amountMalt, amountReward); } ```  If this edge case does indeed happen (i.e. if something is preventing the Uniswap router from removing liquidity at the moment), then the Uniswap handler will transfer the LP tokens back to Bonding.sol. However, Bonding.sol does not have any logic to recognize that this happened, so the LP tokens will become stuck in the contract and the user will never get any of their value back. This could be very bad if the user unbonds a lot of LP and they don't get any of it back.  ## Proof of Concept See `_unbondAndBreak` here: https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Bonding.sol#L226  Notice how the edge case where `amountMalt == 0 || amountReward == 0` is not considered in this function, but it is considered in the Uniswap handler's `removeLiquidity` here: https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/DexHandlers/UniswapHandler.sol#L240  ## Tools Used Inspection.  ## Recommended Mitigation Steps Add a similar edge case check to `_unbondAndBreak`. In the case where LP tokens are transferred back to Bonding.sol instead of malt/reward, these LP tokens should be forwarded back to the user since the value is rightfully theirs.  "}, {"title": "`permit` Double Emits An `Approval` Event", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/230", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  leastwood   # Vulnerability details  ## Impact  The `permit` function is intended to facilitate approvals though signature verification. This helps to merge the two-step token transfer process consisting of an initial token approval and subsequent transfer. The `permit` function emits an `Approval` event, however, the `_approve` function also emits the same `Approval` event. As a result, off-chain scripts monitoring the blockchain for such events will see the same event emitted twice which may cause unintended issues.  ## Proof of Concept  https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/ERC20Permit.sol#L58-L59 https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol#L314  ## Tools Used  Manual code review  ## Recommended Mitigation Steps  Consider not emitting an `Approval` event in `permit`.  "}, {"title": "`_distributeRewards` Does Not Reset Approval If Not All Tokens Were Allocated", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/229", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  leastwood   # Vulnerability details  ## Impact  `_distributeRewards` attempts to reward LP token holders when the price of Malt exceeds its price target. Malt Finance is able to being Malt back to its peg by selling Malt and distributing rewards tokens to LP token holders. An external call to `Auction` is made via the `allocateArbRewards` function. Prior to this call, the `StabilizerNode` approves the contract for a fixed amount of tokens, however, the `allocateArbRewards` function does not necessarily utilise this entire amount. Hence, dust token approval amounts may accrue from within the `StabilizerNode` contract.  ## Proof of Concept  https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/StabilizerNode.sol#L252-L253 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L809-L871  ## Tools Used  Manual code review  ## Recommended Mitigation Steps  Consider resetting the approval amount if the input `rewarded` amount to `allocateArbRewards` is less than the output amount.  "}, {"title": "`addLiquidity` Does Not Reset Approval If Not All Tokens Were Added To Liquidity Pool", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/228", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  leastwood   # Vulnerability details  ## Impact  `addLiquidity` is called when users reinvest their tokens through bonding events. The `RewardReinvestor` first transfers Malt and rewards tokens before adding liquidity to the token pool. `addLiquidity` provides protections against slippage by a margin of 5%, and any dust token amounts are transferred back to the caller. In this instance, the caller is the `RewardReinvestor` contract which further distributes the dust token amounts to the protocol's treasury. However, the token approval for this outcome is not handled properly. Dust approval amounts can accrue over time, leading to large Uniswap approval amounts by the `UniswapHandler` contract.  ## Proof of Concept  https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L212-L214 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L216-L218  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider resetting the approval amount if either `maltUsed < maltBalance` or `rewardUsed < rewardBalance` in `addLiquidity`.  "}, {"title": "Auction collateralToken won't work if token is fee-on-transfer token ", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/227", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  harleythedog   # Vulnerability details  ## Impact There are several ERC20 tokens that take a small fee on transfers/transferFroms (known as \"fee-on-transfer\" tokens). Most notably, USDT is an ERC20 token that has togglable transfer fees, but for now the fee is set to 0 (see the contract here: https://etherscan.io/address/0xdAC17F958D2ee523a2206206994597C13D831ec7#code). For these tokens, it should not be assumed that if you transfer `x` tokens to an address, that the address actually receives `x` tokens. In the current test environment, DAI is the only `collateralToken` available, so there are no issues. However, it has been noted that more pools will be added in the future, so special care will need to be taken if fee-on-transfer tokens (like USDT) are planned to be used as `collateralTokens`.  For example, consider the function `purchaseArbitrageTokens` in Auction.sol. This function transfers `realCommitment` amount of `collateralToken` to the liquidityExtension, and then calls `purchaseAndBurn(realCommitment)` on the liquidityExtension. The very first line of `purchaseAndBurn(amount)` is `require(collateralToken.balanceOf(address(this)) >= amount, \"Insufficient balance\");`. In the case of fee-on-transfer tokens, this line will revert due to the small fee taken. This means that all calls to `purchaseArbitrageTokens` will fail, which would be very bad when the price goes below peg, since no one would be able to participate in this auction.  ## Proof of Concept See `purchaseArbitrageTokens` here: https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L177  See `purchaseAndBurn` here: https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/LiquidityExtension.sol#L117  ## Tools Used Inspection  ## Recommended Mitigation Steps Add logic to transfers/transferFroms to calculate exactly how many tokens were actually sent to a specific address. In the example given with `purchaseArbitrageTokens`, instead of calling `purchaseAndBurn` with `realCommitment`, the contract should use the difference in the liquidityExtension balance after the transfer minus the liquidityExtension  balance before the transfer.  "}, {"title": "Frontrunning in UniswapHandler calls to UniswapV2Router", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/219", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  thank_you   # Vulnerability details  ## Impact UniswapHandler utilizes UniswapV2Router to swap, add liquidity, and remove liquidity with the UniswapV2Pair contract. In order to utilize these functionalities, UniswapHandler must call various UniswapV2Router methods.  - addLiquidity - removeLiquidity - swapExactTokensForTokens (swaps for both DAI and Malt)  In all three methods, UniswapV2Router requires the callee to provide input arguments that define how much the amount out minimum UniswapHandler will allow for a trade. This argument is designed to prevent slippage and more importantly, sandwich attacks.  UniswapHandler correctly handles price slippage when calling [addLiquidity](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L201). However, that is not the case for [removeLiquidity](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L230) and swapExactTokensForTokens [here](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L148) and [here](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L173). For both methods, 0 is passed in as the amount out minimum allowed for a trade. This allows for anyone watching the mempool to sandwich attack UniswapHandler (or any contract that calls UniswapHandler) in such a way that allows the hacker to profit off of a guaranteed trade.  How does this work? Let's assume UniswapHandler makes a call to [UniswapV2Router#swapExactTokensForTokens](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L148) to trade DAI for Malt. Any hacker who watches the mempool and sees this transaction can immediately buy as much Malt as they want. This raises the price of Malt. Since UniswapHandler is willing to accept any amount out minimum (the number is set to [zero](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L150)), then the UniswapHandler will always trade DAI for Malt. This second transaction raises the price of Malt even further. Finally, the hacker trades their Malt for DAI, receiving a profit due to the artificially inflated price of Malt from the sandwich attack.  It's important to note that anyone has access to the UniswapV2Router contract. There are no known ACL controls on UniswapV2Router. This sandwich attack can impact even the `buyMalt` function.  The following functions when called are vulnerable to frontrunning attacks:  - [UniswapHandler#buyMalt](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L131) - [UniswapHandler#sellMalt](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L160) - [UniswapHandler#removeLiquidity](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L221)  And by extension the following contract functions since they also call the UniswapHandler function calls:  - [Bonding#unbondAndBreak](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Bonding.sol#L114) - [LiquidityExtension#purchaseAndBurn](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/LiquidityExtension.sol#L117) - [RewardReinvestor#splitReinvest](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/RewardReinvestor.sol#L78) - [StabilizerNode#stabilize](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/StabilizerNode.sol#L145) - [SwingTrader#buyMalt](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/SwingTrader.sol#L50)   ## Proof of Concept Refer to the impact section for affected code and links to the appropriate LoC.  ## Tools Used N/A  ## Recommended Mitigation Steps The UniswapV2Router and UniswapV2Pair contract should allow only the UniswapHandler contract to call either contract. In addition, price slippage checks should be implemented whenever removing liquidity or swapping tokens. This ensures that a frontrunning attack can't occur.   ## Anything Else We Should Know I wish I had more time to work on this bug but unfortunately I have several current clients who require significant time from me. I'm happy to pursue this beyond the initial submission, in particular building a concrete PoC. I think the most important takeaway from this bug find is that anyone can purchase Malt at any time and anyone can manipulate the Malt reserve. This in turn impacts other functionalities that rely on the Malt reserve to make price/token calculations such as exiting an auction early or reinvesting rewards.  "}, {"title": "Missing zero address check which will put forfeited rewards at risk(ForefeitHandler.sol) ", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/216", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  0xwags   # Vulnerability details  ## Impact Since users forfeited awards will be shared between either the treasury and the swing trader, there should be a zero address in the initialize() function to ensure rewards are not lost and thereby affecting  Malt's collateralisation and other such funding mechanism.   This will have implications for safetransfer() functions in lines 50 & 54 in handleForfeit().   ## Tools Used Manual Analysis.   ## Recommended Mitigation Steps  require(treasuryMultisig&& swingTrader ! =address(0), \"0x0\");  "}, {"title": "`_calculateMaltRequiredForExit` Uses Spot Price To Calculate Malt Quantity In `exitEarly`", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/215", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  leastwood   # Vulnerability details  ## Impact  `_calculateMaltRequiredForExit` in `AuctionEscapeHatch` currently uses Malt's spot price to calculate the quantity to return to the exiting user. This spot price simply tracks the Uniswap pool's reserves which can easily be manipulated via a flash loan attack to extract funds from the protocol.  ## Proof of Concept  https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/AuctionEscapeHatch.sol#L65-L92 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/AuctionEscapeHatch.sol#L193 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L80-L109 https://shouldiusespotpriceasmyoracle.com/  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider implementing/integrating a TWAP oracle to track the price of Malt.  "}, {"title": "Timelock reuse function argument as argument for the event emit", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/214", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  GiveMeTestEther   # Vulnerability details  ## Impact Reuse the function argument in the event emit instead of the storage variable. This saves a SLOAD.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Timelock.sol#L66 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Timelock.sol#L82   ## Tools Used  ## Recommended Mitigation Steps - L76 write: emit NewDelay(_delay); - L92: write: emit NewGracePeriod(_gracePeriod);  "}, {"title": "MovingAverage:getValueWithLookback move sampleDiff  to save gas", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/212", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  GiveMeTestEther   # Vulnerability details  ## Impact Move the initialization of sampleDiff below the if block to save gas in the case of return of the if block.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/MovingAverage.sol#L128  ## Tools Used  "}, {"title": "MovingAverage:getValue move the declaration/initialization of sampleDiff to save gas in the case of an early return", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/210", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  GiveMeTestEther   # Vulnerability details  ## Impact move the sampleDiff (L86) below the if statement L88 to save the declaration/initialization of sampleDiff in the case the if block gets executed and the function returns early  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/MovingAverage.sol#L86 ## Tools Used  ## Recommended Mitigation Steps - move the declaration/initialization of of sampleDiff below the if statement  "}, {"title": "MovingAverage:initialize reuse argument variable instead storage variable in the loop condition", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/209", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  GiveMeTestEther   # Vulnerability details  ## Impact Reuse _sampleMemory instead of the storage variable sampleMemory in the condition statement of the loop to save gas.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/MovingAverage.sol#L60 ## Tools Used  ## Recommended Mitigation Steps - rewrite L60 as: for (uint i = 0; i < _sampleMemory ; i++)  "}, {"title": "Reduce external calls", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/208", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  xYrYuYx   # Vulnerability details  ## Impact https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/StabilizerNode.sol#L167  https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/StabilizerNode.sol#L219  Before call _distributeSupply function, it already get priceTarget, But in _distributeSupply, it again call external call to get price target. This will use higher gas.   ## Tools Used Manual  ## Recommended Mitigation Steps Send price target in _distributeSupply() function argument, and please review all duplicated external calls and optimize them.  "}, {"title": "decimals return of costBasis is not used.", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/205", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-11-malt-findings", "body": "decimals return of costBasis is not used."}, {"title": "deployedCapital variable is internal", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/200", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-11-malt-findings", "body": "deployedCapital variable is internal"}, {"title": "In TransactionService, store index of source to avoid loop when removing verifier", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/199", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  xYrYuYx   # Vulnerability details  ## Impact In removeVerifier function, it loop until last index - 1 to find source index. If you added many verifiers, then the gas cost of removeVerifier will be very high, and it can be reverted due to gas limit as well.   ## Tools Used Manual  ## Recommended Mitigation Steps Store index of address in addVerifier function, and remove loop in removeVerifier, and use stored index.  "}, {"title": "Revert transaction if it is unable to change data", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/198", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  xYrYuYx   # Vulnerability details  ## Impact https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/TransferService.sol#L62 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/TransferService.sol#L78  In addVerifier and removeVerifier functions of TransferService.sol, it just returns instead of revert if it is unable to change data. Revert transaction to avoid creating unnecessary transaction and save transaction cost.   ## Tools Used Manual  ## Recommended Mitigation Steps Revert transaction instead of return.  "}, {"title": "_notSameBlock() can be circumvented in bondToAccount() ", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/195", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The function bondToAccount() of Bonding.sol has a check based on _notSameBlock()  _notSameBlock() makes sure the same msg.sender cannot do 2 actions within the same block.  However this can be circumvented in this case: Suppose you call bondToAccount() via a (custom) smart contract, then the msg.sender will be the address of the smart contract. For a pseudo code proof of concept see below.  I'm not sure what the deeper reason is for the _notSameBlock() in bondToAccount(). But if it is important then circumventing this check it will pose a risk.  ## Proof of Concept call function attack1.attack() ```JS contract attack1 {    function attack(address account, uint256 amount) {          call attack2.forward(account, amount);          call any other function of malt   } }  contract attack2 {    function forward(address account, uint256 amount) {        call bonding.bondToAccount(account, amount); // uses msg.sender of attack2    } } ```  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Bonding.sol#L81-L92  ```JS function bondToAccount(address account, uint256 amount) public {     if (msg.sender != offering) {          _notSameBlock();     }     ... ```  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Permissions.sol#L135-L141 ```JS function _notSameBlock() internal {     require( block.number > lastBlock[_msgSender()],\"Can't carry out actions in the same block\" );     lastBlock[_msgSender()] = block.number;   } ```  ## Tools Used  ## Recommended Mitigation Steps Add access controls to the function bondToAccount() An end-user could still call bond()   "}, {"title": "Adapt count in setAuctionAverageLookback?", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/194", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The function setAuctionAverageLookback of AuctionBurnReserveSkew.sol change auctionAverageLookback  However there is also the variable \"count\" that is used in amongst others, addAbovePegObservation(). The modulo of count with auctionAverageLookback is calculated via _getIndexOfObservation(). When you change auctionAverageLookback then the modulo will result in a different value, so you end up in a different location of the circular buffer.  You should probably adapt count as well in the function setAuctionAverageLookback() (see also function setSampleMemory of MovingAverage.sol where a similar pattern is used)  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/AuctionBurnReserveSkew.sol#L186-L200  ```JS function setAuctionAverageLookback(uint256 _lookback) external onlyRole(ADMIN_ROLE, \"Must have admin role\") { ..     if (_lookback > auctionAverageLookback) {       for (uint i = auctionAverageLookback; i < _lookback; i++) {         pegObservations.push(0);       }     }      auctionAverageLookback = _lookback;  ... ```  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/AuctionBurnReserveSkew.sol#L143-L153 ```JS  function addAbovePegObservation(uint256 amount)  public onlyRole(STABILIZER_NODE_ROLE, \"Must be a stabilizer node to call this method\") {     uint256 index = _getIndexOfObservation(count);     ...     pegObservations[index] = 1;     count = count + 1; ... ```  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/AuctionBurnReserveSkew.sol#L134-L136 ```JS  function _getIndexOfObservation(uint _index) internal view returns (uint index) {     return _index % auctionAverageLookback;   } ```  ## Tools Used  ## Recommended Mitigation Steps Doublecheck the theory above and if you agree: Add the following statement in the function  setAuctionAverageLookback(), before auctionAverageLookback is updated.  ```JS  count = count  % auctionAverageLookback ; // the old version of auctionAverageLookback  ```   "}, {"title": "setSampleMemory counter set to right value?", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/193", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The function setSampleMemory of MovingAverage.sol takes the modulo of counter with the new value of _sampleMemory: \"counter = counter % _sampleMemory;\"  Suppose: counter =15 ; sampleMemory=10 and  _sampleMemory=12 Then:   counter = counter % _sampleMemory ==> 3,  which means processing will continue at position 3.  However I think it should use: counter = counter % sampleMemory,  so it will continue at position 5  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/MovingAverage.sol#L424-L442  ```JS function setSampleMemory(uint256 _sampleMemory) external onlyRole(ADMIN_ROLE, \"Must have admin privs\")  {   ...     if (_sampleMemory > sampleMemory) {       ...       counter = counter % _sampleMemory;     } else {    }     sampleMemory = _sampleMemory; } ```  ## Tools Used  ## Recommended Mitigation Steps Doublecheck the theory above and if you agree: change ```JS  counter = counter % _sampleMemory; ``` to ```JS  counter = counter %  sampleMemory; ```   "}, {"title": "Max value of upperStabilityThreshold and lowerStabilityThreshold not checked", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/192", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The function setStabilityThresholds of StabilizerNode.sol set the values for upperStabilityThreshold and lowerStabilityThreshold, however there is no check for a maximum value. This means that in function _shouldAdjustSupply() the values for upperThreshold and lowerThreshold  could get larger than priceTarget. When they are subtracted from priceTarget a revert will occur.  Thus it is useful the make sure that upperStabilityThreshold and lowerStabilityThreshold don't get too large.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/StabilizerNode.sol#L445-L454  ```JS function setStabilityThresholds(uint256 _upper, uint256 _lower) external onlyRole(ADMIN_ROLE, \"Must have admin role\") {     require(_upper > 0 && _lower > 0, \"Must be above 0\");     upperStabilityThreshold = _upper;     lowerStabilityThreshold = _lower; ```  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/StabilizerNode.sol#L198-L206  ```JS function _shouldAdjustSupply(uint256 exchangeRate) internal view returns (bool) {    ...     uint256 upperThreshold = priceTarget.mul(upperStabilityThreshold).div(10**decimals); // upperStabilityThreshold could be > 10**dec => upperThreshold could be > priceTarget     uint256 lowerThreshold = priceTarget.mul(lowerStabilityThreshold).div(10**decimals);  // lowerStabilityThreshold could be > 10**dec => lowerThreshold could be > priceTarget      return (exchangeRate <= priceTarget.sub(lowerThreshold) && !auction.auctionActive(auction.currentAuctionId())) || exchangeRate >= priceTarget.add(upperThreshold); // can revert   } ```  ## Tools Used  ## Recommended Mitigation Steps In function setStabilityThresholds() check for a maximum value of upperStabilityThreshold and lowerStabilityThreshold  "}, {"title": "`StabilizerNode` Will Mint An Incentive For Triggering An Auction Even If An Auction Exists Already", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/191", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  leastwood   # Vulnerability details  ## Impact  `_startAuction` utilises the `SwingTrader` contract to purchase Malt. If `SwingTrader` has insufficient capital to return the price of Malt back to its target price, an auction is triggered with the remaining amount. However, no auction is triggered if the current auction exists, but `msg.sender` is still rewarded for their call to `stabilize`.  ## Proof of Concept  `_shouldAdjustSupply` initially checks if the current auction is active, however, it does not check if the current auction exists. There is a key distinction between the `auctionActive` and `auctionExists` functions which are not used consistently. Hence, an auction which is inactive but exists would satisfy the edge case and result in `triggerAuction` simply returning.  https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L382-L386 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L268-L272 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/StabilizerNode.sol#L342-L344 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L873-L888  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider using `auctionExists` and `auctionActive` consistently in `StabilizerNode` and `Auction` to ensure this edge case cannot be abused.  "}, {"title": "No max for advanceIncentive", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/190", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The function setAdvanceIncentive of DAO.sol doesn't check for a maximum value of incentive. If incentivewould be very large, then advanceIncentive would be very large and the function advance() would mint a large amount of malt.  The function setAdvanceIncentive() can only be called by an admin, but a mistake could be made. Also if an admin would want to do a rug pull, this would be an ideal place to do it.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/DAO.sol#L98-L104  ```JS   function setAdvanceIncentive(uint256 incentive)  externalonlyRole(ADMIN_ROLE, \"Must have admin role\") {    ...     advanceIncentive = incentive; ```  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/DAO.sol#L55-L63  ```JS function advance() external { ...     malt.mint(msg.sender, advanceIncentive * 1e18);  ```  ## Tools Used  ## Recommended Mitigation Steps Check for a reasonable maximum value in advance()  "}, {"title": "Users Can Contribute To An Auction Without Directly Committing Collateral Tokens", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/188", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  leastwood   # Vulnerability details  ## Impact  `purchaseArbitrageTokens` enables users to commit collateral tokens and in return receive arbitrage tokens which are redeemable in the future for Malt tokens. Each auction specifies a commitment cap which when reached, prevents users from participating in the auction. However, `realCommitment` can be ignored by directly sending the `LiquidityExtension` contract collateral tokens and subsequently calling `purchaseArbitrageTokens`.  ## Proof of Concept  Consider the following scenario: - An auction is currently active. - A user sends collateral tokens to the `LiquidityExtension` contract. - The same user calls `purchaseArbitrageTokens` with amount `0`. - The `purchaseAndBurn` call returns a positive `purchased` amount which is subsequently used in auction calculations.  As a result, a user could effectively influence the average malt price used throughout the `Auction` contract.  https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L177-L214 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/LiquidityExtension.sol#L117-L128  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider adding a check to ensure that `realCommitment != 0` in `purchaseArbitrageTokens`.  "}, {"title": "governor or timelock", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/187", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact In the contract Timelock.sol the following onlyRole expression occurs a few times, referring GOVERNER and timelock: onlyRole(GOVERNOR_ROLE, \"Must have timelock role\")  Whereas several other onlyRole expressions are referring to governor: onlyRole(GOVERNOR_ROLE, \"Timelock::...: Call must come from governor.\")  Either the role should be TIMELOCK_ROLE or the messages should refer consistently to governor. Otherwise it might be more difficult to solve error messages from reverts.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Timelock.sol#L68  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Timelock.sol#L84  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Timelock.sol#L100  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Timelock.sol#L115  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Timelock.sol#L140  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Timelock.sol#L159  ## Tools Used  ## Recommended Mitigation Steps Make the error messages consistent   "}, {"title": "Outdated Solidity Version Provides No Protections Against Arithmetic Underflows And Overflows", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/185", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  leastwood   # Vulnerability details  ## Impact  Malt Finance uses solidity version `>=0.6.6` throughout all of its contracts. This solidity version provides no protections against arithmetic underflows and overflows. As a result, it is incredibly difficult to guarantee that the protocol enforces the necessary arithmetic checks during sensitive actions.  There are several instances where the OpenZeppelin's `SafeMath` library is not used. This exposes the protocol to potential exploits via arithmetic underflows and overflows. The liveness of the protocol depends on safety guarantees that are not provided/enforced. Therefore, this issue should be deemed high severity.  ## Proof of Concept  Solidity version shown in all contracts.  ## Tools Used  Manual code review. https://docs.soliditylang.org/en/v0.8.10/080-breaking-changes.html  ## Recommended Mitigation Steps  Consider updating the smart contract suite to use the latest solidity version or at the very least integrate OpenZeppelin's `SafeMath` library in all areas of the code containing arithmetic operations.  "}, {"title": "`setupParticipant` function should be internal", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/183", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  nathaniel   # Vulnerability details  ## Impact No vulnerability, however as `setupPartipant` would only ever be executed by the constructor in its deriving contracts, it would make sense if it was internal instead of public. If it was not executed in the constructor of the deriving contract, then at least it is safer with internal visibility.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/AuctionParticipant.sol#L30   "}, {"title": "Similar code in `getCollateralValueInMalt` and `totalUsefulCollateral` functions ", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/180", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  nathaniel   # Vulnerability details  ## Impact The code in `getCollateralValueInMalt` of ImpliedCollateralService.sol, can leverage the `totalUsefulCollateral` function, reducing code size and gas cost when calling the contract.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/ImpliedCollateralService.sol#L104-L124  ## Tools Used manual  ## Recommended Mitigation Steps Remove L108-L110, then in the return of `getCollateralValueInMalt` return `totalUsefulCollateral().mul(target).div(maltPrice) + swingTraderMaltBalance`  "}, {"title": "Duplicated code in `unbond` and `unbondAndBreak` functions", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/178", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  nathaniel   # Vulnerability details  ## Impact A large portion of the `unbond` and `unbondAndBreak` code of Bonding.sol is the same, to reduce code bloat and gas when calling the contract   ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Bonding.sol#L97-L109  ## Tools Used Manual  ## Recommended Mitigation Steps I would suggest wrapping the duplicated code into an internal function called by `unbond` and `unbondAndBreak`.  "}, {"title": "Malt decimals inconsistency: StabilizerNode and DAO contracts use 18 as hard coded Malt decimals", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/175", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  hyh   # Vulnerability details  ## Impact  If Malt token be set to have lower decimals the incentives will be too big to be issued and DAO advance epoch and StabilizerNode auction start functions will fail, the system will have to be redeployed.  For example, if Malt was set to have 6 decimals like USDC, then 100*1e18 StabilizerNode defaultIncentive will be 100 trillions Malt.  ## Proof of Concept  Now some parts of the system use ```malt.decimals()``` (SwingTrader, UniswapHandler), some (StabilizerNode, DAO) use 18.  DAO advanceIncentive:  https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DAO.sol#L60   StabilizerNode defaultIncentive:  stabilize function https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/StabilizerNode.sol#L145  calls _startAuction in low exchangeRate case, minting defaultIncentive * 10**18 = 100 * 1e18 Malt to the sender as a caller fee. https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/StabilizerNode.sol#L344   ## Recommended Mitigation Steps  If Malt decimals are meant to be set to 18, add a constant variable and use it across the system to save gas.  If the flexibility is desired ```malt.decimals()``` to be used, in a form of contract storage variable for gas optimization (```decimals()``` can be saved to storage once on initialization, and read from there afterwards).   "}, {"title": "Lack of precision", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/168", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  robee   # Vulnerability details  This issue is about arithmetic computation that could have been done more percise.  The following are places in the codebase in which you multiplied after the divisions.  Doing the multiplications at start lead to more accurate calculations.  This is a list of places in the code that this appears (Solidity file, line number, actual line):           DAO.sol, 105,   /* Internal methods */          UniswapHandler.sol, 265,         buyBase.div(priceTarget).mul(buyBase).mul(997)          RewardDistributor.sol, 113,   /* PUBLIC VIEW FUNCTIONS */          RewardDistributor.sol, 118,   /* INTERNAL VIEW FUNCTIONS */          RewardDistributor.sol, 129,   /* INTERNAL FUNCTIONS */   "}, {"title": "State variables that could be set immutable", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/164", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-malt-findings", "body": "State variables that could be set immutable"}, {"title": "Public functions to external", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/163", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "Public functions to external"}, {"title": "Storage double reading. Could save SLOAD", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/161", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "Storage double reading. Could save SLOAD"}, {"title": "Unused declared local variables", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/158", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  robee   # Vulnerability details  Unused local variables are gas consuming, since the initial value assignment costs gas. And are  a bad code practice. Removing those variables will decrease the gas cost and improve code quality.  This is a full list of all the unused storage variables we found in your code base.  The format is <solidity file>, <in which function we found it>, <unused local variable name>:           AbstractRewardMine.sol, _handleStakePadding, totalRewardedWithStakePadding         AbstractRewardMine.sol, _handleStakePadding, INITIAL_STAKE_SHARE_MULTIPLE         AbstractRewardMine.sol, _handleStakePadding, bondedTotal         Auction.sol, _finalizeAuction, avgMaltPrice         AuctionParticipant.sol, claim, replenishingId         AuctionParticipant.sol, claim, claimableTokens         AuctionParticipant.sol, claim, claimable         Create2Deployer.sol, deploy, addr         UniswapHandler.sol, removeBuyer, buyer         MaltDataLab.sol, trackPoolReserves, rewardDecimals         MovingAverage.sol, update, elapsedSamples         MovingAverage.sol, updateCumulative, elapsedSamples         StabilizerNode.sol, stabilize, exchangeRate         StabilizerNode.sol, _startAuction, decimals         SwingTrader.sol, sellMalt, maltDecimals         SwingTrader.sol, costBasis, maltDecimals         TransferService.sol, removeVerifier, verifier   "}, {"title": "Unused imports", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/157", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "Unused imports"}, {"title": "AuctionBurnReserveSkew:addAbovePegObservation gas optimization", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/153", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  GiveMeTestEther   # Vulnerability details  ## Impact Remove L151 count = count + 1; and change L147 to uint256 index = _getIndexOfObservation(count++); so we save at least a SLOAD.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionBurnReserveSkew.sol#L143  ## Tools Used  ## Recommended Mitigation Steps Remove L151 count = count + 1; and change L147 to uint256 index = _getIndexOfObservation(count++);  "}, {"title": "AuctionBurnReserveSkew:getRealBurnBudget no underflow check needed", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/152", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  GiveMeTestEther   # Vulnerability details  ## Impact After teh if statement on L74, we have premiumExcess <= maxBurnSpend and therefore don't need to do a save subtraction (underflow check) on L80.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionBurnReserveSkew.sol#L69  ## Tools Used  ## Recommended Mitigation Steps - rewrite L80 as: uint256 usableExcess = maxBurnSpend - premiumExcess;  "}, {"title": "Auction:amendAccountParticipation no underflow check needed", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/151", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  GiveMeTestEther   # Vulnerability details  ## Impact Else block on L805 satisfies amountArbTokens <= unclaimedArbTokens and therefore no safe subtraction (underflow check) is needed (saves gas).  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L786  ## Tools Used  ## Recommended Mitigation Steps - rewrite L805 as: unclaimedArbTokens = unclaimedArbTokens - amountArbTokens;  "}, {"title": "Auction:claimArbitrage no underflow checks needed", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/149", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  GiveMeTestEther   # Vulnerability details  # Vulnerability details  ## Impact The else block on L241 satisfies amountTokens <= unclaimedArbTokens and therefore we don't need to do a safe subtraction (underflow check).  The else block on L247 satisfies amountTokens <= claimableArbitrageRewards and therefore we don't need to do a safe subtraction (underflow check).     ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L216 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L247  ## Tools Used  ## Recommended Mitigation Steps - rewrite L241 as: unclaimedArbTokens = unclaimedArbTokens - amountTokens; - rewrite L274 as: claimableArbitrageRewards = claimableArbitrageRewards - amountTokens-;   "}, {"title": "Auction:purchaseArbitrageTokens gas optimization", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/147", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  GiveMeTestEther   # Vulnerability details  ## Impact L209 nextCommitmentId = nextCommitmentId + 1; can be removed and L202 can be changed to nextCommitmentId++; to save a SLOAD  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L177  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps  "}, {"title": "RewardThrottle:handleReward gas optimizations", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/144", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  GiveMeTestEther   # Vulnerability details  ## Impact Storage variable _activeEpoch is read a lot and can be cached in a local variable (epochTmp, maybe choose a better name =)) to save gas. Also the State struct can be loaded into a State storage (currentState, maybe also choose a better name) variable such that we don't have to access the storage array each time.   In the gas optimized code of \"Recommended Mitigation Steps\" section, the _activeEpoch only gets read once. Also note after the first \"if\" we write epoch to the storage variable \"_activeEpoch\" but then also write epoch to the local var \"epochTmp\" so we can use this local var in the whole function.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/RewardSystem/RewardThrottle.sol#L63  ## Tools Used  ## Recommended Mitigation Steps   function handleReward() public {     uint256 balance = rewardToken.balanceOf(address(this));      uint256 epoch = dao.epoch();     uint256 epochTmp = _activeEpoch;     State storage currentState;      checkRewardUnderflow();      if (epoch > epochTmp) {       _activeEpoch = epoch;       epochTmp = epoch;        currentState = _state[epochTmp];        currentState.bondedValue = bonding.averageBondedValue(epochTmp);        currentState.profit = balance;       currentState.rewarded = 0;       currentState.throttle = throttle;     } else {       currentState = _state[epochTmp];       currentState.profit = currentState.profit.add(balance);       currentState.throttle = throttle;      }      // Fetch targetAPR before we update current epoch state     uint256 aprTarget = targetAPR();      // Distribute balance to the correct places     if (aprTarget > 0 && _epochAprGivenReward(epoch, balance) > aprTarget) {       uint256 remainder = _getRewardOverflow(balance, aprTarget);       emit RewardOverflow(epochTmp, remainder);        if (remainder > 0) {         rewardToken.safeTransfer(address(overflowPool), remainder);          if (balance > remainder) {           _sendToDistributor(balance - remainder, epochTmp);         }       }     } else {       _sendToDistributor(balance, epochTmp);     }      emit HandleReward(epoch, balance);   }  "}, {"title": "RewardDistributor:decrementRewards no underflow check needed", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/143", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  GiveMeTestEther   # Vulnerability details  ## Impact Require statement conditions checks that no underflow can happen, therefore we don't need to use safe subtraction (underflow check).  - L275:  require(amount <= _globals.declaredBalance, \"Can't decrement more than total reward balance\"); - L278:  _globals.declaredBalance = _globals.declaredBalance.sub(amount); => Rewrite L278 as:  _globals.declaredBalance = _globals.declaredBalance - amount;  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/RewardSystem/RewardDistributor.sol#L271 ## Tools Used  ## Recommended Mitigation Steps - rewrite L278 as:  _globals.declaredBalance = _globals.declaredBalance - amount;  "}, {"title": "RewardDistributor:_incrementFocalPoint() save storage read", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/142", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  GiveMeTestEther   # Vulnerability details  ## Impact L185:  focalID = focalID + 1; can be removed and L197 can be adapted to:  _resetFocalPoint(++focalID, newEndTime); to save at least one warm storage read (100 gas)  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/RewardSystem/RewardDistributor.sol#L180 ## Tools Used  ## Recommended Mitigation Steps  "}, {"title": "RewardDistributor:_forfeit no underflow check needed", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/140", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  GiveMeTestEther   # Vulnerability details  ## Impact Require condition checks already underflow condition. There for no underflow check is needed.  - L154: require(forfeited <= _globals.declaredBalance, \"Cannot forfeit more than declared\"); - L156:_globals.declaredBalance = _globals.declaredBalance.sub(forfeited);  Therefore L156 can be written as: _globals.declaredBalance = _globals.declaredBalance - forfeited;   ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/RewardSystem/RewardDistributor.sol#L153 ## Tools Used  ## Recommended Mitigation Steps - L156 can be written as: _globals.declaredBalance = _globals.declaredBalance - forfeited;  "}, {"title": "Unneeded variables (Auction.sol, StabilizerNode.sol)", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/137", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-11-malt-findings", "body": "Unneeded variables (Auction.sol, StabilizerNode.sol)"}, {"title": "Code does not match comments in \"_finalizeAuction\" (Auction.sol)", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/135", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-11-malt-findings", "body": "Code does not match comments in \"_finalizeAuction\" (Auction.sol)"}, {"title": "AbstractRewardMine._handleStakePadding logic cases can be separated and function simplified", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/131", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  hyh   # Vulnerability details  ## Impact  Gas is overspent on operations.  ## Proof of Concept  The function contains two non-intersecting logic pathways, which can be separated to lighten calculations.  https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/AbstractRewardMine.sol#L179   ## Recommended Mitigation Steps  Now: ``` function _handleStakePadding(address account, uint256 amount) internal {  uint256 totalRewardedWithStakePadding = totalDeclaredReward().add(totalStakePadding());   uint256 INITIAL_STAKE_SHARE_MULTIPLE = 1e6;   uint256 bondedTotal = totalBonded();   uint256 newStakePadding = bondedTotal == 0 ?   totalDeclaredReward() == 0 ? amount.mul(INITIAL_STAKE_SHARE_MULTIPLE) : 0 :   totalRewardedWithStakePadding.mul(amount).div(bondedTotal);   _addToStakePadding(account, newStakePadding); } ```  To be: ``` function _handleStakePadding(address account, uint256 amount) internal {  uint256 bondedTotal = totalBonded();    uint256 newStakePadding;  if (bondedTotal == 0) {   uint256 INITIAL_STAKE_SHARE_MULTIPLE = 1e6;   newStakePadding = totalDeclaredReward() == 0 ? amount.mul(INITIAL_STAKE_SHARE_MULTIPLE) : 0;  } else {   newStakePadding = (totalDeclaredReward().add(totalStakePadding())).mul(amount).div(bondedTotal);  }   if (newStakePadding > 0)   _addToStakePadding(account, newStakePadding); } ```  "}, {"title": "setupParticipant() function does not check for zero address", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/130", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  jayjonah8   # Vulnerability details  ## Impact The setupParticipant() function in AuctionParticipant.sol does not have require statements to protect again contracts that do not yet exist.  It sets the addresses for \" _impliedCollateralService\", \"_rewardToken\", and \"_auction\" and can only be called once so its vital to have this guard in place.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/AuctionParticipant.sol#L26  ## Tools Used Manual code review   ## Recommended Mitigation Steps Add require checks for the addresses that are passed in the setupParticipant() function checking if they exist like: require(\"address\" != address(0), \"contract does not exist\")  "}, {"title": " AbstractRewardMine._handleStakePadding calls totalDeclaredReward and this way balanceOf function twice", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/128", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  hyh   # Vulnerability details  ## Impact  Gas is overspent on access and function calls.  ## Proof of Concept  totalDeclaredReward is called by _handleStakePadding twice: https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/AbstractRewardMine.sol#L180  While totalDeclaredReward does expensive balanceOf call: https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/AbstractRewardMine.sol#L97  ## Recommended Mitigation Steps  It is viable to at least remove its double usage:  Now: ``` uint256 totalRewardedWithStakePadding = totalDeclaredReward().add(totalStakePadding()); ... uint256 newStakePadding = bondedTotal == 0 ?  totalDeclaredReward() == 0 ? amount.mul(INITIAL_STAKE_SHARE_MULTIPLE) : 0 :  totalRewardedWithStakePadding.mul(amount).div(bondedTotal); ```  To be: ``` uint256 declaredRewardTotal =  rewardToken.balanceOf(address(this)); uint256 totalRewardedWithStakePadding = declaredRewardTotal.add(totalStakePadding()); ... uint256 newStakePadding = bondedTotal == 0 ?  declaredRewardTotal == 0 ? amount.mul(INITIAL_STAKE_SHARE_MULTIPLE) : 0 : totalRewardedWithStakePadding.mul(amount).div(bondedTotal); ```  "}, {"title": "TIMELOCK_ROLE Has Absolute Power to Withdraw All FUND May Raise Red Flags for Investors", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/125", "labels": ["bug", "duplicate", "2 (Med Risk)"], "target": "2021-11-malt-findings", "body": "TIMELOCK_ROLE Has Absolute Power to Withdraw All FUND May Raise Red Flags for Investors"}, {"title": "The Power Structure is Too Centralized And Protocol May Break If Anything Happen to Admin", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/124", "labels": ["bug", "2 (Med Risk)", "sponsor disputed"], "target": "2021-11-malt-findings", "body": "The Power Structure is Too Centralized And Protocol May Break If Anything Happen to Admin"}, {"title": "sellMalt(), addLiquidity() and removeLiquidity() Allow Non Privileged Users Withdraw Fund", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/120", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  Meta0xNull   # Vulnerability details  ## Impact Is Not Uncommon Normal Users Accidentally Send Tokens into Contract.  ENS Airdrop is a Good Example Normal Users Accidentally Send Tokens into Contract: https://discuss.ens.domains/t/social-amend-airdrop-proposal-to-include-accidentally-returned-funds/6975  In UniswapHandler.sol, sellMalt(), addLiquidity() and removeLiquidity() Have No Access Control. When Normal Users Accidently Deposit Tokens into the Contract, Any Random Persons/Bot Can Withdraw the Tokens because it will safeTransfer to msg.sender who find out there is token balance in the contract.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L185-L219 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L221-L245  ## Tools Used Manual Review  ## Recommended Mitigation Steps Add relevant access control, probably Only StabilizerNode and Admin have Access to this contract various functions like sellMalt(), addLiquidity() and removeLiquidity() etc.   "}, {"title": "removeVerifier() Repeat SLOAD During Loop Is Waste of Gas", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/117", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  Meta0xNull   # Vulnerability details  ## Impact removeVerifier() loops follows this for-each pattern: for (uint256 i = 0; i < array.length; i++) {  // do something with `array[i]` }  In such for loops, the array.length is read on every iteration, instead of caching it once in a local variable and read it again using the local variable.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/TransferService.sol#L87-L88  ## Tools Used Manual Review  ## Recommended Mitigation Steps Read these values from memory once, cache them in local variables and then read them again using the local variables. For example:  Before: for (uint i = 0; i < verifierList.length - 1; i = i + 1) { if (verifierList[i] == _address) {  After: uint256 verifierList_temp = verifierList  for (uint i = 0; i < verifierList_temp.length - 1; i = i + 1) { if (verifierList_temp[i] == _address) {  "}, {"title": "Avoiding Initialization of Loop Index If It Is 0", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/116", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "Avoiding Initialization of Loop Index If It Is 0"}, {"title": "_setupRole() Deprecated and Not Using With Constructor Effectively Circumventing the Admin System", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/115", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  Meta0xNull   # Vulnerability details  ## Impact      * [WARNING]      * ====      * This function should only be called from the constructor when setting      * up the initial roles for the system.      *      * Using this function in any other way is effectively circumventing the admin      * system imposed by {AccessControl}.      * ====      *      * NOTE: This function is deprecated in favor of {_grantRole}.  There are multiple contracts that import Permissions.sol and using Deprecated Function _setupRole() with Security Problem that Applicable to all these contracts because all of the contracts use initialize() Rather Than Constructor.   ## Proof of Concept https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/AccessControl.sol#L174-L186 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Permissions.sol#L53 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Permissions.sol#L117 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Permissions.sol#L121  ## Tools Used Manual Review  ## Recommended Mitigation Steps Replace _setupRole() with _grantRole()  "}, {"title": "AbstractRewardMine.getRewardOwnershipFraction shouldn't be used internally", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/114", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  hyh   # Vulnerability details  ## Impact  Gas is overspent on function calls.  ## Proof of Concept  ```earned``` function calls public ```getRewardOwnershipFraction``` function: https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/AbstractRewardMine.sol#L144  ## Recommended Mitigation Steps  Now: ``` function totalDeclaredReward() virtual public view returns (uint256) {  return rewardToken.balanceOf(address(this)); } function getRewardOwnershipFraction(address account) public view returns(uint256 numerator, uint256 denominator) {  numerator = balanceOfRewards(account);  denominator = totalDeclaredReward(); } ... function earned(address account) public view returns (uint256 earnedReward) {  (uint256 rewardNumerator, uint256 rewardDenominator) = getRewardOwnershipFraction(account);  ```  To be: ``` function earned(address account) public view returns (uint256 earnedReward) {  uint256 rewardNumerator = balanceOfRewards(account);  uint256 rewardDenominator = rewardToken.balanceOf(address(this)); ```  "}, {"title": "reassignGlobalAdmin() Lack of Zero Address Check ", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/113", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  Meta0xNull   # Vulnerability details  ## Impact A wrong user input or wallets defaulting to the zero addresses for a missing input can lead to the contract needing to redeploy or Users'FUND Locked inside the Contract.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Permissions.sol#L63-L77  ## Tools Used Manual Review  ## Recommended Mitigation Steps requires Addresses is not zero.  require(_admin != address(0), \"Address Can't Be Zero\")  "}, {"title": "reassignGlobalAdmin() Have No Transfer Ownership Pattern", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/112", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  Meta0xNull   # Vulnerability details  ## Impact The current ownership transfer process involves the current TIMELOCK_ROLE calling reassignGlobalAdmin().  If the nominated EOA account is not a valid account, it is entirely possible the owner may accidentally transfer ownership to an uncontrolled account, breaking all functions with the TIMELOCK_ROLE modifier.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Permissions.sol#L63-L77  ## Tools Used Manual Review  ## Recommended Mitigation Steps Consider implementing a two step process where the TIMELOCK_ROLE nominates an account and the nominated account needs to call an accept_TIMELOCK_ROLE() function for the transfer of ownership to fully succeed. This ensures the nominated EOA account is a valid and active account.   "}, {"title": "Redundant require statements in `Auction:purchaseArbitrageTokens`", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/108", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  loop   # Vulnerability details  When invoking `purchaseArbitrageTokens()` is will first check whether the auction is active using: ``` require(auctionActive(currentAuctionId), \"No auction running\"); ``` `auctionActive()` checks for the following things: ``` auction.active && now >= auction.startingTime; ``` As a result the require statement will fail if either `!auction.active` or `now < auction.startingTime`.   Later on in `purchaseArbitrageTokens()` two more require statements will check the same thing: ``` require(auction.startingTime <= now, \"Auction hasn't started yet\"); (...)  require(auction.active == true, \"Auction is not active\"); ``` These will always pass if `auctionActive(currentAuctionId)` is `true` and never be reached if it is `false`, making them redundant.  ## Proof of Concept - https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L178 - https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L188-L190 - https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L268-L272  ## Recommended Mitigation Steps Remove redundant require statements  "}, {"title": "Cache array length in `for` loops", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/106", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  pmerkleplant   # Vulnerability details  ## Impact  Caching the array length in a `for`-loop saves gas as the length does not need to be read on every iteration.  The following loops could be refactored: ``` ./Malt.sol:34:    for (uint256 i = 0; i < minters.length; i = i + 1) { ./Malt.sol:37:    for (uint256 i = 0; i < burners.length; i = i + 1) { ./TransferService.sol:87:    for (uint i = 0; i < verifierList.length - 1; i = i + 1) { ./Auction.sol:407:    for (uint i = 0; i < epochCommitments.length; ++i) { ./libraries/UniswapV2Library.sol:66:        for (uint i; i < path.length - 1; i++) { ./AuctionParticipant.sol:107:    for (uint256 i = replenishingIndex; i < auctionIds.length; i = i + 1) { ./MiningService.sol:49:    for (uint i = 0; i < mines.length; i = i + 1) { ./MiningService.sol:69:    for (uint i = 0; i < mines.length; i = i + 1) { ./MiningService.sol:86:    for (uint i = 0; i < mines.length; i = i + 1) { ./MiningService.sol:96:    for (uint i = 0; i < mines.length; i = i + 1) { ./MiningService.sol:142:    for (uint i = 0; i < mines.length - 1; i = i + 1) { ./MiningService.sol:166:    for (uint i = 0; i < mines.length; i = i + 1) { ./DexHandlers/UniswapHandler.sol:317:    for (uint i = 0; i < buyers.length - 1; i = i + 1) { ```  ## Tools used  `grep -rn \".length\" .`  "}, {"title": "Incorrect error messages in `StabilizerNode.sol`", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/103", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  pmerkleplant   # Vulnerability details  ## Impact  The functions `setDefaultIncentive` and `setExpansionDamping` in `StabilizerNode.sol` require their arguments to be non-zero, i.e. to be positive, as their argument types are `uint`.  However, the error messages state that the arguments should not be non-negative.  See lines [406](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/StabilizerNode.sol#L406) and [417](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/StabilizerNode.sol#L417).  ## Recommended Mitigation Steps  Change the error messages to something like: \"Must be above 0\".  "}, {"title": "Don't try bonding zero liquidity in `RewardReinvestor`", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/101", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  pmerkleplant   # Vulnerability details  ## Impact  Function `RewardReinvestor::_bondAccount` tries to bond liquidity to an account, even though it is known whether the liquidity is zero.  ## Proof of Concept  The return value `liquidityCreated` in [line 105](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/RewardReinvestor.sol#L105) can be zero. The following function call, `bondToAccount()`, then reverts with \"Cannot bond 0\".  ## Recommended Mitigation Steps  Gas could be saved if the function would revert earlier, i.e. in [line 106](https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/RewardReinvestor.sol#L106), if the `liquidityCreated` is zero.  "}, {"title": "No message in require statements.", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/98", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  BouSalman   # Vulnerability details  ## Vulnerability description There is multiple instances within the **Malt** protocol codebase that do not append messages to the require statements.  ## Impact add a custom message to the require statement to create a better sense of what's is the reason of failure.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L681 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/ERC20Permit.sol#L56 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/ERC20Permit.sol#L76 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/ERC20Permit.sol#L78 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/ERC20Permit.sol#L119  ## Tools Used manual code review.  ## Recommended Mitigation Steps append custom message to the require statements.  "}, {"title": "functions visibility on contract AuctionEscapeHatch", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/97", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  BouSalman   # Vulnerability details  ## Vulnerability description On contract **AuctionEscapeHatch** there is a function labeled as Public, However this function is not used within the contracts of **Malt** protocol.  ## Impact Improve coding style quality for developers and audit.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionEscapeHatch.sol#L94  ## Tools Used manual code review.  ## Recommended Mitigation Steps Evaluate functions labeled as public and set to external if needed just like the rest of functions inside this contract.  "}, {"title": "functions visibility on contract Timelock.sol", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/91", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-11-malt-findings", "body": "functions visibility on contract Timelock.sol"}, {"title": " Cache Reference To State Variable \"currentAuctionID\" in _checkAuctionFinalization (Auction.sol)", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/89", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  ye0lde   # Vulnerability details  ## Impact  Caching the references to \"currentAuctionID\" will decrease gas usage.   ## Proof of Concept  The state variable \"currentAuctionID\" is read 7 times in function \"_checkAuctionFinalization\" here: https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L746-L762  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps  I suggest making the changes below to cache the variable:    ```   function _checkAuctionFinalization(bool isInternal) internal {      uint256 currentId = currentAuctionId;     if (isInternal && !isAuctionFinished(currentId)) {       // Auction is still in progress after internal auction purchasing.       _resetAuctionMaxCommitments();     }      if (isAuctionFinished(currentId)) {       if (auctionActive(currentId)) {         _endAuction(currentId);       }        if (!isAuctionFinalized(currentId)) {         _finalizeAuction(currentId);       }       currentAuctionId = currentId + 1;     }   } ```   "}, {"title": "AuctionParticipant.sol: `setReplenishingIndex` mistake could freeze unclaimed tokens", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/88", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  harleythedog   # Vulnerability details  ## Impact In AuctionParticipant.sol, the function `setReplenishingIndex` is an admin function that allows manually setting `replenishingIndex`. As I have shown in my two previous findings, I believe that this function could be called frequently. In my opinion (and Murphy's law would agree), this implies that eventually an admin will accidentally set `replenishingIndex` incorrectly with this function.  Right now, `setReplenishingIndex` does not allow the admin to set `replenishingIndex` to a value smaller than it currently is. So, if an admin were to accidentally set this value too high, then it would be impossible to set it back to a lower value (the higher the value set, the worse this issue). All of the unclaimed tokens on auctions at smaller indices would be locked forever.  ## Proof of Concept See code for `setReplenishingIndex` here: https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionParticipant.sol#L132  ## Tools Used Inspection  ## Recommended Mitigation Steps Remove the require statement on line 136, so that an admin can set the index to a smaller value.  "}, {"title": "AuctionParticipant.sol: `purchaseArbitrageTokens` should not push duplicate auctions", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/87", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  harleythedog   # Vulnerability details  ## Impact In AuctionParticpant.sol, every time `purchaseArbitrageTokens` is called, the current auction is pushed to `auctionIds`. If this function were to be called on the same auction multiple times, then the same auction id would be pushed multiple times into this array, and the `claim` function would have issues with `replenishingIndex`.   Specifically, even if `replenishingIndex` was incremented once in `claim`, it is still possible that the auction at the next index will never reward any more tokens to the participant, so the contract would need manual intervention to set `replenishingIndex` (due to the if statement on lines 79-82 that does nothing if there is no claimable yield).   It is likely that `purchaseArbitrageTokens` would be called multiple times on the same auction. In fact, the commented out code for `handleDeficit` (in ImpliedCollateralService.sol) even suggests that the purchases might happen within the same transaction. So this issue will likely be an issue on most auctions and would require manual setting of `replenishingIndex`.  NOTE: This is a separate issue from the one I just submitted previously relating to `replenishingIndex`. The previous issue was related to an edge case where `replenishingIndex` might need to be incremented by one if there are never going to be more claims, while this issue is due to duplicate auction ids.  ## Proof of Concept See code for `purchaseArbitrageTokens` here: https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionParticipant.sol#L40  Notice that `currentAuction` is always appended to `auctionIds`.   ## Tools Used Inspection  ## Recommended Mitigation Steps Add a check to the function to `purchaseArbitrageTokens` to ensure that duplicate ids are not added. For example, this can be achieved by changing auctionIds to a mapping instead of an array.  "}, {"title": "AuctionParticipant.sol: `replenishingIndex` incrementing should be improved", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/85", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  harleythedog   # Vulnerability details  ## Impact In AuctionParticipant.sol, the `claim` function is called to claim arb tokens from auctions the participant has entered. This is achieved through the global variable `replenishingIndex` which keeps track of which auction `claim` should be claiming from next. The logic for incrementing `replenishingIndex` is at the end of claim.   I agree with the current logic at the end of the function. The comment on lines 96/97 says \"Don't increment replenishingIndex if replenishingAuctionId == auctionId as claimable could be 0 due to the debt not being 100% replenished\". Notice the keyword \"could\" - it is possible that replenishingAuctionId == auctionId but we will never be able to claim any more arb tokens from this contract, and in this case `replenishingIndex` will NOT be incremented.  In this case, all subsequent calls to `claim` will simply do nothing. Line 77 will have `claimableTokens` be 0, and then the function will immediately return since it thinks it needs to wait longer to get more tokens, which will never happen. In this case, a manual intervention by an admin would be required to set `replenishingIndex', which is obviously annoying and should be avoided. Since `claim` is an external function, a malicious user/troll could intentionally call `claim` at the worst times to trigger this issue to happen. In this case, manual intervention would be required quite often.  The following logic should be added immediately after line 77 to account for this issue:  if (claimableTokens == 0 && replenishingId > auctionId) { // in this case, we will never receive any more tokens from this auction     replenishingIndex = replenishingIndex + 1;     auctionId = auctionIds[replenishingIndex]; }  // retry check for 0 claimable amount  ## Proof of Concept See the code for `claim` here: https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionParticipant.sol#L65  Other than manual intervention, the only place where `replenishingIndex` is set is at the end of `claim`.  ## Tools Used Inspection  ## Recommended Mitigation Steps Add the code described above.  "}, {"title": "Assignment Of Variables To Default ", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/80", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  ye0lde   # Vulnerability details  ## Impact  Variables are being assigned their default value which is unnecessary. Removing the assignment will save gas when deploying and improve code clarity.  ## Proof of Concept  State: https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/DAO.sol#L19  Local: https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L351 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L626 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionBurnReserveSkew.sol#L92 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionBurnReserveSkew.sol#L108 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionBurnReserveSkew.sol#L117 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionBurnReserveSkew.sol#L124 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionPool.sol#L115 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/ERC20VestedMine.sol#L90 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/RewardSystem/RewardDistributor.sol#L94 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/RewardSystem/RewardThrottle.sol#L125 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/RewardSystem/RewardThrottle.sol#L149-L150 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/SwingTrader.sol#L112  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps Remove the unneeded assignments.  Or if you feel it is important to show the default assignment will occur then replace the assignments with a comment.  "}, {"title": "Open TODOs", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/79", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "Open TODOs"}, {"title": "Underutilized Named Returns", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/77", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-11-malt-findings", "body": "Underutilized Named Returns"}, {"title": "Unused Named Returns", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/76", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-malt-findings", "body": "Unused Named Returns"}, {"title": "Lack Of Return Value Check On the Dex Handler Malt Price Calculation", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/75", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  defsec   # Vulnerability details  ## Impact  During the code review, It has been seen that malt price return value has not been checked on the function.  If oracle is returned price as a 0, fullReturn will be zero on the earlyExitReturn function.  ## Proof of Concept  1. Navigate to \"https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/AuctionEscapeHatch.sol#L124\" 2. The return value maltMarketPrice() function has not been checked.  ## Tools Used  Code Review  ## Recommended Mitigation Steps  Consider to add return value check. The maltPrice should be more than zero for the calculation.  \"\"\" require(dexHandler.maltMarketPrice()>0, \"Price should be more than zero\"); \"\"\"  "}, {"title": "Missing zero-address checks on contract initialization", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/74", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  hyh   # Vulnerability details  ## Impact  Being instantiated with wrong configuration, the contract is inoperable and deploy gas costs will be lost. If misconfiguration is noticed too late the various types of malfunctions become possible.  ## Proof of Concept  The checks for zero addresses during contract construction and initialization are considered to be the best-practice.  Now basically all the contract do not check for correctness of constructor arguments:  https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Malt.sol#L29  https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/RewardSystem/RewardOverflowPool.sol#L25  https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/TransferService.sol#L25  https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/ForfeitHandler.sol#L31  https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/MiningService.sol#L30  https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/DexHandlers/UniswapHandler.sol#L47  ...  ## Recommended Mitigation Steps  Add zero-address checks and key non-address variables checks in all contract constructors. Small increase of gas costs are far out weighted by wrong deploy costs savings and additional coverage against misconfiguration.   "}, {"title": "SwingTrader.costBasis function should have internal version that uses Malt balance from sellMalt", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/73", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  hyh   # Vulnerability details  ## Impact  ERC20 balanceOf call is costly. Malt balance is read twice in sellMalt call, which isn't needed, so gas is overspent here.  ## Proof of Concept  Malt balanceOf(address(this)) is called twice: https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/SwingTrader.sol#L86 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/SwingTrader.sol#L150  ## Recommended Mitigation Steps  It's recommended to make internal version of costBasis that takes Malt balance as an argument.  Now: ``` uint256 totalMaltBalance = malt.balanceOf(address(this)); ... (...) = costBasis(); ... function costBasis() public view returns (uint256 cost, uint256 decimals) { ... uint256 maltBalance = malt.balanceOf(address(this)); ... ``` To be: ``` uint256 totalMaltBalance = malt.balanceOf(address(this)); ... (...) = _costBasis(totalMaltBalance); ... function _costBasis(uint256 maltBalance) internal view returns (...) { ... function costBasis() public view returns (...) {  return _costBasis(malt.balanceOf(address(this))); } ```  "}, {"title": "SwingTrader: sellMalt and costBasis functions can be simplified", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/72", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  hyh   # Vulnerability details  ## Impact  Gas is overspent on function call and calculations  ## Proof of Concept  First, save Malt and Collateral tokens decimals difference to storage variable. As neither Malt, nor Collateral token decimals change since initial setup, both can be saved and accessed as a storage variable instead of calling ```decimals()``` function and calculating the difference each time.  Second, now sellMalt calls costBasis, which already retrieved decimals and their difference, but sellMalt ignores those, retrieving them from functions/storage again. This could be unified as discussed below.  sellMalt: https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/SwingTrader.sol#L77 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/SwingTrader.sol#L109  costBasis: https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/SwingTrader.sol#L146   ## Recommended Mitigation Steps   Save both decimals values to contract storage variables and use them instead of ```decimals()``` function. As the calculations use decimals difference it might be enough to save and use the difference only. In any case saving is preferred to calling as the latter spend gas on call and storage access anyway.   Also, return the difference along with decimals from costBasis and use them in sellMalt instead of obtaining afresh. I.e. first reuse ```costBasis``` returned ```decimals``` instead of ```collateralToken.decimals()```, then add ```maltDecimals``` and the difference, whether ```maltDecimals - decimals``` or ```decimals - maltDecimals``` to its output and use in rewards / soldBasis calculations. Function arguments and returned values are memory and are cheaper than another storage access.  Now: ``` (uint256 basis,) = costBasis(); ... uint256 maltDecimals = malt.decimals(); uint256 decimals = collateralToken.decimals(); ... uint256 diff = maltDecimals - decimals;  ``` To be: ``` (uint256 basis, uint256 decimals, uint256 maltDecimals, uint256 diff) = costBasis(); ... ```  "}, {"title": "Unused event or missed emit on SetAnnualYield()", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/69", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  BouSalman   # Vulnerability details  ## Vulnerability description  The event **SetAnnualYield** on Contract **StabilizerNode** is defined but never emitted inside the Contract.  ## Impact Unused events in the codebase can be confusing, each declared event should have a corresponding emit statement.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/StabilizerNode.sol#L73  ## Tools Used manual code review.  ## Recommended Mitigation Steps it's better to remove unused events from the code to improve coding quality, Also monitoring will be effected since no emit statements is there.  "}, {"title": "Auction.userClaimableArbTokens amountOut calculations can be simplified", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/67", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  hyh   # Vulnerability details  ## Impact  Gas is overspent on access and operations.  ## Proof of Concept  ```amountOut``` is calculated in 3 steps, which can be made simpler. https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L302-305  ## Recommended Mitigation Steps  Now: ``` uint256 amountTokens = commitment.commitment.mul(auction.pegPrice).div(price); uint256 redeemedTokens = commitment.redeemed.mul(auction.pegPrice).div(price); uint256 amountOut = amountTokens.mul(claimablePerc).div(auction.pegPrice).sub(redeemedTokens); ```  To be (```amountTokens``` and ```redeemedTokens``` aren't used elsewhere): ```  /* * uint256 amountTokens = commitment.commitment.mul(auction.pegPrice).div(price); * uint256 redeemedTokens = commitment.redeemed.mul(auction.pegPrice).div(price); * uint256 amountOut = amountTokens.mul(claimablePerc).div(auction.pegPrice).sub(redeemedTokens); */ uint256 redeemed = commitment.redeemed.mul(auction.pegPrice); uint256 amountOut = commitment.commitment.mul(claimablePerc).sub(redeemed).div(price); ```   "}, {"title": "Multiple Zero address transfer functions on contract Permissions", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/64", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  BouSalman   # Vulnerability details  ## Vulnerability description On contract **Permissions.sol** there is multiple functions to withdraws funds, these functions currently do not check for zero value address before doing the transaction.  ## Impact Loss of funds, ETHs and ERC20.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Permissions.sol#L80 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Permissions.sol#L88 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Permissions.sol#L97 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Permissions.sol#L104  ## Tools Used manual code review.  ## Recommended Mitigation Steps use require() statement to validate address address(0) before sending the funds.  "}, {"title": "getAuctionCore function returns wrong values out of order", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/63", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  jayjonah8   # Vulnerability details  ## Impact In the AuctionEscapeHatch.sol file both earlyExitReturn() and _calculateMaltRequiredForExit call the getAuctionCore() function which has 10 possible return values most of which are not used.  It gets the wrong value back for the \"active\"  variable since it's the 10th argument but both functions have it as the 9th return value where \"preAuctionReserveRatio\" should be because of one missing comma.  This is serious because these both are functions which deal with allowing a user to exit their arbitrage token position early.  This can result in a loss of user funds.    ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/AuctionEscapeHatch.sol#L100 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/AuctionEscapeHatch.sol#L174 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L527   ## Tools Used Manual code review   ## Recommended Mitigation Steps In AuctionEscapeHatch.sol change the following in _calculateMaltRequiredForExit() and earlyExitReturn() functions:  From:   (,,,,,      uint256 pegPrice,      ,      uint256 auctionEndTime,      bool active     ) = auction.getAuctionCore(_auctionId);  To:   (,,,,,      uint256 pegPrice,      ,      uint256 auctionEndTime,      ,      bool active     ) = auction.getAuctionCore(_auctionId);   "}, {"title": "SafeMath library is not always used in the contracts", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/60", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  defsec   # Vulnerability details  ## Impact  SafeMath library functions are not always used in arithmetic operations in the contracts, which could potentially cause integer underflow/overflows. Although in the reference lines of code, there are upper limits on the variables to ensure an integer underflow/overflow could not happen, using SafeMath is always a best practice, which prevents underflow/overflows completely (even if there were no assumptions on the variables) and increases code consistency as well.   ## Proof of Concept  1. Navigate to the following contracts.  ```  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Auction.sol#L795  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Auction.sol#L821  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/AuctionBurnReserveSkew.sol#L64  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/AuctionEscapeHatch.sol#L76  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/AuctionEscapeHatch.sol#L188  ```  2. SafeMath functions are not used in the every functionality.   ## Tools Used  Code Review  ## Recommended Mitigation Steps  Consider using the SafeMath library functions in the referenced lines of code.   "}, {"title": " Missing events for admin only functions that change critical parameters", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/58", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  defsec   # Vulnerability details  ## Impact  The admin only functions that change critical parameters should emit events. Events allow capturing the changed parameters so that off-chain tools/interfaces can register such changes with timelocks that allow users to evaluate them and consider if they would like to engage/exit based on how they perceive the changes as affecting the trustworthiness of the protocol or profitability of the implemented financial services. The alternative of directly querying on-chain contract state for such changes is not considered practical for most users/usages.  Missing events and timelocks do not promote transparency and if such changes immediately affect users\u2019 perception of fairness or trustworthiness, they could exit the protocol causing a reduction in liquidity which could negatively impact protocol TVL and reputation.  There are owner functions that do not emit any events in the contracts.   ## Proof of Concept  Missing events  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/SwingTrader.sol#L169  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Auction.sol#L1000  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Auction.sol#L1008  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Auction.sol#L992  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Auction.sol#L984  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Auction.sol#L976  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Auction.sol#L968  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Auction.sol#L960  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Auction.sol#L937  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Auction.sol#L930  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Auction.sol#L923  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/Auction.sol#L916  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/AuctionParticipant.sol#L132  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/AuctionEscapeHatch.sol#L226  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/AuctionEscapeHatch.sol#L234  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/AuctionEscapeHatch.sol#L218   See similar High-severity H03 finding OpenZeppelin\u2019s Audit of Audius (https://blog.openzeppelin.com/audius-contracts-audit/#high) and Medium-severity M01 finding OpenZeppelin\u2019s Audit of UMA Phase 4 (https://blog.openzeppelin.com/uma-audit-phase-4/)  ## Tools Used  None  ## Recommended Mitigation Steps  Add events to all admin/privileged functions that change critical parameters.  "}, {"title": "theft of system profit", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/56", "labels": ["bug", "2 (Med Risk)", "needs additional sponsor input"], "target": "2021-11-malt-findings", "body": "theft of system profit"}, {"title": "Auction.userClaimableArbTokens claimablePerc calculations can be simplified", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/50", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  hyh   # Vulnerability details  ## Impact  Gas is overspent on access and operations.  ## Proof of Concept  ```claimablePerc``` is calculated in two steps, which can be made simpler. https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L294  ## Recommended Mitigation Steps  Now: ``` uint256 totalTokens = auction.commitments.mul(auction.pegPrice).div(auction.finalPrice); uint256 claimablePerc = auction.claimableTokens.mul(auction.pegPrice).div(totalTokens); ```  To be (```totalTokens``` isn't used elsewhere): ``` uint256 claimablePerc = auction.claimableTokens.mul(auction.finalPrice).div(auction.commitments); ```  "}, {"title": "Auction.userClaimableArbTokens nonzero auction.finalPrice check is redundant", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/49", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  hyh   # Vulnerability details  ## Proof of Concept  As there is a check in the beginning of the function that includes the ```auction.finalPrice == 0``` condition: https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L285  ## Recommended Mitigation Steps  The same condition down the line is never true and its check is redundant: https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Auction.sol#L298  "}, {"title": "initialized storage variables are set again in the initializer function ", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/45", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  sabtikw   # Vulnerability details  ## Impact  storage variables are initialized in the contract and overwritten in the initializer function.   ## Proof of Concept Auction.sol L#89 L#164 auctionLength AuctionBurnReserveSkew.sol L#25 auctionAverageLookback MaltDataLab.sol L#69 priceTarget  ## Tools Used  manual review   ## Recommended Mitigation Steps  remove initialization outside of initializer function  "}, {"title": "The Contract Should safeApprove(0) first", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/41", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  defsec   # Vulnerability details  ## Impact  Some tokens (like USDT L199) do not work when changing the allowance from an existing non-zero allowance value. They must first be approved by zero and then the actual allowance must be approved.  ``` IERC20(token).safeApprove(address(operator), 0); IERC20(token).safeApprove(address(operator), amount); ```  ## Proof of Concept  1. Navigate to the following contracts.  ```  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/DexHandlers/UniswapHandler.sol#L167  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/AuctionParticipant.sol#L59  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/StabilizerNode.sol#L252  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/RewardReinvestor.sol#L107 ``` 2.  When trying to re-approve an already approved token, all transactions revert and the protocol cannot be used.  ## Tools Used  None  ## Recommended Mitigation Steps  Approve with a zero amount first before setting the actual amount.  "}, {"title": "Storage Optimization", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/38", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  0x1f8b   # Vulnerability details  ## Impact Cheaper storage.  ## Proof of Concept  The struct AuctionData file Auction.sol is optimizable. It looks like this:  ``` struct AuctionData {   // The full amount of commitments required to return to peg   uint256 fullRequirement;   // total maximum desired commitments to this auction   uint256 maxCommitments;   // Quantity of sale currency committed to this auction   uint256 commitments;   // Malt purchased and burned using current commitments   uint256 maltPurchased;   // Desired starting price for the auction   uint256 startingPrice;   // Desired lowest price for the arbitrage token   uint256 endingPrice;   // Price of arbitrage tokens at conclusion of auction. This is either   // when the duration elapses or the maxCommitments is reached   uint256 finalPrice;   // The peg price for the liquidity pool   uint256 pegPrice;   // Time when auction started   uint256 startingTime;   uint256 endingTime;   // Is the auction currently accepting commitments?   bool active;   // The reserve ratio at the start of the auction   uint256 preAuctionReserveRatio;   // Has this auction been finalized? Meaning any additional stabilizing   // has been done   bool finalized;   // The amount of arb tokens that have been executed and are now claimable   uint256 claimableTokens;   // The finally calculated realBurnBudget   uint256 finalBurnBudget;   // The amount of Malt purchased with realBurnBudget   uint256 finalPurchased;   // A map of all commitments to this auction by specific accounts   mapping(address => AccountCommitment) accountCommitments; } ``` But `active` and `finalized`, the unique boolean values, should be together, otherwise they will spend two slots instead of one. ```   uint256 preAuctionReserveRatio;   bool active;   bool finalized; ```  ## Tools Used  Manual review  ## Recommended Mitigation Steps  "}, {"title": "Index address of events for better filtering", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/31", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  tabish   # Vulnerability details  ## Impact Detailed description of the impact of this finding.  Use `indexed` on address to filter through logs better https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L105 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L112   "}, {"title": "Use bps uniformly", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/30", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  tabish   # Vulnerability details  ## Impact Detailed description of the impact of this finding. Some variables are in form of bps https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L90  while some are not https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L91 https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Auction.sol#L92  As a good programming practice, should use bps everywhere if you accepting it as a unit    "}, {"title": "SafeMath Not Used Nearly At All In MovingAverage.sol", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/21", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  jayjonah8   # Vulnerability details  ## Impact In MovingAverage.sol the safeMath.sol library is imported but I counted at least 25 places in the file where it should be used (Nearly the entire file).  This can result in values wrapping around which has caused devastating effects on many protocols in the past.  These values directly effect the exchangeRate variable given in the stabilize() function in StabilizerNode.sol so they must be treated with care.   ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/MovingAverage.sol#L3  https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/StabilizerNode.sol#L156  ## Tools Used Manual code review   ## Recommended Mitigation Steps The MovingAverage.sol file should be completely reviewed making use of safeMath through out the entire file.  "}, {"title": "Deprecated Function Usage", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/18", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "Deprecated Function Usage"}, {"title": "Should include non-existing contract check", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/9", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  jayjonah8   # Vulnerability details  ## Impact The executeTransaction() function in Timelock.sol does not include a check if the contract being called actually exists. The extcodesize is not used when using .call on addresses directly as per the solidity docs.  This is important because the EVM allows calls to a non-existing contract to always succeed.   ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Timelock.sol#L191  solidity docs: https://docs.soliditylang.org/en/v0.8.10/units-and-global-variables.html#address-related  \"Due to the fact that the EVM considers a call to a non-existing contract to always succeed, Solidity includes an extra check using the extcodesize opcode when performing external calls. This ensures that the contract that is about to be called either actually exists (it contains code) or an exception is raised. The low-level calls which operate on addresses rather than contract instances (i.e. .call(), .delegatecall(), .staticcall(), .send() and .transfer()) do not include this check, which makes them cheaper in terms of gas but also less safe.\"   ## Tools Used Manual code review  ## Recommended Mitigation Steps A check should be included to make sure the contract being called actually exists to avoid making possible errors in the executeTransaction() function  "}, {"title": "Unnecessary event fields", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/5", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  TomFrench   # Vulnerability details  ## Impact  Greater costs of epoch advancement  ## Proof of Concept  The `Advance` event emits the block number and timestamp in its data  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/DAO.sol#L24  These fields are attached to events by default so it's unnecessary to manually emit them (and pay the associated gas costs)  ## Recommended Mitigation Steps  Remove `block` and `timestamp` fields from `Advance` event  "}]