[{"title": "All AMMs have to be past nextFundingTime to update", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/130", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-02-hubble-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/AMM.sol#L348   # Vulnerability details  # Impact  settleFunding calls will revert until all AMMs are ready to be updated.  # Proof of Concept  1. AMM 1 has a nextFundingTime of now. AMM 2 has a nextFundingTime in 30 minutes. AMM 1 won't be able to be updated until after AMM 2's nextFundingTime elapses.  # Mitigation You shouldn't revert at the place mentioned in the links to affected code. Just return so that the other AMMs can still get updated.  "}, {"title": "After debt seizure from InsuranceFund, user can dilute all past participants.", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/129", "labels": ["bug", "2 (Med Risk)", "sponsor disputed"], "target": "2022-02-hubble-findings", "body": "After debt seizure from InsuranceFund, user can dilute all past participants."}, {"title": "Assets sent from MarginAccount to InsuranceFund will be locked forever", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/128", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-02-hubble-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/MarginAccount.sol#L377   # Vulnerability details  # Impact Assets sent from MarginAccount to InsuranceFund will be locked forever  # Proof of Concept The insurance fund doesn't have a way to transfer non-vusd out of the contract.  Assets transferred to the InsuranceFund will be locked forever.  # Mitigation Have a way for governance to sweep tokens to swap them.  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/126", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-02-hubble-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/125", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-02-hubble-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/124", "labels": ["bug", "QA (Quality Assurance)", "disagree with severity", "sponsor confirmed"], "target": "2022-02-hubble-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/120", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-02-hubble-findings", "body": "Gas Optimizations"}, {"title": "denial fo service", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/119", "labels": ["bug", "3 (High Risk)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2022-02-hubble-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/VUSD.sol#L53   # Vulnerability details  processWithdrawals can process limited amount in each call. an attacker can push to withdrawals enormous amount of withdrawals with amount = 0. in order to stop the dos attack and process the withdrawal, the governance needs to spend as much gas as the attacker. if the governance doesn't have enough money to pay for the gas, the withdrawals can't be processed.  ## Proof of Concept Alice wants to attack vusd, she spend 1millions dollars for gas to push as many withdrawals of amount = 0 as she can. if the governance wants to process the deposits after alices empty deposits, they also need to spend at least 1 million dollars for gas in order to process alice's withdrawals first. but the governance doesn't have 1 million dollar so the funds will be locked.  ## Recommended Mitigation Steps set  a minimum amount of withdrawal. e.g. 1 dollar  ```     function withdraw(uint amount) external {         require(amount >= 10 ** 6);         burn(amount);         withdrawals.push(Withdrawal(msg.sender, amount));     } ```  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/118", "labels": ["bug", "duplicate", "QA (Quality Assurance)", "2 (Med Risk)"], "target": "2022-02-hubble-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/117", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-02-hubble-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/115", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-02-hubble-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/114", "labels": ["bug", "duplicate", "QA (Quality Assurance)"], "target": "2022-02-hubble-findings", "body": "QA Report"}, {"title": "liquidation is vulnerable to sandwich attacks", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/113", "labels": ["bug", "2 (Med Risk)", "sponsor disputed"], "target": "2022-02-hubble-findings", "body": "liquidation is vulnerable to sandwich attacks"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/112", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-02-hubble-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/111", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-02-hubble-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/109", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-02-hubble-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/108", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-02-hubble-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/107", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-02-hubble-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/106", "labels": ["bug", "duplicate", "G (Gas Optimization)"], "target": "2022-02-hubble-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/105", "labels": ["bug", "duplicate", "QA (Quality Assurance)"], "target": "2022-02-hubble-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/102", "labels": ["bug", "duplicate", "G (Gas Optimization)"], "target": "2022-02-hubble-findings", "body": "Gas Optimizations"}, {"title": "[WP-H7] `InsuranceFund#syncDeps()` may cause users' fund loss", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/100", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-02-hubble-findings", "body": "[WP-H7] `InsuranceFund#syncDeps()` may cause users' fund loss"}, {"title": "`settleFunding` will exceed block gas with more markets and activity", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/97", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor acknowledged"], "target": "2022-02-hubble-findings", "body": "`settleFunding` will exceed block gas with more markets and activity"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/96", "labels": ["bug", "duplicate", "QA (Quality Assurance)"], "target": "2022-02-hubble-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/95", "labels": ["bug", "duplicate", "G (Gas Optimization)"], "target": "2022-02-hubble-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/94", "labels": ["bug", "duplicate", "QA (Quality Assurance)"], "target": "2022-02-hubble-findings", "body": "QA Report"}, {"title": "Ownership of Swap.vy cannot be transferred", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/93", "labels": ["bug", "2 (Med Risk)", "sponsor disputed"], "target": "2022-02-hubble-findings", "body": "Ownership of Swap.vy cannot be transferred"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/92", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-02-hubble-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/91", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-02-hubble-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/89", "labels": ["bug", "QA (Quality Assurance)", "disagree with severity", "sponsor confirmed"], "target": "2022-02-hubble-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/88", "labels": ["bug", "duplicate", "G (Gas Optimization)"], "target": "2022-02-hubble-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/86", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-02-hubble-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/85", "labels": ["bug", "duplicate", "G (Gas Optimization)"], "target": "2022-02-hubble-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/82", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-02-hubble-findings", "body": "Gas Optimizations"}, {"title": "Update initializer modifier to prevent reentrancy during initialization", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/81", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2022-02-hubble-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-jpegd/blob/main/package.json#L18-L19   # Vulnerability details  ## Impact  The solution uses: ```jsx     \"@openzeppelin/contracts\": \"^4.0.0\",     \"@openzeppelin/contracts-upgradeable\": \"^4.3.2\", ``` These dependencies have a known high severity vulnerability:  - https://security.snyk.io/vuln/SNYK-JS-OPENZEPPELINCONTRACTSUPGRADEABLE-2320177 - https://snyk.io/test/npm/@openzeppelin/contracts-upgradeable/4.3.2#SNYK-JS-OPENZEPPELINCONTRACTSUPGRADEABLE-2320177 - https://snyk.io/test/npm/@openzeppelin/contracts/4.0.0#SNYK-JS-OPENZEPPELINCONTRACTS-2320176  Which makes these contracts vulnerable: ```jsx contracts/helpers/CryptoPunksHelper.sol:   19:     function initialize(address punksAddress) external initializer {  contracts/helpers/EtherRocksHelper.sol:   19:     function initialize(address rocksAddress) external initializer {  contracts/staking/JPEGStaking.sol:   21:     function initialize(IERC20Upgradeable _jpeg) external initializer {  contracts/vaults/FungibleAssetVaultForDAO.sol:   71:     ) external initializer {  contracts/vaults/NFTVault.sol:   149:     ) external initializer { ```  ## Recommended Mitigation Steps Upgrade `@openzeppelin/contracts` and `@openzeppelin/contracts-upgradeable` to version 4.4.1 or higher.  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/79", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-02-hubble-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/78", "labels": ["bug", "QA (Quality Assurance)", "disagree with severity", "sponsor confirmed"], "target": "2022-02-hubble-findings", "body": "QA Report"}, {"title": "USDC blacklisted accounts can DoS the withdrawal system", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/76", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-02-hubble-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/VUSD.sol#L53-L67   # Vulnerability details  ## Impact DoS of USDC withdrawal system  ## Proof of Concept Currently, withdrawals are queued in an array and processed sequentially in a for loop. However, a `safeTransfer()` to USDC blacklisted user will fail. It will also brick the withdrawal system because the blacklisted user is never cleared.  https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/VUSD.sol#L53-L67  ## Tools Used Manual review  ## Recommended Mitigation Steps Possible solutions: 1st solution: Implement 2-step withdrawals:     - In a for loop, increase the user's amount that can be safely withdrawn.     - A user himself withdraws his balance  2st solution: Skip blacklisted users in a processWithdrawals loop  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/74", "labels": ["bug", "duplicate", "QA (Quality Assurance)"], "target": "2022-02-hubble-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/69", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-02-hubble-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/68", "labels": ["bug", "G (Gas Optimization)", "sponsor disputed"], "target": "2022-02-hubble-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/63", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-02-hubble-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/60", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-02-hubble-findings", "body": "Gas Optimizations"}, {"title": "Users are able to front-run bad debt settlements to avoid insurance costs", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/59", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-02-hubble-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/InsuranceFund.sol#L71-L75 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/InsuranceFund.sol#L62-L69   # Vulnerability details  ## Impact  A user is able to front-run the call to `seizeBadDebt()` in `InsuranceFund.sol` to avoid paying the insurance costs.  `seizeBadDebt()` is called by `MarginAccount.settleBadDebt()` which is a public function. When this functions is called the transaction will appear in the mem pool.  A user may then call `InsuranceFund.withdraw()` to withdraw all of their shares. If they do this with a higher gas fee it will likely be processed before the `settleBadDebt()` transaction. In this way they will avoid incurring any cost from the assets being seized.  The impact is that users may gain their share of the insurance funding payments with minimal risk (minimal as there is a change the front-run will not succeed) of having to repay these costs.  ## Proof of Concept  ```     function withdraw(uint _shares) external {         settlePendingObligation();         require(pendingObligation == 0, \"IF.withdraw.pending_obligations\");         uint amount = balance() * _shares / totalSupply();         _burn(msg.sender, _shares);         vusd.safeTransfer(msg.sender, amount);         emit FundsWithdrawn(msg.sender, amount, block.timestamp);     } ```  ```     function seizeBadDebt(uint amount) external onlyMarginAccount {         pendingObligation += amount;         emit BadDebtAccumulated(amount, block.timestamp);         settlePendingObligation();     } ```  ## Recommended Mitigation Steps  Consider making the withdrawals a two step process. The first step requests a withdrawal and marks the time. The second request processes the withdrawal but requires a period of time to elapse since the first step.  To avoid having users constantly having pending withdrawal, each withdrawal should have an expiry time and also a recharge time. The if the second step is not called within expiry amount of time it should be considered invalid. The first step must not be able to be called until recharge time has passed.  Another solution involves a design change where the insurance fund is slowly filled up over time without external deposits. However, this has the disadvantage that bad debts received early in the protocols life time may not have sufficient insurance capital to cover them.  "}, {"title": "AMM Cannot Be `initialize()` Except By Governance", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/51", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-02-hubble-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/AMM.sol#L93-L108 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/AMM.sol#L730-L734 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/legos/Governable.sol#L10-L13   # Vulnerability details  ## Impact  The contact `AMM.sol` cannot be initialize unless it is called from the `_governance` address.  This prevents the use of a deployer account and requires the governance to be able to deploy proxy contracts and encode the required arguements. If this is not feasible then the contract cannot be deployed.  ## Proof of Concept  `initialize()` calls `_setGovernace(_governance);` which will store the governance address.   Following this it will call `syncDeps(_registry);` which has `onlyGovernance` modifier.  Thus, if the `msg.sender` of `initialize()` is not the same as the parameter `_governance` then the initialisation will revert.   ```solidity     function initialize(         address _registry,         address _underlyingAsset,         string memory _name,         address _vamm,         address _governance     ) external initializer {         _setGovernace(_governance);          vamm = IVAMM(_vamm);         underlyingAsset = _underlyingAsset;         name = _name;         fundingBufferPeriod = 15 minutes;          syncDeps(_registry);     } ```  ## Recommended Mitigation Steps  Consider adding the steps manually to `initialize()`. i.e.  ```solidity     function initialize(         address _registry,         address _underlyingAsset,         string memory _name,         address _vamm,         address _governance     ) external initializer {         _setGovernace(_governance);          vamm = IVAMM(_vamm);         underlyingAsset = _underlyingAsset;         name = _name;         fundingBufferPeriod = 15 minutes;          IRegistry registry = IRegistry(_registry);         clearingHouse = registry.clearingHouse();         oracle = IOracle(registry.oracle()); } ```  "}, {"title": "ClearingHouse May Whitelist Duplicate AMMs", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/50", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2022-02-hubble-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L339-L342 https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L269-L282   # Vulnerability details  ## Impact  `ClearingHouse.sol` allows the Governance protocol to whitelist `AMM.sol` contracts. These contracts allow users to earn profits based on the price of a base asset against a quote asset.  It is possible to add the same `AMM` twice in the function `whitelistAmm()`. The impact is that unrealized profits will be counted multiple times. As a result the liquidation calculations will be incorrect, potentially allowing users to trade while insolvent or incorrectly liquidating solvent users.  Note `whitelistAmm()` may only be called by Governance.  ## Proof of Concept  The function `getTotalNotionalPositionAndUnrealizedPnl()` will iterate over all `amms` summing the `unrealizedPnl`  and `notinoalPosition`, thus if an `amm` is repeated the `unrealizedPnl` and `notionalPosition` of that asset will be counted multiple times.  This is used in `_calcMarginFraction()` which calculates a users margin as a fraction of the total position. The margin fraction is used to determine if a user is liquitable or is allowed to open new positions.   ## Recommended Mitigation Steps  Consider ensuring the `AMM` does not already exist in the list when adding a new `AMM`.  ```     function whitelistAmm(address _amm) external onlyGovernance {         for (uint256 i; i < amm.length; i++) {             require(amm[i] != IAMM(_amm), \"AMM already whitelisted\");         }         emit MarketAdded(amms.length, _amm);         amms.push(IAMM(_amm));     } ```  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/48", "labels": ["bug", "QA (Quality Assurance)", "disagree with severity", "sponsor acknowledged"], "target": "2022-02-hubble-findings", "body": "QA Report"}, {"title": "Liquidations can be run on the bogus Oracle prices", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/46", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-02-hubble-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/Oracle.sol#L24-L35   # Vulnerability details  ## Impact  If the price feed is manipulated in any way or there is any malfunction based volatility on the market, a malicious user can use this to liquidate a healthy position.  An attacker can setup a monitoring of the used Oracle feed and act on observing a price outbreak (for example, zero price, which is usually a subject to filtration), liquidating the trader position which is perfectly healthy otherwise, obtaining the collateral with a substantial discount at the expense of the trader.  The same is for a flash crash kind of scenario, i.e. a price outbreak of any nature will allow for non-market liquidation by an attacker, who has the incentives to setup such a monitoring and act on such an outbreak, knowing that it will not be smoothed or filtered out, allowing a liquidation at a non-market price that happen to be printed in the Oracle feed  ## Proof of Concept  Oracle.getUnderlyingPrice just passes on the latest Oracle answer, not checking it anyhow:  https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/Oracle.sol#L24-L35  It is then used in liquidation triggers providing isLiquidatable and _getLiquidationInfo functions:  https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/MarginAccount.sol#L249  https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/MarginAccount.sol#L465  ## Recommended Mitigation Steps  Add a non-zero Oracle price check, possibly add an additional Oracle feed information usage to control that the price is fresh. Please consult the Chainlink for that as OCR introduction might have changed the state of the art approach (i.e. whether and how to use latestRoundData returned data):  https://docs.chain.link/docs/off-chain-reporting/  Regarding any price spikes it is straightforward to construct a mitigation mechanics for such cases, so the system will be affected by sustainable price movements only.  As price outrages provide a substantial attack surface for the project it's worth adding some complexity to the implementation.  One of the approaches is to track both current and TWAP prices, and condition all state changing actions, including liquidations, on the current price being within a threshold of the TWAP one. If the liquidation margin level is conservative enough and TWAP window is small enough this is safe for the overall stability of the system, while providing substantial mitigation mechanics by allowing state changes on the locally calm market only.  Another approach is to introduce time delay between liquidation request and actual liquidation. Again, conservative enough margin level plus small enough delay keeps the system safe, while requiring that market conditions allow for liquidation both at request time and at execution time provides ample filtration against price feed outbreaks   "}, {"title": "`Oracle.getUnderlyingPrice` could have wrong decimals", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/44", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed"], "target": "2022-02-hubble-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/Oracle.sol#L34   # Vulnerability details  ## Impact The `Oracle.getUnderlyingPrice` function divides the chainlink price by `100`. It probably assumes that the answer for the underlying is in 8 decimals but then wants to reduce it for 6 decimals to match USDC.  However, arbitrary `underlying` tokens are used and the chainlink oracles can have different decimals.  ## Recommended Mitigation Steps While most USD price feeds use 8 decimals, it's better to take the on-chain reported decimals into account by doing `AggregatorV3Interface(chainLinkAggregatorMap[underlying]).decimals()`, see [Chainlink docs](https://docs.chain.link/docs/get-the-latest-price/#getting-a-different-price-denomination). The price should then be scaled down to 6 decimals.   "}, {"title": "InsuranceFund depositors can be priced out & deposits can be stolen", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/42", "labels": ["bug", "3 (High Risk)"], "target": "2022-02-hubble-findings", "body": "InsuranceFund depositors can be priced out & deposits can be stolen"}, {"title": "ClearingHouse margin calculations will break up if an AMM returning non-6 decimals positions be white listed", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/37", "labels": ["bug", "2 (Med Risk)", "sponsor disputed"], "target": "2022-02-hubble-findings", "body": "ClearingHouse margin calculations will break up if an AMM returning non-6 decimals positions be white listed"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/35", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-02-hubble-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/34", "labels": ["bug", "duplicate", "G (Gas Optimization)"], "target": "2022-02-hubble-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/33", "labels": ["bug", "duplicate", "QA (Quality Assurance)"], "target": "2022-02-hubble-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/32", "labels": ["bug", "duplicate", "QA (Quality Assurance)", "disagree with severity", "sponsor confirmed"], "target": "2022-02-hubble-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/30", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-02-hubble-findings", "body": "QA Report"}, {"title": "Blocking of the VUSD withdrawals is possible if the reserve token doesn't support zero value transfers", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/29", "labels": ["bug", "2 (Med Risk)", "sponsor disputed"], "target": "2022-02-hubble-findings", "body": "Blocking of the VUSD withdrawals is possible if the reserve token doesn't support zero value transfers"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/19", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-02-hubble-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/18", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-02-hubble-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/17", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-02-hubble-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/16", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-02-hubble-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/12", "labels": ["bug", "duplicate", "G (Gas Optimization)"], "target": "2022-02-hubble-findings", "body": "Gas Optimizations"}, {"title": "Hidden governance", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/11", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-02-hubble-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/VUSD.sol#L11   # Vulnerability details  ## Impact The contract use two governance model, one looks hidden.  ## Proof of Concept The VUSD contract uses `VanillaGovernable` but inherits from `ERC20PresetMinterPauserUpgradeable` and this contract uses roles to use some administrative methods like `pause` or `mint`.  This two-governance model does not seem necessary and can hide or raise suspicion about a rogue pool, thus damaging the user's trust.  ## Recommended Mitigation Steps Unify governance in only one, VanillaGovernable or role based.  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/7", "labels": ["bug", "duplicate", "QA (Quality Assurance)"], "target": "2022-02-hubble-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/6", "labels": ["bug", "duplicate", "G (Gas Optimization)"], "target": "2022-02-hubble-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/3", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-02-hubble-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-hubble-findings/issues/2", "labels": ["bug", "duplicate", "G (Gas Optimization)"], "target": "2022-02-hubble-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-phuture-findings/issues/99", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-phuture-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-phuture-findings/issues/98", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-phuture-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-phuture-findings/issues/95", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-phuture-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-phuture-findings/issues/94", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-phuture-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-phuture-findings/issues/93", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-phuture-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-phuture-findings/issues/92", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-phuture-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-phuture-findings/issues/91", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-phuture-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-phuture-findings/issues/89", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-phuture-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-phuture-findings/issues/88", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-phuture-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-phuture-findings/issues/86", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-phuture-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-phuture-findings/issues/85", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-phuture-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-phuture-findings/issues/84", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-phuture-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-phuture-findings/issues/83", "labels": ["bug", "G (Gas Optimization)", "sponsor disputed"], "target": "2022-04-phuture-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-phuture-findings/issues/82", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-phuture-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-phuture-findings/issues/81", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-phuture-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-phuture-findings/issues/80", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-phuture-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-phuture-findings/issues/79", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-phuture-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-phuture-findings/issues/78", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-phuture-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-phuture-findings/issues/77", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-phuture-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-phuture-findings/issues/76", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-phuture-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-phuture-findings/issues/75", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-phuture-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-phuture-findings/issues/73", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-phuture-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-phuture-findings/issues/72", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-phuture-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-phuture-findings/issues/71", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-phuture-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-phuture-findings/issues/70", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-phuture-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-phuture-findings/issues/69", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-phuture-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-phuture-findings/issues/68", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-phuture-findings", "body": "QA Report"}, {"title": "`UniswapV2PriceOracle.sol` `currentCumulativePrices()` will revert when `priceCumulative` addition overflow", "html_url": "https://github.com/code-423n4/2022-04-phuture-findings/issues/62", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2022-04-phuture-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-phuture/blob/594459d0865fb6603ba388b53f3f01648f5bb6fb/contracts/UniswapV2PriceOracle.sol#L62   # Vulnerability details  https://github.com/code-423n4/2022-04-phuture/blob/594459d0865fb6603ba388b53f3f01648f5bb6fb/contracts/UniswapV2PriceOracle.sol#L62  ```solidity (uint price0Cumulative, uint price1Cumulative, uint32 blockTimestamp) = address(pair).currentCumulativePrices(); ```  Because the Solidity version used by the current implementation of `UniswapV2OracleLibrary.sol` is `>=0.8.7`, and there are some breaking changes in Solidity v0.8.0:  > Arithmetic operations revert on underflow and overflow.   Ref: https://docs.soliditylang.org/en/v0.8.13/080-breaking-changes.html#silent-changes-of-the-semantics  While in `UniswapV2OracleLibrary.sol`, subtraction overflow is desired at `blockTimestamp - blockTimestampLast` in `currentCumulativePrices()`:  https://github.com/Uniswap/v2-periphery/blob/master/contracts/libraries/UniswapV2OracleLibrary.sol#L25-L33  ```solidity if (blockTimestampLast != blockTimestamp) {     // subtraction overflow is desired     uint32 timeElapsed = blockTimestamp - blockTimestampLast;     // addition overflow is desired     // counterfactual     price0Cumulative += uint(FixedPoint.fraction(reserve1, reserve0)._x) * timeElapsed;     // counterfactual     price1Cumulative += uint(FixedPoint.fraction(reserve0, reserve1)._x) * timeElapsed; } ```  In another word, `Uniswap/v2-periphery/contracts/libraries/UniswapV2OracleLibrary` only works at solidity < `0.8.0`.  As a result, when `price0Cumulative` or `price1Cumulative` is big enough, `currentCumulativePrices` will revert due to overflow.  ### Impact  Since the overflow is desired in the original version, and it's broken because of using Solidity version >0.8. The `UniswapV2PriceOracle` contract will break when the desired overflow happens, and further breaks other parts of the system that relies on `UniswapV2PriceOracle`.  ### Recommendation  Note: this recommended fix requires a fork of the library contract provided by Uniswap.  Change to:  ```solidity if (blockTimestampLast != blockTimestamp) {     unchecked {         // subtraction overflow is desired         uint32 timeElapsed = blockTimestamp - blockTimestampLast;         // addition overflow is desired         // counterfactual         price0Cumulative += uint(FixedPoint.fraction(reserve1, reserve0)._x) * timeElapsed;         // counterfactual         price1Cumulative += uint(FixedPoint.fraction(reserve0, reserve1)._x) * timeElapsed;     } } ```  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-phuture-findings/issues/61", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-phuture-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-phuture-findings/issues/59", "labels": ["bug", "G (Gas Optimization)", "sponsor disputed"], "target": "2022-04-phuture-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-phuture-findings/issues/58", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-phuture-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-phuture-findings/issues/57", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-phuture-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-phuture-findings/issues/56", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-phuture-findings", "body": "QA Report"}, {"title": "Index managers can rug user funds", "html_url": "https://github.com/code-423n4/2022-04-phuture-findings/issues/55", "labels": ["bug", "2 (Med Risk)"], "target": "2022-04-phuture-findings", "body": "Index managers can rug user funds"}, {"title": "Inactive skipped assets can be drained from the index", "html_url": "https://github.com/code-423n4/2022-04-phuture-findings/issues/54", "labels": ["bug", "2 (Med Risk)"], "target": "2022-04-phuture-findings", "body": "Inactive skipped assets can be drained from the index"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-phuture-findings/issues/50", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-phuture-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-phuture-findings/issues/49", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-phuture-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-phuture-findings/issues/47", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-phuture-findings", "body": "Gas Optimizations"}, {"title": "Tokens with fee on transfer are not supported", "html_url": "https://github.com/code-423n4/2022-04-phuture-findings/issues/43", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-04-phuture-findings", "body": "Tokens with fee on transfer are not supported"}, {"title": "Wrong requirement in reweight function (ManagedIndexReweightingLogic.sol)", "html_url": "https://github.com/code-423n4/2022-04-phuture-findings/issues/40", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-04-phuture-findings", "body": "# Lines of code   https://github.com/code-423n4/2022-04-phuture/blob/594459d0865fb6603ba388b53f3f01648f5bb6fb/contracts/ManagedIndexReweightingLogic.sol#L32 https://github.com/code-423n4/2022-04-phuture/blob/594459d0865fb6603ba388b53f3f01648f5bb6fb/contracts/interfaces/IIndexRegistry.sol#L19   # Vulnerability details  ## Impact The list of assets won't be changed after reweight because of reverted tx   ## Proof of Concept  ```require(_updatedAssets.length <= IIndexRegistry(registry).maxComponents())``` when [reweight](https://github.com/code-423n4/2022-04-phuture/blob/594459d0865fb6603ba388b53f3f01648f5bb6fb/contracts/ManagedIndexReweightingLogic.sol#L32) is not true, because as in the [doc](https://github.com/code-423n4/2022-04-phuture/blob/594459d0865fb6603ba388b53f3f01648f5bb6fb/contracts/interfaces/IIndexRegistry.sol#L19),  ```maxComponent``` is the maximum assets for an index, but ```_updatedAssets``` also contain the assets that you want to remove. So the comparision make no sense  ## Tools Used manual review   ## Recommended Mitigation Steps Require ```assets.length() <= IIndexRegistry(registry).maxComponents()``` at the end of function instead    "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-phuture-findings/issues/39", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-phuture-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-phuture-findings/issues/38", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-phuture-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-phuture-findings/issues/36", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-phuture-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-phuture-findings/issues/35", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-phuture-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-phuture-findings/issues/29", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-phuture-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-phuture-findings/issues/28", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-phuture-findings", "body": "QA Report"}, {"title": "Wrong shareChange() function (vToken.sol)", "html_url": "https://github.com/code-423n4/2022-04-phuture-findings/issues/26", "labels": ["bug", "2 (Med Risk)"], "target": "2022-04-phuture-findings", "body": "Wrong shareChange() function (vToken.sol)"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-phuture-findings/issues/25", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-phuture-findings", "body": "Gas Optimizations"}, {"title": "Duplicate asset can be added", "html_url": "https://github.com/code-423n4/2022-04-phuture-findings/issues/23", "labels": ["bug", "2 (Med Risk)"], "target": "2022-04-phuture-findings", "body": "Duplicate asset can be added"}, {"title": "Asset Manager can update existing _assetAggregator", "html_url": "https://github.com/code-423n4/2022-04-phuture-findings/issues/22", "labels": ["bug", "2 (Med Risk)"], "target": "2022-04-phuture-findings", "body": "Asset Manager can update existing _assetAggregator"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-phuture-findings/issues/21", "labels": ["bug", "G (Gas Optimization)", "sponsor disputed"], "target": "2022-04-phuture-findings", "body": "Gas Optimizations"}, {"title": "IndexLogic: An attacker can mint tokens for himself using assets deposited by other users", "html_url": "https://github.com/code-423n4/2022-04-phuture-findings/issues/19", "labels": ["bug", "3 (High Risk)"], "target": "2022-04-phuture-findings", "body": "IndexLogic: An attacker can mint tokens for himself using assets deposited by other users"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-phuture-findings/issues/18", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-phuture-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-phuture-findings/issues/17", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-phuture-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-phuture-findings/issues/16", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-phuture-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-phuture-findings/issues/14", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-phuture-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-phuture-findings/issues/13", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-phuture-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-phuture-findings/issues/12", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-phuture-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-phuture-findings/issues/11", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-phuture-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-phuture-findings/issues/10", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-phuture-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-04-phuture-findings/issues/8", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-04-phuture-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-04-phuture-findings/issues/7", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-04-phuture-findings", "body": "Gas Optimizations"}, {"title": "Chainlink's latestRoundData might return stale or incorrect results", "html_url": "https://github.com/code-423n4/2022-04-phuture-findings/issues/1", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-04-phuture-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-backd/blob/main/backd/contracts/oracles/ChainlinkOracleProvider.sol#L55   # Vulnerability details  ## Impact On ChainlinkOracleProvider.sol and ChainlinkUsdWrapper.sol , we are using latestRoundData, but there is no check if the return value indicates stale data. ```     function _ethPrice() private view returns (int256) {         (, int256 answer, , , ) = _ethOracle.latestRoundData();         return answer;     } ...     function getPriceUSD(address asset) public view override returns (uint256) {         address feed = feeds[asset];         require(feed != address(0), Error.ASSET_NOT_SUPPORTED);          (, int256 answer, , uint256 updatedAt, ) = AggregatorV2V3Interface(feed).latestRoundData();          require(block.timestamp <= updatedAt + stalePriceDelay, Error.STALE_PRICE);         require(answer >= 0, Error.NEGATIVE_PRICE);          uint256 price = uint256(answer);         uint8 decimals = AggregatorV2V3Interface(feed).decimals();         return price.scaleFrom(decimals);     } ``` This could lead to stale prices according to the Chainlink documentation:  https://docs.chain.link/docs/historical-price-data/#historical-rounds https://docs.chain.link/docs/faq/#how-can-i-check-if-the-answer-to-a-round-is-being-carried-over-from-a-previous-round ## Proof of Concept https://github.com/code-423n4/2022-04-backd/blob/main/backd/contracts/oracles/ChainlinkOracleProvider.sol#L55 https://github.com/code-423n4/2022-04-backd/blob/main/backd/contracts/oracles/ChainlinkUsdWrapper.sol#L64 ## Tools Used None ## Recommended Mitigation Steps ```     function _ethPrice() private view returns (int256) {         (uint80 roundID, int256 answer, , uint256 timestamp, uint80 answeredInRound) = _ethOracle.latestRoundData();         require(answeredInRound >= roundID, \"Stale price\");         require(timestamp != 0,\"Round not complete\");         require(answer > 0,\"Chainlink answer reporting 0\");         return answer;     } ...     function getPriceUSD(address asset) public view override returns (uint256) {         address feed = feeds[asset];         require(feed != address(0), Error.ASSET_NOT_SUPPORTED);         (uint80 roundID, int256 answer, , uint256 updatedAt, uint80 answeredInRound) = AggregatorV2V3Interface(feed).latestRoundData();         require(answeredInRound >= roundID, \"Stale price\");         require(answer > 0,\" Error.NEGATIVE_PRICE\");         require(block.timestamp <= updatedAt + stalePriceDelay, Error.STALE_PRICE);          uint256 price = uint256(answer);         uint8 decimals = AggregatorV2V3Interface(feed).decimals();         return price.scaleFrom(decimals);     }  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-pooltogether-findings/issues/48", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-pooltogether-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-pooltogether-findings/issues/45", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-pooltogether-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-pooltogether-findings/issues/44", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-pooltogether-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-pooltogether-findings/issues/41", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-pooltogether-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-pooltogether-findings/issues/40", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-02-pooltogether-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-pooltogether-findings/issues/39", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-pooltogether-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-pooltogether-findings/issues/38", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-02-pooltogether-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-pooltogether-findings/issues/37", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-pooltogether-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-pooltogether-findings/issues/36", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-pooltogether-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-pooltogether-findings/issues/35", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-02-pooltogether-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-pooltogether-findings/issues/33", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-02-pooltogether-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-pooltogether-findings/issues/32", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-pooltogether-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-pooltogether-findings/issues/31", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-pooltogether-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-pooltogether-findings/issues/30", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-pooltogether-findings", "body": "Gas Optimizations"}, {"title": "QA report", "html_url": "https://github.com/code-423n4/2022-02-pooltogether-findings/issues/28", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-02-pooltogether-findings", "body": "QA report"}, {"title": "QA report", "html_url": "https://github.com/code-423n4/2022-02-pooltogether-findings/issues/27", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-02-pooltogether-findings", "body": "QA report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-pooltogether-findings/issues/25", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-pooltogether-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-pooltogether-findings/issues/22", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-pooltogether-findings", "body": "Gas Optimizations"}, {"title": "`permitAndMulticall()` May Be Used to Steal Funds Or as a Denial Of Service if `_from` Is Not The Message Sender", "html_url": "https://github.com/code-423n4/2022-02-pooltogether-findings/issues/20", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-02-pooltogether-findings", "body": "# Lines of code  https://github.com/pooltogether/v4-twab-delegator/blob/2b6d42506187dd7096043e2dfec65fa06ab18577/contracts/PermitAndMulticall.sol#L46-L64 https://github.com/pooltogether/v4-twab-delegator/blob/2b6d42506187dd7096043e2dfec65fa06ab18577/contracts/PermitAndMulticall.sol#L31-L37 https://github.com/pooltogether/v4-twab-delegator/blob/2b6d42506187dd7096043e2dfec65fa06ab18577/contracts/TWABDelegator.sol#L438-L445   # Vulnerability details  ## Impact  When the `_from` address is not the `msg.sender` `_multiCall()` will be made on behalf of the `msg.sender`. As a result each of the functions called by `multiCall()` will be made on behalf of `msg.sender` and not `_from`.  If functions such as `transfer()` or `unstake()` are called `msg.sender` will be the original caller which would transfer the attacker the funds if the `to` field is set to an attackers address.  Furthermore, if an attacker we to call `permitAndMulticall()` before the `_from` user they may use their signature and nonce combination. As a nonce is only allowe to be used once the siganture will no longer be valid and `_permitToken.permit()` will fail on the second call.  An attacker may use this as a Denial of Service (DoS) attack by continually front-running `permitAndCall()` using other users signatures.  ## Proof of Concept  ```   function _multicall(bytes[] calldata _data) internal virtual returns (bytes[] memory results) {     results = new bytes[](_data.length);     for (uint256 i = 0; i < _data.length; i++) {       results[i] = Address.functionDelegateCall(address(this), _data[i]);     }     return results;   } ```  ```   function _permitAndMulticall(     IERC20Permit _permitToken,     address _from,     uint256 _amount,     Signature calldata _permitSignature,     bytes[] calldata _data   ) internal {     _permitToken.permit(       _from,       address(this),       _amount,       _permitSignature.deadline,       _permitSignature.v,       _permitSignature.r,       _permitSignature.s     );      _multicall(_data);   } ```  ## Recommended Mitigation Steps  Consider updating the `_from` field to be the `msg.sender` in `permitAndMulticall()` (or alternatively do this in `_permitAndMulticall()` to save some gas).  ```   function permitAndMulticall(     uint256 _amount,     Signature calldata _permitSignature,     bytes[] calldata _data   ) external {     _permitAndMulticall(IERC20Permit(address(ticket)), msg.sender, _amount, _permitSignature, _data);   } ```  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-pooltogether-findings/issues/19", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-02-pooltogether-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-pooltogether-findings/issues/17", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-pooltogether-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-pooltogether-findings/issues/16", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-02-pooltogether-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-pooltogether-findings/issues/15", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-02-pooltogether-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-pooltogether-findings/issues/14", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-02-pooltogether-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-pooltogether-findings/issues/10", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-02-pooltogether-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-pooltogether-findings/issues/9", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-02-pooltogether-findings", "body": "Gas Optimizations"}, {"title": "QA report", "html_url": "https://github.com/code-423n4/2022-02-pooltogether-findings/issues/1", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-02-pooltogether-findings", "body": "QA report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-foundation-findings/issues/89", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-02-foundation-findings", "body": "QA Report"}, {"title": "`adminAccountMigration()` Does Not Update `buyPrice.seller`", "html_url": "https://github.com/code-423n4/2022-02-foundation-findings/issues/87", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-02-foundation-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketReserveAuction.sol#L263-L292 https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketBuyPrice.sol#L125-L141   # Vulnerability details  ## Impact  The `adminAccountMigration()` function is called by the operator role to update all sellers' auctions. The `auction.seller` account is updated to the new address, however, the protocol fails to update `buyPrice.seller`. As a result, the protocol is put in a deadlock situation where the new address cannot cancel the auction and withdraw their NFT without the compromised account first cancelling the buy price and vice-versa. This is only recoverable if the new account is migrated back to the compromised account and then `cancelBuyPrice()` is called before migrating back.  ## Proof of Concept  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider invalidating the buy offer before account migration.  "}, {"title": "`_getCreatorPaymentInfo()` is Not Equipped to Handle Reverts on an Unbounded `_recipients` Array", "html_url": "https://github.com/code-423n4/2022-02-foundation-findings/issues/85", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-02-foundation-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketCreators.sol#L49-L251   # Vulnerability details  ## Impact  The `_getCreatorPaymentInfo()` function is utilised by `_distributeFunds()` whenever an NFT sale is made. The function uses `try` and `catch` statements to handle bad API endpoints. As such, a revert in this function would lead to NFTs that are locked in the contract. Some API endpoints receive an array of recipient addresses which are iterated over. If for whatever reason the function reverts inside of a `try` statement, the revert is actually not handled and it will not fall through to the empty `catch` statement.  ## Proof of Concept  The end result is that valid and honest NFT contracts may revert if the call runs out of gas due to an unbounded `_recipients` array. `try` statements are only able to handle external calls.  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider bounding the number of iterations to `MAX_ROYALTY_RECIPIENTS_INDEX` as this is already enforced by `_distributeFunds()`. It may be useful to identify other areas where the `try` statement will not handle reverts on internal calls.  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-foundation-findings/issues/84", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-02-foundation-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-foundation-findings/issues/83", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-foundation-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-foundation-findings/issues/81", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-02-foundation-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-foundation-findings/issues/80", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-02-foundation-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-foundation-findings/issues/79", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-02-foundation-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-foundation-findings/issues/78", "labels": ["bug", "G (Gas Optimization)", "sponsor disputed"], "target": "2022-02-foundation-findings", "body": "Gas Optimizations"}, {"title": "`buyFromPrivateSaleFor()` Will Fail if The Buyer Has Insufficient Balance Due to an Open Offer on The Same NFT", "html_url": "https://github.com/code-423n4/2022-02-foundation-findings/issues/77", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-02-foundation-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketPrivateSale.sol#L143-L150   # Vulnerability details  ## Impact  The `buyFromPrivateSaleFor()` function allows sellers to make private sales to users. If insufficient `ETH` is provided to the function call, the protocol will attempt to withdraw the amount difference from the user's unlocked balance. However, if the same user has an open offer on the same NFT, then these funds will remain locked until expiration. As a result, the user cannot make use of these locked funds even though they may be needed for a successful sale.  ## Proof of Concept  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider adding a `_cancelBuyersOffer()` call to the `buyFromPrivateSaleFor()` function. This should be added only to the case where insufficient `ETH` was provided to the trade. By cancelling the buyer's offer on the same NFT, we can guarantee that the user has access to the correct amount of funds.  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-foundation-findings/issues/75", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-foundation-findings", "body": "Gas Optimizations"}, {"title": "There is no Support For The Trading of Cryptopunks", "html_url": "https://github.com/code-423n4/2022-02-foundation-findings/issues/74", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-02-foundation-findings", "body": "There is no Support For The Trading of Cryptopunks"}, {"title": "Fees Are Incorrectly Charged on Unfinalized NFT Sales", "html_url": "https://github.com/code-423n4/2022-02-foundation-findings/issues/73", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-02-foundation-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketOffer.sol#L255-L271 https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketReserveAuction.sol#L557 https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketReserveAuction.sol#L510-L515 https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketFees.sol#L188-L189   # Vulnerability details  ## Impact  Once an auction has ended, the highest bidder now has sole rights to the underlying NFT. By finalizing the auction, fees are charged on the sale and the NFT is transferred to `auction.bidder`. However, if `auction.bidder` accepts an offer before finalization, fees will be charged on the `auction.bidder` sale before the original sale. As a result, it is possible to avoid paying the primary foundation fee as a creator if the NFT is sold by `auction.bidder` before finalization.  ## Proof of Concept  Consider the following scenario: - Alice creates an auction and is the NFT creator. - Bob bids on the auction and is the highest bidder. - The auction ends but Alice leaves it in an unfinalized state. - Carol makes an offer on the NFT which Bob accepts. - `_acceptOffer()` will distribute funds on the sale between Bob and Carol before distributing funds on the sale between Alice and Bob. - The first call to `_distributeFunds()` will set the `_nftContractToTokenIdToFirstSaleCompleted` to true, meaning that future sales will only be charged the secondary foundation fee.  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Ensure the `_nftContractToTokenIdToFirstSaleCompleted` is correctly tracked. It might be useful to ensure the distribution of funds are in the order of when the trades occurred. For example, an unfinalized auction should always have its fees paid before other sales.  "}, {"title": "EIP-712 signatures can be re-used in private sales", "html_url": "https://github.com/code-423n4/2022-02-foundation-findings/issues/68", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-02-foundation-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketPrivateSale.sol#L123-L174   # Vulnerability details  ## Impact Within a NFTMarketPrivateSale contract, buyers are allowed to purchase a seller's NFT. This is done through a seller providing a buyer a EIP-712 signature. The buyer can then call `#buyFromPrivateSaleFor` providing the v, r, and s values of the signature as well as any additional details to generate the message hash. If the signature is valid, then the NFT is transferred to the buyer.   The problem with the code is that EIP-712 signatures can be re-used within a small range of time assuming that the original seller takes back ownership of the NFT. This is because the NFTMarketPrivateSale#buyFromPrivateSaleFor method has no checks to determine if the EIP-712 signature has been used before.   ## Proof of Concept  Consider the following example:  1. Joe the NFT owner sells a NFT to the malicious buyer Rachel via a private sale.  2. Rachel through this private sale obtains the EIP-712 signature and uses it to purchase a NFT. 3. Joe the NFT owner purchases back the NFT within two days of the original sale to Rachel. 4. Joe the NFT owner puts the NFT back on sale. 5. Rachel, who has the original EIP-712 signature, can re-purchase the NFT by calling `#buyFromPrivateSaleFor` again with the same parameters they provided in the original private sale purchase in step 1.  The `#buyFromPrivateSaleFor` [function](https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketPrivateSale.sol#L123) runs several validation checks before transferring the NFT over to the buyer. The validations are as follows:  1. L#132 - The signature has expired. 2. L#135 - The deadline is beyond 48 hours from now. 3. L#143 - The amount argument is greater than msg.value. 4. L#149 - The msg.value is greater than the amount set. 5. L#171 - This checks that the EIP-712 signature comes from the NFT seller.  As you can see, there are no checks that the EIP-712 signature has been used before. If the original NFT seller purchases back the NFT, then they are susceptible to having the original buyer taking back the NFT. This can be problematic if the NFT has risen in value, as the original buyer can utilize the same purchase amount from the first transaction in this malicious transaction.  ## Tools Used Pen and paper  ## Recommended Mitigation Steps Most contracts utilize nonces when generating EIP-712 signatures to ensure that the contract hasn't been used for. When a nonce is injected into a signature, it makes it impossible for re-use, assuming of course the nonce feature is done correctly.  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-foundation-findings/issues/66", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-02-foundation-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-foundation-findings/issues/65", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-foundation-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-foundation-findings/issues/64", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-02-foundation-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-foundation-findings/issues/63", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-foundation-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-foundation-findings/issues/61", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-02-foundation-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-foundation-findings/issues/60", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-02-foundation-findings", "body": "QA Report"}, {"title": "[WP-M6] Inappropriate support of EIP-2981", "html_url": "https://github.com/code-423n4/2022-02-foundation-findings/issues/58", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-02-foundation-findings", "body": "[WP-M6] Inappropriate support of EIP-2981"}, {"title": "[WP-M5] Royalties can be distribution unfairly among `creatorRecipients` for NFT contracts with non-standard `getRoyalties()` returns", "html_url": "https://github.com/code-423n4/2022-02-foundation-findings/issues/57", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-02-foundation-findings", "body": "[WP-M5] Royalties can be distribution unfairly among `creatorRecipients` for NFT contracts with non-standard `getRoyalties()` returns"}, {"title": "QA report", "html_url": "https://github.com/code-423n4/2022-02-foundation-findings/issues/56", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-02-foundation-findings", "body": "QA report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-foundation-findings/issues/54", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-foundation-findings", "body": "Gas Optimizations"}, {"title": "Upgradable escrow contract", "html_url": "https://github.com/code-423n4/2022-02-foundation-findings/issues/53", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-02-foundation-findings", "body": "Upgradable escrow contract"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-foundation-findings/issues/52", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-02-foundation-findings", "body": "QA Report"}, {"title": "Escrowed NFT can be stolen by anyone if no active buyPrice or auction exists for it", "html_url": "https://github.com/code-423n4/2022-02-foundation-findings/issues/51", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-02-foundation-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketCore.sol#L77-L87   # Vulnerability details     ## Impact  If a NFT happens to be in escrow with neither buyPrice, nor auction being initialised for it, there is a way to obtain it for free by any actor via `makeOffer`, `acceptOffer` combination.  I.e. a malicious user can track the FNDNFTMarket contract and obtain any NFT from it for which there are no buyPrice or auction structures initialised. For example, if a NFT is mistakenly sent to the contract, an attacker can immediately steal it.  This will happen as NFT is being guarded by buyPrice and auction structures only. The severity here is medium as normal usage of the system imply that either one of them is initialised (NFT was sent to escrow as a part of `setBuyPrice` or `createReserveAuction`, and so one of the structures is present), so this seems to leave only mistakenly sent assets exposed.  ## Proof of Concept  An attacker can make a tiny offer with `makeOffer`:  https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketOffer.sol#L189  Then call `acceptOffer`, which will lead to `_acceptOffer`.  Direct NFT transfer will fail in `_acceptOffer` as the NFT is being held by the contract and `_transferFromEscrow` will be called instead:  https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketOffer.sol#L262-L271  `_transferFromEscrow` calls will proceed according to the FNDNFTMarket defined order: ``` function _transferFromEscrow( ... ) internal override(NFTMarketCore, NFTMarketReserveAuction, NFTMarketBuyPrice, NFTMarketOffer) {    super._transferFromEscrow(nftContract, tokenId, recipient, seller); } ```  If there are no corresponding structures, the NFTMarketOffer, NFTMarketBuyPrice and NFTMarketReserveAuction versions of `_transferFromEscrow` will pass through the call to NFTMarketCore's plain transfer implementation:  https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketCore.sol#L77-L87  This will effectively transfer the NFT to the attacker, which will pay gas costs and an arbitrary small offer price for it.  ## Recommended Mitigation Steps  Consider adding additional checks to control who can obtain unallocated NFTs from the contract.  Protocol controlled entity can handle such cases manually by initial sender's request.  "}, {"title": "An offer made after auction end can be stolen by an auction winner", "html_url": "https://github.com/code-423n4/2022-02-foundation-findings/issues/49", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-02-foundation-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketReserveAuction.sol#L556-L560   # Vulnerability details   ## Impact  An Offer which is made for an NFT when auction has ended, but its winner hasn't received the NFT yet, can be stolen by this winner as `_transferFromEscrow` being called by `_acceptOffer` will transfer the NFT to the winner, finalising the auction, while no transfer to the user who made the offer will happen.  This way the auction winner will obtain both the NFT and the offer amount after the fees at no additional cost, at the expense of the user who made the offer.  ## Proof of Concept  When an auction has ended, there is a possibility to make the offers for an auctioned NFT as:  `makeOffer` checks `_isInActiveAuction`:  https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketOffer.sol#L200  `_isInActiveAuction` returns false when `auctionIdToAuction[auctionId].endTime < block.timestamp`, so `makeOffer` above can proceed:  https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketReserveAuction.sol#L666-L669  Then, the auction winner can call `acceptOffer -> _acceptOffer` (or `setBuyPrice -> _autoAcceptOffer -> _acceptOffer`).  `_acceptOffer` will try to transfer directly, and then calls `_transferFromEscrow`:  https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketOffer.sol#L262-L271  If the auction has ended, but a winner hasn't picked up the NFT yet, the direct transfer will fail, proceeding with `_transferFromEscrow` in the FNDNFTMarket defined order: ``` function _transferFromEscrow( address nftContract, uint256 tokenId, address recipient, address seller ) internal override(NFTMarketCore, NFTMarketReserveAuction, NFTMarketBuyPrice, NFTMarketOffer) { super._transferFromEscrow(nftContract, tokenId, recipient, seller); } ```  NFTMarketOffer._transferFromEscrow will call super as `nftContractToIdToOffer` was already deleted:  https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketOffer.sol#L296-L302  NFTMarketBuyPrice._transferFromEscrow will call super as there is no buy price set:  https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketBuyPrice.sol#L283-L293  Finally, NFTMarketReserveAuction._transferFromEscrow will send the NFT to the winner via `_finalizeReserveAuction`, not to the user who made the offer:  https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketReserveAuction.sol#L556-L560  The `recipient` user who made the offer is not present in this logic, the NFT is being transferred to the `auction.bidder`, and the original `acceptOffer` will go through successfully.  ## Recommended Mitigation Steps  An attempt to set a buy price from auction winner will lead to auction finalisation, so `_buy` cannot be called with a not yet finalised auction, this way the NFTMarketReserveAuction._transferFromEscrow L550-L560 logic is called from the NFTMarketOffer._acceptOffer only:  https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketOffer.sol#L270  is the only user of   https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/NFTMarketReserveAuction.sol#L550-L560   This way the fix is to update L556-L560 for the described case as:  Now: ``` // Finalization will revert if the auction has not yet ended. _finalizeReserveAuction(auctionId, false);  // Finalize includes the transfer, so we are done here. return; ```  To be, we leave the NFT in the escrow and let L564 super call to transfer it to the recipient: ``` // Finalization will revert if the auction has not yet ended. _finalizeReserveAuction(auctionId, true); ```  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-foundation-findings/issues/48", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-02-foundation-findings", "body": "QA Report"}, {"title": "Private sale spoofing", "html_url": "https://github.com/code-423n4/2022-02-foundation-findings/issues/46", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-02-foundation-findings", "body": "Private sale spoofing"}, {"title": "`MAX_ROYALTY_RECIPIENTS_INDEX` set too low", "html_url": "https://github.com/code-423n4/2022-02-foundation-findings/issues/45", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-02-foundation-findings", "body": "`MAX_ROYALTY_RECIPIENTS_INDEX` set too low"}, {"title": "`LockedBalance` library should drop parameters to 96/32 bits", "html_url": "https://github.com/code-423n4/2022-02-foundation-findings/issues/44", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-02-foundation-findings", "body": "`LockedBalance` library should drop parameters to 96/32 bits"}, {"title": "Missing receiver validation in `withdrawFrom`", "html_url": "https://github.com/code-423n4/2022-02-foundation-findings/issues/42", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-02-foundation-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-foundation/blob/4d8c8931baffae31c7506872bf1100e1598f2754/contracts/FETH.sol#L433   # Vulnerability details  ## Impact The `FETH.withdrawFrom` function does not validate its `to` parameter. Funds can be lost if `to` is the zero address.  > Similar issues have been judged as medium recently, see [Sandclock M-15](https://code4rena.com/reports/2022-01-sandclock/) / [Github issue](https://github.com/code-423n4/2022-01-sandclock-findings/issues/183#issuecomment-1024626171)  ## Recommended Mitigation Steps Check that `to != 0`.  "}, {"title": "Primary seller can avoid paying the primary fee", "html_url": "https://github.com/code-423n4/2022-02-foundation-findings/issues/39", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-02-foundation-findings", "body": "Primary seller can avoid paying the primary fee"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-foundation-findings/issues/38", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-02-foundation-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-foundation-findings/issues/37", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-foundation-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-foundation-findings/issues/36", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-02-foundation-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-foundation-findings/issues/32", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-foundation-findings", "body": "Gas Optimizations"}, {"title": "Creators can steal sale revenue from owners' sales", "html_url": "https://github.com/code-423n4/2022-02-foundation-findings/issues/30", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-02-foundation-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-foundation/blob/a03a7e198c1dfffb1021c0e8ec91ba4194b8aa12/contracts/mixins/NFTMarketCreators.sol#L158-L160 https://github.com/code-423n4/2022-02-foundation/blob/a03a7e198c1dfffb1021c0e8ec91ba4194b8aa12/contracts/mixins/NFTMarketCreators.sol#L196-L198 https://github.com/code-423n4/2022-02-foundation/blob/a03a7e198c1dfffb1021c0e8ec91ba4194b8aa12/contracts/mixins/NFTMarketCreators.sol#L97-L99   # Vulnerability details  According to the `README.md` > All sales in the Foundation market will pay the creator 10% royalties on secondary sales. This is not specific to NFTs minted on Foundation, it should work for any NFT. If royalty information was not defined when the NFT was originally deployed, it may be added using the Royalty Registry which will be respected by our market contract.  https://github.com/code-423n4/2022-02-foundation/blob/4d8c8931baffae31c7506872bf1100e1598f2754/README.md?plain=1#L21  Using the Royalty Registry an owner can decide to change the royalty information right before the sale is complete, affecting who gets what.  ## Impact By updating the registry to include the seller as one of the royalty recipients, the creator can steal the sale price minus fees. This is because if code finds that the seller is a royalty recipient the royalties are all passed to the creator regardless of whether the owner is the seller or not.  ## Proof of Concept ```solidity           // 4th priority: getRoyalties override           if (recipients.length == 0 && nftContract.supportsERC165Interface(type(IGetRoyalties).interfaceId)) {             try IGetRoyalties(nftContract).getRoyalties{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (               address payable[] memory _recipients,               uint256[] memory recipientBasisPoints             ) {               if (_recipients.length > 0 && _recipients.length == recipientBasisPoints.length) {                 bool hasRecipient;                 for (uint256 i = 0; i < _recipients.length; ++i) {                   if (_recipients[i] != address(0)) {                     hasRecipient = true;                     if (_recipients[i] == seller) {                       return (_recipients, recipientBasisPoints, true); ``` https://github.com/code-423n4/2022-02-concur/blob/72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0/contracts/MasterChef.sol#L127-L154  When `true` is returned as the final return value above, the following code leaves `ownerRev` as zero because `isCreator` is `true` ```solidity       uint256 ownerRev     )   {     bool isCreator;     (creatorRecipients, creatorShares, isCreator) = _getCreatorPaymentInfo(nftContract, tokenId, seller);      // Calculate the Foundation fee     uint256 fee;     if (isCreator && !_nftContractToTokenIdToFirstSaleCompleted[nftContract][tokenId]) {       fee = PRIMARY_FOUNDATION_FEE_BASIS_POINTS;     } else {       fee = SECONDARY_FOUNDATION_FEE_BASIS_POINTS;     }      foundationFee = (price * fee) / BASIS_POINTS;      if (creatorRecipients.length > 0) {       if (isCreator) {         // When sold by the creator, all revenue is split if applicable.         creatorRev = price - foundationFee;       } else {         // Rounding favors the owner first, then creator, and foundation last.         creatorRev = (price * CREATOR_ROYALTY_BASIS_POINTS) / BASIS_POINTS;         ownerRevTo = seller;         ownerRev = price - foundationFee - creatorRev;       }     } else {       // No royalty recipients found.       ownerRevTo = seller;       ownerRev = price - foundationFee;     }   } ```  In addition, if the index of the seller in `_recipients` is greater than `MAX_ROYALTY_RECIPIENTS_INDEX`, then the seller is omitted from the calculation and gets zero (`_sendValueWithFallbackWithdraw()` doesn't complain when it sends zero) ```solidity         uint256 maxCreatorIndex = creatorRecipients.length - 1;         if (maxCreatorIndex > MAX_ROYALTY_RECIPIENTS_INDEX) {           maxCreatorIndex = MAX_ROYALTY_RECIPIENTS_INDEX;         } ``` https://github.com/code-423n4/2022-02-foundation/blob/4d8c8931baffae31c7506872bf1100e1598f2754/contracts/mixins/NFTMarketFees.sol#L76-L79  This issue does a lot of damage because the creator can choose whether and when to apply it on a sale-by-sale basis. Two other similar, but separate, exploits are available for the other blocks in `_getCreatorPaymentInfo()` that return arrays but they either require a malicious NFT implementation or can only specify a static seller for which this will affect things. In all cases, not only may the seller get zero dollars for the sale, but they'll potentially owe a lot of taxes based on the 'sale' price. The attacker may or may not be the creator - creators can be bribed with kickbacks.  ## Tools Used Code inspection  ## Recommended Mitigation Steps Always calculate owner/seller revenue separately from royalty revenue   "}, {"title": "Exchange does not split royalty revenue correctly", "html_url": "https://github.com/code-423n4/2022-02-foundation-findings/issues/29", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-02-foundation-findings", "body": "Exchange does not split royalty revenue correctly"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-foundation-findings/issues/28", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-02-foundation-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-foundation-findings/issues/25", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-02-foundation-findings", "body": "QA Report"}, {"title": "NFT owner can create multiple auctions", "html_url": "https://github.com/code-423n4/2022-02-foundation-findings/issues/23", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-02-foundation-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-foundation/blob/4d8c8931baffae31c7506872bf1100e1598f2754/contracts/mixins/NFTMarketReserveAuction.sol#L325-L349 https://github.com/code-423n4/2022-02-foundation/blob/4d8c8931baffae31c7506872bf1100e1598f2754/contracts/mixins/NFTMarketReserveAuction.sol#L596-L599   # Vulnerability details  # Impact NFT owner can permanently lock funds of bidders.   # Proof of concept  Alice (the attacker) calls `createReserveAuction`, and creates one like normal. let this be auction id 1.  Alice calls `createReserveAuction` again, before any user has placed a bid (this is easy to guarantee with a deployed attacker contract). We'd expect that Alice wouldn't be able to create another auction, but she can, because `_transferToEscrow` doesn't revert if there's an existing auction. let this be Auction id 2.  Since `nftContractToTokenIdToAuctionId[nftContract][tokenId]` will contain auction id 2, all bidders will see that auction as the one to bid on (unless they inspect contract events or data manually).  Alice can now cancel auction id 1, then cancel auction id 2, locking up the funds of the last bidder on auction id 2 forever.  # Mitigation Prevent NFT owners from creating multiple auctions  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-foundation-findings/issues/15", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-foundation-findings", "body": "Gas Optimizations"}, {"title": "Approve race condition in FETH", "html_url": "https://github.com/code-423n4/2022-02-foundation-findings/issues/14", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-02-foundation-findings", "body": "Approve race condition in FETH"}, {"title": "QA report", "html_url": "https://github.com/code-423n4/2022-02-foundation-findings/issues/13", "labels": ["bug", "QA (Quality Assurance)", "disagree with severity", "sponsor acknowledged"], "target": "2022-02-foundation-findings", "body": "QA report"}, {"title": "SendValueWithFallbackWithdraw: withdrawFor function may fail to withdraw ether recorded in pendingWithdrawals", "html_url": "https://github.com/code-423n4/2022-02-foundation-findings/issues/12", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed"], "target": "2022-02-foundation-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/SendValueWithFallbackWithdraw.sol#L37-L77   # Vulnerability details  ## Impact The NFTMarketFees contract and the NFTMarketReserveAuction contract use the _sendValueWithFallbackWithdraw function to send ether to FoundationTreasury, CreatorRecipients, Seller, Bidder. When the receiver fails to receive due to some reasons (exceeding the gas limit or the receiver contract cannot receive ether), it will record the ether to be sent in the pendingWithdrawals variable.  ```   function _sendValueWithFallbackWithdraw(     address payable user,     uint256 amount,     uint256 gasLimit   ) internal {     if (amount == 0) {       return;     }     // Cap the gas to prevent consuming all available gas to block a tx from completing successfully     // solhint-disable-next-line avoid-low-level-calls     (bool success, ) = user.call{ value: amount, gas: gasLimit }(\"\");     if (!success) {       // Record failed sends for a withdrawal later       // Transfers could fail if sent to a multisig with non-trivial receiver logic       unchecked {         pendingWithdrawals[user] += amount;       }       emit WithdrawPending(user, amount);     }   } ``` The user can then withdraw ether via the withdraw or withdrawFor functions. ```   function withdraw() external {     withdrawFor(payable(msg.sender));   }   function withdrawFor(address payable user) public nonReentrant {     uint256 amount = pendingWithdrawals[user];     if (amount == 0) {       revert SendValueWithFallbackWithdraw_No_Funds_Available();     }     pendingWithdrawals[user] = 0;     user.sendValue(amount);     emit Withdrawal(user, amount);   } ``` However, the withdrawFor function can only send ether to the address recorded in pendingWithdrawals. When the recipient is a contract that cannot receive ether, these ethers will be locked in the contract and cannot be withdrawn. ## Proof of Concept https://github.com/code-423n4/2022-02-foundation/blob/main/contracts/mixins/SendValueWithFallbackWithdraw.sol#L37-L77 ## Tools Used None ## Recommended Mitigation Steps Add the withdrawTo function as follows:  ```   function withdrawTo(address payable to) public nonReentrant {     uint256 amount = pendingWithdrawals[msg.sneder];     if (amount == 0) {       revert SendValueWithFallbackWithdraw_No_Funds_Available();     }     pendingWithdrawals[msg.sneder] = 0;     to.sendValue(amount);     emit Withdrawal(msg.sneder, amount);   } ```  "}, {"title": "QA report", "html_url": "https://github.com/code-423n4/2022-02-foundation-findings/issues/11", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-02-foundation-findings", "body": "QA report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-foundation-findings/issues/10", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-foundation-findings", "body": "Gas Optimizations"}, {"title": "QA report", "html_url": "https://github.com/code-423n4/2022-02-foundation-findings/issues/9", "labels": ["bug", "QA (Quality Assurance)", "disagree with severity", "sponsor confirmed"], "target": "2022-02-foundation-findings", "body": "QA report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-foundation-findings/issues/2", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-02-foundation-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-foundation-findings/issues/1", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-foundation-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-jpyc-findings/issues/62", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-02-jpyc-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-jpyc-findings/issues/61", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-jpyc-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-jpyc-findings/issues/60", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-jpyc-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-jpyc-findings/issues/58", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-02-jpyc-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-jpyc-findings/issues/57", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-jpyc-findings", "body": "Gas Optimizations"}, {"title": "QA report", "html_url": "https://github.com/code-423n4/2022-02-jpyc-findings/issues/56", "labels": ["bug", "duplicate", "QA (Quality Assurance)", "disagree with severity"], "target": "2022-02-jpyc-findings", "body": "QA report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-jpyc-findings/issues/55", "labels": ["bug", "G (Gas Optimization)", "resolved"], "target": "2022-02-jpyc-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-jpyc-findings/issues/52", "labels": ["bug", "QA (Quality Assurance)", "resolved"], "target": "2022-02-jpyc-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-jpyc-findings/issues/51", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-jpyc-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-jpyc-findings/issues/49", "labels": ["bug", "G (Gas Optimization)", "resolved"], "target": "2022-02-jpyc-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-jpyc-findings/issues/47", "labels": ["bug", "question", "QA (Quality Assurance)", "resolved"], "target": "2022-02-jpyc-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-jpyc-findings/issues/45", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-jpyc-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-jpyc-findings/issues/44", "labels": ["bug", "QA (Quality Assurance)", "resolved"], "target": "2022-02-jpyc-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-jpyc-findings/issues/41", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-02-jpyc-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-jpyc-findings/issues/40", "labels": ["bug", "question", "G (Gas Optimization)"], "target": "2022-02-jpyc-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-jpyc-findings/issues/39", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-02-jpyc-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-jpyc-findings/issues/38", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-jpyc-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-jpyc-findings/issues/36", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-jpyc-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-jpyc-findings/issues/35", "labels": ["bug", "question", "QA (Quality Assurance)", "resolved"], "target": "2022-02-jpyc-findings", "body": "QA Report"}, {"title": "QA report", "html_url": "https://github.com/code-423n4/2022-02-jpyc-findings/issues/34", "labels": ["bug", "QA (Quality Assurance)", "disagree with severity", "sponsor disputed"], "target": "2022-02-jpyc-findings", "body": "QA report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-jpyc-findings/issues/32", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-jpyc-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-jpyc-findings/issues/31", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-02-jpyc-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-jpyc-findings/issues/30", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-02-jpyc-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-jpyc-findings/issues/29", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-jpyc-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-jpyc-findings/issues/28", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-02-jpyc-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-jpyc-findings/issues/27", "labels": ["bug", "question", "G (Gas Optimization)", "resolved"], "target": "2022-02-jpyc-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-jpyc-findings/issues/26", "labels": ["bug", "QA (Quality Assurance)", "resolved"], "target": "2022-02-jpyc-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-jpyc-findings/issues/25", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-02-jpyc-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-jpyc-findings/issues/24", "labels": ["bug", "QA (Quality Assurance)", "resolved"], "target": "2022-02-jpyc-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-jpyc-findings/issues/20", "labels": ["bug", "question", "G (Gas Optimization)", "resolved"], "target": "2022-02-jpyc-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-jpyc-findings/issues/19", "labels": ["bug", "QA (Quality Assurance)", "resolved"], "target": "2022-02-jpyc-findings", "body": "QA Report"}, {"title": "QA report", "html_url": "https://github.com/code-423n4/2022-02-jpyc-findings/issues/18", "labels": ["bug", "duplicate", "QA (Quality Assurance)", "disagree with severity"], "target": "2022-02-jpyc-findings", "body": "QA report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-jpyc-findings/issues/17", "labels": ["bug", "G (Gas Optimization)", "resolved"], "target": "2022-02-jpyc-findings", "body": "Gas Optimizations"}, {"title": "QA report", "html_url": "https://github.com/code-423n4/2022-02-jpyc-findings/issues/16", "labels": ["bug", "QA (Quality Assurance)", "disagree with severity", "sponsor acknowledged"], "target": "2022-02-jpyc-findings", "body": "QA report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-jpyc-findings/issues/15", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-02-jpyc-findings", "body": "QA Report"}, {"title": "QA report", "html_url": "https://github.com/code-423n4/2022-02-jpyc-findings/issues/10", "labels": ["bug", "QA (Quality Assurance)", "disagree with severity"], "target": "2022-02-jpyc-findings", "body": "QA report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-jpyc-findings/issues/8", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-02-jpyc-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-jpyc-findings/issues/5", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-02-jpyc-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-02-jpyc-findings/issues/3", "labels": ["bug", "QA (Quality Assurance)", "resolved"], "target": "2022-02-jpyc-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-02-jpyc-findings/issues/2", "labels": ["bug", "question", "G (Gas Optimization)", "resolved"], "target": "2022-02-jpyc-findings", "body": "Gas Optimizations"}, {"title": "QA report", "html_url": "https://github.com/code-423n4/2022-02-jpyc-findings/issues/1", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-02-jpyc-findings", "body": "QA report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-timeswap-findings/issues/38", "labels": ["bug", "QA (Quality Assurance)", "resolved", "sponsor confirmed"], "target": "2022-03-timeswap-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-timeswap-findings/issues/37", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-03-timeswap-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-timeswap-findings/issues/36", "labels": ["bug", "QA (Quality Assurance)", "resolved", "sponsor acknowledged", "sponsor confirmed"], "target": "2022-03-timeswap-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-timeswap-findings/issues/35", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-03-timeswap-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-timeswap-findings/issues/34", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-03-timeswap-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-timeswap-findings/issues/33", "labels": ["bug", "QA (Quality Assurance)", "resolved", "sponsor confirmed"], "target": "2022-03-timeswap-findings", "body": "QA Report"}, {"title": "Underflown variable in ``borrowGivenDebtETHCollateral`` function", "html_url": "https://github.com/code-423n4/2022-03-timeswap-findings/issues/32", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-03-timeswap-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/libraries/Borrow.sol#L121-L127   # Vulnerability details  ## Impact ``borrowGivenDebtETHCollateral`` function does never properly call ``ETH.transfer`` due to underflow. If ``borrowGivenDebtETHCollateral`` function is not deprecated, it would cause unexpected behaviors for users.   ## Proof of Concept Here are codes which contain a potential issue.  https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/libraries/Borrow.sol#L121-L127 ``` if (maxCollateral > dueOut.collateral) {     uint256 excess;     unchecked {         excess -= dueOut.collateral;     }     ETH.transfer(payable(msg.sender), excess); } ```  ``excess`` variable is ``uint256``, and ``dueOut.collateral`` variable is ``uint112`` as shown below. Hence, both variables will never be less than 0.  https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Core/contracts/interfaces/IPair.sol#L22-L26 ``` struct Due {     uint112 debt;     uint112 collateral;     uint32 startBlock; } ```  ``uint256 excess`` is initialized to 0. However, subtracting ``dueOut.collateral`` variable which is more than or equal to 0 from ``excess`` variable which is 0 will be less than 0. Hence, ``excess -= dueOut.collateral`` will be less than 0, and ``excess`` will be underflown.   ## Tools Used static code analysis   ## Recommended Mitigation Steps The code should properly initialize ``excess`` variable.  ``borrowGivenPercentETHCollateral`` function uses ``uint256 excess = maxCollateral`` at similar functionality. https://github.com/code-423n4/2022-03-timeswap/blob/main/Timeswap/Convenience/contracts/libraries/Borrow.sol#L347  Hence, just initializing ``excess`` variable with ``maxCollateral`` can be a potential workaround to prevent the underflown. ``` if (maxCollateral > dueOut.collateral) {     uint256 excess = maxCollateral;     unchecked {         excess -= dueOut.collateral;     }     ETH.transfer(payable(msg.sender), excess); } ```  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-timeswap-findings/issues/31", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-03-timeswap-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-timeswap-findings/issues/30", "labels": ["bug", "QA (Quality Assurance)", "resolved", "sponsor confirmed"], "target": "2022-03-timeswap-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-timeswap-findings/issues/27", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-timeswap-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-timeswap-findings/issues/25", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-03-timeswap-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-timeswap-findings/issues/24", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor acknowledged", "sponsor confirmed"], "target": "2022-03-timeswap-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-timeswap-findings/issues/20", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-03-timeswap-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-timeswap-findings/issues/19", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-03-timeswap-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-timeswap-findings/issues/18", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-03-timeswap-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-timeswap-findings/issues/17", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor acknowledged", "sponsor confirmed"], "target": "2022-03-timeswap-findings", "body": "Gas Optimizations"}, {"title": "[WP-H1] Wrong timing of check allows users to withdraw collateral without paying for the debt", "html_url": "https://github.com/code-423n4/2022-03-timeswap-findings/issues/16", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2022-03-timeswap-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-timeswap/blob/00317d9a8319715a8e28361901ab14fe50d06172/Timeswap/Core/contracts/TimeswapPair.sol#L459-L490   # Vulnerability details  https://github.com/code-423n4/2022-03-timeswap/blob/00317d9a8319715a8e28361901ab14fe50d06172/Timeswap/Core/contracts/TimeswapPair.sol#L459-L490  ```solidity function pay(PayParam calldata param)     external      override      lock      returns (         uint128 assetIn,          uint128 collateralOut     )  {     require(block.timestamp < param.maturity, 'E202');     require(param.owner != address(0), 'E201');     require(param.to != address(0), 'E201');     require(param.to != address(this), 'E204');     require(param.ids.length == param.assetsIn.length, 'E205');     require(param.ids.length == param.collateralsOut.length, 'E205');      Pool storage pool = pools[param.maturity];      Due[] storage dues = pool.dues[param.owner];     require(dues.length >= param.ids.length, 'E205');      for (uint256 i; i < param.ids.length;) {         Due storage due = dues[param.ids[i]];         require(due.startBlock != BlockNumber.get(), 'E207');         if (param.owner != msg.sender) require(param.collateralsOut[i] == 0, 'E213');         require(uint256(assetIn) * due.collateral >= uint256(collateralOut) * due.debt, 'E303');         due.debt -= param.assetsIn[i];         due.collateral -= param.collateralsOut[i];         assetIn += param.assetsIn[i];         collateralOut += param.collateralsOut[i];         unchecked { ++i; }     }     ... ```  At L484, if there is only one `id`, and for the first and only time of the for loop, `assetIn` and `collateralOut` will be `0`, therefore `require(uint256(assetIn) * due.collateral >= uint256(collateralOut) * due.debt, 'E303');` will pass.  A attacker can call `pay()` with `param.assetsIn[0] == 0` and `param.collateralsOut[i] == due.collateral`.  ### PoC  The attacker can:   1. `borrow()` `10,000 USDC` with `1 BTC` as `collateral`; 2. `pay()` with `0 USDC` as `assetsIn` and `1 BTC` as `collateralsOut`.  As a result, the attacker effectively stole `10,000 USDC`.  ### Recommendation  Change to:  ```solidity for (uint256 i; i < param.ids.length;) {     Due storage due = dues[param.ids[i]];     require(due.startBlock != BlockNumber.get(), 'E207');     if (param.owner != msg.sender) require(param.collateralsOut[i] == 0, 'E213');     due.debt -= param.assetsIn[i];     due.collateral -= param.collateralsOut[i];     assetIn += param.assetsIn[i];     collateralOut += param.collateralsOut[i];     unchecked { ++i; } }  require(uint256(assetIn) * due.collateral >= uint256(collateralOut) * due.debt, 'E303'); ... ```  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-timeswap-findings/issues/14", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-03-timeswap-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-timeswap-findings/issues/13", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2022-03-timeswap-findings", "body": "Gas Optimizations"}, {"title": "The `pay()` function can still be DOSed", "html_url": "https://github.com/code-423n4/2022-03-timeswap-findings/issues/11", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-03-timeswap-findings", "body": "The `pay()` function can still be DOSed"}, {"title": "NPM Dependency confusion. Unclaimed NPM Package and Scope/Org", "html_url": "https://github.com/code-423n4/2022-03-timeswap-findings/issues/9", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-03-timeswap-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-timeswap/blob/00317d9a8319715a8e28361901ab14fe50d06172/Timeswap/Convenience/package.json#L40   # Vulnerability details  ## Impact I discovered an npm package and the scope of the package is unclaimed on the NPM website. This will give any User to claim that package and be able to Upload a Malicious Code under that unclaimed package. This results in achieving the Remote code execution on developers/users' machine who depends on the timeswap repository to build it on local env.  ##Vulnerable Package Name: @timeswap-labs/timeswap-v1-core  ## Proof of Concept 1. Create an Organization called \"timeswap-labs\". 2. Create a package called \"@timeswap-labs/timeswap-v1-core\" under \"timeswap-labs\" Organization. 3. Attacker can able to upload malicious code on unclaimed npm package with a higher version like 99.99.99 4. Now If any user/timeswap developer installs it by npm install package.json. The malicious pkg will be executed.  Till now \"The Package is not claimed on NPM Registry, but it's vulnerable to dependency confusion\".  You can read more dependency confusion here: https://dhiyaneshgeek.github.io/web/security/2021/09/04/dependency-confusion/  ## Tools Used Nothing Just OSINT  ## Recommended Mitigation Steps Claim the Scope name called \"timeswap-labs\" By Following the above POC Step 1.  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-timeswap-findings/issues/7", "labels": ["bug", "QA (Quality Assurance)", "resolved", "sponsor acknowledged", "sponsor confirmed"], "target": "2022-03-timeswap-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-timeswap-findings/issues/6", "labels": ["bug", "G (Gas Optimization)", "resolved"], "target": "2022-03-timeswap-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-timeswap-findings/issues/5", "labels": ["bug", "QA (Quality Assurance)", "resolved", "sponsor confirmed"], "target": "2022-03-timeswap-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-timeswap-findings/issues/4", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor acknowledged", "sponsor confirmed"], "target": "2022-03-timeswap-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-timeswap-findings/issues/3", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-03-timeswap-findings", "body": "QA Report"}, {"title": "Agreements & Disclosures", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/216", "labels": [], "target": "2022-03-biconomy-findings", "body": "Agreements & Disclosures"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/196", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-biconomy-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/195", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-biconomy-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/193", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-biconomy-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/191", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-biconomy-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/190", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-biconomy-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/189", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-biconomy-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/188", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-biconomy-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/187", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-biconomy-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/184", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-biconomy-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/183", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-biconomy-findings", "body": "Gas Optimizations"}, {"title": "Sending tokens close to the maximum will fail and user will lose tokens", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/181", "labels": ["bug", "2 (Med Risk)", "sponsor disputed"], "target": "2022-03-biconomy-findings", "body": "Sending tokens close to the maximum will fail and user will lose tokens"}, {"title": " Possible frontrun on deposits on LiquidityPool", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/180", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-03-biconomy-findings", "body": " Possible frontrun on deposits on LiquidityPool"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/176", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-biconomy-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/173", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-biconomy-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/172", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-biconomy-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/171", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-biconomy-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/170", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-biconomy-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/169", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-biconomy-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/167", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-biconomy-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/166", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-biconomy-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/165", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-biconomy-findings", "body": "QA Report"}, {"title": "Frontrunning of setPerTokenWalletCap edge case", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/158", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-03-biconomy-findings", "body": "Frontrunning of setPerTokenWalletCap edge case"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/156", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-biconomy-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/155", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-biconomy-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/154", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-biconomy-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/152", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-biconomy-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/151", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-biconomy-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/149", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-biconomy-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/148", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-biconomy-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/147", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-biconomy-findings", "body": "Gas Optimizations"}, {"title": "[WP-H23] Improper `tokenGasPrice` design can overcharge user for the gas cost by a huge margin", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/145", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-03-biconomy-findings", "body": "[WP-H23] Improper `tokenGasPrice` design can overcharge user for the gas cost by a huge margin"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/143", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-biconomy-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/141", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-biconomy-findings", "body": "Gas Optimizations"}, {"title": "[WP-H17] Users will lose a majority or even all of the rewards when the amount of total shares is too large, due to precision loss", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/140", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-03-biconomy-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-biconomy/blob/db8a1fdddd02e8cc209a4c73ffbb3de210e4a81a/contracts/hyphen/LiquidityFarming.sol#L265-L291   # Vulnerability details  https://github.com/code-423n4/2022-03-biconomy/blob/db8a1fdddd02e8cc209a4c73ffbb3de210e4a81a/contracts/hyphen/LiquidityFarming.sol#L265-L291  ```solidity function getUpdatedAccTokenPerShare(address _baseToken) public view returns (uint256) {     uint256 accumulator = 0;     uint256 lastUpdatedTime = poolInfo[_baseToken].lastRewardTime;     uint256 counter = block.timestamp;     uint256 i = rewardRateLog[_baseToken].length - 1;     while (true) {         if (lastUpdatedTime >= counter) {             break;         }         unchecked {             accumulator +=                 rewardRateLog[_baseToken][i].rewardsPerSecond *                 (counter - max(lastUpdatedTime, rewardRateLog[_baseToken][i].timestamp));         }         counter = rewardRateLog[_baseToken][i].timestamp;         if (i == 0) {             break;         }         --i;     }      // We know that during all the periods that were included in the current iterations,     // the value of totalSharesStaked[_baseToken] would not have changed, as we only consider the     // updates to the pool that happened after the lastUpdatedTime.     accumulator = (accumulator * ACC_TOKEN_PRECISION) / totalSharesStaked[_baseToken];     return accumulator + poolInfo[_baseToken].accTokenPerShare; } ```  https://github.com/code-423n4/2022-03-biconomy/blob/04751283f85c9fc94fb644ff2b489ec339cd9ffc/contracts/hyphen/LiquidityProviders.sol#L286-L292  ```solidity uint256 mintedSharesAmount; // Adding liquidity in the pool for the first time if (totalReserve[token] == 0) {     mintedSharesAmount = BASE_DIVISOR * _amount; } else {     mintedSharesAmount = (_amount * totalSharesMinted[token]) / totalReserve[token]; } ```  In `HyphenLiquidityFarming`, the `accTokenPerShare` is calculated based on the total staked shares.  However, as the `mintedSharesAmount` can easily become very large on `LiquidityProviders.sol`, all the users can lose their rewards due to precision loss.  ### PoC  Given:  - rewardsPerSecond is `10e18`; - lastRewardTime is 24 hrs ago;  Then:  1. Alice `addTokenLiquidity()` with `1e8 * 1e18` XYZ on B-Chain, totalSharesMinted == `1e44`; 2. Alice `deposit()` to HyphenLiquidityFarming, totalSharesStaked == `1e44`; 3. 24 hrs later, Alice tries to claim the rewards.   `accumulator = rewardsPerSecond * 24 hours` == 864000e18 == 8.64e23  Expected Results: As the sole staker, Alice should get all the `864000e18` rewards.  Actual Results: Alice received 0 rewards.  That's becasue when `totalSharesStaked > 1e36`, `accumulator = (accumulator * ACC_TOKEN_PRECISION) / totalSharesStaked[_baseToken];` will be round down to `0`.  When the `totalSharesStaked` is large enough, all users will lose their rewards due to precision loss.  ### Recommendation  1. Consider lowering the `BASE_DIVISOR` so that the initial share price can be higher; 2. Consider making `ACC_TOKEN_PRECISION` larger to prevent precision loss;  See also the Recommendation on [WP-H14].  "}, {"title": "[WP-H14] `LiquidityProviders.sol` The share price of the LP can be manipulated and making future liquidityProviders unable to `removeLiquidity()`", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/139", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-03-biconomy-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-biconomy/blob/04751283f85c9fc94fb644ff2b489ec339cd9ffc/contracts/hyphen/LiquidityProviders.sol#L345-L362   # Vulnerability details  https://github.com/code-423n4/2022-03-biconomy/blob/04751283f85c9fc94fb644ff2b489ec339cd9ffc/contracts/hyphen/LiquidityProviders.sol#L345-L362  ```solidity function removeLiquidity(uint256 _nftId, uint256 _amount)     external     nonReentrant     onlyValidLpToken(_nftId, _msgSender())     whenNotPaused {     (address _tokenAddress, uint256 nftSuppliedLiquidity, uint256 totalNFTShares) = lpToken.tokenMetadata(_nftId);     require(_isSupportedToken(_tokenAddress), \"ERR__TOKEN_NOT_SUPPORTED\");      require(_amount != 0, \"ERR__INVALID_AMOUNT\");     require(nftSuppliedLiquidity >= _amount, \"ERR__INSUFFICIENT_LIQUIDITY\");     whiteListPeriodManager.beforeLiquidityRemoval(_msgSender(), _tokenAddress, _amount);     // Claculate how much shares represent input amount     uint256 lpSharesForInputAmount = _amount * getTokenPriceInLPShares(_tokenAddress);      // Calculate rewards accumulated     uint256 eligibleLiquidity = sharesToTokenAmount(totalNFTShares, _tokenAddress); ```  https://github.com/code-423n4/2022-03-biconomy/blob/db8a1fdddd02e8cc209a4c73ffbb3de210e4a81a/contracts/hyphen/LiquidityProviders.sol#L192-L194  ```solidity=192 function sharesToTokenAmount(uint256 _shares, address _tokenAddress) public view returns (uint256) {     return (_shares * totalReserve[_tokenAddress]) / totalSharesMinted[_tokenAddress]; } ```  The share price of the liquidity can be manipulated to an extremely low value (1 underlying token worth a huge amount of shares), making it possible for `sharesToTokenAmount(totalNFTShares, _tokenAddress)` to overflow in `removeLiquidity()` and therefore freeze users' funds.   ### PoC  1. Alice `addTokenLiquidity()` with `1e8 * 1e18` XYZ on B-Chain, totalSharesMinted == `1e44`; 2. Alice `sendFundsToUser()` and bridge `1e8 * 1e18` XYZ from B-Chain to A-Chain; 3. Alice `depositErc20()` and bridge `1e8 * 1e18` XYZ from A-Chain to B-Chain; 4. Alice `removeLiquidity()` and withdraw `1e8 * 1e18 - 1` XYZ, then: `totalReserve` == `1 wei` XYZ, and `totalSharesMinted` == `1e26`; 5. Bob `addTokenLiquidity()` with `3.4e7 * 1e18` XYZ; 6. Bob tries to `removeLiquidity()`.  Expected Results: Bob to get back the deposits;  Actual Results: The tx reverted due to overflow at `sharesToTokenAmount()`.  ### Recommendation  https://github.com/code-423n4/2022-03-biconomy/blob/04751283f85c9fc94fb644ff2b489ec339cd9ffc/contracts/hyphen/LiquidityProviders.sol#L280-L292  ```solidity=280 function _increaseLiquidity(uint256 _nftId, uint256 _amount) internal onlyValidLpToken(_nftId, _msgSender()) {     (address token, uint256 totalSuppliedLiquidity, uint256 totalShares) = lpToken.tokenMetadata(_nftId);      require(_amount > 0, \"ERR__AMOUNT_IS_0\");     whiteListPeriodManager.beforeLiquidityAddition(_msgSender(), token, _amount);      uint256 mintedSharesAmount;     // Adding liquidity in the pool for the first time     if (totalReserve[token] == 0) {         mintedSharesAmount = BASE_DIVISOR * _amount;     } else {         mintedSharesAmount = (_amount * totalSharesMinted[token]) / totalReserve[token];     }     ... ```  Consider locking part of the first mint's liquidity to maintain a minimum amount of `totalReserve[token]`, so that the share price can not be easily manipulated.  "}, {"title": "A `pauser` can brick the contracts", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/137", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-03-biconomy-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-biconomy/blob/db8a1fdddd02e8cc209a4c73ffbb3de210e4a81a/contracts/security/Pausable.sol#L65-L68   # Vulnerability details  https://github.com/code-423n4/2022-03-biconomy/blob/db8a1fdddd02e8cc209a4c73ffbb3de210e4a81a/contracts/security/Pausable.sol#L65-L68  ```solidity     function renouncePauser() external virtual onlyPauser {         emit PauserChanged(_pauser, address(0));         _pauser = address(0);     } ```  A malicious or compromised `pauser` can call `pause()` and `renouncePauser()` to brick the contract and all the funds can be frozen.  ### PoC  Given:  * Alice (EOA) is the `pauser` of the contract.  1. Alice calls `pause()` ; 2. Alice calls `renouncePauser()`;   As a result, most of the contract's methods are now unavailable, and this cannot be reversed even by the `owner`.  ### Recommendation  Consider removing `renouncePauser()`, or requiring the contract not in `paused` mode when `renouncePauser()`.  "}, {"title": "[WP-H5] `LiquidityFarming.sol` Unbounded for loops can potentially freeze users' funds in edge cases", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/136", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-03-biconomy-findings", "body": "[WP-H5] `LiquidityFarming.sol` Unbounded for loops can potentially freeze users' funds in edge cases"}, {"title": "[WP-H4] Deleting `nft Info` can cause users' `nft.unpaidRewards` to be permanently erased", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/135", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-03-biconomy-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-biconomy/blob/db8a1fdddd02e8cc209a4c73ffbb3de210e4a81a/contracts/hyphen/LiquidityFarming.sol#L229-L253   # Vulnerability details  https://github.com/code-423n4/2022-03-biconomy/blob/db8a1fdddd02e8cc209a4c73ffbb3de210e4a81a/contracts/hyphen/LiquidityFarming.sol#L229-L253  ```solidity function withdraw(uint256 _nftId, address payable _to) external whenNotPaused nonReentrant {     address msgSender = _msgSender();     uint256 nftsStakedLength = nftIdsStaked[msgSender].length;     uint256 index;     for (index = 0; index < nftsStakedLength; ++index) {         if (nftIdsStaked[msgSender][index] == _nftId) {             break;         }     }      require(index != nftsStakedLength, \"ERR__NFT_NOT_STAKED\");     nftIdsStaked[msgSender][index] = nftIdsStaked[msgSender][nftIdsStaked[msgSender].length - 1];     nftIdsStaked[msgSender].pop();      _sendRewardsForNft(_nftId, _to);     delete nftInfo[_nftId];      (address baseToken, , uint256 amount) = lpToken.tokenMetadata(_nftId);     amount /= liquidityProviders.BASE_DIVISOR();     totalSharesStaked[baseToken] -= amount;      lpToken.safeTransferFrom(address(this), msgSender, _nftId);      emit LogWithdraw(msgSender, baseToken, _nftId, _to); } ```   https://github.com/code-423n4/2022-03-biconomy/blob/db8a1fdddd02e8cc209a4c73ffbb3de210e4a81a/contracts/hyphen/LiquidityFarming.sol#L122-L165  ```solidity function _sendRewardsForNft(uint256 _nftId, address payable _to) internal {     NFTInfo storage nft = nftInfo[_nftId];     require(nft.isStaked, \"ERR__NFT_NOT_STAKED\");      (address baseToken, , uint256 amount) = lpToken.tokenMetadata(_nftId);     amount /= liquidityProviders.BASE_DIVISOR();      PoolInfo memory pool = updatePool(baseToken);     uint256 pending;     uint256 amountSent;     if (amount > 0) {         pending = ((amount * pool.accTokenPerShare) / ACC_TOKEN_PRECISION) - nft.rewardDebt + nft.unpaidRewards;         if (rewardTokens[baseToken] == NATIVE) {             uint256 balance = address(this).balance;             if (pending > balance) {                 unchecked {                     nft.unpaidRewards = pending - balance;                 }                 (bool success, ) = _to.call{value: balance}(\"\");                 require(success, \"ERR__NATIVE_TRANSFER_FAILED\");                 amountSent = balance;             } else {                 nft.unpaidRewards = 0;                 (bool success, ) = _to.call{value: pending}(\"\");                 require(success, \"ERR__NATIVE_TRANSFER_FAILED\");                 amountSent = pending;             }         } else {             IERC20Upgradeable rewardToken = IERC20Upgradeable(rewardTokens[baseToken]);             uint256 balance = rewardToken.balanceOf(address(this));             if (pending > balance) {                 unchecked {                     nft.unpaidRewards = pending - balance;                 }                 amountSent = _sendErc20AndGetSentAmount(rewardToken, balance, _to);             } else {                 nft.unpaidRewards = 0;                 amountSent = _sendErc20AndGetSentAmount(rewardToken, pending, _to);             }         }     }     nft.rewardDebt = (amount * pool.accTokenPerShare) / ACC_TOKEN_PRECISION;     emit LogOnReward(_msgSender(), baseToken, amountSent, _to); } ```  When `withdraw()` is called, `_sendRewardsForNft(_nftId, _to)` will be called to send the rewards.  In `_sendRewardsForNft()`, when `address(this).balance` is insufficient at the moment, `nft.unpaidRewards = pending - balance` will be recorded and the user can get it back at the next time.  However, at L244, the whole `nftInfo` is being deleted, so that `nft.unpaidRewards` will also get erased.  There is no way for the user to get back this `unpaidRewards` anymore.  ### Recommendation  Consider adding a new parameter named `force` for `withdraw()`, `require(force || unpaidRewards == 0)` before deleting nftInfo.  "}, {"title": " LiquidityFarming variable allows for hash collisions", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/131", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-03-biconomy-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-biconomy/blob/04751283f85c9fc94fb644ff2b489ec339cd9ffc/contracts/hyphen/LiquidityFarming.sol#L59 https://github.com/code-423n4/2022-03-biconomy/blob/04751283f85c9fc94fb644ff2b489ec339cd9ffc/contracts/hyphen/LiquidityFarming.sol#L196:L224 https://github.com/code-423n4/2022-03-biconomy/blob/04751283f85c9fc94fb644ff2b489ec339cd9ffc/contracts/hyphen/LiquidityFarming.sol#L229:L253   # Vulnerability details  ## Impact The `nftIdsStaked` variable introduces a hash collision vulnerability into the `LiquidityFarming.sol` contract as it is employing a mapping from address to a variable length of data field. Source: `https://github.com/code-423n4/2022-03-biconomy/blob/04751283f85c9fc94fb644ff2b489ec339cd9ffc/contracts/hyphen/LiquidityFarming.sol#L59`  The easiest attack scenario allows loss of funds for victims as the attackers can stop victims from unstaking their NFT in the `withdraw` function. Two more complicated attack scenarios allow loss of funds as attackers can outright withdraw nfts of victims.   ## Proof of Concept This attack depends very on the address of the victim an attacker would want to attack. Therefore let me just illustrate the problem.  When using an address mapping to some fixed length data field one can rely on keccak to prevent collisions.  When using an address mapping with an attacker controlled length data field an attacker has a somewhat easy path to create collisions and thereby write to or read from victims data.  The first part to understanding the attack is understanding that all the nfts of a victim are going to be in continous storage locations of the contract. Lets assume that a victims mapped to array starts at 0x1337 and the own 2 nft with the Ids: 23 and 38. The memory layout could look like this:  ``` addr  | val | description ------|-----|---- 0x1337| 2   | length of the array 0x1338| 23   | Id of the first owned nft 0x1339| 38   | Id of the second owned nft ```  Please note if the victim were to deposit more nfts those nftIds would be placed in the storage address 0x133a, 0x133b and so on.  ### Less complex attack scenario The easier attack scenario would involve the attacker generating addresses that result in a continous storage region below address 0x1337. Suppose the attacker were to generate an address whose arrays storage of nftIdsStaked lands at 0x1330. The memory layout would look like this.  ``` addr  | val | description ------|-----|---- 0x1330| 0   | length of the array 0x1337| 2   | length of the array 0x1338| 23   | Id of the first owned nft 0x1339| 38   | Id of the second owned nft ```  It is easy to see, that they could grow their array and thereby corrupting the array of the victim.  They could essentially write nftIds of worthless nftId into the storage of the victim, thereby overwriting their nftId and preventing them (or anybody else) from withdrawing them.  ### More complex attack scenario  The more complex attack scenario involves finding two addresses that will have somewhat adjacent storage regions.  Where the lower storage region encroaches on the length field of the array. The length field is attacker controlled, thereby allowing the attacker to call `withdraw` on arbitrary nftId.  ``` addr  | val | description ------|-----|---- 0x1337| 4   | length of lower array 0x1338| 37   | Id of the first owned (worthless) nft 0x1339| 39   | Id of the second owned (worthless) nft 0x133a| 40   | Id of the third owned (worthless) nft 0x133b| N    | length of higher array (attacker controlled) AND 4th nftId of lower array 0x133a| 42   | Id of the first owned (worthless) nft ```   Please note that this \"feels\" like a traditional bruteforce attack on keccak (because it is) but it is orders of magnitude more likely to be succesful.  Attackers can essentially trade bruteforcing addresses with calling `deposit` a bunch of times.  As this attack scenario is somewhat less known and more similar to traditional memory corruption attacks allow me to leave a link describing the issue in more detail: `https://xlab.tencent.com/en/2018/11/09/pay-attention-to-the-ethereum-hash-collision-problem-from-the-stealing-coins-incident/`   ## Tools Used Manual audit  ## Recommended Mitigation Steps Track nftIdsStaked like so:  ``` // user address =>        nth nft =>  nft id mapping(address => mapping(uint256 => uint256)) public nftIdsStaked; ```  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/130", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-biconomy-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/129", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-biconomy-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/128", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-biconomy-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/127", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-biconomy-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/126", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-biconomy-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/122", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-biconomy-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/117", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-biconomy-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/116", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-biconomy-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/115", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-biconomy-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/114", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-biconomy-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/112", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-biconomy-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/111", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-biconomy-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/110", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-biconomy-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/108", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-biconomy-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/107", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-biconomy-findings", "body": "Gas Optimizations"}, {"title": "wrong condition checking in price calculation", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/105", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-03-biconomy-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-biconomy/blob/04751283f85c9fc94fb644ff2b489ec339cd9ffc/contracts/hyphen/LiquidityProviders.sol#L180-L186   # Vulnerability details  ## Impact The `getTokenPriceInLPShares` function calculates the token price in LP shares, but it checks a wrong condition - if supposed to return `BASE_DIVISOR` if the total reserve is zero, not if the total shares minted is zero. This might leads to a case where the price is calculated incorrectly, or a division by zero is happening.   ## Proof of Concept This is the wrong function implementation: ```sol function getTokenPriceInLPShares(address _baseToken) public view returns (uint256) {     uint256 supply = totalSharesMinted[_baseToken];     if (supply > 0) {         return totalSharesMinted[_baseToken] / totalReserve[_baseToken];     }     return BASE_DIVISOR; } ``` This function is used in this contract only in the removeLiquidity and claimFee function, so it's called only if funds were already deposited and totalReserve is not zero, but it can be problematic when other contracts will use this function (it's a public view function so it might get called from outside of the contract).  ## Recommended Mitigation Steps The correct code should be: ```sol function getTokenPriceInLPShares(address _baseToken) public view returns (uint256) {     uint256 reserve = totalReserve[_baseToken];     if (reserve > 0) {         return totalSharesMinted[_baseToken] / totalReserve[_baseToken];     }     return BASE_DIVISOR; } ```  "}, {"title": "call to non-existing contracts returns success", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/104", "labels": ["bug", "2 (Med Risk)"], "target": "2022-03-biconomy-findings", "body": "call to non-existing contracts returns success"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/103", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-biconomy-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/102", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-biconomy-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/101", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-biconomy-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/100", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-biconomy-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/99", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-biconomy-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/95", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-biconomy-findings", "body": "QA Report"}, {"title": "Liquidity providers unable to remove liquidity when the pool is in deficit state", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/93", "labels": ["bug", "2 (Med Risk)", "disagree with severity"], "target": "2022-03-biconomy-findings", "body": "Liquidity providers unable to remove liquidity when the pool is in deficit state"}, {"title": "Incompatibility With Rebasing/Deflationary/Inflationary token", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/91", "labels": ["bug", "2 (Med Risk)"], "target": "2022-03-biconomy-findings", "body": "Incompatibility With Rebasing/Deflationary/Inflationary token"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/89", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-biconomy-findings", "body": "Gas Optimizations"}, {"title": "Incentive Pool can be drained without rebalancing the pool", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/87", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-03-biconomy-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-biconomy/blob/04751283f85c9fc94fb644ff2b489ec339cd9ffc/contracts/hyphen/LiquidityPool.sol#L149-L173 https://github.com/code-423n4/2022-03-biconomy/blob/04751283f85c9fc94fb644ff2b489ec339cd9ffc/contracts/hyphen/LiquidityPool.sol#L263-L277   # Vulnerability details  ## Impact `depositErc20` allows an attacker to specify the destination chain to be the same as the source chain and the receiver account to be the same as the caller account. This enables an attacker to drain the incentive pool without rebalancing the pool back to the equilibrium state.    ## Proof of Concept This requires the attacker to have some collateral, to begin with. The profit also depends on how much the attacker has. Assume the attacker has enough assets.  In each chain, when the pool is very deficit (e.g. `currentLiquidity` is much less than `providedLiquidity`), which often mean there's a good amount in the Incentive pool after some high valued transfers, then do the following.    - step 1 :  borrow the liquidityDifference amount such that one can get the whole incentivePool. ```             uint256 liquidityDifference = providedLiquidity - currentLiquidity;             if (amount >= liquidityDifference) {                 rewardAmount = incentivePool[tokenAddress]; ``` - step 2 : call `depositErc20()` with `toChainId` being the same chain and `receiver` being `msg.sender`.  The executor will call `sendFundsToUser` to msg.sender. Then a rewardAmount, equivalent to the entire incentive pool (up to 10% of the total pool value), will be added to `msg.sender` minus equilibrium fee (~0.01%) and gas fee.    In the end, the pool is back to the deficit state as before, the incentive pool is drained and the exploiter pockets the difference of rewardAmount minus fees.   This attack can be repeated on each deployed chain multiple times whenever the incentive pool is profitable (particularly right after a big transfer).    ## Tools Used  ## Recommended Mitigation Steps - Disallow `toChainId` to be the source chain by validating it in `depositErc20` or in `sendFundsToUser` validate that `fromChainId` is not the same as current chain.  - require `receiver` is not `msg.sender` in `depositErc20`.      "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/84", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-biconomy-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/83", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-biconomy-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/82", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-biconomy-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/81", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-biconomy-findings", "body": "Gas Optimizations"}, {"title": "Owners have absolute control over protocol", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/80", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-03-biconomy-findings", "body": "Owners have absolute control over protocol"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/78", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-biconomy-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/77", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-biconomy-findings", "body": "Gas Optimizations"}, {"title": "WhitelistPeriodManager: Improper state handling of exclusion additions", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/75", "labels": ["bug", "2 (Med Risk)"], "target": "2022-03-biconomy-findings", "body": "WhitelistPeriodManager: Improper state handling of exclusion additions"}, {"title": "WhitelistPeriodManager: Improper state handling of exclusion removals", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/72", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-03-biconomy-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-biconomy/blob/main/contracts/hyphen/WhitelistPeriodManager.sol#L178-L184 https://github.com/code-423n4/2022-03-biconomy/blob/main/contracts/hyphen/WhitelistPeriodManager.sol#L115-L125   # Vulnerability details  ## Impact  The `totalLiquidity` and `totalLiquidityByLp` mappings are not updated when an address is removed from the `isExcludedAddress` mapping. While this affects the enforcement of the cap limits and the `getMaxCommunityLpPositon()` function, the worst impact this has is that the address cannot have liquidity removed / transferred due to subtraction overflow.  In particular, users can be prevented from withdrawing their staked LP tokens from the liquidity farming contract should it become non-excluded.  ## Proof of Concept  - Assume liquidity farming address `0xA` is excluded - Bob stakes his LP token - Liquidity farming contract is no longer to be excluded: `setIsExcludedAddressStatus([0xA, false])` - Bob attempts to withdraw liquidity \u2192 reverts because `totalLiquidityByLp[USDC][0xA] = 0`, resulting in subtraction overflow.  ```jsx // insert test case in Withdraw test block of LiquidityFarming.tests.ts it.only('will brick withdrawals by no longer excluding farming contract', async () => {   await farmingContract.deposit(1, bob.address);   await wlpm.setIsExcludedAddressStatus([farmingContract.address], [false]);   await farmingContract.connect(bob).withdraw(1, bob.address); });  // results in // Error: VM Exception while processing transaction: reverted with panic code 0x11 (Arithmetic operation underflowed or overflowed outside of an unchecked block) ```  ## Recommended Mitigation Steps  The simplest way is to prevent exclusion removals.  ```jsx function setIsExcludedAddresses(address[] memory _addresses) external onlyOwner {   for (uint256 i = 0; i < _addresses.length; ++i) {     isExcludedAddress[_addresses[i]] = true;     // emit event     emit AddressExcluded(_addresses[i]);   } } ```  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/69", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-biconomy-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/67", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-biconomy-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/66", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-biconomy-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/65", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-biconomy-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/62", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-biconomy-findings", "body": "QA Report"}, {"title": "Can deposit native token for free and steal funds", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/55", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-03-biconomy-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-biconomy/blob/db8a1fdddd02e8cc209a4c73ffbb3de210e4a81a/contracts/hyphen/LiquidityPool.sol#L151   # Vulnerability details  ## Impact The `depositErc20` function allows setting `tokenAddress = NATIVE` and does not throw an error. No matter the `amount` chosen, the `SafeERC20Upgradeable.safeTransferFrom(IERC20Upgradeable(tokenAddress), sender, address(this), amount);` call will not revert because it performs a low-level call to `NATIVE = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE`, which is an EOA, and the low-level calls to EOAs always succeed. Because the `safe*` version is used, the EOA not returning any data does not revert either.  This allows an attacker to deposit infinite native tokens by not paying anything. The contract will emit the same `Deposit` event as a real `depositNative` call and the attacker receives the native funds on the other chain.  ## Recommended Mitigation Steps Check `tokenAddress != NATIVE` in `depositErc20`.   "}, {"title": "Unsupported tokens cannot be withdrawn", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/54", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-03-biconomy-findings", "body": "Unsupported tokens cannot be withdrawn"}, {"title": "`sharesToTokenAmount`: Division by zero", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/53", "labels": ["bug", "2 (Med Risk)"], "target": "2022-03-biconomy-findings", "body": "`sharesToTokenAmount`: Division by zero"}, {"title": "`LiquidityProviders`: Setting new liquidity pool will break contract", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/52", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-03-biconomy-findings", "body": "`LiquidityProviders`: Setting new liquidity pool will break contract"}, {"title": "`LiquidityProviders`: Setting new LP token will break contract", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/51", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-03-biconomy-findings", "body": "`LiquidityProviders`: Setting new LP token will break contract"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/43", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-biconomy-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/42", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-biconomy-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/41", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-biconomy-findings", "body": "Gas Optimizations"}, {"title": "Wrong formula when add fee `incentivePool` can lead to loss of funds.", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/38", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-03-biconomy-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-biconomy/blob/db8a1fdddd02e8cc209a4c73ffbb3de210e4a81a/contracts/hyphen/LiquidityPool.sol#L319-L322   # Vulnerability details  ## Impact The `getAmountToTransfer` function of `LiquidityPool` updates `incentivePool[tokenAddress]` by adding some fee to it but the formula is wrong and the value of `incentivePool[tokenAddress]` will be divided by `BASE_DIVISOR` (10000000000) each time. After just a few time, the value of `incentivePool[tokenAddress]` will become zero and that amount of `tokenAddress` token will be locked in contract. ## Proof of concept Line 319-322 ``` incentivePool[tokenAddress] = (incentivePool[tokenAddress] + (amount * (transferFeePerc - tokenManager.getTokensInfo(tokenAddress).equilibriumFee))) / BASE_DIVISOR; ``` Let `x = incentivePool[tokenAddress]`, `y = amount`, `z = transferFeePerc` and `t = tokenManager.getTokensInfo(tokenAddress).equilibriumFee`. Then that be written as ``` x = (x + (y * (z - t))) / BASE_DIVISOR; x = x / BASE_DIVISOR + (y * (z - t)) / BASE_DIVISOR; ``` ## Recommended Mitigation Steps Fix the bug by change line 319-322 to: ``` incentivePool[tokenAddress] += (amount * (transferFeePerc - tokenManager.getTokensInfo(tokenAddress).equilibriumFee)) / BASE_DIVISOR; ```   "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/35", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-biconomy-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/33", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-biconomy-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/32", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-biconomy-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/31", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-biconomy-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/30", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-biconomy-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/27", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-biconomy-findings", "body": "Gas Optimizations"}, {"title": "unnecessary receive function", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/25", "labels": ["bug", "duplicate", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-03-biconomy-findings", "body": "unnecessary receive function"}, {"title": "DoS by gas limit", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/24", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-03-biconomy-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-biconomy/blob/main/contracts/hyphen/LiquidityFarming.sol#L220 https://github.com/code-423n4/2022-03-biconomy/blob/main/contracts/hyphen/LiquidityFarming.sol#L233   # Vulnerability details  In `deposit` function it is possible to push to `nftIdsStaked` of anyone, an attacker can deposit too many nfts to another user, and when the user will try to withdraw an nft at the end of the list, they will iterate on the list and revert because of gas limit.   "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/21", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-biconomy-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/11", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-03-biconomy-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/9", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-biconomy-findings", "body": "QA Report"}, {"title": "Improper Upper Bound Definition on the Fee", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/8", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-03-biconomy-findings", "body": "Improper Upper Bound Definition on the Fee"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/6", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-03-biconomy-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-biconomy-findings/issues/5", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-03-biconomy-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-maple-findings/issues/39", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-03-maple-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-maple-findings/issues/38", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2022-03-maple-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-maple-findings/issues/36", "labels": ["bug", "G (Gas Optimization)", "sponsor disputed"], "target": "2022-03-maple-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-maple-findings/issues/35", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "sponsor disputed"], "target": "2022-03-maple-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-maple-findings/issues/34", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "sponsor disputed"], "target": "2022-03-maple-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-maple-findings/issues/32", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-03-maple-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-maple-findings/issues/31", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged", "sponsor confirmed"], "target": "2022-03-maple-findings", "body": "Gas Optimizations"}, {"title": "Processes refinance operations may call malicious code by re-created refinancer contract", "html_url": "https://github.com/code-423n4/2022-03-maple-findings/issues/23", "labels": ["bug", "2 (Med Risk)", "sponsor disputed"], "target": "2022-03-maple-findings", "body": "Processes refinance operations may call malicious code by re-created refinancer contract"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-maple-findings/issues/22", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2022-03-maple-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-maple-findings/issues/21", "labels": ["bug", "QA (Quality Assurance)", "disagree with severity", "sponsor confirmed"], "target": "2022-03-maple-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-maple-findings/issues/20", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged", "sponsor confirmed"], "target": "2022-03-maple-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-maple-findings/issues/18", "labels": ["bug", "G (Gas Optimization)", "sponsor disputed"], "target": "2022-03-maple-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-maple-findings/issues/17", "labels": ["bug", "QA (Quality Assurance)", "disagree with severity", "sponsor confirmed"], "target": "2022-03-maple-findings", "body": "QA Report"}, {"title": "Incorrect implementation of Lender can result in lost tokens", "html_url": "https://github.com/code-423n4/2022-03-maple-findings/issues/16", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed"], "target": "2022-03-maple-findings", "body": "# Lines of code  https://github.com/maple-labs/loan/blob/main/contracts/MapleLoanInternals.sol#L332-L344   # Vulnerability details  ## Impact MapleLoanInternals._sendFee should check returnData.length == 32 before decoding, otherwise if it returns bytes data, the abi.decode will return 0x20, result in lost tokens. ## Proof of Concept https://github.com/maple-labs/loan/blob/main/contracts/MapleLoanInternals.sol#L332-L344 This contract can test that when the function returns bytes data, abi.encode will decode the return value as 0x20. ``` pragma solidity 0.8.7; contract A{     address public destination;     uint256 public number;     function convertA() external{         (bool su,bytes memory ret )= address(this).call(abi.encodeWithSelector(this.ret.selector));         number = ret.length;         destination = abi.decode(ret, (address));     }     function ret() public returns(bytes memory){         return \"0x74d754378a59Ab45d3E6CaC83f0b87E8E8719270\";     } } ``` ## Tools Used None ## Recommended Mitigation Steps ```     function _sendFee(address lookup_, bytes4 selector_, uint256 amount_) internal returns (bool success_) {         if (amount_ == uint256(0)) return true;          ( bool success , bytes memory data ) = lookup_.call(abi.encodeWithSelector(selector_));  +       if (!success || data.length != uint256(32)) return false;          address destination = abi.decode(data, (address));          if (destination == address(0)) return false;          return ERC20Helper.transfer(_fundsAsset, destination, amount_);     } ```   "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-maple-findings/issues/15", "labels": ["bug", "G (Gas Optimization)", "sponsor disputed"], "target": "2022-03-maple-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-maple-findings/issues/14", "labels": ["bug", "QA (Quality Assurance)", "disagree with severity", "sponsor confirmed"], "target": "2022-03-maple-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-maple-findings/issues/13", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-03-maple-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-maple-findings/issues/12", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-maple-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-maple-findings/issues/11", "labels": ["bug", "G (Gas Optimization)", "sponsor disputed"], "target": "2022-03-maple-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-maple-findings/issues/7", "labels": ["bug", "QA (Quality Assurance)", "disagree with severity", "sponsor confirmed"], "target": "2022-03-maple-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-maple-findings/issues/6", "labels": ["bug", "G (Gas Optimization)", "sponsor disputed"], "target": "2022-03-maple-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-03-maple-findings/issues/4", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-03-maple-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-maple-findings/issues/3", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-03-maple-findings", "body": "QA Report"}, {"title": "Spreads can be minted with a deactivated oracle", "html_url": "https://github.com/code-423n4/2022-03-rolla-findings/issues/66", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-03-rolla-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/libraries/FundsCalculator.sol#L91-L117   # Vulnerability details  ## Impact  When deactivateOracle() is called for an oracle in OracleRegistry it is still available for option spreads minting.  This way a user can continue to mint new options within spreads that rely on an oracle that was deactivated. As economic output of spreads is close to vanilla options, so all users who already posses an option linked to a deactivated oracle can surpass this deactivation, being able to mint new options linked to it as a part of option spreads.  ## Proof of Concept  Oracle active state is checked with isOracleActive() during option creation in validateOptionParameters() and during option minting in _mintOptionsPosition().  It isn't checked during spreads creation:  https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/libraries/FundsCalculator.sol#L91-L117  In other words besides vanilla option minting and creation all spectrum of operations is available for the deactivated oracle assets, including spreads minting, which economically is reasonably close to vanilla minting.  ## Recommended Mitigation Steps  If oracle deactivation is meant to transfer all related assets to the close only state then consider requiring oracle to be active on spreads minting as well in the same way it's done for vanilla option minting:  https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/Controller.sol#L188-L197   "}, {"title": "Arbitrary code can be run with Controller as msg.sender", "html_url": "https://github.com/code-423n4/2022-03-rolla-findings/issues/65", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-03-rolla-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/Controller.sol#L497-L516   # Vulnerability details  ## Impact  A malicious user can call Controller's operate with ActionType.QTokenPermit, providing a precooked contract address as qToken, that will be called by Controller contract with IQToken(_qToken).permit(), which implementation can be arbitrary as long as IQToken interface and permit signature is implemented.  The Controller is asset bearing contract and it will be msg.sender in this arbitrary permit() function called, which is a setup that better be avoided.  ## Proof of Concept  When the Controller's operate with a QTokenPermit action, it parses the arguments with Actions library and then calls internal _qTokenPermit:  https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/Controller.sol#L91-L92  _qTokenPermit calls the IQToken(_qToken) address provided without performing any additional checks:  https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/Controller.sol#L497-L516  This way, contrary to the approach used in other actions, qToken isn't checked to be properly created address and is used right away, while the requirement that the address provided should implement IQToken interface and have permit function with a given signature can be easily met with a precooked contract.  ## Recommended Mitigation Steps  Given that QToken can be called directly please examine the need for QTokenPermit ActionType.  If current approach is based on UI convenience and better be kept, consider probing for IOptionsFactory(optionsFactory).isQToken(_qToken) before calling the address provided.  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-rolla-findings/issues/63", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-03-rolla-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-rolla-findings/issues/62", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-03-rolla-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-rolla-findings/issues/61", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-03-rolla-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-rolla-findings/issues/58", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-03-rolla-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-rolla-findings/issues/56", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-03-rolla-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-rolla-findings/issues/54", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-03-rolla-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-rolla-findings/issues/52", "labels": ["bug", "QA (Quality Assurance)", "sponsor disputed"], "target": "2022-03-rolla-findings", "body": "QA Report"}, {"title": "Low-level transfer via call() can fail silently", "html_url": "https://github.com/code-423n4/2022-03-rolla-findings/issues/51", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-03-rolla-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-rolla/blob/a06418c9cc847395f3699bdf684a9ac066651ed7/quant-protocol/contracts/timelock/TimelockController.sol#L414-L415   # Vulnerability details  ## Impact In the `_call()` function in `TimelockController.sol`, a call is executed with the following code:  ``` function _call(         bytes32 id,         uint256 index,         address target,         uint256 value,         bytes memory data     ) private {         // solhint-disable-next-line avoid-low-level-calls         (bool success, ) = target.call{value: value}(data);         require(success, \"TimelockController: underlying transaction reverted\");          emit CallExecuted(id, index, target, value, data);     } ```  Per the Solidity docs:  \"The low-level functions call, delegatecall and staticcall return true as their first return value if the account called is non-existent, as part of the design of the EVM. Account existence must be checked prior to calling if needed.\"   Therefore, transfers may fail silently.  ## Proof of Concept Please find the documentation here: https://docs.soliditylang.org/en/develop/control-structures.html#error-handling-assert-require-revert-and-exceptions  ## Tools Used Manual review.  ## Recommended Mitigation Steps Check for the account's existence prior to transferring.  "}, {"title": "[WP-H6] Admin of the upgradeable proxy contract of `Controller.sol` can rug users", "html_url": "https://github.com/code-423n4/2022-03-rolla-findings/issues/48", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-03-rolla-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-rolla/blob/a06418c9cc847395f3699bdf684a9ac066651ed7/quant-protocol/contracts/Controller.sol#L22-L34   # Vulnerability details  Use of Upgradeable Proxy Contract Structure allows the logic of the contract to be arbitrarily changed.  This allows the proxy admin to perform malicious actions e.g., taking funds from users' wallets up to the allowance limit.  This action can be performed by the malicious/compromised proxy admin without any restriction.   Considering that the purpose of this particular contract is for accounting of the Collateral and LongShortTokens, we believe the users' allowances should not be hold by this upgradeable contract.  ### PoC  Given:  - collateral: `USDC`  #### Rug Users' Allowances  1. Alice `approve()` and `_mintOptionsPosition()` with `1e8 USDC`; 2. Bob  `approve()` and `_mintOptionsPosition()` with `5e8 USDC`; 3. A malicious/compromised proxy admin can call `upgradeToAndCall()` on the proxy contract and set a malicious contract as `newImplementation` and stolen all the USDC in Alice and Bob's wallets;  #### Rug Contract's Holdings (funds that belongs to users)  A malicious/compromised proxy admin can just call `upgradeToAndCall()` on the proxy contract and send all the USDC held by the contract to an arbitrary address.  ### Severity  A smart contract being structured as an upgradeable contract alone is not usually considered as a high severity risk. But given the severe impact (all the funds in the contract and funds in users' wallets can be stolen), we mark it as a `High` severity issue.  ### Recommendation  Consider using the non-upgradeable `CollateralToken` contract to hold user's allowances instead.  See also the Recommendation of [WP-H7].  "}, {"title": "[WP-M3] `OperateProxy.callFunction()` should check if the `callee` is a contract", "html_url": "https://github.com/code-423n4/2022-03-rolla-findings/issues/46", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-03-rolla-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/utils/OperateProxy.sol#L10-L19   # Vulnerability details  https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/Controller.sol#L550-L558  ```solidity     /// @notice Allows a sender/signer to make external calls to any other contract.     /// @dev A separate OperateProxy contract is used to make the external calls so     /// that the Controller, which holds funds and has special privileges in the Quant     /// Protocol, is never the `msg.sender` in any of those external calls.     /// @param _callee The address of the contract to be called.     /// @param _data The calldata to be sent to the contract.     function _call(address _callee, bytes memory _data) internal {         IOperateProxy(operateProxy).callFunction(_callee, _data);     } ```  https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/utils/OperateProxy.sol#L10-L19  ```solidity     function callFunction(address callee, bytes memory data) external override {         require(             callee != address(0),             \"OperateProxy: cannot make function calls to the zero address\"         );          (bool success, bytes memory returnData) = address(callee).call(data);         require(success, \"OperateProxy: low-level call failed\");         emit FunctionCallExecuted(tx.origin, returnData);     } ```  As the `OperateProxy.sol#callFunction()` function not payable, we believe it's not the desired behavior to call a non-contract address and consider it a successful call.  For example, if a certain business logic requires a successful `token.transferFrom()` call to be made with the `OperateProxy`, if the `token` is not a existing contract, the call will return `success: true` instead of `success: false` and break the caller's assumption and potentially malfunction features or even cause fund loss to users.  The qBridge exploit (January 2022) was caused by a similar issue.  As a reference, OpenZeppelin's `Address.functionCall()` will check and `require(isContract(target), \"Address: call to non-contract\");`  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.5.0/contracts/utils/Address.sol#L135  ```solidity     function functionCallWithValue(         address target,         bytes memory data,         uint256 value,         string memory errorMessage     ) internal returns (bytes memory) {         require(address(this).balance >= value, \"Address: insufficient balance for call\");         require(isContract(target), \"Address: call to non-contract\");          (bool success, bytes memory returndata) = target.call{value: value}(data);         return verifyCallResult(success, returndata, errorMessage);     } ```  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.5.0/contracts/utils/Address.sol#L36-L42  ```solidity     function isContract(address account) internal view returns (bool) {         // This method relies on extcodesize/address.code.length, which returns 0         // for contracts in construction, since the code is only stored at the end         // of the constructor execution.          return account.code.length > 0;     } ```  ### Recommendation  Consider adding a check and throw when the `callee` is not a contract.  "}, {"title": "[WP-H2] `EIP712MetaTransaction.executeMetaTransaction()` failed txs are open to replay attacks", "html_url": "https://github.com/code-423n4/2022-03-rolla-findings/issues/45", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2022-03-rolla-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/utils/EIP712MetaTransaction.sol#L86   # Vulnerability details  Any transactions that fail based on some conditions that may change in the future are not safe to be executed again later (e.g. transactions that are based on others actions, or time-dependent etc).  In the current implementation, once the low-level call is failed, the whole tx will be reverted and so that `_nonces[metaAction.from]` will remain unchanged.  As a result, the same tx can be replayed by anyone, using the same signature.  https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/utils/EIP712MetaTransaction.sol#L86  ```solidity     function executeMetaTransaction(         MetaAction memory metaAction,         bytes32 r,         bytes32 s,         uint8 v     ) external payable returns (bytes memory) {         require(             _verify(metaAction.from, metaAction, r, s, v),             \"signer and signature don't match\"         );          uint256 currentNonce = _nonces[metaAction.from];          // intentionally allow this to overflow to save gas,         // and it's impossible for someone to do 2 ^ 256 - 1 meta txs         unchecked {             _nonces[metaAction.from] = currentNonce + 1;         }          // Append the metaAction.from at the end so that it can be extracted later         // from the calling context (see _msgSender() below)         (bool success, bytes memory returnData) = address(this).call(             abi.encodePacked(                 abi.encodeWithSelector(                     IController(address(this)).operate.selector,                     metaAction.actions                 ),                 metaAction.from             )         );          require(success, \"unsuccessful function call\");         emit MetaTransactionExecuted(             metaAction.from,             payable(msg.sender),             currentNonce         );         return returnData;     } ```  See also the implementation of OpenZeppelin's `MinimalForwarder`:  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.5.0/contracts/metatx/MinimalForwarder.sol#L42-L66  ### PoC  Given:  - The collateral is USDC; - Alice got `10,000 USDC` in the wallet.  1. Alice submitted a MetaTransaction to `operate()` and `_mintOptionsPosition()` with `10,000 USDC`; 2. Before the MetaTransaction get executed, Alice sent `1,000 USDC` to Bob; 3. The MetaTransaction submited by Alice in step 1 get executed but failed; 4. A few days later, Bob sent `1,000 USDC` to Alice; 5. The attacker can replay the MetaTransaction failed to execute at step 3 and succeed.  Alice's `10,000 USDC` is now been spent unexpectedly against her will and can potentially cause fund loss depends on the market situation.  ### Recommendation  Failed txs should still increase the nonce.  While implementating the change above, consider adding one more check to require sufficient gas to be paid, to prevent \"insufficient gas griefing attack\" as described in [this article](https://ipfs.io/ipfs/QmbbYTGTeot9ic4hVrsvnvVuHw4b5P7F5SeMSNX9TYPGjY/blog/ethereum-gas-dangers/).  "}, {"title": " [WP-H0] Wrong implementation of `EIP712MetaTransaction`", "html_url": "https://github.com/code-423n4/2022-03-rolla-findings/issues/43", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2022-03-rolla-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/utils/EIP712MetaTransaction.sol#L102-L114   # Vulnerability details  1. `EIP712MetaTransaction` is a utils contract that intended to be inherited by concrete (actual) contracts, therefore. it's initializer function should not use the `initializer` modifier, instead, it should use `onlyInitializing` modifier. See the implementation of [openzeppelin `EIP712Upgradeable` initializer function](https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/v4.5.1/contracts/utils/cryptography/draft-EIP712Upgradeable.sol#L48-L57).  https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/utils/EIP712MetaTransaction.sol#L102-L114  ```solidity     /// @notice initialize method for EIP712Upgradeable     /// @dev called once after initial deployment and every upgrade.     /// @param _name the user readable name of the signing domain for EIP712     /// @param _version the current major version of the signing domain for EIP712     function initializeEIP712(string memory _name, string memory _version)         public         initializer     {         name = _name;         version = _version;          __EIP712_init(_name, _version);     } ```  Otherwise, when the concrete contract's initializer function (with a `initializer` modifier) is calling EIP712MetaTransaction's initializer function, it will be mistok as reentered and so that it will be reverted (unless in the context of a constructor, e.g. Using @openzeppelin/hardhat-upgrades `deployProxy()` to initialize).  https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/v4.5.1/contracts/proxy/utils/Initializable.sol#L50-L53  ```solidity     /**      * @dev Modifier to protect an initializer function from being invoked twice.      */     modifier initializer() {         // If the contract is initializing we ignore whether _initialized is set in order to support multiple         // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the         // contract may have been reentered.         require(_initializing ? _isConstructor() : !_initialized, \"Initializable: contract is already initialized\");          bool isTopLevelCall = !_initializing;         if (isTopLevelCall) {             _initializing = true;             _initialized = true;         }          _;          if (isTopLevelCall) {             _initializing = false;         }     } ```  See also: https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/releases/tag/v4.4.1   2. `initializer` can only be called once, it can not be \"called once after every upgrade\".  https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/utils/EIP712MetaTransaction.sol#L102-L114  ```solidity     /// @notice initialize method for EIP712Upgradeable     /// @dev called once after initial deployment and every upgrade.     /// @param _name the user readable name of the signing domain for EIP712     /// @param _version the current major version of the signing domain for EIP712     function initializeEIP712(string memory _name, string memory _version)         public         initializer     {         name = _name;         version = _version;          __EIP712_init(_name, _version);     } ```   3. A utils contract that is not expected to be deployed as a standalone contract should be declared as `abstract`. It's `initializer` function should be `internal`.  See the implementation of [openzeppelin `EIP712Upgradeable`](https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/v4.5.1/contracts/utils/cryptography/draft-EIP712Upgradeable.sol#L28).  https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/v4.5.1/contracts/utils/cryptography/draft-EIP712Upgradeable.sol#L28  ```solidity abstract contract EIP712Upgradeable is Initializable {     // ... } ```  ### Recommendation  Change to:  ```solidity abstract contract EIP712MetaTransaction is EIP712Upgradeable {     // ... } ```  ```solidity     /// @notice initialize method for EIP712Upgradeable     /// @dev called once after initial deployment.     /// @param _name the user readable name of the signing domain for EIP712     /// @param _version the current major version of the signing domain for EIP712     function __EIP712MetaTransaction_init(string memory _name, string memory _version)         internal         onlyInitializing     {         name = _name;         version = _version;          __EIP712_init(_name, _version);     } ```    "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-rolla-findings/issues/42", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-03-rolla-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-rolla-findings/issues/41", "labels": ["bug", "QA (Quality Assurance)", "disagree with severity", "sponsor confirmed"], "target": "2022-03-rolla-findings", "body": "QA Report"}, {"title": "QTokens with the same symbol will lead to mistakes", "html_url": "https://github.com/code-423n4/2022-03-rolla-findings/issues/38", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-03-rolla-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/options/QTokenStringUtils.sol#L115-L130   # Vulnerability details  The `README.md` states: > Bob can then trade the QToken with Alice for a premium. The method for doing that is beyond the scope of the protocol but can be done via any smart contract trading platform e.g. 0x.  https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/README.md?plain=1#L70  It is therefore important that tokens be easily identifiable so that trading on DEXes is not error-prone.  ## Impact Currently the `QToken` `name` includes the full year but the `QToken` symbol only contains the last two digits of the year, which can lead to mistakes. If someone mints a QToken with an expiry 100 years into the future, then the year will be truncated and appear as if the token expired this year. Normal centralized exchanges prevent this by listing options themselves and ensuring that there are never two options with the same identifier at the same time. The Rolla protocol does not have any such protections. Users must be told to not only check that the symbol name is what they expect, but to also separately check the token name or the specific expiry, or they might buy the wrong option on a DEX, or have fat-fingered during minting on a non-Rolla web interface. It's important to minimize the possibility of mistakes, and not including the full year in the symbol makes things error-prone, and will lead to other options providers winning out.  The 0x [REST interface](https://docs.0x.org/0x-api-swap/api-references/get-swap-v1-quote) for swaps has the ability to do a swap by token name rather than by token address. I was unable to figure out whether there was an allow-list of token names, or if it is easy to add a new token. If there is no, or an easily bypassed, access-control for adding new tokens, I would say this finding should be upgraded to high-severity, though I doubt this is the case.  ## Proof of Concept ```solidity         /// concatenated symbol string         tokenSymbol = string(             abi.encodePacked(                 \"ROLLA\",                 \"-\",                 underlying,                 \"-\",                 _uintToChars(day),                 monthSymbol,                 _uintToChars(year),                 \"-\",                 displayStrikePrice,                 \"-\",                 typeSymbol             )         ); ``` https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/options/QTokenStringUtils.sol#L115-L130  ```solidity     /// @return 2 characters that correspond to a number     function _uintToChars(uint256 _number)         internal         pure         virtual         returns (string memory)     {         if (_number > 99) {             _number %= 100;         }          string memory str = Strings.toString(_number);          if (_number < 10) {             return string(abi.encodePacked(\"0\", str));         }          return str;     } ``` https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/options/QTokenStringUtils.sol#L181-L199  ## Tools Used Code inspection  ## Recommended Mitigation Steps Include the full year in the token's symbol   "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-rolla-findings/issues/37", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-03-rolla-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-rolla-findings/issues/36", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-03-rolla-findings", "body": "QA Report"}, {"title": "Mint spread collateral-less and conjuring collateral claims out of thin air with implicit arithmetic rounding and flawed int to uint conversion", "html_url": "https://github.com/code-423n4/2022-03-rolla-findings/issues/31", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2022-03-rolla-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/libraries/QuantMath.sol#L137 https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/libraries/QuantMath.sol#L151 https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/libraries/SignedConverter.sol#L28   # Vulnerability details  ## Impact  This report presents 2 different incorrect behaviour that can affect the correctness of math calculations 1. Unattended Implicit rounding in QuantMath.sol `div` and `mul` 2. Inappropriate method of casting integer to unsigned integer in SignedConverter.sol `intToUint`  Bug 1 affects the correctness when calculating collateral required for `_mintSpread`. Bug 2 expands the attack surface and allows attackers to target the `_claimCollateral` phase instead. Both attacks may result in tokens being stolen from Controller in the worst case, but is most likely too costly to exploit under current BNB chain environment. The potential impact however, should not be taken lightly, since it is known that the ethereum environment in highly volatile and minor changes in the environment can suddenly make those bugs cheap to exploit.   ## Proof of Concept  In this section, we will first present bug 1, and then demonstrate how this bug can be exploited. Then we will discuss how bug 2 opens up more attack chances and go over another PoC.  Before getting started, we should go over an important concept while dealing with fixed point number -- rounding. Math has no limits on precision, but computers do. This problem is especially critical to systems handling large amount of \"money\" that is allowed to be arbitrarily divided. A common way for ethereum smart contract developers to handle this is through rounding numbers. Rolla is no exception.  In QuantMath, Rolla explicitly wrote the `toScaledUint` function to differentiate between rounding numbers up or down when scaling numbers to different precision (or we call it `_decimals` here). The intended usage is to scale calculated numbers (amount of tokens) up when Controller is the receiver, and scale it down when Controller is sender. In theory, this function should guarantee Controller can never \"lose tokens\" due to rounding.  ``` library QuantMath {     ...     struct FixedPointInt {         int256 value;     }      int256 private constant _SCALING_FACTOR = 1e27;     uint256 private constant _BASE_DECIMALS = 27;      ...      function toScaledUint(         FixedPointInt memory _a,         uint256 _decimals,         bool _roundDown     ) internal pure returns (uint256) {         uint256 scaledUint;          if (_decimals == _BASE_DECIMALS) {             scaledUint = _a.value.intToUint();         } else if (_decimals > _BASE_DECIMALS) {             uint256 exp = _decimals - _BASE_DECIMALS;             scaledUint = (_a.value).intToUint() * 10**exp;         } else {             uint256 exp = _BASE_DECIMALS - _decimals;             uint256 tailing;             if (!_roundDown) {                 uint256 remainer = (_a.value).intToUint() % 10**exp;                 if (remainer > 0) tailing = 1;             }             scaledUint = (_a.value).intToUint() / 10**exp + tailing;         }          return scaledUint;     }     ... } ```  In practice, the above function also works quite well (sadly, not perfect, notice the `intToUint` function within. We will come back to this later), but it only works if we can promise that before entering this function, all numbers retain full precision and is not already rounded. This is where `div` and `mul` comes into play. As we can easily see in the snippet below, both functions involve the division operator '/', which by default discards the decimal part of the calculated result (be aware to not confuse this with the `_decimal` used while scaling FixedPointInt). The operation here results in an implicit round down, which limits the effectiveness of  explicit rounding in `toScaledUint` showned above.  ```     function mul(FixedPointInt memory a, FixedPointInt memory b)         internal         pure         returns (FixedPointInt memory)     {         return FixedPointInt((a.value * b.value) / _SCALING_FACTOR);     }       function div(FixedPointInt memory a, FixedPointInt memory b)         internal         pure         returns (FixedPointInt memory)     {         return FixedPointInt((a.value * _SCALING_FACTOR) / b.value);     } ```  Now let's see how this implicit rounding can causes troubles. We start with the `_mintSpread` procedure creating a call credit spread. For brevity, the related code is not shown, but here's a summary of what is done.  * `Controller._mintSpread`   * `QuantCalculator.getCollateralRequirement`     * `FundsCalculator.getCollateralRequirement`       * `FundsCalculator.getOptionCollateralRequirement`         * `FundsCalculator.getCallCollateralRequirement`           * scales `_qTokenToMintStrikePrice` from              `_strikeAssetDecimals (8)` to `_BASE_DECIMALS (27)`           * scales `_qTokenForCollateralStrikePrice` from              `_strikeAssetDecimals (8)` to `_BASE_DECIMALS (27)`           * `collateralPerOption = (collateralStrikePrice.sub(mintStrikePrice)).div(collateralStrikePrice)`         * scale `_optionsAmount` from `_optionsDecimals (18)` to `_BASE_DECIMALS (27)`         * `collateralAmount = _optionsAmount.mul(collateralPerOption)`       * uses `qTokenToMint.underlyingAsset` (weth or wbtc) as collateral     * scale and round up `collateralAmountFP` from `_BASE_DECIMALS (27)` to `payoutDecimals (18)`  If we extract all the math related stuff, it would be something like below  ``` def callCreditSpreadCollateralRequirement(_qTokenToMintStrikePrice, _qTokenForCollateralStrikePrice, _optionsAmount):         X1 = _qTokenToMintStrikePrice * 10^19         X2 = _qTokenForCollateralStrikePrice * 10^19         X3 = _optionsAmount * 10^9          assert X1 < X2          #credit spread          Y1 = (X2 - X1) * 10^27 // X2    #implicit round down due to div         Y2 = Y1 * X3 // 10^27   #implicit round down due to mul          Z = Y2 // 10^9         if Y2 % 10^9 > 0:       #round up since we are minting spread (Controller is receiver)                 Z+=1         return Z ```  Both implicit round downs can be abused, but we shall focus on the `mul` one here. Assume we follow the following actions  1. create option `A` with strike price `10 + 10^-8 BUSD (10^9 + 1 under 8 decimals) <-> 1 WETH` 2. create option `B` with strike price `10 BUSD (10^9 under 8 decimals) <-> 1 WETH` 3. mint `10^-18` (1 under 18 decimals) option `A`         3-1. `pay 1 eth` 4. mint `10^-18` (1 under 18 decimals) spread `B` with `A` as collateral         4-1. `X1 = _qTokenToMintStrikePrice * 10^19 = 10^9 * 10^19 = 10^28`         4-2. `X2 = _qTokenToMintStrikePrice * 10^19 = (10^9 + 1) * 10^19 = 10^28 + 10^19`         4-3. `X3 = _optionsAmount * 10^9 = 1 * 10^9 = 10^9`         4-4. `Y1 = (X2 - X1) * 10^27 // X2 = (10^28 + 10^19 - 10^28) * 10^27 // (10^28 + 10^19) = 99999999000000000`         4-5. `Y2 = Y1 * X3 // 10^27 = 99999999000000000 * 10^9 / 10^27 = 0`         4-6. `Z = Y2 // 10^9 = 0`         4-7. `Y2 % 10^9 = 0` so `Z` remains unchanged  We minted a call credit spread without paying any fee.  Now let's think about how to extract the value we conjured out of thin air. To be able to withdraw excessive collateral, we can choose to do a excercise+claim or neutralize current options. Here we take the neutralize path.  For neutralizing spreads, the procedure is basically the same as minting spreads, except that the explicit round down is taken since `Controller` is the payer here. The neutralize procedure returns the `qToken` used as collateral and pays the collateral fee back. The math part can be summarized as below.  ``` def neutralizeCreditSpreadCollateralRequirement(_qTokenToMintStrikePrice, _qTokenForCollateralStrikePrice, _optionsAmount):         X1 = _qTokenToMintStrikePrice * 10^19         X2 = _qTokenForCollateralStrikePrice * 10^19         X3 = _optionsAmount * 10^9          assert X1 < X2          #credit spread          Y1 = (X2 - X1) * 10^27 // X2    #implicit round down due to div         Y2 = Y1 * X3 // 10^27   #implicit round down due to mul          Z = Y2 // 10^9  #explicit scaling         return Z ```  There are two challenges that need to be bypassed, the first one is to avoid implicit round down in `mul`, and the second is to ensure the revenue is not rounded away during explicit scaling. To achieve this, we first mint `10^-9 + 2 * 10^-18` spreads seperately (10^9 + 2 under 18 decimals), and as shown before, no additional fees are required while minting spread from original option. Then we neutralize all those spreads at once, the calculation is shown below  1. neutralize `10^-9 + 2 * 10^-18` (10^9 + 2 under 18 decimals) spread `B`         4-1. `X1 = _qTokenToMintStrikePrice * 10^19 = 10^9 * 10^19 = 10^28`         4-2. `X2 = _qTokenToMintStrikePrice * 10^19 = (10^9 + 1) * 10^19 = 10^28 + 10^19`         4-3. `X3 = _optionsAmount * 10^9 = (10^9 + 2) * 10^9 = 10^18 + 2`         4-4. `Y1 = (X2 - X1) * 10^27 // X2 = (10^28 + 10^19 - 10^28) * 10^27 // (10^28 + 10^19) = 99999999000000000`         4-5. `Y2 = Y1 * X3 // 10^27 = 99999999000000000 * (10^18 + 2) / 10^27 = 1000000000`         4-6. `Z = Y2 // 10^9 = 10^9 // 10^9 = 1`  And with this, we managed to generate 10^-18 weth of revenue.  This approach is pretty impractical due to the requirement of minting 10^-18 for `10^9 + 2` times. This montrous count mostly likely requires a lot of gas to pull off, and offsets the marginal revenue generated through our attack. This leads us to explore other possible methods to bypass this limitation.  It's time to start looking at the second bug.  Recall we mentioned the second bug is in `intToUint`, so here's the implementation of it. It is not hard to see that this is actually an `abs` function named as `intToUint`.  ```     function intToUint(int256 a) internal pure returns (uint256) {         if (a < 0) {             return uint256(-a);         } else {             return uint256(a);         }     } ```  Where is this function used? And yes, you guessed it, in `QuantCalculator.calculateClaimableCollateral`. The process of claiming collateral is quite complex, but we will only look at the specific case relevant to the exploit. Before reading code, let's first show the desired scenario. Note that while we wait for expiry, there are no need to sell any option/spread.  1. mint a `qTokenLong` option 2. mint a `qTokenShort` spread with `qTokenLong` as collateral 3. wait until expire, and expect expiryPrice to be between qTokenLong and qTokenShort  ``` ----------- qTokenLong strike price  ----------- expiryPrice  ----------- qTokenShort strike price ```  Here is the outline of the long waited claimCollateral for spread.  * `Controller._claimCollateral`   * `QuantCalculator.calculateClaimableCollateral`     * `FundsCalculator.getSettlementPriceWithDecimals`     * `FundsCalculator.getPayout` for qTokenLong       * qTokenLong strike price is above expiry price, worth 0     * `FundsCalculator.getCollateralRequirement`       * This part we saw earlier, omit details     * `FundsCalculator.getPayout` for qTokenShort       * uses `qTokenToMint.underlyingAsset` (weth or wbtc) as collateral       * `FundsCalculator.getPayoutAmount` for qTokenShort         * scale `_strikePrice` from           `_strikeAssetDecimals (8)` to `_BASE_DECIMALS (27)`         * scale `_expiryPrice.price` from           `_expiryPrice.decimals (8)` to `_BASE_DECIMALS (27)`         * scale `_amount` from           `_optionsDecimals (18)` to `_BASE_DECIMALS (27)`         * `FundsCalculator.getPayoutForCall` for qTokenShort           * `payoutAmount = expiryPrice.sub(strikePrice).mul(amount).div(expiryPrice)`     * `returnableCollateral = payoutFromLong.add(collateralRequirement).sub(payoutFromShort)`     * scale and round down `abs(returnableCollateral)` from `_BASE_DECIMALS (27)` to `payoutDecimals (18)`   Again, we summarize the math part into a function  ``` def claimableCollateralCallCreditSpreadExpiryInbetween(_qTokenShortStrikePrice, _qTokenLongStrikePrice, _expiryPrice, _amount):          def callCreditSpreadCollateralRequirement(_qTokenToMintStrikePrice, _qTokenForCollateralStrikePrice, _optionsAmount):                 X1 = _qTokenToMintStrikePrice * 10^19                 X2 = _qTokenForCollateralStrikePrice * 10^19                 X3 = _optionsAmount * 10^9                  Y1 = (X2 - X1) * 10^27 // X2                 Y2 = Y1 * X3 // 10^27                 return Y2          def callCreditSpreadQTokenShortPayout(_strikePrice, _expiryPrice, _amount):                 X1 = _strikePrice * 10^19                 X2 = _expiryPrice * 10^19                 X3 = _amount * 10^9                  Y1 = (X2-X1) * X3 // 10^27                 Y2 = Y1 * 10^27 // X2                 return Y2           assert _qTokenShortStrikePrice > _expiryPrice > _qTokenLongStrikePrice          A1 = payoutFromLong = 0         A2 = collateralRequirement = callCreditSpreadCollateralRequirement(_qTokenShortStrikePrice, _qTokenLongStrikePrice, _amount)         A3 = payoutFromShort = callCreditSpreadQTokenShortPayout(_qTokenShortStrikePrice, _expiryPrice, _amount)          B1 = A1 + A2 - A3          Z = abs(B1) // 10^9         return Z ```  Given the context, it should be pretty easy to imagine what I am aiming here, to make `B1 < 0`. We already know `A1 = 0`, so the gaol basically boils down to making `A2 < A3`. Let's further simplify this requirement and see if the equation is solvable.  ``` X = _qTokenLongStrikePrice (8 decimals) Y = _expiryPrice (8 decimals) Z = _qTokenShortStrikePrice (8 decimals) A = _amount (scaled to 27 decimals)  assert X>Y>Z>0 assert X,Y,Z are integers assert (((X - Z) * 10^27 // X) * A // 10^27) < (((Y - Z) * A // 10^27) * 10^27 // Y) ```  Notice apart from the use of `X` and `Y`, the two sides of the equation only differs by when `A` is mixed into the equation, meaning that if we temporarily ignore the limitation and set `X = Y`, as long as left hand side of equation does an implicit rounding after dividing by X, right hand side will most likely be larger.  Utilizing this, we turn to solve the equation of  ``` (X-Z) / X - (Y-Z) / Y < 10^-27 => Z / Y - Z / X < 10^-27 => (Z = 1 yields best solution) => 1 / Y - 1 / X < 10^-27 => X - Y < X * Y * 10^-27 => 0 < X * Y - 10^27 * X + 10^27 * Y  => require X > Y, so model Y as X - B, where B > 0 and B is an integer => 0 < X^2 - B * X - 10^27 * B ```  It is not easy to see that the larger `X` is, the larger the range of allowed `B`. This is pretty important since `B` stands for the range of expiry prices where attack could work, so the larger it is, the less accurate our guess can be to profit.  Apart form range of `B`, value of `X` is the long strike price and upper bound of range `B`, so we would also care about it, a simple estimation shows that `X` must be above `10^13.5 (8 decimals)` for there to be a solution, which amounts to about `316228 BUSD <-> 1 WETH`. This is an extremely high price, but not high enough to be concluded as unreachable in the near future. So let's take a slightly generous number of `10^14 - 1` as X and calculate the revenue generated following this exploit path.  ``` 0 < (10^14 - 1)^2 - B * (10^14 - 1) - 10^27 * B => (10^14 - 1)^2 / (10^14 - 1 + 10^27) > B => B <= 9 ```  Now we've got the range of profitable expiry price. As we concluded earlier, the range is extremely small with a modest long strike price, but let's settle with this for now and see how much profit can be generated if we get lucky. To calculate profit, we take `_qTokenLongStrikePrice = 10^14 - 1 (8 decimals)`, `_qTokenShortStrikePrice = 1 (8 decimals)`, `_expiryPrice = 10^14 - 2 (8 decimals)` and `_amount = 10^28 (18 decimals)` and plug it back into the function. 1. in `callCreditSpreadCollateralRequirement`         1-1. `X1 = _qTokenForCollateralStrikePrice * 10^19 = 1 * 10^19 = 10^19`         1-2. `X2 = _qTokenToMintStrikePrice * 10^19 = (10^14 - 1) * 10^19 = 10^33 - 10^19`         1-3. `X3 = _optionsAmount * 10^9 = 10^28 * 10^9 = 10^37`         1-4. `Y1 = (X2 - X1) * 10^27 // X2 = (10^33 - 2 * 10^19) * 10^27 // (10^33 - 10^19) = 999999999999989999999999999`         1-5. `Y2 = Y1 * X3 // 10^27 = 999999999999989999999999999 * 10^37 // 10^27 = 999999999999989999999999999 * 10^10` 2. in `callCreditSpreadQTokenShortPayout`         2-1. `X1 = _strikePrice * 10^19 = 1 * 10^19 = 10^19`         2-2. `X2 = _expiryPrice * 10^19 = (10^14 - 2) * 10^19 = 10^33 - 2 * 10^19`         2-3. `X3 = _amount * 10^9 = 10^28 * 10^9 = 10^37`         2-4. `Y1 = (X2 - X1) * X3 // 10^27 = (10^33 - 3 * 10^19) * 10^37 // 10^27 = 99999999999997 * 10^29`         2-5. `Y2 = Y1 * 10^27 / X2 = (99999999999997 * 10^28) * 10^27 / (10^33 - 2 * 10^19) = 9999999999999899999999999997999999999 3. combine terms         3-1. `B1 = A1 + A2 - A3 = 0 + 9999999999999899999999999990000000000 - 9999999999999899999999999997999999999 = -2000000001         3-2. `Z = abs(B1) // 10^9 = 2000000000 // 10^9 = 2  And with this, we managed to squeeze 2 wei from a presumably worthless collateral.  This attack still suffers from several problems 1. cost of WETH in BUSD is way higher than current market 2. need to predict target price accurately to profit 3. requires large amount of WETH to profit  While it is still pretty hard to pull off attack, the requirements seems pretty more likely to be achievable compared to the first version of exploit. Apart from this, there is also the nice property that this attack allows profit to scale with money invested.  This concludes our demonstration of two attacks against the potential flaws in number handling.  ## Tools Used  vim, ganache-cli  ## Recommended Mitigation Steps  For `div` and `mul`, adding in a similar opt-out round up argument would work. This would require some refactoring of code, but is the only way to fundamentally solve the problem.  For `intToUint`, I still can't understand what the original motive is to design it as `abs` in disguise. Since nowhere in this project would we benefit from the current `abs` behaviour, in my opinion, it would be best to adopt a similar strategy to the `uintToInt` function. If the value goes out of directly convertable range ( < 0), revert and throw an error message.  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-rolla-findings/issues/30", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-03-rolla-findings", "body": "QA Report"}, {"title": "Incorrect strike price displayed in name/symbol of qToken ", "html_url": "https://github.com/code-423n4/2022-03-rolla-findings/issues/28", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2022-03-rolla-findings", "body": "# Lines of code  https://github.com/RollaProject/quant-protocol/blob/main/contracts/options/QTokenStringUtils.sol#L38 https://github.com/RollaProject/quant-protocol/blob/main/contracts/options/QTokenStringUtils.sol#L90 https://github.com/RollaProject/quant-protocol/blob/main/contracts/options/QTokenStringUtils.sol#L136 https://github.com/RollaProject/quant-protocol/blob/main/contracts/options/QTokenStringUtils.sol#L206   # Vulnerability details  ## Impact  `_slice()` in `options/QTokenStringUtils.sol` cut a string into `string[start:end]` However, while fetching bytes, it uses `bytes(_s)[_start+1]` instead of `bytes(_s)[_start+i]`. This causes the return string to be composed of `_s[start]*(_end-_start)`. The result of this function is then used to represent the decimal part of strike price in name/symbol of qToken, leading to potential confusion over the actual value of options.   ## Proof of Concept  ERC20 tokens are usually identified by their name and symbol. If the symbols are incorrect, confusions may occur. Some may argue that even if names and symbols are not accurate, it is still possible to identify correct information/usage of tokens by querying the provided view functions and looking at its interactions with other contracts. However, the truth is many users of those tokens are not very tech savvy, and it is reasonable to believe a large proportion of users are not equipped with enough knowledge, or not willing to dig further than the plain symbols and names. This highlights the importance of maintaining a correct facade for ERC20 tokens.  The bug demonstrated here shows that any qToken with decimals in its strike price will be misdisplayed, and the maximal difference between actual price and displayed one can be up to 0.1 BUSD.  The exploit can be outlined through the following steps:  * Alice created a call option with strike price 10000.90001. The expected symbol should for this qToken should be : `ROLLA WETH 31-December-2022 10000.90001 Call`  * Both `_qTokenName()` and `_qTokenSymbol()` in `options/QTokenStringUtils.sol` use `_displayedStrikePrice()` to get the strike price string which should be `10000.90001`  https://github.com/RollaProject/quant-protocol/blob/main/contracts/options/QTokenStringUtils.sol#L38 https://github.com/RollaProject/quant-protocol/blob/main/contracts/options/QTokenStringUtils.sol#L90  ```     function _qTokenName(         address _quantConfig,         address _underlyingAsset,         address _strikeAsset,         uint256 _strikePrice,         uint256 _expiryTime,         bool _isCall     ) internal view virtual returns (string memory tokenName) {         string memory underlying = _assetSymbol(_quantConfig, _underlyingAsset);         string memory displayStrikePrice = _displayedStrikePrice(             _strikePrice,             _strikeAsset         );            ...            tokenName = string(             abi.encodePacked(                 \"ROLLA\",                 \" \",                 underlying,                 \" \",                 _uintToChars(day),                 \"-\",                 monthFull,                 \"-\",                 Strings.toString(year),                 \" \",                 displayStrikePrice,                 \" \",                 typeFull             )         );     } ```  ```      function _qTokenSymbol(         address _quantConfig,         address _underlyingAsset,         address _strikeAsset,         uint256 _strikePrice,         uint256 _expiryTime,         bool _isCall     ) internal view virtual returns (string memory tokenSymbol) {         string memory underlying = _assetSymbol(_quantConfig, _underlyingAsset);         string memory displayStrikePrice = _displayedStrikePrice(             _strikePrice,             _strikeAsset         );          // convert the expiry to a readable string         (uint256 year, uint256 month, uint256 day) = DateTime.timestampToDate(             _expiryTime         );          // get option type string         (string memory typeSymbol, ) = _getOptionType(_isCall);          // get option month string         (string memory monthSymbol, ) = _getMonth(month);          /// concatenated symbol string         tokenSymbol = string(             abi.encodePacked(                 \"ROLLA\",                 \"-\",                 underlying,                 \"-\",                 _uintToChars(day),                 monthSymbol,                 _uintToChars(year),                 \"-\",                 displayStrikePrice,                 \"-\",                 typeSymbol             )         );     } ```  * `_displayedStrikePrice()` combines the quotient and the remainder to form the strike price string. The remainder use `_slice` to compute. In this case, the quotient is `10000` and the remainder is `90001`  https://github.com/RollaProject/quant-protocol/blob/main/contracts/options/QTokenStringUtils.sol#L136 ``` function _displayedStrikePrice(uint256 _strikePrice, address _strikeAsset)         internal         view         virtual         returns (string memory)     {         uint256 strikePriceDigits = ERC20(_strikeAsset).decimals();         uint256 strikePriceScale = 10**strikePriceDigits;         uint256 remainder = _strikePrice % strikePriceScale;         uint256 quotient = _strikePrice / strikePriceScale;         string memory quotientStr = Strings.toString(quotient);          if (remainder == 0) {             return quotientStr;         }          uint256 trailingZeroes;         while (remainder % 10 == 0) {             remainder /= 10;             trailingZeroes++;         }          // pad the number with \"1 + starting zeroes\"         remainder += 10**(strikePriceDigits - trailingZeroes);          string memory tmp = Strings.toString(remainder);         tmp = _slice(tmp, 1, (1 + strikePriceDigits) - trailingZeroes);          return string(abi.encodePacked(quotientStr, \".\", tmp));     } ```  * However inside the loop of `_slice()`, `slice[i] = bytes(_s)[_start + 1];` lead to an incorrect string, which is `90001`  https://github.com/RollaProject/quant-protocol/blob/main/contracts/options/QTokenStringUtils.sol#L206  ```     function _slice(         string memory _s,         uint256 _start,         uint256 _end     ) internal pure virtual returns (string memory) {         uint256 range = _end - _start;         bytes memory slice = new bytes(range);         for (uint256 i = 0; i < range; ) {             slice[i] = bytes(_s)[_start + 1];             unchecked {                 ++i;             }         }          return string(slice);     } ```  * The final qtoken name now becomes `ROLLA WETH 31-December-2022 10000.99999 Call`, which results in confusion over the actual value of options.  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Fix the bug in the `_slice()`  ```     function _slice(         string memory _s,         uint256 _start,         uint256 _end     ) internal pure virtual returns (string memory) {         uint256 range = _end - _start;         bytes memory slice = new bytes(range);         for (uint256 i = 0; i < range; ) {             slice[i] = bytes(_s)[_start + i];             unchecked {                 ++i;             }         }          return string(slice);     } ```   "}, {"title": "ConfigTimeLockController will put QuantConfig in a stalemate(rendering it unusable) ", "html_url": "https://github.com/code-423n4/2022-03-rolla-findings/issues/27", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-03-rolla-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L28 https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/QuantConfig.sol#L27   # Vulnerability details  The QuantConfig contract has these important setters, setProtocolAddress(), setProtocolUint256, setProtocolBoolean() and setProtocolRole(). This contract is subjected to a timelock before all such processes above are executed. But, the issue arises in the fact that in configTimeLockController, the state variable minimum delay can be set to an arbitrary value, up to type(uint256).max(cannot assume what value will be set) and could potentially render the QuantConfig contract unusable . All the previous values and addresses would not be able to be changed because of a very high delay being set:  https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/timelock/ConfigTimelockController.sol#L28   I discussed with one of the devs about the use of this specific mapping :  https://github.com/code-423n4/2022-03-rolla/blob/efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd/quant-protocol/contracts/QuantConfig.sol#L27  After discussions with one of the devs(#0xca11.eth) , it was understood  that these values are for the rollaOrderFee which is a part of their limit order protocol contract(outside of the scope of the contest) but given the argument above,  its configuration will be severely impacted (old percentage fees won't be able to be changed).Rolla limit order protocol depends on this configuration setting within QuantConfig.  It is recommended that a constant be declared with a MAXIMUM_DELAY and whatever \u2018minimum delay\u2019 that is set thereafter should be below this value since there's another function setDelay () which can also be of high arbitrary value:  require(minimum delay \u2264MAXIMUM_DELAY, \u201c too high\u201d)  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-rolla-findings/issues/26", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-03-rolla-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-rolla-findings/issues/25", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-03-rolla-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-rolla-findings/issues/23", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-rolla-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-rolla-findings/issues/22", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-03-rolla-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-rolla-findings/issues/20", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-03-rolla-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-rolla-findings/issues/18", "labels": ["bug", "QA (Quality Assurance)", "disagree with severity", "sponsor confirmed"], "target": "2022-03-rolla-findings", "body": "QA Report"}, {"title": "Usage of deprecated Chainlink functions", "html_url": "https://github.com/code-423n4/2022-03-rolla-findings/issues/17", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-03-rolla-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/pricing/oracle/ChainlinkOracleManager.sol#L120 https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/pricing/oracle/ChainlinkFixedTimeOracleManager.sol#L81 https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/pricing/oracle/ChainlinkFixedTimeOracleManager.sol#L84   # Vulnerability details  ## Impact The Chainlink functions `latestAnswer()` and `getAnswer()` are deprecated. Instead, use the [`latestRoundData()`](https://docs.chain.link/docs/price-feeds-api-reference/#latestrounddata) and [`getRoundData()`](https://docs.chain.link/docs/price-feeds-api-reference/#getrounddata) functions.  ## Proof of Concept https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/pricing/oracle/ChainlinkOracleManager.sol#L120  https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/pricing/oracle/ChainlinkFixedTimeOracleManager.sol#L81  https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/pricing/oracle/ChainlinkFixedTimeOracleManager.sol#L84  Go to https://etherscan.io/address/0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419#code and search for `latestAnswer()` or `getAnswer()`. You'll find the deprecation notice.  ## Tools Used none  ## Recommended Mitigation Steps Switch to `latestRoundData()` as described [here](https://docs.chain.link/docs/price-feeds-api-reference/#latestrounddata)  "}, {"title": "COLLATERAL_MINTER_ROLE can be granted by the deployer of QuantConfig and mint arbitrary amount of tokens", "html_url": "https://github.com/code-423n4/2022-03-rolla-findings/issues/12", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2022-03-rolla-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/options/CollateralToken.sol#L101-L117   # Vulnerability details  ## Impact ```     function mintCollateralToken(         address recipient,         uint256 collateralTokenId,         uint256 amount     ) external override {         require(             quantConfig.hasRole(                 quantConfig.quantRoles(\"COLLATERAL_MINTER_ROLE\"),                 msg.sender             ),             \"CollateralToken: Only a collateral minter can mint CollateralTokens\"         );          emit CollateralTokenMinted(recipient, collateralTokenId, amount);          _mint(recipient, collateralTokenId, amount, \"\");     } ```  Using the mintCollateralToken() function of CollateralToken, an address with COLLATERAL_MINTER_ROLE can mint an arbitrary amount of tokens.  If the private key of the deployer or an address with the COLLATERAL_MINTER_ROLE is compromised, the attacker will be able to mint an unlimited amount of collateral tokens.  We believe this is unnecessary and poses a serious centralization risk.  ## Proof of Concept https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/options/CollateralToken.sol#L101-L117 https://github.com/code-423n4/2022-03-rolla/blob/main/quant-protocol/contracts/options/CollateralToken.sol#L138-L160 ## Tools Used None  ## Recommended Mitigation Steps Consider removing the COLLATERAL_MINTER_ROLE, make the CollateralToken only mintable by the owner, and make the Controller contract to be the owner and therefore the only minter.  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-rolla-findings/issues/8", "labels": ["bug", "QA (Quality Assurance)", "resolved", "sponsor confirmed"], "target": "2022-03-rolla-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-rolla-findings/issues/6", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-03-rolla-findings", "body": "QA Report"}, {"title": "No use of upgradeable SafeERC20 contract in Controller.sol", "html_url": "https://github.com/code-423n4/2022-03-rolla-findings/issues/5", "labels": ["bug", "2 (Med Risk)", "resolved"], "target": "2022-03-rolla-findings", "body": "No use of upgradeable SafeERC20 contract in Controller.sol"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-03-rolla-findings/issues/1", "labels": ["bug", "QA (Quality Assurance)", "disagree with severity", "sponsor confirmed"], "target": "2022-03-rolla-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/272", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-vetoken-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/271", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-vetoken-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/269", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-vetoken-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/268", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-vetoken-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/264", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-vetoken-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/261", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-vetoken-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/259", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-vetoken-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/254", "labels": ["bug", "QA (Quality Assurance)", "sponsor confirmed"], "target": "2022-05-vetoken-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/251", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-vetoken-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/248", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-vetoken-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/241", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-vetoken-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/240", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-vetoken-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/234", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-vetoken-findings", "body": "QA Report"}, {"title": "Governance can arbitrarily burn VeToken from any address", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/233", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2022-05-vetoken-findings", "body": "Governance can arbitrarily burn VeToken from any address"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/232", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-vetoken-findings", "body": "QA Report"}, {"title": "lockVeAsset() in VeAssetDepositor don't follow the check-effect-interact pattern and it's vulnerable to reentrancy attack", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/231", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-vetoken-findings", "body": "lockVeAsset() in VeAssetDepositor don't follow the check-effect-interact pattern and it's vulnerable to reentrancy attack"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/230", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-vetoken-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/229", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-vetoken-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/228", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-vetoken-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/223", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-vetoken-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/221", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-vetoken-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/219", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-vetoken-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/218", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-vetoken-findings", "body": "QA Report"}, {"title": "Misconfiguration of Fees Incentive Might Cause Tokens To Be Stuck In `Booster` Contract", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/215", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-vetoken-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/Booster.sol#L193 https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/Booster.sol#L576   # Vulnerability details  ## Proof-of-Concept  The `Booster.setFeeInfo` function is responsible for setting the allocation of gauge fees between lockers and $VE3D stakers.  `lockFeesIncentive` and `stakerLockFeesIncentive` should add up to `10000` , which is equivalent to `100%`.  However, there is no validation check to ensure that that `_lockFeesIncentive` and `_stakerLockFeesIncentive` add up to `10000`. Thus, it entirely depends on the developer to get these two values right.  As such, it is possible to set `lockFeesIncentive + takerLockFeesIncentive` to be less than `100%`. This might happen due to human error. For instance, a typo (forget a few zero) or newly joined developer might not be aware of the fee denomination and called `setFeeInfo(40, 60)` instead of `setFeeInfo(4000, 6000)`.  [https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/Booster.sol#L193](https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/Booster.sol#L193)  ```solidity uint256 public constant FEE_DENOMINATOR = 10000;  // Set reward token and claim contract, get from Curve's registry function setFeeInfo(uint256 _lockFeesIncentive, uint256 _stakerLockFeesIncentive) external {     require(msg.sender == feeManager, \"!auth\");      lockFeesIncentive = _lockFeesIncentive;     stakerLockFeesIncentive = _stakerLockFeesIncentive;     ..SNIP.. } ```  Assume that `setFeeInfo(40, 60)` is called instead of of `setFeeInfo(4000, 6000)`, only `1%` of the fee collected will be transferred to the users and the remaining `99%` of the fee collected will be stuck in the `Booster` contract.  [https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/Booster.sol#L576](https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/Booster.sol#L576)  ```solidity function earmarkFees() external returns (bool) {     //claim fee rewards     IStaker(staker).claimFees(feeDistro, feeToken);     //send fee rewards to reward contract     uint256 _balance = IERC20(feeToken).balanceOf(address(this));      uint256 _lockFeesIncentive = _balance.mul(lockFeesIncentive).div(FEE_DENOMINATOR);     uint256 _stakerLockFeesIncentive = _balance.mul(stakerLockFeesIncentive).div(         FEE_DENOMINATOR     );     if (_lockFeesIncentive > 0) {         IERC20(feeToken).safeTransfer(lockFees, _lockFeesIncentive);         IRewards(lockFees).queueNewRewards(_lockFeesIncentive);     }     if (_stakerLockFeesIncentive > 0) {         IERC20(feeToken).safeTransfer(stakerLockRewards, _stakerLockFeesIncentive);         IRewards(stakerLockRewards).queueNewRewards(feeToken, _stakerLockFeesIncentive);     }     return true; } ```  ### Can we retrieve or \"save\" the tokens stuck in `Booster` contract?  Any veAsset (e.g. CRV, ANGLE) sitting on the `Booster` contract is claimable. However, in this case, the `feeToken` is likely not a veAsset, thus the remaining gauge fee will be stuck in the `Booster` contract perpetually. For instance, in Curve, the gauge fee is paid out in 3CRV, the LP token for the TriPool. ([Source](https://resources.curve.fi/crv-token/understanding-crv#staking-trading-fees))  ## Impact  Users will lost their gauge fee if this happens.  ## Recommended Mitigation Steps  Implement validation check to ensure that `lockFeesIncentive` and `takerLockFeesIncentive` add up to 100% to eliminate any risk of misconfiguration.  ```solidity uint256 public constant FEE_DENOMINATOR = 10000;  // Set reward token and claim contract, get from Curve's registry function setFeeInfo(uint256 _lockFeesIncentive, uint256 _stakerLockFeesIncentive) external {     require(msg.sender == feeManager, \"!auth\");     require(_lockFeesIncentive + _stakerLockFeesIncentive == FEE_DENOMINATOR, \"Invalid fees\");      lockFeesIncentive = _lockFeesIncentive;     stakerLockFeesIncentive = _stakerLockFeesIncentive;     ..SNIP.. } ```  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/213", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-vetoken-findings", "body": "QA Report"}, {"title": "Gauge Rewards Stuck In `VoterProxy` Contract When `ExtraRewardStashV3` Is Used Within Angle Deployment", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/209", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2022-05-vetoken-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/Booster.sol#L495   # Vulnerability details  > Note: This report aims to discuss the issue encountered when `ExtraRewardStashV3` is used within Angle Deployment. There is also another issue when `ExtraRewardStashV2` is used within Angle Deployment, but I will raise it in a separate report since `ExtraRewardStashV2` and `ExtraRewardStashV3` operate differently, and the proof-of-concept and mitigation are different too.  ## Proof-of-Concept  In this example, assume the following Angle's gauge setup  > Name = Angle sanDAI_EUR Gauge > > Symbol = SsanDAI_EUR > > reward_count = 2 > > reward_tokens(0) = ANGLE > > reward_tokens(1) = DAI > > Gauge Contract: [LiquidityGaugeV4.vy](https://github.com/AngleProtocol/angle-core/blob/4d854e0d74be703a3707898f26ea2dd4166bc9b6/contracts/staking/LiquidityGaugeV4.vy) > > Stash Contract: [ExtraRewardStashV3](https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/ExtraRewardStashV3.sol)  To collect the gauge rewards, users would trigger the `Booster._earmarkRewards` function to claim veAsset and extra rewards from a gauge.   Per the code logic, the function will attempt to execute the following two key operations:  1) First Operation -  Claim the veAsset by calling `VoterProxy.claimVeAsset`. Call Flow as follow: `VoterProxy.claimVeAsset() > IGauge(_gauge).claim_rewards()`. 2) Second Operation - Claim extra rewards by calling `ExtraRewardStashV3.claimRewards`. Call flow as follows: `ExtraRewardStashV3.claimRewards > Booster.claimRewards > VoterProxy.claimRewards > IGauge(_gauge).claim_rewards()` .   Note that`IGauge(_gauge).claim_rewards()` will claim all available reward tokens from the Angle's gauge.  [https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/Booster.sol#L495](https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/Booster.sol#L495)  ```solidity //claim veAsset and extra rewards and disperse to reward contracts function _earmarkRewards(uint256 _pid) internal {     PoolInfo storage pool = poolInfo[_pid];     require(pool.shutdown == false, \"pool is closed\");      address gauge = pool.gauge;      //claim veAsset     IStaker(staker).claimVeAsset(gauge);      //check if there are extra rewards     address stash = pool.stash;     if (stash != address(0)) {         //claim extra rewards         IStash(stash).claimRewards();         //process extra rewards         IStash(stash).processStash();     }  ..SNIP.. } ```  ### First Operation -  Claim the veAsset  Since this is a Angle Deployment, when the `VoterProxy.claimVeAsset` is triggered,  it will go through the if-else logic (`escrowModle == IVoteEscrow.EscrowModle.ANGLE`) and execute ` IGauge(_gauge).claim_rewards()`, and all rewards tokens will be sent to `VoterProxy` contract. Assume that `100 ANGLE` and `100 DAI` were received.  Note that in this example, we have two reward tokens (ANGLE and DAI). Additionally, gauge redirection was not configured on the gauge at this point, thus the gauge rewards will be sent to the caller, which is the `VoterProxy` contract.  Subsequently, the code `IERC20(veAsset).safeTransfer(operator, _balance);` will be executed, and veAsset (`100 ANGLE`) reward tokens will be transferred to the `Booster` contract for distribution. However, the `100 DAI` reward tokens will remain stuck in the `VoterProxy` contract. As such, users will not be able to get any reward tokens (e.g. DAI, WETH) except veAsset (ANGLE) tokens from the gauges.  [https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/VoterProxy.sol#L224](https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/VoterProxy.sol#L224)  ```solidity function claimVeAsset(address _gauge) external returns (uint256) {     require(msg.sender == operator, \"!auth\");      uint256 _balance = 0;      if (escrowModle == IVoteEscrow.EscrowModle.PICKLE) {         try IGauge(_gauge).getReward() {} catch {             return _balance;         }     } else if (         escrowModle == IVoteEscrow.EscrowModle.CURVE ||         escrowModle == IVoteEscrow.EscrowModle.RIBBON     ) {         try ITokenMinter(minter).mint(_gauge) {} catch {             return _balance;         }     } else if (escrowModle == IVoteEscrow.EscrowModle.IDLE) {         try ITokenMinter(minter).distribute(_gauge) {} catch {             return _balance;         }     } else if (escrowModle == IVoteEscrow.EscrowModle.ANGLE) {         try IGauge(_gauge).claim_rewards() {} catch {             return _balance;         }     }      _balance = IERC20(veAsset).balanceOf(address(this));     IERC20(veAsset).safeTransfer(operator, _balance);      return _balance; } ```  Following is Angle's Gauge Contract for reference:  [https://github.com/AngleProtocol/angle-core/blob/4d854e0d74be703a3707898f26ea2dd4166bc9b6/contracts/staking/LiquidityGaugeV4.vy#L344](https://github.com/AngleProtocol/angle-core/blob/4d854e0d74be703a3707898f26ea2dd4166bc9b6/contracts/staking/LiquidityGaugeV4.vy#L344)  (Mainnet Deployed Address: https://etherscan.io/address/0x8E2c0CbDa6bA7B65dbcA333798A3949B07638026)   > Note: Angle Protocol is observed to use LiquidityGaugeV4 contract for all of their gauges. Thus, ExtraRewardStashV3 is utilised during pool creation.  ```python @external @nonreentrant('lock') def claim_rewards(_addr: address = msg.sender, _receiver: address = ZERO_ADDRESS):     \"\"\"     @notice Claim available reward tokens for `_addr`     @param _addr Address to claim for     @param _receiver Address to transfer rewards to - if set to                      ZERO_ADDRESS, uses the default reward receiver                      for the caller     \"\"\"     if _receiver != ZERO_ADDRESS:         assert _addr == msg.sender  # dev: cannot redirect when claiming for another user     self._checkpoint_rewards(_addr, self.totalSupply, True, _receiver) ```  ### Second Operation - Claim extra rewards  After the `IStaker(staker).claimVeAsset(gauge);` code within the `Booster._earmarkRewards` function is executed, `IStash(stash).claimRewards();`  and `IStash(stash).processStash();` functions will be executed next. `stash` == `ExtraRewardStashV3`.  The `ExtraRewardStashV3.claimRewards` will call the `Booster.setGaugeRedirect` first so that all the gauge rewards will be redirected to `ExtraRewardStashV3` stash contract. Subsequently, `ExtraRewardStashV3.claimRewards` will trigger `Booster.claimRewards` to claim the gauge rewards from the Angle's gauge.   Note that this is the second time the contract attempts to claim gauge rewards from the gauge. Thus, no gauge rewards will be received since we already claimed them earlier. Next, `ExtraRewardStashV3` will attempt to process all the tokens stored in its contract and send them to the respective reward contracts for distribution to the users. However, the contract does not have any tokens stored in it because the earlier attempt to claim gauge rewards return nothing.  As we can see, the DAI reward tokens are still stuck in the `VoterProxy` contract at this point.  [https://github.com/AngleProtocol/angle-core/blob/4d854e0d74be703a3707898f26ea2dd4166bc9b6/contracts/staking/LiquidityGaugeV4.vy#L332](https://github.com/AngleProtocol/angle-core/blob/4d854e0d74be703a3707898f26ea2dd4166bc9b6/contracts/staking/LiquidityGaugeV4.vy#L332)  ```python def set_rewards_receiver(_receiver: address):     \"\"\"     @notice Set the default reward receiver for the caller.     @dev When set to ZERO_ADDRESS, rewards are sent to the caller     @param _receiver Receiver address for any rewards claimed via `claim_rewards`     \"\"\"     self.rewards_receiver[msg.sender] = _receiver ```  [https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/ExtraRewardStashV3.sol#L61](https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/ExtraRewardStashV3.sol#L61)  ```solidity //try claiming if there are reward tokens registered function claimRewards() external returns (bool) {     require(msg.sender == operator, \"!authorized\");      //this is updateable from v2 gauges now so must check each time.     checkForNewRewardTokens();      //make sure we're redirected     if (!hasRedirected) {         IDeposit(operator).setGaugeRedirect(pid);         hasRedirected = true;     }      uint256 length = tokenCount;     if (length > 0) {         //claim rewards on gauge for staker         //using reward_receiver so all rewards will be moved to this stash         IDeposit(operator).claimRewards(pid, gauge);     }     return true; } ```  ## Impact  User's gauge rewards are frozen/stuck in `VoterProxy` contract. Additionally, there is no method to sweep/collect the reward tokens stuck in the `VoterProxy` contract.  ## Recommended Mitigation Steps  > Note: I do not see `Booster.setGaugeRedirect` being called in the deployment and testing scripts. Thus, it is fair to assume that the team is not aware of the need to trigger `Booster.setGaugeRedirect` during deployment. If the gauge redirection has been set to the stash contract `ExtraRewardStashV3` right from the start before anyone triggered the `earmarkRewards` function, this issue should not occur.  Consider triggering `Booster.setGaugeRedirect` during the deployment to set gauge redirection to stash contract (`ExtraRewardStashV3`) so that the Angle's gauge rewards will not be redirected to `VoterProxy` contract and get stuck there.  Alternatively, update the `Booster._earmarkRewards` to as follows:  ```solidity //claim veAsset and extra rewards and disperse to reward contracts function _earmarkRewards(uint256 _pid) internal {  PoolInfo storage pool = poolInfo[_pid];  require(pool.shutdown == false, \"pool is closed\");   address stash = pool.stash;  if (escrowModle == IVoteEscrow.EscrowModle.ANGLE) {   //claims gauges rewards   IStash(stash).claimRewards();   //process gauges rewards   IStash(stash).processStash();  } else {   //claim veAsset         IStaker(staker).claimVeAsset(gauge);          //check if there are extra rewards         address stash = pool.stash;         if (stash != address(0)) {             //claim extra rewards             IStash(stash).claimRewards();             //process extra rewards             IStash(stash).processStash();         }  }   //veAsset balance     uint256 veAssetBal = IERC20(veAsset).balanceOf(address(this));  ..SNIP.. } ```  There is no need to specifically call `VoterProxy.claimVeAsset` to fetch ANGLE for Angle Protocol because calling `IStash(stash).claimRewards()` will fetch both ANGLE and other reward tokens from the gauge anyway. When the stash contract receives the ANGLE tokens, it will automatically transfer all of them back to `Booster` contract when `IStash(stash).processStash()` is executed. The `IStash(stash).claimRewards()` function also performs a sanity check to ensure that the gauge redirection is pointing to itself before claiming the gauge rewards, and automatically configure them if it is not, so it will not cause the reward tokens to get stuck in `VoterProxy` contract.  - Curve uses an older version of LiquidityGauge contract. Thus, two calls are needed (`Minter.mint` to claim CRV and `LiquidityGauge.claim_rewards` to claim other rewards).   - Angle uses newer version of LiquidityGauge (V4) contract that just need one function call (`LiquidityGauge.claim_rewards` ) to fetch both veAsset and other rewards. - IDLE uses LiquidityGauge (V3) contract. veAsset (IDLE) is minted by calling `DistributorProxy.distribute` and gauge rewards are claimed by calling `LiquidityGauge.claim_rewards`.  Due to the discrepancies between different protocols in the reward claiming process, additional care must be taken to ensure that the flow of veAsset and gauge rewards are transferred to the appropriate contracts during integration. Otherwise, rewards will be stuck.  Lastly, I only see test cases written for claiming veAsset from the gauge. For completeness, it is recommended to also write test cases for claiming extra rewards from the gauge apart from veAsset.  "}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/208", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-vetoken-findings", "body": "Gas Optimizations"}, {"title": "uint256 unlockInWeeks = (unlockAt / WEEK) * WEEK; is in seconds instead of weeks", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/207", "labels": ["bug", "duplicate", "QA (Quality Assurance)"], "target": "2022-05-vetoken-findings", "body": "uint256 unlockInWeeks = (unlockAt / WEEK) * WEEK; is in seconds instead of weeks"}, {"title": "Unable To Get Rewards If Admin Withdraws $VE3D tokens From `VeTokenMinter` Contract", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/202", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-vetoken-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/VeTokenMinter.sol#L48   # Vulnerability details  ## Vulernability Details  It was observed that users will not be able to get their rewards from the reward contract at certain point of time if admin withdraws $VE3D token from the `VeTokenMinter` contract.  ## Proof-of-Concept  Based on the deployment script, it was understood that at the start of the project deployment, 30 million $VE3D tokens will be pre-minted for the `VeTokenMinter` contract. Thus, the `veToken.balanceOf(VeTokenMinter.address)` will be 30 million $VE3D tokens after the deployment.  [https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/migrations/2_deploy_basic_contracts.js#L18](https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/migrations/2_deploy_basic_contracts.js#L18)  ```javascript // vetoken minter await deployer.deploy(VeTokenMinter, veTokenAddress); let vetokenMinter = await VeTokenMinter.deployed(); addContract(\"system\", \"vetokenMinter\", vetokenMinter.address); global.created = true; //mint vetoke to minter contract const vetoken = await VeToken.at(veTokenAddress); await vetoken.mint(vetokenMinter.address, web3.utils.toWei(\"30000000\"), { from: vetokenOperator }); addContract(\"system\", \"vetoken\", veTokenAddress); ```  In the `VeTokenMinter ` contract, there is a function called `VeTokenMinter.withdraw` that allows the admin to withdraw $VE3D tokens from the contract. Noted that this withdraw function only perform the transfer, but did not update any of the state variables (e.g. totalSupply, maxSupply) in the contract.  [https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/VeTokenMinter.sol#L77](https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/VeTokenMinter.sol#L77)  ```solidity function withdraw(address _destination, uint256 _amount) external onlyOwner {     veToken.safeTransfer(_destination, _amount);      emit Withdraw(_destination, _amount); } ```  Assuming that an admin withdrawed 29 million $VE3D tokens from the `VoteProxy` with the appropriate approval from the DAO or community for some valid purposes. The `veToken.balanceOf(VeTokenMinter.address)` will be 1 million $VE3D tokens after the withdrawal.  At this point, notice that `veToken.balanceOf(VeTokenMinter.address)` is 1 million, while the `VeTokenMinter.maxSupply` constant is 30 million. Therefore, there exists a discrepency between the actual amount of $VE3D tokens (1 million) stored in the contact versus the max supply (30 million).  This discrepency will cause an issue in the `VeTokenMinter.mint` function because the calculation of the amount of $VE3D tokens to be transferred is based on the fact that 30 million $VE3D tokens is always sitting in the `VeTokenMinter` contract, and thus there is always sufficient $VE3D tokens available in the `VeTokenMinter` contract to send to its users.  The `uint256 amtTillMax = maxSupply.sub(supply);` code shows that the calculation is based on `maxSupply` constant, which is 30 million.  Assume that `mint(0x001, 10 million)` is called, and the value of the state variables when stepping through this function are as follows:  - `maxSupply` constant = 30 million - `veToken.balanceOf(VeTokenMinter.address)` = 1 million - `supply` & `totalSupply` = 20 million - `totalCliffs` = 1000 - `reductionPerCliff ` = 30,000 (maxSupply / totalCliffs) - `cliff` = 666 (supply/reductionPerCliff) - `reduction` = 1000 - 666 = 334 - `_amount` = 10 million * (334/1000) = 3.340 million - `amtTillMax` = 10 million (maxSupply - supply) (Over here the contract assume that it still has 10 million VE3D tokens more to reach the max supply) - `(_amount > amtTillMax)` = `False` (since \"3.340 million > 10 million\" = false ) - `veToken.safeTransfer(0x001, 3.340 million)` (This will revert. Insufficent balance)  The `veToken.safeTransfer(0x001, 3.340 million` will fail and revert because `VeTokenMinter` contract does not hold sufficent amount of $VE3D tokens to transfer out.`veToken.balanceOf(VeTokenMinter.address)` = 1 million, while the contract was attempting to send out 3.340 million.  [https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/VeTokenMinter.sol#L48](https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/VeTokenMinter.sol#L48)  ```solidity function mint(address _to, uint256 _amount) external {     require(operators.contains(_msgSender()), \"not an operator\");      uint256 supply = totalSupply;      //use current supply to gauge cliff     //this will cause a bit of overflow into the next cliff range     //but should be within reasonable levels.     //requires a max supply check though     uint256 cliff = supply.div(reductionPerCliff);     //mint if below total cliffs     if (cliff < totalCliffs) {         //for reduction% take inverse of current cliff         uint256 reduction = totalCliffs.sub(cliff);         //reduce         _amount = _amount.mul(reduction).div(totalCliffs);          //supply cap check         uint256 amtTillMax = maxSupply.sub(supply);         if (_amount > amtTillMax) {             _amount = amtTillMax;         }          //mint         veToken.safeTransfer(_to, _amount);         totalSupply += _amount;     } } ```  The failure/revert of `VeTokenMinter.mint` function will cascade up to `Booster.rewardClaimed`, and futher cascade up to `BaseRewardPool.getReward`. Thus, `BaseRewardPool.getReward` will stop working. As a result, the users will not be able to get any rewards from the reward contracts.   This issue will affect all projects (Curve, Pickle, Ribbon, Idle, Angle, Balancer) because `VeTokenMinter ` contract is deployed once, and referenced by all the projects. Thus, the impact could be quite widespread if this occurs, and many users would be affected.  [https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/Booster.sol#L598](https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/Booster.sol#L598)  ```solidity function rewardClaimed(     uint256 _pid,     address _address,     uint256 _amount ) external returns (bool) {     address rewardContract = poolInfo[_pid].veAssetRewards;     require(msg.sender == rewardContract || msg.sender == lockRewards, \"!auth\");     ITokenMinter veTokenMinter = ITokenMinter(minter);     //calc the amount of veAssetEarned     uint256 _veAssetEarned = _amount.mul(veTokenMinter.veAssetWeights(address(this))).div(         veTokenMinter.totalWeight()     );     //mint reward tokens     ITokenMinter(minter).mint(_address, _veAssetEarned);      return true; } ```  [https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/BaseRewardPool.sol#L267](https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/BaseRewardPool.sol#L267)  ```solidity function getReward(address _account, bool _claimExtras)     public     updateReward(_account)     returns (bool) {     uint256 reward = earned(_account);     if (reward > 0) {         rewards[_account] = 0;         rewardToken.safeTransfer(_account, reward);         IDeposit(operator).rewardClaimed(pid, _account, reward);         emit RewardPaid(_account, reward);     }      //also get rewards from linked rewards     if (_claimExtras) {         for (uint256 i = 0; i < extraRewards.length; i++) {             IRewards(extraRewards[i]).getReward(_account);         }     }     return true; } ```  ## Recommended Mitigation Steps  Remove the `VeTokenMinter.withdraw` function if possible. Otherwise, update the internal accounting of `VeTokenMinter` contract during withdrawal so that the actual balance of the $VE3D tokens is taken into consideration within the `VeTokenMinter.mint`, and the contract will not attempt to transfer more tokens than what it has.  On a side note, [Convex's Minter contract](https://github.com/convex-eth/platform/blob/main/contracts/contracts/Cvx.sol), will mint the `CRX` gov tokens to the users on the fly. See https://github.com/convex-eth/platform/blob/1f11027d429e454dacc4c959502687eaeffdb74a/contracts/contracts/Cvx.sol#L76. Thus, there will not be a case where there is not sufficient `CRV` tokens in the contract to send to it users.  However, in VeToken Protocol, it attempts to transfer the portion of pre-minted $VE3D tokens (30 millions) to the users. See https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/VeTokenMinter.sol#L72. Thus, it is possible that there is not enough $VE3D tokens to send to its users if the admin withdraw the pre-minted $VE3D tokens.  "}, {"title": "BaseRewardPool's `rewardPerTokenStored` can be inflated and rewards can be stolen", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/201", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor acknowledged"], "target": "2022-05-vetoken-findings", "body": "BaseRewardPool's `rewardPerTokenStored` can be inflated and rewards can be stolen"}, {"title": "Serious Violation in Checks-Effects-Interactions pattern ", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/199", "labels": ["bug", "QA (Quality Assurance)", "sponsor acknowledged"], "target": "2022-05-vetoken-findings", "body": "Serious Violation in Checks-Effects-Interactions pattern "}, {"title": "Functions will be frozen if setXXX to `address(0)`", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/193", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-vetoken-findings", "body": "Functions will be frozen if setXXX to `address(0)`"}, {"title": "Missing sane bounds on asset weights", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/192", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed"], "target": "2022-05-vetoken-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/VeTokenMinter.sol#L41-L46   # Vulnerability details  ## Impact The admin may fat-finger a change, or be malicious, and have the weights be extreme - ranging from zero to `type(uint256).max`, which would cause the booster to pay out unexpected amounts  ## Proof of Concept No bounds checks in the update function: ```solidity File: contracts/VeTokenMinter.sol   #1  41       function updateveAssetWeight(address veAssetOperator, uint256 newWeight) external onlyOwner { 42           require(operators.contains(veAssetOperator), \"not an veAsset operator\"); 43           totalWeight -= veAssetWeights[veAssetOperator]; 44           veAssetWeights[veAssetOperator] = newWeight; 45           totalWeight += newWeight; 46       } ``` https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/VeTokenMinter.sol#L41-L46  The value is used by the reward contract to determine how much to mint: ```solidity File: contracts/Booster.sol   #2  598       function rewardClaimed( 599           uint256 _pid, 600           address _address, 601           uint256 _amount 602       ) external returns (bool) { 603           address rewardContract = poolInfo[_pid].veAssetRewards; 604           require(msg.sender == rewardContract || msg.sender == lockRewards, \"!auth\"); 605           ITokenMinter veTokenMinter = ITokenMinter(minter); 606           //calc the amount of veAssetEarned 607           uint256 _veAssetEarned = _amount.mul(veTokenMinter.veAssetWeights(address(this))).div( 608               veTokenMinter.totalWeight() 609           ); 610           //mint reward tokens 611           ITokenMinter(minter).mint(_address, _veAssetEarned); ``` https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/Booster.sol#L598-L611  Wrong values will lead to excessive inflation/deflation  ## Tools Used Code inspection  ## Recommended Mitigation Steps Have sane upper/lower limits on the values   "}, {"title": "Consistently check account balance before and after transfers for Fee-On-Transfer discrepancies", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/190", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-vetoken-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/Booster.sol#L356 https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/VE3DRewardPool.sol#L337   # Vulnerability details  As arbitrary ERC20 tokens can be passed, the amount here should be calculated every time to take into consideration a possible fee-on-transfer or deflation. Also, it's a good practice for the future of the solution.  Affected code:  - File: Booster.sol  ```solidity 345:     function deposit( 346:         uint256 _pid, 347:         uint256 _amount, 348:         bool _stake 349:     ) public returns (bool) { ... 356:         IERC20(lptoken).safeTransferFrom(msg.sender, staker, _amount); //@audit medium: not compatible with Fee On Transfer Tokens ... 372:             ITokenMinter(token).mint(address(this), _amount); ... 374:             IERC20(token).safeApprove(rewardContract, _amount); 375:             IRewards(rewardContract).stakeFor(msg.sender, _amount); ... 378:             ITokenMinter(token).mint(msg.sender, _amount); ... 381:         emit Deposited(msg.sender, _pid, _amount); ... ```  - File: VE3DRewardPool.sol  ```solidity 336:     function donate(address _rewardToken, uint256 _amount) external { 337:         IERC20(_rewardToken).safeTransferFrom(msg.sender, address(this), _amount); //@audit medium: not compatible with Fee On Transfer Tokens 338:         rewardTokenInfo[_rewardToken].queuedRewards += _amount; 339:     } ```  ## Recommended Mitigation Steps  Use the balance before and after the transfer to calculate the received amount instead of assuming that it would be equal to the amount passed as a parameter.  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/186", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-vetoken-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/184", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-vetoken-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/183", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-vetoken-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/182", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-vetoken-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/181", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-vetoken-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/180", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-vetoken-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/178", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-vetoken-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/177", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-vetoken-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/175", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-vetoken-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/174", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-vetoken-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/173", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-vetoken-findings", "body": "Gas Optimizations"}, {"title": "deposited staking tokens can be lost if rewards token info added by mistake in addReward() in VE3DRewardPool and there is no checking to ensure this would not happen (ve3Token for one reward was equal to stacking token)", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/172", "labels": ["bug", "2 (Med Risk)", "disagree with severity"], "target": "2022-05-vetoken-findings", "body": "deposited staking tokens can be lost if rewards token info added by mistake in addReward() in VE3DRewardPool and there is no checking to ensure this would not happen (ve3Token for one reward was equal to stacking token)"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/171", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-vetoken-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/169", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-vetoken-findings", "body": "Gas Optimizations"}, {"title": "Unused rewards(because of totalSupply()==0 for some period) will be locked forever in VE3DRewardPool and BaseRewardPool", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/168", "labels": ["bug", "2 (Med Risk)", "disagree with severity"], "target": "2022-05-vetoken-findings", "body": "Unused rewards(because of totalSupply()==0 for some period) will be locked forever in VE3DRewardPool and BaseRewardPool"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/167", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-vetoken-findings", "body": "Gas Optimizations"}, {"title": "`VE3DRewardPool` claim in loop depend on pausable token", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/166", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-vetoken-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/VE3DRewardPool.sol#L296-L299 https://github.com/code-423n4/2022-05-vetoken/blob/1be2f03670e407908f175c08cf8cc0ce96c55baf/contracts/VeAssetDepositor.sol#L134-L152   # Vulnerability details  Project veToken is supposed to be a generalized version of Convex for non-Curve token. There is only one contract for all rewards token in the platform.  All ve3Token rewards are bundled together inside `ve3DLocker` and `ve3DRewardPool` in a loop. Instead of having its own unique contract like `VeAssetDepositer` or `VoterProxy` for each token.  ## Impact  If one token has pausable transfer, user cannot claim rewards or withdraw if they have multiple rewards include that pause token.  Right now the project intends to support only 6 tokens, including Ribbon token which has [pausable transfer](https://etherscan.io/address/0x6123b0049f904d730db3c36a31167d9d4121fa6b#code#L810) controlled by Ribbon DAO.  Normally, this would not be an issue in Convex where only a few pools would be affected by single coin. Since, veAsset are bundled together into single reward pool, it becomes a major problem.  ## Proof of concept  - Token like Ribbon pause token transfer by DAO due to an unfortunate event. - `VE3DRewardPool` try call `getReward()`, `VeAssetDepositor` [try deposit token from earned rewards](https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/VE3DRewardPool.sol#L296-L299) does not work anymore because `IERC20.transfer` [is blocked](https://github.com/code-423n4/2022-05-vetoken/blob/1be2f03670e407908f175c08cf8cc0ce96c55baf/contracts/VeAssetDepositor.sol#L134-L152). This effectively reverts current function if user have this token reward > 0.  ## Recommended mitigation step  It would be a better practice if we had a second `getReward()` function that accepts an array of token that we would like to interact with. It saves gas and only requires some extra work on frontend website. Instead of current implementation, withdraw all token bundles together.   "}, {"title": "in notifyRewardAmount() of VE3DRewardPool and BaseRewardPool some tokes will be locked and not distributed becasue of rounding error", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/165", "labels": ["bug", "2 (Med Risk)", "disagree with severity"], "target": "2022-05-vetoken-findings", "body": "in notifyRewardAmount() of VE3DRewardPool and BaseRewardPool some tokes will be locked and not distributed becasue of rounding error"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/163", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-vetoken-findings", "body": "Gas Optimizations"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/162", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-vetoken-findings", "body": "QA Report"}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/159", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-vetoken-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/158", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-vetoken-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/153", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-vetoken-findings", "body": "Gas Optimizations"}, {"title": "`VE3DLocker.sol` Wrong implementation of inversely traverse for loops always reverts", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/150", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2022-05-vetoken-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/VE3DLocker.sol#L305-L329 https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/VE3DLocker.sol#L349-L373 https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/VE3DLocker.sol#L376-L396 https://github.com/code-423n4/2022-05-vetoken/blob/2d7cd1f6780a9bcc8387dea8fecfbd758462c152/contracts/VE3DLocker.sol#L399-L415   # Vulnerability details  ```solidity function totalSupplyAtEpoch(uint256 _epoch) external view returns (uint256 supply) {     uint256 epochStart = uint256(epochs[_epoch].date).div(rewardsDuration).mul(         rewardsDuration     );     uint256 cutoffEpoch = epochStart.sub(lockDuration);      //traverse inversely to make more current queries more gas efficient     for (uint256 i = _epoch; i + 1 != 0; i--) {         Epoch storage e = epochs[i];         if (uint256(e.date) <= cutoffEpoch) {             break;         }         supply = supply.add(epochs[i].supply);     }      return supply; } ````  In `VE3DLocker.sol`, there are multiple instances in which an inversely traverse for loop is used \"to make more current queries more gas efficient\".  For example:  - `totalSupplyAtEpoch()` - `balanceAtEpochOf()` - `pendingLockAtEpochOf()` - `totalSupply()`  The implementation of the inversely traverse for loop is inherited from Convex's original version: https://github.com/convex-eth/platform/blob/main/contracts/contracts/CvxLockerV2.sol#L333-L334  However, Convex's locker contract is using Solidity 0.6.12, in which the arithmetic operations will overflow/underflow without revert.  As the solidity version used in the current implementation of `VE3DLocker.sol` is `0.8.7`, and there are some breaking changes in Solidity v0.8.0, including:  > Arithmetic operations revert on underflow and overflow.   Ref: https://docs.soliditylang.org/en/v0.8.7/080-breaking-changes.html#silent-changes-of-the-semantics  Which makes the current implementation of inversely traverse for loops always reverts.  More specifically:  1. `for (uint i = locks.length - 1; i + 1 != 0; i--) {` will revert when `locks.length == 0` at `locks.length - 1` due to underflow; 2. `for (uint256 i = _epoch; i + 1 != 0; i--) {` will loop until `i == 0` and reverts at `i--` due to underflow.  As a result, all these functions will be malfunctioning and all the internal and external usage of these function will always revert.  ### Recommendation  Change `VE3DLocker.sol#L315` to:  ```solidity for (uint256 i = locks.length; i > 0; i--) {     uint256 lockEpoch = uint256(locks[i - 1].unlockTime).sub(lockDuration);     //lock epoch must be less or equal to the epoch we're basing from.     if (lockEpoch <= epochTime) {         if (lockEpoch > cutoffEpoch) {             amount = amount.add(locks[i - 1].amount); ```  Change `VE3DLocker.sol#L360` to:  ```solidity for (uint256 i = locks.length; i > 0; i--) {     uint256 lockEpoch = uint256(locks[i - 1].unlockTime).sub(lockDuration);      //return the next epoch balance     if (lockEpoch == nextEpoch) {         return locks[i - 1].amount;     } else if (lockEpoch < nextEpoch) {         //no need to check anymore         break;     } ```  Change `VE3DLocker.sol#L387` to:  ```solidity for (uint256 i = epochindex; i > 0; i--) {     Epoch storage e = epochs[i - 1]; ```  Change `VE3DLocker.sol#L406` to:  ```solidity for (uint256 i = _epoch + 1; i > 0; i--) {     Epoch storage e = epochs[i - 1];     if (uint256(e.date) <= cutoffEpoch) {         break;     }     supply = supply.add(e.supply); } ```  "}, {"title": "QA Report", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/148", "labels": ["bug", "QA (Quality Assurance)"], "target": "2022-05-vetoken-findings", "body": "QA Report"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/147", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-vetoken-findings", "body": "Gas Optimizations"}, {"title": "Gas Optimizations", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/146", "labels": ["bug", "G (Gas Optimization)"], "target": "2022-05-vetoken-findings", "body": "Gas Optimizations"}, {"title": "Incorrectly set ```_maxTime``` to be in line with the locking ```maxTime``` of each veToken could render the ```deposit``` of this contract to be unfunctional or even freeze assets inside the contract ", "html_url": "https://github.com/code-423n4/2022-05-vetoken-findings/issues/141", "labels": ["bug", "2 (Med Risk)", "disagree with severity"], "target": "2022-05-vetoken-findings", "body": "Incorrectly set ```_maxTime``` to be in line with the locking ```maxTime``` of each veToken could render the ```deposit``` of this contract to be unfunctional or even freeze assets inside the contract "}]