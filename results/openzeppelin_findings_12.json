[{"title": "Medium severity", "body": "Medium severity", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#medium-severity", "labels": ["OpenZeppelin"]}, {"title": "No allowance front-running mitigation", "body": "No allowance front-running mitigation", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#no-allowance-front-running-mitigation", "labels": ["OpenZeppelin"]}, {"title": "The ArroToken contract is vulnerable to the ERC20 approve and double spend front-running attack. In this attack, a token owner authorizes another account to transfer a specific amount of tokens on their behalf, and in the case that the token owner decides to change that allowance amount, the spender could spend both allowances by front running the allowance-changing transaction.", "body": "The ArroToken contract is vulnerable to the ERC20 approve and double spend front-running attack. In this attack, a token owner authorizes another account to transfer a specific amount of tokens on their behalf, and in the case that the token owner decides to change that allowance amount, the spender could spend both allowances by front running the allowance-changing transaction.", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#the-arrotoken-contract-is-vulnerable-to-the-erc20-approve-and-double-spend-front-running-attack.-in-this-attack,-a-token-owner-authorizes-another-account-to-transfer-a-specific-amount-of-tokens-on-their-behalf,-and-in-the-case-that-the-token-owner-decides-to-change-that-allowance-amount,-the-spender-could-spend-both-allowances-by-front-running-the-allowance-changing-transaction.", "labels": ["OpenZeppelin"]}, {"title": "Consider using the OpenZeppelin\u2019s ERC20 implementation, and the decreaseAllowance and increaseAllowance functions to help mitigate this.", "body": "Consider using the OpenZeppelin\u2019s ERC20 implementation, and the decreaseAllowance and increaseAllowance functions to help mitigate this.", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#consider-using-the-openzeppelin\u2019s-erc20-implementation,-and-the-decreaseallowance-and-increaseallowance-functions-to-help-mitigate-this.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in pull request #1.", "body": "Missing docstrings  All the contracts and functions in Arros code base lack proper documentation. This hinders reviewers understanding of the codes intention, which is fundamental to correctly assess not only security, but also correctness. Additionally, docstrings improve readability and ease maintenance. They should explicitly explain the purpose or intention of the functions, the scenarios under which they can fail, the roles allowed to call them, the values returned and the events emitted.  Consider thoroughly documenting all functions (and their parameters) that are part of the contracts public API. Functions implementing sensitive functionality, even if not public, should be clearly documented as well. When writing docstrings, consider following the Ethereum Natural Specification Format (NatSpec).  Update: Partially fixed in pull request #1. Arros statement for this issue:  The project structure has been changed to rely heavily on the OpenZeppelin ERC20 implementation. This provides a well-documented base of most of the contract functionality. The rest of the structure of the documentation has been changed to follow a consistent structure but will be updated in the future to follow the Ethereum Natural Specification Format (NatSpec).  Low severity  Lack of event emission OwnershipTransferred on contract construction  The OwnershipTransferred event is not being emitted when the ArroToken contract is initialized.  This means that there will be no record of who was the initial owner of the token in the OwnershipTransferred event logs.  Consider using OpenZeppelins Ownable contract which already covers this, or consider emitting an OwnershipTransferred after asigning the owner in the Owneds constructor.    Lack of event emission after modifying newOwner variable  In line 90 and in line 96, the storage variable newOwner is being modifed, but no events are being triggered.  This means that there will be no record of the changes of the newOwner variable, and traceability of the potential new owners of the TokenArro will be lost.  Consider to define an event for tracking the newOwner variable value, and emit an event each time it is modified.    owner and newOwner storage variables can be modified without events emission  owner and  newOwner storage variables in the  Consider using OpenZeppelins Ownable contract which already covers this, or consider declaring owner and newOwner variables as private, and add getter functions for accessing them.    Duplicate code in transfer and transferFrom functions  The transfer and transferFrom functions share very similar code. Duplicate code is more difficult to maintain, as it is longer and needs to be updated in different sections of the codebase.  Consider moving the duplicated code into another function and call it from the transfer and transferFrom functions.    Wrong usage of inheritance with Safemath contract  A SafeMath contract is implemented in order to manage arithmetic overflows and underflows.  In this contract, all its functions are defined as public, which means that the ArroToken contract will expose them as part of its API, as it inherits from SafeMath. This extends the functionality that should be exposed by an ERC20 token. Additionally, the gas costs of the deploy will be higher as opposed to using SafeMath as a library.  Given that the functionality of the SafeMath contract can be exposed as a library, consider using OpenZeppelins SafeMath    The TokenArro contract can be transferred to the zero address  The transferOwnership function in the Owned contract does not prevent to transfer the ownership of the contract to the zero address.  Consider using OpenZeppelins Ownable contract which already covers this, or consider restricting the new owner to non-zero addresses.    Tokens can be transferred to the zero address  The transfer and the transferFrom functions in the ArroToken contract do not prevent to transfer tokens to the zero address.  Consider using the OpenZeppelins ERC20 implementation which already covers this, or consider restricting the to parameter to non-zero addresses.    The totalSupply function does not return the real total supply  The totalSupply function returns the difference between the tokens total supply defined in the constructor and the tokens owned by the zero address, which is not strictly the total supply amount.  This could lead to a misinterpretation of the real total supply of the token when querying it.  Consider modifying the the totalSupply function implementation so it returns the real total supply value, and consider using the OpenZeppelins ERC20 implementation that implements the _burn and _burnFrom functions to keep the total supply variable up-to-date.    Notes & Additional information  [introduced with the first round of fixes] Unnecessary inheritance and imports.  ArroToken contract inherits from the  OwnableUpgradeSafe contract inherits from the  Consider simplifying the code by removing the redundant inheritance declarations.  [introduced with the first round of fixes] initialize function missing the initializer modifier  initialize function of the  ArroToken contract is not using the  initializer modifier. Currently this is not an issue because the functions called by  initializer modifier to make the intention clearer and safer in case the code is modified.  Consider adding the initializer modifier in the definition of the initialize function.  [introduced with the first round of fixes] Unnecessary calls to initializers  initialize function of the  ArroToken contract calls  __Context_init_unchained(),  __Pausable_init_unchained(), and  __ERC20Pausable_init_unchained(). The  __ERC20Pausable_init() calls the same three initializers, so they can be replaced by this single call.  Consider calling __ERC20Pausable_init() to simplify the code.  Not following a consistent coding style  The code base deviates from the Solidity Style Guide. A consistent coding style helps with the readability of the project. Consider enforcing a standard coding style with help of linter tools such as Solhint.    Multiple variables declared as uint  There are several variable declarations of uint variables throughout the project.  25 and  29,  49,  109 and  111.  Update: Partially fixed in pull request #1. In line 46 of ArroToken.sol there is still a uint declaration.  No explicit visibility definition of variables  In line 111 and line 112, the balances and allowed variables are not explicitly declared as public.  To favor explicitness and readability, consider adding the visibility in all variable declarations.    Link reference to the ERC20 EIP is deprecated  The links to the ERC20 EIP in line 46 and in line 161 references to an old ERC20 document.  Consider referencing the official ERC20 EIP site instead.    Unused variables defined in function definitions  Named return variables are declared and unused. For example, in lines 139, 149, 165 and 181.  Consider removing all declared but unused return variables, or explicitly declaring them as local variables, and adding the necessary return statements when appropriate.    Missing error messages in require and revert statements  There are require and revert statements without an error message specified in line 85, line 93, and line 216.  Consider adding an appropriate message describing the validation or revert reason.    Inconsistent variable naming  Variable naming is inconsistent. For example, in line 109 _totalSupply has a leading underscore, while the other storage variables within the same contract do not.  Consider defining a naming convention based on Solidity Style Guide and follow this convention throughout the project.    Non-standard initialization of ERC20  In the ArroToken constructor, the variables of the token are being hardcoded.  OpenZeppelins ERC20Detailed contracts constructor for initializing the    Conclusion  No critical and one high severity issue was found. Some changes were proposed to follow best programming practices and reduce the potential attack surface.  Update: Changes in pull request #1 have introduced one high severity issue.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#update:-fixed-in-pull-request-#1.", "labels": ["OpenZeppelin"]}, {"title": "Outdated solidity version in use", "body": "Outdated solidity version in use", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#outdated-solidity-version-in-use", "labels": ["OpenZeppelin"]}, {"title": "An outdated Solidity version, 0.4.24, is currently in use.", "body": "An outdated Solidity version, 0.4.24, is currently in use.", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#an-outdated-solidity-version,-0.4.24,-is-currently-in-use.", "labels": ["OpenZeppelin"]}, {"title": "This can introduce vulnerabilities to the project that were fixed in newer solidity versions, such as the short address attack in the transfer and transferFrom functions. In this attack, a user inputs a malformed address as destination for a token transfer in an exchange, which is misled to craft a transaction for a much bigger amount of tokens. This does not constitute an issue in the smart contract code per se, since it is ultimately the responsibility of the entity crafting the transaction to check its validity and integrity, but it should be taken into account when interacting with the token contract.", "body": "This can introduce vulnerabilities to the project that were fixed in newer solidity versions, such as the short address attack in the transfer and transferFrom functions. In this attack, a user inputs a malformed address as destination for a token transfer in an exchange, which is misled to craft a transaction for a much bigger amount of tokens. This does not constitute an issue in the smart contract code per se, since it is ultimately the responsibility of the entity crafting the transaction to check its validity and integrity, but it should be taken into account when interacting with the token contract.", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#this-can-introduce-vulnerabilities-to-the-project-that-were-fixed-in-newer-solidity-versions,-such-as-the-short-address-attack-in-the-transfer-and-transferfrom-functions.-in-this-attack,-a-user-inputs-a-malformed-address-as-destination-for-a-token-transfer-in-an-exchange,-which-is-misled-to-craft-a-transaction-for-a-much-bigger-amount-of-tokens.-this-does-not-constitute-an-issue-in-the-smart-contract-code-per-se,-since-it-is-ultimately-the-responsibility-of-the-entity-crafting-the-transaction-to-check-its-validity-and-integrity,-but-it-should-be-taken-into-account-when-interacting-with-the-token-contract.", "labels": ["OpenZeppelin"]}, {"title": "Consider bumping the project to the latest version supported by OpenZeppelin Contracts (presently 0.5.15).", "body": "Consider bumping the project to the latest version supported by OpenZeppelin Contracts (presently 0.5.15).", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#consider-bumping-the-project-to-the-latest-version-supported-by-openzeppelin-contracts-(presently-0.5.15).", "labels": ["OpenZeppelin"]}, {"title": "Missing docstrings", "body": "Missing docstrings", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#missing-docstrings", "labels": ["OpenZeppelin"]}, {"title": "All the contracts and functions in Arro\u2019s code base lack proper documentation. This hinders reviewers\u2019 understanding of the code\u2019s intention, which is fundamental to correctly assess not only security, but also correctness. Additionally, docstrings improve readability and ease maintenance. They should explicitly explain the purpose or intention of the functions, the scenarios under which they can fail, the roles allowed to call them, the values returned and the events emitted.", "body": "All the contracts and functions in Arro\u2019s code base lack proper documentation. This hinders reviewers\u2019 understanding of the code\u2019s intention, which is fundamental to correctly assess not only security, but also correctness. Additionally, docstrings improve readability and ease maintenance. They should explicitly explain the purpose or intention of the functions, the scenarios under which they can fail, the roles allowed to call them, the values returned and the events emitted.", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#all-the-contracts-and-functions-in-arro\u2019s-code-base-lack-proper-documentation.-this-hinders-reviewers\u2019-understanding-of-the-code\u2019s-intention,-which-is-fundamental-to-correctly-assess-not-only-security,-but-also-correctness.-additionally,-docstrings-improve-readability-and-ease-maintenance.-they-should-explicitly-explain-the-purpose-or-intention-of-the-functions,-the-scenarios-under-which-they-can-fail,-the-roles-allowed-to-call-them,-the-values-returned-and-the-events-emitted.", "labels": ["OpenZeppelin"]}, {"title": "Consider thoroughly documenting all functions (and their parameters) that are part of the contracts\u2019 public API. Functions implementing sensitive functionality, even if not public, should be clearly documented as well. When writing docstrings, consider following the Ethereum Natural Specification Format (NatSpec).", "body": "Consider thoroughly documenting all functions (and their parameters) that are part of the contracts\u2019 public API. Functions implementing sensitive functionality, even if not public, should be clearly documented as well. When writing docstrings, consider following the Ethereum Natural Specification Format (NatSpec).", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#consider-thoroughly-documenting-all-functions-(and-their-parameters)-that-are-part-of-the-contracts\u2019-public-api.-functions-implementing-sensitive-functionality,-even-if-not-public,-should-be-clearly-documented-as-well.-when-writing-docstrings,-consider-following-the-ethereum-natural-specification-format-(natspec).", "labels": ["OpenZeppelin"]}, {"title": "Update: Partially fixed in pull request #1. Arro\u2019s statement for this issue:", "body": "Update: Partially fixed in pull request #1. Arro\u2019s statement for this issue:", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#update:-partially-fixed-in-pull-request-#1.-arro\u2019s-statement-for-this-issue:", "labels": ["OpenZeppelin"]}, {"title": "The project structure has been changed to rely heavily on the OpenZeppelin ERC20 implementation. This provides a well-documented base of most of the contract functionality. The rest of the structure of the documentation has been changed to follow a consistent structure but will be updated in the future to follow the Ethereum Natural Specification Format (NatSpec).", "body": "The project structure has been changed to rely heavily on the OpenZeppelin ERC20 implementation. This provides a well-documented base of most of the contract functionality. The rest of the structure of the documentation has been changed to follow a consistent structure but will be updated in the future to follow the Ethereum Natural Specification Format (NatSpec).", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#the-project-structure-has-been-changed-to-rely-heavily-on-the-openzeppelin-erc20-implementation.-this-provides-a-well-documented-base-of-most-of-the-contract-functionality.-the-rest-of-the-structure-of-the-documentation-has-been-changed-to-follow-a-consistent-structure-but-will-be-updated-in-the-future-to-follow-the-ethereum-natural-specification-format-(natspec).", "labels": ["OpenZeppelin"]}, {"title": "Low severity", "body": "Low severity", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#low-severity", "labels": ["OpenZeppelin"]}, {"title": "Lack of event emission OwnershipTransferred on contract construction", "body": "Lack of event emission OwnershipTransferred on contract construction", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#lack-of-event-emission-ownershiptransferred-on-contract-construction", "labels": ["OpenZeppelin"]}, {"title": "The OwnershipTransferred event is not being emitted when the ArroToken contract is initialized.", "body": "The OwnershipTransferred event is not being emitted when the ArroToken contract is initialized.", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#the-ownershiptransferred-event-is-not-being-emitted-when-the-arrotoken-contract-is-initialized.", "labels": ["OpenZeppelin"]}, {"title": "This means that there will be no record of who was the initial owner of the token in the OwnershipTransferred event logs.", "body": "This means that there will be no record of who was the initial owner of the token in the OwnershipTransferred event logs.", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#this-means-that-there-will-be-no-record-of-who-was-the-initial-owner-of-the-token-in-the-ownershiptransferred-event-logs.", "labels": ["OpenZeppelin"]}, {"title": "Consider using OpenZeppelin\u2019s Ownable contract which already covers this, or consider emitting an OwnershipTransferred after asigning the owner in the Owned\u2018s constructor.", "body": "Consider using OpenZeppelin\u2019s Ownable contract which already covers this, or consider emitting an OwnershipTransferred after asigning the owner in the Owned\u2018s constructor.", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#consider-using-openzeppelin\u2019s-ownable-contract-which-already-covers-this,-or-consider-emitting-an-ownershiptransferred-after-asigning-the-owner-in-the-owned\u2018s-constructor.", "labels": ["OpenZeppelin"]}, {"title": "Lack of event emission after modifying newOwner variable", "body": "Lack of event emission after modifying newOwner variable", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#lack-of-event-emission-after-modifying-newowner-variable", "labels": ["OpenZeppelin"]}, {"title": "In line 90 and in line 96, the storage variable newOwner is being modifed, but no events are being triggered.", "body": "In line 90 and in line 96, the storage variable newOwner is being modifed, but no events are being triggered.", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#in-line-90-and-in-line-96,-the-storage-variable-newowner-is-being-modifed,-but-no-events-are-being-triggered.", "labels": ["OpenZeppelin"]}, {"title": "This means that there will be no record of the changes of the newOwner variable, and traceability of the potential new owners of the TokenArro will be lost.", "body": "This means that there will be no record of the changes of the newOwner variable, and traceability of the potential new owners of the TokenArro will be lost.", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#this-means-that-there-will-be-no-record-of-the-changes-of-the-newowner-variable,-and-traceability-of-the-potential-new-owners-of-the-tokenarro-will-be-lost.", "labels": ["OpenZeppelin"]}, {"title": "Consider to define an event for tracking the newOwner variable value, and emit an event each time it is modified.", "body": "Consider to define an event for tracking the newOwner variable value, and emit an event each time it is modified.", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#consider-to-define-an-event-for-tracking-the-newowner-variable-value,-and-emit-an-event-each-time-it-is-modified.", "labels": ["OpenZeppelin"]}, {"title": "owner and newOwner storage variables can be modified without events emission", "body": "owner and newOwner storage variables can be modified without events emission", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#owner-and-newowner-storage-variables-can-be-modified-without-events-emission", "labels": ["OpenZeppelin"]}, {"title": "owner and", "body": "newOwner storage variables in the  Consider using OpenZeppelins Ownable contract which already covers this, or consider declaring  newOwner variables as private, and add getter functions for accessing them.  Update: Fixed in pull request #1.  Duplicate code in transfer and transferFrom functions  The transfer and transferFrom functions share very similar code. Duplicate code is more difficult to maintain, as it is longer and needs to be updated in different sections of the codebase.  Consider moving the duplicated code into another function and call it from the transfer and transferFrom functions.  Update: Fixed in pull request #1.  Wrong usage of inheritance with Safemath contract  A SafeMath contract is implemented in order to manage arithmetic overflows and underflows.  In this contract, all its functions are defined as public, which means that the ArroToken contract will expose them as part of its API, as it inherits from SafeMath. This extends the functionality that should be exposed by an ERC20 token. Additionally, the gas costs of the deploy will be higher as opposed to using SafeMath as a library.  Given that the functionality of the SafeMath contract can be exposed as a library, consider using OpenZeppelins SafeMath  Update: Fixed in pull request #1.  The TokenArro contract can be transferred to the zero address  The transferOwnership function in the Owned contract does not prevent to transfer the ownership of the contract to the zero address.  Consider using OpenZeppelins Ownable contract which already covers this, or consider restricting the new owner to non-zero addresses.  Update: Fixed in pull request #1.  Tokens can be transferred to the zero address  The transfer and the transferFrom functions in the ArroToken contract do not prevent to transfer tokens to the zero address.  Consider using the OpenZeppelins ERC20 implementation which already covers this, or consider restricting the to parameter to non-zero addresses.  Update: Fixed in pull request #1.  The totalSupply function does not return the real total supply  The totalSupply function returns the difference between the tokens total supply defined in the constructor and the tokens owned by the zero address, which is not strictly the total supply amount.  This could lead to a misinterpretation of the real total supply of the token when querying it.  Consider modifying the the totalSupply function implementation so it returns the real total supply value, and consider using the OpenZeppelins ERC20 implementation that implements the _burn and _burnFrom functions to keep the total supply variable up-to-date.  Update: Fixed in pull request #1.  Notes & Additional information  [introduced with the first round of fixes] Unnecessary inheritance and imports.  ArroToken contract inherits from the  OwnableUpgradeSafe contract inherits from the  Consider simplifying the code by removing the redundant inheritance declarations.  [introduced with the first round of fixes] initialize function missing the initializer modifier  initialize function of the  ArroToken contract is not using the  initializer modifier. Currently this is not an issue because the functions called by  initializer modifier to make the intention clearer and safer in case the code is modified.  Consider adding the initializer modifier in the definition of the initialize function.  [introduced with the first round of fixes] Unnecessary calls to initializers  initialize function of the  ArroToken contract calls  __Context_init_unchained(),  __Pausable_init_unchained(), and  __ERC20Pausable_init_unchained(). The  __ERC20Pausable_init() calls the same three initializers, so they can be replaced by this single call.  Consider calling __ERC20Pausable_init() to simplify the code.  Not following a consistent coding style  The code base deviates from the Solidity Style Guide. A consistent coding style helps with the readability of the project. Consider enforcing a standard coding style with help of linter tools such as Solhint.  Update: Fixed in pull request #1.  Multiple variables declared as uint  There are several variable declarations of uint variables throughout the project.  25 and  29,  49,  109 and  111.  Update: Partially fixed in pull request #1. In line 46 of ArroToken.sol there is still a uint declaration.  No explicit visibility definition of variables  In line 111 and line 112, the balances and allowed variables are not explicitly declared as public.  To favor explicitness and readability, consider adding the visibility in all variable declarations.  Update: Fixed in pull request #1.  Link reference to the ERC20 EIP is deprecated  The links to the ERC20 EIP in line 46 and in line 161 references to an old ERC20 document.  Consider referencing the official ERC20 EIP site instead.  Update: Fixed in pull request #1.  Unused variables defined in function definitions  Named return variables are declared and unused. For example, in lines 139, 149, 165 and 181.  Consider removing all declared but unused return variables, or explicitly declaring them as local variables, and adding the necessary return statements when appropriate.  Update: Fixed in pull request #1.  Missing error messages in require and revert statements  There are require and revert statements without an error message specified in line 85, line 93, and line 216.  Consider adding an appropriate message describing the validation or revert reason.  Update: Fixed in pull request #1.  Inconsistent variable naming  Variable naming is inconsistent. For example, in line 109 _totalSupply has a leading underscore, while the other storage variables within the same contract do not.  Consider defining a naming convention based on Solidity Style Guide and follow this convention throughout the project.  Update: Fixed in pull request #1.  Non-standard initialization of ERC20  In the ArroToken constructor, the variables of the token are being hardcoded.  OpenZeppelins ERC20Detailed contracts constructor for initializing the  Update: Fixed in pull request #1.  Conclusion  No critical and one high severity issue was found. Some changes were proposed to follow best programming practices and reduce the potential attack surface.  Update: Changes in pull request #1 have introduced one high severity issue.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#owner-and", "labels": ["OpenZeppelin"]}, {"title": "newOwner storage variables in the", "body": "newOwner storage variables in the", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#newowner-storage-variables-in-the", "labels": ["OpenZeppelin"]}, {"title": "Consider using OpenZeppelin\u2019s Ownable contract which already covers this, or consider declaring owner and newOwner variables as private, and add getter functions for accessing them.", "body": "Consider using OpenZeppelin\u2019s Ownable contract which already covers this, or consider declaring owner and newOwner variables as private, and add getter functions for accessing them.", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#consider-using-openzeppelin\u2019s-ownable-contract-which-already-covers-this,-or-consider-declaring-owner-and-newowner-variables-as-private,-and-add-getter-functions-for-accessing-them.", "labels": ["OpenZeppelin"]}, {"title": "Duplicate code in transfer and transferFrom functions", "body": "Duplicate code in transfer and transferFrom functions", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#duplicate-code-in-transfer-and-transferfrom-functions", "labels": ["OpenZeppelin"]}, {"title": "The transfer and transferFrom functions share very similar code. Duplicate code is more difficult to maintain, as it is longer and needs to be updated in different sections of the codebase.", "body": "The transfer and transferFrom functions share very similar code. Duplicate code is more difficult to maintain, as it is longer and needs to be updated in different sections of the codebase.", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#the-transfer-and-transferfrom-functions-share-very-similar-code.-duplicate-code-is-more-difficult-to-maintain,-as-it-is-longer-and-needs-to-be-updated-in-different-sections-of-the-codebase.", "labels": ["OpenZeppelin"]}, {"title": "Consider moving the duplicated code into another function and call it from the transfer and transferFrom functions.", "body": "Consider moving the duplicated code into another function and call it from the transfer and transferFrom functions.", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#consider-moving-the-duplicated-code-into-another-function-and-call-it-from-the-transfer-and-transferfrom-functions.", "labels": ["OpenZeppelin"]}, {"title": "Wrong usage of inheritance with Safemath contract", "body": "Wrong usage of inheritance with Safemath contract", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#wrong-usage-of-inheritance-with-safemath-contract", "labels": ["OpenZeppelin"]}, {"title": "A SafeMath contract is implemented in order to manage arithmetic overflows and underflows.", "body": "A SafeMath contract is implemented in order to manage arithmetic overflows and underflows.", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#a-safemath-contract-is-implemented-in-order-to-manage-arithmetic-overflows-and-underflows.", "labels": ["OpenZeppelin"]}, {"title": "In this contract, all its functions are defined as public, which means that the ArroToken contract will expose them as part of its API, as it inherits from SafeMath. This extends the functionality that should be exposed by an ERC20 token. Additionally, the gas costs of the deploy will be higher as opposed to using SafeMath as a library.", "body": "In this contract, all its functions are defined as public, which means that the ArroToken contract will expose them as part of its API, as it inherits from SafeMath. This extends the functionality that should be exposed by an ERC20 token. Additionally, the gas costs of the deploy will be higher as opposed to using SafeMath as a library.", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#in-this-contract,-all-its-functions-are-defined-as-public,-which-means-that-the-arrotoken-contract-will-expose-them-as-part-of-its-api,-as-it-inherits-from-safemath.-this-extends-the-functionality-that-should-be-exposed-by-an-erc20-token.-additionally,-the-gas-costs-of-the-deploy-will-be-higher-as-opposed-to-using-safemath-as-a-library.", "labels": ["OpenZeppelin"]}, {"title": "Given that the functionality of the SafeMath contract can be exposed as a library, consider using OpenZeppelin\u2019s SafeMath", "body": "Given that the functionality of the SafeMath contract can be exposed as a library, consider using OpenZeppelin\u2019s SafeMath", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#given-that-the-functionality-of-the-safemath-contract-can-be-exposed-as-a-library,-consider-using-openzeppelin\u2019s-safemath", "labels": ["OpenZeppelin"]}, {"title": "The TokenArro contract can be transferred to the zero address", "body": "The TokenArro contract can be transferred to the zero address", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#the-tokenarro-contract-can-be-transferred-to-the-zero-address", "labels": ["OpenZeppelin"]}, {"title": "The transferOwnership function in the Owned contract does not prevent to transfer the ownership of the contract to the zero address.", "body": "The transferOwnership function in the Owned contract does not prevent to transfer the ownership of the contract to the zero address.", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#the-transferownership-function-in-the-owned-contract-does-not-prevent-to-transfer-the-ownership-of-the-contract-to-the-zero-address.", "labels": ["OpenZeppelin"]}, {"title": "Consider using OpenZeppelin\u2019s Ownable contract which already covers this, or consider restricting the new owner to non-zero addresses.", "body": "Consider using OpenZeppelin\u2019s Ownable contract which already covers this, or consider restricting the new owner to non-zero addresses.", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#consider-using-openzeppelin\u2019s-ownable-contract-which-already-covers-this,-or-consider-restricting-the-new-owner-to-non-zero-addresses.", "labels": ["OpenZeppelin"]}, {"title": "Tokens can be transferred to the zero address", "body": "Tokens can be transferred to the zero address", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#tokens-can-be-transferred-to-the-zero-address", "labels": ["OpenZeppelin"]}, {"title": "The transfer and the transferFrom functions in the ArroToken contract do not prevent to transfer tokens to the zero address.", "body": "The transfer and the transferFrom functions in the ArroToken contract do not prevent to transfer tokens to the zero address.", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#the-transfer-and-the-transferfrom-functions-in-the-arrotoken-contract-do-not-prevent-to-transfer-tokens-to-the-zero-address.", "labels": ["OpenZeppelin"]}, {"title": "Consider using the OpenZeppelin\u2019s ERC20 implementation which already covers this, or consider restricting the to parameter to non-zero addresses.", "body": "Consider using the OpenZeppelin\u2019s ERC20 implementation which already covers this, or consider restricting the to parameter to non-zero addresses.", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#consider-using-the-openzeppelin\u2019s-erc20-implementation-which-already-covers-this,-or-consider-restricting-the-to-parameter-to-non-zero-addresses.", "labels": ["OpenZeppelin"]}, {"title": "The totalSupply function does not return the real total supply", "body": "The totalSupply function does not return the real total supply", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#the-totalsupply-function-does-not-return-the-real-total-supply", "labels": ["OpenZeppelin"]}, {"title": "The totalSupply function returns the difference between the token\u2019s total supply defined in the constructor and the tokens owned by the zero address, which is not strictly the total supply amount.", "body": "The totalSupply function returns the difference between the token\u2019s total supply defined in the constructor and the tokens owned by the zero address, which is not strictly the total supply amount.", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#the-totalsupply-function-returns-the-difference-between-the-token\u2019s-total-supply-defined-in-the-constructor-and-the-tokens-owned-by-the-zero-address,-which-is-not-strictly-the-total-supply-amount.", "labels": ["OpenZeppelin"]}, {"title": "This could lead to a misinterpretation of the real total supply of the token when querying it.", "body": "This could lead to a misinterpretation of the real total supply of the token when querying it.", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#this-could-lead-to-a-misinterpretation-of-the-real-total-supply-of-the-token-when-querying-it.", "labels": ["OpenZeppelin"]}, {"title": "Consider modifying the the totalSupply function implementation so it returns the real total supply value, and consider using the OpenZeppelin\u2019s ERC20 implementation that implements the _burn and _burnFrom functions to keep the total supply variable up-to-date.", "body": "Consider modifying the the totalSupply function implementation so it returns the real total supply value, and consider using the OpenZeppelin\u2019s ERC20 implementation that implements the _burn and _burnFrom functions to keep the total supply variable up-to-date.", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#consider-modifying-the-the-totalsupply-function-implementation-so-it-returns-the-real-total-supply-value,-and-consider-using-the-openzeppelin\u2019s-erc20-implementation-that-implements-the-_burn-and-_burnfrom-functions-to-keep-the-total-supply-variable-up-to-date.", "labels": ["OpenZeppelin"]}, {"title": "Notes & Additional information", "body": "Notes & Additional information", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#notes-&-additional-information", "labels": ["OpenZeppelin"]}, {"title": "[introduced with the first round of fixes] Unnecessary inheritance and imports.", "body": "[introduced with the first round of fixes] Unnecessary inheritance and imports.", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#[introduced-with-the-first-round-of-fixes]-unnecessary-inheritance-and-imports.", "labels": ["OpenZeppelin"]}, {"title": "ArroToken contract inherits from the", "body": "ArroToken contract inherits from the", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#arrotoken-contract-inherits-from-the", "labels": ["OpenZeppelin"]}, {"title": "OwnableUpgradeSafe contract inherits from the", "body": "OwnableUpgradeSafe contract inherits from the", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#ownableupgradesafe-contract-inherits-from-the", "labels": ["OpenZeppelin"]}, {"title": "Consider simplifying the code by removing the redundant inheritance declarations.", "body": "Consider simplifying the code by removing the redundant inheritance declarations.", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#consider-simplifying-the-code-by-removing-the-redundant-inheritance-declarations.", "labels": ["OpenZeppelin"]}, {"title": "[introduced with the first round of fixes] initialize function missing the initializer modifier", "body": "[introduced with the first round of fixes] initialize function missing the initializer modifier", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#[introduced-with-the-first-round-of-fixes]-initialize-function-missing-the-initializer-modifier", "labels": ["OpenZeppelin"]}, {"title": "initialize function of the", "body": "ArroToken contract calls  __Context_init_unchained(),  __Pausable_init_unchained(), and  __ERC20Pausable_init_unchained(). The  __ERC20Pausable_init() calls the same three initializers, so they can be replaced by this single call.  Consider calling __ERC20Pausable_init() to simplify the code.  Not following a consistent coding style  The code base deviates from the Solidity Style Guide. A consistent coding style helps with the readability of the project. Consider enforcing a standard coding style with help of linter tools such as Solhint.  Update: Fixed in pull request #1.  Multiple variables declared as uint  There are several variable declarations of uint variables throughout the project.  25 and  29,  49,  109 and  111.  Update: Partially fixed in pull request #1. In line 46 of ArroToken.sol there is still a uint declaration.  No explicit visibility definition of variables  In line 111 and line 112, the balances and allowed variables are not explicitly declared as public.  To favor explicitness and readability, consider adding the visibility in all variable declarations.  Update: Fixed in pull request #1.  Link reference to the ERC20 EIP is deprecated  The links to the ERC20 EIP in line 46 and in line 161 references to an old ERC20 document.  Consider referencing the official ERC20 EIP site instead.  Update: Fixed in pull request #1.  Unused variables defined in function definitions  Named return variables are declared and unused. For example, in lines 139, 149, 165 and 181.  Consider removing all declared but unused return variables, or explicitly declaring them as local variables, and adding the necessary return statements when appropriate.  Update: Fixed in pull request #1.  Missing error messages in require and revert statements  There are require and revert statements without an error message specified in line 85, line 93, and line 216.  Consider adding an appropriate message describing the validation or revert reason.  Update: Fixed in pull request #1.  Inconsistent variable naming  Variable naming is inconsistent. For example, in line 109 _totalSupply has a leading underscore, while the other storage variables within the same contract do not.  Consider defining a naming convention based on Solidity Style Guide and follow this convention throughout the project.  Update: Fixed in pull request #1.  Non-standard initialization of ERC20  In the ArroToken constructor, the variables of the token are being hardcoded.  OpenZeppelins ERC20Detailed contracts constructor for initializing the  Update: Fixed in pull request #1.  Conclusion  No critical and one high severity issue was found. Some changes were proposed to follow best programming practices and reduce the potential attack surface.  Update: Changes in pull request #1 have introduced one high severity issue.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#initialize-function-of-the", "labels": ["OpenZeppelin"]}, {"title": "ArroToken contract is not using the", "body": "ArroToken contract is not using the", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#arrotoken-contract-is-not-using-the", "labels": ["OpenZeppelin"]}, {"title": "initializer modifier. Currently this is not an issue because the functions called by", "body": "initializer modifier. Currently this is not an issue because the functions called by", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#initializer-modifier.-currently-this-is-not-an-issue-because-the-functions-called-by", "labels": ["OpenZeppelin"]}, {"title": "initializer modifier to make the intention clearer and safer in case the code is modified.", "body": "initializer modifier to make the intention clearer and safer in case the code is modified.", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#initializer-modifier-to-make-the-intention-clearer-and-safer-in-case-the-code-is-modified.", "labels": ["OpenZeppelin"]}, {"title": "Consider adding the initializer modifier in the definition of the initialize function.", "body": "Consider adding the initializer modifier in the definition of the initialize function.", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#consider-adding-the-initializer-modifier-in-the-definition-of-the-initialize-function.", "labels": ["OpenZeppelin"]}, {"title": "[introduced with the first round of fixes] Unnecessary calls to initializers", "body": "[introduced with the first round of fixes] Unnecessary calls to initializers", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#[introduced-with-the-first-round-of-fixes]-unnecessary-calls-to-initializers", "labels": ["OpenZeppelin"]}, {"title": "ArroToken contract calls", "body": "ArroToken contract calls", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#arrotoken-contract-calls", "labels": ["OpenZeppelin"]}, {"title": "__Context_init_unchained(),", "body": "__Context_init_unchained(),", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#__context_init_unchained(),", "labels": ["OpenZeppelin"]}, {"title": "__Pausable_init_unchained(), and", "body": "__Pausable_init_unchained(), and", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#__pausable_init_unchained(),-and", "labels": ["OpenZeppelin"]}, {"title": "__ERC20Pausable_init_unchained(). The", "body": "__ERC20Pausable_init_unchained(). The", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#__erc20pausable_init_unchained().-the", "labels": ["OpenZeppelin"]}, {"title": "__ERC20Pausable_init() calls the same three initializers, so they can be replaced by this single call.", "body": "__ERC20Pausable_init() calls the same three initializers, so they can be replaced by this single call.", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#__erc20pausable_init()-calls-the-same-three-initializers,-so-they-can-be-replaced-by-this-single-call.", "labels": ["OpenZeppelin"]}, {"title": "Consider calling __ERC20Pausable_init() to simplify the code.", "body": "Consider calling __ERC20Pausable_init() to simplify the code.", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#consider-calling-__erc20pausable_init()-to-simplify-the-code.", "labels": ["OpenZeppelin"]}, {"title": "Not following a consistent coding style", "body": "Not following a consistent coding style", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#not-following-a-consistent-coding-style", "labels": ["OpenZeppelin"]}, {"title": "The code base deviates from the Solidity Style Guide. A consistent coding style helps with the readability of the project. Consider enforcing a standard coding style with help of linter tools such as Solhint.", "body": "The code base deviates from the Solidity Style Guide. A consistent coding style helps with the readability of the project. Consider enforcing a standard coding style with help of linter tools such as Solhint.", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#the-code-base-deviates-from-the-solidity-style-guide.-a-consistent-coding-style-helps-with-the-readability-of-the-project.-consider-enforcing-a-standard-coding-style-with-help-of-linter-tools-such-as-solhint.", "labels": ["OpenZeppelin"]}, {"title": "Multiple variables declared as uint", "body": "Multiple variables declared as uint", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#multiple-variables-declared-as-uint", "labels": ["OpenZeppelin"]}, {"title": "There are several variable declarations of uint variables throughout the project.", "body": "There are several variable declarations of uint variables throughout the project.", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#there-are-several-variable-declarations-of-uint-variables-throughout-the-project.", "labels": ["OpenZeppelin"]}, {"title": "25 and", "body": "25 and", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#25-and", "labels": ["OpenZeppelin"]}, {"title": "29,", "body": "29,", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#29,", "labels": ["OpenZeppelin"]}, {"title": "49,", "body": "165 and 181.  Consider removing all declared but unused return variables, or explicitly declaring them as local variables, and adding the necessary return statements when appropriate.  Update: Fixed in pull request #1.  Missing error messages in require and revert statements  There are require and revert statements without an error message specified in line 85, line 93, and line 216.  Consider adding an appropriate message describing the validation or revert reason.  Update: Fixed in pull request #1.  Inconsistent variable naming  Variable naming is inconsistent. For example, in line 109 _totalSupply has a leading underscore, while the other storage variables within the same contract do not.  Consider defining a naming convention based on Solidity Style Guide and follow this convention throughout the project.  Update: Fixed in pull request #1.  Non-standard initialization of ERC20  In the ArroToken constructor, the variables of the token are being hardcoded.  OpenZeppelins ERC20Detailed contracts constructor for initializing the  Update: Fixed in pull request #1.  Conclusion  No critical and one high severity issue was found. Some changes were proposed to follow best programming practices and reduce the potential attack surface.  Update: Changes in pull request #1 have introduced one high severity issue.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#49,", "labels": ["OpenZeppelin"]}, {"title": "109 and", "body": "109 and", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#109-and", "labels": ["OpenZeppelin"]}, {"title": "111.", "body": "111.", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#111.", "labels": ["OpenZeppelin"]}, {"title": "Update: Partially fixed in pull request #1. In line 46 of ArroToken.sol there is still a uint declaration.", "body": "Update: Partially fixed in pull request #1. In line 46 of ArroToken.sol there is still a uint declaration.", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#update:-partially-fixed-in-pull-request-#1.-in-line-46-of-arrotoken.sol-there-is-still-a-uint-declaration.", "labels": ["OpenZeppelin"]}, {"title": "No explicit visibility definition of variables", "body": "No explicit visibility definition of variables", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#no-explicit-visibility-definition-of-variables", "labels": ["OpenZeppelin"]}, {"title": "In line 111 and line 112, the balances and allowed variables are not explicitly declared as public.", "body": "In line 111 and line 112, the balances and allowed variables are not explicitly declared as public.", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#in-line-111-and-line-112,-the-balances-and-allowed-variables-are-not-explicitly-declared-as-public.", "labels": ["OpenZeppelin"]}, {"title": "To favor explicitness and readability, consider adding the visibility in all variable declarations.", "body": "To favor explicitness and readability, consider adding the visibility in all variable declarations.", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#to-favor-explicitness-and-readability,-consider-adding-the-visibility-in-all-variable-declarations.", "labels": ["OpenZeppelin"]}, {"title": "Link reference to the ERC20 EIP is deprecated", "body": "Link reference to the ERC20 EIP is deprecated", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#link-reference-to-the-erc20-eip-is-deprecated", "labels": ["OpenZeppelin"]}, {"title": "The links to the ERC20 EIP in line 46 and in line 161 references to an old ERC20 document.", "body": "The links to the ERC20 EIP in line 46 and in line 161 references to an old ERC20 document.", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#the-links-to-the-erc20-eip-in-line-46-and-in-line-161-references-to-an-old-erc20-document.", "labels": ["OpenZeppelin"]}, {"title": "Consider referencing the official ERC20 EIP site instead.", "body": "Consider referencing the official ERC20 EIP site instead.", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#consider-referencing-the-official-erc20-eip-site-instead.", "labels": ["OpenZeppelin"]}, {"title": "Unused variables defined in function definitions", "body": "Unused variables defined in function definitions", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#unused-variables-defined-in-function-definitions", "labels": ["OpenZeppelin"]}, {"title": "Named return variables are declared and unused. For example, in lines 139, 149, 165 and 181.", "body": "Named return variables are declared and unused. For example, in lines 139, 149, 165 and 181.", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#named-return-variables-are-declared-and-unused.-for-example,-in-lines-139,-149,-165-and-181.", "labels": ["OpenZeppelin"]}, {"title": "Consider removing all declared but unused return variables, or explicitly declaring them as local variables, and adding the necessary return statements when appropriate.", "body": "Consider removing all declared but unused return variables, or explicitly declaring them as local variables, and adding the necessary return statements when appropriate.", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#consider-removing-all-declared-but-unused-return-variables,-or-explicitly-declaring-them-as-local-variables,-and-adding-the-necessary-return-statements-when-appropriate.", "labels": ["OpenZeppelin"]}, {"title": "Missing error messages in require and revert statements", "body": "Missing error messages in require and revert statements", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#missing-error-messages-in-require-and-revert-statements", "labels": ["OpenZeppelin"]}, {"title": "There are require and revert statements without an error message specified in line 85, line 93, and line 216.", "body": "There are require and revert statements without an error message specified in line 85, line 93, and line 216.", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#there-are-require-and-revert-statements-without-an-error-message-specified-in-line-85,-line-93,-and-line-216.", "labels": ["OpenZeppelin"]}, {"title": "Consider adding an appropriate message describing the validation or revert reason.", "body": "Consider adding an appropriate message describing the validation or revert reason.", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#consider-adding-an-appropriate-message-describing-the-validation-or-revert-reason.", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent variable naming", "body": "Inconsistent variable naming", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#inconsistent-variable-naming", "labels": ["OpenZeppelin"]}, {"title": "Variable naming is inconsistent. For example, in line 109 _totalSupply has a leading underscore, while the other storage variables within the same contract do not.", "body": "Variable naming is inconsistent. For example, in line 109 _totalSupply has a leading underscore, while the other storage variables within the same contract do not.", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#variable-naming-is-inconsistent.-for-example,-in-line-109-_totalsupply-has-a-leading-underscore,-while-the-other-storage-variables-within-the-same-contract-do-not.", "labels": ["OpenZeppelin"]}, {"title": "Consider defining a naming convention based on Solidity Style Guide and follow this convention throughout the project.", "body": "Consider defining a naming convention based on Solidity Style Guide and follow this convention throughout the project.", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#consider-defining-a-naming-convention-based-on-solidity-style-guide-and-follow-this-convention-throughout-the-project.", "labels": ["OpenZeppelin"]}, {"title": "Non-standard initialization of ERC20", "body": "Non-standard initialization of ERC20", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#non-standard-initialization-of-erc20", "labels": ["OpenZeppelin"]}, {"title": "In the ArroToken constructor, the variables of the token are being hardcoded.", "body": "In the ArroToken constructor, the variables of the token are being hardcoded.", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#in-the-arrotoken-constructor,-the-variables-of-the-token-are-being-hardcoded.", "labels": ["OpenZeppelin"]}, {"title": "OpenZeppelin\u2019s ERC20Detailed contract\u2019s constructor for initializing the", "body": "OpenZeppelin\u2019s ERC20Detailed contract\u2019s constructor for initializing the", "html_url": "https://blog.openzeppelin.com/arrotoken-audit#openzeppelin\u2019s-erc20detailed-contract\u2019s-constructor-for-initializing-the", "labels": ["OpenZeppelin"]}, {"title": "None.", "body": "Medium Severity Contract does not conform to the ERC1820 specification The ERC1820 standard defines a universal registry where addresses can register the interfaces they support. The specification requires that compliant contracts have a canImplementInterfaceForAddress(bytes32 interfaceHash, address addr) function that returns the ERC1820_ACCEPT_MAGIC constant if and only if the contract implements the interface (interfaceHash) for a given address (addr). Importantly, EIP1820 specifies:  If [the contract] does not implement the interfaceHash for a given address (addr), [the canImplementInterfaceForAddress function] MUST NOT return ERC1820_ACCEPT_MAGIC.  On line 12 of recoverable-wallet.sol the Erc777TokensRecipient contract implements a canImplementInterfaceForAddress function which returns the ERC1820_ACCEPT_MAGIC constant on all inputs. This would indicate to an external caller that the contract implements all interfaces for all addresses. Consider modifying this function so that it returns ERC1820_ACCEPT_MAGIC only when interfaceHash is keccak256(abi.encodePacked(ERC777TokensRecipient) and addr is address(this). Additionally, the ERC1820 standard defines the canImplementInterfaceForAddress(bytes32 interfaceHash, address addr) function with bytes32 interfaceHash as the first parameter and address addr as the second parameter. However, the implementation on line 12 of recoverable-wallet.sol has these parameters reversed. We recommend changing the order of these parameters so the canImplementInterfaceForAddress function complies with the ERC1820 specification. Update: The canImplementInterfaceForAddress function has been modified to conform with the ERC1820 standard. Note that the comments in lines 18 and 21 are still using addr, yet the variable has been renamed to _implementer. Race condition may result from compromised recovery address The RecoverableWallet contract implements a recovery system whereby the owner can register a list of recovery addresses using the add_recovery_address function on line 86. Each recovery address is associated with a positive _recovery_delay_in_days, and a recovery address with a strictly lower_recovery_delay_in_days is said to have a higher priority than a recovery address with a strictly higher _recovery_delay_in_days. The owner is able to remove recovery addresses using the remove_recovery_address function on line 92. At any time, a recover address may begin the recovery process by calling start_recovery (line 97 of recoverable-wallet.sol), thereby becoming the active_recovery_address. This puts the contract in the in recovery state, during which several of the contracts functions cannot be called, including the remove_recovery_address function. The owner can abort the recovery process by calling the cancel_recovery function, thereby putting the contract back into the out of recovery state. If a recovery address becomes compromised, the compromised address may call the start_recovery function, during which time the owner cannot remove the compromised address via the remove_recovery_address function due to the only_outside_recovery modifier. To remove the compromised address, the owner must first call the cancel_recovery function before calling remove_recovery_address(<compromised_address>). However, once the owner has called the cancel_recovery() function, there exists a race condition during which the compromised address attempts to call start_recovery() again before the owner can call remove_recovery_address(<compromised_address>). If successful, a compromised recovery address can keep the contract in a recovery state, thereby preventing any calls to any function with the only_outside_recovery modifier\u200a\u200aincluding the deploy and execute functions. If compromised recovery addresses are within the scope of the threat model, consider adding a function with the only_owner and only_during_recovery modifiers that cancels the recovery process and removes the compromised address in a single function call. Update: A new function (cancelRecoveryAndRemoveRecoveryAddress), has been added which allows the owner to cancel the recovery process and remove the offending recovery address in a single transaction. Ownership transfer cancellation can be front-run The RecoverableWallet contract implements an ownership transfer system whereby the owner may offer ownership of the Ownable contract to an address referred to as the pending_owner. This is achieved by calling the start_ownership_transfer function on line 38. Afterwards, the pending_owner may accept ownership by calling the accept_ownership function on line 50. If the current owner calls the cancel_ownership_transfer function before the pending_owner calls the accept_ownership function, then the offer is rescinded and the pending_onwer may no longer claim ownership. After the start_ownership_transfer function has been called by the owner, the owner may wish to call the cancel_ownership_transfer to prevent ownership transfer. After the owner has broadcasted a transaction calling the cancel_ownership_transfer function\u200a\u200abut before that transaction is mined\u200a\u200athe pending_owner may call the accept_ownership function using a transaction with a higher gas price, thereby accepting ownership before the transaction to rescind the offer has been mined. Whether or not this is a concern depends upon the intention of the owner when calling cancel_ownership_transfer. If the intention is to cancel the transfer of ownership to a non-responsive address, then this poses no threat. If the intention, however, is to prevent the transfer of ownership to a pending_owner that is no longer trusted, then this may pose a threat. Update: This is intentional functionality and a comment has been added to the code to indicate this. Recovery cancellation can be front-run Similar to the issue Ownership transfer cancellation can be front-run, cancellation of the recovery process can also be front-run. After the start_recovery function has been called by a recovery address, and after the active_recovery_end_time has passed, the owner may wish to call the cancel_recovery function to prevent finalization of recovery before someone calls the finish_recovery function. After the owner has broadcasted a transaction calling the cancel_recovery function\u200a\u200abut before that transaction is mined\u200a\u200aanyone may call the finish_recovery function using a transaction with a higher gas price. Whether or not this is a concern depends upon the intention of the owner when calling cancel_recovery. If the intention is to cancel the transfer of ownership to a non-responsive recovery address, then this poses no threat. If the intention, however, is to prevent the transfer of ownership to an active_recovery_address that is no longer trusted, then this may pose a threat. Update: This is intentional functionality and a comment has been added to the code to indicate this. Low Severity uint256/uint16 type mismatch There is a parameter type mismatch in the recovery_address_added event. The recovery_delay_in_days parameter in the recovery_address_added event (line 59) is of type uint256. This event is emitted on line 89 with its second parameter being passed a uint16. Consider using uint256 rather than uint16 everywhere. Update: The type of the recovery_delay_in_days parameter has been changed to uint16 to resolve the type mismatch. Mixed usage of the recovery and ownership transfer systems On line 122 the finish_recovery function sets pending_owner = active_recovery_address;. This requires the recovery address to then call accept_ownership in order to become the new owner. While this works fine, it requires two on-chain transactions and may result in an ownership_transfer_finished event being emitted without a corresponding ownership_transfer_started event preceding it. If this is undesirable behavior, consider setting the owner instead of the pending_owner on line 122, and then modifying the recovery_finished event accordingly. This would require one fewer on-chain transaction to change owners via the recovery process, and it would keep the recovery process and the ownership transfer system independent of one another. Update: The  finish_recovery function (since renamed to finishRecovery) has been modified to directly set the new owner and emit the correct sequence of events. Obscure error message provided upon contract creation failure The deploy function attempts to create a contract based on user-provided parameters and checks whether contract creation was successful by checking whether the output of create2 is a non-zero address. If the wallet contract doesnt have enough balance to fund the newly created contract with the amount specified in the _value parameter, the transaction will revert with the obscure Contract creation failed. error message issued by the non-zero address check. Consider splitting this into two checks. First, we suggest adding a require statement to the beginning of the deploy function that checks whether the RecoverableWallet contract has a balance of at least _value ETH, and returns a meaningful error message otherwise. Second, rather than checking that the output of create2 is a non-zero address, we recommend the more stringent requirement that code actually exists at the address returned by the call to create2 using extcodesize. Update: The deploy function has been modified to output more detailed messages in the event of a failed contract deployment. The extcodesize option was not used because a valid create2 call may not result in any code actually being deployed at the destination address (e.g., self-destruct in constructor or deployment code returning an empty bytecode array). Unnecessary setting of the active_recovery_end_time variable The variable active_recovery_end_time is consumed only in the finish_recovery function (on line 120), which has the only_during_recovery modifier. The only_during_recovery modifier passes only when active_recovery_address != address(0). This occurs only after start_recovery has been called and before either cancel_recovery or finish_recovery has been called. Since start_recovery sets active_recovery_end_time, there is no need to set active_recovery_end_time = uint256(-1) on line 67. Consider leaving the active_recovery_end_time variable uninitialized on line 67. For the same reason, it is unnecessary to set active_recovery_end_time = uint256(-1); in the reset_recovery function on line 146. Consider removing the code at line 146. Update: No changes have been made here. Setting active_recovery_end_time to uint256(-1) is intended to make code auditing and strict invariant checks easier. Unnecessary call to reset_recovery() in constructor Whether or not the recommendations from the issue Unnecessary setting of the active_recovery_end_time variable are taken into consideration, the call to reset_recovery on line 80 is unnecessary since active_recovery_address and active_recovery_end_time will be set correctly when start_recovery is called. Consider removing this function call. Update: The call to reset_recovery has been removed from the constructor.  Duplicate code in the finish_recovery() function Line 119 duplicates the code in the only_during_recovery modifier, which is already being applied to the finish_recovery function. Consider removing this superfluous line. Update: The duplicate code has been removed from the finish_recovery function. False comment in the start_recovery() function The comment on line 103 states:  NOTE: the recovery address cannot change during recovery, so we can rely on this being != 0  The second half of the statement\u200a\u200athat we can rely on this being != 0 is true. However the first part of the statement\u200a\u200athat the recovery address cannot change during recovery is false. The function that contains the comment (the start_recovery function) is the means by which a recovery address can change during recovery. In particular, a recovery address can change during recovery when a recovery address with a higher priority than the current active_recovery_address calls the start_recovery function. Update: The comment has be updated to correctly reflect contract behavior.  Ownership transfer can be started while another is underway The start_ownership_transfer function (line 38) in the Ownable contract can be called when the pending_owner is NOT address(0) (that is, when an ownership transfer is already underway). This can result in two or more ownership_transfer_started events being emitted back-to-back, with no ownership_transfer_cancelled or ownership_transfer_finished events emitted in between. If this is not intended functionality, consider adding a require(pending_owner == address(0)) to the start_ownership_transfer function to prevent this. Update: The start_ownership_transfer function (since renamed to startOwnershipTransfer) has been modified to first call the cancelOwnershipTransfer function before beginning a new ownership transfer. This ensures that the correct sequence of events is emitted. Ownership transfer can be cancelled before one is underway The cancel_ownership_transfer function (line 44) in the Ownable contract can be called when the pending_owner is address(0) (that is, when an ownership transfer is not already underway). This can result in an ownership_transfer_cancelled event being emitted without a corresponding ownership_transfer_started event having been emitted. If this is not intended functionality, consider adding a require(pending_owner != address(0)) to the cancel_ownership_transfer function to prevent this. Update: A require statement has been included that prevents the function from being called when no ownership transfer is underway. Overloaded functionality of the start_recovery() function The start_recovery function provides two functionalities. One is to allow a recovery address to initiate the recovery process when no recovery is underway. The other is to allow a recovery address with higher priority to usurp the current active_recovery_address when a recovery is already underway. These differing intentions both leverage the same function and both emit the same events. Consider disentangling these two functionalities by breaking the existing start_recovery function into two separate functions: a startRecovery function with the only_outside_recovery modifier that provides the first functionality, and a usurpRecovery function with the only_during_recovery modifier that provides the second functionality. Update: The start_recovery function is still being used to both begin a new recovery and usurp an existing one, but it has been modified so that a RecoveryCancelled event is emitted when usurping. This ensures that the correct events are emitted in the order.  Notes & Additional Information  The recovery_cancelled event (line 62) accepts no parameters. This may make recovery_cancelled events harder to track or interpret. Consider adding a parameter to this event.Update: A parameter has been added to this event. The start_ownership_transfer function can be called with the current owner passed as the _pending_owner. Similarly, the current owner can be added as a recovery address and so also may become the pending_owner by way of completing the recovery process. If this is undesirable behavior, consider adding require statements in the start_ownership_transfer and start_recovery functions to prevent this.Update: This is intended behavior. For all variables that store time values, consider changing their variable names to include the units of time they encode. For example, consider naming _proposed_recovery_delay to _proposedRecoveryDelayDays. Additionally, to make the code less error-prone during future changes, consider using only seconds throughout the code and using days only in the function interface.Update: Variables in units of days had their names changed to reflect this, but activeRecoveryEndTime is in units of seconds and its name still does not reflect it. On line 3 and line 9, consider renaming Erc1820Registry to ERC1820Registry. Following the Solidity Style Guide can improve code readability. For example, consider naming events using the CapWords style, naming functions and modifiers with the mixedCase style, keeping to a maximum line length of 79 (or 99) characters, etc.Update: Several changes were made to bring the code closer inline with the Solidity style guide.  The code active_recovery_address != address(0) is used in several places. Consider moving it to an internal view function, _inRecovery(), and referencing it on line 70, line 75, line 101, and line 119. If applying the suggestion from the issue Duplicate code in the finish_recovery() function and also splitting the current start_recovery function into two functions, then this recommendation will not provide any benefit. To improve readability/understandability, consider adding NatSpec documentation throughout the code.Update: NatSpec documentation was added throughout the code. Consider adding a comment above the exists function in the RecoverableWalletFactory contract to explain its purpose.Update: A comment was added above the exists function explaining its purpose. Two or more owners of recovery addresses with the same priority may find themselves in a race to be the first to call start_recovery.Update: This is intended functionality. We observed that it is not easy for the owner to unilaterally relinquish ownership of the wallet. The owner may offer ownership to another address, but that other address must actively accept the offer in order for ownership to transfer. It is possible, however, for the owner to provably relinquish control of the wallet by (1) failing to add any recovery addresses and (2) transferring ownership to a contract that calls accept_ownership() but provides no other functionality.Update: This is intended functionality. The function add_recovery_address will accept address(0) as a _new_recovery_address. This can result in recovery_delays[address(0)] > 0 and a recovery_address_added event being emitted with address(0). This is benign, but one may consider adding a require statement to add_recovery_address to prevent this.Update: A require statement has been added to prevent passing address(0) as the _new_recovery_address.  Conclusion No critical or high severity issues were found. Some changes were proposed to follow best practices, reduce the potential attack surface, and comply with the ERC1820 specification.        Note that as of the date of publishing, the above review reflects the current understanding of known security patterns as they relate to the audited contracts. The above should not be construed as investment advice. For general information about smart contract security, check out our thoughts here.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/recoverable-wallet-audit#none.", "labels": ["OpenZeppelin"]}, {"title": "Contract does not conform to the ERC1820 specification", "body": "Contract does not conform to the ERC1820 specification", "html_url": "https://blog.openzeppelin.com/recoverable-wallet-audit#contract-does-not-conform-to-the-erc1820-specification", "labels": ["OpenZeppelin"]}, {"title": "The ERC1820 standard defines a universal registry where addresses can register the interfaces they support. The specification requires that compliant contracts have a canImplementInterfaceForAddress(bytes32 interfaceHash, address addr) function that returns the ERC1820_ACCEPT_MAGIC constant if and only if the contract implements the interface (interfaceHash) for a given address (addr).", "body": "The ERC1820 standard defines a universal registry where addresses can register the interfaces they support. The specification requires that compliant contracts have a canImplementInterfaceForAddress(bytes32 interfaceHash, address addr) function that returns the ERC1820_ACCEPT_MAGIC constant if and only if the contract implements the interface (interfaceHash) for a given address (addr).", "html_url": "https://blog.openzeppelin.com/recoverable-wallet-audit#the-erc1820-standard-defines-a-universal-registry-where-addresses-can-register-the-interfaces-they-support.-the-specification-requires-that-compliant-contracts-have-a-canimplementinterfaceforaddress(bytes32-interfacehash,-address-addr)-function-that-returns-the-erc1820_accept_magic-constant-if-and-only-if-the-contract-implements-the-interface-(interfacehash)-for-a-given-address-(addr).", "labels": ["OpenZeppelin"]}, {"title": "Importantly, EIP1820 specifies:", "body": "Importantly, EIP1820 specifies:", "html_url": "https://blog.openzeppelin.com/recoverable-wallet-audit#importantly,-eip1820-specifies:", "labels": ["OpenZeppelin"]}, {"title": "If [the contract] does not implement the interfaceHash for a given address (addr), [the canImplementInterfaceForAddress function] MUST NOT return ERC1820_ACCEPT_MAGIC.", "body": "If [the contract] does not implement the interfaceHash for a given address (addr), [the canImplementInterfaceForAddress function] MUST NOT return ERC1820_ACCEPT_MAGIC.", "html_url": "https://blog.openzeppelin.com/recoverable-wallet-audit#if-[the-contract]-does-not-implement-the-interfacehash-for-a-given-address-(addr),-[the-canimplementinterfaceforaddress-function]-must-not-return-erc1820_accept_magic.", "labels": ["OpenZeppelin"]}, {"title": "On line 12 of recoverable-wallet.sol the Erc777TokensRecipient contract implements a canImplementInterfaceForAddress function which returns the ERC1820_ACCEPT_MAGIC constant on all inputs. This would indicate to an external caller that the contract implements all interfaces for all addresses.", "body": "On line 12 of recoverable-wallet.sol the Erc777TokensRecipient contract implements a canImplementInterfaceForAddress function which returns the ERC1820_ACCEPT_MAGIC constant on all inputs. This would indicate to an external caller that the contract implements all interfaces for all addresses.", "html_url": "https://blog.openzeppelin.com/recoverable-wallet-audit#on-line-12-of-recoverable-wallet.sol-the-erc777tokensrecipient-contract-implements-a-canimplementinterfaceforaddress-function-which-returns-the-erc1820_accept_magic-constant-on-all-inputs.-this-would-indicate-to-an-external-caller-that-the-contract-implements-all-interfaces-for-all-addresses.", "labels": ["OpenZeppelin"]}, {"title": "Consider modifying this function so that it returns ERC1820_ACCEPT_MAGIC only when interfaceHash is keccak256(abi.encodePacked(\u201cERC777TokensRecipient\u201d) and addr is address(this).", "body": "Consider modifying this function so that it returns ERC1820_ACCEPT_MAGIC only when interfaceHash is keccak256(abi.encodePacked(\u201cERC777TokensRecipient\u201d) and addr is address(this).", "html_url": "https://blog.openzeppelin.com/recoverable-wallet-audit#consider-modifying-this-function-so-that-it-returns-erc1820_accept_magic-only-when-interfacehash-is-keccak256(abi.encodepacked(\u201cerc777tokensrecipient\u201d)-and-addr-is-address(this).", "labels": ["OpenZeppelin"]}, {"title": "Additionally, the ERC1820 standard defines the canImplementInterfaceForAddress(bytes32 interfaceHash, address addr) function with bytes32 interfaceHash as the first parameter and address addr as the second parameter. However, the implementation on line 12 of recoverable-wallet.sol has these parameters reversed. We recommend changing the order of these parameters so the canImplementInterfaceForAddress function complies with the ERC1820 specification.", "body": "Additionally, the ERC1820 standard defines the canImplementInterfaceForAddress(bytes32 interfaceHash, address addr) function with bytes32 interfaceHash as the first parameter and address addr as the second parameter. However, the implementation on line 12 of recoverable-wallet.sol has these parameters reversed. We recommend changing the order of these parameters so the canImplementInterfaceForAddress function complies with the ERC1820 specification.", "html_url": "https://blog.openzeppelin.com/recoverable-wallet-audit#additionally,-the-erc1820-standard-defines-the-canimplementinterfaceforaddress(bytes32-interfacehash,-address-addr)-function-with-bytes32-interfacehash-as-the-first-parameter-and-address-addr-as-the-second-parameter.-however,-the-implementation-on-line-12-of-recoverable-wallet.sol-has-these-parameters-reversed.-we-recommend-changing-the-order-of-these-parameters-so-the-canimplementinterfaceforaddress-function-complies-with-the-erc1820-specification.", "labels": ["OpenZeppelin"]}, {"title": "Update: The\u00a0canImplementInterfaceForAddress function has been modified to conform with the ERC1820 standard. Note that the comments in lines 18 and 21 are still using addr, yet the variable has been renamed to _implementer.", "body": "Update: The\u00a0canImplementInterfaceForAddress function has been modified to conform with the ERC1820 standard. Note that the comments in lines 18 and 21 are still using addr, yet the variable has been renamed to _implementer.", "html_url": "https://blog.openzeppelin.com/recoverable-wallet-audit#update:-the\u00a0canimplementinterfaceforaddress-function-has-been-modified-to-conform-with-the-erc1820-standard.-note-that-the-comments-in-lines-18-and-21-are-still-using-addr,-yet-the-variable-has-been-renamed-to-_implementer.", "labels": ["OpenZeppelin"]}, {"title": "Race condition may result from compromised recovery\u00a0address", "body": "Race condition may result from compromised recovery\u00a0address", "html_url": "https://blog.openzeppelin.com/recoverable-wallet-audit#race-condition-may-result-from-compromised-recovery\u00a0address", "labels": ["OpenZeppelin"]}, {"title": "The RecoverableWallet contract implements a recovery system whereby the owner can register a list of recovery addresses using the add_recovery_address function on line 86. Each recovery address is associated with a positive _recovery_delay_in_days, and a recovery address with a strictly lower_recovery_delay_in_days is said to have a \u201chigher priority\u201d than a recovery address with a strictly higher _recovery_delay_in_days. The owner is able to remove recovery addresses using the remove_recovery_address function on line 92.", "body": "The RecoverableWallet contract implements a recovery system whereby the owner can register a list of recovery addresses using the add_recovery_address function on line 86. Each recovery address is associated with a positive _recovery_delay_in_days, and a recovery address with a strictly lower_recovery_delay_in_days is said to have a \u201chigher priority\u201d than a recovery address with a strictly higher _recovery_delay_in_days. The owner is able to remove recovery addresses using the remove_recovery_address function on line 92.", "html_url": "https://blog.openzeppelin.com/recoverable-wallet-audit#the-recoverablewallet-contract-implements-a-recovery-system-whereby-the-owner-can-register-a-list-of-recovery-addresses-using-the-add_recovery_address-function-on-line-86.-each-recovery-address-is-associated-with-a-positive-_recovery_delay_in_days,-and-a-recovery-address-with-a-strictly-lower_recovery_delay_in_days-is-said-to-have-a-\u201chigher-priority\u201d-than-a-recovery-address-with-a-strictly-higher-_recovery_delay_in_days.-the-owner-is-able-to-remove-recovery-addresses-using-the-remove_recovery_address-function-on-line-92.", "labels": ["OpenZeppelin"]}, {"title": "At any time, a recover address may begin the recovery process by calling start_recovery (line 97 of recoverable-wallet.sol), thereby becoming the active_recovery_address. This puts the contract in the \u201cin recovery\u201d state, during which several of the contract\u2019s functions cannot be called, including the remove_recovery_address function. The owner can abort the recovery process by calling the cancel_recovery function, thereby putting the contract back into the \u201cout of recovery\u201d state.", "body": "At any time, a recover address may begin the recovery process by calling start_recovery (line 97 of recoverable-wallet.sol), thereby becoming the active_recovery_address. This puts the contract in the \u201cin recovery\u201d state, during which several of the contract\u2019s functions cannot be called, including the remove_recovery_address function. The owner can abort the recovery process by calling the cancel_recovery function, thereby putting the contract back into the \u201cout of recovery\u201d state.", "html_url": "https://blog.openzeppelin.com/recoverable-wallet-audit#at-any-time,-a-recover-address-may-begin-the-recovery-process-by-calling-start_recovery-(line-97-of-recoverable-wallet.sol),-thereby-becoming-the-active_recovery_address.-this-puts-the-contract-in-the-\u201cin-recovery\u201d-state,-during-which-several-of-the-contract\u2019s-functions-cannot-be-called,-including-the-remove_recovery_address-function.-the-owner-can-abort-the-recovery-process-by-calling-the-cancel_recovery-function,-thereby-putting-the-contract-back-into-the-\u201cout-of-recovery\u201d-state.", "labels": ["OpenZeppelin"]}, {"title": "If a recovery address becomes compromised, the compromised address may call the start_recovery function, during which time the owner cannot remove the compromised address via the remove_recovery_address function due to the only_outside_recovery modifier. To remove the compromised address, the owner must first call the cancel_recovery function before calling remove_recovery_address(<compromised_address>).", "body": "If a recovery address becomes compromised, the compromised address may call the start_recovery function, during which time the owner cannot remove the compromised address via the remove_recovery_address function due to the only_outside_recovery modifier. To remove the compromised address, the owner must first call the cancel_recovery function before calling remove_recovery_address(<compromised_address>).", "html_url": "https://blog.openzeppelin.com/recoverable-wallet-audit#if-a-recovery-address-becomes-compromised,-the-compromised-address-may-call-the-start_recovery-function,-during-which-time-the-owner-cannot-remove-the-compromised-address-via-the-remove_recovery_address-function-due-to-the-only_outside_recovery-modifier.-to-remove-the-compromised-address,-the-owner-must-first-call-the-cancel_recovery-function-before-calling-remove_recovery_address(<compromised_address>).", "labels": ["OpenZeppelin"]}, {"title": "However, once the owner has called the cancel_recovery() function, there exists a race condition during which the compromised address attempts to call start_recovery() again before the owner can call remove_recovery_address(<compromised_address>). If successful, a compromised recovery address can keep the contract in a recovery state, thereby preventing any calls to any function with the only_outside_recovery modifier\u200a\u2014\u200aincluding the deploy and execute functions.", "body": "However, once the owner has called the cancel_recovery() function, there exists a race condition during which the compromised address attempts to call start_recovery() again before the owner can call remove_recovery_address(<compromised_address>). If successful, a compromised recovery address can keep the contract in a recovery state, thereby preventing any calls to any function with the only_outside_recovery modifier\u200a\u2014\u200aincluding the deploy and execute functions.", "html_url": "https://blog.openzeppelin.com/recoverable-wallet-audit#however,-once-the-owner-has-called-the-cancel_recovery()-function,-there-exists-a-race-condition-during-which-the-compromised-address-attempts-to-call-start_recovery()-again-before-the-owner-can-call-remove_recovery_address(<compromised_address>).-if-successful,-a-compromised-recovery-address-can-keep-the-contract-in-a-recovery-state,-thereby-preventing-any-calls-to-any-function-with-the-only_outside_recovery-modifier\u200a\u2014\u200aincluding-the-deploy-and-execute-functions.", "labels": ["OpenZeppelin"]}, {"title": "If compromised recovery addresses are within the scope of the threat model, consider adding a function with the only_owner and only_during_recovery modifiers that cancels the recovery process and removes the compromised address in a single function call.", "body": "If compromised recovery addresses are within the scope of the threat model, consider adding a function with the only_owner and only_during_recovery modifiers that cancels the recovery process and removes the compromised address in a single function call.", "html_url": "https://blog.openzeppelin.com/recoverable-wallet-audit#if-compromised-recovery-addresses-are-within-the-scope-of-the-threat-model,-consider-adding-a-function-with-the-only_owner-and-only_during_recovery-modifiers-that-cancels-the-recovery-process-and-removes-the-compromised-address-in-a-single-function-call.", "labels": ["OpenZeppelin"]}, {"title": "Update: A new function (cancelRecoveryAndRemoveRecoveryAddress), has been added which allows the owner to cancel the recovery process and remove the offending recovery address in a single transaction.", "body": "Update: A new function (cancelRecoveryAndRemoveRecoveryAddress), has been added which allows the owner to cancel the recovery process and remove the offending recovery address in a single transaction.", "html_url": "https://blog.openzeppelin.com/recoverable-wallet-audit#update:-a-new-function-(cancelrecoveryandremoverecoveryaddress),-has-been-added-which-allows-the-owner-to-cancel-the-recovery-process-and-remove-the-offending-recovery-address-in-a-single-transaction.", "labels": ["OpenZeppelin"]}, {"title": "Ownership transfer cancellation can be front-run", "body": ", cancellation of the recovery process can also be front-run. After the start_recovery function has been called by a recovery address, and after the active_recovery_end_time has passed, the owner may wish to call the cancel_recovery function to prevent finalization of recovery before someone calls the finish_recovery function. After the owner has broadcasted a transaction calling the cancel_recovery function\u200a\u200abut before that transaction is mined\u200a\u200aanyone may call the finish_recovery function using a transaction with a higher gas price. Whether or not this is a concern depends upon the intention of the owner when calling cancel_recovery. If the intention is to cancel the transfer of ownership to a non-responsive recovery address, then this poses no threat. If the intention, however, is to prevent the transfer of ownership to an active_recovery_address that is no longer trusted, then this may pose a threat. Update: This is intentional functionality and a comment has been added to the code to indicate this. Low Severity uint256/uint16 type mismatch There is a parameter type mismatch in the recovery_address_added event. The recovery_delay_in_days parameter in the recovery_address_added event (line 59) is of type uint256. This event is emitted on line 89 with its second parameter being passed a uint16. Consider using uint256 rather than uint16 everywhere. Update: The type of the recovery_delay_in_days parameter has been changed to uint16 to resolve the type mismatch. Mixed usage of the recovery and ownership transfer systems On line 122 the finish_recovery function sets pending_owner = active_recovery_address;. This requires the recovery address to then call accept_ownership in order to become the new owner. While this works fine, it requires two on-chain transactions and may result in an ownership_transfer_finished event being emitted without a corresponding ownership_transfer_started event preceding it. If this is undesirable behavior, consider setting the owner instead of the pending_owner on line 122, and then modifying the recovery_finished event accordingly. This would require one fewer on-chain transaction to change owners via the recovery process, and it would keep the recovery process and the ownership transfer system independent of one another. Update: The  finish_recovery function (since renamed to finishRecovery) has been modified to directly set the new owner and emit the correct sequence of events. Obscure error message provided upon contract creation failure The deploy function attempts to create a contract based on user-provided parameters and checks whether contract creation was successful by checking whether the output of create2 is a non-zero address. If the wallet contract doesnt have enough balance to fund the newly created contract with the amount specified in the _value parameter, the transaction will revert with the obscure Contract creation failed. error message issued by the non-zero address check. Consider splitting this into two checks. First, we suggest adding a require statement to the beginning of the deploy function that checks whether the RecoverableWallet contract has a balance of at least _value ETH, and returns a meaningful error message otherwise. Second, rather than checking that the output of create2 is a non-zero address, we recommend the more stringent requirement that code actually exists at the address returned by the call to create2 using extcodesize. Update: The deploy function has been modified to output more detailed messages in the event of a failed contract deployment. The extcodesize option was not used because a valid create2 call may not result in any code actually being deployed at the destination address (e.g., self-destruct in constructor or deployment code returning an empty bytecode array). Unnecessary setting of the active_recovery_end_time variable The variable active_recovery_end_time is consumed only in the finish_recovery function (on line 120), which has the only_during_recovery modifier. The only_during_recovery modifier passes only when active_recovery_address != address(0). This occurs only after start_recovery has been called and before either cancel_recovery or finish_recovery has been called. Since start_recovery sets active_recovery_end_time, there is no need to set active_recovery_end_time = uint256(-1) on line 67. Consider leaving the active_recovery_end_time variable uninitialized on line 67. For the same reason, it is unnecessary to set active_recovery_end_time = uint256(-1); in the reset_recovery function on line 146. Consider removing the code at line 146. Update: No changes have been made here. Setting active_recovery_end_time to uint256(-1) is intended to make code auditing and strict invariant checks easier. Unnecessary call to reset_recovery() in constructor Whether or not the recommendations from the issue Unnecessary setting of the active_recovery_end_time variable are taken into consideration, the call to reset_recovery on line 80 is unnecessary since active_recovery_address and active_recovery_end_time will be set correctly when start_recovery is called. Consider removing this function call. Update: The call to reset_recovery has been removed from the constructor.  Duplicate code in the finish_recovery() function Line 119 duplicates the code in the only_during_recovery modifier, which is already being applied to the finish_recovery function. Consider removing this superfluous line. Update: The duplicate code has been removed from the finish_recovery function. False comment in the start_recovery() function The comment on line 103 states:  NOTE: the recovery address cannot change during recovery, so we can rely on this being != 0  The second half of the statement\u200a\u200athat we can rely on this being != 0 is true. However the first part of the statement\u200a\u200athat the recovery address cannot change during recovery is false. The function that contains the comment (the start_recovery function) is the means by which a recovery address can change during recovery. In particular, a recovery address can change during recovery when a recovery address with a higher priority than the current active_recovery_address calls the start_recovery function. Update: The comment has be updated to correctly reflect contract behavior.  Ownership transfer can be started while another is underway The start_ownership_transfer function (line 38) in the Ownable contract can be called when the pending_owner is NOT address(0) (that is, when an ownership transfer is already underway). This can result in two or more ownership_transfer_started events being emitted back-to-back, with no ownership_transfer_cancelled or ownership_transfer_finished events emitted in between. If this is not intended functionality, consider adding a require(pending_owner == address(0)) to the start_ownership_transfer function to prevent this. Update: The start_ownership_transfer function (since renamed to startOwnershipTransfer) has been modified to first call the cancelOwnershipTransfer function before beginning a new ownership transfer. This ensures that the correct sequence of events is emitted. Ownership transfer can be cancelled before one is underway The cancel_ownership_transfer function (line 44) in the Ownable contract can be called when the pending_owner is address(0) (that is, when an ownership transfer is not already underway). This can result in an ownership_transfer_cancelled event being emitted without a corresponding ownership_transfer_started event having been emitted. If this is not intended functionality, consider adding a require(pending_owner != address(0)) to the cancel_ownership_transfer function to prevent this. Update: A require statement has been included that prevents the function from being called when no ownership transfer is underway. Overloaded functionality of the start_recovery() function The start_recovery function provides two functionalities. One is to allow a recovery address to initiate the recovery process when no recovery is underway. The other is to allow a recovery address with higher priority to usurp the current active_recovery_address when a recovery is already underway. These differing intentions both leverage the same function and both emit the same events. Consider disentangling these two functionalities by breaking the existing start_recovery function into two separate functions: a startRecovery function with the only_outside_recovery modifier that provides the first functionality, and a usurpRecovery function with the only_during_recovery modifier that provides the second functionality. Update: The start_recovery function is still being used to both begin a new recovery and usurp an existing one, but it has been modified so that a RecoveryCancelled event is emitted when usurping. This ensures that the correct events are emitted in the order.  Notes & Additional Information  The recovery_cancelled event (line 62) accepts no parameters. This may make recovery_cancelled events harder to track or interpret. Consider adding a parameter to this event.Update: A parameter has been added to this event. The start_ownership_transfer function can be called with the current owner passed as the _pending_owner. Similarly, the current owner can be added as a recovery address and so also may become the pending_owner by way of completing the recovery process. If this is undesirable behavior, consider adding require statements in the start_ownership_transfer and start_recovery functions to prevent this.Update: This is intended behavior. For all variables that store time values, consider changing their variable names to include the units of time they encode. For example, consider naming _proposed_recovery_delay to _proposedRecoveryDelayDays. Additionally, to make the code less error-prone during future changes, consider using only seconds throughout the code and using days only in the function interface.Update: Variables in units of days had their names changed to reflect this, but activeRecoveryEndTime is in units of seconds and its name still does not reflect it. On line 3 and line 9, consider renaming Erc1820Registry to ERC1820Registry. Following the Solidity Style Guide can improve code readability. For example, consider naming events using the CapWords style, naming functions and modifiers with the mixedCase style, keeping to a maximum line length of 79 (or 99) characters, etc.Update: Several changes were made to bring the code closer inline with the Solidity style guide.  The code active_recovery_address != address(0) is used in several places. Consider moving it to an internal view function, _inRecovery(), and referencing it on line 70, line 75, line 101, and line 119. If applying the suggestion from the issue Duplicate code in the finish_recovery() function and also splitting the current start_recovery function into two functions, then this recommendation will not provide any benefit. To improve readability/understandability, consider adding NatSpec documentation throughout the code.Update: NatSpec documentation was added throughout the code. Consider adding a comment above the exists function in the RecoverableWalletFactory contract to explain its purpose.Update: A comment was added above the exists function explaining its purpose. Two or more owners of recovery addresses with the same priority may find themselves in a race to be the first to call start_recovery.Update: This is intended functionality. We observed that it is not easy for the owner to unilaterally relinquish ownership of the wallet. The owner may offer ownership to another address, but that other address must actively accept the offer in order for ownership to transfer. It is possible, however, for the owner to provably relinquish control of the wallet by (1) failing to add any recovery addresses and (2) transferring ownership to a contract that calls accept_ownership() but provides no other functionality.Update: This is intended functionality. The function add_recovery_address will accept address(0) as a _new_recovery_address. This can result in recovery_delays[address(0)] > 0 and a recovery_address_added event being emitted with address(0). This is benign, but one may consider adding a require statement to add_recovery_address to prevent this.Update: A require statement has been added to prevent passing address(0) as the _new_recovery_address.  Conclusion No critical or high severity issues were found. Some changes were proposed to follow best practices, reduce the potential attack surface, and comply with the ERC1820 specification.        Note that as of the date of publishing, the above review reflects the current understanding of known security patterns as they relate to the audited contracts. The above should not be construed as investment advice. For general information about smart contract security, check out our thoughts here.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/recoverable-wallet-audit#ownership-transfer-cancellation-can-be-front-run", "labels": ["OpenZeppelin"]}, {"title": "The RecoverableWallet contract implements an ownership transfer system whereby the owner may offer ownership of the Ownable contract to an address referred to as the pending_owner. This is achieved by calling the start_ownership_transfer function on line 38. Afterwards, the pending_owner may accept ownership by calling the accept_ownership function on line 50. If the current owner calls the cancel_ownership_transfer function before the pending_owner calls the accept_ownership function, then the offer is rescinded and the pending_onwer may no longer claim ownership.", "body": "The RecoverableWallet contract implements an ownership transfer system whereby the owner may offer ownership of the Ownable contract to an address referred to as the pending_owner. This is achieved by calling the start_ownership_transfer function on line 38. Afterwards, the pending_owner may accept ownership by calling the accept_ownership function on line 50. If the current owner calls the cancel_ownership_transfer function before the pending_owner calls the accept_ownership function, then the offer is rescinded and the pending_onwer may no longer claim ownership.", "html_url": "https://blog.openzeppelin.com/recoverable-wallet-audit#the-recoverablewallet-contract-implements-an-ownership-transfer-system-whereby-the-owner-may-offer-ownership-of-the-ownable-contract-to-an-address-referred-to-as-the-pending_owner.-this-is-achieved-by-calling-the-start_ownership_transfer-function-on-line-38.-afterwards,-the-pending_owner-may-accept-ownership-by-calling-the-accept_ownership-function-on-line-50.-if-the-current-owner-calls-the-cancel_ownership_transfer-function-before-the-pending_owner-calls-the-accept_ownership-function,-then-the-offer-is-rescinded-and-the-pending_onwer-may-no-longer-claim-ownership.", "labels": ["OpenZeppelin"]}, {"title": "After the start_ownership_transfer function has been called by the owner, the owner may wish to call the cancel_ownership_transfer to prevent ownership transfer. After the owner has broadcasted a transaction calling the cancel_ownership_transfer function\u200a\u2014\u200abut before that transaction is mined\u200a\u2014\u200athe pending_owner may call the accept_ownership function using a transaction with a higher gas price, thereby accepting ownership before the transaction to rescind the offer has been mined.", "body": "After the start_ownership_transfer function has been called by the owner, the owner may wish to call the cancel_ownership_transfer to prevent ownership transfer. After the owner has broadcasted a transaction calling the cancel_ownership_transfer function\u200a\u2014\u200abut before that transaction is mined\u200a\u2014\u200athe pending_owner may call the accept_ownership function using a transaction with a higher gas price, thereby accepting ownership before the transaction to rescind the offer has been mined.", "html_url": "https://blog.openzeppelin.com/recoverable-wallet-audit#after-the-start_ownership_transfer-function-has-been-called-by-the-owner,-the-owner-may-wish-to-call-the-cancel_ownership_transfer-to-prevent-ownership-transfer.-after-the-owner-has-broadcasted-a-transaction-calling-the-cancel_ownership_transfer-function\u200a\u2014\u200abut-before-that-transaction-is-mined\u200a\u2014\u200athe-pending_owner-may-call-the-accept_ownership-function-using-a-transaction-with-a-higher-gas-price,-thereby-accepting-ownership-before-the-transaction-to-rescind-the-offer-has-been-mined.", "labels": ["OpenZeppelin"]}, {"title": "Whether or not this is a concern depends upon the intention of the owner when calling cancel_ownership_transfer. If the intention is to cancel the transfer of ownership to a non-responsive address, then this poses no threat. If the intention, however, is to prevent the transfer of ownership to a pending_owner that is no longer trusted, then this may pose a threat.", "body": "Whether or not this is a concern depends upon the intention of the owner when calling cancel_ownership_transfer. If the intention is to cancel the transfer of ownership to a non-responsive address, then this poses no threat. If the intention, however, is to prevent the transfer of ownership to a pending_owner that is no longer trusted, then this may pose a threat.", "html_url": "https://blog.openzeppelin.com/recoverable-wallet-audit#whether-or-not-this-is-a-concern-depends-upon-the-intention-of-the-owner-when-calling-cancel_ownership_transfer.-if-the-intention-is-to-cancel-the-transfer-of-ownership-to-a-non-responsive-address,-then-this-poses-no-threat.-if-the-intention,-however,-is-to-prevent-the-transfer-of-ownership-to-a-pending_owner-that-is-no-longer-trusted,-then-this-may-pose-a-threat.", "labels": ["OpenZeppelin"]}, {"title": "Update: This is intentional functionality and a comment has been added to the code to indicate this.", "body": "Low Severity uint256/uint16 type mismatch There is a parameter type mismatch in the recovery_address_added event. The recovery_delay_in_days parameter in the recovery_address_added event (line 59) is of type uint256. This event is emitted on line 89 with its second parameter being passed a uint16. Consider using uint256 rather than uint16 everywhere. Update: The type of the recovery_delay_in_days parameter has been changed to uint16 to resolve the type mismatch. Mixed usage of the recovery and ownership transfer systems On line 122 the finish_recovery function sets pending_owner = active_recovery_address;. This requires the recovery address to then call accept_ownership in order to become the new owner. While this works fine, it requires two on-chain transactions and may result in an ownership_transfer_finished event being emitted without a corresponding ownership_transfer_started event preceding it. If this is undesirable behavior, consider setting the owner instead of the pending_owner on line 122, and then modifying the recovery_finished event accordingly. This would require one fewer on-chain transaction to change owners via the recovery process, and it would keep the recovery process and the ownership transfer system independent of one another. Update: The  finish_recovery function (since renamed to finishRecovery) has been modified to directly set the new owner and emit the correct sequence of events. Obscure error message provided upon contract creation failure The deploy function attempts to create a contract based on user-provided parameters and checks whether contract creation was successful by checking whether the output of create2 is a non-zero address. If the wallet contract doesnt have enough balance to fund the newly created contract with the amount specified in the _value parameter, the transaction will revert with the obscure Contract creation failed. error message issued by the non-zero address check. Consider splitting this into two checks. First, we suggest adding a require statement to the beginning of the deploy function that checks whether the RecoverableWallet contract has a balance of at least _value ETH, and returns a meaningful error message otherwise. Second, rather than checking that the output of create2 is a non-zero address, we recommend the more stringent requirement that code actually exists at the address returned by the call to create2 using extcodesize. Update: The deploy function has been modified to output more detailed messages in the event of a failed contract deployment. The extcodesize option was not used because a valid create2 call may not result in any code actually being deployed at the destination address (e.g., self-destruct in constructor or deployment code returning an empty bytecode array). Unnecessary setting of the active_recovery_end_time variable The variable active_recovery_end_time is consumed only in the finish_recovery function (on line 120), which has the only_during_recovery modifier. The only_during_recovery modifier passes only when active_recovery_address != address(0). This occurs only after start_recovery has been called and before either cancel_recovery or finish_recovery has been called. Since start_recovery sets active_recovery_end_time, there is no need to set active_recovery_end_time = uint256(-1) on line 67. Consider leaving the active_recovery_end_time variable uninitialized on line 67. For the same reason, it is unnecessary to set active_recovery_end_time = uint256(-1); in the reset_recovery function on line 146. Consider removing the code at line 146. Update: No changes have been made here. Setting active_recovery_end_time to uint256(-1) is intended to make code auditing and strict invariant checks easier. Unnecessary call to reset_recovery() in constructor Whether or not the recommendations from the issue Unnecessary setting of the active_recovery_end_time variable are taken into consideration, the call to reset_recovery on line 80 is unnecessary since active_recovery_address and active_recovery_end_time will be set correctly when start_recovery is called. Consider removing this function call. Update: The call to reset_recovery has been removed from the constructor.  Duplicate code in the finish_recovery() function Line 119 duplicates the code in the only_during_recovery modifier, which is already being applied to the finish_recovery function. Consider removing this superfluous line. Update: The duplicate code has been removed from the finish_recovery function. False comment in the start_recovery() function The comment on line 103 states:  NOTE: the recovery address cannot change during recovery, so we can rely on this being != 0  The second half of the statement\u200a\u200athat we can rely on this being != 0 is true. However the first part of the statement\u200a\u200athat the recovery address cannot change during recovery is false. The function that contains the comment (the start_recovery function) is the means by which a recovery address can change during recovery. In particular, a recovery address can change during recovery when a recovery address with a higher priority than the current active_recovery_address calls the start_recovery function. Update: The comment has be updated to correctly reflect contract behavior.  Ownership transfer can be started while another is underway The start_ownership_transfer function (line 38) in the Ownable contract can be called when the pending_owner is NOT address(0) (that is, when an ownership transfer is already underway). This can result in two or more ownership_transfer_started events being emitted back-to-back, with no ownership_transfer_cancelled or ownership_transfer_finished events emitted in between. If this is not intended functionality, consider adding a require(pending_owner == address(0)) to the start_ownership_transfer function to prevent this. Update: The start_ownership_transfer function (since renamed to startOwnershipTransfer) has been modified to first call the cancelOwnershipTransfer function before beginning a new ownership transfer. This ensures that the correct sequence of events is emitted. Ownership transfer can be cancelled before one is underway The cancel_ownership_transfer function (line 44) in the Ownable contract can be called when the pending_owner is address(0) (that is, when an ownership transfer is not already underway). This can result in an ownership_transfer_cancelled event being emitted without a corresponding ownership_transfer_started event having been emitted. If this is not intended functionality, consider adding a require(pending_owner != address(0)) to the cancel_ownership_transfer function to prevent this. Update: A require statement has been included that prevents the function from being called when no ownership transfer is underway. Overloaded functionality of the start_recovery() function The start_recovery function provides two functionalities. One is to allow a recovery address to initiate the recovery process when no recovery is underway. The other is to allow a recovery address with higher priority to usurp the current active_recovery_address when a recovery is already underway. These differing intentions both leverage the same function and both emit the same events. Consider disentangling these two functionalities by breaking the existing start_recovery function into two separate functions: a startRecovery function with the only_outside_recovery modifier that provides the first functionality, and a usurpRecovery function with the only_during_recovery modifier that provides the second functionality. Update: The start_recovery function is still being used to both begin a new recovery and usurp an existing one, but it has been modified so that a RecoveryCancelled event is emitted when usurping. This ensures that the correct events are emitted in the order.  Notes & Additional Information  The recovery_cancelled event (line 62) accepts no parameters. This may make recovery_cancelled events harder to track or interpret. Consider adding a parameter to this event.Update: A parameter has been added to this event. The start_ownership_transfer function can be called with the current owner passed as the _pending_owner. Similarly, the current owner can be added as a recovery address and so also may become the pending_owner by way of completing the recovery process. If this is undesirable behavior, consider adding require statements in the start_ownership_transfer and start_recovery functions to prevent this.Update: This is intended behavior. For all variables that store time values, consider changing their variable names to include the units of time they encode. For example, consider naming _proposed_recovery_delay to _proposedRecoveryDelayDays. Additionally, to make the code less error-prone during future changes, consider using only seconds throughout the code and using days only in the function interface.Update: Variables in units of days had their names changed to reflect this, but activeRecoveryEndTime is in units of seconds and its name still does not reflect it. On line 3 and line 9, consider renaming Erc1820Registry to ERC1820Registry. Following the Solidity Style Guide can improve code readability. For example, consider naming events using the CapWords style, naming functions and modifiers with the mixedCase style, keeping to a maximum line length of 79 (or 99) characters, etc.Update: Several changes were made to bring the code closer inline with the Solidity style guide.  The code active_recovery_address != address(0) is used in several places. Consider moving it to an internal view function, _inRecovery(), and referencing it on line 70, line 75, line 101, and line 119. If applying the suggestion from the issue Duplicate code in the finish_recovery() function and also splitting the current start_recovery function into two functions, then this recommendation will not provide any benefit. To improve readability/understandability, consider adding NatSpec documentation throughout the code.Update: NatSpec documentation was added throughout the code. Consider adding a comment above the exists function in the RecoverableWalletFactory contract to explain its purpose.Update: A comment was added above the exists function explaining its purpose. Two or more owners of recovery addresses with the same priority may find themselves in a race to be the first to call start_recovery.Update: This is intended functionality. We observed that it is not easy for the owner to unilaterally relinquish ownership of the wallet. The owner may offer ownership to another address, but that other address must actively accept the offer in order for ownership to transfer. It is possible, however, for the owner to provably relinquish control of the wallet by (1) failing to add any recovery addresses and (2) transferring ownership to a contract that calls accept_ownership() but provides no other functionality.Update: This is intended functionality. The function add_recovery_address will accept address(0) as a _new_recovery_address. This can result in recovery_delays[address(0)] > 0 and a recovery_address_added event being emitted with address(0). This is benign, but one may consider adding a require statement to add_recovery_address to prevent this.Update: A require statement has been added to prevent passing address(0) as the _new_recovery_address.  Conclusion No critical or high severity issues were found. Some changes were proposed to follow best practices, reduce the potential attack surface, and comply with the ERC1820 specification.        Note that as of the date of publishing, the above review reflects the current understanding of known security patterns as they relate to the audited contracts. The above should not be construed as investment advice. For general information about smart contract security, check out our thoughts here.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/recoverable-wallet-audit#update:-this-is-intentional-functionality-and-a-comment-has-been-added-to-the-code-to-indicate-this.", "labels": ["OpenZeppelin"]}, {"title": "Recovery cancellation can be front-run", "body": "Recovery cancellation can be front-run", "html_url": "https://blog.openzeppelin.com/recoverable-wallet-audit#recovery-cancellation-can-be-front-run", "labels": ["OpenZeppelin"]}, {"title": "Similar to the issue \u201cOwnership transfer cancellation can be front-run\u201d, cancellation of the recovery process can also be front-run. After the start_recovery function has been called by a recovery address, and after the active_recovery_end_time has passed, the owner may wish to call the cancel_recovery function to prevent finalization of recovery before someone calls the finish_recovery function. After the owner has broadcasted a transaction calling the cancel_recovery function\u200a\u2014\u200abut before that transaction is mined\u200a\u2014\u200aanyone may call the finish_recovery function using a transaction with a higher gas price.", "body": "Similar to the issue \u201cOwnership transfer cancellation can be front-run\u201d, cancellation of the recovery process can also be front-run. After the start_recovery function has been called by a recovery address, and after the active_recovery_end_time has passed, the owner may wish to call the cancel_recovery function to prevent finalization of recovery before someone calls the finish_recovery function. After the owner has broadcasted a transaction calling the cancel_recovery function\u200a\u2014\u200abut before that transaction is mined\u200a\u2014\u200aanyone may call the finish_recovery function using a transaction with a higher gas price.", "html_url": "https://blog.openzeppelin.com/recoverable-wallet-audit#similar-to-the-issue-\u201cownership-transfer-cancellation-can-be-front-run\u201d,-cancellation-of-the-recovery-process-can-also-be-front-run.-after-the-start_recovery-function-has-been-called-by-a-recovery-address,-and-after-the-active_recovery_end_time-has-passed,-the-owner-may-wish-to-call-the-cancel_recovery-function-to-prevent-finalization-of-recovery-before-someone-calls-the-finish_recovery-function.-after-the-owner-has-broadcasted-a-transaction-calling-the-cancel_recovery-function\u200a\u2014\u200abut-before-that-transaction-is-mined\u200a\u2014\u200aanyone-may-call-the-finish_recovery-function-using-a-transaction-with-a-higher-gas-price.", "labels": ["OpenZeppelin"]}, {"title": "Whether or not this is a concern depends upon the intention of the owner when calling cancel_recovery. If the intention is to cancel the transfer of ownership to a non-responsive recovery address, then this poses no threat. If the intention, however, is to prevent the transfer of ownership to an active_recovery_address that is no longer trusted, then this may pose a threat.", "body": "Whether or not this is a concern depends upon the intention of the owner when calling cancel_recovery. If the intention is to cancel the transfer of ownership to a non-responsive recovery address, then this poses no threat. If the intention, however, is to prevent the transfer of ownership to an active_recovery_address that is no longer trusted, then this may pose a threat.", "html_url": "https://blog.openzeppelin.com/recoverable-wallet-audit#whether-or-not-this-is-a-concern-depends-upon-the-intention-of-the-owner-when-calling-cancel_recovery.-if-the-intention-is-to-cancel-the-transfer-of-ownership-to-a-non-responsive-recovery-address,-then-this-poses-no-threat.-if-the-intention,-however,-is-to-prevent-the-transfer-of-ownership-to-an-active_recovery_address-that-is-no-longer-trusted,-then-this-may-pose-a-threat.", "labels": ["OpenZeppelin"]}, {"title": "uint256/uint16 type\u00a0mismatch", "body": "uint256/uint16 type\u00a0mismatch", "html_url": "https://blog.openzeppelin.com/recoverable-wallet-audit#uint256/uint16-type\u00a0mismatch", "labels": ["OpenZeppelin"]}, {"title": "There is a parameter type mismatch in the recovery_address_added event. The recovery_delay_in_days parameter in the recovery_address_added event (line 59) is of type uint256. This event is emitted on line 89 with its second parameter being passed a uint16.", "body": "There is a parameter type mismatch in the recovery_address_added event. The recovery_delay_in_days parameter in the recovery_address_added event (line 59) is of type uint256. This event is emitted on line 89 with its second parameter being passed a uint16.", "html_url": "https://blog.openzeppelin.com/recoverable-wallet-audit#there-is-a-parameter-type-mismatch-in-the-recovery_address_added-event.-the-recovery_delay_in_days-parameter-in-the-recovery_address_added-event-(line-59)-is-of-type-uint256.-this-event-is-emitted-on-line-89-with-its-second-parameter-being-passed-a-uint16.", "labels": ["OpenZeppelin"]}, {"title": "Consider using uint256 rather than uint16 everywhere.", "body": "Consider using uint256 rather than uint16 everywhere.", "html_url": "https://blog.openzeppelin.com/recoverable-wallet-audit#consider-using-uint256-rather-than-uint16-everywhere.", "labels": ["OpenZeppelin"]}, {"title": "Update: The type of the\u00a0recovery_delay_in_days parameter has been changed to uint16 to resolve the type mismatch.", "body": "Update: The type of the\u00a0recovery_delay_in_days parameter has been changed to uint16 to resolve the type mismatch.", "html_url": "https://blog.openzeppelin.com/recoverable-wallet-audit#update:-the-type-of-the\u00a0recovery_delay_in_days-parameter-has-been-changed-to-uint16-to-resolve-the-type-mismatch.", "labels": ["OpenZeppelin"]}, {"title": "Mixed usage of the recovery and ownership transfer\u00a0systems", "body": "Mixed usage of the recovery and ownership transfer\u00a0systems", "html_url": "https://blog.openzeppelin.com/recoverable-wallet-audit#mixed-usage-of-the-recovery-and-ownership-transfer\u00a0systems", "labels": ["OpenZeppelin"]}, {"title": "On line 122 the finish_recovery function sets pending_owner = active_recovery_address;. This requires the recovery address to then call accept_ownership in order to become the new owner. While this works fine, it requires two on-chain transactions and may result in an ownership_transfer_finished event being emitted without a corresponding ownership_transfer_started event preceding it.", "body": "On line 122 the finish_recovery function sets pending_owner = active_recovery_address;. This requires the recovery address to then call accept_ownership in order to become the new owner. While this works fine, it requires two on-chain transactions and may result in an ownership_transfer_finished event being emitted without a corresponding ownership_transfer_started event preceding it.", "html_url": "https://blog.openzeppelin.com/recoverable-wallet-audit#on-line-122-the-finish_recovery-function-sets-pending_owner-=-active_recovery_address;.-this-requires-the-recovery-address-to-then-call-accept_ownership-in-order-to-become-the-new-owner.-while-this-works-fine,-it-requires-two-on-chain-transactions-and-may-result-in-an-ownership_transfer_finished-event-being-emitted-without-a-corresponding-ownership_transfer_started-event-preceding-it.", "labels": ["OpenZeppelin"]}, {"title": "If this is undesirable behavior, consider setting the owner instead of the pending_owner on line 122, and then modifying the recovery_finished event accordingly. This would require one fewer on-chain transaction to change owners via the recovery process, and it would keep the recovery process and the ownership transfer system independent of one another.", "body": "If this is undesirable behavior, consider setting the owner instead of the pending_owner on line 122, and then modifying the recovery_finished event accordingly. This would require one fewer on-chain transaction to change owners via the recovery process, and it would keep the recovery process and the ownership transfer system independent of one another.", "html_url": "https://blog.openzeppelin.com/recoverable-wallet-audit#if-this-is-undesirable-behavior,-consider-setting-the-owner-instead-of-the-pending_owner-on-line-122,-and-then-modifying-the-recovery_finished-event-accordingly.-this-would-require-one-fewer-on-chain-transaction-to-change-owners-via-the-recovery-process,-and-it-would-keep-the-recovery-process-and-the-ownership-transfer-system-independent-of-one-another.", "labels": ["OpenZeppelin"]}, {"title": "Update: The \u00a0finish_recovery function (since renamed to finishRecovery) has been modified to directly set the new owner and emit the correct sequence of events.", "body": "Update: The \u00a0finish_recovery function (since renamed to finishRecovery) has been modified to directly set the new owner and emit the correct sequence of events.", "html_url": "https://blog.openzeppelin.com/recoverable-wallet-audit#update:-the-\u00a0finish_recovery-function-(since-renamed-to-finishrecovery)-has-been-modified-to-directly-set-the-new-owner-and-emit-the-correct-sequence-of-events.", "labels": ["OpenZeppelin"]}, {"title": "Obscure error message provided upon contract creation\u00a0failure", "body": "Obscure error message provided upon contract creation\u00a0failure", "html_url": "https://blog.openzeppelin.com/recoverable-wallet-audit#obscure-error-message-provided-upon-contract-creation\u00a0failure", "labels": ["OpenZeppelin"]}, {"title": "The deploy function attempts to create a contract based on user-provided parameters and checks whether contract creation was successful by checking whether the output of create2 is a non-zero address. If the wallet contract doesn\u2019t have enough balance to fund the newly created contract with the amount specified in the _value parameter, the transaction will revert with the obscure \u201cContract creation failed.\u201d error message issued by the non-zero address check.", "body": "The deploy function attempts to create a contract based on user-provided parameters and checks whether contract creation was successful by checking whether the output of create2 is a non-zero address. If the wallet contract doesn\u2019t have enough balance to fund the newly created contract with the amount specified in the _value parameter, the transaction will revert with the obscure \u201cContract creation failed.\u201d error message issued by the non-zero address check.", "html_url": "https://blog.openzeppelin.com/recoverable-wallet-audit#the-deploy-function-attempts-to-create-a-contract-based-on-user-provided-parameters-and-checks-whether-contract-creation-was-successful-by-checking-whether-the-output-of-create2-is-a-non-zero-address.-if-the-wallet-contract-doesn\u2019t-have-enough-balance-to-fund-the-newly-created-contract-with-the-amount-specified-in-the-_value-parameter,-the-transaction-will-revert-with-the-obscure-\u201ccontract-creation-failed.\u201d-error-message-issued-by-the-non-zero-address-check.", "labels": ["OpenZeppelin"]}, {"title": "Consider splitting this into two checks. First, we suggest adding a require statement to the beginning of the deploy function that checks whether the RecoverableWallet contract has a balance of at least _value ETH, and returns a meaningful error message otherwise. Second, rather than checking that the output of create2 is a non-zero address, we recommend the more stringent requirement that code actually exists at the address returned by the call to create2 using extcodesize.", "body": "Consider splitting this into two checks. First, we suggest adding a require statement to the beginning of the deploy function that checks whether the RecoverableWallet contract has a balance of at least _value ETH, and returns a meaningful error message otherwise. Second, rather than checking that the output of create2 is a non-zero address, we recommend the more stringent requirement that code actually exists at the address returned by the call to create2 using extcodesize.", "html_url": "https://blog.openzeppelin.com/recoverable-wallet-audit#consider-splitting-this-into-two-checks.-first,-we-suggest-adding-a-require-statement-to-the-beginning-of-the-deploy-function-that-checks-whether-the-recoverablewallet-contract-has-a-balance-of-at-least-_value-eth,-and-returns-a-meaningful-error-message-otherwise.-second,-rather-than-checking-that-the-output-of-create2-is-a-non-zero-address,-we-recommend-the-more-stringent-requirement-that-code-actually-exists-at-the-address-returned-by-the-call-to-create2-using-extcodesize.", "labels": ["OpenZeppelin"]}, {"title": "Update: The\u00a0deploy function has been modified to output more detailed messages in the event of a failed contract deployment. The\u00a0extcodesize option was not used because \u201ca valid create2 call may not result in any code actually being deployed at the destination address (e.g.,\u00a0self-destruct in constructor or deployment code returning an empty bytecode array)\u201d.", "body": "Update: The\u00a0deploy function has been modified to output more detailed messages in the event of a failed contract deployment. The\u00a0extcodesize option was not used because \u201ca valid create2 call may not result in any code actually being deployed at the destination address (e.g.,\u00a0self-destruct in constructor or deployment code returning an empty bytecode array)\u201d.", "html_url": "https://blog.openzeppelin.com/recoverable-wallet-audit#update:-the\u00a0deploy-function-has-been-modified-to-output-more-detailed-messages-in-the-event-of-a-failed-contract-deployment.-the\u00a0extcodesize-option-was-not-used-because-\u201ca-valid-create2-call-may-not-result-in-any-code-actually-being-deployed-at-the-destination-address-(e.g.,\u00a0self-destruct-in-constructor-or-deployment-code-returning-an-empty-bytecode-array)\u201d.", "labels": ["OpenZeppelin"]}, {"title": "Unnecessary setting of the active_recovery_end_time variable", "body": " are taken into consideration, the call to reset_recovery on line 80 is unnecessary since active_recovery_address and active_recovery_end_time will be set correctly when start_recovery is called. Consider removing this function call. Update: The call to reset_recovery has been removed from the constructor.  Duplicate code in the finish_recovery() function Line 119 duplicates the code in the only_during_recovery modifier, which is already being applied to the finish_recovery function. Consider removing this superfluous line. Update: The duplicate code has been removed from the finish_recovery function. False comment in the start_recovery() function The comment on line 103 states:  NOTE: the recovery address cannot change during recovery, so we can rely on this being != 0  The second half of the statement\u200a\u200athat we can rely on this being != 0 is true. However the first part of the statement\u200a\u200athat the recovery address cannot change during recovery is false. The function that contains the comment (the start_recovery function) is the means by which a recovery address can change during recovery. In particular, a recovery address can change during recovery when a recovery address with a higher priority than the current active_recovery_address calls the start_recovery function. Update: The comment has be updated to correctly reflect contract behavior.  Ownership transfer can be started while another is underway The start_ownership_transfer function (line 38) in the Ownable contract can be called when the pending_owner is NOT address(0) (that is, when an ownership transfer is already underway). This can result in two or more ownership_transfer_started events being emitted back-to-back, with no ownership_transfer_cancelled or ownership_transfer_finished events emitted in between. If this is not intended functionality, consider adding a require(pending_owner == address(0)) to the start_ownership_transfer function to prevent this. Update: The start_ownership_transfer function (since renamed to startOwnershipTransfer) has been modified to first call the cancelOwnershipTransfer function before beginning a new ownership transfer. This ensures that the correct sequence of events is emitted. Ownership transfer can be cancelled before one is underway The cancel_ownership_transfer function (line 44) in the Ownable contract can be called when the pending_owner is address(0) (that is, when an ownership transfer is not already underway). This can result in an ownership_transfer_cancelled event being emitted without a corresponding ownership_transfer_started event having been emitted. If this is not intended functionality, consider adding a require(pending_owner != address(0)) to the cancel_ownership_transfer function to prevent this. Update: A require statement has been included that prevents the function from being called when no ownership transfer is underway. Overloaded functionality of the start_recovery() function The start_recovery function provides two functionalities. One is to allow a recovery address to initiate the recovery process when no recovery is underway. The other is to allow a recovery address with higher priority to usurp the current active_recovery_address when a recovery is already underway. These differing intentions both leverage the same function and both emit the same events. Consider disentangling these two functionalities by breaking the existing start_recovery function into two separate functions: a startRecovery function with the only_outside_recovery modifier that provides the first functionality, and a usurpRecovery function with the only_during_recovery modifier that provides the second functionality. Update: The start_recovery function is still being used to both begin a new recovery and usurp an existing one, but it has been modified so that a RecoveryCancelled event is emitted when usurping. This ensures that the correct events are emitted in the order.  Notes & Additional Information  The recovery_cancelled event (line 62) accepts no parameters. This may make recovery_cancelled events harder to track or interpret. Consider adding a parameter to this event.Update: A parameter has been added to this event. The start_ownership_transfer function can be called with the current owner passed as the _pending_owner. Similarly, the current owner can be added as a recovery address and so also may become the pending_owner by way of completing the recovery process. If this is undesirable behavior, consider adding require statements in the start_ownership_transfer and start_recovery functions to prevent this.Update: This is intended behavior. For all variables that store time values, consider changing their variable names to include the units of time they encode. For example, consider naming _proposed_recovery_delay to _proposedRecoveryDelayDays. Additionally, to make the code less error-prone during future changes, consider using only seconds throughout the code and using days only in the function interface.Update: Variables in units of days had their names changed to reflect this, but activeRecoveryEndTime is in units of seconds and its name still does not reflect it. On line 3 and line 9, consider renaming Erc1820Registry to ERC1820Registry. Following the Solidity Style Guide can improve code readability. For example, consider naming events using the CapWords style, naming functions and modifiers with the mixedCase style, keeping to a maximum line length of 79 (or 99) characters, etc.Update: Several changes were made to bring the code closer inline with the Solidity style guide.  The code active_recovery_address != address(0) is used in several places. Consider moving it to an internal view function, _inRecovery(), and referencing it on line 70, line 75, line 101, and line 119. If applying the suggestion from the issue Duplicate code in the finish_recovery() function and also splitting the current start_recovery function into two functions, then this recommendation will not provide any benefit. To improve readability/understandability, consider adding NatSpec documentation throughout the code.Update: NatSpec documentation was added throughout the code. Consider adding a comment above the exists function in the RecoverableWalletFactory contract to explain its purpose.Update: A comment was added above the exists function explaining its purpose. Two or more owners of recovery addresses with the same priority may find themselves in a race to be the first to call start_recovery.Update: This is intended functionality. We observed that it is not easy for the owner to unilaterally relinquish ownership of the wallet. The owner may offer ownership to another address, but that other address must actively accept the offer in order for ownership to transfer. It is possible, however, for the owner to provably relinquish control of the wallet by (1) failing to add any recovery addresses and (2) transferring ownership to a contract that calls accept_ownership() but provides no other functionality.Update: This is intended functionality. The function add_recovery_address will accept address(0) as a _new_recovery_address. This can result in recovery_delays[address(0)] > 0 and a recovery_address_added event being emitted with address(0). This is benign, but one may consider adding a require statement to add_recovery_address to prevent this.Update: A require statement has been added to prevent passing address(0) as the _new_recovery_address.  Conclusion No critical or high severity issues were found. Some changes were proposed to follow best practices, reduce the potential attack surface, and comply with the ERC1820 specification.        Note that as of the date of publishing, the above review reflects the current understanding of known security patterns as they relate to the audited contracts. The above should not be construed as investment advice. For general information about smart contract security, check out our thoughts here.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/recoverable-wallet-audit#unnecessary-setting-of-the-active_recovery_end_time-variable", "labels": ["OpenZeppelin"]}, {"title": "The variable active_recovery_end_time is consumed only in the finish_recovery function (on line 120), which has the only_during_recovery modifier. The only_during_recovery modifier passes only when active_recovery_address\u00a0!= address(0). This occurs only after start_recovery has been called and before either cancel_recovery or finish_recovery has been called.", "body": "The variable active_recovery_end_time is consumed only in the finish_recovery function (on line 120), which has the only_during_recovery modifier. The only_during_recovery modifier passes only when active_recovery_address\u00a0!= address(0). This occurs only after start_recovery has been called and before either cancel_recovery or finish_recovery has been called.", "html_url": "https://blog.openzeppelin.com/recoverable-wallet-audit#the-variable-active_recovery_end_time-is-consumed-only-in-the-finish_recovery-function-(on-line-120),-which-has-the-only_during_recovery-modifier.-the-only_during_recovery-modifier-passes-only-when-active_recovery_address\u00a0!=-address(0).-this-occurs-only-after-start_recovery-has-been-called-and-before-either-cancel_recovery-or-finish_recovery-has-been-called.", "labels": ["OpenZeppelin"]}, {"title": "Since start_recovery sets active_recovery_end_time, there is no need to set active_recovery_end_time = uint256(-1) on line 67. Consider leaving the active_recovery_end_time variable uninitialized on line 67.", "body": "Since start_recovery sets active_recovery_end_time, there is no need to set active_recovery_end_time = uint256(-1) on line 67. Consider leaving the active_recovery_end_time variable uninitialized on line 67.", "html_url": "https://blog.openzeppelin.com/recoverable-wallet-audit#since-start_recovery-sets-active_recovery_end_time,-there-is-no-need-to-set-active_recovery_end_time-=-uint256(-1)-on-line-67.-consider-leaving-the-active_recovery_end_time-variable-uninitialized-on-line-67.", "labels": ["OpenZeppelin"]}, {"title": "For the same reason, it is unnecessary to set active_recovery_end_time = uint256(-1); in the reset_recovery function on line 146. Consider removing the code at line 146.", "body": "For the same reason, it is unnecessary to set active_recovery_end_time = uint256(-1); in the reset_recovery function on line 146. Consider removing the code at line 146.", "html_url": "https://blog.openzeppelin.com/recoverable-wallet-audit#for-the-same-reason,-it-is-unnecessary-to-set-active_recovery_end_time-=-uint256(-1);-in-the-reset_recovery-function-on-line-146.-consider-removing-the-code-at-line-146.", "labels": ["OpenZeppelin"]}, {"title": "Update: No changes have been made here. Setting active_recovery_end_time to uint256(-1) is intended to make code auditing and strict invariant checks easier.", "body": "Update: No changes have been made here. Setting active_recovery_end_time to uint256(-1) is intended to make code auditing and strict invariant checks easier.", "html_url": "https://blog.openzeppelin.com/recoverable-wallet-audit#update:-no-changes-have-been-made-here.-setting-active_recovery_end_time-to-uint256(-1)-is-intended-to-make-code-auditing-and-strict-invariant-checks-easier.", "labels": ["OpenZeppelin"]}, {"title": "Unnecessary call to reset_recovery() in constructor", "body": "Unnecessary call to reset_recovery() in constructor", "html_url": "https://blog.openzeppelin.com/recoverable-wallet-audit#unnecessary-call-to-reset_recovery()-in-constructor", "labels": ["OpenZeppelin"]}, {"title": "Whether or not the recommendations from the issue \u201cUnnecessary setting of the active_recovery_end_time variable\u201d are taken into consideration, the call to reset_recovery on line 80 is unnecessary since active_recovery_address and active_recovery_end_time will be set correctly when start_recovery is called. Consider removing this function call.", "body": "Whether or not the recommendations from the issue \u201cUnnecessary setting of the active_recovery_end_time variable\u201d are taken into consideration, the call to reset_recovery on line 80 is unnecessary since active_recovery_address and active_recovery_end_time will be set correctly when start_recovery is called. Consider removing this function call.", "html_url": "https://blog.openzeppelin.com/recoverable-wallet-audit#whether-or-not-the-recommendations-from-the-issue-\u201cunnecessary-setting-of-the-active_recovery_end_time-variable\u201d-are-taken-into-consideration,-the-call-to-reset_recovery-on-line-80-is-unnecessary-since-active_recovery_address-and-active_recovery_end_time-will-be-set-correctly-when-start_recovery-is-called.-consider-removing-this-function-call.", "labels": ["OpenZeppelin"]}, {"title": "Update: The call to\u00a0reset_recovery has been removed from the constructor.\u00a0", "body": "Update: The call to\u00a0reset_recovery has been removed from the constructor.\u00a0", "html_url": "https://blog.openzeppelin.com/recoverable-wallet-audit#update:-the-call-to\u00a0reset_recovery-has-been-removed-from-the-constructor.\u00a0", "labels": ["OpenZeppelin"]}, {"title": "Duplicate code in the finish_recovery() function", "body": " and also splitting the current start_recovery function into two functions, then this recommendation will not provide any benefit. To improve readability/understandability, consider adding NatSpec documentation throughout the code.Update: NatSpec documentation was added throughout the code. Consider adding a comment above the exists function in the RecoverableWalletFactory contract to explain its purpose.Update: A comment was added above the exists function explaining its purpose. Two or more owners of recovery addresses with the same priority may find themselves in a race to be the first to call start_recovery.Update: This is intended functionality. We observed that it is not easy for the owner to unilaterally relinquish ownership of the wallet. The owner may offer ownership to another address, but that other address must actively accept the offer in order for ownership to transfer. It is possible, however, for the owner to provably relinquish control of the wallet by (1) failing to add any recovery addresses and (2) transferring ownership to a contract that calls accept_ownership() but provides no other functionality.Update: This is intended functionality. The function add_recovery_address will accept address(0) as a _new_recovery_address. This can result in recovery_delays[address(0)] > 0 and a recovery_address_added event being emitted with address(0). This is benign, but one may consider adding a require statement to add_recovery_address to prevent this.Update: A require statement has been added to prevent passing address(0) as the _new_recovery_address.  Conclusion No critical or high severity issues were found. Some changes were proposed to follow best practices, reduce the potential attack surface, and comply with the ERC1820 specification.        Note that as of the date of publishing, the above review reflects the current understanding of known security patterns as they relate to the audited contracts. The above should not be construed as investment advice. For general information about smart contract security, check out our thoughts here.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/recoverable-wallet-audit#duplicate-code-in-the-finish_recovery()-function", "labels": ["OpenZeppelin"]}, {"title": "Line 119 duplicates the code in the only_during_recovery modifier, which is already being applied to the finish_recovery function. Consider removing this superfluous line.", "body": "Line 119 duplicates the code in the only_during_recovery modifier, which is already being applied to the finish_recovery function. Consider removing this superfluous line.", "html_url": "https://blog.openzeppelin.com/recoverable-wallet-audit#line-119-duplicates-the-code-in-the-only_during_recovery-modifier,-which-is-already-being-applied-to-the-finish_recovery-function.-consider-removing-this-superfluous-line.", "labels": ["OpenZeppelin"]}, {"title": "Update: The duplicate code has been removed from the finish_recovery function.", "body": "Update: The duplicate code has been removed from the finish_recovery function.", "html_url": "https://blog.openzeppelin.com/recoverable-wallet-audit#update:-the-duplicate-code-has-been-removed-from-the-finish_recovery-function.", "labels": ["OpenZeppelin"]}, {"title": "False comment in the start_recovery() function", "body": "False comment in the start_recovery() function", "html_url": "https://blog.openzeppelin.com/recoverable-wallet-audit#false-comment-in-the-start_recovery()-function", "labels": ["OpenZeppelin"]}, {"title": "The comment on line 103 states:", "body": "The comment on line 103 states:", "html_url": "https://blog.openzeppelin.com/recoverable-wallet-audit#the-comment-on-line-103-states:", "labels": ["OpenZeppelin"]}, {"title": "NOTE: the recovery address cannot change during recovery, so we can rely on this being\u00a0!= 0", "body": "NOTE: the recovery address cannot change during recovery, so we can rely on this being\u00a0!= 0", "html_url": "https://blog.openzeppelin.com/recoverable-wallet-audit#note:-the-recovery-address-cannot-change-during-recovery,-so-we-can-rely-on-this-being\u00a0!=-0", "labels": ["OpenZeppelin"]}, {"title": "The second half of the statement\u200a\u2014\u200athat \u201cwe can rely on this being\u00a0!= 0\u201d is true. However the first part of the statement\u200a\u2014\u200athat \u201cthe recovery address cannot change during recovery\u201d is false. The function that contains the comment (the start_recovery function) is the means by which a recovery address can change during recovery. In particular, a recovery address can change during recovery when a recovery address with a higher priority than the current active_recovery_address calls the start_recovery function.", "body": "The second half of the statement\u200a\u2014\u200athat \u201cwe can rely on this being\u00a0!= 0\u201d is true. However the first part of the statement\u200a\u2014\u200athat \u201cthe recovery address cannot change during recovery\u201d is false. The function that contains the comment (the start_recovery function) is the means by which a recovery address can change during recovery. In particular, a recovery address can change during recovery when a recovery address with a higher priority than the current active_recovery_address calls the start_recovery function.", "html_url": "https://blog.openzeppelin.com/recoverable-wallet-audit#the-second-half-of-the-statement\u200a\u2014\u200athat-\u201cwe-can-rely-on-this-being\u00a0!=-0\u201d-is-true.-however-the-first-part-of-the-statement\u200a\u2014\u200athat-\u201cthe-recovery-address-cannot-change-during-recovery\u201d-is-false.-the-function-that-contains-the-comment-(the-start_recovery-function)-is-the-means-by-which-a-recovery-address-can-change-during-recovery.-in-particular,-a-recovery-address-can-change-during-recovery-when-a-recovery-address-with-a-higher-priority-than-the-current-active_recovery_address-calls-the-start_recovery-function.", "labels": ["OpenZeppelin"]}, {"title": "Update: The comment has be updated to correctly reflect contract behavior.\u00a0", "body": "Update: The comment has be updated to correctly reflect contract behavior.\u00a0", "html_url": "https://blog.openzeppelin.com/recoverable-wallet-audit#update:-the-comment-has-be-updated-to-correctly-reflect-contract-behavior.\u00a0", "labels": ["OpenZeppelin"]}, {"title": "Ownership transfer can be started while another is\u00a0underway", "body": "Ownership transfer can be started while another is\u00a0underway", "html_url": "https://blog.openzeppelin.com/recoverable-wallet-audit#ownership-transfer-can-be-started-while-another-is\u00a0underway", "labels": ["OpenZeppelin"]}, {"title": "The start_ownership_transfer function (line 38) in the Ownable contract can be called when the pending_owner is NOT address(0) (that is, when an ownership transfer is already underway). This can result in two or more ownership_transfer_started events being emitted back-to-back, with no ownership_transfer_cancelled or ownership_transfer_finished events emitted in between.", "body": "The start_ownership_transfer function (line 38) in the Ownable contract can be called when the pending_owner is NOT address(0) (that is, when an ownership transfer is already underway). This can result in two or more ownership_transfer_started events being emitted back-to-back, with no ownership_transfer_cancelled or ownership_transfer_finished events emitted in between.", "html_url": "https://blog.openzeppelin.com/recoverable-wallet-audit#the-start_ownership_transfer-function-(line-38)-in-the-ownable-contract-can-be-called-when-the-pending_owner-is-not-address(0)-(that-is,-when-an-ownership-transfer-is-already-underway).-this-can-result-in-two-or-more-ownership_transfer_started-events-being-emitted-back-to-back,-with-no-ownership_transfer_cancelled-or-ownership_transfer_finished-events-emitted-in-between.", "labels": ["OpenZeppelin"]}, {"title": "If this is not intended functionality, consider adding a require(pending_owner == address(0)) to the start_ownership_transfer function to prevent this.", "body": "If this is not intended functionality, consider adding a require(pending_owner == address(0)) to the start_ownership_transfer function to prevent this.", "html_url": "https://blog.openzeppelin.com/recoverable-wallet-audit#if-this-is-not-intended-functionality,-consider-adding-a-require(pending_owner-==-address(0))-to-the-start_ownership_transfer-function-to-prevent-this.", "labels": ["OpenZeppelin"]}, {"title": "Update: The start_ownership_transfer function (since renamed to startOwnershipTransfer) has been modified to first call the cancelOwnershipTransfer function before beginning a new ownership transfer. This ensures that the correct sequence of events is emitted.", "body": "Update: The start_ownership_transfer function (since renamed to startOwnershipTransfer) has been modified to first call the cancelOwnershipTransfer function before beginning a new ownership transfer. This ensures that the correct sequence of events is emitted.", "html_url": "https://blog.openzeppelin.com/recoverable-wallet-audit#update:-the-start_ownership_transfer-function-(since-renamed-to-startownershiptransfer)-has-been-modified-to-first-call-the-cancelownershiptransfer-function-before-beginning-a-new-ownership-transfer.-this-ensures-that-the-correct-sequence-of-events-is-emitted.", "labels": ["OpenZeppelin"]}, {"title": "Ownership transfer can be cancelled before one is\u00a0underway", "body": "Ownership transfer can be cancelled before one is\u00a0underway", "html_url": "https://blog.openzeppelin.com/recoverable-wallet-audit#ownership-transfer-can-be-cancelled-before-one-is\u00a0underway", "labels": ["OpenZeppelin"]}, {"title": "The cancel_ownership_transfer function (line 44) in the Ownable contract can be called when the pending_owner is address(0) (that is, when an ownership transfer is not already underway). This can result in an ownership_transfer_cancelled event being emitted without a corresponding ownership_transfer_started event having been emitted.", "body": "The cancel_ownership_transfer function (line 44) in the Ownable contract can be called when the pending_owner is address(0) (that is, when an ownership transfer is not already underway). This can result in an ownership_transfer_cancelled event being emitted without a corresponding ownership_transfer_started event having been emitted.", "html_url": "https://blog.openzeppelin.com/recoverable-wallet-audit#the-cancel_ownership_transfer-function-(line-44)-in-the-ownable-contract-can-be-called-when-the-pending_owner-is-address(0)-(that-is,-when-an-ownership-transfer-is-not-already-underway).-this-can-result-in-an-ownership_transfer_cancelled-event-being-emitted-without-a-corresponding-ownership_transfer_started-event-having-been-emitted.", "labels": ["OpenZeppelin"]}, {"title": "If this is not intended functionality, consider adding a require(pending_owner\u00a0!= address(0)) to the cancel_ownership_transfer function to prevent this.", "body": "If this is not intended functionality, consider adding a require(pending_owner\u00a0!= address(0)) to the cancel_ownership_transfer function to prevent this.", "html_url": "https://blog.openzeppelin.com/recoverable-wallet-audit#if-this-is-not-intended-functionality,-consider-adding-a-require(pending_owner\u00a0!=-address(0))-to-the-cancel_ownership_transfer-function-to-prevent-this.", "labels": ["OpenZeppelin"]}, {"title": "Update: A require statement has been included that prevents the function from being called when no ownership transfer is underway.", "body": "Update: A require statement has been included that prevents the function from being called when no ownership transfer is underway.", "html_url": "https://blog.openzeppelin.com/recoverable-wallet-audit#update:-a-require-statement-has-been-included-that-prevents-the-function-from-being-called-when-no-ownership-transfer-is-underway.", "labels": ["OpenZeppelin"]}, {"title": "Overloaded functionality of the start_recovery() function", "body": "Overloaded functionality of the start_recovery() function", "html_url": "https://blog.openzeppelin.com/recoverable-wallet-audit#overloaded-functionality-of-the-start_recovery()-function", "labels": ["OpenZeppelin"]}, {"title": "The start_recovery function provides two functionalities. One is to allow a recovery address to initiate the recovery process when no recovery is underway. The other is to allow a recovery address with higher priority to usurp the current active_recovery_address when a recovery is already underway. These differing intentions both leverage the same function and both emit the same events.", "body": "The start_recovery function provides two functionalities. One is to allow a recovery address to initiate the recovery process when no recovery is underway. The other is to allow a recovery address with higher priority to usurp the current active_recovery_address when a recovery is already underway. These differing intentions both leverage the same function and both emit the same events.", "html_url": "https://blog.openzeppelin.com/recoverable-wallet-audit#the-start_recovery-function-provides-two-functionalities.-one-is-to-allow-a-recovery-address-to-initiate-the-recovery-process-when-no-recovery-is-underway.-the-other-is-to-allow-a-recovery-address-with-higher-priority-to-usurp-the-current-active_recovery_address-when-a-recovery-is-already-underway.-these-differing-intentions-both-leverage-the-same-function-and-both-emit-the-same-events.", "labels": ["OpenZeppelin"]}, {"title": "Consider disentangling these two functionalities by breaking the existing start_recovery function into two separate functions: a startRecovery function with the only_outside_recovery modifier that provides the first functionality, and a usurpRecovery function with the only_during_recovery modifier that provides the second functionality.", "body": "Consider disentangling these two functionalities by breaking the existing start_recovery function into two separate functions: a startRecovery function with the only_outside_recovery modifier that provides the first functionality, and a usurpRecovery function with the only_during_recovery modifier that provides the second functionality.", "html_url": "https://blog.openzeppelin.com/recoverable-wallet-audit#consider-disentangling-these-two-functionalities-by-breaking-the-existing-start_recovery-function-into-two-separate-functions:-a-startrecovery-function-with-the-only_outside_recovery-modifier-that-provides-the-first-functionality,-and-a-usurprecovery-function-with-the-only_during_recovery-modifier-that-provides-the-second-functionality.", "labels": ["OpenZeppelin"]}, {"title": "Update: The\u00a0start_recovery function is still being used to both begin a new recovery and usurp an existing one, but it has been modified so that a RecoveryCancelled event is emitted when usurping. This ensures that the correct events are emitted in the order.\u00a0", "body": "Update: The\u00a0start_recovery function is still being used to both begin a new recovery and usurp an existing one, but it has been modified so that a RecoveryCancelled event is emitted when usurping. This ensures that the correct events are emitted in the order.\u00a0", "html_url": "https://blog.openzeppelin.com/recoverable-wallet-audit#update:-the\u00a0start_recovery-function-is-still-being-used-to-both-begin-a-new-recovery-and-usurp-an-existing-one,-but-it-has-been-modified-so-that-a-recoverycancelled-event-is-emitted-when-usurping.-this-ensures-that-the-correct-events-are-emitted-in-the-order.\u00a0", "labels": ["OpenZeppelin"]}, {"title": "The recovery_cancelled event (line 62) accepts no parameters. This may make recovery_cancelled events harder to track or interpret. Consider adding a parameter to this event.Update: A parameter has been added to this event.", "body": "The recovery_cancelled event (line 62) accepts no parameters. This may make recovery_cancelled events harder to track or interpret. Consider adding a parameter to this event.Update: A parameter has been added to this event.", "html_url": "https://blog.openzeppelin.com/recoverable-wallet-audit#the-recovery_cancelled-event-(line-62)-accepts-no-parameters.-this-may-make-recovery_cancelled-events-harder-to-track-or-interpret.-consider-adding-a-parameter-to-this-event.update:-a-parameter-has-been-added-to-this-event.", "labels": ["OpenZeppelin"]}, {"title": "The start_ownership_transfer function can be called with the current owner passed as the _pending_owner. Similarly, the current owner can be added as a recovery address and so also may become the pending_owner by way of completing the recovery process. If this is undesirable behavior, consider adding require statements in the start_ownership_transfer and start_recovery functions to prevent this.Update: This is intended behavior.", "body": "The start_ownership_transfer function can be called with the current owner passed as the _pending_owner. Similarly, the current owner can be added as a recovery address and so also may become the pending_owner by way of completing the recovery process. If this is undesirable behavior, consider adding require statements in the start_ownership_transfer and start_recovery functions to prevent this.Update: This is intended behavior.", "html_url": "https://blog.openzeppelin.com/recoverable-wallet-audit#the-start_ownership_transfer-function-can-be-called-with-the-current-owner-passed-as-the-_pending_owner.-similarly,-the-current-owner-can-be-added-as-a-recovery-address-and-so-also-may-become-the-pending_owner-by-way-of-completing-the-recovery-process.-if-this-is-undesirable-behavior,-consider-adding-require-statements-in-the-start_ownership_transfer-and-start_recovery-functions-to-prevent-this.update:-this-is-intended-behavior.", "labels": ["OpenZeppelin"]}, {"title": "For all variables that store time values, consider changing their variable names to include the units of time they encode. For example, consider naming _proposed_recovery_delay to _proposedRecoveryDelayDays. Additionally, to make the code less error-prone during future changes, consider using only seconds throughout the code and using days only in the function interface.Update: Variables in units of days had their names changed to reflect this, but\u00a0activeRecoveryEndTime is in units of seconds and its name still does not reflect it.", "body": "For all variables that store time values, consider changing their variable names to include the units of time they encode. For example, consider naming _proposed_recovery_delay to _proposedRecoveryDelayDays. Additionally, to make the code less error-prone during future changes, consider using only seconds throughout the code and using days only in the function interface.Update: Variables in units of days had their names changed to reflect this, but\u00a0activeRecoveryEndTime is in units of seconds and its name still does not reflect it.", "html_url": "https://blog.openzeppelin.com/recoverable-wallet-audit#for-all-variables-that-store-time-values,-consider-changing-their-variable-names-to-include-the-units-of-time-they-encode.-for-example,-consider-naming-_proposed_recovery_delay-to-_proposedrecoverydelaydays.-additionally,-to-make-the-code-less-error-prone-during-future-changes,-consider-using-only-seconds-throughout-the-code-and-using-days-only-in-the-function-interface.update:-variables-in-units-of-days-had-their-names-changed-to-reflect-this,-but\u00a0activerecoveryendtime-is-in-units-of-seconds-and-its-name-still-does-not-reflect-it.", "labels": ["OpenZeppelin"]}, {"title": "On line 3 and line 9, consider renaming Erc1820Registry to ERC1820Registry.", "body": "On line 3 and line 9, consider renaming Erc1820Registry to ERC1820Registry.", "html_url": "https://blog.openzeppelin.com/recoverable-wallet-audit#on-line-3-and-line-9,-consider-renaming-erc1820registry-to-erc1820registry.", "labels": ["OpenZeppelin"]}, {"title": "Following the Solidity Style Guide can improve code readability. For example, consider naming events using the CapWords style, naming functions and modifiers with the mixedCase style, keeping to a maximum line length of 79 (or 99) characters, etc.Update: Several changes were made to bring the code closer inline with the Solidity style guide.\u00a0", "body": "Following the Solidity Style Guide can improve code readability. For example, consider naming events using the CapWords style, naming functions and modifiers with the mixedCase style, keeping to a maximum line length of 79 (or 99) characters, etc.Update: Several changes were made to bring the code closer inline with the Solidity style guide.\u00a0", "html_url": "https://blog.openzeppelin.com/recoverable-wallet-audit#following-the-solidity-style-guide-can-improve-code-readability.-for-example,-consider-naming-events-using-the-capwords-style,-naming-functions-and-modifiers-with-the-mixedcase-style,-keeping-to-a-maximum-line-length-of-79-(or-99)-characters,-etc.update:-several-changes-were-made-to-bring-the-code-closer-inline-with-the-solidity-style-guide.\u00a0", "labels": ["OpenZeppelin"]}, {"title": "The code active_recovery_address\u00a0!= address(0) is used in several places. Consider moving it to an internal view function, _inRecovery(), and referencing it on line 70, line 75, line 101, and line 119. If applying the suggestion from the issue \u201cDuplicate code in the finish_recovery() function\u201d and also splitting the current start_recovery function into two functions, then this recommendation will not provide any benefit.", "body": "The code active_recovery_address\u00a0!= address(0) is used in several places. Consider moving it to an internal view function, _inRecovery(), and referencing it on line 70, line 75, line 101, and line 119. If applying the suggestion from the issue \u201cDuplicate code in the finish_recovery() function\u201d and also splitting the current start_recovery function into two functions, then this recommendation will not provide any benefit.", "html_url": "https://blog.openzeppelin.com/recoverable-wallet-audit#the-code-active_recovery_address\u00a0!=-address(0)-is-used-in-several-places.-consider-moving-it-to-an-internal-view-function,-_inrecovery(),-and-referencing-it-on-line-70,-line-75,-line-101,-and-line-119.-if-applying-the-suggestion-from-the-issue-\u201cduplicate-code-in-the-finish_recovery()-function\u201d-and-also-splitting-the-current-start_recovery-function-into-two-functions,-then-this-recommendation-will-not-provide-any-benefit.", "labels": ["OpenZeppelin"]}, {"title": "To improve readability/understandability, consider adding NatSpec documentation throughout the code.Update: NatSpec documentation was added throughout the code.", "body": "To improve readability/understandability, consider adding NatSpec documentation throughout the code.Update: NatSpec documentation was added throughout the code.", "html_url": "https://blog.openzeppelin.com/recoverable-wallet-audit#to-improve-readability/understandability,-consider-adding-natspec-documentation-throughout-the-code.update:-natspec-documentation-was-added-throughout-the-code.", "labels": ["OpenZeppelin"]}, {"title": "Consider adding a comment above the exists function in the RecoverableWalletFactory contract to explain its purpose.Update: A comment was added above the\u00a0exists function explaining its purpose.", "body": "Consider adding a comment above the exists function in the RecoverableWalletFactory contract to explain its purpose.Update: A comment was added above the\u00a0exists function explaining its purpose.", "html_url": "https://blog.openzeppelin.com/recoverable-wallet-audit#consider-adding-a-comment-above-the-exists-function-in-the-recoverablewalletfactory-contract-to-explain-its-purpose.update:-a-comment-was-added-above-the\u00a0exists-function-explaining-its-purpose.", "labels": ["OpenZeppelin"]}, {"title": "Two or more owners of recovery addresses with the same priority may find themselves in a race to be the first to call start_recovery.Update: This is intended functionality.", "body": "Two or more owners of recovery addresses with the same priority may find themselves in a race to be the first to call start_recovery.Update: This is intended functionality.", "html_url": "https://blog.openzeppelin.com/recoverable-wallet-audit#two-or-more-owners-of-recovery-addresses-with-the-same-priority-may-find-themselves-in-a-race-to-be-the-first-to-call-start_recovery.update:-this-is-intended-functionality.", "labels": ["OpenZeppelin"]}, {"title": "We observed that it is not easy for the owner to unilaterally relinquish ownership of the wallet. The owner may offer ownership to another address, but that other address must actively accept the offer in order for ownership to transfer. It is possible, however, for the owner to provably relinquish control of the wallet by (1) failing to add any recovery addresses and (2) transferring ownership to a contract that calls accept_ownership() but provides no other functionality.Update: This is intended functionality.", "body": "We observed that it is not easy for the owner to unilaterally relinquish ownership of the wallet. The owner may offer ownership to another address, but that other address must actively accept the offer in order for ownership to transfer. It is possible, however, for the owner to provably relinquish control of the wallet by (1) failing to add any recovery addresses and (2) transferring ownership to a contract that calls accept_ownership() but provides no other functionality.Update: This is intended functionality.", "html_url": "https://blog.openzeppelin.com/recoverable-wallet-audit#we-observed-that-it-is-not-easy-for-the-owner-to-unilaterally-relinquish-ownership-of-the-wallet.-the-owner-may-offer-ownership-to-another-address,-but-that-other-address-must-actively-accept-the-offer-in-order-for-ownership-to-transfer.-it-is-possible,-however,-for-the-owner-to-provably-relinquish-control-of-the-wallet-by-(1)-failing-to-add-any-recovery-addresses-and-(2)-transferring-ownership-to-a-contract-that-calls-accept_ownership()-but-provides-no-other-functionality.update:-this-is-intended-functionality.", "labels": ["OpenZeppelin"]}, {"title": "The function add_recovery_address will accept address(0) as a _new_recovery_address. This can result in recovery_delays[address(0)] > 0 and a recovery_address_added event being emitted with address(0). This is benign, but one may consider adding a require statement to add_recovery_address to prevent this.Update: A require statement has been added to prevent passing address(0) as the _new_recovery_address.", "body": "The function add_recovery_address will accept address(0) as a _new_recovery_address. This can result in recovery_delays[address(0)] > 0 and a recovery_address_added event being emitted with address(0). This is benign, but one may consider adding a require statement to add_recovery_address to prevent this.Update: A require statement has been added to prevent passing address(0) as the _new_recovery_address.", "html_url": "https://blog.openzeppelin.com/recoverable-wallet-audit#the-function-add_recovery_address-will-accept-address(0)-as-a-_new_recovery_address.-this-can-result-in-recovery_delays[address(0)]->-0-and-a-recovery_address_added-event-being-emitted-with-address(0).-this-is-benign,-but-one-may-consider-adding-a-require-statement-to-add_recovery_address-to-prevent-this.update:-a-require-statement-has-been-added-to-prevent-passing-address(0)-as-the-_new_recovery_address.", "labels": ["OpenZeppelin"]}, {"title": "In the PropsTimeBasedTransfers contract, consider refactoring the functionality of the canTransfer function to a canTransfer modifier that includes a require statement, so as to avoid repeating code in both transfer and transferFrom functions.Update: canTransfer is now a modifier.", "body": "In the PropsTimeBasedTransfers contract, consider refactoring the functionality of the canTransfer function to a canTransfer modifier that includes a require statement, so as to avoid repeating code in both transfer and transferFrom functions.Update: canTransfer is now a modifier.", "html_url": "https://blog.openzeppelin.com/props-token-contracts-audit-2#in-the-propstimebasedtransfers-contract,-consider-refactoring-the-functionality-of-the-cantransfer-function-to-a-cantransfer-modifier-that-includes-a-require-statement,-so-as-to-avoid-repeating-code-in-both-transfer-and-transferfrom-functions.update:-cantransfer-is-now-a-modifier.", "labels": ["OpenZeppelin"]}, {"title": "It is recommended to always first inherit from the zos-lib/contracts/Initializable.sol contract when dealing with upgradeable contracts, so as to prevent any unexpected C3-linearization issues down the inheritance chain, as explained in Zeppelin\u2019s forum. This is a common practice applied throughout the openzeppelin-eth project (the official OpenZeppelin fork adapted to upgradeable contracts), as well as in the code examples at ZeppelinOS docs.The PropsToken correctly follows this practice, so consider explicitly adding the Initializable contract first in the inheritance chain in both PropsTimeBasedTransfers and PropsSidechainCompatible contracts as well.Update: The PropsTimeBasedTransfers contract now inherits first from Initializable. The PropsSidechainCompatible contract has been removed.", "body": "It is recommended to always first inherit from the zos-lib/contracts/Initializable.sol contract when dealing with upgradeable contracts, so as to prevent any unexpected C3-linearization issues down the inheritance chain, as explained in Zeppelin\u2019s forum. This is a common practice applied throughout the openzeppelin-eth project (the official OpenZeppelin fork adapted to upgradeable contracts), as well as in the code examples at ZeppelinOS docs.The PropsToken correctly follows this practice, so consider explicitly adding the Initializable contract first in the inheritance chain in both PropsTimeBasedTransfers and PropsSidechainCompatible contracts as well.Update: The PropsTimeBasedTransfers contract now inherits first from Initializable. The PropsSidechainCompatible contract has been removed.", "html_url": "https://blog.openzeppelin.com/props-token-contracts-audit-2#it-is-recommended-to-always-first-inherit-from-the-zos-lib/contracts/initializable.sol-contract-when-dealing-with-upgradeable-contracts,-so-as-to-prevent-any-unexpected-c3-linearization-issues-down-the-inheritance-chain,-as-explained-in-zeppelin\u2019s-forum.-this-is-a-common-practice-applied-throughout-the-openzeppelin-eth-project-(the-official-openzeppelin-fork-adapted-to-upgradeable-contracts),-as-well-as-in-the-code-examples-at-zeppelinos-docs.the-propstoken-correctly-follows-this-practice,-so-consider-explicitly-adding-the-initializable-contract-first-in-the-inheritance-chain-in-both-propstimebasedtransfers-and-propssidechaincompatible-contracts-as-well.update:-the-propstimebasedtransfers-contract-now-inherits-first-from-initializable.-the-propssidechaincompatible-contract-has-been-removed.", "labels": ["OpenZeppelin"]}, {"title": "In the PropsToken contract\u2019s initialize function, consider clearly stating the time units of the _transfersStartTime argument.Update: The comment of the initialize function now mentions that _transfersStartTime is a Unix timestamp.", "body": "In the PropsToken contract\u2019s initialize function, consider clearly stating the time units of the _transfersStartTime argument.Update: The comment of the initialize function now mentions that _transfersStartTime is a Unix timestamp.", "html_url": "https://blog.openzeppelin.com/props-token-contracts-audit-2#in-the-propstoken-contract\u2019s-initialize-function,-consider-clearly-stating-the-time-units-of-the-_transfersstarttime-argument.update:-the-comment-of-the-initialize-function-now-mentions-that-_transfersstarttime-is-a-unix-timestamp.", "labels": ["OpenZeppelin"]}, {"title": "The project\u2019s documentation refer to the token as \u201cPROPS token\u201d, while the name used in the contract\u2019s code is DEV_Token. Consider modifying the hardcoded name before deploying the token to a public network so as to avoid confusion in users.Update: The name of the token is now \u201cProps Token\u201d and the symbol \u201cPROPS\u201d.", "body": "The project\u2019s documentation refer to the token as \u201cPROPS token\u201d, while the name used in the contract\u2019s code is DEV_Token. Consider modifying the hardcoded name before deploying the token to a public network so as to avoid confusion in users.Update: The name of the token is now \u201cProps Token\u201d and the symbol \u201cPROPS\u201d.", "html_url": "https://blog.openzeppelin.com/props-token-contracts-audit-2#the-project\u2019s-documentation-refer-to-the-token-as-\u201cprops-token\u201d,-while-the-name-used-in-the-contract\u2019s-code-is-dev_token.-consider-modifying-the-hardcoded-name-before-deploying-the-token-to-a-public-network-so-as-to-avoid-confusion-in-users.update:-the-name-of-the-token-is-now-\u201cprops-token\u201d-and-the-symbol-\u201cprops\u201d.", "labels": ["OpenZeppelin"]}, {"title": "To favor readability in the PropsToken contract, consider refactoring the token\u2019s total supply calculation to 6 * 1e8 * (10 ** uint256(decimals)), adding a short comment with the exact total supply number in a clearer format.Update: Comments about the decimals and supply have been added.", "body": "To favor readability in the PropsToken contract, consider refactoring the token\u2019s total supply calculation to 6 * 1e8 * (10 ** uint256(decimals)), adding a short comment with the exact total supply number in a clearer format.Update: Comments about the decimals and supply have been added.", "html_url": "https://blog.openzeppelin.com/props-token-contracts-audit-2#to-favor-readability-in-the-propstoken-contract,-consider-refactoring-the-token\u2019s-total-supply-calculation-to-6-*-1e8-*-(10-**-uint256(decimals)),-adding-a-short-comment-with-the-exact-total-supply-number-in-a-clearer-format.update:-comments-about-the-decimals-and-supply-have-been-added.", "labels": ["OpenZeppelin"]}, {"title": "The vesting schedule implemented in the TokenVesting contract is time-based (i.e. using block timestamps as opposed to e.g. block numbers), and is therefore sensitive to timestamp manipulation (something miners can do, to a certain degree). Therefore, it is recommended to avoid using a short time duration (less than a minute). Typical vesting schemes, such as those with a cliff period of a year and a duration of four years, are safe to use. While this does not pose a security issue per se, it is advisable to properly document this behavior and bear it in mind when defining the token\u2019s vesting scheme.Update: The TokenVesting contract has been removed. It is still used by distribution scripts, which are out of the scope of this audit.", "body": "The vesting schedule implemented in the TokenVesting contract is time-based (i.e. using block timestamps as opposed to e.g. block numbers), and is therefore sensitive to timestamp manipulation (something miners can do, to a certain degree). Therefore, it is recommended to avoid using a short time duration (less than a minute). Typical vesting schemes, such as those with a cliff period of a year and a duration of four years, are safe to use. While this does not pose a security issue per se, it is advisable to properly document this behavior and bear it in mind when defining the token\u2019s vesting scheme.Update: The TokenVesting contract has been removed. It is still used by distribution scripts, which are out of the scope of this audit.", "html_url": "https://blog.openzeppelin.com/props-token-contracts-audit-2#the-vesting-schedule-implemented-in-the-tokenvesting-contract-is-time-based-(i.e.-using-block-timestamps-as-opposed-to-e.g.-block-numbers),-and-is-therefore-sensitive-to-timestamp-manipulation-(something-miners-can-do,-to-a-certain-degree).-therefore,-it-is-recommended-to-avoid-using-a-short-time-duration-(less-than-a-minute).-typical-vesting-schemes,-such-as-those-with-a-cliff-period-of-a-year-and-a-duration-of-four-years,-are-safe-to-use.-while-this-does-not-pose-a-security-issue-per-se,-it-is-advisable-to-properly-document-this-behavior-and-bear-it-in-mind-when-defining-the-token\u2019s-vesting-scheme.update:-the-tokenvesting-contract-has-been-removed.-it-is-still-used-by-distribution-scripts,-which-are-out-of-the-scope-of-this-audit.", "labels": ["OpenZeppelin"]}, {"title": "To favor explicitness and readability, consider changing all instances of uint to uint256 (see for example ERC865Token: L159).Update: Some uint256 in PropsTimeBasedTransfers and PropsToken are still not declared explicitly.", "body": "To favor explicitness and readability, consider changing all instances of uint to uint256 (see for example ERC865Token: L159).Update: Some uint256 in PropsTimeBasedTransfers and PropsToken are still not declared explicitly.", "html_url": "https://blog.openzeppelin.com/props-token-contracts-audit-2#to-favor-explicitness-and-readability,-consider-changing-all-instances-of-uint-to-uint256-(see-for-example-erc865token:-l159).update:-some-uint256-in-propstimebasedtransfers-and-propstoken-are-still-not-declared-explicitly.", "labels": ["OpenZeppelin"]}, {"title": "The ERC865 interface may benefit from renaming to IERC865, so as to explicitly denote that it is an interface. Moreover, following good practices already applied in community-vetted frameworks, consider moving event definitions such as TransferPreSigned and ApprovalPreSigned from the implementation ERC865Token contract to the interface. These events will then be inherited by all implementations of the ERC865 interface.Update: The interface is now named IERC865. It now includes the definition of the events.", "body": "The ERC865 interface may benefit from renaming to IERC865, so as to explicitly denote that it is an interface. Moreover, following good practices already applied in community-vetted frameworks, consider moving event definitions such as TransferPreSigned and ApprovalPreSigned from the implementation ERC865Token contract to the interface. These events will then be inherited by all implementations of the ERC865 interface.Update: The interface is now named IERC865. It now includes the definition of the events.", "html_url": "https://blog.openzeppelin.com/props-token-contracts-audit-2#the-erc865-interface-may-benefit-from-renaming-to-ierc865,-so-as-to-explicitly-denote-that-it-is-an-interface.-moreover,-following-good-practices-already-applied-in-community-vetted-frameworks,-consider-moving-event-definitions-such-as-transferpresigned-and-approvalpresigned-from-the-implementation-erc865token-contract-to-the-interface.-these-events-will-then-be-inherited-by-all-implementations-of-the-erc865-interface.update:-the-interface-is-now-named-ierc865.-it-now-includes-the-definition-of-the-events.", "labels": ["OpenZeppelin"]}, {"title": "Although not strictly required, it is always advisable to follow interfaces proposed by most popular smart contract frameworks, which have become the de-facto standard supported by developers. As the OpenZeppelin\u2019s ERC20 contract from which the ERC865 contract inherits includes two functions increaseAllowance and decreaseAllowance, it would be sensible to rename both increaseApprovalPreSigned and decreaseApprovalPreSigned functions to increaseAllowancePreSigned and decreaseAllowancePreSigned respectively. Be aware that the suggested naming would not be aligned to the current state of the EIP 865, so make sure these changes are first applied in the EIP before modifying the interface (ERC865) and implementation (ERC865Token)\u00a0contracts.Update: The functions are now named increaseAllowancePreSigned and decreaseAllowancePreSigned.\u00a0Note that the renames have not been proposed to the EIP yet.", "body": "Although not strictly required, it is always advisable to follow interfaces proposed by most popular smart contract frameworks, which have become the de-facto standard supported by developers. As the OpenZeppelin\u2019s ERC20 contract from which the ERC865 contract inherits includes two functions increaseAllowance and decreaseAllowance, it would be sensible to rename both increaseApprovalPreSigned and decreaseApprovalPreSigned functions to increaseAllowancePreSigned and decreaseAllowancePreSigned respectively. Be aware that the suggested naming would not be aligned to the current state of the EIP 865, so make sure these changes are first applied in the EIP before modifying the interface (ERC865) and implementation (ERC865Token)\u00a0contracts.Update: The functions are now named increaseAllowancePreSigned and decreaseAllowancePreSigned.\u00a0Note that the renames have not been proposed to the EIP yet.", "html_url": "https://blog.openzeppelin.com/props-token-contracts-audit-2#although-not-strictly-required,-it-is-always-advisable-to-follow-interfaces-proposed-by-most-popular-smart-contract-frameworks,-which-have-become-the-de-facto-standard-supported-by-developers.-as-the-openzeppelin\u2019s-erc20-contract-from-which-the-erc865-contract-inherits-includes-two-functions-increaseallowance-and-decreaseallowance,-it-would-be-sensible-to-rename-both-increaseapprovalpresigned-and-decreaseapprovalpresigned-functions-to-increaseallowancepresigned-and-decreaseallowancepresigned-respectively.-be-aware-that-the-suggested-naming-would-not-be-aligned-to-the-current-state-of-the-eip-865,-so-make-sure-these-changes-are-first-applied-in-the-eip-before-modifying-the-interface-(erc865)-and-implementation-(erc865token)\u00a0contracts.update:-the-functions-are-now-named-increaseallowancepresigned-and-decreaseallowancepresigned.\u00a0note-that-the-renames-have-not-been-proposed-to-the-eip-yet.", "labels": ["OpenZeppelin"]}, {"title": "Several functions in the ERC865Token contract modify state variables after making token transfers. Although not entirely applicable in this case since no external calls are made, as a recommended coding practice, consider always modifying state variables before executing any transfer operation, following the Check-Effects-Interactions pattern.Update: state variables are now modified before the transfer operations. For example, see L91.", "body": "Several functions in the ERC865Token contract modify state variables after making token transfers. Although not entirely applicable in this case since no external calls are made, as a recommended coding practice, consider always modifying state variables before executing any transfer operation, following the Check-Effects-Interactions pattern.Update: state variables are now modified before the transfer operations. For example, see L91.", "html_url": "https://blog.openzeppelin.com/props-token-contracts-audit-2#several-functions-in-the-erc865token-contract-modify-state-variables-after-making-token-transfers.-although-not-entirely-applicable-in-this-case-since-no-external-calls-are-made,-as-a-recommended-coding-practice,-consider-always-modifying-state-variables-before-executing-any-transfer-operation,-following-the-check-effects-interactions-pattern.update:-state-variables-are-now-modified-before-the-transfer-operations.-for-example,-see-l91.", "labels": ["OpenZeppelin"]}, {"title": "To favor explicitness and readability, several functions in the ERC865Token contract may benefit from better naming. Our suggestions are:", "body": "To favor explicitness and readability, several functions in the ERC865Token contract may benefit from better naming. Our suggestions are:", "html_url": "https://blog.openzeppelin.com/props-token-contracts-audit-2#to-favor-explicitness-and-readability,-several-functions-in-the-erc865token-contract-may-benefit-from-better-naming.-our-suggestions-are:", "labels": ["OpenZeppelin"]}, {"title": "transferPreSignedHashing to getTransferPreSignedHash", "body": "transferPreSignedHashing to getTransferPreSignedHash", "html_url": "https://blog.openzeppelin.com/props-token-contracts-audit-2#transferpresignedhashing-to-gettransferpresignedhash", "labels": ["OpenZeppelin"]}, {"title": "transferFromPreSignedHashing to getTransferFromPreSignedHash", "body": "transferFromPreSignedHashing to getTransferFromPreSignedHash", "html_url": "https://blog.openzeppelin.com/props-token-contracts-audit-2#transferfrompresignedhashing-to-gettransferfrompresignedhash", "labels": ["OpenZeppelin"]}, {"title": "approvePreSignedHashing to getApprovePreSignedHash\u2013 increaseApprovalPreSignedHashing to getIncreaseApprovalPreSignedHash\u2013 decreaseApprovalPreSignedHashing to getDecreaseApprovalPreSignedHashConsider applying these modifications only after they are proposed and accepted in the EIP 865, so as to avoid rendering the current implemented interfaces non-compliant.Update: The functions have been renamed. Note that the renames have not been proposed to the EIP yet.", "body": "approvePreSignedHashing to getApprovePreSignedHash\u2013 increaseApprovalPreSignedHashing to getIncreaseApprovalPreSignedHash\u2013 decreaseApprovalPreSignedHashing to getDecreaseApprovalPreSignedHashConsider applying these modifications only after they are proposed and accepted in the EIP 865, so as to avoid rendering the current implemented interfaces non-compliant.Update: The functions have been renamed. Note that the renames have not been proposed to the EIP yet.", "html_url": "https://blog.openzeppelin.com/props-token-contracts-audit-2#approvepresignedhashing-to-getapprovepresignedhash\u2013-increaseapprovalpresignedhashing-to-getincreaseapprovalpresignedhash\u2013-decreaseapprovalpresignedhashing-to-getdecreaseapprovalpresignedhashconsider-applying-these-modifications-only-after-they-are-proposed-and-accepted-in-the-eip-865,-so-as-to-avoid-rendering-the-current-implemented-interfaces-non-compliant.update:-the-functions-have-been-renamed.-note-that-the-renames-have-not-been-proposed-to-the-eip-yet.", "labels": ["OpenZeppelin"]}, {"title": "Function parameters of transferFrom function in PropsTimeBasedTransfers contract and function transferFrom in PropsSidechainCompatible should be indented one extra level.Update: The PropsSidechainCompatible contract has been removed. The transferFrom function in PropsTimeBasedTransfers is now properly indented. However, note that now the require statements are not properly indented.", "body": "Function parameters of transferFrom function in PropsTimeBasedTransfers contract and function transferFrom in PropsSidechainCompatible should be indented one extra level.Update: The PropsSidechainCompatible contract has been removed. The transferFrom function in PropsTimeBasedTransfers is now properly indented. However, note that now the require statements are not properly indented.", "html_url": "https://blog.openzeppelin.com/props-token-contracts-audit-2#function-parameters-of-transferfrom-function-in-propstimebasedtransfers-contract-and-function-transferfrom-in-propssidechaincompatible-should-be-indented-one-extra-level.update:-the-propssidechaincompatible-contract-has-been-removed.-the-transferfrom-function-in-propstimebasedtransfers-is-now-properly-indented.-however,-note-that-now-the-require-statements-are-not-properly-indented.", "labels": ["OpenZeppelin"]}, {"title": "Consider always following Solidity\u2019s style guide, where it is suggested that functions\u2019 visibility modifiers should come before any custom modifiers. A recommended practice to help enforce coding style is the integration of a linter tool, such as Solhint, into the development process.", "body": "Consider always following Solidity\u2019s style guide, where it is suggested that functions\u2019 visibility modifiers should come before any custom modifiers. A recommended practice to help enforce coding style is the integration of a linter tool, such as Solhint, into the development process.", "html_url": "https://blog.openzeppelin.com/props-token-contracts-audit-2#consider-always-following-solidity\u2019s-style-guide,-where-it-is-suggested-that-functions\u2019-visibility-modifiers-should-come-before-any-custom-modifiers.-a-recommended-practice-to-help-enforce-coding-style-is-the-integration-of-a-linter-tool,-such-as-solhint,-into-the-development-process.", "labels": ["OpenZeppelin"]}, {"title": "In \u201ctruffle.js file, there are several different networks with the exact same parameters, such as: test0, test1, test2, testValidator, test, local. Additionally, the naming of the network called rinkebydev is misleading and may confuse developers, considering that it actually points to a localhost network.Update: The mentioned test networks have been removed, and rinkebydev has been renamed.", "body": "In \u201ctruffle.js file, there are several different networks with the exact same parameters, such as: test0, test1, test2, testValidator, test, local. Additionally, the naming of the network called rinkebydev is misleading and may confuse developers, considering that it actually points to a localhost network.Update: The mentioned test networks have been removed, and rinkebydev has been renamed.", "html_url": "https://blog.openzeppelin.com/props-token-contracts-audit-2#in-\u201ctruffle.js-file,-there-are-several-different-networks-with-the-exact-same-parameters,-such-as:-test0,-test1,-test2,-testvalidator,-test,-local.-additionally,-the-naming-of-the-network-called-rinkebydev-is-misleading-and-may-confuse-developers,-considering-that-it-actually-points-to-a-localhost-network.update:-the-mentioned-test-networks-have-been-removed,-and-rinkebydev-has-been-renamed.", "labels": ["OpenZeppelin"]}, {"title": "In \u201ctruffle.js file, there are absolute paths from a developer\u2019s machine where Infura\u2019s private key is stored. To prevent information disclosure and favor maintainability, consider removing these paths and instead use environment variables.Update: The paths have been removed.", "body": "In \u201ctruffle.js file, there are absolute paths from a developer\u2019s machine where Infura\u2019s private key is stored. To prevent information disclosure and favor maintainability, consider removing these paths and instead use environment variables.Update: The paths have been removed.", "html_url": "https://blog.openzeppelin.com/props-token-contracts-audit-2#in-\u201ctruffle.js-file,-there-are-absolute-paths-from-a-developer\u2019s-machine-where-infura\u2019s-private-key-is-stored.-to-prevent-information-disclosure-and-favor-maintainability,-consider-removing-these-paths-and-instead-use-environment-variables.update:-the-paths-have-been-removed.", "labels": ["OpenZeppelin"]}, {"title": "There is an unnecessary ZeppelinOS development configuration file called zos.dev-5777.json in the root directory of the repository that should be removed. Refer to ZeppelinOS docs on configuration files to learn more about which files are intended to be tracked in version control.Update: The ZeppelinOS development configuration file has been removed.", "body": "There is an unnecessary ZeppelinOS development configuration file called zos.dev-5777.json in the root directory of the repository that should be removed. Refer to ZeppelinOS docs on configuration files to learn more about which files are intended to be tracked in version control.Update: The ZeppelinOS development configuration file has been removed.", "html_url": "https://blog.openzeppelin.com/props-token-contracts-audit-2#there-is-an-unnecessary-zeppelinos-development-configuration-file-called-zos.dev-5777.json-in-the-root-directory-of-the-repository-that-should-be-removed.-refer-to-zeppelinos-docs-on-configuration-files-to-learn-more-about-which-files-are-intended-to-be-tracked-in-version-control.update:-the-zeppelinos-development-configuration-file-has-been-removed.", "labels": ["OpenZeppelin"]}, {"title": "web3 is currently included as a dependency in the package.json file as \"web3\": \"^1.0.0-beta.35\". Developers should be aware of issue #2266 introduced in web3 v1.0.0-beta.38, where custom providers are no longer accepted, which could introduce unexpected bugs in the project. Pinning the web3 dependency to a fixed version (e.g. \"web3\": \"1.0.0-beta.37\") is the recommended course of action, which other projects have already taken, until this issue is solved.Update: The web3 dependency is now pinned to 1.0.0-beta.35.", "body": "web3 is currently included as a dependency in the package.json file as \"web3\": \"^1.0.0-beta.35\". Developers should be aware of issue #2266 introduced in web3 v1.0.0-beta.38, where custom providers are no longer accepted, which could introduce unexpected bugs in the project. Pinning the web3 dependency to a fixed version (e.g. \"web3\": \"1.0.0-beta.37\") is the recommended course of action, which other projects have already taken, until this issue is solved.Update: The web3 dependency is now pinned to 1.0.0-beta.35.", "html_url": "https://blog.openzeppelin.com/props-token-contracts-audit-2#web3-is-currently-included-as-a-dependency-in-the-package.json-file-as-\"web3\":-\"^1.0.0-beta.35\".-developers-should-be-aware-of-issue-#2266-introduced-in-web3-v1.0.0-beta.38,-where-custom-providers-are-no-longer-accepted,-which-could-introduce-unexpected-bugs-in-the-project.-pinning-the-web3-dependency-to-a-fixed-version-(e.g.-\"web3\":-\"1.0.0-beta.37\")-is-the-recommended-course-of-action,-which-other-projects-have-already-taken,-until-this-issue-is-solved.update:-the-web3-dependency-is-now-pinned-to-1.0.0-beta.35.", "labels": ["OpenZeppelin"]}, {"title": "The package.json file includes a\u00a0fs dependency which should be removed, considering that the fs package in NPM is only a security holding package.Update: The fs dependency has been removed.", "body": "The package.json file includes a\u00a0fs dependency which should be removed, considering that the fs package in NPM is only a security holding package.Update: The fs dependency has been removed.", "html_url": "https://blog.openzeppelin.com/props-token-contracts-audit-2#the-package.json-file-includes-a\u00a0fs-dependency-which-should-be-removed,-considering-that-the-fs-package-in-npm-is-only-a-security-holding-package.update:-the-fs-dependency-has-been-removed.", "labels": ["OpenZeppelin"]}, {"title": "The dependency \"zeppelin-solidity\": \"^1.6.0\" that is included in the package.json file is deprecated and no longer maintained. To use OpenZeppelin up-to-date audited contracts, install the openzeppelin-solidity package.Update: The zeppelin-solidity dependency has been removed.", "body": "The dependency \"zeppelin-solidity\": \"^1.6.0\" that is included in the package.json file is deprecated and no longer maintained. To use OpenZeppelin up-to-date audited contracts, install the openzeppelin-solidity package.Update: The zeppelin-solidity dependency has been removed.", "html_url": "https://blog.openzeppelin.com/props-token-contracts-audit-2#the-dependency-\"zeppelin-solidity\":-\"^1.6.0\"-that-is-included-in-the-package.json-file-is-deprecated-and-no-longer-maintained.-to-use-openzeppelin-up-to-date-audited-contracts,-install-the-openzeppelin-solidity-package.update:-the-zeppelin-solidity-dependency-has-been-removed.", "labels": ["OpenZeppelin"]}, {"title": "None. \ud83d\ude42", "body": "None. \ud83d\ude42", "html_url": "https://blog.openzeppelin.com/compound-audit#none.-\ud83d\ude42", "labels": ["OpenZeppelin"]}, {"title": "Interest-Free Loans", "body": " issue).  Administrators list an ERC20 token with a later-discovered bug that allows minting of arbitrarily many tokens. This bad token is used as collateral to borrow funds that it never intends to repay.  In any case, the effects of an insolvent market could be disastrous. It would mean that cToken contracts would effectively be running a fractional reserve. This could result in a run on the bank, with the last suppliers out losing their money.  This risk is not unique to Compound. All collateralized loans (even non-blockchain loans) have a risk of insolvency. However, it is important to know that this risk does exist, and that it can be difficult to recover from even a small dip into insolvency.  Reserves Increased Event  The accrueInterest function of the CToken contract accrues interest and increases the reserves. However, the AccrueInterest event that it emits does not include the amount by which the reserves have increased. Consider adding this value to the AccrueInterest event or creating a new ReservesIncreased event to match the existing ReservesReduced event.  Multiple Contracts Per File  The ErrorReporter file contains three independent contracts: ComptrollerErrorReporter, TokenErrorReporter and OracleErrorReporter. This does not follow the Solidity style guide and makes the code harder to read.  Consider using a separate file for each contract.  Inconsistent NatSpec Usage  The docstrings of the contracts and functions are partially following the Ethereum Natural Specification Format (NatSpec). They use the tags sporadically. Consider adding the relevant missing tags to all contracts and functions.  Incorrect Code Comments  The comment on line 906 of Comptroller.sol uses the variable newLiquidationDiscount when it should use newLiquidationIncentive.  The comment on line 298 of CToken.sol states that the transferVerify function checks for under-collateralization. In fact, that check is performed at the start of the function with the transferAllowed hook.  The comment on line 821 of CToken.sol states that redeemAmountIn is the amount of cTokens to redeem but it is the amount of underlying.  The comments on line 821-822 of CToken.sol state that only one of redeemTokensIn or redeemAmountIn may be zero but in fact at least one must be zero and both may be zero.  The comment on line 322 of Comptroller.sol should state Require tokens is non-zero or amount is also zero  Consider updating the comments appropriately.  Require Statement Without Error Message  There is a require statement on line 111 of CEther.sol with no failure message. Consider adding a message to inform users in case of a revert.  Non-traditional Use of ReentrancyGuard  The NatSpec documentation on ReentrancyGuard.sol states:  If you mark a function nonReentrant, you should also mark it external.  However, the following functions in CToken.sol have the nonReentrant modifier and are NOT external:  exchangeRateCurrent (public)  mintInternal (internal)  redeemInternal (internal)  redeemUnderlyingInternal (internal)  borrowInternal (internal)  repayBorrowInternal (internal)  repayBorrowBehalfInternal (internal)  liquidateBorrowInternal (internal)  Typically, the nonReentrant modifier would be put on their external function counterparts in CEther.sol and CErc20.sol. That said, the existing use of ReentrancyGuard does prevent reentry into the corresponding external functions, and so no changes are needed.  Unvetted Token Warning  It is important to note that if a malicious or poorly-designed token is added to Compound, it could allow someone to steal all funds entrusted to Compound. For example, if anyone can arbitrarily change the totalSupply or account balances of a listed ERC20 token faster than the price oracle can adjust the price, an attacker could use those newly minted tokens as collateral to borrow all Compound assets.  Consider making a formal list of properties that a safe token should and should not have, and be sure each new token is safe before listing it on Compound.  Transparent Proxy Pattern  The Unitroller contract uses a proxy pattern to redirect transactions to functions it does not recognize. However, it will not be able to proxy calls to functions with the same function signature as one of its own functions, including its inherited functions.  Consider using the transparent proxy pattern for increased generality.  Unused Return Value  The getUtilizationAndAnnualBorrowRate function of the WhitePaperInterestRateModel contract returns the utilization rate in addition to the borrow rate. However, the only function that calls it discards the utilization rate. Consider removing the utilization rate from the return values.  collateralFactorMantissa Needs to be Set  In Comptroller.sol, collateralFactorMantissa for each market is initialized implicitly to 0 until it is set within _setCollateralFactor. This means that whenever a new market is created, a second transaction must be submitted to set the collateral factor. If this doesnt happen, account liquidity contributions for that market will be 0.  Consider Adding Syntax Highlighting to GitHub Repository  Consider adding Solidity syntax highlighting to the GitHub repository by putting the line *.sol linguist-language=Solidity in a .gitattributes file in the root of the repository.  This helps improve readability for users inspecting contract code on GitHub.  Accrue Zero Interest Event  In the accrueInterest function of CToken, the AccrueInterest event is still emitted when there is no interest (because it was already accrued in this block). Consider checking the accrualBlockNumber before emitting the event (or indeed, executing the rest of the function).  Unexpected ERC20s  Within each of the cToken ERC20 contracts, there is no way to check for unexpected sends of ERC20 tokens to the contract. However, the ERC20 balance is used in the exchangeRate calculation via the variable totalCash, which is equal to the ERC20 token balance.  This results in cToken values increasing with ERC20 sends, but importantly, it does not result in the value of borrows increasing, as borrowIndex is unaffected by total underlying balance.  Consider adding a state variable to track internal balances, which would help identify any unexpected ERC20 tokens.  Avoid Overloaded Functions  Within Exponential.sol there are two definitions for mulExp() (here, and here). Consider changing the name of one of the functions for improved readability of code.  Use ABI Encoder  The requireNoError function in the CEther contract appends a string to another string one byte at a time. Consider commenting the operation for clarity and using abi.encodePacked for brevity.  Missing require  sanity check in the  Default Visibility  The following state variables and constants are using the default visibility:  In Comptroller:closeFactorMinMantissa, closeFactorMaxMantissa, collateralFactorMaxMantissa, liquidationIncentiveMinMantissa, liquidationIncentiveMaxMantissa  In CToken:borrowRateMaxMantissa, reserveFactorMaxMantissa, accountTokens,transferAllowances, accountBorrows  In Exponential:expScale, halfExpScale, mantissaOne  For readability, consider explicitly declaring the visibility of all state variables.  TODOs in Code  Exponential,  Unitroller, and  1306,  1405,  1455,  1465 and  1525 ), despite being used in production.  Consider resolving and removing them.  Superfluous Code in acceptAdmin  On line 1333 of CToken.sol there is the conditional statement:  if (msg.sender != pendingAdmin || msg.sender == address(0)) ...  The comment immediately above this line is:  // Check caller is pendingAdmin and pendingAdmin \u2260 address(0)  This comment suggests that the conditional on line 1333 was intended to be:  if (msg.sender != pendingAdmin || pendingAdmin == address(0)) ...  In either case, however, the second half of the conditional is superfluous. It is infeasible for msg.sender to be the zero address. Thus, the conditional statement can be reduced to:  if (msg.sender != pendingAdmin) ....  Change uint to uint256  Throughout the code base, some variables are declared as uint. To favor explicitness, consider changing all instances of uint to uint256.  Use assert  The require statement on line 1476 of CToken.sol is confirming a property that should never fail for any user input. In such a situation, consider using an assert statement instead.  Conclusion  No critical and two high severity issues were found. Some changes were proposed to follow best practices and reduce potential attack surface.  Summary  If you are interested in a non-technical overview of this audit, we present a summary of the system as it relates to the audit as well as a couple of interesting findings in our summary article.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/compound-audit#interest-free-loans", "labels": ["OpenZeppelin"]}, {"title": "The CToken contract calculates the borrow balance of an account in the function borrowBalanceStoredInternal.", "body": "The CToken contract calculates the borrow balance of an account in the function borrowBalanceStoredInternal.", "html_url": "https://blog.openzeppelin.com/compound-audit#the-ctoken-contract-calculates-the-borrow-balance-of-an-account-in-the-function-borrowbalancestoredinternal.", "labels": ["OpenZeppelin"]}, {"title": "The balance is the principal scaled by the ratio of the borrow indices (which track the accumulative effect of per-block interest changes):", "body": "The balance is the principal scaled by the ratio of the borrow indices (which track the accumulative effect of per-block interest changes):", "html_url": "https://blog.openzeppelin.com/compound-audit#the-balance-is-the-principal-scaled-by-the-ratio-of-the-borrow-indices-(which-track-the-accumulative-effect-of-per-block-interest-changes):", "labels": ["OpenZeppelin"]}, {"title": "balance = principal * (current borrow index) / (original borrow index)", "body": "balance = principal * (current borrow index) / (original borrow index)", "html_url": "https://blog.openzeppelin.com/compound-audit#balance-=-principal-*-(current-borrow-index)-/-(original-borrow-index)", "labels": ["OpenZeppelin"]}, {"title": "However, when the principal and ratio of borrow indices are both small the result can equal the principal, due to automatic truncation of division within solidity.", "body": "However, when the principal and ratio of borrow indices are both small the result can equal the principal, due to automatic truncation of division within solidity.", "html_url": "https://blog.openzeppelin.com/compound-audit#however,-when-the-principal-and-ratio-of-borrow-indices-are-both-small-the-result-can-equal-the-principal,-due-to-automatic-truncation-of-division-within-solidity.", "labels": ["OpenZeppelin"]}, {"title": "This means that a loan could accrue no actual interest, yet still be factored into calculations of totalReserves, totalBorrows, and exchangeRates. In the case of many small loans being taken out, the associated interest calculated for that market may not match the amount actually received when users pay off those loans.", "body": "This means that a loan could accrue no actual interest, yet still be factored into calculations of totalReserves, totalBorrows, and exchangeRates. In the case of many small loans being taken out, the associated interest calculated for that market may not match the amount actually received when users pay off those loans.", "html_url": "https://blog.openzeppelin.com/compound-audit#this-means-that-a-loan-could-accrue-no-actual-interest,-yet-still-be-factored-into-calculations-of-totalreserves,-totalborrows,-and-exchangerates.-in-the-case-of-many-small-loans-being-taken-out,-the-associated-interest-calculated-for-that-market-may-not-match-the-amount-actually-received-when-users-pay-off-those-loans.", "labels": ["OpenZeppelin"]}, {"title": "In brief: it is possible for users to take out small, short-term, interest-free loans. Optionally, they can then resupply the borrowed assets back into Compound to receive interest.", "body": "In brief: it is possible for users to take out small, short-term, interest-free loans. Optionally, they can then resupply the borrowed assets back into Compound to receive interest.", "html_url": "https://blog.openzeppelin.com/compound-audit#in-brief:-it-is-possible-for-users-to-take-out-small,-short-term,-interest-free-loans.-optionally,-they-can-then-resupply-the-borrowed-assets-back-into-compound-to-receive-interest.", "labels": ["OpenZeppelin"]}, {"title": "An example attack works as follows:", "body": "An example attack works as follows:", "html_url": "https://blog.openzeppelin.com/compound-audit#an-example-attack-works-as-follows:", "labels": ["OpenZeppelin"]}, {"title": "The attacker takes out several interest-free loans. By the nature of this vulnerability, these loans must be small. However, the attacker can take out arbitrarily many of them. It is most effective if the attacker borrows an asset for which the value of this truncation error is greatest (currently, wBTC).", "body": "The attacker takes out several interest-free loans. By the nature of this vulnerability, these loans must be small. However, the attacker can take out arbitrarily many of them. It is most effective if the attacker borrows an asset for which the value of this truncation error is greatest (currently, wBTC).", "html_url": "https://blog.openzeppelin.com/compound-audit#the-attacker-takes-out-several-interest-free-loans.-by-the-nature-of-this-vulnerability,-these-loans-must-be-small.-however,-the-attacker-can-take-out-arbitrarily-many-of-them.-it-is-most-effective-if-the-attacker-borrows-an-asset-for-which-the-value-of-this-truncation-error-is-greatest-(currently,-wbtc).", "labels": ["OpenZeppelin"]}, {"title": "The attacker consolidates the small interest-free loans by sending all the borrowed assets to a single Ethereum account.", "body": "The attacker consolidates the small interest-free loans by sending all the borrowed assets to a single Ethereum account.", "html_url": "https://blog.openzeppelin.com/compound-audit#the-attacker-consolidates-the-small-interest-free-loans-by-sending-all-the-borrowed-assets-to-a-single-ethereum-account.", "labels": ["OpenZeppelin"]}, {"title": "(Optional) The attacker swaps the borrowed assets for an equal value of the highest-interest-rate asset on Compound (currently DAI).", "body": "(Optional) The attacker swaps the borrowed assets for an equal value of the highest-interest-rate asset on Compound (currently DAI).", "html_url": "https://blog.openzeppelin.com/compound-audit#(optional)-the-attacker-swaps-the-borrowed-assets-for-an-equal-value-of-the-highest-interest-rate-asset-on-compound-(currently-dai).", "labels": ["OpenZeppelin"]}, {"title": "The attacker deposits the asset into Compound.", "body": "The attacker deposits the asset into Compound.", "html_url": "https://blog.openzeppelin.com/compound-audit#the-attacker-deposits-the-asset-into-compound.", "labels": ["OpenZeppelin"]}, {"title": "(Optional) The attacker can then repeat the process \u2014 leveraging up \u2014 if they so desire.", "body": "(Optional) The attacker can then repeat the process \u2014 leveraging up \u2014 if they so desire.", "html_url": "https://blog.openzeppelin.com/compound-audit#(optional)-the-attacker-can-then-repeat-the-process-\u2014-leveraging-up-\u2014-if-they-so-desire.", "labels": ["OpenZeppelin"]}, {"title": "The attacker unwinds the trade and pays off all the small loans before the loans start \u201cregistering\u201d interest (that is, before the interest owed is no longer \u201ctruncated away\u201d). The result is that the attacker collects the supply-interest but does not have to pay the borrow-interest. Note that this is mathematically equivalent to the attacker simply stealing cash.", "body": "The attacker unwinds the trade and pays off all the small loans before the loans start \u201cregistering\u201d interest (that is, before the interest owed is no longer \u201ctruncated away\u201d). The result is that the attacker collects the supply-interest but does not have to pay the borrow-interest. Note that this is mathematically equivalent to the attacker simply stealing cash.", "html_url": "https://blog.openzeppelin.com/compound-audit#the-attacker-unwinds-the-trade-and-pays-off-all-the-small-loans-before-the-loans-start-\u201cregistering\u201d-interest-(that-is,-before-the-interest-owed-is-no-longer-\u201ctruncated-away\u201d).-the-result-is-that-the-attacker-collects-the-supply-interest-but-does-not-have-to-pay-the-borrow-interest.-note-that-this-is-mathematically-equivalent-to-the-attacker-simply-stealing-cash.", "labels": ["OpenZeppelin"]}, {"title": "Repeat.", "body": "Repeat.", "html_url": "https://blog.openzeppelin.com/compound-audit#repeat.", "labels": ["OpenZeppelin"]}, {"title": "There are a few practical considerations that make this attack non-trivial to pull off on the live network. These difficulties have to do with things unrelated to the Compound protocol: gas costs, slippage, and the unpredictable behavior of other Compound users. All of these can be overcome by certain classes of attackers, and we address them below.", "body": "There are a few practical considerations that make this attack non-trivial to pull off on the live network. These difficulties have to do with things unrelated to the Compound protocol: gas costs, slippage, and the unpredictable behavior of other Compound users. All of these can be overcome by certain classes of attackers, and we address them below.", "html_url": "https://blog.openzeppelin.com/compound-audit#there-are-a-few-practical-considerations-that-make-this-attack-non-trivial-to-pull-off-on-the-live-network.-these-difficulties-have-to-do-with-things-unrelated-to-the-compound-protocol:-gas-costs,-slippage,-and-the-unpredictable-behavior-of-other-compound-users.-all-of-these-can-be-overcome-by-certain-classes-of-attackers,-and-we-address-them-below.", "labels": ["OpenZeppelin"]}, {"title": "In practice, steps 1, 2, and 6 of this process would be gas-intensive. So much so that the attack would not be profitable if the attacker has to pay a normal gas price. However, if the attacker is a miner then their gas price is zero, and so this attack costs them nothing in gas. (An exception is if the blocks are full, in which case the attacking miner must pay the opportunity cost of not filling the block with normal, paying transactions). Note that the miner does not need much mining power to do this. The ability to mine a couple of blocks per week is technically sufficient \u2014 though the more mining power they have, the more money they can borrow with no interest, and the more likely they are to be able to unwind the trade in time.", "body": "In practice, steps 1, 2, and 6 of this process would be gas-intensive. So much so that the attack would not be profitable if the attacker has to pay a normal gas price. However, if the attacker is a miner then their gas price is zero, and so this attack costs them nothing in gas. (An exception is if the blocks are full, in which case the attacking miner must pay the opportunity cost of not filling the block with normal, paying transactions). Note that the miner does not need much mining power to do this. The ability to mine a couple of blocks per week is technically sufficient \u2014 though the more mining power they have, the more money they can borrow with no interest, and the more likely they are to be able to unwind the trade in time.", "html_url": "https://blog.openzeppelin.com/compound-audit#in-practice,-steps-1,-2,-and-6-of-this-process-would-be-gas-intensive.-so-much-so-that-the-attack-would-not-be-profitable-if-the-attacker-has-to-pay-a-normal-gas-price.-however,-if-the-attacker-is-a-miner-then-their-gas-price-is-zero,-and-so-this-attack-costs-them-nothing-in-gas.-(an-exception-is-if-the-blocks-are-full,-in-which-case-the-attacking-miner-must-pay-the-opportunity-cost-of-not-filling-the-block-with-normal,-paying-transactions).-note-that-the-miner-does-not-need-much-mining-power-to-do-this.-the-ability-to-mine-a-couple-of-blocks-per-week-is-technically-sufficient-\u2014-though-the-more-mining-power-they-have,-the-more-money-they-can-borrow-with-no-interest,-and-the-more-likely-they-are-to-be-able-to-unwind-the-trade-in-time.", "labels": ["OpenZeppelin"]}, {"title": "Additionally, if the attacker wants to get the most out of the attack, they\u2019ll likely want to perform the optional step 3. This requires that they exchange one asset for another on the open market. Here they may incur fees and/or slippage as they sell one asset for another. If fees and/or slippage are greater than the profit they make on their short-term, interest-free loan, then the attack is not profitable. This limits the attackers to those that can make trades very cheaply (or to those who are willing to forgo step 3 and accept a smaller rate of return).", "body": "Additionally, if the attacker wants to get the most out of the attack, they\u2019ll likely want to perform the optional step 3. This requires that they exchange one asset for another on the open market. Here they may incur fees and/or slippage as they sell one asset for another. If fees and/or slippage are greater than the profit they make on their short-term, interest-free loan, then the attack is not profitable. This limits the attackers to those that can make trades very cheaply (or to those who are willing to forgo step 3 and accept a smaller rate of return).", "html_url": "https://blog.openzeppelin.com/compound-audit#additionally,-if-the-attacker-wants-to-get-the-most-out-of-the-attack,-they\u2019ll-likely-want-to-perform-the-optional-step-3.-this-requires-that-they-exchange-one-asset-for-another-on-the-open-market.-here-they-may-incur-fees-and/or-slippage-as-they-sell-one-asset-for-another.-if-fees-and/or-slippage-are-greater-than-the-profit-they-make-on-their-short-term,-interest-free-loan,-then-the-attack-is-not-profitable.-this-limits-the-attackers-to-those-that-can-make-trades-very-cheaply-(or-to-those-who-are-willing-to-forgo-step-3-and-accept-a-smaller-rate-of-return).", "labels": ["OpenZeppelin"]}, {"title": "Finally, the attacker may be foiled if other users of Compound borrow more of the same asset the attacker did \u2014 thus driving the borrow interest rate up and causing the attacker\u2019s owed interest to unexpectedly rise above the level at which it would be \u201ctruncated away\u201d. An attacker has two ways to mitigate this risk. First, they can borrow smaller amounts to give themselves some \u201ccushion\u201d just in case the interest rate on their borrow rises. Second, they can choose to only go long on assets where they would be okay paying the interest anyway. That way, if the attack fails, they end up in the same position as anyone else going long on that asset \u2014 and if the attack succeeds, then they get the added bonus of not having to pay interest for the assets they used for leverage.", "body": "Finally, the attacker may be foiled if other users of Compound borrow more of the same asset the attacker did \u2014 thus driving the borrow interest rate up and causing the attacker\u2019s owed interest to unexpectedly rise above the level at which it would be \u201ctruncated away\u201d. An attacker has two ways to mitigate this risk. First, they can borrow smaller amounts to give themselves some \u201ccushion\u201d just in case the interest rate on their borrow rises. Second, they can choose to only go long on assets where they would be okay paying the interest anyway. That way, if the attack fails, they end up in the same position as anyone else going long on that asset \u2014 and if the attack succeeds, then they get the added bonus of not having to pay interest for the assets they used for leverage.", "html_url": "https://blog.openzeppelin.com/compound-audit#finally,-the-attacker-may-be-foiled-if-other-users-of-compound-borrow-more-of-the-same-asset-the-attacker-did-\u2014-thus-driving-the-borrow-interest-rate-up-and-causing-the-attacker\u2019s-owed-interest-to-unexpectedly-rise-above-the-level-at-which-it-would-be-\u201ctruncated-away\u201d.-an-attacker-has-two-ways-to-mitigate-this-risk.-first,-they-can-borrow-smaller-amounts-to-give-themselves-some-\u201ccushion\u201d-just-in-case-the-interest-rate-on-their-borrow-rises.-second,-they-can-choose-to-only-go-long-on-assets-where-they-would-be-okay-paying-the-interest-anyway.-that-way,-if-the-attack-fails,-they-end-up-in-the-same-position-as-anyone-else-going-long-on-that-asset-\u2014-and-if-the-attack-succeeds,-then-they-get-the-added-bonus-of-not-having-to-pay-interest-for-the-assets-they-used-for-leverage.", "labels": ["OpenZeppelin"]}, {"title": "In short, there exists unavoidable error when computing interest. However, there does exist a choice over who gets the benefit of that error. The error should always be handled in a way that benefits the cToken contract, not the borrower. The small rounding error in favor of the borrower (and at the expense of the cToken contract) can be scaled up to eventually steal arbitrarily large sums of money from the cToken contract.", "body": "In short, there exists unavoidable error when computing interest. However, there does exist a choice over who gets the benefit of that error. The error should always be handled in a way that benefits the cToken contract, not the borrower. The small rounding error in favor of the borrower (and at the expense of the cToken contract) can be scaled up to eventually steal arbitrarily large sums of money from the cToken contract.", "html_url": "https://blog.openzeppelin.com/compound-audit#in-short,-there-exists-unavoidable-error-when-computing-interest.-however,-there-does-exist-a-choice-over-who-gets-the-benefit-of-that-error.-the-error-should-always-be-handled-in-a-way-that-benefits-the-ctoken-contract,-not-the-borrower.-the-small-rounding-error-in-favor-of-the-borrower-(and-at-the-expense-of-the-ctoken-contract)-can-be-scaled-up-to-eventually-steal-arbitrarily-large-sums-of-money-from-the-ctoken-contract.", "labels": ["OpenZeppelin"]}, {"title": "Consider adjusting the code such that the calculated borrow balance is always rounded up instead of being truncated.", "body": "Consider adjusting the code such that the calculated borrow balance is always rounded up instead of being truncated.", "html_url": "https://blog.openzeppelin.com/compound-audit#consider-adjusting-the-code-such-that-the-calculated-borrow-balance-is-always-rounded-up-instead-of-being-truncated.", "labels": ["OpenZeppelin"]}, {"title": "Counterproductive Incentives", "body": "Counterproductive Incentives", "html_url": "https://blog.openzeppelin.com/compound-audit#counterproductive-incentives", "labels": ["OpenZeppelin"]}, {"title": "The protocol includes a mechanism to incentivize arbitrageurs to repay loans that are under-collateralized. This should increase the borrower\u2019s liquidity, reducing the risk of insolvency. After all, that is the point of the mechanism. However, there is a threshold where the incentives reverse and the liquidation mechanism actually pushes borrowers towards insolvency.", "body": "The protocol includes a mechanism to incentivize arbitrageurs to repay loans that are under-collateralized. This should increase the borrower\u2019s liquidity, reducing the risk of insolvency. After all, that is the point of the mechanism. However, there is a threshold where the incentives reverse and the liquidation mechanism actually pushes borrowers towards insolvency.", "html_url": "https://blog.openzeppelin.com/compound-audit#the-protocol-includes-a-mechanism-to-incentivize-arbitrageurs-to-repay-loans-that-are-under-collateralized.-this-should-increase-the-borrower\u2019s-liquidity,-reducing-the-risk-of-insolvency.-after-all,-that-is-the-point-of-the-mechanism.-however,-there-is-a-threshold-where-the-incentives-reverse-and-the-liquidation-mechanism-actually-pushes-borrowers-towards-insolvency.", "labels": ["OpenZeppelin"]}, {"title": "Consider a borrower with cTokens in various markets worth a total of C, and total debt worth D. They are located at point (D, C) in the following diagram:", "body": "Consider a borrower with cTokens in various markets worth a total of C, and total debt worth D. They are located at point (D, C) in the following diagram:", "html_url": "https://blog.openzeppelin.com/compound-audit#consider-a-borrower-with-ctokens-in-various-markets-worth-a-total-of-c,-and-total-debt-worth-d.-they-are-located-at-point-(d,-c)-in-the-following-diagram:", "labels": ["OpenZeppelin"]}, {"title": "After accounting for the distribution of cTokens and their corresponding collateral factors (the fraction of cTokens that can be used as collateral in each market), we can assign them an effective collateral ratio (ECR). The maximum possible value is 90%, which is labeled on the diagram. It corresponds to the minimum possible slope for remaining in the collateralized region, which is 1 / 90% = 1.11. With these values, we can describe the important regions:", "body": "After accounting for the distribution of cTokens and their corresponding collateral factors (the fraction of cTokens that can be used as collateral in each market), we can assign them an effective collateral ratio (ECR). The maximum possible value is 90%, which is labeled on the diagram. It corresponds to the minimum possible slope for remaining in the collateralized region, which is 1 / 90% = 1.11. With these values, we can describe the important regions:", "html_url": "https://blog.openzeppelin.com/compound-audit#after-accounting-for-the-distribution-of-ctokens-and-their-corresponding-collateral-factors-(the-fraction-of-ctokens-that-can-be-used-as-collateral-in-each-market),-we-can-assign-them-an-effective-collateral-ratio-(ecr).-the-maximum-possible-value-is-90%,-which-is-labeled-on-the-diagram.-it-corresponds-to-the-minimum-possible-slope-for-remaining-in-the-collateralized-region,-which-is-1-/-90%-=-1.11.-with-these-values,-we-can-describe-the-important-regions:", "labels": ["OpenZeppelin"]}, {"title": "Users in the green region above the ECR line are fully collateralized. They have enough collateral that even after reducing it by the ECR, it is still larger than their debt.", "body": "Users in the green region above the ECR line are fully collateralized. They have enough collateral that even after reducing it by the ECR, it is still larger than their debt.", "html_url": "https://blog.openzeppelin.com/compound-audit#users-in-the-green-region-above-the-ecr-line-are-fully-collateralized.-they-have-enough-collateral-that-even-after-reducing-it-by-the-ecr,-it-is-still-larger-than-their-debt.", "labels": ["OpenZeppelin"]}, {"title": "Users in the red region are insolvent. Their debt is larger than their collateral and they no longer have any incentive to repay it. Users in this region can be a major problem for the market because they continue accruing interest while removing liquidity from the market, ensuring at least some cToken holders will be unable to redeem their assets.", "body": "Users in the red region are insolvent. Their debt is larger than their collateral and they no longer have any incentive to repay it. Users in this region can be a major problem for the market because they continue accruing interest while removing liquidity from the market, ensuring at least some cToken holders will be unable to redeem their assets.", "html_url": "https://blog.openzeppelin.com/compound-audit#users-in-the-red-region-are-insolvent.-their-debt-is-larger-than-their-collateral-and-they-no-longer-have-any-incentive-to-repay-it.-users-in-this-region-can-be-a-major-problem-for-the-market-because-they-continue-accruing-interest-while-removing-liquidity-from-the-market,-ensuring-at-least-some-ctoken-holders-will-be-unable-to-redeem-their-assets.", "labels": ["OpenZeppelin"]}, {"title": "Users in the blue region are under-collateralized. They still have more assets than debt in the system, but the protocol deems them to be at risk of becoming insolvent.", "body": "Users in the blue region are under-collateralized. They still have more assets than debt in the system, but the protocol deems them to be at risk of becoming insolvent.", "html_url": "https://blog.openzeppelin.com/compound-audit#users-in-the-blue-region-are-under-collateralized.-they-still-have-more-assets-than-debt-in-the-system,-but-the-protocol-deems-them-to-be-at-risk-of-becoming-insolvent.", "labels": ["OpenZeppelin"]}, {"title": "When a borrower is under-collateralized, anyone can repay some of their debt in exchange for collateral at better-than-market rates. This mechanism is parameterized by two global values that are set by the administrator:", "body": "When a borrower is under-collateralized, anyone can repay some of their debt in exchange for collateral at better-than-market rates. This mechanism is parameterized by two global values that are set by the administrator:", "html_url": "https://blog.openzeppelin.com/compound-audit#when-a-borrower-is-under-collateralized,-anyone-can-repay-some-of-their-debt-in-exchange-for-collateral-at-better-than-market-rates.-this-mechanism-is-parameterized-by-two-global-values-that-are-set-by-the-administrator:", "labels": ["OpenZeppelin"]}, {"title": "the close factor: the maximum fraction of the original loan that can be liquidated", "body": "the close factor: the maximum fraction of the original loan that can be liquidated", "html_url": "https://blog.openzeppelin.com/compound-audit#the-close-factor:-the-maximum-fraction-of-the-original-loan-that-can-be-liquidated", "labels": ["OpenZeppelin"]}, {"title": "the liquidation incentive L: how much collateral do they receive (as a multiplier of the amount paid by the liquidator)", "body": "the liquidation incentive L: how much collateral do they receive (as a multiplier of the amount paid by the liquidator)", "html_url": "https://blog.openzeppelin.com/compound-audit#the-liquidation-incentive-l:-how-much-collateral-do-they-receive-(as-a-multiplier-of-the-amount-paid-by-the-liquidator)", "labels": ["OpenZeppelin"]}, {"title": "The Liquidation line on the diagram has slope L and passes through the origin. When an arbitrageur repays x debt, they receive x*L collateral from the borrower. In other words, they force the borrower to the bottom-left of the diagram on a trajectory parallel to the Liquidation line. The crucial observation is that this process can never cause a borrower to cross the liquidation line. Borrowers above the line are liquidated until they are fully collateralized, but borrowers below the line are actually pushed further towards insolvency by the liquidation process.", "body": "The Liquidation line on the diagram has slope L and passes through the origin. When an arbitrageur repays x debt, they receive x*L collateral from the borrower. In other words, they force the borrower to the bottom-left of the diagram on a trajectory parallel to the Liquidation line. The crucial observation is that this process can never cause a borrower to cross the liquidation line. Borrowers above the line are liquidated until they are fully collateralized, but borrowers below the line are actually pushed further towards insolvency by the liquidation process.", "html_url": "https://blog.openzeppelin.com/compound-audit#the-liquidation-line-on-the-diagram-has-slope-l-and-passes-through-the-origin.-when-an-arbitrageur-repays-x-debt,-they-receive-x*l-collateral-from-the-borrower.-in-other-words,-they-force-the-borrower-to-the-bottom-left-of-the-diagram-on-a-trajectory-parallel-to-the-liquidation-line.-the-crucial-observation-is-that-this-process-can-never-cause-a-borrower-to-cross-the-liquidation-line.-borrowers-above-the-line-are-liquidated-until-they-are-fully-collateralized,-but-borrowers-below-the-line-are-actually-pushed-further-towards-insolvency-by-the-liquidation-process.", "labels": ["OpenZeppelin"]}, {"title": "Ideally, they would already be liquidated before they crossed the threshold, but this would depend on various factors outside of the protocol, such as the speed of price changes, the liveness of the oracle, the congestion of Ethereum and the responsiveness and liquidity of arbitrageurs.", "body": "Ideally, they would already be liquidated before they crossed the threshold, but this would depend on various factors outside of the protocol, such as the speed of price changes, the liveness of the oracle, the congestion of Ethereum and the responsiveness and liquidity of arbitrageurs.", "html_url": "https://blog.openzeppelin.com/compound-audit#ideally,-they-would-already-be-liquidated-before-they-crossed-the-threshold,-but-this-would-depend-on-various-factors-outside-of-the-protocol,-such-as-the-speed-of-price-changes,-the-liveness-of-the-oracle,-the-congestion-of-ethereum-and-the-responsiveness-and-liquidity-of-arbitrageurs.", "labels": ["OpenZeppelin"]}, {"title": "The Compound system currently has a liquidation incentive of 1.05, which means that when a borrower\u2019s debt rises to at least 1 / 1.05 = 95.2% of the value of their cTokens, each liquidation will push them further towards insolvency. The maximum amount that they can be liquidated in one transaction is bounded by the close factor. The current close factor in the Compound system is 0.5, which means that when a borrower\u2019s debt rises to at least 97.6% of the value of their cTokens, it is possible for a liquidation to force them into insolvency.", "body": "The Compound system currently has a liquidation incentive of 1.05, which means that when a borrower\u2019s debt rises to at least 1 / 1.05 = 95.2% of the value of their cTokens, each liquidation will push them further towards insolvency. The maximum amount that they can be liquidated in one transaction is bounded by the close factor. The current close factor in the Compound system is 0.5, which means that when a borrower\u2019s debt rises to at least 97.6% of the value of their cTokens, it is possible for a liquidation to force them into insolvency.", "html_url": "https://blog.openzeppelin.com/compound-audit#the-compound-system-currently-has-a-liquidation-incentive-of-1.05,-which-means-that-when-a-borrower\u2019s-debt-rises-to-at-least-1-/-1.05-=-95.2%-of-the-value-of-their-ctokens,-each-liquidation-will-push-them-further-towards-insolvency.-the-maximum-amount-that-they-can-be-liquidated-in-one-transaction-is-bounded-by-the-close-factor.-the-current-close-factor-in-the-compound-system-is-0.5,-which-means-that-when-a-borrower\u2019s-debt-rises-to-at-least-97.6%-of-the-value-of-their-ctokens,-it-is-possible-for-a-liquidation-to-force-them-into-insolvency.", "labels": ["OpenZeppelin"]}, {"title": "Consider using a dynamic liquidation incentive that lowers as borrowers approach insolvency to ensure liquidations always increase solvency. Alternatively, consider treating the \u201cincentivized insolvency\u201d threshold of 95.2% as equivalent to insolvency, and choose the collateral factors and liquidation incentive accordingly.", "body": "Consider using a dynamic liquidation incentive that lowers as borrowers approach insolvency to ensure liquidations always increase solvency. Alternatively, consider treating the \u201cincentivized insolvency\u201d threshold of 95.2% as equivalent to insolvency, and choose the collateral factors and liquidation incentive accordingly.", "html_url": "https://blog.openzeppelin.com/compound-audit#consider-using-a-dynamic-liquidation-incentive-that-lowers-as-borrowers-approach-insolvency-to-ensure-liquidations-always-increase-solvency.-alternatively,-consider-treating-the-\u201cincentivized-insolvency\u201d-threshold-of-95.2%-as-equivalent-to-insolvency,-and-choose-the-collateral-factors-and-liquidation-incentive-accordingly.", "labels": ["OpenZeppelin"]}, {"title": "Interest May Not Compound", "body": "Interest May Not Compound", "html_url": "https://blog.openzeppelin.com/compound-audit#interest-may-not-compound", "labels": ["OpenZeppelin"]}, {"title": "When calculating interest in CToken.accrueInterest(), simple interest is applied over the blocks since the last update. This will underestimate the amount of interest that would be calculated if it were compounded every block.", "body": "When calculating interest in CToken.accrueInterest(), simple interest is applied over the blocks since the last update. This will underestimate the amount of interest that would be calculated if it were compounded every block.", "html_url": "https://blog.openzeppelin.com/compound-audit#when-calculating-interest-in-ctoken.accrueinterest(),-simple-interest-is-applied-over-the-blocks-since-the-last-update.-this-will-underestimate-the-amount-of-interest-that-would-be-calculated-if-it-were-compounded-every-block.", "labels": ["OpenZeppelin"]}, {"title": "The code is designed to accrue interest as frequently as possible, but this requirement expands the responsibility of accruing interest into otherwise unrelated functions. Additionally, the size of the discrepancy between the computed and theoretical interest will depend on the volume of transactions being handled by the Compound protocol, which may change unpredictably.", "body": "The code is designed to accrue interest as frequently as possible, but this requirement expands the responsibility of accruing interest into otherwise unrelated functions. Additionally, the size of the discrepancy between the computed and theoretical interest will depend on the volume of transactions being handled by the Compound protocol, which may change unpredictably.", "html_url": "https://blog.openzeppelin.com/compound-audit#the-code-is-designed-to-accrue-interest-as-frequently-as-possible,-but-this-requirement-expands-the-responsibility-of-accruing-interest-into-otherwise-unrelated-functions.-additionally,-the-size-of-the-discrepancy-between-the-computed-and-theoretical-interest-will-depend-on-the-volume-of-transactions-being-handled-by-the-compound-protocol,-which-may-change-unpredictably.", "labels": ["OpenZeppelin"]}, {"title": "To improve predictability and functional encapsulation, consider calculating interest with the compound interest formula, rather than simulating it through repeated transactions. Note that the additional gas requirements may be reduced using the modexp precompile. Separately, consider measuring the time between calls to accrueInterest() using seconds rather than blocks. This will help keep the interest rate calculation robust against changes to the average blocktime.", "body": "To improve predictability and functional encapsulation, consider calculating interest with the compound interest formula, rather than simulating it through repeated transactions. Note that the additional gas requirements may be reduced using the modexp precompile. Separately, consider measuring the time between calls to accrueInterest() using seconds rather than blocks. This will help keep the interest rate calculation robust against changes to the average blocktime.", "html_url": "https://blog.openzeppelin.com/compound-audit#to-improve-predictability-and-functional-encapsulation,-consider-calculating-interest-with-the-compound-interest-formula,-rather-than-simulating-it-through-repeated-transactions.-note-that-the-additional-gas-requirements-may-be-reduced-using-the-modexp-precompile.-separately,-consider-measuring-the-time-between-calls-to-accrueinterest()-using-seconds-rather-than-blocks.-this-will-help-keep-the-interest-rate-calculation-robust-against-changes-to-the-average-blocktime.", "labels": ["OpenZeppelin"]}, {"title": "Incorrect Whitepaper Interest Rate", "body": "Incorrect Whitepaper Interest Rate", "html_url": "https://blog.openzeppelin.com/compound-audit#incorrect-whitepaper-interest-rate", "labels": ["OpenZeppelin"]}, {"title": "The Compound Finance whitepaper states in section 2.3:", "body": "The Compound Finance whitepaper states in section 2.3:", "html_url": "https://blog.openzeppelin.com/compound-audit#the-compound-finance-whitepaper-states-in-section-2.3:", "labels": ["OpenZeppelin"]}, {"title": "The interest rate earned by suppliers is implicit, and is equal to the borrowing interest rate multiplied by the utilization rate.", "body": "The interest rate earned by suppliers is implicit, and is equal to the borrowing interest rate multiplied by the utilization rate.", "html_url": "https://blog.openzeppelin.com/compound-audit#the-interest-rate-earned-by-suppliers-is-implicit,-and-is-equal-to-the-borrowing-interest-rate-multiplied-by-the-utilization-rate.", "labels": ["OpenZeppelin"]}, {"title": "In fact, the supplyRatePerBlock function calculates it as the borrow interest rate multiplied by borrowsPer (which is not identical to the whitepaper utilization rate), and then multiplied again by (1 \u2013 the reserve factor). This is a related but not equivalent value to the specified one.", "body": "In fact, the supplyRatePerBlock function calculates it as the borrow interest rate multiplied by borrowsPer (which is not identical to the whitepaper utilization rate), and then multiplied again by (1 \u2013 the reserve factor). This is a related but not equivalent value to the specified one.", "html_url": "https://blog.openzeppelin.com/compound-audit#in-fact,-the-supplyrateperblock-function-calculates-it-as-the-borrow-interest-rate-multiplied-by-borrowsper-(which-is-not-identical-to-the-whitepaper-utilization-rate),-and-then-multiplied-again-by-(1-\u2013-the-reserve-factor).-this-is-a-related-but-not-equivalent-value-to-the-specified-one.", "labels": ["OpenZeppelin"]}, {"title": "Consider updating the whitepaper or the calculation for consistency.", "body": "Consider updating the whitepaper or the calculation for consistency.", "html_url": "https://blog.openzeppelin.com/compound-audit#consider-updating-the-whitepaper-or-the-calculation-for-consistency.", "labels": ["OpenZeppelin"]}, {"title": "Outdated Interest Rates", "body": "Outdated Interest Rates", "html_url": "https://blog.openzeppelin.com/compound-audit#outdated-interest-rates", "labels": ["OpenZeppelin"]}, {"title": "In the CToken contract, borrowRatePerBlock and supplyRatePerBlock are supposed to return the current rates but they may be outdated. This is because those rates depend on variables that are updated when accrueInterest is called. Consider calling accrueInterest at the beginning of these functions.", "body": "In the CToken contract, borrowRatePerBlock and supplyRatePerBlock are supposed to return the current rates but they may be outdated. This is because those rates depend on variables that are updated when accrueInterest is called. Consider calling accrueInterest at the beginning of these functions.", "html_url": "https://blog.openzeppelin.com/compound-audit#in-the-ctoken-contract,-borrowrateperblock-and-supplyrateperblock-are-supposed-to-return-the-current-rates-but-they-may-be-outdated.-this-is-because-those-rates-depend-on-variables-that-are-updated-when-accrueinterest-is-called.-consider-calling-accrueinterest-at-the-beginning-of-these-functions.", "labels": ["OpenZeppelin"]}, {"title": "Error Propagation", "body": "Error Propagation", "html_url": "https://blog.openzeppelin.com/compound-audit#error-propagation", "labels": ["OpenZeppelin"]}, {"title": "The codebase uses an error propagation mechanism that works as follows:", "body": "The codebase uses an error propagation mechanism that works as follows:", "html_url": "https://blog.openzeppelin.com/compound-audit#the-codebase-uses-an-error-propagation-mechanism-that-works-as-follows:", "labels": ["OpenZeppelin"]}, {"title": "A function that is supposed to return value X, instead returns a tuple (NO_ERROR, X)", "body": "A function that is supposed to return value X, instead returns a tuple (NO_ERROR, X)", "html_url": "https://blog.openzeppelin.com/compound-audit#a-function-that-is-supposed-to-return-value-x,-instead-returns-a-tuple-(no_error,-x)", "labels": ["OpenZeppelin"]}, {"title": "A function that would normally error out instead returns a tuple (ERROR_NAME, 0)", "body": "A function that would normally error out instead returns a tuple (ERROR_NAME, 0)", "html_url": "https://blog.openzeppelin.com/compound-audit#a-function-that-would-normally-error-out-instead-returns-a-tuple-(error_name,-0)", "labels": ["OpenZeppelin"]}, {"title": "Note that in both cases, the first return value is an error code (an enum type named Error)", "body": "Note that in both cases, the first return value is an error code (an enum type named Error)", "html_url": "https://blog.openzeppelin.com/compound-audit#note-that-in-both-cases,-the-first-return-value-is-an-error-code-(an-enum-type-named-error)", "labels": ["OpenZeppelin"]}, {"title": "Whenever a function returns an error, the calling function has to check it and then bubbles it up (ie. the caller returns the error tuple, possibly adding context to the error message)", "body": "Whenever a function returns an error, the calling function has to check it and then bubbles it up (ie. the caller returns the error tuple, possibly adding context to the error message)", "html_url": "https://blog.openzeppelin.com/compound-audit#whenever-a-function-returns-an-error,-the-calling-function-has-to-check-it-and-then-bubbles-it-up-(ie.-the-caller-returns-the-error-tuple,-possibly-adding-context-to-the-error-message)", "labels": ["OpenZeppelin"]}, {"title": "At the top level, the error/context codes are emitted in an event and then the error code is returned. The transaction is successful.", "body": "At the top level, the error/context codes are emitted in an event and then the error code is returned. The transaction is successful.", "html_url": "https://blog.openzeppelin.com/compound-audit#at-the-top-level,-the-error/context-codes-are-emitted-in-an-event-and-then-the-error-code-is-returned.-the-transaction-is-successful.", "labels": ["OpenZeppelin"]}, {"title": "The UI will need to convert the error codes into an error message", "body": "The UI will need to convert the error codes into an error message", "html_url": "https://blog.openzeppelin.com/compound-audit#the-ui-will-need-to-convert-the-error-codes-into-an-error-message", "labels": ["OpenZeppelin"]}, {"title": "This scheme has the benefit of providing useful failure messages when an operation fails. However, there are serious negative properties of this pattern which we discuss below.", "body": "This scheme has the benefit of providing useful failure messages when an operation fails. However, there are serious negative properties of this pattern which we discuss below.", "html_url": "https://blog.openzeppelin.com/compound-audit#this-scheme-has-the-benefit-of-providing-useful-failure-messages-when-an-operation-fails.-however,-there-are-serious-negative-properties-of-this-pattern-which-we-discuss-below.", "labels": ["OpenZeppelin"]}, {"title": "First, the error propagation scheme violates the \u201cFail Early and Loudly\u201d principle. Errors are not trapped when they are found. Callers have to remember to check and handle the returned error codes. Failure to do so can have serious security consequences.", "body": "First, the error propagation scheme violates the \u201cFail Early and Loudly\u201d principle. Errors are not trapped when they are found. Callers have to remember to check and handle the returned error codes. Failure to do so can have serious security consequences.", "html_url": "https://blog.openzeppelin.com/compound-audit#first,-the-error-propagation-scheme-violates-the-\u201cfail-early-and-loudly\u201d-principle.-errors-are-not-trapped-when-they-are-found.-callers-have-to-remember-to-check-and-handle-the-returned-error-codes.-failure-to-do-so-can-have-serious-security-consequences.", "labels": ["OpenZeppelin"]}, {"title": "The scheme also increases both the size and the complexity of the code base. We estimate that abandoning the current scheme in favor of the traditional require/assert/revert paradigm would reduce the size of the (Solidity) codebase by 40%-60%. This would, additionally, make the code itself easier to read and understand \u2014 which is an often overlooked but important property of secure code.", "body": "The scheme also increases both the size and the complexity of the code base. We estimate that abandoning the current scheme in favor of the traditional require/assert/revert paradigm would reduce the size of the (Solidity) codebase by 40%-60%. This would, additionally, make the code itself easier to read and understand \u2014 which is an often overlooked but important property of secure code.", "html_url": "https://blog.openzeppelin.com/compound-audit#the-scheme-also-increases-both-the-size-and-the-complexity-of-the-code-base.-we-estimate-that-abandoning-the-current-scheme-in-favor-of-the-traditional-require/assert/revert-paradigm-would-reduce-the-size-of-the-(solidity)-codebase-by-40%-60%.-this-would,-additionally,-make-the-code-itself-easier-to-read-and-understand-\u2014-which-is-an-often-overlooked-but-important-property-of-secure-code.", "labels": ["OpenZeppelin"]}, {"title": "The increased code complexity is not just a matter of cognitive overhead for those attempting to read/understand the code. It also results in very large increases in gas costs due to all the extra required opcodes. From the user\u2019s perspective, this is a strong argument against this pattern.", "body": "The increased code complexity is not just a matter of cognitive overhead for those attempting to read/understand the code. It also results in very large increases in gas costs due to all the extra required opcodes. From the user\u2019s perspective, this is a strong argument against this pattern.", "html_url": "https://blog.openzeppelin.com/compound-audit#the-increased-code-complexity-is-not-just-a-matter-of-cognitive-overhead-for-those-attempting-to-read/understand-the-code.-it-also-results-in-very-large-increases-in-gas-costs-due-to-all-the-extra-required-opcodes.-from-the-user\u2019s-perspective,-this-is-a-strong-argument-against-this-pattern.", "labels": ["OpenZeppelin"]}, {"title": "Implementation of the scheme makes it incompatible with battle-tested libraries (like SafeMath) and requires the use of custom math functions that reproduce the same functionality except that they return errors instead of throwing on failure.", "body": "Implementation of the scheme makes it incompatible with battle-tested libraries (like SafeMath) and requires the use of custom math functions that reproduce the same functionality except that they return errors instead of throwing on failure.", "html_url": "https://blog.openzeppelin.com/compound-audit#implementation-of-the-scheme-makes-it-incompatible-with-battle-tested-libraries-(like-safemath)-and-requires-the-use-of-custom-math-functions-that-reproduce-the-same-functionality-except-that-they-return-errors-instead-of-throwing-on-failure.", "labels": ["OpenZeppelin"]}, {"title": "The default value of an uninitialized Error enum is the Error.NO_ERROR value. This means that if a new Error variable is declared and returned by a function without having been set, the caller will assume that there was no error. That is, the default assumption by error handlers is that everything went according to plan. It would be safer to assume, by default, that things did not go according to plan unless verified otherwise. While this property is not inherent to this error-handling pattern, it is a feature of the particular implementation we audited.", "body": "The default value of an uninitialized Error enum is the Error.NO_ERROR value. This means that if a new Error variable is declared and returned by a function without having been set, the caller will assume that there was no error. That is, the default assumption by error handlers is that everything went according to plan. It would be safer to assume, by default, that things did not go according to plan unless verified otherwise. While this property is not inherent to this error-handling pattern, it is a feature of the particular implementation we audited.", "html_url": "https://blog.openzeppelin.com/compound-audit#the-default-value-of-an-uninitialized-error-enum-is-the-error.no_error-value.-this-means-that-if-a-new-error-variable-is-declared-and-returned-by-a-function-without-having-been-set,-the-caller-will-assume-that-there-was-no-error.-that-is,-the-default-assumption-by-error-handlers-is-that-everything-went-according-to-plan.-it-would-be-safer-to-assume,-by-default,-that-things-did-not-go-according-to-plan-unless-verified-otherwise.-while-this-property-is-not-inherent-to-this-error-handling-pattern,-it-is-a-feature-of-the-particular-implementation-we-audited.", "labels": ["OpenZeppelin"]}, {"title": "It does not cover every case, leading to inconsistencies within the code base. For example, the CEther mint function reverts on failure, whereas the CErc20 mint function returns an error code.", "body": "It does not cover every case, leading to inconsistencies within the code base. For example, the CEther mint function reverts on failure, whereas the CErc20 mint function returns an error code.", "html_url": "https://blog.openzeppelin.com/compound-audit#it-does-not-cover-every-case,-leading-to-inconsistencies-within-the-code-base.-for-example,-the-cether-mint-function-reverts-on-failure,-whereas-the-cerc20-mint-function-returns-an-error-code.", "labels": ["OpenZeppelin"]}, {"title": "Finally, lack of a revert on failure is counter to what most Ethereum users have come to expect. For instance, a failed call to CToken.transfer via MetaMask will result in a success message from MetaMask even though the transfer failed. While this may not technically violate the ERC20 standard, it is counter-intuitive and increases the probability of user error.", "body": "Finally, lack of a revert on failure is counter to what most Ethereum users have come to expect. For instance, a failed call to CToken.transfer via MetaMask will result in a success message from MetaMask even though the transfer failed. While this may not technically violate the ERC20 standard, it is counter-intuitive and increases the probability of user error.", "html_url": "https://blog.openzeppelin.com/compound-audit#finally,-lack-of-a-revert-on-failure-is-counter-to-what-most-ethereum-users-have-come-to-expect.-for-instance,-a-failed-call-to-ctoken.transfer-via-metamask-will-result-in-a-success-message-from-metamask-even-though-the-transfer-failed.-while-this-may-not-technically-violate-the-erc20-standard,-it-is-counter-intuitive-and-increases-the-probability-of-user-error.", "labels": ["OpenZeppelin"]}, {"title": "With all of that said, it appears that all errors are properly handled in the code we audited. If considering a refactor of the contracts at some point in the future, we strongly recommend moving away from this error propagation pattern and instead using off-chain tools to evaluate failed transactions in order to display meaningful error messages to users.", "body": "With all of that said, it appears that all errors are properly handled in the code we audited. If considering a refactor of the contracts at some point in the future, we strongly recommend moving away from this error propagation pattern and instead using off-chain tools to evaluate failed transactions in order to display meaningful error messages to users.", "html_url": "https://blog.openzeppelin.com/compound-audit#with-all-of-that-said,-it-appears-that-all-errors-are-properly-handled-in-the-code-we-audited.-if-considering-a-refactor-of-the-contracts-at-some-point-in-the-future,-we-strongly-recommend-moving-away-from-this-error-propagation-pattern-and-instead-using-off-chain-tools-to-evaluate-failed-transactions-in-order-to-display-meaningful-error-messages-to-users.", "labels": ["OpenZeppelin"]}, {"title": "Unknown Repayment Amount", "body": "Unknown Repayment Amount", "html_url": "https://blog.openzeppelin.com/compound-audit#unknown-repayment-amount", "labels": ["OpenZeppelin"]}, {"title": "To repay an ERC20 loan, a borrower can call repayBorrow or repayBorrowBehalf with a specified amount to repay.", "body": "To repay an ERC20 loan, a borrower can call repayBorrow or repayBorrowBehalf with a specified amount to repay.", "html_url": "https://blog.openzeppelin.com/compound-audit#to-repay-an-erc20-loan,-a-borrower-can-call-repayborrow-or-repayborrowbehalf-with-a-specified-amount-to-repay.", "labels": ["OpenZeppelin"]}, {"title": "However, they accrue interest in every block, which means if they specify the value of the loan at a particular block, their loan will be slightly higher in a future block when the transaction is confirmed and they will end up leaving part of the loan unpaid.", "body": "However, they accrue interest in every block, which means if they specify the value of the loan at a particular block, their loan will be slightly higher in a future block when the transaction is confirmed and they will end up leaving part of the loan unpaid.", "html_url": "https://blog.openzeppelin.com/compound-audit#however,-they-accrue-interest-in-every-block,-which-means-if-they-specify-the-value-of-the-loan-at-a-particular-block,-their-loan-will-be-slightly-higher-in-a-future-block-when-the-transaction-is-confirmed-and-they-will-end-up-leaving-part-of-the-loan-unpaid.", "labels": ["OpenZeppelin"]}, {"title": "On the other hand, they could set the repay amount to uint256(-1), which is used as a signal to mean \u201cpay the whole loan\u201d. This prevents the user from setting an upper bound on how much to pay. It is also particularly vulnerable in the case where an address is repaying on behalf of another address, since the borrower could front-run the transaction and borrow additional funds (up to the amount that the message sender has authorized the CToken contract to spend), which would also be repaid in the same transaction.", "body": "On the other hand, they could set the repay amount to uint256(-1), which is used as a signal to mean \u201cpay the whole loan\u201d. This prevents the user from setting an upper bound on how much to pay. It is also particularly vulnerable in the case where an address is repaying on behalf of another address, since the borrower could front-run the transaction and borrow additional funds (up to the amount that the message sender has authorized the CToken contract to spend), which would also be repaid in the same transaction.", "html_url": "https://blog.openzeppelin.com/compound-audit#on-the-other-hand,-they-could-set-the-repay-amount-to-uint256(-1),-which-is-used-as-a-signal-to-mean-\u201cpay-the-whole-loan\u201d.-this-prevents-the-user-from-setting-an-upper-bound-on-how-much-to-pay.-it-is-also-particularly-vulnerable-in-the-case-where-an-address-is-repaying-on-behalf-of-another-address,-since-the-borrower-could-front-run-the-transaction-and-borrow-additional-funds-(up-to-the-amount-that-the-message-sender-has-authorized-the-ctoken-contract-to-spend),-which-would-also-be-repaid-in-the-same-transaction.", "labels": ["OpenZeppelin"]}, {"title": "Consider treating the specified repayment amount as an upper bound, where the transaction repays the minimum of that value and the size of the loan.", "body": "Consider treating the specified repayment amount as an upper bound, where the transaction repays the minimum of that value and the size of the loan.", "html_url": "https://blog.openzeppelin.com/compound-audit#consider-treating-the-specified-repayment-amount-as-an-upper-bound,-where-the-transaction-repays-the-minimum-of-that-value-and-the-size-of-the-loan.", "labels": ["OpenZeppelin"]}, {"title": "Unsafe Assumptions About Average Time Between Blocks", "body": "Unsafe Assumptions About Average Time Between Blocks", "html_url": "https://blog.openzeppelin.com/compound-audit#unsafe-assumptions-about-average-time-between-blocks", "labels": ["OpenZeppelin"]}, {"title": "The current implementation of the protocol uses blocks rather than seconds to measure time between interest accruals. This makes the implementation highly sensitive to changes in the average time between Ethereum blocks.", "body": "The current implementation of the protocol uses blocks rather than seconds to measure time between interest accruals. This makes the implementation highly sensitive to changes in the average time between Ethereum blocks.", "html_url": "https://blog.openzeppelin.com/compound-audit#the-current-implementation-of-the-protocol-uses-blocks-rather-than-seconds-to-measure-time-between-interest-accruals.-this-makes-the-implementation-highly-sensitive-to-changes-in-the-average-time-between-ethereum-blocks.", "labels": ["OpenZeppelin"]}, {"title": "On line 30 of WhitePaperInterestRateModel.sol it is implicitly assumed that the time between blocks is 15 seconds. However, the average time between blocks can change dramatically.", "body": "On line 30 of WhitePaperInterestRateModel.sol it is implicitly assumed that the time between blocks is 15 seconds. However, the average time between blocks can change dramatically.", "html_url": "https://blog.openzeppelin.com/compound-audit#on-line-30-of-whitepaperinterestratemodel.sol-it-is-implicitly-assumed-that-the-time-between-blocks-is-15-seconds.-however,-the-average-time-between-blocks-can-change-dramatically.", "labels": ["OpenZeppelin"]}, {"title": "For example, the average time between blocks may increase by significant factors due to the difficulty bomb or decrease by significant factors during the transition to Serenity.", "body": "For example, the average time between blocks may increase by significant factors due to the difficulty bomb or decrease by significant factors during the transition to Serenity.", "html_url": "https://blog.openzeppelin.com/compound-audit#for-example,-the-average-time-between-blocks-may-increase-by-significant-factors-due-to-the-difficulty-bomb-or-decrease-by-significant-factors-during-the-transition-to-serenity.", "labels": ["OpenZeppelin"]}, {"title": "The difference between the actual time between blocks and the assumed time between blocks causes proportional differences between the intended interest rates and the actual interest rates.", "body": "The difference between the actual time between blocks and the assumed time between blocks causes proportional differences between the intended interest rates and the actual interest rates.", "html_url": "https://blog.openzeppelin.com/compound-audit#the-difference-between-the-actual-time-between-blocks-and-the-assumed-time-between-blocks-causes-proportional-differences-between-the-intended-interest-rates-and-the-actual-interest-rates.", "labels": ["OpenZeppelin"]}, {"title": "While it is possible for the admin to combat this by adjusting the interest rate model when the average time between blocks changes, such adjustments are manual and happen only after-the-fact. Errors in blocktime assumptions are cumulative, and fixing the model after-the-fact does not make users whole \u2013 it only prevents incorrect interest calculations moving forward (until the next change in blocktime).", "body": "While it is possible for the admin to combat this by adjusting the interest rate model when the average time between blocks changes, such adjustments are manual and happen only after-the-fact. Errors in blocktime assumptions are cumulative, and fixing the model after-the-fact does not make users whole \u2013 it only prevents incorrect interest calculations moving forward (until the next change in blocktime).", "html_url": "https://blog.openzeppelin.com/compound-audit#while-it-is-possible-for-the-admin-to-combat-this-by-adjusting-the-interest-rate-model-when-the-average-time-between-blocks-changes,-such-adjustments-are-manual-and-happen-only-after-the-fact.-errors-in-blocktime-assumptions-are-cumulative,-and-fixing-the-model-after-the-fact-does-not-make-users-whole-\u2013-it-only-prevents-incorrect-interest-calculations-moving-forward-(until-the-next-change-in-blocktime).", "labels": ["OpenZeppelin"]}, {"title": "Consider refactoring the implementation to use seconds rather than blocks to measure the time between accruals. While block.timestamp can be manipulated by miners within a narrow window, these errors are small and, importantly, are not cumulative. This would decouple the interest rate model from Ethereum\u2019s average blocktime.", "body": "Consider refactoring the implementation to use seconds rather than blocks to measure the time between accruals. While block.timestamp can be manipulated by miners within a narrow window, these errors are small and, importantly, are not cumulative. This would decouple the interest rate model from Ethereum\u2019s average blocktime.", "html_url": "https://blog.openzeppelin.com/compound-audit#consider-refactoring-the-implementation-to-use-seconds-rather-than-blocks-to-measure-the-time-between-accruals.-while-block.timestamp-can-be-manipulated-by-miners-within-a-narrow-window,-these-errors-are-small-and,-importantly,-are-not-cumulative.-this-would-decouple-the-interest-rate-model-from-ethereum\u2019s-average-blocktime.", "labels": ["OpenZeppelin"]}, {"title": "Misleading NatSpec Comments", "body": "Misleading NatSpec Comments", "html_url": "https://blog.openzeppelin.com/compound-audit#misleading-natspec-comments", "labels": ["OpenZeppelin"]}, {"title": "Since the purpose of the Ethereum Natural Specification (NatSpec) is to describe the code to the user, misleading statements should be considered a violation of the public API that may confuse or mislead users.", "body": "Since the purpose of the Ethereum Natural Specification (NatSpec) is to describe the code to the user, misleading statements should be considered a violation of the public API that may confuse or mislead users.", "html_url": "https://blog.openzeppelin.com/compound-audit#since-the-purpose-of-the-ethereum-natural-specification-(natspec)-is-to-describe-the-code-to-the-user,-misleading-statements-should-be-considered-a-violation-of-the-public-api-that-may-confuse-or-mislead-users.", "labels": ["OpenZeppelin"]}, {"title": "The getBorrowRate interface and implementation @return comments state that the rate is scaled by 10e18. In fact, it is only scaled by 1e18.", "body": "The getBorrowRate interface and implementation @return comments state that the rate is scaled by 10e18. In fact, it is only scaled by 1e18.", "html_url": "https://blog.openzeppelin.com/compound-audit#the-getborrowrate-interface-and-implementation-@return-comments-state-that-the-rate-is-scaled-by-10e18.-in-fact,-it-is-only-scaled-by-1e18.", "labels": ["OpenZeppelin"]}, {"title": "The CToken contract borrowRateMaxMantissa comment states that the maximum borrow rate per block is 0.0005% but it is actually 0.0005 ( or 0.05% ).", "body": "The CToken contract borrowRateMaxMantissa comment states that the maximum borrow rate per block is 0.0005% but it is actually 0.0005 ( or 0.05% ).", "html_url": "https://blog.openzeppelin.com/compound-audit#the-ctoken-contract-borrowratemaxmantissa-comment-states-that-the-maximum-borrow-rate-per-block-is-0.0005%-but-it-is-actually-0.0005-(-or-0.05%-).", "labels": ["OpenZeppelin"]}, {"title": "The comment on line 7 of Unitroller.sol is an incomplete thought/sentence.", "body": "The comment on line 7 of Unitroller.sol is an incomplete thought/sentence.", "html_url": "https://blog.openzeppelin.com/compound-audit#the-comment-on-line-7-of-unitroller.sol-is-an-incomplete-thought/sentence.", "labels": ["OpenZeppelin"]}, {"title": "The comment on line 41 of ComptrollerStorage.sol uses the word \u201cdiscount\u201d when it should use \u201cbonus\u201d, which may cause confusion for people trying to understand the code. For example, a 25% discount is equivalent to a 33% bonus. That is, \u201c25% off\u201d is the same as \u201c33% more for free\u201d.", "body": "The comment on line 41 of ComptrollerStorage.sol uses the word \u201cdiscount\u201d when it should use \u201cbonus\u201d, which may cause confusion for people trying to understand the code. For example, a 25% discount is equivalent to a 33% bonus. That is, \u201c25% off\u201d is the same as \u201c33% more for free\u201d.", "html_url": "https://blog.openzeppelin.com/compound-audit#the-comment-on-line-41-of-comptrollerstorage.sol-uses-the-word-\u201cdiscount\u201d-when-it-should-use-\u201cbonus\u201d,-which-may-cause-confusion-for-people-trying-to-understand-the-code.-for-example,-a-25%-discount-is-equivalent-to-a-33%-bonus.-that-is,-\u201c25%-off\u201d-is-the-same-as-\u201c33%-more-for-free\u201d.", "labels": ["OpenZeppelin"]}, {"title": "The comment on line 6 of Exponential.sol says \u201cfixed-decision\u201d when it should say \u201cfixed-precision\u201d.", "body": "The comment on line 6 of Exponential.sol says \u201cfixed-decision\u201d when it should say \u201cfixed-precision\u201d.", "html_url": "https://blog.openzeppelin.com/compound-audit#the-comment-on-line-6-of-exponential.sol-says-\u201cfixed-decision\u201d-when-it-should-say-\u201cfixed-precision\u201d.", "labels": ["OpenZeppelin"]}, {"title": "The comment on line 83 of CToken.sol describes borrowIndex as the accumulator of earned interest when it should be the accumulator of the earned interest rate.", "body": "The comment on line 83 of CToken.sol describes borrowIndex as the accumulator of earned interest when it should be the accumulator of the earned interest rate.", "html_url": "https://blog.openzeppelin.com/compound-audit#the-comment-on-line-83-of-ctoken.sol-describes-borrowindex-as-the-accumulator-of-earned-interest-when-it-should-be-the-accumulator-of-the-earned-interest-rate.", "labels": ["OpenZeppelin"]}, {"title": "Consider updating the comments appropriately.", "body": "Require Statement Without Error Message  There is a require statement on line 111 of CEther.sol with no failure message. Consider adding a message to inform users in case of a revert.  Non-traditional Use of ReentrancyGuard  The NatSpec documentation on ReentrancyGuard.sol states:  If you mark a function nonReentrant, you should also mark it external.  However, the following functions in CToken.sol have the nonReentrant modifier and are NOT external:  exchangeRateCurrent (public)  mintInternal (internal)  redeemInternal (internal)  redeemUnderlyingInternal (internal)  borrowInternal (internal)  repayBorrowInternal (internal)  repayBorrowBehalfInternal (internal)  liquidateBorrowInternal (internal)  Typically, the nonReentrant modifier would be put on their external function counterparts in CEther.sol and CErc20.sol. That said, the existing use of ReentrancyGuard does prevent reentry into the corresponding external functions, and so no changes are needed.  Unvetted Token Warning  It is important to note that if a malicious or poorly-designed token is added to Compound, it could allow someone to steal all funds entrusted to Compound. For example, if anyone can arbitrarily change the totalSupply or account balances of a listed ERC20 token faster than the price oracle can adjust the price, an attacker could use those newly minted tokens as collateral to borrow all Compound assets.  Consider making a formal list of properties that a safe token should and should not have, and be sure each new token is safe before listing it on Compound.  Transparent Proxy Pattern  The Unitroller contract uses a proxy pattern to redirect transactions to functions it does not recognize. However, it will not be able to proxy calls to functions with the same function signature as one of its own functions, including its inherited functions.  Consider using the transparent proxy pattern for increased generality.  Unused Return Value  The getUtilizationAndAnnualBorrowRate function of the WhitePaperInterestRateModel contract returns the utilization rate in addition to the borrow rate. However, the only function that calls it discards the utilization rate. Consider removing the utilization rate from the return values.  collateralFactorMantissa Needs to be Set  In Comptroller.sol, collateralFactorMantissa for each market is initialized implicitly to 0 until it is set within _setCollateralFactor. This means that whenever a new market is created, a second transaction must be submitted to set the collateral factor. If this doesnt happen, account liquidity contributions for that market will be 0.  Consider Adding Syntax Highlighting to GitHub Repository  Consider adding Solidity syntax highlighting to the GitHub repository by putting the line *.sol linguist-language=Solidity in a .gitattributes file in the root of the repository.  This helps improve readability for users inspecting contract code on GitHub.  Accrue Zero Interest Event  In the accrueInterest function of CToken, the AccrueInterest event is still emitted when there is no interest (because it was already accrued in this block). Consider checking the accrualBlockNumber before emitting the event (or indeed, executing the rest of the function).  Unexpected ERC20s  Within each of the cToken ERC20 contracts, there is no way to check for unexpected sends of ERC20 tokens to the contract. However, the ERC20 balance is used in the exchangeRate calculation via the variable totalCash, which is equal to the ERC20 token balance.  This results in cToken values increasing with ERC20 sends, but importantly, it does not result in the value of borrows increasing, as borrowIndex is unaffected by total underlying balance.  Consider adding a state variable to track internal balances, which would help identify any unexpected ERC20 tokens.  Avoid Overloaded Functions  Within Exponential.sol there are two definitions for mulExp() (here, and here). Consider changing the name of one of the functions for improved readability of code.  Use ABI Encoder  The requireNoError function in the CEther contract appends a string to another string one byte at a time. Consider commenting the operation for clarity and using abi.encodePacked for brevity.  Missing require  sanity check in the  Default Visibility  The following state variables and constants are using the default visibility:  In Comptroller:closeFactorMinMantissa, closeFactorMaxMantissa, collateralFactorMaxMantissa, liquidationIncentiveMinMantissa, liquidationIncentiveMaxMantissa  In CToken:borrowRateMaxMantissa, reserveFactorMaxMantissa, accountTokens,transferAllowances, accountBorrows  In Exponential:expScale, halfExpScale, mantissaOne  For readability, consider explicitly declaring the visibility of all state variables.  TODOs in Code  Exponential,  Unitroller, and  1306,  1405,  1455,  1465 and  1525 ), despite being used in production.  Consider resolving and removing them.  Superfluous Code in acceptAdmin  On line 1333 of CToken.sol there is the conditional statement:  if (msg.sender != pendingAdmin || msg.sender == address(0)) ...  The comment immediately above this line is:  // Check caller is pendingAdmin and pendingAdmin \u2260 address(0)  This comment suggests that the conditional on line 1333 was intended to be:  if (msg.sender != pendingAdmin || pendingAdmin == address(0)) ...  In either case, however, the second half of the conditional is superfluous. It is infeasible for msg.sender to be the zero address. Thus, the conditional statement can be reduced to:  if (msg.sender != pendingAdmin) ....  Change uint to uint256  Throughout the code base, some variables are declared as uint. To favor explicitness, consider changing all instances of uint to uint256.  Use assert  The require statement on line 1476 of CToken.sol is confirming a property that should never fail for any user input. In such a situation, consider using an assert statement instead.  Conclusion  No critical and two high severity issues were found. Some changes were proposed to follow best practices and reduce potential attack surface.  Summary  If you are interested in a non-technical overview of this audit, we present a summary of the system as it relates to the audit as well as a couple of interesting findings in our summary article.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/compound-audit#consider-updating-the-comments-appropriately.", "labels": ["OpenZeppelin"]}, {"title": "Excessive Indirection", "body": "Excessive Indirection", "html_url": "https://blog.openzeppelin.com/compound-audit#excessive-indirection", "labels": ["OpenZeppelin"]}, {"title": "The Exponential contract represents a fixed-size decimal number with a uint that is scaled up so the smallest non-zero decimal value is internally represented by the number 1. However, it is also unnecessarily wrapped in a struct.", "body": "The Exponential contract represents a fixed-size decimal number with a uint that is scaled up so the smallest non-zero decimal value is internally represented by the number 1. However, it is also unnecessarily wrapped in a struct.", "html_url": "https://blog.openzeppelin.com/compound-audit#the-exponential-contract-represents-a-fixed-size-decimal-number-with-a-uint-that-is-scaled-up-so-the-smallest-non-zero-decimal-value-is-internally-represented-by-the-number-1.-however,-it-is-also-unnecessarily-wrapped-in-a-struct.", "labels": ["OpenZeppelin"]}, {"title": "This has the advantage that the scaled values can have a unique Solidity type. On the other hand, this feature is used inconsistently throughout the code base and introduces a very large overhead. Many of the functions in the Exponential contract implement common mathematical operations on the Exp type when the equivalent functions already exist for the uint256 type. Most of the functions in the Exponential contract could be simplified or eliminated if the additional layer of indirection were removed. Additionally, many operations are complicated by mapping back and forth between the two representations.", "body": "This has the advantage that the scaled values can have a unique Solidity type. On the other hand, this feature is used inconsistently throughout the code base and introduces a very large overhead. Many of the functions in the Exponential contract implement common mathematical operations on the Exp type when the equivalent functions already exist for the uint256 type. Most of the functions in the Exponential contract could be simplified or eliminated if the additional layer of indirection were removed. Additionally, many operations are complicated by mapping back and forth between the two representations.", "html_url": "https://blog.openzeppelin.com/compound-audit#this-has-the-advantage-that-the-scaled-values-can-have-a-unique-solidity-type.-on-the-other-hand,-this-feature-is-used-inconsistently-throughout-the-code-base-and-introduces-a-very-large-overhead.-many-of-the-functions-in-the-exponential-contract-implement-common-mathematical-operations-on-the-exp-type-when-the-equivalent-functions-already-exist-for-the-uint256-type.-most-of-the-functions-in-the-exponential-contract-could-be-simplified-or-eliminated-if-the-additional-layer-of-indirection-were-removed.-additionally,-many-operations-are-complicated-by-mapping-back-and-forth-between-the-two-representations.", "labels": ["OpenZeppelin"]}, {"title": "Consider using the uint256 type to internally represent the fixed-size decimal numbers. Then, consider enforcing the existing Mantissa suffix convention to consistently indicate whether a given variable is scaled.", "body": "Consider using the uint256 type to internally represent the fixed-size decimal numbers. Then, consider enforcing the existing Mantissa suffix convention to consistently indicate whether a given variable is scaled.", "html_url": "https://blog.openzeppelin.com/compound-audit#consider-using-the-uint256-type-to-internally-represent-the-fixed-size-decimal-numbers.-then,-consider-enforcing-the-existing-mantissa-suffix-convention-to-consistently-indicate-whether-a-given-variable-is-scaled.", "labels": ["OpenZeppelin"]}, {"title": "cToken Related Issues", "body": "cToken Related Issues", "html_url": "https://blog.openzeppelin.com/compound-audit#ctoken-related-issues", "labels": ["OpenZeppelin"]}, {"title": "cTokens might not be transferable", "body": "cTokens might not be transferable", "html_url": "https://blog.openzeppelin.com/compound-audit#ctokens-might-not-be-transferable", "labels": ["OpenZeppelin"]}, {"title": "Currently cTokens can not be transferred if they are required to collateralize a loan, but there are no functions to check if users\u2019 cTokens are locked. This is not standard ERC20 behaviour and could be confusing to users.Considering adding a related function to check if users\u2019 cTokens are transferable.", "body": "Currently cTokens can not be transferred if they are required to collateralize a loan, but there are no functions to check if users\u2019 cTokens are locked. This is not standard ERC20 behaviour and could be confusing to users.Considering adding a related function to check if users\u2019 cTokens are transferable.", "html_url": "https://blog.openzeppelin.com/compound-audit#currently-ctokens-can-not-be-transferred-if-they-are-required-to-collateralize-a-loan,-but-there-are-no-functions-to-check-if-users\u2019-ctokens-are-locked.-this-is-not-standard-erc20-behaviour-and-could-be-confusing-to-users.considering-adding-a-related-function-to-check-if-users\u2019-ctokens-are-transferable.", "labels": ["OpenZeppelin"]}, {"title": "ERC20 double spend race condition", "body": "ERC20 double spend race condition", "html_url": "https://blog.openzeppelin.com/compound-audit#erc20-double-spend-race-condition", "labels": ["OpenZeppelin"]}, {"title": "Due to CToken\u2018s inheritance of ERC20\u2019s approve function, it is vulnerable to the ERC20 approve and double spend front running attack. Briefly, an authorized spender could spend both allowances by front running an allowance-changing transaction. Consider implementing OpenZeppelin\u2019s decreaseAllowance and increaseAllowance functions to help mitigate this.", "body": "Due to CToken\u2018s inheritance of ERC20\u2019s approve function, it is vulnerable to the ERC20 approve and double spend front running attack. Briefly, an authorized spender could spend both allowances by front running an allowance-changing transaction. Consider implementing OpenZeppelin\u2019s decreaseAllowance and increaseAllowance functions to help mitigate this.", "html_url": "https://blog.openzeppelin.com/compound-audit#due-to-ctoken\u2018s-inheritance-of-erc20\u2019s-approve-function,-it-is-vulnerable-to-the-erc20-approve-and-double-spend-front-running-attack.-briefly,-an-authorized-spender-could-spend-both-allowances-by-front-running-an-allowance-changing-transaction.-consider-implementing-openzeppelin\u2019s-decreaseallowance-and-increaseallowance-functions-to-help-mitigate-this.", "labels": ["OpenZeppelin"]}, {"title": "ERC20 decimals size", "body": "ERC20 decimals size", "html_url": "https://blog.openzeppelin.com/compound-audit#erc20-decimals-size", "labels": ["OpenZeppelin"]}, {"title": "optionally defines a uint8 decimals field. However, the", "body": "optionally defines a uint8 decimals field. However, the", "html_url": "https://blog.openzeppelin.com/compound-audit#optionally-defines-a-uint8-decimals-field.-however,-the", "labels": ["OpenZeppelin"]}, {"title": "corresponding field in the", "body": "corresponding field in the", "html_url": "https://blog.openzeppelin.com/compound-audit#corresponding-field-in-the", "labels": ["OpenZeppelin"]}, {"title": "0 Address for Mints & Burns", "body": "0 Address for Mints & Burns", "html_url": "https://blog.openzeppelin.com/compound-audit#0-address-for-mints-&-burns", "labels": ["OpenZeppelin"]}, {"title": "mintFresh and", "body": "mintFresh and", "html_url": "https://blog.openzeppelin.com/compound-audit#mintfresh-and", "labels": ["OpenZeppelin"]}, {"title": "redeemFresh use the address of the", "body": "redeemFresh use the address of the", "html_url": "https://blog.openzeppelin.com/compound-audit#redeemfresh-use-the-address-of-the", "labels": ["OpenZeppelin"]}, {"title": "Mixing concerns", "body": "Mixing concerns", "html_url": "https://blog.openzeppelin.com/compound-audit#mixing-concerns", "labels": ["OpenZeppelin"]}, {"title": "The CToken contract performs three different categories of functions:1. ERC20 operations including transferring tokens, checking balances and setting allowances1. Administrative operations such as setting the comptroller, interest rate model and reserve rate1. The borrowing, loaning, repaying and liquidating operations as well as their support functions", "body": "The CToken contract performs three different categories of functions:1. ERC20 operations including transferring tokens, checking balances and setting allowances1. Administrative operations such as setting the comptroller, interest rate model and reserve rate1. The borrowing, loaning, repaying and liquidating operations as well as their support functions", "html_url": "https://blog.openzeppelin.com/compound-audit#the-ctoken-contract-performs-three-different-categories-of-functions:1.-erc20-operations-including-transferring-tokens,-checking-balances-and-setting-allowances1.-administrative-operations-such-as-setting-the-comptroller,-interest-rate-model-and-reserve-rate1.-the-borrowing,-loaning,-repaying-and-liquidating-operations-as-well-as-their-support-functions", "labels": ["OpenZeppelin"]}, {"title": "For simplicity and readability, consider splitting it into multiple contracts with distinct roles.", "body": "For simplicity and readability, consider splitting it into multiple contracts with distinct roles.", "html_url": "https://blog.openzeppelin.com/compound-audit#for-simplicity-and-readability,-consider-splitting-it-into-multiple-contracts-with-distinct-roles.", "labels": ["OpenZeppelin"]}, {"title": "Admin Must Receive Reserves", "body": "Admin Must Receive Reserves", "html_url": "https://blog.openzeppelin.com/compound-audit#admin-must-receive-reserves", "labels": ["OpenZeppelin"]}, {"title": "The CToken administrator can call the _reduceReserves function to withdraw some of the reserves. However, the function requires that the administrator is the recipient address. This merges roles that should probably be distinct, particularly when the administrator is replaced with a decentralized governance process.", "body": "The CToken administrator can call the _reduceReserves function to withdraw some of the reserves. However, the function requires that the administrator is the recipient address. This merges roles that should probably be distinct, particularly when the administrator is replaced with a decentralized governance process.", "html_url": "https://blog.openzeppelin.com/compound-audit#the-ctoken-administrator-can-call-the-_reducereserves-function-to-withdraw-some-of-the-reserves.-however,-the-function-requires-that-the-administrator-is-the-recipient-address.-this-merges-roles-that-should-probably-be-distinct,-particularly-when-the-administrator-is-replaced-with-a-decentralized-governance-process.", "labels": ["OpenZeppelin"]}, {"title": "Consider having a separate recipient role, or allowing the administrator to choose the recipient in the function call.", "body": "Consider having a separate recipient role, or allowing the administrator to choose the recipient in the function call.", "html_url": "https://blog.openzeppelin.com/compound-audit#consider-having-a-separate-recipient-role,-or-allowing-the-administrator-to-choose-the-recipient-in-the-function-call.", "labels": ["OpenZeppelin"]}, {"title": "Truncation-Related Issues", "body": "Truncation-Related Issues", "html_url": "https://blog.openzeppelin.com/compound-audit#truncation-related-issues", "labels": ["OpenZeppelin"]}, {"title": "Throughout the compound contracts, truncation issues inherent to EVM operation result in some relatively unavoidable errors. These errors exist when minting cTokens, when redeeming cTokens for their underlying assets, and when liquidating another user\u2019s loan.", "body": "Throughout the compound contracts, truncation issues inherent to EVM operation result in some relatively unavoidable errors. These errors exist when minting cTokens, when redeeming cTokens for their underlying assets, and when liquidating another user\u2019s loan.", "html_url": "https://blog.openzeppelin.com/compound-audit#throughout-the-compound-contracts,-truncation-issues-inherent-to-evm-operation-result-in-some-relatively-unavoidable-errors.-these-errors-exist-when-minting-ctokens,-when-redeeming-ctokens-for-their-underlying-assets,-and-when-liquidating-another-user\u2019s-loan.", "labels": ["OpenZeppelin"]}, {"title": "In the case of minting, the CToken.mintFresh function calls divScalarByExpTruncate to determine the number of cTokens the user will receive given their input of a certain number of underlying tokens. The result will be truncated if it is calculated to be some non-integer number of cToken units.", "body": "In the case of minting, the CToken.mintFresh function calls divScalarByExpTruncate to determine the number of cTokens the user will receive given their input of a certain number of underlying tokens. The result will be truncated if it is calculated to be some non-integer number of cToken units.", "html_url": "https://blog.openzeppelin.com/compound-audit#in-the-case-of-minting,-the-ctoken.mintfresh-function-calls-divscalarbyexptruncate-to-determine-the-number-of-ctokens-the-user-will-receive-given-their-input-of-a-certain-number-of-underlying-tokens.-the-result-will-be-truncated-if-it-is-calculated-to-be-some-non-integer-number-of-ctoken-units.", "labels": ["OpenZeppelin"]}, {"title": "In the case of redeeming, the CToken.redeemFresh function also calls divScalarByExpTruncate. The number of tokens to redeem will similarly be truncated to the next lowest integer value of underlying token units.", "body": "In the case of redeeming, the CToken.redeemFresh function also calls divScalarByExpTruncate. The number of tokens to redeem will similarly be truncated to the next lowest integer value of underlying token units.", "html_url": "https://blog.openzeppelin.com/compound-audit#in-the-case-of-redeeming,-the-ctoken.redeemfresh-function-also-calls-divscalarbyexptruncate.-the-number-of-tokens-to-redeem-will-similarly-be-truncated-to-the-next-lowest-integer-value-of-underlying-token-units.", "labels": ["OpenZeppelin"]}, {"title": "Finally, the Comptroller.liquidateCalculateSeizeTokens function calls mulScalarTruncate. If the amount repaid is sufficiently small, the result will be rounded down to the next nearest integer value of indivisible token units.", "body": "Finally, the Comptroller.liquidateCalculateSeizeTokens function calls mulScalarTruncate. If the amount repaid is sufficiently small, the result will be rounded down to the next nearest integer value of indivisible token units.", "html_url": "https://blog.openzeppelin.com/compound-audit#finally,-the-comptroller.liquidatecalculateseizetokens-function-calls-mulscalartruncate.-if-the-amount-repaid-is-sufficiently-small,-the-result-will-be-rounded-down-to-the-next-nearest-integer-value-of-indivisible-token-units.", "labels": ["OpenZeppelin"]}, {"title": "In all cases, the user receives less than they theoretically should (either in terms of cTokens, or in terms of underlying tokens). However, the loss should never be more than 1 indivisible unit of whatever token the user is receiving. Even in the case of wBTC, where 1 indivisible unit is worth the most out of any other token involved, the loss is only roughly 1% of a USD cent (at time of writing). This issue, unlike the issue of interest-free loans, does not hurt the protocol. Instead, the users take the brunt of the (very small) loss.", "body": "In all cases, the user receives less than they theoretically should (either in terms of cTokens, or in terms of underlying tokens). However, the loss should never be more than 1 indivisible unit of whatever token the user is receiving. Even in the case of wBTC, where 1 indivisible unit is worth the most out of any other token involved, the loss is only roughly 1% of a USD cent (at time of writing). This issue, unlike the issue of interest-free loans, does not hurt the protocol. Instead, the users take the brunt of the (very small) loss.", "html_url": "https://blog.openzeppelin.com/compound-audit#in-all-cases,-the-user-receives-less-than-they-theoretically-should-(either-in-terms-of-ctokens,-or-in-terms-of-underlying-tokens).-however,-the-loss-should-never-be-more-than-1-indivisible-unit-of-whatever-token-the-user-is-receiving.-even-in-the-case-of-wbtc,-where-1-indivisible-unit-is-worth-the-most-out-of-any-other-token-involved,-the-loss-is-only-roughly-1%-of-a-usd-cent-(at-time-of-writing).-this-issue,-unlike-the-issue-of-interest-free-loans,-does-not-hurt-the-protocol.-instead,-the-users-take-the-brunt-of-the-(very-small)-loss.", "labels": ["OpenZeppelin"]}, {"title": "It should be pointed out that extremely small loans that are able to be liquidated may not actually be liquidated, since truncation could cause the liquidator to receive nothing, or far less than they\u2019d theoretically receive. However, loans that are not liquidated because of this will eventually accrue enough interest that they can be profitably liquidated.", "body": "It should be pointed out that extremely small loans that are able to be liquidated may not actually be liquidated, since truncation could cause the liquidator to receive nothing, or far less than they\u2019d theoretically receive. However, loans that are not liquidated because of this will eventually accrue enough interest that they can be profitably liquidated.", "html_url": "https://blog.openzeppelin.com/compound-audit#it-should-be-pointed-out-that-extremely-small-loans-that-are-able-to-be-liquidated-may-not-actually-be-liquidated,-since-truncation-could-cause-the-liquidator-to-receive-nothing,-or-far-less-than-they\u2019d-theoretically-receive.-however,-loans-that-are-not-liquidated-because-of-this-will-eventually-accrue-enough-interest-that-they-can-be-profitably-liquidated.", "labels": ["OpenZeppelin"]}, {"title": "Partial Refactorization", "body": "Partial Refactorization", "html_url": "https://blog.openzeppelin.com/compound-audit#partial-refactorization", "labels": ["OpenZeppelin"]}, {"title": "getUtilizationAndAnnualBorrowRate function of the", "body": "WhitePaperInterestRateModel contract returns the utilization rate in addition to the borrow rate. However, the only function that calls it discards the utilization rate. Consider removing the utilization rate from the return values.  collateralFactorMantissa Needs to be Set  In Comptroller.sol, collateralFactorMantissa for each market is initialized implicitly to 0 until it is set within _setCollateralFactor. This means that whenever a new market is created, a second transaction must be submitted to set the collateral factor. If this doesnt happen, account liquidity contributions for that market will be 0.  Consider Adding Syntax Highlighting to GitHub Repository  Consider adding Solidity syntax highlighting to the GitHub repository by putting the line *.sol linguist-language=Solidity in a .gitattributes file in the root of the repository.  This helps improve readability for users inspecting contract code on GitHub.  Accrue Zero Interest Event  In the accrueInterest function of CToken, the AccrueInterest event is still emitted when there is no interest (because it was already accrued in this block). Consider checking the accrualBlockNumber before emitting the event (or indeed, executing the rest of the function).  Unexpected ERC20s  Within each of the cToken ERC20 contracts, there is no way to check for unexpected sends of ERC20 tokens to the contract. However, the ERC20 balance is used in the exchangeRate calculation via the variable totalCash, which is equal to the ERC20 token balance.  This results in cToken values increasing with ERC20 sends, but importantly, it does not result in the value of borrows increasing, as borrowIndex is unaffected by total underlying balance.  Consider adding a state variable to track internal balances, which would help identify any unexpected ERC20 tokens.  Avoid Overloaded Functions  Within Exponential.sol there are two definitions for mulExp() (here, and here). Consider changing the name of one of the functions for improved readability of code.  Use ABI Encoder  The requireNoError function in the CEther contract appends a string to another string one byte at a time. Consider commenting the operation for clarity and using abi.encodePacked for brevity.  Missing require  sanity check in the  Default Visibility  The following state variables and constants are using the default visibility:  In Comptroller:closeFactorMinMantissa, closeFactorMaxMantissa, collateralFactorMaxMantissa, liquidationIncentiveMinMantissa, liquidationIncentiveMaxMantissa  In CToken:borrowRateMaxMantissa, reserveFactorMaxMantissa, accountTokens,transferAllowances, accountBorrows  In Exponential:expScale, halfExpScale, mantissaOne  For readability, consider explicitly declaring the visibility of all state variables.  TODOs in Code  Exponential,  Unitroller, and  1306,  1405,  1455,  1465 and  1525 ), despite being used in production.  Consider resolving and removing them.  Superfluous Code in acceptAdmin  On line 1333 of CToken.sol there is the conditional statement:  if (msg.sender != pendingAdmin || msg.sender == address(0)) ...  The comment immediately above this line is:  // Check caller is pendingAdmin and pendingAdmin \u2260 address(0)  This comment suggests that the conditional on line 1333 was intended to be:  if (msg.sender != pendingAdmin || pendingAdmin == address(0)) ...  In either case, however, the second half of the conditional is superfluous. It is infeasible for msg.sender to be the zero address. Thus, the conditional statement can be reduced to:  if (msg.sender != pendingAdmin) ....  Change uint to uint256  Throughout the code base, some variables are declared as uint. To favor explicitness, consider changing all instances of uint to uint256.  Use assert  The require statement on line 1476 of CToken.sol is confirming a property that should never fail for any user input. In such a situation, consider using an assert statement instead.  Conclusion  No critical and two high severity issues were found. Some changes were proposed to follow best practices and reduce potential attack surface.  Summary  If you are interested in a non-technical overview of this audit, we present a summary of the system as it relates to the audit as well as a couple of interesting findings in our summary article.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/compound-audit#getutilizationandannualborrowrate-function-of-the", "labels": ["OpenZeppelin"]}, {"title": "multiplier variable is represented as a percentage (ie. the value 45 would imply a multiplier of 45%). However, instead of dividing by 100,", "body": "multiplier variable is represented as a percentage (ie. the value 45 would imply a multiplier of 45%). However, instead of dividing by 100,", "html_url": "https://blog.openzeppelin.com/compound-audit#multiplier-variable-is-represented-as-a-percentage-(ie.-the-value-45-would-imply-a-multiplier-of-45%).-however,-instead-of-dividing-by-100,", "labels": ["OpenZeppelin"]}, {"title": "it is divided by 1e18. This is consistent with how the deployed contracts treat the", "body": "it is divided by 1e18. This is consistent with how the deployed contracts treat the", "html_url": "https://blog.openzeppelin.com/compound-audit#it-is-divided-by-1e18.-this-is-consistent-with-how-the-deployed-contracts-treat-the", "labels": ["OpenZeppelin"]}, {"title": "mulExp function without the rounding check.", "body": "mulExp function without the rounding check.", "html_url": "https://blog.openzeppelin.com/compound-audit#mulexp-function-without-the-rounding-check.", "labels": ["OpenZeppelin"]}, {"title": "Consider using the mulExp function to scale the utilization rate instead of mulScalar and divScalar and update the comments to describe the correct code behaviour. In addition, consider stating the unit type in the multiplier and baseRate comments.", "body": "Consider using the mulExp function to scale the utilization rate instead of mulScalar and divScalar and update the comments to describe the correct code behaviour. In addition, consider stating the unit type in the multiplier and baseRate comments.", "html_url": "https://blog.openzeppelin.com/compound-audit#consider-using-the-mulexp-function-to-scale-the-utilization-rate-instead-of-mulscalar-and-divscalar-and-update-the-comments-to-describe-the-correct-code-behaviour.-in-addition,-consider-stating-the-unit-type-in-the-multiplier-and-baserate-comments.", "labels": ["OpenZeppelin"]}, {"title": "Notes", "body": "Notes", "html_url": "https://blog.openzeppelin.com/compound-audit#notes", "labels": ["OpenZeppelin"]}, {"title": "Markets Can Become Insolvent", "body": "Markets Can Become Insolvent", "html_url": "https://blog.openzeppelin.com/compound-audit#markets-can-become-insolvent", "labels": ["OpenZeppelin"]}, {"title": "When the value of all collateral is worth less than the value of all borrowed assets, we say the market is insolvent. Compound does many things to reduce the risk of market insolvency, including: prudent selection of collateral-ratios, incentivizing third-party collateral liquidation, careful selection of which tokens are listed on the platform, etc. However, the risk of insolvency cannot be entirely eliminated, and there are numerous ways a market can become insolvent.", "body": "When the value of all collateral is worth less than the value of all borrowed assets, we say the market is insolvent. Compound does many things to reduce the risk of market insolvency, including: prudent selection of collateral-ratios, incentivizing third-party collateral liquidation, careful selection of which tokens are listed on the platform, etc. However, the risk of insolvency cannot be entirely eliminated, and there are numerous ways a market can become insolvent.", "html_url": "https://blog.openzeppelin.com/compound-audit#when-the-value-of-all-collateral-is-worth-less-than-the-value-of-all-borrowed-assets,-we-say-the-market-is-insolvent.-compound-does-many-things-to-reduce-the-risk-of-market-insolvency,-including:-prudent-selection-of-collateral-ratios,-incentivizing-third-party-collateral-liquidation,-careful-selection-of-which-tokens-are-listed-on-the-platform,-etc.-however,-the-risk-of-insolvency-cannot-be-entirely-eliminated,-and-there-are-numerous-ways-a-market-can-become-insolvent.", "labels": ["OpenZeppelin"]}, {"title": "Here are five examples of things that could cause a market to become insolvent:", "body": "Here are five examples of things that could cause a market to become insolvent:", "html_url": "https://blog.openzeppelin.com/compound-audit#here-are-five-examples-of-things-that-could-cause-a-market-to-become-insolvent:", "labels": ["OpenZeppelin"]}, {"title": "The price of the underlying (or borrowed) asset makes a big, quick move during a time of high network congestion \u2014 resulting in the market becoming insolvent before enough liquidation transactions can be mined.", "body": "The price of the underlying (or borrowed) asset makes a big, quick move during a time of high network congestion \u2014 resulting in the market becoming insolvent before enough liquidation transactions can be mined.", "html_url": "https://blog.openzeppelin.com/compound-audit#the-price-of-the-underlying-(or-borrowed)-asset-makes-a-big,-quick-move-during-a-time-of-high-network-congestion-\u2014-resulting-in-the-market-becoming-insolvent-before-enough-liquidation-transactions-can-be-mined.", "labels": ["OpenZeppelin"]}, {"title": "The price oracle temporarily goes offline during a time of high market volatility. This could result in the oracle not updating the asset prices until after the market has become insolvent. In this case, there will never have been an opportunity for liquidation to occur.", "body": "The price oracle temporarily goes offline during a time of high market volatility. This could result in the oracle not updating the asset prices until after the market has become insolvent. In this case, there will never have been an opportunity for liquidation to occur.", "html_url": "https://blog.openzeppelin.com/compound-audit#the-price-oracle-temporarily-goes-offline-during-a-time-of-high-market-volatility.-this-could-result-in-the-oracle-not-updating-the-asset-prices-until-after-the-market-has-become-insolvent.-in-this-case,-there-will-never-have-been-an-opportunity-for-liquidation-to-occur.", "labels": ["OpenZeppelin"]}, {"title": "The admin or oracle steals enough collateral that the market becomes insolvent.", "body": "The admin or oracle steals enough collateral that the market becomes insolvent.", "html_url": "https://blog.openzeppelin.com/compound-audit#the-admin-or-oracle-steals-enough-collateral-that-the-market-becomes-insolvent.", "labels": ["OpenZeppelin"]}, {"title": "Miners \u201csteal\u201d (by not paying interest) enough funds that the market eventually becomes insolvent. (See the \u201cInterest-Free Loans\u201d issue).", "body": "Miners \u201csteal\u201d (by not paying interest) enough funds that the market eventually becomes insolvent. (See the \u201cInterest-Free Loans\u201d issue).", "html_url": "https://blog.openzeppelin.com/compound-audit#miners-\u201csteal\u201d-(by-not-paying-interest)-enough-funds-that-the-market-eventually-becomes-insolvent.-(see-the-\u201cinterest-free-loans\u201d-issue).", "labels": ["OpenZeppelin"]}, {"title": "Administrators list an ERC20 token with a later-discovered bug that allows minting of arbitrarily many tokens. This bad token is used as collateral to borrow funds that it never intends to repay.", "body": "Administrators list an ERC20 token with a later-discovered bug that allows minting of arbitrarily many tokens. This bad token is used as collateral to borrow funds that it never intends to repay.", "html_url": "https://blog.openzeppelin.com/compound-audit#administrators-list-an-erc20-token-with-a-later-discovered-bug-that-allows-minting-of-arbitrarily-many-tokens.-this-bad-token-is-used-as-collateral-to-borrow-funds-that-it-never-intends-to-repay.", "labels": ["OpenZeppelin"]}, {"title": "In any case, the effects of an insolvent market could be disastrous. It would mean that cToken contracts would effectively be running a fractional reserve. This could result in a \u201crun on the bank\u201d, with the last suppliers out losing their money.", "body": "In any case, the effects of an insolvent market could be disastrous. It would mean that cToken contracts would effectively be running a fractional reserve. This could result in a \u201crun on the bank\u201d, with the last suppliers out losing their money.", "html_url": "https://blog.openzeppelin.com/compound-audit#in-any-case,-the-effects-of-an-insolvent-market-could-be-disastrous.-it-would-mean-that-ctoken-contracts-would-effectively-be-running-a-fractional-reserve.-this-could-result-in-a-\u201crun-on-the-bank\u201d,-with-the-last-suppliers-out-losing-their-money.", "labels": ["OpenZeppelin"]}, {"title": "This risk is not unique to Compound. All collateralized loans (even non-blockchain loans) have a risk of insolvency. However, it is important to know that this risk does exist, and that it can be difficult to recover from even a small dip into insolvency.", "body": "This risk is not unique to Compound. All collateralized loans (even non-blockchain loans) have a risk of insolvency. However, it is important to know that this risk does exist, and that it can be difficult to recover from even a small dip into insolvency.", "html_url": "https://blog.openzeppelin.com/compound-audit#this-risk-is-not-unique-to-compound.-all-collateralized-loans-(even-non-blockchain-loans)-have-a-risk-of-insolvency.-however,-it-is-important-to-know-that-this-risk-does-exist,-and-that-it-can-be-difficult-to-recover-from-even-a-small-dip-into-insolvency.", "labels": ["OpenZeppelin"]}, {"title": "Reserves Increased Event", "body": "Reserves Increased Event", "html_url": "https://blog.openzeppelin.com/compound-audit#reserves-increased-event", "labels": ["OpenZeppelin"]}, {"title": "The accrueInterest function of the CToken contract accrues interest and increases the reserves. However, the AccrueInterest event that it emits does not include the amount by which the reserves have increased. Consider adding this value to the AccrueInterest event or creating a new ReservesIncreased event to match the existing ReservesReduced event.", "body": "The accrueInterest function of the CToken contract accrues interest and increases the reserves. However, the AccrueInterest event that it emits does not include the amount by which the reserves have increased. Consider adding this value to the AccrueInterest event or creating a new ReservesIncreased event to match the existing ReservesReduced event.", "html_url": "https://blog.openzeppelin.com/compound-audit#the-accrueinterest-function-of-the-ctoken-contract-accrues-interest-and-increases-the-reserves.-however,-the-accrueinterest-event-that-it-emits-does-not-include-the-amount-by-which-the-reserves-have-increased.-consider-adding-this-value-to-the-accrueinterest-event-or-creating-a-new-reservesincreased-event-to-match-the-existing-reservesreduced-event.", "labels": ["OpenZeppelin"]}, {"title": "Multiple Contracts Per File", "body": "Multiple Contracts Per File", "html_url": "https://blog.openzeppelin.com/compound-audit#multiple-contracts-per-file", "labels": ["OpenZeppelin"]}, {"title": "The ErrorReporter file contains three independent contracts: ComptrollerErrorReporter, TokenErrorReporter and OracleErrorReporter. This does not follow the Solidity style guide and makes the code harder to read.", "body": "The ErrorReporter file contains three independent contracts: ComptrollerErrorReporter, TokenErrorReporter and OracleErrorReporter. This does not follow the Solidity style guide and makes the code harder to read.", "html_url": "https://blog.openzeppelin.com/compound-audit#the-errorreporter-file-contains-three-independent-contracts:-comptrollererrorreporter,-tokenerrorreporter-and-oracleerrorreporter.-this-does-not-follow-the-solidity-style-guide-and-makes-the-code-harder-to-read.", "labels": ["OpenZeppelin"]}, {"title": "Consider using a separate file for each contract.", "body": "Consider using a separate file for each contract.", "html_url": "https://blog.openzeppelin.com/compound-audit#consider-using-a-separate-file-for-each-contract.", "labels": ["OpenZeppelin"]}, {"title": "Inconsistent NatSpec Usage", "body": "Inconsistent NatSpec Usage", "html_url": "https://blog.openzeppelin.com/compound-audit#inconsistent-natspec-usage", "labels": ["OpenZeppelin"]}, {"title": "The docstrings of the contracts and functions are partially following the Ethereum Natural Specification Format (NatSpec). They use the tags sporadically. Consider adding the relevant missing tags to all contracts and functions.", "body": "The docstrings of the contracts and functions are partially following the Ethereum Natural Specification Format (NatSpec). They use the tags sporadically. Consider adding the relevant missing tags to all contracts and functions.", "html_url": "https://blog.openzeppelin.com/compound-audit#the-docstrings-of-the-contracts-and-functions-are-partially-following-the-ethereum-natural-specification-format-(natspec).-they-use-the-tags-sporadically.-consider-adding-the-relevant-missing-tags-to-all-contracts-and-functions.", "labels": ["OpenZeppelin"]}, {"title": "Incorrect Code Comments", "body": "Incorrect Code Comments", "html_url": "https://blog.openzeppelin.com/compound-audit#incorrect-code-comments", "labels": ["OpenZeppelin"]}, {"title": "The comment on line 906 of Comptroller.sol uses the variable newLiquidationDiscount when it should use newLiquidationIncentive.", "body": "The comment on line 906 of Comptroller.sol uses the variable newLiquidationDiscount when it should use newLiquidationIncentive.", "html_url": "https://blog.openzeppelin.com/compound-audit#the-comment-on-line-906-of-comptroller.sol-uses-the-variable-newliquidationdiscount-when-it-should-use-newliquidationincentive.", "labels": ["OpenZeppelin"]}, {"title": "The comment on line 298 of CToken.sol states that the transferVerify function checks for under-collateralization. In fact, that check is performed at the start of the function with the transferAllowed hook.", "body": "The comment on line 298 of CToken.sol states that the transferVerify function checks for under-collateralization. In fact, that check is performed at the start of the function with the transferAllowed hook.", "html_url": "https://blog.openzeppelin.com/compound-audit#the-comment-on-line-298-of-ctoken.sol-states-that-the-transferverify-function-checks-for-under-collateralization.-in-fact,-that-check-is-performed-at-the-start-of-the-function-with-the-transferallowed-hook.", "labels": ["OpenZeppelin"]}, {"title": "The comment on line 821 of CToken.sol states that redeemAmountIn is the amount of cTokens to redeem but it is the amount of underlying.", "body": "The comment on line 821 of CToken.sol states that redeemAmountIn is the amount of cTokens to redeem but it is the amount of underlying.", "html_url": "https://blog.openzeppelin.com/compound-audit#the-comment-on-line-821-of-ctoken.sol-states-that-redeemamountin-is-the-amount-of-ctokens-to-redeem-but-it-is-the-amount-of-underlying.", "labels": ["OpenZeppelin"]}, {"title": "The comments on line 821-822 of CToken.sol state that only one of redeemTokensIn or redeemAmountIn may be zero but in fact at least one must be zero and both may be zero.", "body": "The comments on line 821-822 of CToken.sol state that only one of redeemTokensIn or redeemAmountIn may be zero but in fact at least one must be zero and both may be zero.", "html_url": "https://blog.openzeppelin.com/compound-audit#the-comments-on-line-821-822-of-ctoken.sol-state-that-only-one-of-redeemtokensin-or-redeemamountin-may-be-zero-but-in-fact-at-least-one-must-be-zero-and-both-may-be-zero.", "labels": ["OpenZeppelin"]}, {"title": "The comment on line 322 of Comptroller.sol should state \u201cRequire tokens is non-zero or amount is also zero\u201d", "body": "The comment on line 322 of Comptroller.sol should state \u201cRequire tokens is non-zero or amount is also zero\u201d", "html_url": "https://blog.openzeppelin.com/compound-audit#the-comment-on-line-322-of-comptroller.sol-should-state-\u201crequire-tokens-is-non-zero-or-amount-is-also-zero\u201d", "labels": ["OpenZeppelin"]}, {"title": "Require Statement Without Error Message", "body": "Require Statement Without Error Message", "html_url": "https://blog.openzeppelin.com/compound-audit#require-statement-without-error-message", "labels": ["OpenZeppelin"]}, {"title": "There is a require statement on line 111 of CEther.sol with no failure message. Consider adding a message to inform users in case of a revert.", "body": "There is a require statement on line 111 of CEther.sol with no failure message. Consider adding a message to inform users in case of a revert.", "html_url": "https://blog.openzeppelin.com/compound-audit#there-is-a-require-statement-on-line-111-of-cether.sol-with-no-failure-message.-consider-adding-a-message-to-inform-users-in-case-of-a-revert.", "labels": ["OpenZeppelin"]}, {"title": "Non-traditional Use of ReentrancyGuard", "body": "Non-traditional Use of ReentrancyGuard", "html_url": "https://blog.openzeppelin.com/compound-audit#non-traditional-use-of-reentrancyguard", "labels": ["OpenZeppelin"]}, {"title": "The NatSpec documentation on ReentrancyGuard.sol states:", "body": "The NatSpec documentation on ReentrancyGuard.sol states:", "html_url": "https://blog.openzeppelin.com/compound-audit#the-natspec-documentation-on-reentrancyguard.sol-states:", "labels": ["OpenZeppelin"]}, {"title": "If you mark a function nonReentrant, you should also mark it external.", "body": "If you mark a function nonReentrant, you should also mark it external.", "html_url": "https://blog.openzeppelin.com/compound-audit#if-you-mark-a-function-nonreentrant,-you-should-also-mark-it-external.", "labels": ["OpenZeppelin"]}, {"title": "However, the following functions in CToken.sol have the nonReentrant modifier and are NOT external:", "body": "However, the following functions in CToken.sol have the nonReentrant modifier and are NOT external:", "html_url": "https://blog.openzeppelin.com/compound-audit#however,-the-following-functions-in-ctoken.sol-have-the-nonreentrant-modifier-and-are-not-external:", "labels": ["OpenZeppelin"]}, {"title": "exchangeRateCurrent (public)", "body": "exchangeRateCurrent (public)", "html_url": "https://blog.openzeppelin.com/compound-audit#exchangeratecurrent-(public)", "labels": ["OpenZeppelin"]}, {"title": "mintInternal (internal)", "body": "mintInternal (internal)", "html_url": "https://blog.openzeppelin.com/compound-audit#mintinternal-(internal)", "labels": ["OpenZeppelin"]}, {"title": "redeemInternal (internal)", "body": "redeemInternal (internal)", "html_url": "https://blog.openzeppelin.com/compound-audit#redeeminternal-(internal)", "labels": ["OpenZeppelin"]}, {"title": "redeemUnderlyingInternal (internal)", "body": "redeemUnderlyingInternal (internal)", "html_url": "https://blog.openzeppelin.com/compound-audit#redeemunderlyinginternal-(internal)", "labels": ["OpenZeppelin"]}, {"title": "borrowInternal (internal)", "body": "borrowInternal (internal)", "html_url": "https://blog.openzeppelin.com/compound-audit#borrowinternal-(internal)", "labels": ["OpenZeppelin"]}, {"title": "repayBorrowInternal (internal)", "body": "repayBorrowInternal (internal)", "html_url": "https://blog.openzeppelin.com/compound-audit#repayborrowinternal-(internal)", "labels": ["OpenZeppelin"]}, {"title": "repayBorrowBehalfInternal (internal)", "body": "repayBorrowBehalfInternal (internal)", "html_url": "https://blog.openzeppelin.com/compound-audit#repayborrowbehalfinternal-(internal)", "labels": ["OpenZeppelin"]}, {"title": "liquidateBorrowInternal (internal)", "body": "liquidateBorrowInternal (internal)", "html_url": "https://blog.openzeppelin.com/compound-audit#liquidateborrowinternal-(internal)", "labels": ["OpenZeppelin"]}, {"title": "Typically, the nonReentrant modifier would be put on their external function counterparts in CEther.sol and CErc20.sol. That said, the existing use of ReentrancyGuard does prevent reentry into the corresponding external functions, and so no changes are needed.", "body": "Typically, the nonReentrant modifier would be put on their external function counterparts in CEther.sol and CErc20.sol. That said, the existing use of ReentrancyGuard does prevent reentry into the corresponding external functions, and so no changes are needed.", "html_url": "https://blog.openzeppelin.com/compound-audit#typically,-the-nonreentrant-modifier-would-be-put-on-their-external-function-counterparts-in-cether.sol-and-cerc20.sol.-that-said,-the-existing-use-of-reentrancyguard-does-prevent-reentry-into-the-corresponding-external-functions,-and-so-no-changes-are-needed.", "labels": ["OpenZeppelin"]}, {"title": "Unvetted Token Warning", "body": "Unvetted Token Warning", "html_url": "https://blog.openzeppelin.com/compound-audit#unvetted-token-warning", "labels": ["OpenZeppelin"]}, {"title": "It is important to note that if a malicious or poorly-designed token is added to Compound, it could allow someone to steal all funds entrusted to Compound. For example, if anyone can arbitrarily change the totalSupply or account balances of a listed ERC20 token faster than the price oracle can adjust the price, an attacker could use those newly minted tokens as collateral to borrow all Compound assets.", "body": "It is important to note that if a malicious or poorly-designed token is added to Compound, it could allow someone to steal all funds entrusted to Compound. For example, if anyone can arbitrarily change the totalSupply or account balances of a listed ERC20 token faster than the price oracle can adjust the price, an attacker could use those newly minted tokens as collateral to borrow all Compound assets.", "html_url": "https://blog.openzeppelin.com/compound-audit#it-is-important-to-note-that-if-a-malicious-or-poorly-designed-token-is-added-to-compound,-it-could-allow-someone-to-steal-all-funds-entrusted-to-compound.-for-example,-if-anyone-can-arbitrarily-change-the-totalsupply-or-account-balances-of-a-listed-erc20-token-faster-than-the-price-oracle-can-adjust-the-price,-an-attacker-could-use-those-newly-minted-tokens-as-collateral-to-borrow-all-compound-assets.", "labels": ["OpenZeppelin"]}, {"title": "Consider making a formal list of properties that a \u201csafe\u201d token should and should not have, and be sure each new token is safe before listing it on Compound.", "body": "Consider making a formal list of properties that a \u201csafe\u201d token should and should not have, and be sure each new token is safe before listing it on Compound.", "html_url": "https://blog.openzeppelin.com/compound-audit#consider-making-a-formal-list-of-properties-that-a-\u201csafe\u201d-token-should-and-should-not-have,-and-be-sure-each-new-token-is-safe-before-listing-it-on-compound.", "labels": ["OpenZeppelin"]}, {"title": "Transparent Proxy Pattern", "body": "Transparent Proxy Pattern", "html_url": "https://blog.openzeppelin.com/compound-audit#transparent-proxy-pattern", "labels": ["OpenZeppelin"]}, {"title": "The Unitroller contract uses a proxy pattern to redirect transactions to functions it does not recognize. However, it will not be able to proxy calls to functions with the same function signature as one of its own functions, including its inherited functions.", "body": "The Unitroller contract uses a proxy pattern to redirect transactions to functions it does not recognize. However, it will not be able to proxy calls to functions with the same function signature as one of its own functions, including its inherited functions.", "html_url": "https://blog.openzeppelin.com/compound-audit#the-unitroller-contract-uses-a-proxy-pattern-to-redirect-transactions-to-functions-it-does-not-recognize.-however,-it-will-not-be-able-to-proxy-calls-to-functions-with-the-same-function-signature-as-one-of-its-own-functions,-including-its-inherited-functions.", "labels": ["OpenZeppelin"]}, {"title": "Consider using the transparent proxy pattern for increased generality.", "body": "Consider using the transparent proxy pattern for increased generality.", "html_url": "https://blog.openzeppelin.com/compound-audit#consider-using-the-transparent-proxy-pattern-for-increased-generality.", "labels": ["OpenZeppelin"]}, {"title": "Unused Return Value", "body": "Unused Return Value", "html_url": "https://blog.openzeppelin.com/compound-audit#unused-return-value", "labels": ["OpenZeppelin"]}, {"title": "The getUtilizationAndAnnualBorrowRate function of the WhitePaperInterestRateModel contract returns the utilization rate in addition to the borrow rate. However, the only function that calls it discards the utilization rate. Consider removing the utilization rate from the return values.", "body": "The getUtilizationAndAnnualBorrowRate function of the WhitePaperInterestRateModel contract returns the utilization rate in addition to the borrow rate. However, the only function that calls it discards the utilization rate. Consider removing the utilization rate from the return values.", "html_url": "https://blog.openzeppelin.com/compound-audit#the-getutilizationandannualborrowrate-function-of-the-whitepaperinterestratemodel-contract-returns-the-utilization-rate-in-addition-to-the-borrow-rate.-however,-the-only-function-that-calls-it-discards-the-utilization-rate.-consider-removing-the-utilization-rate-from-the-return-values.", "labels": ["OpenZeppelin"]}, {"title": "collateralFactorMantissa Needs to be Set", "body": "collateralFactorMantissa Needs to be Set", "html_url": "https://blog.openzeppelin.com/compound-audit#collateralfactormantissa-needs-to-be-set", "labels": ["OpenZeppelin"]}, {"title": "In Comptroller.sol, collateralFactorMantissa for each market is initialized implicitly to 0 until it is set within _setCollateralFactor. This means that whenever a new market is created, a second transaction must be submitted to set the collateral factor. If this doesn\u2019t happen, account liquidity contributions for that market will be 0.", "body": "In Comptroller.sol, collateralFactorMantissa for each market is initialized implicitly to 0 until it is set within _setCollateralFactor. This means that whenever a new market is created, a second transaction must be submitted to set the collateral factor. If this doesn\u2019t happen, account liquidity contributions for that market will be 0.", "html_url": "https://blog.openzeppelin.com/compound-audit#in-comptroller.sol,-collateralfactormantissa-for-each-market-is-initialized-implicitly-to-0-until-it-is-set-within-_setcollateralfactor.-this-means-that-whenever-a-new-market-is-created,-a-second-transaction-must-be-submitted-to-set-the-collateral-factor.-if-this-doesn\u2019t-happen,-account-liquidity-contributions-for-that-market-will-be-0.", "labels": ["OpenZeppelin"]}, {"title": "Consider Adding Syntax Highlighting to GitHub Repository", "body": "Consider Adding Syntax Highlighting to GitHub Repository", "html_url": "https://blog.openzeppelin.com/compound-audit#consider-adding-syntax-highlighting-to-github-repository", "labels": ["OpenZeppelin"]}, {"title": "Consider adding Solidity syntax highlighting to the GitHub repository by putting the line *.sol linguist-language=Solidity in a .gitattributes file in the root of the repository.", "body": "Consider adding Solidity syntax highlighting to the GitHub repository by putting the line *.sol linguist-language=Solidity in a .gitattributes file in the root of the repository.", "html_url": "https://blog.openzeppelin.com/compound-audit#consider-adding-solidity-syntax-highlighting-to-the-github-repository-by-putting-the-line-*.sol-linguist-language=solidity-in-a-.gitattributes-file-in-the-root-of-the-repository.", "labels": ["OpenZeppelin"]}, {"title": "This helps improve readability for users inspecting contract code on GitHub.", "body": "This helps improve readability for users inspecting contract code on GitHub.", "html_url": "https://blog.openzeppelin.com/compound-audit#this-helps-improve-readability-for-users-inspecting-contract-code-on-github.", "labels": ["OpenZeppelin"]}, {"title": "Accrue Zero Interest Event", "body": "Accrue Zero Interest Event", "html_url": "https://blog.openzeppelin.com/compound-audit#accrue-zero-interest-event", "labels": ["OpenZeppelin"]}, {"title": "In the accrueInterest function of CToken, the AccrueInterest event is still emitted when there is no interest (because it was already accrued in this block). Consider checking the accrualBlockNumber before emitting the event (or indeed, executing the rest of the function).", "body": "In the accrueInterest function of CToken, the AccrueInterest event is still emitted when there is no interest (because it was already accrued in this block). Consider checking the accrualBlockNumber before emitting the event (or indeed, executing the rest of the function).", "html_url": "https://blog.openzeppelin.com/compound-audit#in-the-accrueinterest-function-of-ctoken,-the-accrueinterest-event-is-still-emitted-when-there-is-no-interest-(because-it-was-already-accrued-in-this-block).-consider-checking-the-accrualblocknumber-before-emitting-the-event-(or-indeed,-executing-the-rest-of-the-function).", "labels": ["OpenZeppelin"]}, {"title": "Unexpected ERC20\u2019s", "body": "Unexpected ERC20\u2019s", "html_url": "https://blog.openzeppelin.com/compound-audit#unexpected-erc20\u2019s", "labels": ["OpenZeppelin"]}, {"title": "Within each of the cToken ERC20 contracts, there is no way to check for unexpected sends of ERC20 tokens to the contract. However, the ERC20 balance is used in the exchangeRate calculation via the variable totalCash, which is equal to the ERC20 token balance.", "body": "Within each of the cToken ERC20 contracts, there is no way to check for unexpected sends of ERC20 tokens to the contract. However, the ERC20 balance is used in the exchangeRate calculation via the variable totalCash, which is equal to the ERC20 token balance.", "html_url": "https://blog.openzeppelin.com/compound-audit#within-each-of-the-ctoken-erc20-contracts,-there-is-no-way-to-check-for-unexpected-sends-of-erc20-tokens-to-the-contract.-however,-the-erc20-balance-is-used-in-the-exchangerate-calculation-via-the-variable-totalcash,-which-is-equal-to-the-erc20-token-balance.", "labels": ["OpenZeppelin"]}, {"title": "This results in cToken values increasing with ERC20 sends, but importantly, it does not result in the value of borrows increasing, as borrowIndex is unaffected by total underlying balance.", "body": "This results in cToken values increasing with ERC20 sends, but importantly, it does not result in the value of borrows increasing, as borrowIndex is unaffected by total underlying balance.", "html_url": "https://blog.openzeppelin.com/compound-audit#this-results-in-ctoken-values-increasing-with-erc20-sends,-but-importantly,-it-does-not-result-in-the-value-of-borrows-increasing,-as-borrowindex-is-unaffected-by-total-underlying-balance.", "labels": ["OpenZeppelin"]}, {"title": "Consider adding a state variable to track internal balances, which would help identify any unexpected ERC20 tokens.", "body": "Consider adding a state variable to track internal balances, which would help identify any unexpected ERC20 tokens.", "html_url": "https://blog.openzeppelin.com/compound-audit#consider-adding-a-state-variable-to-track-internal-balances,-which-would-help-identify-any-unexpected-erc20-tokens.", "labels": ["OpenZeppelin"]}, {"title": "Avoid Overloaded Functions", "body": "Avoid Overloaded Functions", "html_url": "https://blog.openzeppelin.com/compound-audit#avoid-overloaded-functions", "labels": ["OpenZeppelin"]}, {"title": "Within Exponential.sol there are two definitions for mulExp() (here, and here). Consider changing the name of one of the functions for improved readability of code.", "body": "Within Exponential.sol there are two definitions for mulExp() (here, and here). Consider changing the name of one of the functions for improved readability of code.", "html_url": "https://blog.openzeppelin.com/compound-audit#within-exponential.sol-there-are-two-definitions-for-mulexp()-(here,-and-here).-consider-changing-the-name-of-one-of-the-functions-for-improved-readability-of-code.", "labels": ["OpenZeppelin"]}, {"title": "Use ABI Encoder", "body": "Use ABI Encoder", "html_url": "https://blog.openzeppelin.com/compound-audit#use-abi-encoder", "labels": ["OpenZeppelin"]}, {"title": "The requireNoError function in the CEther contract appends a string to another string one byte at a time. Consider commenting the operation for clarity and using abi.encodePacked for brevity.", "body": "The requireNoError function in the CEther contract appends a string to another string one byte at a time. Consider commenting the operation for clarity and using abi.encodePacked for brevity.", "html_url": "https://blog.openzeppelin.com/compound-audit#the-requirenoerror-function-in-the-cether-contract-appends-a-string-to-another-string-one-byte-at-a-time.-consider-commenting-the-operation-for-clarity-and-using-abi.encodepacked-for-brevity.", "labels": ["OpenZeppelin"]}, {"title": "Missing require", "body": "Missing require", "html_url": "https://blog.openzeppelin.com/compound-audit#missing-require", "labels": ["OpenZeppelin"]}, {"title": "sanity check in the", "body": "sanity check in the", "html_url": "https://blog.openzeppelin.com/compound-audit#sanity-check-in-the", "labels": ["OpenZeppelin"]}, {"title": "Default Visibility", "body": "Default Visibility", "html_url": "https://blog.openzeppelin.com/compound-audit#default-visibility", "labels": ["OpenZeppelin"]}, {"title": "The following state variables and constants are using the default visibility:", "body": "The following state variables and constants are using the default visibility:", "html_url": "https://blog.openzeppelin.com/compound-audit#the-following-state-variables-and-constants-are-using-the-default-visibility:", "labels": ["OpenZeppelin"]}, {"title": "In Comptroller:closeFactorMinMantissa, closeFactorMaxMantissa, collateralFactorMaxMantissa, liquidationIncentiveMinMantissa, liquidationIncentiveMaxMantissa", "body": "In Comptroller:closeFactorMinMantissa, closeFactorMaxMantissa, collateralFactorMaxMantissa, liquidationIncentiveMinMantissa, liquidationIncentiveMaxMantissa", "html_url": "https://blog.openzeppelin.com/compound-audit#in-comptroller:closefactorminmantissa,-closefactormaxmantissa,-collateralfactormaxmantissa,-liquidationincentiveminmantissa,-liquidationincentivemaxmantissa", "labels": ["OpenZeppelin"]}, {"title": "In CToken:borrowRateMaxMantissa, reserveFactorMaxMantissa, accountTokens,transferAllowances, accountBorrows", "body": "In CToken:borrowRateMaxMantissa, reserveFactorMaxMantissa, accountTokens,transferAllowances, accountBorrows", "html_url": "https://blog.openzeppelin.com/compound-audit#in-ctoken:borrowratemaxmantissa,-reservefactormaxmantissa,-accounttokens,transferallowances,-accountborrows", "labels": ["OpenZeppelin"]}, {"title": "In Exponential:expScale, halfExpScale, mantissaOne", "body": "In Exponential:expScale, halfExpScale, mantissaOne", "html_url": "https://blog.openzeppelin.com/compound-audit#in-exponential:expscale,-halfexpscale,-mantissaone", "labels": ["OpenZeppelin"]}, {"title": "For readability, consider explicitly declaring the visibility of all state variables.", "body": "For readability, consider explicitly declaring the visibility of all state variables.", "html_url": "https://blog.openzeppelin.com/compound-audit#for-readability,-consider-explicitly-declaring-the-visibility-of-all-state-variables.", "labels": ["OpenZeppelin"]}, {"title": "TODO\u2019s in Code", "body": "TODO\u2019s in Code", "html_url": "https://blog.openzeppelin.com/compound-audit#todo\u2019s-in-code", "labels": ["OpenZeppelin"]}, {"title": "Exponential,", "body": "Unitroller, and  1306,  1405,  1455,  1465 and  1525 ), despite being used in production.  Consider resolving and removing them.  Superfluous Code in acceptAdmin  On line 1333 of CToken.sol there is the conditional statement:  if (msg.sender != pendingAdmin || msg.sender == address(0)) ...  The comment immediately above this line is:  // Check caller is pendingAdmin and pendingAdmin \u2260 address(0)  This comment suggests that the conditional on line 1333 was intended to be:  if (msg.sender != pendingAdmin || pendingAdmin == address(0)) ...  In either case, however, the second half of the conditional is superfluous. It is infeasible for msg.sender to be the zero address. Thus, the conditional statement can be reduced to:  if (msg.sender != pendingAdmin) ....  Change uint to uint256  Throughout the code base, some variables are declared as uint. To favor explicitness, consider changing all instances of uint to uint256.  Use assert  The require statement on line 1476 of CToken.sol is confirming a property that should never fail for any user input. In such a situation, consider using an assert statement instead.  Conclusion  No critical and two high severity issues were found. Some changes were proposed to follow best practices and reduce potential attack surface.  Summary  If you are interested in a non-technical overview of this audit, we present a summary of the system as it relates to the audit as well as a couple of interesting findings in our summary article.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/compound-audit#exponential,", "labels": ["OpenZeppelin"]}, {"title": "Unitroller, and", "body": "Unitroller, and", "html_url": "https://blog.openzeppelin.com/compound-audit#unitroller,-and", "labels": ["OpenZeppelin"]}, {"title": "1306,", "body": "1306,", "html_url": "https://blog.openzeppelin.com/compound-audit#1306,", "labels": ["OpenZeppelin"]}, {"title": "1405,", "body": "1405,", "html_url": "https://blog.openzeppelin.com/compound-audit#1405,", "labels": ["OpenZeppelin"]}, {"title": "1455,", "body": "1455,", "html_url": "https://blog.openzeppelin.com/compound-audit#1455,", "labels": ["OpenZeppelin"]}, {"title": "1465 and", "body": "1465 and", "html_url": "https://blog.openzeppelin.com/compound-audit#1465-and", "labels": ["OpenZeppelin"]}, {"title": "1525 ), despite being used in production.", "body": "1525 ), despite being used in production.", "html_url": "https://blog.openzeppelin.com/compound-audit#1525-),-despite-being-used-in-production.", "labels": ["OpenZeppelin"]}, {"title": "Consider resolving and removing them.", "body": "Consider resolving and removing them.", "html_url": "https://blog.openzeppelin.com/compound-audit#consider-resolving-and-removing-them.", "labels": ["OpenZeppelin"]}, {"title": "Superfluous Code in acceptAdmin", "body": "Superfluous Code in acceptAdmin", "html_url": "https://blog.openzeppelin.com/compound-audit#superfluous-code-in-acceptadmin", "labels": ["OpenZeppelin"]}, {"title": "On line 1333 of CToken.sol there is the conditional statement:", "body": "On line 1333 of CToken.sol there is the conditional statement:", "html_url": "https://blog.openzeppelin.com/compound-audit#on-line-1333-of-ctoken.sol-there-is-the-conditional-statement:", "labels": ["OpenZeppelin"]}, {"title": "if (msg.sender != pendingAdmin || msg.sender == address(0)) ...", "body": "if (msg.sender != pendingAdmin || msg.sender == address(0)) ...", "html_url": "https://blog.openzeppelin.com/compound-audit#if-(msg.sender-!=-pendingadmin-||-msg.sender-==-address(0))-...", "labels": ["OpenZeppelin"]}, {"title": "The comment immediately above this line is:", "body": "The comment immediately above this line is:", "html_url": "https://blog.openzeppelin.com/compound-audit#the-comment-immediately-above-this-line-is:", "labels": ["OpenZeppelin"]}, {"title": "// Check caller is pendingAdmin and pendingAdmin \u2260 address(0)", "body": "// Check caller is pendingAdmin and pendingAdmin \u2260 address(0)", "html_url": "https://blog.openzeppelin.com/compound-audit#//-check-caller-is-pendingadmin-and-pendingadmin-\u2260-address(0)", "labels": ["OpenZeppelin"]}, {"title": "This comment suggests that the conditional on line 1333 was intended to be:", "body": "This comment suggests that the conditional on line 1333 was intended to be:", "html_url": "https://blog.openzeppelin.com/compound-audit#this-comment-suggests-that-the-conditional-on-line-1333-was-intended-to-be:", "labels": ["OpenZeppelin"]}, {"title": "if (msg.sender != pendingAdmin || pendingAdmin == address(0)) ...", "body": "if (msg.sender != pendingAdmin || pendingAdmin == address(0)) ...", "html_url": "https://blog.openzeppelin.com/compound-audit#if-(msg.sender-!=-pendingadmin-||-pendingadmin-==-address(0))-...", "labels": ["OpenZeppelin"]}, {"title": "In either case, however, the second half of the conditional is superfluous. It is infeasible for msg.sender to be the zero address. Thus, the conditional statement can be reduced to:", "body": "In either case, however, the second half of the conditional is superfluous. It is infeasible for msg.sender to be the zero address. Thus, the conditional statement can be reduced to:", "html_url": "https://blog.openzeppelin.com/compound-audit#in-either-case,-however,-the-second-half-of-the-conditional-is-superfluous.-it-is-infeasible-for-msg.sender-to-be-the-zero-address.-thus,-the-conditional-statement-can-be-reduced-to:", "labels": ["OpenZeppelin"]}, {"title": "if (msg.sender != pendingAdmin) ....", "body": "if (msg.sender != pendingAdmin) ....", "html_url": "https://blog.openzeppelin.com/compound-audit#if-(msg.sender-!=-pendingadmin)-....", "labels": ["OpenZeppelin"]}, {"title": "Change uint to uint256", "body": "Change uint to uint256", "html_url": "https://blog.openzeppelin.com/compound-audit#change-uint-to-uint256", "labels": ["OpenZeppelin"]}, {"title": "Throughout the code base, some variables are declared as uint. To favor explicitness, consider changing all instances of uint to uint256.", "body": "Throughout the code base, some variables are declared as uint. To favor explicitness, consider changing all instances of uint to uint256.", "html_url": "https://blog.openzeppelin.com/compound-audit#throughout-the-code-base,-some-variables-are-declared-as-uint.-to-favor-explicitness,-consider-changing-all-instances-of-uint-to-uint256.", "labels": ["OpenZeppelin"]}, {"title": "Use assert", "body": "Use assert", "html_url": "https://blog.openzeppelin.com/compound-audit#use-assert", "labels": ["OpenZeppelin"]}, {"title": "The require statement on line 1476 of CToken.sol is confirming a property that should never fail for any user input. In such a situation, consider using an assert statement instead.", "body": "The require statement on line 1476 of CToken.sol is confirming a property that should never fail for any user input. In such a situation, consider using an assert statement instead.", "html_url": "https://blog.openzeppelin.com/compound-audit#the-require-statement-on-line-1476-of-ctoken.sol-is-confirming-a-property-that-should-never-fail-for-any-user-input.-in-such-a-situation,-consider-using-an-assert-statement-instead.", "labels": ["OpenZeppelin"]}, {"title": "None.", "body": "None.", "html_url": "https://blog.openzeppelin.com/solo-margin-protocol-audit-30ac2aaf6b10#none.", "labels": ["OpenZeppelin"]}, {"title": "Contracts using the experimental ABIEncoderV2", "body": "Contracts using the experimental ABIEncoderV2", "html_url": "https://blog.openzeppelin.com/solo-margin-protocol-audit-30ac2aaf6b10#contracts-using-the-experimental-abiencoderv2", "labels": ["OpenZeppelin"]}, {"title": "The Solo project uses features from the ABIEncoderV2 of Solidity. This new version of the encoder is still experimental. Since the release of Solidity v0.5.4 (the one used by the Solo project), two new versions of Solidity have been released fixing important issues in this encoder.", "body": "The Solo project uses features from the ABIEncoderV2 of Solidity. This new version of the encoder is still experimental. Since the release of Solidity v0.5.4 (the one used by the Solo project), two new versions of Solidity have been released fixing important issues in this encoder.", "html_url": "https://blog.openzeppelin.com/solo-margin-protocol-audit-30ac2aaf6b10#the-solo-project-uses-features-from-the-abiencoderv2-of-solidity.-this-new-version-of-the-encoder-is-still-experimental.-since-the-release-of-solidity-v0.5.4-(the-one-used-by-the-solo-project),-two-new-versions-of-solidity-have-been-released-fixing-important-issues-in-this-encoder.", "labels": ["OpenZeppelin"]}, {"title": "Because the ABIEncoderV2 is experimental, it would be risky to release the project using it. Moreover, the recent findings show that it is likely that other important bugs are yet to be found.", "body": "Because the ABIEncoderV2 is experimental, it would be risky to release the project using it. Moreover, the recent findings show that it is likely that other important bugs are yet to be found.", "html_url": "https://blog.openzeppelin.com/solo-margin-protocol-audit-30ac2aaf6b10#because-the-abiencoderv2-is-experimental,-it-would-be-risky-to-release-the-project-using-it.-moreover,-the-recent-findings-show-that-it-is-likely-that-other-important-bugs-are-yet-to-be-found.", "labels": ["OpenZeppelin"]}, {"title": "As mentioned in the recent bug announcement, most of the issues of the encoder will have impact on the functionality of the contracts. So the risk can be mitigated by being extra thorough on the testing process of the project at all levels.", "body": "As mentioned in the recent bug announcement, most of the issues of the encoder will have impact on the functionality of the contracts. So the risk can be mitigated by being extra thorough on the testing process of the project at all levels.", "html_url": "https://blog.openzeppelin.com/solo-margin-protocol-audit-30ac2aaf6b10#as-mentioned-in-the-recent-bug-announcement,-most-of-the-issues-of-the-encoder-will-have-impact-on-the-functionality-of-the-contracts.-so-the-risk-can-be-mitigated-by-being-extra-thorough-on-the-testing-process-of-the-project-at-all-levels.", "labels": ["OpenZeppelin"]}, {"title": "However, even with great tests there is always a chance to miss important issues that will affect the project. Consider also more conservative options, like implementing upgrade, migration or pause functionalities, delaying the release until the ABIEncoderV2 is stable, or rewriting the project to use the current stable encoder.", "body": "However, even with great tests there is always a chance to miss important issues that will affect the project. Consider also more conservative options, like implementing upgrade, migration or pause functionalities, delaying the release until the ABIEncoderV2 is stable, or rewriting the project to use the current stable encoder.", "html_url": "https://blog.openzeppelin.com/solo-margin-protocol-audit-30ac2aaf6b10#however,-even-with-great-tests-there-is-always-a-chance-to-miss-important-issues-that-will-affect-the-project.-consider-also-more-conservative-options,-like-implementing-upgrade,-migration-or-pause-functionalities,-delaying-the-release-until-the-abiencoderv2-is-stable,-or-rewriting-the-project-to-use-the-current-stable-encoder.", "labels": ["OpenZeppelin"]}, {"title": "Update: Statement from the dYdX team about this issue: \u201cThe AbiEncoderV2 has been used in production for months without incident by other high-profile protocols such as 0x Version 2. We do not see its use as a larger security risk than using the Solidity compiler in general. We have also upgraded the compiler version to v0.5.7 since beginning the Audit (which fixes the aforementioned bugs).\u201d", "body": "Update: Statement from the dYdX team about this issue: \u201cThe AbiEncoderV2 has been used in production for months without incident by other high-profile protocols such as 0x Version 2. We do not see its use as a larger security risk than using the Solidity compiler in general. We have also upgraded the compiler version to v0.5.7 since beginning the Audit (which fixes the aforementioned bugs).\u201d", "html_url": "https://blog.openzeppelin.com/solo-margin-protocol-audit-30ac2aaf6b10#update:-statement-from-the-dydx-team-about-this-issue:-\u201cthe-abiencoderv2-has-been-used-in-production-for-months-without-incident-by-other-high-profile-protocols-such-as-0x-version-2.-we-do-not-see-its-use-as-a-larger-security-risk-than-using-the-solidity-compiler-in-general.-we-have-also-upgraded-the-compiler-version-to-v0.5.7-since-beginning-the-audit-(which-fixes-the-aforementioned-bugs).\u201d", "labels": ["OpenZeppelin"]}, {"title": "Malicious AutoTrader contracts may steal\u00a0funds", "body": "Malicious AutoTrader contracts may steal\u00a0funds", "html_url": "https://blog.openzeppelin.com/solo-margin-protocol-audit-30ac2aaf6b10#malicious-autotrader-contracts-may-steal\u00a0funds", "labels": ["OpenZeppelin"]}, {"title": "The Solo contract allows a user to set any contract as their AutoTrader. If a user makes a trade with an attacker using a malicious AutoTrader, the attacker may front-run the trade with a transaction that changes the rate returned by the AutoTrader\u2018s getTradeCost() effectively allowing the attacker to steal the full amount of the trade.", "body": "The Solo contract allows a user to set any contract as their AutoTrader. If a user makes a trade with an attacker using a malicious AutoTrader, the attacker may front-run the trade with a transaction that changes the rate returned by the AutoTrader\u2018s getTradeCost() effectively allowing the attacker to steal the full amount of the trade.", "html_url": "https://blog.openzeppelin.com/solo-margin-protocol-audit-30ac2aaf6b10#the-solo-contract-allows-a-user-to-set-any-contract-as-their-autotrader.-if-a-user-makes-a-trade-with-an-attacker-using-a-malicious-autotrader,-the-attacker-may-front-run-the-trade-with-a-transaction-that-changes-the-rate-returned-by-the-autotrader\u2018s-gettradecost()-effectively-allowing-the-attacker-to-steal-the-full-amount-of-the-trade.", "labels": ["OpenZeppelin"]}, {"title": "This can be prevented by only allowing users to interact with approved AutoTrader contracts on the front-end. However, it would be best to prevent this attack on-chain rather than relying on off-chain protections.", "body": "This can be prevented by only allowing users to interact with approved AutoTrader contracts on the front-end. However, it would be best to prevent this attack on-chain rather than relying on off-chain protections.", "html_url": "https://blog.openzeppelin.com/solo-margin-protocol-audit-30ac2aaf6b10#this-can-be-prevented-by-only-allowing-users-to-interact-with-approved-autotrader-contracts-on-the-front-end.-however,-it-would-be-best-to-prevent-this-attack-on-chain-rather-than-relying-on-off-chain-protections.", "labels": ["OpenZeppelin"]}, {"title": "Consider adding a whitelist of AutoTrader contracts or AutoTrader factories to restrict the possible implementations on-chain.", "body": "Consider adding a whitelist of AutoTrader contracts or AutoTrader factories to restrict the possible implementations on-chain.", "html_url": "https://blog.openzeppelin.com/solo-margin-protocol-audit-30ac2aaf6b10#consider-adding-a-whitelist-of-autotrader-contracts-or-autotrader-factories-to-restrict-the-possible-implementations-on-chain.", "labels": ["OpenZeppelin"]}, {"title": "Note: This issue was downgraded from critical severity because the dYdX team is aware of the issue and has plans for off-chain mitigation.", "body": "Note: This issue was downgraded from critical severity because the dYdX team is aware of the issue and has plans for off-chain mitigation.", "html_url": "https://blog.openzeppelin.com/solo-margin-protocol-audit-30ac2aaf6b10#note:-this-issue-was-downgraded-from-critical-severity-because-the-dydx-team-is-aware-of-the-issue-and-has-plans-for-off-chain-mitigation.", "labels": ["OpenZeppelin"]}, {"title": "Missing docstrings", "body": "issue reported above. Some other parts can be improved by following the rule of low coupling and high cohesion. And some others by making layers of code as minimal as possible, which has the added benefit of reducing the attack surface and making each layer easier to test.  Following are examples of encapsulation pain points that made it difficult to review the Solo code, or possible improvements for the encapsulation design.  Rather than passing the entire State struct into functions, only pass in the specific pieces of state that will be operated on. This makes it easier to understand what a function is doing and ensures only the intended pieces of state are changed.  There is a circular dependency between the Storage and Cache contracts. As suggested above, consider passing in only the necessary parameters rather a State struct to Cache.addMarket() to remove Caches dependency on Storage.  There is a contract called Getters. This fails at cohesion because it is too generic and it is too far from the setter functions and the state it is querying. Consider moving all the getter and setter functions, and state variables they manipulate, to the same contract.  The same functionality to revert if a market does not exist is implemented in two different contracts: requireValidMarket in Getters.sol and validateMarketId in AdminImpl.sol. Consider moving this function to a single place, either the Storage library or the State contract.  The getMarketCurrentIndex function calls the fetchNewIndex function of the Storage library, passing as an argument the return value of a function of the same Storage library. Instead of calling two functions from the same library in a single statement, consider defining a new function fetchCurrentIndex in the Storage library.  The Admin contract is just a thin layer that adds security modifiers to the AdminImpl contract where it forwards all the calls. This means that AdminImpl is not usable on its own because it is not safe. Consider moving all the implementations into the Admin contract and dropping AdminImpl. It could make sense to define an interface to specify the Administrator functions in a clear way, and to make it easy to have alternate implementations.  When an index is updated, the corresponding event is emitted by OperationImpl. Consider emitting the event inside the updateIndex function. This would be a clearer assignment of responsibilities, and it ensures that it is not possible to update the index and forget to emit the event.  When the more readable design cannot be implemented because of the Ethereum contract size limitations, consider explaining this in the comments of the source code, and supplement the sub-optimal implementation with extra comments to guide the readers and future contributors.  Low Severity  README is missing important information  The README.md files on the root of the git repositories are the first documents that most developers will read, so they should be complete, clear, concise and accurate.  The README.md of the Solo project has little information about what is the purpose of the project and how to use it.  Consider following Standard Readme to define the structure and contents for the README.md file. Consider including an explanation of the core concepts of the repository, the usage workflows, the public APIs, instructions to test and deploy it, and how it relates to other parts of the project.  Make sure to include instructions for the responsible disclosure of any security vulnerabilities found in the project.  #219  #243  Allowed non-standard ERC20 tokens should be explicitly specified  Since non-standard ERC20 tokens are allowed to be used in markets, the behavior of these tokens should be explicitly specified in comments or the README. All ERC20 tokens that make up markets should abide by these specified conditions in order to be accepted as a market. Certain non-standard implementations may cause undesired effects on the dYdX contracts.  As mentioned in the comments in the code, a custom ERC20 interface is used in order to deal with tokens that dont adhere strictly to the ERC20 standard (for example tokens that dont return a boolean value on success). Because of this lack of return value, the code allows for a number of non-standard ERC20 implementations, rather than just the one mentioned in the comments.  Token.sol.  This ERC20 implementation would cause issues with Dapps other than dYdX, so it is expected that this type of token never makes it into production on the main Ethereum network. Nevertheless, we suggest being explicit about the types of tokens that are allowed to make up a market and checking that tokens meet these conditions prior to being accepted as a market.  Global operators are not restricted to contract addresses  The Solo contract allows global operators to operate on behalf of any account. The motivation behind the global operator feature is to allow for things such as a wrapped Ether proxy and automatic loan expiry. Because the intention is for the global operator to always be a contract, consider adding a sanity check using OpenZeppelins isContract() function to ensure regular accounts can not be added as global operators and to be more explicit about the intention of the feature.  There are magic constants in the code  There are magic constants in several Solo contracts. For example, Require.sol, line 203 and Require.sol, line 207. These values make the code harder to understand and to maintain.  Consider defining a constant variable for every hard-coded value (including booleans), giving it a clear and explanatory name. For complex values, consider adding a comment explaining how they were calculated or why they were chosen.  Update: Comments were added to the constants in pull request #233.  stringify() for bytes32 may unexpectedly truncate data  Require.sol, the  Update: Fixed in pull request #214.  Interest rate calculation may be error prone  The Solo contracts calculate interest accumulated over time by incrementing an index which represents the total accumulated interest with a starting value of 1. The index is updated by taking the per-second interest rate and multiplying by the number of seconds elapsed since the last time the index was updated (percentageInterestSinceLastUpdate = perSecondRate * (currentTime - lastUpdatedTime)). This number represents the percentage gained since the last calculation and is multiplied by the previous index value to calculate the updated index value (index = index * (1 + percentageInterestSinceLastUpdate)).  This calculation differs from the true calculation which would calculate percentageInterestSinceLastUpdate like so: percentageInterestSinceLastUpdate = (currentTime - lastUpdated) ^ marginalRate. The differences between the calculation used and the true calculation are negligible when the index is updated fairly frequently but start to diverge as the index is updated less frequently. Consider implementing the true interest calculation or properly documenting the current interest calculation.  Update: The function was better documented in pull request #218.  Nonreentrant functions should be marked external  As stated in ReentrancyGuard.sol, calling a nonReentrant function from another nonReentrant function is not supported. All nonreentrant functions should be marked as external rather than public to enforce this more explicitly.  However, Solidity does not yet support structs as arguments of external functions (see issue #5479). Consider adding a comment to prevent developers to call these nonReentrant functions from the same contract.  Using Wei to refer to the minimum unit of a token  The Solo project uses the word Wei to refer to the minimum and indivisible unit of a token. 1 wei in Ethereum is equal to 10^-18 ether. While most tokens follow the same convention of having a human-readable unit with 18 decimals, many tokens define a different number of decimals. In addition to that, most tokens leave their minimum unit nameless, using the prefix of the International System of Units to refer to it (for example, attoToken for 1 token * 10^-18), instead of calling it Wei. This important detail is only mentioned once in the codebase.  There is no consistent way to call this minimum unit, and it could be very confusing to use Wei when the token has a different number of decimals. Consider using an alternative name that is clearer and less loaded, like BaseUnit or (as Matt Condon has suggested) TokenBits. Also consider documenting the expected unit on all the functions that receive a token amount as an argument.  Multiple operations in single statement  To increase code readability, avoid combining independent operations into a single line of code. In Require.sol, in the stringify(uint256) function, the variable k is decremented on the same line as it is used to access an array. Consider decrementing k on the line following the array access.  Update: Fixed in pull request #214.  Not following the Checks-Effects-Interactions Pattern  Solidity recommends the usage of the Check-Effects-Interaction Pattern to avoid potential problems, like reentrancy.  In a couple of places the code of Solo the checks are not done first:  The invalid oracle price check in_setPriceOracle.  The primary account check in verifyFinalState.  While in these cases there is no risk of reentrancy, consider moving the checks to the start of the corresponding block to make sure that no issues are introduced by later changes.  pull request #193  does not plan to update the  _verifyFinalState  function  Unexpected return value from Time.hasHappened()  The hasHappened() function in the Time library will return false if the time is 0 instead of reverting. In the future, this may lead to a false positive if the function is being used to check if something hasnt happened yet. Consider reverting when the input value is 0.  Update: Fixed in pull request #220.  Unused import  In Monetary.sol it is unnecessary to import the SafeMath and Math libraries as they are never used.  Update: Fixed in pull request #210.  Notes  Some contract files include the pragma experimental ABIEncoderV2; (for example, Admin.sol) and some others do not include it (for example, Decimal.sol). The effect of declaring the experimental pragma only on some files is not very clear. Consider declaring the usage of ABIEncoderV2 on all the Solidity files, for consistency, to make it clear that the new version of the encoder is used in the project, and to avoid any complications that can come for not declaring it in some files.Update: Fixed in pull request #229.  Explicitly type cast integers before making a comparison between different types in the following locations:In Math.sol: line 77 line 93 line 109In Types.sol: line 98 line 102 line 105 line 211 line 215 line 218  In Decimal.sol add() takes two D256 and returns a D256. However, mul() and div() take a uint256 and a D256 and return a uint256. This may be confusing when comparable libraries such as SafeMath have consistency across arithmetic functions.  All the copyright headers include Copyright 2018 dYdX Trading Inc. According to the Free Software Foundation, You should add the proper year for each past release; for example, Copyright 1998, 1999 Terry Jones if some releases were finished in 1998 and some were finished in 1999. Consider updating the copyright headers to add the year 2019.Update: Fixed in pull request #223.  There are a couple of typos in the comments: IErc20.sol L26 and Token.sol L167: dont instead of dont. SoloMargin.sol L34: inherets instead of inherits.Consider running codespell on pull requests.Update: Fixed in pull request #225.  To favor explicitness and readability, several parts of the contracts may benefit from better naming. Our suggestions are: ttype to type in Actions.sol, line 152 and Actions.sol, line 172. x to number in Math.sol, lines 69, 85 and 100. r to result in Math.sol, lines 75, 91 and 107. In Admin.sol and AdminImpl.sol, drop the word owner from the function names. For example, ownerWithdrawExcessTokens to withdrawExcessTokens. OperatorArg to Operator. operator to account. getAccountValues to getAccountSupplyAndBorrowValues in Storage.sol, line 296 and Getters.sol, line 319. getAdjustedAccountValues to getAccountSupplyAndBorrowValuesAdjusted. getIsLocalOperator to isLocalOperator. getIsGlobalOperator to isGlobalOperator. g_state to globalState. arg to action.Update: Partially fixed in pull request #228. The dYdX team prefers to keep some of these variable names.  Conclusion  No critical and two high severity issues were found. Some changes were proposed to follow best practices and reduce the potential attack surface.  The code of the contracts was carefully written by the Solo team, following a consistent and nice style, considering all the possible conditions, and with extensive tests. The idea of their protocol is very interesting, and the way they implemented it simplifies many details that in other similar projects become hard to understand, test, and audit.  However, the use of structs and libraries, the shared global state and the side-effects to keep it up-to-date, the split of responsibilities between multiple contracts (sometimes forced by Ethereum limitations), and the lack of comments, made the codebase hard to read and navigate, forcing us to jump through many files to fully understand every function. In addition to that, the functions did not specify their expected results, making them harder to audit for correctness. Most of these problems can be solved or mitigated by simply adding more comments to guide the readers, or with small tweaks of the design.  An important thing to notice for readers of this report and users of the Solo system is that, while most parts are non-custodial and allow free peer-to-peer interactions, the administrators are in full control of the fundamental parameters of the system. Also, to improve the usability and usefulness of the system, the Solo team decided to implement global operators that will be able to execute actions that can affect user accounts without waiting for their approval. These are important and necessary decisions to build a functioning system. The Solo team has ensured the transparency of their system, and can easily implement time delays, present notifications on the user interface, and document every aspect of the system, to make sure that their users will have a clear idea of what to expect, what to monitor, and how to take full advantage of the available features.  Note that as of the date of publishing, the above review reflects the current understanding of known security patterns as they relate to the Solo contracts. The above should not be construed as investment advice. For general information about smart contract security, check out our thoughts here.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/solo-margin-protocol-audit-30ac2aaf6b10#missing-docstrings", "labels": ["OpenZeppelin"]}, {"title": "Some areas of the code base were difficult to understand or were not self-explanatory. The layout of the project makes this a bigger problem because the reader has to jump through many files to understand a single function.", "body": "Some areas of the code base were difficult to understand or were not self-explanatory. The layout of the project makes this a bigger problem because the reader has to jump through many files to understand a single function.", "html_url": "https://blog.openzeppelin.com/solo-margin-protocol-audit-30ac2aaf6b10#some-areas-of-the-code-base-were-difficult-to-understand-or-were-not-self-explanatory.-the-layout-of-the-project-makes-this-a-bigger-problem-because-the-reader-has-to-jump-through-many-files-to-understand-a-single-function.", "labels": ["OpenZeppelin"]}, {"title": "Consider adding Natspec docstrings to everything that is part of the contracts\u2019 public API, including structs and struct fields. In addition to that, consider documenting in the code any side-effects of the functions, and the conditions that will make them revert. If a new concept or a business rule is introduced in a high-level function, consider briefly explaining it and adding a link to the user documentation for more details.", "body": "Consider adding Natspec docstrings to everything that is part of the contracts\u2019 public API, including structs and struct fields. In addition to that, consider documenting in the code any side-effects of the functions, and the conditions that will make them revert. If a new concept or a business rule is introduced in a high-level function, consider briefly explaining it and adding a link to the user documentation for more details.", "html_url": "https://blog.openzeppelin.com/solo-margin-protocol-audit-30ac2aaf6b10#consider-adding-natspec-docstrings-to-everything-that-is-part-of-the-contracts\u2019-public-api,-including-structs-and-struct-fields.-in-addition-to-that,-consider-documenting-in-the-code-any-side-effects-of-the-functions,-and-the-conditions-that-will-make-them-revert.-if-a-new-concept-or-a-business-rule-is-introduced-in-a-high-level-function,-consider-briefly-explaining-it-and-adding-a-link-to-the-user-documentation-for-more-details.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in pull request #234.", "body": "Update: Fixed in pull request #234.", "html_url": "https://blog.openzeppelin.com/solo-margin-protocol-audit-30ac2aaf6b10#update:-fixed-in-pull-request-#234.", "labels": ["OpenZeppelin"]}, {"title": "Encapsulation issues make the code hard to\u00a0read", "body": "Encapsulation issues make the code hard to\u00a0read", "html_url": "https://blog.openzeppelin.com/solo-margin-protocol-audit-30ac2aaf6b10#encapsulation-issues-make-the-code-hard-to\u00a0read", "labels": ["OpenZeppelin"]}, {"title": "Encapsulation is essential for writing clean and readable code. However, in a language like Solidity it is very hard to encapsulate the code. Contract oriented programming is not quite like object oriented programming, so its flexibility and limitations affect the design of the project.", "body": "Encapsulation is essential for writing clean and readable code. However, in a language like Solidity it is very hard to encapsulate the code. Contract oriented programming is not quite like object oriented programming, so its flexibility and limitations affect the design of the project.", "html_url": "https://blog.openzeppelin.com/solo-margin-protocol-audit-30ac2aaf6b10#encapsulation-is-essential-for-writing-clean-and-readable-code.-however,-in-a-language-like-solidity-it-is-very-hard-to-encapsulate-the-code.-contract-oriented-programming-is-not-quite-like-object-oriented-programming,-so-its-flexibility-and-limitations-affect-the-design-of-the-project.", "labels": ["OpenZeppelin"]}, {"title": "The Solo team decided to heavily use structs and libraries for encapsulation. This is a nice idea, but it brings its own challenges due to important details for understanding functions being spread across many files.", "body": "The Solo team decided to heavily use structs and libraries for encapsulation. This is a nice idea, but it brings its own challenges due to important details for understanding functions being spread across many files.", "html_url": "https://blog.openzeppelin.com/solo-margin-protocol-audit-30ac2aaf6b10#the-solo-team-decided-to-heavily-use-structs-and-libraries-for-encapsulation.-this-is-a-nice-idea,-but-it-brings-its-own-challenges-due-to-important-details-for-understanding-functions-being-spread-across-many-files.", "labels": ["OpenZeppelin"]}, {"title": "Most of the readability problems can be mitigated by adding extensive comments as explained in the Missing docstrings issue reported above. Some other parts can be improved by following the rule of \u201clow coupling and high cohesion\u201d. And some others by making layers of code as minimal as possible, which has the added benefit of reducing the attack surface and making each layer easier to test.", "body": "Most of the readability problems can be mitigated by adding extensive comments as explained in the Missing docstrings issue reported above. Some other parts can be improved by following the rule of \u201clow coupling and high cohesion\u201d. And some others by making layers of code as minimal as possible, which has the added benefit of reducing the attack surface and making each layer easier to test.", "html_url": "https://blog.openzeppelin.com/solo-margin-protocol-audit-30ac2aaf6b10#most-of-the-readability-problems-can-be-mitigated-by-adding-extensive-comments-as-explained-in-the-missing-docstrings-issue-reported-above.-some-other-parts-can-be-improved-by-following-the-rule-of-\u201clow-coupling-and-high-cohesion\u201d.-and-some-others-by-making-layers-of-code-as-minimal-as-possible,-which-has-the-added-benefit-of-reducing-the-attack-surface-and-making-each-layer-easier-to-test.", "labels": ["OpenZeppelin"]}, {"title": "Following are examples of encapsulation pain points that made it difficult to review the Solo code, or possible improvements for the encapsulation design.", "body": "Following are examples of encapsulation pain points that made it difficult to review the Solo code, or possible improvements for the encapsulation design.", "html_url": "https://blog.openzeppelin.com/solo-margin-protocol-audit-30ac2aaf6b10#following-are-examples-of-encapsulation-pain-points-that-made-it-difficult-to-review-the-solo-code,-or-possible-improvements-for-the-encapsulation-design.", "labels": ["OpenZeppelin"]}, {"title": "Rather than passing the entire State struct into functions, only pass in the specific pieces of state that will be operated on. This makes it easier to understand what a function is doing and ensures only the intended pieces of state are changed.", "body": "Rather than passing the entire State struct into functions, only pass in the specific pieces of state that will be operated on. This makes it easier to understand what a function is doing and ensures only the intended pieces of state are changed.", "html_url": "https://blog.openzeppelin.com/solo-margin-protocol-audit-30ac2aaf6b10#rather-than-passing-the-entire-state-struct-into-functions,-only-pass-in-the-specific-pieces-of-state-that-will-be-operated-on.-this-makes-it-easier-to-understand-what-a-function-is-doing-and-ensures-only-the-intended-pieces-of-state-are-changed.", "labels": ["OpenZeppelin"]}, {"title": "There is a circular dependency between the Storage and Cache contracts. As suggested above, consider passing in only the necessary parameters rather a State struct to Cache.addMarket() to remove Cache\u2018s dependency on Storage.", "body": "There is a circular dependency between the Storage and Cache contracts. As suggested above, consider passing in only the necessary parameters rather a State struct to Cache.addMarket() to remove Cache\u2018s dependency on Storage.", "html_url": "https://blog.openzeppelin.com/solo-margin-protocol-audit-30ac2aaf6b10#there-is-a-circular-dependency-between-the-storage-and-cache-contracts.-as-suggested-above,-consider-passing-in-only-the-necessary-parameters-rather-a-state-struct-to-cache.addmarket()-to-remove-cache\u2018s-dependency-on-storage.", "labels": ["OpenZeppelin"]}, {"title": "There is a contract called Getters. This fails at cohesion because it is too generic and it is too far from the setter functions and the state it is querying. Consider moving all the getter and setter functions, and state variables they manipulate, to the same contract.", "body": "There is a contract called Getters. This fails at cohesion because it is too generic and it is too far from the setter functions and the state it is querying. Consider moving all the getter and setter functions, and state variables they manipulate, to the same contract.", "html_url": "https://blog.openzeppelin.com/solo-margin-protocol-audit-30ac2aaf6b10#there-is-a-contract-called-getters.-this-fails-at-cohesion-because-it-is-too-generic-and-it-is-too-far-from-the-setter-functions-and-the-state-it-is-querying.-consider-moving-all-the-getter-and-setter-functions,-and-state-variables-they-manipulate,-to-the-same-contract.", "labels": ["OpenZeppelin"]}, {"title": "The same functionality to revert if a market does not exist is implemented in two different contracts: requireValidMarket in Getters.sol and validateMarketId in AdminImpl.sol. Consider moving this function to a single place, either the Storage library or the State contract.", "body": "The same functionality to revert if a market does not exist is implemented in two different contracts: requireValidMarket in Getters.sol and validateMarketId in AdminImpl.sol. Consider moving this function to a single place, either the Storage library or the State contract.", "html_url": "https://blog.openzeppelin.com/solo-margin-protocol-audit-30ac2aaf6b10#the-same-functionality-to-revert-if-a-market-does-not-exist-is-implemented-in-two-different-contracts:-requirevalidmarket-in-getters.sol-and-validatemarketid-in-adminimpl.sol.-consider-moving-this-function-to-a-single-place,-either-the-storage-library-or-the-state-contract.", "labels": ["OpenZeppelin"]}, {"title": "The getMarketCurrentIndex function calls the fetchNewIndex function of the Storage library, passing as an argument the return value of a function of the same Storage library. Instead of calling two functions from the same library in a single statement, consider defining a new function fetchCurrentIndex in the Storage library.", "body": "The getMarketCurrentIndex function calls the fetchNewIndex function of the Storage library, passing as an argument the return value of a function of the same Storage library. Instead of calling two functions from the same library in a single statement, consider defining a new function fetchCurrentIndex in the Storage library.", "html_url": "https://blog.openzeppelin.com/solo-margin-protocol-audit-30ac2aaf6b10#the-getmarketcurrentindex-function-calls-the-fetchnewindex-function-of-the-storage-library,-passing-as-an-argument-the-return-value-of-a-function-of-the-same-storage-library.-instead-of-calling-two-functions-from-the-same-library-in-a-single-statement,-consider-defining-a-new-function-fetchcurrentindex-in-the-storage-library.", "labels": ["OpenZeppelin"]}, {"title": "The Admin contract is just a thin layer that adds security modifiers to the AdminImpl contract where it forwards all the calls. This means that AdminImpl is not usable on its own because it is not safe. Consider moving all the implementations into the Admin contract and dropping AdminImpl. It could make sense to define an interface to specify the Administrator functions in a clear way, and to make it easy to have alternate implementations.", "body": "The Admin contract is just a thin layer that adds security modifiers to the AdminImpl contract where it forwards all the calls. This means that AdminImpl is not usable on its own because it is not safe. Consider moving all the implementations into the Admin contract and dropping AdminImpl. It could make sense to define an interface to specify the Administrator functions in a clear way, and to make it easy to have alternate implementations.", "html_url": "https://blog.openzeppelin.com/solo-margin-protocol-audit-30ac2aaf6b10#the-admin-contract-is-just-a-thin-layer-that-adds-security-modifiers-to-the-adminimpl-contract-where-it-forwards-all-the-calls.-this-means-that-adminimpl-is-not-usable-on-its-own-because-it-is-not-safe.-consider-moving-all-the-implementations-into-the-admin-contract-and-dropping-adminimpl.-it-could-make-sense-to-define-an-interface-to-specify-the-administrator-functions-in-a-clear-way,-and-to-make-it-easy-to-have-alternate-implementations.", "labels": ["OpenZeppelin"]}, {"title": "When an index is updated, the corresponding event is emitted by OperationImpl. Consider emitting the event inside the updateIndex function. This would be a clearer assignment of responsibilities, and it ensures that it is not possible to update the index and forget to emit the event.", "body": "When an index is updated, the corresponding event is emitted by OperationImpl. Consider emitting the event inside the updateIndex function. This would be a clearer assignment of responsibilities, and it ensures that it is not possible to update the index and forget to emit the event.", "html_url": "https://blog.openzeppelin.com/solo-margin-protocol-audit-30ac2aaf6b10#when-an-index-is-updated,-the-corresponding-event-is-emitted-by-operationimpl.-consider-emitting-the-event-inside-the-updateindex-function.-this-would-be-a-clearer-assignment-of-responsibilities,-and-it-ensures-that-it-is-not-possible-to-update-the-index-and-forget-to-emit-the-event.", "labels": ["OpenZeppelin"]}, {"title": "When the more readable design cannot be implemented because of the Ethereum contract size limitations, consider explaining this in the comments of the source code, and supplement the sub-optimal implementation with extra comments to guide the readers and future contributors.", "body": "When the more readable design cannot be implemented because of the Ethereum contract size limitations, consider explaining this in the comments of the source code, and supplement the sub-optimal implementation with extra comments to guide the readers and future contributors.", "html_url": "https://blog.openzeppelin.com/solo-margin-protocol-audit-30ac2aaf6b10#when-the-more-readable-design-cannot-be-implemented-because-of-the-ethereum-contract-size-limitations,-consider-explaining-this-in-the-comments-of-the-source-code,-and-supplement-the-sub-optimal-implementation-with-extra-comments-to-guide-the-readers-and-future-contributors.", "labels": ["OpenZeppelin"]}, {"title": "README is missing important information", "body": "README is missing important information", "html_url": "https://blog.openzeppelin.com/solo-margin-protocol-audit-30ac2aaf6b10#readme-is-missing-important-information", "labels": ["OpenZeppelin"]}, {"title": "The README.md files on the root of the git repositories are the first documents that most developers will read, so they should be complete, clear, concise and accurate.", "body": "The README.md files on the root of the git repositories are the first documents that most developers will read, so they should be complete, clear, concise and accurate.", "html_url": "https://blog.openzeppelin.com/solo-margin-protocol-audit-30ac2aaf6b10#the-readme.md-files-on-the-root-of-the-git-repositories-are-the-first-documents-that-most-developers-will-read,-so-they-should-be-complete,-clear,-concise-and-accurate.", "labels": ["OpenZeppelin"]}, {"title": "The README.md of the Solo project has little information about what is the purpose of the project and how to use it.", "body": "The README.md of the Solo project has little information about what is the purpose of the project and how to use it.", "html_url": "https://blog.openzeppelin.com/solo-margin-protocol-audit-30ac2aaf6b10#the-readme.md-of-the-solo-project-has-little-information-about-what-is-the-purpose-of-the-project-and-how-to-use-it.", "labels": ["OpenZeppelin"]}, {"title": "Consider following Standard Readme to define the structure and contents for the README.md file. Consider including an explanation of the core concepts of the repository, the usage workflows, the public APIs, instructions to test and deploy it, and how it relates to other parts of the project.", "body": "Consider following Standard Readme to define the structure and contents for the README.md file. Consider including an explanation of the core concepts of the repository, the usage workflows, the public APIs, instructions to test and deploy it, and how it relates to other parts of the project.", "html_url": "https://blog.openzeppelin.com/solo-margin-protocol-audit-30ac2aaf6b10#consider-following-standard-readme-to-define-the-structure-and-contents-for-the-readme.md-file.-consider-including-an-explanation-of-the-core-concepts-of-the-repository,-the-usage-workflows,-the-public-apis,-instructions-to-test-and-deploy-it,-and-how-it-relates-to-other-parts-of-the-project.", "labels": ["OpenZeppelin"]}, {"title": "Make sure to include instructions for the responsible disclosure of any security vulnerabilities found in the project.", "body": "Make sure to include instructions for the responsible disclosure of any security vulnerabilities found in the project.", "html_url": "https://blog.openzeppelin.com/solo-margin-protocol-audit-30ac2aaf6b10#make-sure-to-include-instructions-for-the-responsible-disclosure-of-any-security-vulnerabilities-found-in-the-project.", "labels": ["OpenZeppelin"]}, {"title": "#219", "body": "#219", "html_url": "https://blog.openzeppelin.com/solo-margin-protocol-audit-30ac2aaf6b10##219", "labels": ["OpenZeppelin"]}, {"title": "#243", "body": "#243", "html_url": "https://blog.openzeppelin.com/solo-margin-protocol-audit-30ac2aaf6b10##243", "labels": ["OpenZeppelin"]}, {"title": "Allowed non-standard ERC20 tokens should be explicitly specified", "body": "Allowed non-standard ERC20 tokens should be explicitly specified", "html_url": "https://blog.openzeppelin.com/solo-margin-protocol-audit-30ac2aaf6b10#allowed-non-standard-erc20-tokens-should-be-explicitly-specified", "labels": ["OpenZeppelin"]}, {"title": "Since non-standard ERC20 tokens are allowed to be used in markets, the behavior of these tokens should be explicitly specified in comments or the README. All ERC20 tokens that make up markets should abide by these specified conditions in order to be accepted as a market. Certain non-standard implementations may cause undesired effects on the dYdX contracts.", "body": "Since non-standard ERC20 tokens are allowed to be used in markets, the behavior of these tokens should be explicitly specified in comments or the README. All ERC20 tokens that make up markets should abide by these specified conditions in order to be accepted as a market. Certain non-standard implementations may cause undesired effects on the dYdX contracts.", "html_url": "https://blog.openzeppelin.com/solo-margin-protocol-audit-30ac2aaf6b10#since-non-standard-erc20-tokens-are-allowed-to-be-used-in-markets,-the-behavior-of-these-tokens-should-be-explicitly-specified-in-comments-or-the-readme.-all-erc20-tokens-that-make-up-markets-should-abide-by-these-specified-conditions-in-order-to-be-accepted-as-a-market.-certain-non-standard-implementations-may-cause-undesired-effects-on-the-dydx-contracts.", "labels": ["OpenZeppelin"]}, {"title": "As mentioned in the comments in the code, \u201ca custom ERC20 interface is used in order to deal with tokens that don\u2019t adhere strictly to the ERC20 standard (for example tokens that don\u2019t return a boolean value on success)\u201d. Because of this lack of return value, the code allows for a number of non-standard ERC20 implementations, rather than just the one mentioned in the comments.", "body": "As mentioned in the comments in the code, \u201ca custom ERC20 interface is used in order to deal with tokens that don\u2019t adhere strictly to the ERC20 standard (for example tokens that don\u2019t return a boolean value on success)\u201d. Because of this lack of return value, the code allows for a number of non-standard ERC20 implementations, rather than just the one mentioned in the comments.", "html_url": "https://blog.openzeppelin.com/solo-margin-protocol-audit-30ac2aaf6b10#as-mentioned-in-the-comments-in-the-code,-\u201ca-custom-erc20-interface-is-used-in-order-to-deal-with-tokens-that-don\u2019t-adhere-strictly-to-the-erc20-standard-(for-example-tokens-that-don\u2019t-return-a-boolean-value-on-success)\u201d.-because-of-this-lack-of-return-value,-the-code-allows-for-a-number-of-non-standard-erc20-implementations,-rather-than-just-the-one-mentioned-in-the-comments.", "labels": ["OpenZeppelin"]}, {"title": "Token.sol.", "body": "Token.sol.", "html_url": "https://blog.openzeppelin.com/solo-margin-protocol-audit-30ac2aaf6b10#token.sol.", "labels": ["OpenZeppelin"]}, {"title": "This ERC20 implementation would cause issues with Dapps other than dYdX, so it is expected that this type of token never makes it into production on the main Ethereum network. Nevertheless, we suggest being explicit about the types of tokens that are allowed to make up a market and checking that tokens meet these conditions prior to being accepted as a market.", "body": "This ERC20 implementation would cause issues with Dapps other than dYdX, so it is expected that this type of token never makes it into production on the main Ethereum network. Nevertheless, we suggest being explicit about the types of tokens that are allowed to make up a market and checking that tokens meet these conditions prior to being accepted as a market.", "html_url": "https://blog.openzeppelin.com/solo-margin-protocol-audit-30ac2aaf6b10#this-erc20-implementation-would-cause-issues-with-dapps-other-than-dydx,-so-it-is-expected-that-this-type-of-token-never-makes-it-into-production-on-the-main-ethereum-network.-nevertheless,-we-suggest-being-explicit-about-the-types-of-tokens-that-are-allowed-to-make-up-a-market-and-checking-that-tokens-meet-these-conditions-prior-to-being-accepted-as-a-market.", "labels": ["OpenZeppelin"]}, {"title": "Global operators are not restricted to contract addresses", "body": "Global operators are not restricted to contract addresses", "html_url": "https://blog.openzeppelin.com/solo-margin-protocol-audit-30ac2aaf6b10#global-operators-are-not-restricted-to-contract-addresses", "labels": ["OpenZeppelin"]}, {"title": "The Solo contract allows \u201cglobal operators\u201d to operate on behalf of any account. The motivation behind the global operator feature is to allow for things such as a wrapped Ether proxy and automatic loan expiry. Because the intention is for the global operator to always be a contract, consider adding a sanity check using OpenZeppelin\u2019s isContract() function to ensure regular accounts can not be added as global operators and to be more explicit about the intention of the feature.", "body": "The Solo contract allows \u201cglobal operators\u201d to operate on behalf of any account. The motivation behind the global operator feature is to allow for things such as a wrapped Ether proxy and automatic loan expiry. Because the intention is for the global operator to always be a contract, consider adding a sanity check using OpenZeppelin\u2019s isContract() function to ensure regular accounts can not be added as global operators and to be more explicit about the intention of the feature.", "html_url": "https://blog.openzeppelin.com/solo-margin-protocol-audit-30ac2aaf6b10#the-solo-contract-allows-\u201cglobal-operators\u201d-to-operate-on-behalf-of-any-account.-the-motivation-behind-the-global-operator-feature-is-to-allow-for-things-such-as-a-wrapped-ether-proxy-and-automatic-loan-expiry.-because-the-intention-is-for-the-global-operator-to-always-be-a-contract,-consider-adding-a-sanity-check-using-openzeppelin\u2019s-iscontract()-function-to-ensure-regular-accounts-can-not-be-added-as-global-operators-and-to-be-more-explicit-about-the-intention-of-the-feature.", "labels": ["OpenZeppelin"]}, {"title": "There are magic constants in the\u00a0code", "body": "There are magic constants in the\u00a0code", "html_url": "https://blog.openzeppelin.com/solo-margin-protocol-audit-30ac2aaf6b10#there-are-magic-constants-in-the\u00a0code", "labels": ["OpenZeppelin"]}, {"title": "There are magic constants in several Solo contracts. For example, Require.sol, line 203 and Require.sol, line 207. These values make the code harder to understand and to maintain.", "body": "There are magic constants in several Solo contracts. For example, Require.sol, line 203 and Require.sol, line 207. These values make the code harder to understand and to maintain.", "html_url": "https://blog.openzeppelin.com/solo-margin-protocol-audit-30ac2aaf6b10#there-are-magic-constants-in-several-solo-contracts.-for-example,-require.sol,-line-203-and-require.sol,-line-207.-these-values-make-the-code-harder-to-understand-and-to-maintain.", "labels": ["OpenZeppelin"]}, {"title": "Consider defining a constant variable for every hard-coded value (including booleans), giving it a clear and explanatory name. For complex values, consider adding a comment explaining how they were calculated or why they were chosen.", "body": "Consider defining a constant variable for every hard-coded value (including booleans), giving it a clear and explanatory name. For complex values, consider adding a comment explaining how they were calculated or why they were chosen.", "html_url": "https://blog.openzeppelin.com/solo-margin-protocol-audit-30ac2aaf6b10#consider-defining-a-constant-variable-for-every-hard-coded-value-(including-booleans),-giving-it-a-clear-and-explanatory-name.-for-complex-values,-consider-adding-a-comment-explaining-how-they-were-calculated-or-why-they-were-chosen.", "labels": ["OpenZeppelin"]}, {"title": "Update: Comments were added to the constants in pull request #233.", "body": "Update: Comments were added to the constants in pull request #233.", "html_url": "https://blog.openzeppelin.com/solo-margin-protocol-audit-30ac2aaf6b10#update:-comments-were-added-to-the-constants-in-pull-request-#233.", "labels": ["OpenZeppelin"]}, {"title": "stringify() for bytes32 may unexpectedly truncate\u00a0data", "body": "stringify() for bytes32 may unexpectedly truncate\u00a0data", "html_url": "https://blog.openzeppelin.com/solo-margin-protocol-audit-30ac2aaf6b10#stringify()-for-bytes32-may-unexpectedly-truncate\u00a0data", "labels": ["OpenZeppelin"]}, {"title": "Require.sol, the", "body": "Require.sol, the", "html_url": "https://blog.openzeppelin.com/solo-margin-protocol-audit-30ac2aaf6b10#require.sol,-the", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in pull request #214.", "body": "Not following the Checks-Effects-Interactions Pattern  Solidity recommends the usage of the Check-Effects-Interaction Pattern to avoid potential problems, like reentrancy.  In a couple of places the code of Solo the checks are not done first:  The invalid oracle price check in_setPriceOracle.  The primary account check in verifyFinalState.  While in these cases there is no risk of reentrancy, consider moving the checks to the start of the corresponding block to make sure that no issues are introduced by later changes.  pull request #193  does not plan to update the  _verifyFinalState  function  Unexpected return value from Time.hasHappened()  The hasHappened() function in the Time library will return false if the time is 0 instead of reverting. In the future, this may lead to a false positive if the function is being used to check if something hasnt happened yet. Consider reverting when the input value is 0.  Update: Fixed in pull request #220.  Unused import  In Monetary.sol it is unnecessary to import the SafeMath and Math libraries as they are never used.  Update: Fixed in pull request #210.  Notes  Some contract files include the pragma experimental ABIEncoderV2; (for example, Admin.sol) and some others do not include it (for example, Decimal.sol). The effect of declaring the experimental pragma only on some files is not very clear. Consider declaring the usage of ABIEncoderV2 on all the Solidity files, for consistency, to make it clear that the new version of the encoder is used in the project, and to avoid any complications that can come for not declaring it in some files.Update: Fixed in pull request #229.  Explicitly type cast integers before making a comparison between different types in the following locations:In Math.sol: line 77 line 93 line 109In Types.sol: line 98 line 102 line 105 line 211 line 215 line 218  In Decimal.sol add() takes two D256 and returns a D256. However, mul() and div() take a uint256 and a D256 and return a uint256. This may be confusing when comparable libraries such as SafeMath have consistency across arithmetic functions.  All the copyright headers include Copyright 2018 dYdX Trading Inc. According to the Free Software Foundation, You should add the proper year for each past release; for example, Copyright 1998, 1999 Terry Jones if some releases were finished in 1998 and some were finished in 1999. Consider updating the copyright headers to add the year 2019.Update: Fixed in pull request #223.  There are a couple of typos in the comments: IErc20.sol L26 and Token.sol L167: dont instead of dont. SoloMargin.sol L34: inherets instead of inherits.Consider running codespell on pull requests.Update: Fixed in pull request #225.  To favor explicitness and readability, several parts of the contracts may benefit from better naming. Our suggestions are: ttype to type in Actions.sol, line 152 and Actions.sol, line 172. x to number in Math.sol, lines 69, 85 and 100. r to result in Math.sol, lines 75, 91 and 107. In Admin.sol and AdminImpl.sol, drop the word owner from the function names. For example, ownerWithdrawExcessTokens to withdrawExcessTokens. OperatorArg to Operator. operator to account. getAccountValues to getAccountSupplyAndBorrowValues in Storage.sol, line 296 and Getters.sol, line 319. getAdjustedAccountValues to getAccountSupplyAndBorrowValuesAdjusted. getIsLocalOperator to isLocalOperator. getIsGlobalOperator to isGlobalOperator. g_state to globalState. arg to action.Update: Partially fixed in pull request #228. The dYdX team prefers to keep some of these variable names.  Conclusion  No critical and two high severity issues were found. Some changes were proposed to follow best practices and reduce the potential attack surface.  The code of the contracts was carefully written by the Solo team, following a consistent and nice style, considering all the possible conditions, and with extensive tests. The idea of their protocol is very interesting, and the way they implemented it simplifies many details that in other similar projects become hard to understand, test, and audit.  However, the use of structs and libraries, the shared global state and the side-effects to keep it up-to-date, the split of responsibilities between multiple contracts (sometimes forced by Ethereum limitations), and the lack of comments, made the codebase hard to read and navigate, forcing us to jump through many files to fully understand every function. In addition to that, the functions did not specify their expected results, making them harder to audit for correctness. Most of these problems can be solved or mitigated by simply adding more comments to guide the readers, or with small tweaks of the design.  An important thing to notice for readers of this report and users of the Solo system is that, while most parts are non-custodial and allow free peer-to-peer interactions, the administrators are in full control of the fundamental parameters of the system. Also, to improve the usability and usefulness of the system, the Solo team decided to implement global operators that will be able to execute actions that can affect user accounts without waiting for their approval. These are important and necessary decisions to build a functioning system. The Solo team has ensured the transparency of their system, and can easily implement time delays, present notifications on the user interface, and document every aspect of the system, to make sure that their users will have a clear idea of what to expect, what to monitor, and how to take full advantage of the available features.  Note that as of the date of publishing, the above review reflects the current understanding of known security patterns as they relate to the Solo contracts. The above should not be construed as investment advice. For general information about smart contract security, check out our thoughts here.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/solo-margin-protocol-audit-30ac2aaf6b10#update:-fixed-in-pull-request-#214.", "labels": ["OpenZeppelin"]}, {"title": "Interest rate calculation may be error\u00a0prone", "body": "Interest rate calculation may be error\u00a0prone", "html_url": "https://blog.openzeppelin.com/solo-margin-protocol-audit-30ac2aaf6b10#interest-rate-calculation-may-be-error\u00a0prone", "labels": ["OpenZeppelin"]}, {"title": "The Solo contracts calculate interest accumulated over time by incrementing an index which represents the total accumulated interest with a starting value of 1. The index is updated by taking the per-second interest rate and multiplying by the number of seconds elapsed since the last time the index was updated (percentageInterestSinceLastUpdate = perSecondRate * (currentTime - lastUpdatedTime)). This number represents the percentage gained since the last calculation and is multiplied by the previous index value to calculate the updated index value (index = index * (1 + percentageInterestSinceLastUpdate)).", "body": "The Solo contracts calculate interest accumulated over time by incrementing an index which represents the total accumulated interest with a starting value of 1. The index is updated by taking the per-second interest rate and multiplying by the number of seconds elapsed since the last time the index was updated (percentageInterestSinceLastUpdate = perSecondRate * (currentTime - lastUpdatedTime)). This number represents the percentage gained since the last calculation and is multiplied by the previous index value to calculate the updated index value (index = index * (1 + percentageInterestSinceLastUpdate)).", "html_url": "https://blog.openzeppelin.com/solo-margin-protocol-audit-30ac2aaf6b10#the-solo-contracts-calculate-interest-accumulated-over-time-by-incrementing-an-index-which-represents-the-total-accumulated-interest-with-a-starting-value-of-1.-the-index-is-updated-by-taking-the-per-second-interest-rate-and-multiplying-by-the-number-of-seconds-elapsed-since-the-last-time-the-index-was-updated-(percentageinterestsincelastupdate-=-persecondrate-*-(currenttime---lastupdatedtime)).-this-number-represents-the-percentage-gained-since-the-last-calculation-and-is-multiplied-by-the-previous-index-value-to-calculate-the-updated-index-value-(index-=-index-*-(1-+-percentageinterestsincelastupdate)).", "labels": ["OpenZeppelin"]}, {"title": "This calculation differs from the true calculation which would calculate percentageInterestSinceLastUpdate like so: percentageInterestSinceLastUpdate = (currentTime - lastUpdated) ^ marginalRate. The differences between the calculation used and the true calculation are negligible when the index is updated fairly frequently but start to diverge as the index is updated less frequently. Consider implementing the true interest calculation or properly documenting the current interest calculation.", "body": "This calculation differs from the true calculation which would calculate percentageInterestSinceLastUpdate like so: percentageInterestSinceLastUpdate = (currentTime - lastUpdated) ^ marginalRate. The differences between the calculation used and the true calculation are negligible when the index is updated fairly frequently but start to diverge as the index is updated less frequently. Consider implementing the true interest calculation or properly documenting the current interest calculation.", "html_url": "https://blog.openzeppelin.com/solo-margin-protocol-audit-30ac2aaf6b10#this-calculation-differs-from-the-true-calculation-which-would-calculate-percentageinterestsincelastupdate-like-so:-percentageinterestsincelastupdate-=-(currenttime---lastupdated)-^-marginalrate.-the-differences-between-the-calculation-used-and-the-true-calculation-are-negligible-when-the-index-is-updated-fairly-frequently-but-start-to-diverge-as-the-index-is-updated-less-frequently.-consider-implementing-the-true-interest-calculation-or-properly-documenting-the-current-interest-calculation.", "labels": ["OpenZeppelin"]}, {"title": "Update: The function was better documented in pull request #218.", "body": "Update: The function was better documented in pull request #218.", "html_url": "https://blog.openzeppelin.com/solo-margin-protocol-audit-30ac2aaf6b10#update:-the-function-was-better-documented-in-pull-request-#218.", "labels": ["OpenZeppelin"]}, {"title": "Nonreentrant functions should be marked\u00a0external", "body": "Nonreentrant functions should be marked\u00a0external", "html_url": "https://blog.openzeppelin.com/solo-margin-protocol-audit-30ac2aaf6b10#nonreentrant-functions-should-be-marked\u00a0external", "labels": ["OpenZeppelin"]}, {"title": "As stated in ReentrancyGuard.sol, \u201ccalling a nonReentrant function from another nonReentrant function is not supported.\u201d All nonreentrant functions should be marked as external rather than public to enforce this more explicitly.", "body": "As stated in ReentrancyGuard.sol, \u201ccalling a nonReentrant function from another nonReentrant function is not supported.\u201d All nonreentrant functions should be marked as external rather than public to enforce this more explicitly.", "html_url": "https://blog.openzeppelin.com/solo-margin-protocol-audit-30ac2aaf6b10#as-stated-in-reentrancyguard.sol,-\u201ccalling-a-nonreentrant-function-from-another-nonreentrant-function-is-not-supported.\u201d-all-nonreentrant-functions-should-be-marked-as-external-rather-than-public-to-enforce-this-more-explicitly.", "labels": ["OpenZeppelin"]}, {"title": "However, Solidity does not yet support structs as arguments of external functions (see issue #5479). Consider adding a comment to prevent developers to call these nonReentrant functions from the same contract.", "body": "However, Solidity does not yet support structs as arguments of external functions (see issue #5479). Consider adding a comment to prevent developers to call these nonReentrant functions from the same contract.", "html_url": "https://blog.openzeppelin.com/solo-margin-protocol-audit-30ac2aaf6b10#however,-solidity-does-not-yet-support-structs-as-arguments-of-external-functions-(see-issue-#5479).-consider-adding-a-comment-to-prevent-developers-to-call-these-nonreentrant-functions-from-the-same-contract.", "labels": ["OpenZeppelin"]}, {"title": "Using Wei to refer to the minimum unit of a\u00a0token", "body": "Using Wei to refer to the minimum unit of a\u00a0token", "html_url": "https://blog.openzeppelin.com/solo-margin-protocol-audit-30ac2aaf6b10#using-wei-to-refer-to-the-minimum-unit-of-a\u00a0token", "labels": ["OpenZeppelin"]}, {"title": "The Solo project uses the word \u201cWei\u201d to refer to the minimum and indivisible unit of a token. 1 wei in Ethereum is equal to 10^-18 ether. While most tokens follow the same convention of having a \u201chuman-readable\u201d unit with 18 decimals, many tokens define a different number of decimals. In addition to that, most tokens leave their minimum unit nameless, using the prefix of the International System of Units to refer to it (for example, attoToken for 1 token * 10^-18), instead of calling it Wei. This important detail is only mentioned once in the codebase.", "body": "The Solo project uses the word \u201cWei\u201d to refer to the minimum and indivisible unit of a token. 1 wei in Ethereum is equal to 10^-18 ether. While most tokens follow the same convention of having a \u201chuman-readable\u201d unit with 18 decimals, many tokens define a different number of decimals. In addition to that, most tokens leave their minimum unit nameless, using the prefix of the International System of Units to refer to it (for example, attoToken for 1 token * 10^-18), instead of calling it Wei. This important detail is only mentioned once in the codebase.", "html_url": "https://blog.openzeppelin.com/solo-margin-protocol-audit-30ac2aaf6b10#the-solo-project-uses-the-word-\u201cwei\u201d-to-refer-to-the-minimum-and-indivisible-unit-of-a-token.-1-wei-in-ethereum-is-equal-to-10^-18-ether.-while-most-tokens-follow-the-same-convention-of-having-a-\u201chuman-readable\u201d-unit-with-18-decimals,-many-tokens-define-a-different-number-of-decimals.-in-addition-to-that,-most-tokens-leave-their-minimum-unit-nameless,-using-the-prefix-of-the-international-system-of-units-to-refer-to-it-(for-example,-attotoken-for-1-token-*-10^-18),-instead-of-calling-it-wei.-this-important-detail-is-only-mentioned-once-in-the-codebase.", "labels": ["OpenZeppelin"]}, {"title": "There is no consistent way to call this minimum unit, and it could be very confusing to use Wei when the token has a different number of decimals. Consider using an alternative name that is clearer and less loaded, like BaseUnit or (as Matt Condon has suggested) TokenBits. Also consider documenting the expected unit on all the functions that receive a token amount as an argument.", "body": "There is no consistent way to call this minimum unit, and it could be very confusing to use Wei when the token has a different number of decimals. Consider using an alternative name that is clearer and less loaded, like BaseUnit or (as Matt Condon has suggested) TokenBits. Also consider documenting the expected unit on all the functions that receive a token amount as an argument.", "html_url": "https://blog.openzeppelin.com/solo-margin-protocol-audit-30ac2aaf6b10#there-is-no-consistent-way-to-call-this-minimum-unit,-and-it-could-be-very-confusing-to-use-wei-when-the-token-has-a-different-number-of-decimals.-consider-using-an-alternative-name-that-is-clearer-and-less-loaded,-like-baseunit-or-(as-matt-condon-has-suggested)-tokenbits.-also-consider-documenting-the-expected-unit-on-all-the-functions-that-receive-a-token-amount-as-an-argument.", "labels": ["OpenZeppelin"]}, {"title": "Multiple operations in single statement", "body": "Multiple operations in single statement", "html_url": "https://blog.openzeppelin.com/solo-margin-protocol-audit-30ac2aaf6b10#multiple-operations-in-single-statement", "labels": ["OpenZeppelin"]}, {"title": "To increase code readability, avoid combining independent operations into a single line of code. In Require.sol, in the stringify(uint256) function, the variable k is decremented on the same line as it is used to access an array. Consider decrementing k on the line following the array access.", "body": "To increase code readability, avoid combining independent operations into a single line of code. In Require.sol, in the stringify(uint256) function, the variable k is decremented on the same line as it is used to access an array. Consider decrementing k on the line following the array access.", "html_url": "https://blog.openzeppelin.com/solo-margin-protocol-audit-30ac2aaf6b10#to-increase-code-readability,-avoid-combining-independent-operations-into-a-single-line-of-code.-in-require.sol,-in-the-stringify(uint256)-function,-the-variable-k-is-decremented-on-the-same-line-as-it-is-used-to-access-an-array.-consider-decrementing-k-on-the-line-following-the-array-access.", "labels": ["OpenZeppelin"]}, {"title": "Not following the Checks-Effects-Interactions Pattern", "body": "Not following the Checks-Effects-Interactions Pattern", "html_url": "https://blog.openzeppelin.com/solo-margin-protocol-audit-30ac2aaf6b10#not-following-the-checks-effects-interactions-pattern", "labels": ["OpenZeppelin"]}, {"title": "Solidity recommends the usage of the Check-Effects-Interaction Pattern to avoid potential problems, like reentrancy.", "body": "Solidity recommends the usage of the Check-Effects-Interaction Pattern to avoid potential problems, like reentrancy.", "html_url": "https://blog.openzeppelin.com/solo-margin-protocol-audit-30ac2aaf6b10#solidity-recommends-the-usage-of-the-check-effects-interaction-pattern-to-avoid-potential-problems,-like-reentrancy.", "labels": ["OpenZeppelin"]}, {"title": "In a couple of places the code of Solo the checks are not done first:", "body": "In a couple of places the code of Solo the checks are not done first:", "html_url": "https://blog.openzeppelin.com/solo-margin-protocol-audit-30ac2aaf6b10#in-a-couple-of-places-the-code-of-solo-the-checks-are-not-done-first:", "labels": ["OpenZeppelin"]}, {"title": "The invalid oracle price check in_setPriceOracle.", "body": "The invalid oracle price check in_setPriceOracle.", "html_url": "https://blog.openzeppelin.com/solo-margin-protocol-audit-30ac2aaf6b10#the-invalid-oracle-price-check-in_setpriceoracle.", "labels": ["OpenZeppelin"]}, {"title": "The primary account check in verifyFinalState.", "body": "The primary account check in verifyFinalState.", "html_url": "https://blog.openzeppelin.com/solo-margin-protocol-audit-30ac2aaf6b10#the-primary-account-check-in-verifyfinalstate.", "labels": ["OpenZeppelin"]}, {"title": "While in these cases there is no risk of reentrancy, consider moving the checks to the start of the corresponding block to make sure that no issues are introduced by later changes.", "body": "While in these cases there is no risk of reentrancy, consider moving the checks to the start of the corresponding block to make sure that no issues are introduced by later changes.", "html_url": "https://blog.openzeppelin.com/solo-margin-protocol-audit-30ac2aaf6b10#while-in-these-cases-there-is-no-risk-of-reentrancy,-consider-moving-the-checks-to-the-start-of-the-corresponding-block-to-make-sure-that-no-issues-are-introduced-by-later-changes.", "labels": ["OpenZeppelin"]}, {"title": "pull request #193", "body": "pull request #193", "html_url": "https://blog.openzeppelin.com/solo-margin-protocol-audit-30ac2aaf6b10#pull-request-#193", "labels": ["OpenZeppelin"]}, {"title": "does not plan to update the", "body": "does not plan to update the", "html_url": "https://blog.openzeppelin.com/solo-margin-protocol-audit-30ac2aaf6b10#does-not-plan-to-update-the", "labels": ["OpenZeppelin"]}, {"title": "_verifyFinalState", "body": "_verifyFinalState", "html_url": "https://blog.openzeppelin.com/solo-margin-protocol-audit-30ac2aaf6b10#_verifyfinalstate", "labels": ["OpenZeppelin"]}, {"title": "function", "body": "alities, delaying the release until the ABIEncoderV2 is stable, or rewriting the project to use the current stable encoder.  Update: Statement from the dYdX team about this issue: The AbiEncoderV2 has been used in production for months without incident by other high-profile protocols such as 0x Version 2. We do not see its use as a larger security risk than using the Solidity compiler in general. We have also upgraded the compiler version to v0.5.7 since beginning the Audit (which fixes the aforementioned bugs).  Malicious AutoTrader contracts may steal funds  The Solo contract allows a user to set any contract as their AutoTrader. If a user makes a trade with an attacker using a malicious AutoTrader, the attacker may front-run the trade with a transaction that changes the rate returned by the AutoTraders getTradeCost() effectively allowing the attacker to steal the full amount of the trade.  This can be prevented by only allowing users to interact with approved AutoTrader contracts on the front-end. However, it would be best to prevent this attack on-chain rather than relying on off-chain protections.  Consider adding a whitelist of AutoTrader contracts or AutoTrader factories to restrict the possible implementations on-chain.  Note: This issue was downgraded from critical severity because the dYdX team is aware of the issue and has plans for off-chain mitigation.  Medium Severity  Missing docstrings  Some areas of the code base were difficult to understand or were not self-explanatory. The layout of the project makes this a bigger problem because the reader has to jump through many files to understand a single .  Consider adding Natspec docstrings to everything that is part of the contracts public API, including structs and struct fields. In addition to that, consider documenting in the code any side-effects of the s, and the conditions that will make them revert. If a new concept or a business rule is introduced in a high-level , consider briefly explaining it and adding a link to the user documentation for more details.  Update: Fixed in pull request #234.  Encapsulation issues make the code hard to read  Encapsulation is essential for writing clean and readable code. However, in a language like Solidity it is very hard to encapsulate the code. Contract oriented programming is not quite like object oriented programming, so its flexibility and limitations affect the design of the project.  The Solo team decided to heavily use structs and libraries for encapsulation. This is a nice idea, but it brings its own challenges due to important details for understanding s being spread across many files.  Most of the readability problems can be mitigated by adding extensive comments as explained in the Missing docstrings issue reported above. Some other parts can be improved by following the rule of low coupling and high cohesion. And some others by making layers of code as minimal as possible, which has the added benefit of reducing the attack surface and making each layer easier to test.  Following are examples of encapsulation pain points that made it difficult to review the Solo code, or possible improvements for the encapsulation design.  Rather than passing the entire State struct into s, only pass in the specific pieces of state that will be operated on. This makes it easier to understand what a  is doing and ensures only the intended pieces of state are changed.  There is a circular dependency between the Storage and Cache contracts. As suggested above, consider passing in only the necessary parameters rather a State struct to Cache.addMarket() to remove Caches dependency on Storage.  There is a contract called Getters. This fails at cohesion because it is too generic and it is too far from the setter s and the state it is querying. Consider moving all the getter and setter s, and state variables they manipulate, to the same contract.  The same ality to revert if a market does not exist is implemented in two different contracts: requireValidMarket in Getters.sol and validateMarketId in AdminImpl.sol. Consider moving this  to a single place, either the Storage library or the State contract.  The getMarketCurrentIndex  calls the fetchNewIndex  of the Storage library, passing as an argument the return value of a  of the same Storage library. Instead of calling two s from the same library in a single statement, consider defining a new  fetchCurrentIndex in the Storage library.  The Admin contract is just a thin layer that adds security modifiers to the AdminImpl contract where it forwards all the calls. This means that AdminImpl is not usable on its own because it is not safe. Consider moving all the implementations into the Admin contract and dropping AdminImpl. It could make sense to define an interface to specify the Administrator s in a clear way, and to make it easy to have alternate implementations.  When an index is updated, the corresponding event is emitted by OperationImpl. Consider emitting the event inside the updateIndex . This would be a clearer assignment of responsibilities, and it ensures that it is not possible to update the index and forget to emit the event.  When the more readable design cannot be implemented because of the Ethereum contract size limitations, consider explaining this in the comments of the source code, and supplement the sub-optimal implementation with extra comments to guide the readers and future contributors.  Low Severity  README is missing important information  The README.md files on the root of the git repositories are the first documents that most developers will read, so they should be complete, clear, concise and accurate.  The README.md of the Solo project has little information about what is the purpose of the project and how to use it.  Consider following Standard Readme to define the structure and contents for the README.md file. Consider including an explanation of the core concepts of the repository, the usage workflows, the public APIs, instructions to test and deploy it, and how it relates to other parts of the project.  Make sure to include instructions for the responsible disclosure of any security vulnerabilities found in the project.  #219  #243  Allowed non-standard ERC20 tokens should be explicitly specified  Since non-standard ERC20 tokens are allowed to be used in markets, the behavior of these tokens should be explicitly specified in comments or the README. All ERC20 tokens that make up markets should abide by these specified conditions in order to be accepted as a market. Certain non-standard implementations may cause undesired effects on the dYdX contracts.  As mentioned in the comments in the code, a custom ERC20 interface is used in order to deal with tokens that dont adhere strictly to the ERC20 standard (for example tokens that dont return a boolean value on success). Because of this lack of return value, the code allows for a number of non-standard ERC20 implementations, rather than just the one mentioned in the comments.  Token.sol.  This ERC20 implementation would cause issues with Dapps other than dYdX, so it is expected that this type of token never makes it into production on the main Ethereum network. Nevertheless, we suggest being explicit about the types of tokens that are allowed to make up a market and checking that tokens meet these conditions prior to being accepted as a market.  Global operators are not restricted to contract addresses  The Solo contract allows global operators to operate on behalf of any account. The motivation behind the global operator feature is to allow for things such as a wrapped Ether proxy and automatic loan expiry. Because the intention is for the global operator to always be a contract, consider adding a sanity check using OpenZeppelins isContract()  to ensure regular accounts can not be added as global operators and to be more explicit about the intention of the feature.  There are magic constants in the code  There are magic constants in several Solo contracts. For example, Require.sol, line 203 and Require.sol, line 207. These values make the code harder to understand and to maintain.  Consider defining a constant variable for every hard-coded value (including booleans), giving it a clear and explanatory name. For complex values, consider adding a comment explaining how they were calculated or why they were chosen.  Update: Comments were added to the constants in pull request #233.  stringify() for bytes32 may unexpectedly truncate data  Require.sol, the  Update: Fixed in pull request #214.  Interest rate calculation may be error prone  The Solo contracts calculate interest accumulated over time by incrementing an index which represents the total accumulated interest with a starting value of 1. The index is updated by taking the per-second interest rate and multiplying by the number of seconds elapsed since the last time the index was updated (percentageInterestSinceLastUpdate = perSecondRate * (currentTime - lastUpdatedTime)). This number represents the percentage gained since the last calculation and is multiplied by the previous index value to calculate the updated index value (index = index * (1 + percentageInterestSinceLastUpdate)).  This calculation differs from the true calculation which would calculate percentageInterestSinceLastUpdate like so: percentageInterestSinceLastUpdate = (currentTime - lastUpdated) ^ marginalRate. The differences between the calculation used and the true calculation are negligible when the index is updated fairly frequently but start to diverge as the index is updated less frequently. Consider implementing the true interest calculation or properly documenting the current interest calculation.  Update: The  was better documented in pull request #218.  Nonreentrant s should be marked external  As stated in ReentrancyGuard.sol, calling a nonReentrant  from another nonReentrant  is not supported. All nonreentrant s should be marked as external rather than public to enforce this more explicitly.  However, Solidity does not yet support structs as arguments of external s (see issue #5479). Consider adding a comment to prevent developers to call these nonReentrant s from the same contract.  Using Wei to refer to the minimum unit of a token  The Solo project uses the word Wei to refer to the minimum and indivisible unit of a token. 1 wei in Ethereum is equal to 10^-18 ether. While most tokens follow the same convention of having a human-readable unit with 18 decimals, many tokens define a different number of decimals. In addition to that, most tokens leave their minimum unit nameless, using the prefix of the International System of Units to refer to it (for example, attoToken for 1 token * 10^-18), instead of calling it Wei. This important detail is only mentioned once in the codebase.  There is no consistent way to call this minimum unit, and it could be very confusing to use Wei when the token has a different number of decimals. Consider using an alternative name that is clearer and less loaded, like BaseUnit or (as Matt Condon has suggested) TokenBits. Also consider documenting the expected unit on all the s that receive a token amount as an argument.  Multiple operations in single statement  To increase code readability, avoid combining independent operations into a single line of code. In Require.sol, in the stringify(uint256) , the variable k is decremented on the same line as it is used to access an array. Consider decrementing k on the line following the array access.  Update: Fixed in pull request #214.  Not following the Checks-Effects-Interactions Pattern  Solidity recommends the usage of the Check-Effects-Interaction Pattern to avoid potential problems, like reentrancy.  In a couple of places the code of Solo the checks are not done first:  The invalid oracle price check in_setPriceOracle.  The primary account check in verifyFinalState.  While in these cases there is no risk of reentrancy, consider moving the checks to the start of the corresponding block to make sure that no issues are introduced by later changes.  pull request #193  does not plan to update the  _verifyFinalState    Unexpected return value from Time.hasHappened()  The hasHappened()  in the Time library will return false if the time is 0 instead of reverting. In the future, this may lead to a false positive if the  is being used to check if something hasnt happened yet. Consider reverting when the input value is 0.  Update: Fixed in pull request #220.  Unused import  In Monetary.sol it is unnecessary to import the SafeMath and Math libraries as they are never used.  Update: Fixed in pull request #210.  Notes  Some contract files include the pragma experimental ABIEncoderV2; (for example, Admin.sol) and some others do not include it (for example, Decimal.sol). The effect of declaring the experimental pragma only on some files is not very clear. Consider declaring the usage of ABIEncoderV2 on all the Solidity files, for consistency, to make it clear that the new version of the encoder is used in the project, and to avoid any complications that can come for not declaring it in some files.Update: Fixed in pull request #229.  Explicitly type cast integers before making a comparison between different types in the following locations:In Math.sol: line 77 line 93 line 109In Types.sol: line 98 line 102 line 105 line 211 line 215 line 218  In Decimal.sol add() takes two D256 and returns a D256. However, mul() and div() take a uint256 and a D256 and return a uint256. This may be confusing when comparable libraries such as SafeMath have consistency across arithmetic s.  All the copyright headers include Copyright 2018 dYdX Trading Inc. According to the Free Software Foundation, You should add the proper year for each past release; for example, Copyright 1998, 1999 Terry Jones if some releases were finished in 1998 and some were finished in 1999. Consider updating the copyright headers to add the year 2019.Update: Fixed in pull request #223.  There are a couple of typos in the comments: IErc20.sol L26 and Token.sol L167: dont instead of dont. SoloMargin.sol L34: inherets instead of inherits.Consider running codespell on pull requests.Update: Fixed in pull request #225.  To favor explicitness and readability, several parts of the contracts may benefit from better naming. Our suggestions are: ttype to type in Actions.sol, line 152 and Actions.sol, line 172. x to number in Math.sol, lines 69, 85 and 100. r to result in Math.sol, lines 75, 91 and 107. In Admin.sol and AdminImpl.sol, drop the word owner from the  names. For example, ownerWithdrawExcessTokens to withdrawExcessTokens. OperatorArg to Operator. operator to account. getAccountValues to getAccountSupplyAndBorrowValues in Storage.sol, line 296 and Getters.sol, line 319. getAdjustedAccountValues to getAccountSupplyAndBorrowValuesAdjusted. getIsLocalOperator to isLocalOperator. getIsGlobalOperator to isGlobalOperator. g_state to globalState. arg to action.Update: Partially fixed in pull request #228. The dYdX team prefers to keep some of these variable names.  Conclusion  No critical and two high severity issues were found. Some changes were proposed to follow best practices and reduce the potential attack surface.  The code of the contracts was carefully written by the Solo team, following a consistent and nice style, considering all the possible conditions, and with extensive tests. The idea of their protocol is very interesting, and the way they implemented it simplifies many details that in other similar projects become hard to understand, test, and audit.  However, the use of structs and libraries, the shared global state and the side-effects to keep it up-to-date, the split of responsibilities between multiple contracts (sometimes forced by Ethereum limitations), and the lack of comments, made the codebase hard to read and navigate, forcing us to jump through many files to fully understand every . In addition to that, the s did not specify their expected results, making them harder to audit for correctness. Most of these problems can be solved or mitigated by simply adding more comments to guide the readers, or with small tweaks of the design.  An important thing to notice for readers of this report and users of the Solo system is that, while most parts are non-custodial and allow free peer-to-peer interactions, the administrators are in full control of the fundamental parameters of the system. Also, to improve the usability and usefulness of the system, the Solo team decided to implement global operators that will be able to execute actions that can affect user accounts without waiting for their approval. These are important and necessary decisions to build a ing system. The Solo team has ensured the transparency of their system, and can easily implement time delays, present notifications on the user interface, and document every aspect of the system, to make sure that their users will have a clear idea of what to expect, what to monitor, and how to take full advantage of the available features.  Note that as of the date of publishing, the above review reflects the current understanding of known security patterns as they relate to the Solo contracts. The above should not be construed as investment advice. For general information about smart contract security, check out our thoughts here.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/solo-margin-protocol-audit-30ac2aaf6b10#function", "labels": ["OpenZeppelin"]}, {"title": "Unexpected return value from Time.hasHappened()", "body": "Unexpected return value from Time.hasHappened()", "html_url": "https://blog.openzeppelin.com/solo-margin-protocol-audit-30ac2aaf6b10#unexpected-return-value-from-time.hashappened()", "labels": ["OpenZeppelin"]}, {"title": "The hasHappened() function in the Time library will return false if the time is 0 instead of reverting. In the future, this may lead to a false positive if the function is being used to check if something hasn\u2019t happened yet. Consider reverting when the input value is 0.", "body": "The hasHappened() function in the Time library will return false if the time is 0 instead of reverting. In the future, this may lead to a false positive if the function is being used to check if something hasn\u2019t happened yet. Consider reverting when the input value is 0.", "html_url": "https://blog.openzeppelin.com/solo-margin-protocol-audit-30ac2aaf6b10#the-hashappened()-function-in-the-time-library-will-return-false-if-the-time-is-0-instead-of-reverting.-in-the-future,-this-may-lead-to-a-false-positive-if-the-function-is-being-used-to-check-if-something-hasn\u2019t-happened-yet.-consider-reverting-when-the-input-value-is-0.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in pull request #220.", "body": "Update: Fixed in pull request #220.", "html_url": "https://blog.openzeppelin.com/solo-margin-protocol-audit-30ac2aaf6b10#update:-fixed-in-pull-request-#220.", "labels": ["OpenZeppelin"]}, {"title": "Unused import", "body": "Unused import", "html_url": "https://blog.openzeppelin.com/solo-margin-protocol-audit-30ac2aaf6b10#unused-import", "labels": ["OpenZeppelin"]}, {"title": "In Monetary.sol it is unnecessary to import the SafeMath and Math libraries as they are never used.", "body": "In Monetary.sol it is unnecessary to import the SafeMath and Math libraries as they are never used.", "html_url": "https://blog.openzeppelin.com/solo-margin-protocol-audit-30ac2aaf6b10#in-monetary.sol-it-is-unnecessary-to-import-the-safemath-and-math-libraries-as-they-are-never-used.", "labels": ["OpenZeppelin"]}, {"title": "Update: Fixed in pull request #210.", "body": "Update: Fixed in pull request #210.", "html_url": "https://blog.openzeppelin.com/solo-margin-protocol-audit-30ac2aaf6b10#update:-fixed-in-pull-request-#210.", "labels": ["OpenZeppelin"]}, {"title": "Notes", "body": "Notes", "html_url": "https://blog.openzeppelin.com/solo-margin-protocol-audit-30ac2aaf6b10#notes", "labels": ["OpenZeppelin"]}, {"title": "Some contract files include the pragma experimental ABIEncoderV2; (for example, Admin.sol) and some others do not include it (for example, Decimal.sol). The effect of declaring the experimental pragma only on some files is not very clear. Consider declaring the usage of ABIEncoderV2 on all the Solidity files, for consistency, to make it clear that the new version of the encoder is used in the project, and to avoid any complications that can come for not declaring it in some files.Update: Fixed in pull request #229.", "body": "Some contract files include the pragma experimental ABIEncoderV2; (for example, Admin.sol) and some others do not include it (for example, Decimal.sol). The effect of declaring the experimental pragma only on some files is not very clear. Consider declaring the usage of ABIEncoderV2 on all the Solidity files, for consistency, to make it clear that the new version of the encoder is used in the project, and to avoid any complications that can come for not declaring it in some files.Update: Fixed in pull request #229.", "html_url": "https://blog.openzeppelin.com/solo-margin-protocol-audit-30ac2aaf6b10#some-contract-files-include-the-pragma-experimental-abiencoderv2;-(for-example,-admin.sol)-and-some-others-do-not-include-it-(for-example,-decimal.sol).-the-effect-of-declaring-the-experimental-pragma-only-on-some-files-is-not-very-clear.-consider-declaring-the-usage-of-abiencoderv2-on-all-the-solidity-files,-for-consistency,-to-make-it-clear-that-the-new-version-of-the-encoder-is-used-in-the-project,-and-to-avoid-any-complications-that-can-come-for-not-declaring-it-in-some-files.update:-fixed-in-pull-request-#229.", "labels": ["OpenZeppelin"]}, {"title": "Explicitly type cast integers before making a comparison between different types in the following locations:In Math.sol:\u2013 line 77\u2013 line 93\u2013 line 109In Types.sol:\u2013 line 98\u2013 line 102\u2013 line 105\u2013 line 211\u2013 line 215\u2013 line 218", "body": "Explicitly type cast integers before making a comparison between different types in the following locations:In Math.sol:\u2013 line 77\u2013 line 93\u2013 line 109In Types.sol:\u2013 line 98\u2013 line 102\u2013 line 105\u2013 line 211\u2013 line 215\u2013 line 218", "html_url": "https://blog.openzeppelin.com/solo-margin-protocol-audit-30ac2aaf6b10#explicitly-type-cast-integers-before-making-a-comparison-between-different-types-in-the-following-locations:in-math.sol:\u2013-line-77\u2013-line-93\u2013-line-109in-types.sol:\u2013-line-98\u2013-line-102\u2013-line-105\u2013-line-211\u2013-line-215\u2013-line-218", "labels": ["OpenZeppelin"]}, {"title": "In Decimal.sol add() takes two D256 and returns a D256. However, mul() and div() take a uint256 and a D256 and return a uint256. This may be confusing when comparable libraries such as SafeMath have consistency across arithmetic functions.", "body": "In Decimal.sol add() takes two D256 and returns a D256. However, mul() and div() take a uint256 and a D256 and return a uint256. This may be confusing when comparable libraries such as SafeMath have consistency across arithmetic functions.", "html_url": "https://blog.openzeppelin.com/solo-margin-protocol-audit-30ac2aaf6b10#in-decimal.sol-add()-takes-two-d256-and-returns-a-d256.-however,-mul()-and-div()-take-a-uint256-and-a-d256-and-return-a-uint256.-this-may-be-confusing-when-comparable-libraries-such-as-safemath-have-consistency-across-arithmetic-functions.", "labels": ["OpenZeppelin"]}, {"title": "All the copyright headers include \u201cCopyright 2018 dYdX Trading Inc.\u201d According to the Free Software Foundation, \u201cYou should add the proper year for each past release; for example, \u2018Copyright 1998, 1999 Terry Jones\u2019 if some releases were finished in 1998 and some were finished in 1999.\u201d Consider updating the copyright headers to add the year 2019.Update: Fixed in pull request #223.", "body": "All the copyright headers include \u201cCopyright 2018 dYdX Trading Inc.\u201d According to the Free Software Foundation, \u201cYou should add the proper year for each past release; for example, \u2018Copyright 1998, 1999 Terry Jones\u2019 if some releases were finished in 1998 and some were finished in 1999.\u201d Consider updating the copyright headers to add the year 2019.Update: Fixed in pull request #223.", "html_url": "https://blog.openzeppelin.com/solo-margin-protocol-audit-30ac2aaf6b10#all-the-copyright-headers-include-\u201ccopyright-2018-dydx-trading-inc.\u201d-according-to-the-free-software-foundation,-\u201cyou-should-add-the-proper-year-for-each-past-release;-for-example,-\u2018copyright-1998,-1999-terry-jones\u2019-if-some-releases-were-finished-in-1998-and-some-were-finished-in-1999.\u201d-consider-updating-the-copyright-headers-to-add-the-year-2019.update:-fixed-in-pull-request-#223.", "labels": ["OpenZeppelin"]}, {"title": "There are a couple of typos in the comments:\u2013 IErc20.sol L26 and Token.sol L167: \u201cdont\u201d instead of \u201cdon\u2019t\u201d.\u2013 SoloMargin.sol L34: \u201cinherets\u201d instead of \u201cinherits\u201d.Consider running codespell on pull requests.Update: Fixed in pull request #225.", "body": "There are a couple of typos in the comments:\u2013 IErc20.sol L26 and Token.sol L167: \u201cdont\u201d instead of \u201cdon\u2019t\u201d.\u2013 SoloMargin.sol L34: \u201cinherets\u201d instead of \u201cinherits\u201d.Consider running codespell on pull requests.Update: Fixed in pull request #225.", "html_url": "https://blog.openzeppelin.com/solo-margin-protocol-audit-30ac2aaf6b10#there-are-a-couple-of-typos-in-the-comments:\u2013-ierc20.sol-l26-and-token.sol-l167:-\u201cdont\u201d-instead-of-\u201cdon\u2019t\u201d.\u2013-solomargin.sol-l34:-\u201cinherets\u201d-instead-of-\u201cinherits\u201d.consider-running-codespell-on-pull-requests.update:-fixed-in-pull-request-#225.", "labels": ["OpenZeppelin"]}, {"title": "To favor explicitness and readability, several parts of the contracts may benefit from better naming. Our suggestions are:\u2013 ttype to type in Actions.sol, line 152 and Actions.sol,\u00a0line 172.\u2013 x to number in Math.sol, lines 69, 85 and 100.\u2013 r to result in Math.sol, lines 75, 91 and 107.\u2013 In Admin.sol and AdminImpl.sol, drop the word \u201cowner\u201d from the function names. For example, ownerWithdrawExcessTokens to withdrawExcessTokens.\u2013 OperatorArg to Operator.\u2013 operator to account.\u2013 getAccountValues to getAccountSupplyAndBorrowValues in Storage.sol,\u00a0line 296 and Getters.sol, line 319.\u2013 getAdjustedAccountValues to getAccountSupplyAndBorrowValuesAdjusted.\u2013 getIsLocalOperator to isLocalOperator.\u2013 getIsGlobalOperator to isGlobalOperator.\u2013 g_state to globalState.\u2013 arg to action.Update: Partially fixed in pull request #228. The dYdX team prefers to keep some of these variable names.", "body": "To favor explicitness and readability, several parts of the contracts may benefit from better naming. Our suggestions are:\u2013 ttype to type in Actions.sol, line 152 and Actions.sol,\u00a0line 172.\u2013 x to number in Math.sol, lines 69, 85 and 100.\u2013 r to result in Math.sol, lines 75, 91 and 107.\u2013 In Admin.sol and AdminImpl.sol, drop the word \u201cowner\u201d from the function names. For example, ownerWithdrawExcessTokens to withdrawExcessTokens.\u2013 OperatorArg to Operator.\u2013 operator to account.\u2013 getAccountValues to getAccountSupplyAndBorrowValues in Storage.sol,\u00a0line 296 and Getters.sol, line 319.\u2013 getAdjustedAccountValues to getAccountSupplyAndBorrowValuesAdjusted.\u2013 getIsLocalOperator to isLocalOperator.\u2013 getIsGlobalOperator to isGlobalOperator.\u2013 g_state to globalState.\u2013 arg to action.Update: Partially fixed in pull request #228. The dYdX team prefers to keep some of these variable names.", "html_url": "https://blog.openzeppelin.com/solo-margin-protocol-audit-30ac2aaf6b10#to-favor-explicitness-and-readability,-several-parts-of-the-contracts-may-benefit-from-better-naming.-our-suggestions-are:\u2013-ttype-to-type-in-actions.sol,-line-152-and-actions.sol,\u00a0line-172.\u2013-x-to-number-in-math.sol,-lines-69,-85-and-100.\u2013-r-to-result-in-math.sol,-lines-75,-91-and-107.\u2013-in-admin.sol-and-adminimpl.sol,-drop-the-word-\u201cowner\u201d-from-the-function-names.-for-example,-ownerwithdrawexcesstokens-to-withdrawexcesstokens.\u2013-operatorarg-to-operator.\u2013-operator-to-account.\u2013-getaccountvalues-to-getaccountsupplyandborrowvalues-in-storage.sol,\u00a0line-296-and-getters.sol,-line-319.\u2013-getadjustedaccountvalues-to-getaccountsupplyandborrowvaluesadjusted.\u2013-getislocaloperator-to-islocaloperator.\u2013-getisglobaloperator-to-isglobaloperator.\u2013-g_state-to-globalstate.\u2013-arg-to-action.update:-partially-fixed-in-pull-request-#228.-the-dydx-team-prefers-to-keep-some-of-these-variable-names.", "labels": ["OpenZeppelin"]}, {"title": "None.", "body": "None.", "html_url": "https://blog.openzeppelin.com/marmo-contracts-audit-3c17e9642120#none.", "labels": ["OpenZeppelin"]}, {"title": "Assembly and bytecode without extensive documentation", "body": "Assembly and bytecode without extensive documentation", "html_url": "https://blog.openzeppelin.com/marmo-contracts-audit-3c17e9642120#assembly-and-bytecode-without-extensive-documentation", "labels": ["OpenZeppelin"]}, {"title": "The Marmo contracts include multiple assembly blocks and a big amount of bytecode. While it is not a security vulnerability right now, this is at the same time the most complicated and the most critical part of the system, it needs to be documented with extra care.", "body": "The Marmo contracts include multiple assembly blocks and a big amount of bytecode. While it is not a security vulnerability right now, this is at the same time the most complicated and the most critical part of the system, it needs to be documented with extra care.", "html_url": "https://blog.openzeppelin.com/marmo-contracts-audit-3c17e9642120#the-marmo-contracts-include-multiple-assembly-blocks-and-a-big-amount-of-bytecode.-while-it-is-not-a-security-vulnerability-right-now,-this-is-at-the-same-time-the-most-complicated-and-the-most-critical-part-of-the-system,-it-needs-to-be-documented-with-extra-care.", "labels": ["OpenZeppelin"]}, {"title": "These assembly blocks and bytecode are not extensively documented. Developers may misunderstand the purpose of the code and cause unexpected errors when attempting to modify it.", "body": "These assembly blocks and bytecode are not extensively documented. Developers may misunderstand the purpose of the code and cause unexpected errors when attempting to modify it.", "html_url": "https://blog.openzeppelin.com/marmo-contracts-audit-3c17e9642120#these-assembly-blocks-and-bytecode-are-not-extensively-documented.-developers-may-misunderstand-the-purpose-of-the-code-and-cause-unexpected-errors-when-attempting-to-modify-it.", "labels": ["OpenZeppelin"]}, {"title": "Consider clearly documenting the intent of each block of assembly code, as well as exhaustively documenting every opcode and every parameter. This will guide future contributors and reviewers when trying to understand, extend or fix the code.", "body": "Consider clearly documenting the intent of each block of assembly code, as well as exhaustively documenting every opcode and every parameter. This will guide future contributors and reviewers when trying to understand, extend or fix the code.", "html_url": "https://blog.openzeppelin.com/marmo-contracts-audit-3c17e9642120#consider-clearly-documenting-the-intent-of-each-block-of-assembly-code,-as-well-as-exhaustively-documenting-every-opcode-and-every-parameter.-this-will-guide-future-contributors-and-reviewers-when-trying-to-understand,-extend-or-fix-the-code.", "labels": ["OpenZeppelin"]}, {"title": "pull request #28", "body": "pull request #28", "html_url": "https://blog.openzeppelin.com/marmo-contracts-audit-3c17e9642120#pull-request-#28", "labels": ["OpenZeppelin"]}, {"title": "library", "body": "library", "html_url": "https://blog.openzeppelin.com/marmo-contracts-audit-3c17e9642120#library", "labels": ["OpenZeppelin"]}, {"title": "MarmoStork constructor", "body": "MarmoStork constructor", "html_url": "https://blog.openzeppelin.com/marmo-contracts-audit-3c17e9642120#marmostork-constructor", "labels": ["OpenZeppelin"]}, {"title": "Implementations have full control over the Marmo\u00a0wallet", "body": "Implementations have full control over the Marmo\u00a0wallet", "html_url": "https://blog.openzeppelin.com/marmo-contracts-audit-3c17e9642120#implementations-have-full-control-over-the-marmo\u00a0wallet", "labels": ["OpenZeppelin"]}, {"title": "relay", "body": "an intent. Users could call the wrong implementations by mistake or by deception and lose control over their own wallets.  One possible solution would be to whitelist the EXTCODEHASH of verified implementations, and to block calls to unverified implementations. That brings limitations and an extra layer of complexity, though. If decided to leave as is, we recommend stating this risk clearly and display it to user  Update: This is by design. The RCN team does not plan to control a Marmo ecosystem, but to encourage users to deploy their private Marmo instances to  their own intents. Also, the system is designed to be used through an SDK which will prevent many problems that could happen if the intents are generated manually.  Medium Severity  Missing test coverage report  There is no automated test coverage report. Without this report it is impossible to know whether there are parts of the code never executed by the automated tests; so for every change, a full manual test suite has to be executed to make sure that nothing is broken or misbehaving.  Consider adding the test coverage report, and making it reach at least 95% of the source code.  Canceled event not emitted  The Marmo contract has a Canceled event that should be emitted when an intent is canceled. However, this event is not emitted by the cancel function. This will make more difficult for clients to follow the status of intents, forcing them to either listen for all the transactions of the contract or to poll calling isCanceled.  Consider emitting Canceled at the end of the cancel function.  Update: Fixed in pull request #29.  MarmoStork does not check the size of the implementation contract address explicitly  The constructor of the MarmoStork contract takes an array of bytes in the _source argument, and uses it as the destination address for a delegatecall. An ethereum address has 20 bytes, but the size of this array is not checked at the beginning of the function.  The length of this _source argument is then used to generate the bytecode of the contract that will delegate the calls. If an array that is not a valid address is passed to this constructor, the resulting bytecode will have an unintended behavior. The part generated from the length of the array is surrounded by other hardcoded bytecode, so it would be very difficult to craft an attack just by manipulating the length. But, for example, taking the part that generates the opcode that should push the address to the stack when the _source array length is bigger than that of a valid address, it can even result in the selfdestruct opcode instead of the expected push20.  Later in the constructor, this argument is converted to an address calling the toAddress function which does require the length to be 20 or less. So a bigger array will end up reverting the constructor, but this does not happen explicitly and because of that it has the risk of being removed by mistake.  Consider changing the type of the _source parameter to address. This will make the expectations clear and prevent any issues derived from invalid addresses. Alternatively, consider requiring the array to be 20 bytes at the start of the constructor, following best practices to fail early and to structure your functions starting with the conditions. Both options have an added benefit: a fixed size would simplify the bytecode generation because more terms can be replaced by constants.  pull request #30  constructor of MarmoStork  Low Severity  README is empty  The README.md files on the root of the git repositories are the first documents that most developers will read, so they should be complete, clear, concise and accurate.  The README.md of the Marmo contracts has no information about what is the purpose of the project nor how to use it.  Consider following Standard Readme to define the structure and contents for the README.md file. Consider including an explanation of the core concepts of the repository, the usage workflows, the public APIs, instructions to test and deploy it, and how it relates to the parts of the project.  Make sure to include instructions for the responsible disclosure of any security vulnerabilities found in the project.  README file  Standard Readme  There are hard-coded values in the code  There are hard-coded values in several Marmo contracts. For example, 65536 and 0xff. These values make the code harder to understand and to maintain.  Consider defining a constant variable for every hard-coded value, giving it a clear and explanatory name. For complex values, consider adding a comment explaining how were they calculated or why were they chosen.  #33  #37  32  in  Marmo.sol  line 125  0x20  in  MarmoStork.sol  line 82  Restricted Address Range is in Draft  The Marmo contract can be made unusable by setting the signer to the invalid address 65536. This address was chosen because it is the first one after the restricted range, as defined by EIP1352: Specify restricted address range for precompiles/system contracts.  This EIP is still a draft, so there is a little risk of it changing in the future and making 65536 one of the restricted addresses. If the code has to be released to production before the EIP is finalized, consider using a random address to invalidate the contract, instead of one so close to the restricted range.  pull request #33  higher address as an invalid signer  Duplicated Code to Get the Signer  signer  function that returns the address of the signer. This code is  duplicated in the  init  function.  Consider calling signer from the init function, instead of duplicating the code.  Update: The RCN team decided not to fix this in order to save one jump operation.  Misleading comment about destroying the wallet  The Marmo contract has a special INVALID_ADDRESS. According to the comments, the purpose of this address is to destroy the wallet. However, setting the signer to this invalid address does not destroy the wallet. Instead, it does make it impossible to  any further transactions, but the wallet contract still exists.  Consider updating the comments to more accurately describe the purpose and effect of the INVALID_ADDRESS.  Update: Fixed in pull request #38.  Invalid address check uses assert  The", "html_url": "https://blog.openzeppelin.com/marmo-contracts-audit-3c17e9642120#relay", "labels": ["OpenZeppelin"]}, {"title": "function of the", "body": "function of the", "html_url": "https://blog.openzeppelin.com/marmo-contracts-audit-3c17e9642120#function-of-the", "labels": ["OpenZeppelin"]}, {"title": "Marmo", "body": "contracts. We looked at the code and here are the results.  The audited code is located in the marmo-contracts repository. The version used for this report is d3fb5922a4f01e47d585343d08cccfad659b3584.  Following are our assessment and recommendations, in order of importance.  Update: the RCN team made some fixes based on our recommendations. We address below the fixes introduced up to commit cbe0388bd7a624f8ca73d805af4d31c5d0b53960.  Critical Severity  None.  High Severity  Assembly and bytecode without extensive documentation  The  contracts include multiple assembly blocks and a big amount of bytecode. While it is not a security vulnerability right now, this is at the same time the most complicated and the most critical part of the system, it needs to be documented with extra care.  These assembly blocks and bytecode are not extensively documented. Developers may misunderstand the purpose of the code and cause unexpected errors when attempting to modify it.  Consider clearly documenting the intent of each block of assembly code, as well as exhaustively documenting every opcode and every parameter. This will guide future contributors and reviewers when trying to understand, extend or fix the code.  pull request #28  library  Stork constructor  Implementations have full control over the  wallet  relay  function of the    contract uses  This gives implementations a lot of power and forces users to verify its deployed code every time they want to relay an intent. Users could call the wrong implementations by mistake or by deception and lose control over their own wallets.  One possible solution would be to whitelist the EXTCODEHASH of verified implementations, and to block calls to unverified implementations. That brings limitations and an extra layer of complexity, though. If decided to leave as is, we recommend stating this risk clearly and display it to user  Update: This is by design. The RCN team does not plan to control a  ecosystem, but to encourage users to deploy their private  instances to relay their own intents. Also, the system is designed to be used through an SDK which will prevent many problems that could happen if the intents are generated manually.  Medium Severity  Missing test coverage report  There is no automated test coverage report. Without this report it is impossible to know whether there are parts of the code never executed by the automated tests; so for every change, a full manual test suite has to be executed to make sure that nothing is broken or misbehaving.  Consider adding the test coverage report, and making it reach at least 95% of the source code.  Canceled event not emitted  The  contract has a Canceled event that should be emitted when an intent is canceled. However, this event is not emitted by the cancel function. This will make more difficult for clients to follow the status of intents, forcing them to either listen for all the transactions of the contract or to poll calling isCanceled.  Consider emitting Canceled at the end of the cancel function.  Update: Fixed in pull request #29.  Stork does not check the size of the implementation contract address explicitly  The constructor of the Stork contract takes an array of bytes in the _source argument, and uses it as the destination address for a delegatecall. An ethereum address has 20 bytes, but the size of this array is not checked at the beginning of the function.  The length of this _source argument is then used to generate the bytecode of the contract that will delegate the calls. If an array that is not a valid address is passed to this constructor, the resulting bytecode will have an unintended behavior. The part generated from the length of the array is surrounded by other hardcoded bytecode, so it would be very difficult to craft an attack just by manipulating the length. But, for example, taking the part that generates the opcode that should push the address to the stack when the _source array length is bigger than that of a valid address, it can even result in the selfdestruct opcode instead of the expected push20.  Later in the constructor, this argument is converted to an address calling the toAddress function which does require the length to be 20 or less. So a bigger array will end up reverting the constructor, but this does not happen explicitly and because of that it has the risk of being removed by mistake.  Consider changing the type of the _source parameter to address. This will make the expectations clear and prevent any issues derived from invalid addresses. Alternatively, consider requiring the array to be 20 bytes at the start of the constructor, following best practices to fail early and to structure your functions starting with the conditions. Both options have an added benefit: a fixed size would simplify the bytecode generation because more terms can be replaced by constants.  pull request #30  constructor of Stork  Low Severity  README is empty  The README.md files on the root of the git repositories are the first documents that most developers will read, so they should be complete, clear, concise and accurate.  The README.md of the  contracts has no information about what is the purpose of the project nor how to use it.  Consider following Standard Readme to define the structure and contents for the README.md file. Consider including an explanation of the core concepts of the repository, the usage workflows, the public APIs, instructions to test and deploy it, and how it relates to the parts of the project.  Make sure to include instructions for the responsible disclosure of any security vulnerabilities found in the project.  README file  Standard Readme  There are hard-coded values in the code  There are hard-coded values in several  contracts. For example, 65536 and 0xff. These values make the code harder to understand and to maintain.  Consider defining a constant variable for every hard-coded value, giving it a clear and explanatory name. For complex values, consider adding a comment explaining how were they calculated or why were they chosen.  #33  #37  32  in  .sol  line 125  0x20  in  Stork.sol  line 82  Restricted Address Range is in Draft  The  contract can be made unusable by setting the signer to the invalid address 65536. This address was chosen because it is the first one after the restricted range, as defined by EIP1352: Specify restricted address range for precompiles/system contracts.  This EIP is still a draft, so there is a little risk of it changing in the future and making 65536 one of the restricted addresses. If the code has to be released to production before the EIP is finalized, consider using a random address to invalidate the contract, instead of one so close to the restricted range.  pull request #33  higher address as an invalid signer  Duplicated Code to Get the Signer  signer  function that returns the address of the signer. This code is  duplicated in the  init  function.  Consider calling signer from the init function, instead of duplicating the code.  Update: The RCN team decided not to fix this in order to save one jump operation.  Misleading comment about destroying the wallet  The  contract has a special INVALID_ADDRESS. According to the comments, the purpose of this address is to destroy the wallet. However, setting the signer to this invalid address does not destroy the wallet. Instead, it does make it impossible to relay any further transactions, but the wallet contract still exists.  Consider updating the comments to more accurately describe the purpose and effect of the INVALID_ADDRESS.  Update: Fixed in pull request #38.  Invalid address check uses assert  The relay function of the  contract fails when the signer is the invalid address. This failure is executed with the assert function, so if somebody calls an invalidated contract by mistake, they will lose their gas.  Consider using require instead of assert to be more forgiving and return the remaining gas when an invalidated contract is called. Also, the semantics of the require statement are closer to the intent of this feature.  Update: Fixed in pull request #34.  Relayed event is emitted before the action is executed  emits a  Relayed  event. This event is emitted before the  reentrancy protection, it is safer and clearer to emit events immediately after the action they are signaling is executed.  Consider moving the emit of the Relayed event immediately after the delegatecall statement.  Update: This is by design. The RCN team wants to have the execution of an intent between two events.  Block on intent receipt can overflow  An intent receipt encodes the block in which it was relayed using 95 bits. Theoretically, the block numbers can be bigger than the maximum number that can fit in 95 bits, which means that the block can overflow as mentioned in a comment.  It is more likely that the Ethereum ecosystem will be completely different before we get to that many blocks, and it is true that an overflow will not affect the assumptions and conditions of the  contract. However, in the case of an overflow the relayedAt function will return wrong information.  Consider being extra safe by reverting when the block is bigger than the value that can be stored, or by storing the block in a uint256 variable. Or alternatively, consider documenting more thoroughly the effects of storing the block in 95 bits.  Update: The RCN team decided not to implement a revert in this case due to the costs and complications of addressing something with this low probability.  Re-implementing ECDSA signature recovery  The  project includes an implementation of the ECDSA signature recovery function. This function is already part of the OpenZeppelin package, which has been audited and is constantly reviewed by the community.  Consider using the recover function from OpenZeppelin to reduce the code surface area.  An important point related to this implementation is that it is subject to signature malleability, which means that multiple signatures will be considered valid. This also affects the OpenZeppelin implementation, and it is currently being discussed with the community to find the best solution. This issue does not affect the  contracts because the signatures are not used as if they were unique. However, consider documenting this to make it clear that higher layer applications should not consider the signatures unique either.  Update: The RCN team decided not to add external dependencies to their project.  No way to check whether a wallet has been revealed  The Stork contract has no way to check whether a wallet has been revealed.  Consider adding a mapping to save all the addresses of wallets that have been revealed. Consider emitting an event after a wallet is revealed.  Update: The RCN team considers this functionality unnecessary because extcodesize allows to check if an address has code.  Transactions can be relayed only once  The relay function of the", "html_url": "https://blog.openzeppelin.com/marmo-contracts-audit-3c17e9642120#marmo", "labels": ["OpenZeppelin"]}, {"title": "contract uses", "body": "the address of the wallet, the address of the implementation, and the signed transaction data as the id of the intent. This means that an intent can be relayed only once.  This is correct to prevent replay attacks. However, note that there will be many valid cases to call the same transaction multiple times. Consider adding a nonce to the intent data, to allow users to relay the same transaction securely.  Update: The Marmo SDK adds a salt to the transaction data to allow sending the same intent multiple times.  Notes & Additional Information  In the package.json file, ethlint and solium are listed as dependencies. Solium has been deprecated starting with version 1.2.0 on 20181225, and was renamed to Ethlint. Consider removing the Solium dependency.  The Truffle config file is full of comments and commented options coming from the template. Consider removing all the things that are not relevant for the developers of the Marmo project.  The docstrings of the contracts are not following the Ethereum Natural Specification Format (NatSpec). Consider following this specification on everything that is part of the contracts public API.  In the Marmo contract, there are two cases that call revert(\"Unknown error\"); (L95 and L138). While it is a good safeguard to catch unexpected conditions, these states should be impossible to reach. With a unit test suite that covers all the possible code paths, the impossibility of those states can be verified. Consider adding all the required unit tests to safely remove the revert statements. If you prefer to stay extra safe and keep these statements, consider modifying the code to use assert instead, to accurately reflect your intentions.  An intent receipt encodes the block in which it was relayed. When the intent is canceled, the block value is set to 0. Consider using the receipt to also record the block in which the intent was canceled, which might be useful for user interfaces or other projects using the system.  To favor explicitness and readability, several parts of the contracts may benefit from better naming. Our suggestions are:  MarmoStork to MarmoWalletFactory.  bytecode to deploymentBytecode.  marmo to marmoWalletImplementation.  marmoOf to getMarmoWalletAddress.  reveal to createMarmoWallet.  p to marmoWallet.  Marmo to MarmoWallet.  signer to existentSigner.  relayedBy to getIntentRelayer.  relayedAt to getBlockOfIntentExecution.  Relayed to IntentRelayed.  Canceled to IntentCanceled.  isCanceled to isIntentCanceled. Maybe even consider here modifying the implementation to avoid the negative, and call it isIntentValid.  relay to relayIntent.  _implementation to _executor.  MarmoImp to MarmoExecutor.  Receipt to IntentExecuted. Note that most of the projects similar to Marmo are using the term meta-transactions instead of intents. While intent is a good name for this concept, consider renaming it to be more aligned with the ecosystem and what people are starting to expect.  Conclusion  No critical and two high severity issues were found. Some changes were proposed to follow best practices and reduce the potential attack surface.  Note that as of the date of publishing, the above review reflects the current understanding of known security patterns as they relate to the Marmo contracts. The above should not be construed as investment advice. For general information about smart contract security, check out our thoughts here.  Related Posts  Venus Protocol Diamond Comptroller Audit  The Comptroller is the core smart contract system responsible for managing markets and risk within...  Security Audits  Trufin Audit  The TruStakeMATICv2 and its supporting contracts allow users to stake MATIC via delegation to a...  Security Audits  Land and Tunnel Audit  The LAND token follows the EIP-721 non-fungible token (NFT) standard and has been deployed on both...  Security Audit", "html_url": "https://blog.openzeppelin.com/marmo-contracts-audit-3c17e9642120#contract-uses", "labels": ["OpenZeppelin"]}, {"title": "This gives implementations a lot of power and forces users to verify its deployed code every time they want to relay an intent. Users could call the wrong implementations by mistake or by deception and lose control over their own wallets.", "body": "This gives implementations a lot of power and forces users to verify its deployed code every time they want to relay an intent. Users could call the wrong implementations by mistake or by deception and lose control over their own wallets.", "html_url": "https://blog.openzeppelin.com/marmo-contracts-audit-3c17e9642120#this-gives-implementations-a-lot-of-power-and-forces-users-to-verify-its-deployed-code-every-time-they-want-to-relay-an-intent.-users-could-call-the-wrong-implementations-by-mistake-or-by-deception-and-lose-control-over-their-own-wallets.", "labels": ["OpenZeppelin"]}, {"title": "One possible solution would be to whitelist the EXTCODEHASH of verified implementations, and to block calls to unverified implementations. That brings limitations and an extra layer of complexity, though. If decided to leave as is, we recommend stating this risk clearly and display it to user", "body": "One possible solution would be to whitelist the EXTCODEHASH of verified implementations, and to block calls to unverified implementations. That brings limitations and an extra layer of complexity, though. If decided to leave as is, we recommend stating this risk clearly and display it to user", "html_url": "https://blog.openzeppelin.com/marmo-contracts-audit-3c17e9642120#one-possible-solution-would-be-to-whitelist-the-extcodehash-of-verified-implementations,-and-to-block-calls-to-unverified-implementations.-that-brings-limitations-and-an-extra-layer-of-complexity,-though.-if-decided-to-leave-as-is,-we-recommend-stating-this-risk-clearly-and-display-it-to-user", "labels": ["OpenZeppelin"]}, {"title": "Update: This is by design. The RCN team does not plan to control a Marmo ecosystem, but to encourage users to deploy their private Marmo instances to relay their own intents. Also, the system is designed to be used through an SDK which will prevent many problems that could happen if the intents are generated manually.", "body": "Update: This is by design. The RCN team does not plan to control a Marmo ecosystem, but to encourage users to deploy their private Marmo instances to relay their own intents. Also, the system is designed to be used through an SDK which will prevent many problems that could happen if the intents are generated manually.", "html_url": "https://blog.openzeppelin.com/marmo-contracts-audit-3c17e9642120#update:-this-is-by-design.-the-rcn-team-does-not-plan-to-control-a-marmo-ecosystem,-but-to-encourage-users-to-deploy-their-private-marmo-instances-to-relay-their-own-intents.-also,-the-system-is-designed-to-be-used-through-an-sdk-which-will-prevent-many-problems-that-could-happen-if-the-intents-are-generated-manually.", "labels": ["OpenZeppelin"]}, {"title": "Missing test coverage\u00a0report", "body": "Missing test coverage\u00a0report", "html_url": "https://blog.openzeppelin.com/marmo-contracts-audit-3c17e9642120#missing-test-coverage\u00a0report", "labels": ["OpenZeppelin"]}]