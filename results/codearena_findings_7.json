[{"title": "`public` functions can be `external`", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/126", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged", "GovernorAlpha"], "target": "2021-11-vader-findings", "body": "`public` functions can be `external`"}, {"title": "Prefix increaments are cheaper than postfix increaments", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/125", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-11-vader-findings", "body": "Prefix increaments are cheaper than postfix increaments"}, {"title": "Unchecked{i++} is better than i++", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/124", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-vader-findings", "body": "Unchecked{i++} is better than i++"}, {"title": "Caching array length to save gas", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/123", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-11-vader-findings", "body": "Caching array length to save gas"}, {"title": "Add zero address validation in the GovernorAlpha contract", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/122", "labels": ["bug", "1 (Low Risk)", "GovernorAlpha"], "target": "2021-11-vader-findings", "body": "Add zero address validation in the GovernorAlpha contract"}, {"title": "Incompatibility With Rebasing/Deflationary/Inflationary tokens", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/118", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "BasePool"], "target": "2021-11-vader-findings", "body": "Incompatibility With Rebasing/Deflationary/Inflationary tokens"}, {"title": "Redundant Functions", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/117", "labels": ["bug", "G (Gas Optimization)", "sponsor disputed", "SwapQueue"], "target": "2021-11-vader-findings", "body": "Redundant Functions"}, {"title": "Redundant Gas Modifider", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/115", "labels": ["bug", "0 (Non-critical)", "sponsor disputed", "GasThrottle"], "target": "2021-11-vader-findings", "body": "Redundant Gas Modifider"}, {"title": "Redundant Code Statement", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/114", "labels": ["bug", "G (Gas Optimization)", "sponsor disputed", "GovernorAlpha"], "target": "2021-11-vader-findings", "body": "Redundant Code Statement"}, {"title": "No event emission for \"guardian\" changes (GovernorAlpha.sol)", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/110", "labels": ["bug", "0 (Non-critical)", "sponsor disputed", "GovernorAlpha"], "target": "2021-11-vader-findings", "body": "No event emission for \"guardian\" changes (GovernorAlpha.sol)"}, {"title": "No event emission for \"timelock\" changes (GovernorAlpha.sol)", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/108", "labels": ["bug", "0 (Non-critical)", "sponsor disputed", "GovernorAlpha"], "target": "2021-11-vader-findings", "body": "No event emission for \"timelock\" changes (GovernorAlpha.sol)"}, {"title": "Long Revert Strings", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/104", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-11-vader-findings", "body": "Long Revert Strings"}, {"title": "User may not receive the full amount of IL compensation", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/100", "labels": ["bug", "2 (Med Risk)", "sponsor disputed", "VaderReserve"], "target": "2021-11-vader-findings", "body": "User may not receive the full amount of IL compensation"}, {"title": "internal function _addLiquidity in the router is unnecessary", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/99", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged", "VaderRouter"], "target": "2021-11-vader-findings", "body": "internal function _addLiquidity in the router is unnecessary"}, {"title": "Attacker can get extremely cheap synth by front-running create Pool", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/98", "labels": ["bug", "3 (High Risk)", "sponsor disputed", "VaderPoolV2", "VaderPoolFactory"], "target": "2021-11-vader-findings", "body": "Attacker can get extremely cheap synth by front-running create Pool"}, {"title": "token allocation specs in contract code does not match with whitepaper", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/95", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged", "ProtocolConstants"], "target": "2021-11-vader-findings", "body": "token allocation specs in contract code does not match with whitepaper"}, {"title": "Save gas by caching array length used in for loops", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/94", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged", "GovernorAlpha", "LinearVesting"], "target": "2021-11-vader-findings", "body": "# Handle  0x0x0x   # Vulnerability details  ## Proof of Concept Example: ``` for (uint i = 0; i < arr.length; i++) { //Operations not effecting the length of the array. } ``` Loading length of array costs gas. Therefore, the length should be cached, if the length of the array doesn't change inside the loop. Recommended implementation: ``` uint length = arr.length; for (uint i = 0; i < length; i++) { //Operations not effecting the length of the array. } ``` By doing so the length is only loaded once rather than loading it as many times as iterations (Therefore, less gas is spent).  ## Occurences ``` contracts/FeeSplitter.sol:108:        for (uint256 i = 0; i < _accounts.length; i++) { contracts/FeeSplitter.sol:125:        for (uint256 i = 0; i < _tokens.length; i++) { contracts/FeeSplitter.sol:210:        for (uint256 i = 0; i < shareholders.length; i++) { contracts/FeeSplitter.sol:227:        for (uint256 i = 0; i < shareholders.length; i++) { contracts/MixinOperatorResolver.sol:32:        for (uint256 i = 0; i < requiredAddresses.length; i++) { contracts/MixinOperatorResolver.sol:48:        for (uint256 i = 0; i < requiredAddresses.length; i++) { contracts/NestedFactory.sol:203:        for (uint256 i = 0; i < tokens.length; i++) { contracts/NestedFactory.sol:280:        for (uint256 i = 0; i < _orders.length; i++) { contracts/NestedFactory.sol:316:        for (uint256 i = 0; i < _orders.length; i++) { contracts/OperatorResolver.sol:33:        for (uint256 i = 0; i < names.length; i++) { contracts/OperatorResolver.sol:45:        for (uint256 i = 0; i < names.length; i++) { contracts/OperatorResolver.sol:56:        for (uint256 i = 0; i < destinations.length; i++) { ```  "}, {"title": "Missing hasStarted modifier, can lead to user vesting before the owner begin the vesting", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/90", "labels": ["bug", "2 (Med Risk)", "LinearVesting"], "target": "2021-11-vader-findings", "body": "Missing hasStarted modifier, can lead to user vesting before the owner begin the vesting"}, {"title": "using memory pointer instead storage", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/87", "labels": ["bug", "duplicate", "G (Gas Optimization)", "LinearVesting"], "target": "2021-11-vader-findings", "body": "using memory pointer instead storage"}, {"title": "using memory pointer instead storage", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/86", "labels": ["bug", "G (Gas Optimization)", "LinearVesting"], "target": "2021-11-vader-findings", "body": "using memory pointer instead storage"}, {"title": "Multiple Solidity pragma in repo/vader-bond/contracts/VaderBond.sol", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/79", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged", "VaderBond"], "target": "2021-11-vader-findings", "body": "Multiple Solidity pragma in repo/vader-bond/contracts/VaderBond.sol"}, {"title": "Multiple Solidity pragma in repo/vader-bond/contracts/Treasury.sol", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/78", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged", "VaderBond", "Treasury"], "target": "2021-11-vader-findings", "body": "Multiple Solidity pragma in repo/vader-bond/contracts/Treasury.sol"}, {"title": "Multiple Solidity pragma repo/vader-bond/contracts/lib/FixedPoint.sol", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/77", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged", "VaderBond"], "target": "2021-11-vader-findings", "body": "Multiple Solidity pragma repo/vader-bond/contracts/lib/FixedPoint.sol"}, {"title": "Multiple Solidity pragma In repo/vader-bond/contracts/Ownable.sol", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/76", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged", "VaderBond"], "target": "2021-11-vader-findings", "body": "Multiple Solidity pragma In repo/vader-bond/contracts/Ownable.sol"}, {"title": "Multiple Solidity pragma repo/vader-bond/contracts/lib/FullMath.sol", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/75", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged", "VaderBond"], "target": "2021-11-vader-findings", "body": "Multiple Solidity pragma repo/vader-bond/contracts/lib/FullMath.sol"}, {"title": "Multiple Solidity pragma in repo/vader-bond/contracts/test/TestToken.sol", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/74", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged", "VaderBond"], "target": "2021-11-vader-findings", "body": "Multiple Solidity pragma in repo/vader-bond/contracts/test/TestToken.sol"}, {"title": "Multiple Solidity pragma in repo/vader-bond/contracts/interfaces/ITreasury.sol ", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/73", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged", "Treasury"], "target": "2021-11-vader-findings", "body": "Multiple Solidity pragma in repo/vader-bond/contracts/interfaces/ITreasury.sol "}, {"title": "Multiple Solidity pragma", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/72", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged", "VaderBond"], "target": "2021-11-vader-findings", "body": "Multiple Solidity pragma"}, {"title": "(dex-v1) BasePool.mint() function can be frontrun", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/71", "labels": ["bug", "3 (High Risk)", "sponsor disputed", "BasePool"], "target": "2021-11-vader-findings", "body": "(dex-v1) BasePool.mint() function can be frontrun"}, {"title": "`onlyOnwer` in the synthFactory is confusing", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/68", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor acknowledged", "VaderPoolV2"], "target": "2021-11-vader-findings", "body": "`onlyOnwer` in the synthFactory is confusing"}, {"title": "add liquidity is vulnerable to sandwich attack", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/67", "labels": ["bug", "2 (Med Risk)", "sponsor disputed", "VaderRouterV2"], "target": "2021-11-vader-findings", "body": "add liquidity is vulnerable to sandwich attack"}, {"title": " calculate Loss is vulnerable to flashloan attack", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/65", "labels": ["bug", "3 (High Risk)", "sponsor disputed", "VaderMath"], "target": "2021-11-vader-findings", "body": " calculate Loss is vulnerable to flashloan attack"}, {"title": "Using SafeMath ins Solidity 0.8.9 contracts wastes gas", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/64", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-11-vader-findings", "body": "Using SafeMath ins Solidity 0.8.9 contracts wastes gas"}, {"title": "Unnecessary validation of `proposalId>0` due to incorrect proposalId increments", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/62", "labels": ["bug", "G (Gas Optimization)", "sponsor disputed", "GovernorAlpha"], "target": "2021-11-vader-findings", "body": "Unnecessary validation of `proposalId>0` due to incorrect proposalId increments"}, {"title": "Governance Veto lacks sufficient validation to protect against frontrunning", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/61", "labels": ["bug", "1 (Low Risk)", "sponsor disputed", "GovernorAlpha"], "target": "2021-11-vader-findings", "body": "Governance Veto lacks sufficient validation to protect against frontrunning"}, {"title": "Some public functions can be converted as external", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/52", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged", "GovernorAlpha"], "target": "2021-11-vader-findings", "body": "Some public functions can be converted as external"}, {"title": "Use SafeERC20 library", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/46", "labels": ["bug", "invalid", "sponsor disputed", "USDV", "XVader", "GovernorAlpha"], "target": "2021-11-vader-findings", "body": "Use SafeERC20 library"}, {"title": "Did not check if vestor is address(0)", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/42", "labels": ["bug", "1 (Low Risk)", "sponsor disputed", "LinearVesting"], "target": "2021-11-vader-findings", "body": "Did not check if vestor is address(0)"}, {"title": "Cache length of array before loop to optimize gas", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/41", "labels": ["bug", "G (Gas Optimization)", "LinearVesting"], "target": "2021-11-vader-findings", "body": "Cache length of array before loop to optimize gas"}, {"title": "Use `indexed` keyword in events which can be used as filter", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/40", "labels": ["bug", "0 (Non-critical)", "Vader"], "target": "2021-11-vader-findings", "body": "Use `indexed` keyword in events which can be used as filter"}, {"title": "VaderReserve does not support paying IL protection out to more than one address, resulting in locked funds", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/37", "labels": ["bug", "3 (High Risk)", "sponsor disputed", "VaderRouter", "VaderRouterV2"], "target": "2021-11-vader-findings", "body": "VaderReserve does not support paying IL protection out to more than one address, resulting in locked funds"}, {"title": "Paying IL protection for all VaderPool pairs allows the reserve to be drained.", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/34", "labels": ["bug", "3 (High Risk)", "sponsor disputed", "VaderRouter", "VaderPool"], "target": "2021-11-vader-findings", "body": "Paying IL protection for all VaderPool pairs allows the reserve to be drained."}, {"title": "LPs of VaderPoolV2 can manipulate pool reserves to extract funds from the reserve.", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/31", "labels": ["bug", "question", "3 (High Risk)", "VaderPoolV2", "VaderRouterV2"], "target": "2021-11-vader-findings", "body": "LPs of VaderPoolV2 can manipulate pool reserves to extract funds from the reserve."}, {"title": "Function LinearVesting.claim() will never meet require conditions", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/29", "labels": ["bug", "1 (Low Risk)", "sponsor disputed", "LinearVesting"], "target": "2021-11-vader-findings", "body": "Function LinearVesting.claim() will never meet require conditions"}, {"title": "Use `_safeMint()` instead of `_mint()`", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/27", "labels": ["bug", "1 (Low Risk)", "sponsor disputed", "BasePoolV2", "VaderRouterV2"], "target": "2021-11-vader-findings", "body": "Use `_safeMint()` instead of `_mint()`"}, {"title": "_totalSupply can be different from actual supply", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/26", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged", "StakingRewards"], "target": "2021-11-vader-findings", "body": "_totalSupply can be different from actual supply"}, {"title": "VaderRouter breaks compatibility with IUniswapV2Router0X", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/25", "labels": ["bug", "0 (Non-critical)", "VaderRouter"], "target": "2021-11-vader-findings", "body": "VaderRouter breaks compatibility with IUniswapV2Router0X"}, {"title": "VaderRouterV2 breaks compatibility with IUniswapV2Router0X", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/24", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "VaderRouterV2"], "target": "2021-11-vader-findings", "body": "VaderRouterV2 breaks compatibility with IUniswapV2Router0X"}, {"title": "Use proxy clones to create Synths & LPTokens", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/21", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged", "SynthFactory", "LPWrapper"], "target": "2021-11-vader-findings", "body": "Use proxy clones to create Synths & LPTokens"}, {"title": "Use of SafeERC20 for known tokens used extra gas unnecessarily", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/7", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged", "Vader", "USDV"], "target": "2021-11-vader-findings", "body": "Use of SafeERC20 for known tokens used extra gas unnecessarily"}, {"title": "BasePool does not account for Vader transfer fees when removing liquidity", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/4", "labels": ["bug", "0 (Non-critical)", "sponsor disputed", "Vader", "BasePool"], "target": "2021-11-vader-findings", "body": "BasePool does not account for Vader transfer fees when removing liquidity"}, {"title": "Redemption value of synths can be manipulated to drain `VaderPool` of all native assets", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/3", "labels": ["bug", "question", "3 (High Risk)", "VaderPoolV2"], "target": "2021-11-vader-findings", "body": "Redemption value of synths can be manipulated to drain `VaderPool` of all native assets"}, {"title": "Minting and burning synths exposes users to unlimited slippage", "html_url": "https://github.com/code-423n4/2021-11-vader-findings/issues/2", "labels": ["bug", "3 (High Risk)", "disagree with severity", "sponsor acknowledged", "VaderPoolV2"], "target": "2021-11-vader-findings", "body": "Minting and burning synths exposes users to unlimited slippage"}, {"title": "Passing multiple ETH deposits in orders array will use the same msg.value many times", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/226", "labels": ["bug", "2 (Med Risk)", "disagree with severity"], "target": "2021-11-nested-findings", "body": "Passing multiple ETH deposits in orders array will use the same msg.value many times"}, {"title": "NestedFactory._decreaseHoldingAmount needs explicit amount control for spending reserve", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/223", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-11-nested-findings", "body": "NestedFactory._decreaseHoldingAmount needs explicit amount control for spending reserve"}, {"title": "NestedFactory.removeOperator code doesn't correspond to it's logic", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/220", "labels": ["bug", "1 (Low Risk)"], "target": "2021-11-nested-findings", "body": "NestedFactory.removeOperator code doesn't correspond to it's logic"}, {"title": "Ensure on-chain that cache is synced", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/217", "labels": ["bug", "2 (Med Risk)"], "target": "2021-11-nested-findings", "body": "Ensure on-chain that cache is synced"}, {"title": "mintWithMetadata onlyFactory ", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/213", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact function \"mintWithMetadata\" does not need onlyFactory modifier as it will be checked in function \"mint\" later.   "}, {"title": "OperatorResolver.areAddressesImported doesn't check lengths of argument arrays", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/210", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  hyh   # Vulnerability details  ## Impact  Array bounds check violation will happen if the function be called with arrays of different lengths.  ## Proof of Concept  Loop is performed by names array, while both arrays are accessed: ``` for (uint256 i = 0; i < names.length; i++) {   if (operators[names[i]] != destinations[i]) { ``` https://github.com/code-423n4/2021-11-nested/blob/main/contracts/OperatorResolver.sol#L27  ## Recommended Mitigation Steps  Add a check: ``` require(names.length == destinations.length, \"OperatorResolver::areAddressesImported: Input lengths must match\"); ```  "}, {"title": "_burnNST", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/208", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact I think it is not necessary to have function _burnNST as a separate private function. It is called only once and has just one LOC so it just incurs in extra gas cost which can be avoided by moving this line to function trigger and getting rid of _burnNST.   "}, {"title": "index + 1 can be simplified", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/207", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact This can be simplified to reduce gas costs by eliminating math operation: ```solidity   // before   require(_accountIndex + 1 <= shareholders.length, \"FeeSplitter: INVALID_ACCOUNT_INDEX\");   // after   require(_accountIndex < shareholders.length, \"FeeSplitter: INVALID_ACCOUNT_INDEX\");  ```  "}, {"title": "INestedToken interface", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/206", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact INestedToken is declared as an abstract contract, yet it contains no function bodies and is located under the interfaces directory, so I think it should be declared as an interface.  ## Recommended Mitigation Steps Consider making INestedToken an interface.  "}, {"title": "NestedAsset.setFactory should be named addFactory", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/204", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  hyh   # Vulnerability details  ```setFactory``` should be named ```addFactory``` as it doesn't set the only factory, but adds to the list of factories  https://github.com/code-423n4/2021-11-nested/blob/main/contracts/NestedAsset.sol#L133  "}, {"title": "Can't revoke factory in NestedRecrods", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/203", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact NestedRecords contains no removeFactory function so there is no way to revoke a factory in case you no longer want to support it. This function is present in NestedAsset contract so I thought you might want to also have it here.  ## Recommended Mitigation Steps Consider if you are missing removeFactory or is this an intended functionality.   "}, {"title": "NestedFactory.addTokens and withdraw functions require NFT reserve check", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/199", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  hyh   # Vulnerability details  ## Impact  NFT token operations will fail if wrong reserve is used.  ## Proof of Concept  ```NestedFactory``` ```reserve``` is used in ```addtokens``` and ```withdraw``` function for a given NFT, but the NFT to reserve contract correspondence isn't checked.  addtokens: https://github.com/code-423n4/2021-11-nested/blob/main/contracts/NestedFactory.sol#L119  withdraw: https://github.com/code-423n4/2021-11-nested/blob/main/contracts/NestedFactory.sol#L241  ## Recommended Mitigation Steps  Add the ```require(nestedRecords.getAssetReserve(_nftId) == address(reserve), \"...\")``` check in the beginning of the functions.  "}, {"title": "Check condition before calling NestedFactory._handleUnderSpending", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/198", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  hyh   # Vulnerability details  ## Impact  Whenever condition of the ```_handleUnderSpending``` function fails function call gas costs are wasted. The cost of checking the condition is paid anyway, while when it doesn't hold the function call costs are avoidable.  ## Proof of Concept  ```_handleUnderSpending``` checks for ```_amountToSpent - _amountSpent > 0```.  https://github.com/code-423n4/2021-11-nested/blob/main/contracts/NestedFactory.sol#L481  ## Recommended Mitigation Steps  When the check condition is false ```_handleUnderSpending``` shouldn't be called and this way the check with corresponding variables to be placed in caller functions:  _submitInOrders https://github.com/code-423n4/2021-11-nested/blob/main/contracts/NestedFactory.sol#L306  _safeSubmitOrder https://github.com/code-423n4/2021-11-nested/blob/main/contracts/NestedFactory.sol#L415  "}, {"title": "Unused local variables ", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/195", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-nested-findings", "body": "Unused local variables "}, {"title": "Small refactor for functions to save some gas", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/193", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  0xngndev   # Vulnerability details  ## Impact In `FeeSplitter.sol` by doing a small refactory gas can be saved in case of a revert in the functions: `getAmountDue` and `_releaseToken` . We can swap the order of two lines so we return earlier in case of a bad input, this way we save some gas because the evm would execute less opcodes before reverting.  ## Mitigation steps getAmountDue: Swap line 83 with 84 to avoid computing unnecessary logic. Remove the \"else\"  and combine it with line 83. Something like this:  ```   function getAmountDue(address _account, IERC20 _token) public view returns (uint256) {         TokenRecords storage _tokenRecords = tokenRecords[address(_token)];     if (_tokenRecords.totalShares == 0) return 0;         uint256 totalReceived = _tokenRecords.totalReleased + _token.balanceOf(address(this));         uint256 amountDue = (totalReceived * _tokenRecords.shares[_account]) /             _tokenRecords.totalShares -             _tokenRecords.released[_account];         return amountDue;     } ``` _releaseToken: move line 252 after the require in line 254. Like this:  ```   function _releaseToken(address _account, IERC20 _token) private returns (uint256) {         uint256 amountToRelease = getAmountDue(_account, _token);         require(amountToRelease != 0, \"FeeSplitter: NO_PAYMENT_DUE\");         TokenRecords storage _tokenRecords = tokenRecords[address(_token)];          _tokenRecords.released[_account] = _tokenRecords.released[_account] + amountToRelease;         _tokenRecords.totalReleased = _tokenRecords.totalReleased + amountToRelease;          return amountToRelease;     } ```   "}, {"title": "Unnecessary Use of _msgSender()", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/185", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "Unnecessary Use of _msgSender()"}, {"title": "`_handleUnderSpending` reverts if condition is false", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/183", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  cmichel   # Vulnerability details  The `NestedFactory._handleUnderSpending` function implements a condition as `_amountToSpent - _amountSpent > 0` instead of `_amountToSpent > _amountSpent`. The former reverts if `_amountSpent > _amountToSpent` while the latter doesn't.  It's unclear which behavior is preferred.  ## Recommended Mitigation Steps Think about if `_amountSpent > _amountToSpent` should revert or not. If not, the `if` condition can be rewritten as `_amountSpent > _amountToSpent` which would also save gas.  "}, {"title": "Function using `msg.value` called in loop", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/182", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-11-nested-findings", "body": "Function using `msg.value` called in loop"}, {"title": "Can add duplicate operators", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/180", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  cmichel   # Vulnerability details  The `NestedFactory.addOperator` function pushes the `operator` even if it already exists in `operators`.  ## Impact When this duplicated operator is removed through a `removeOperator` call, only the first instance is removed. The operator can now still be called which can lead to unexpected behavior.  ## Recommended Mitigation Steps Check if the operator already exists before adding it.  "}, {"title": "Cannot change `tokenUri`", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/179", "labels": ["bug", "1 (Low Risk)", "sponsor disputed"], "target": "2021-11-nested-findings", "body": "Cannot change `tokenUri`"}, {"title": "Missing parameter validation", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/178", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "Missing parameter validation"}, {"title": "Cache and read storage variables from the stack can save gas", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/175", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "Cache and read storage variables from the stack can save gas"}, {"title": "Adding unchecked directive can save gas", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/173", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-11-nested-findings", "body": "Adding unchecked directive can save gas"}, {"title": "`NestedFactory#removeOperator()` Avoid empty items can save gas", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/170", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-nested-findings", "body": "`NestedFactory#removeOperator()` Avoid empty items can save gas"}, {"title": "Inconsistent use of `_msgSender()`", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/169", "labels": ["bug", "invalid", "sponsor disputed"], "target": "2021-11-nested-findings", "body": "Inconsistent use of `_msgSender()`"}, {"title": "Consider making `_calculateFees` inline to save gas", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/167", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-nested/blob/f646002b692ca5fa3631acfff87dda897541cf41/contracts/NestedFactory.sol#L553-L559  ```solidity=553 /// @dev Calculate the fees for a specific user and amount (1%) /// @param _user The user address /// @param _amount The amount /// @return The fees amount function _calculateFees(address _user, uint256 _amount) private view returns (uint256) {     return _amount / 100; } ```  The function `_calculateFees()` is a rather simple function, replacing it with inline expression `_amount / 100` can save some gas.  "}, {"title": "Use of assert() instead of require()", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/166", "labels": ["bug", "1 (Low Risk)"], "target": "2021-11-nested-findings", "body": "Use of assert() instead of require()"}, {"title": "Avoid unnecessary storage writes can save gas", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/162", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  WatchPug   # Vulnerability details  `releaseToken()` has `nonReentrant` modifier, making `releaseTokens()` to set storage `_status` multiple times in the for loop.  https://github.com/code-423n4/2021-11-nested/blob/f646002b692ca5fa3631acfff87dda897541cf41/contracts/FeeSplitter.sol#L116-L129  ```solidity=116 function releaseToken(IERC20 _token) public nonReentrant {     uint256 amount = _releaseToken(_msgSender(), _token);     _token.safeTransfer(_msgSender(), amount);     emit PaymentReleased(_msgSender(), address(_token), amount); }  /// @notice Call releaseToken() for multiple tokens /// @param _tokens ERC20 tokens to release function releaseTokens(IERC20[] memory _tokens) external {     for (uint256 i = 0; i < _tokens.length; i++) {         releaseToken(_tokens[i]);     } } ```  ### Recommendation  Change to:  ```solidity=116 function releaseToken(IERC20 _token) public nonReentrant {     _releaseTokenAndTransfer(_token); }  /// @notice Call releaseToken() for multiple tokens /// @param _tokens ERC20 tokens to release function releaseTokens(IERC20[] memory _tokens) external {     for (uint256 i = 0; i < _tokens.length; i++) {         _releaseTokenAndTransfer(_tokens[i]);     } }  function _releaseTokenAndTransfer(IERC20 _token) private {     uint256 amount = _releaseToken(_msgSender(), _token);     _token.safeTransfer(_msgSender(), amount);     emit PaymentReleased(_msgSender(), address(_token), amount); } ```  "}, {"title": "Misleading error message", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/161", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Permissions.sol#L80-L86  ```solidity=80 function emergencyWithdrawGAS(address payable destination)     external      onlyRole(TIMELOCK_ROLE, \"Only timelock can assign roles\")   {     // Transfers the entire balance of the Gas token to destination     destination.call{value: address(this).balance}('');   } ```  The error message \"Only timelock can assign roles\" can be changed to \"Only timelock can emergencyWithdrawGAS\".  Other examples include:  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/Permissions.sol#L104-L110  ```solidity=104 function partialWithdraw(address _token, address destination, uint256 amount)     external      onlyRole(TIMELOCK_ROLE, \"Only timelock can assign roles\")   {     ERC20 token = ERC20(_token);     token.safeTransfer(destination, amount);   } ```  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/PoolTransferVerification.sol#L94-L94  ```solidity=94 require(_pool != address(0), \"Cannot have 0 lookback\"); ```  https://github.com/code-423n4/2021-11-malt/blob/c3a204a2c0f7c653c6c2dda9f4563fd1dc1cecf3/src/contracts/AuctionEscapeHatch.sol#L230-L230  ```solidity=230 require(_period > 0, \"Cannot have 0 lookback period\"); ```  "}, {"title": "`NestedFactory.sol#_submitInOrders()` Wrong implementation cause users to be overcharged", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/160", "labels": ["bug", "2 (Med Risk)", "sponsor disputed"], "target": "2021-11-nested-findings", "body": "`NestedFactory.sol#_submitInOrders()` Wrong implementation cause users to be overcharged"}, {"title": "Gas Optimization: Set allowance only when needed", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/151", "labels": ["bug", "G (Gas Optimization)", "sponsor disputed"], "target": "2021-11-nested-findings", "body": "Gas Optimization: Set allowance only when needed"}, {"title": "Gas Optimization: Pack struct in FeeSplitter.sol", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/146", "labels": ["bug", "G (Gas Optimization)", "sponsor disputed"], "target": "2021-11-nested-findings", "body": "Gas Optimization: Pack struct in FeeSplitter.sol"}, {"title": "isResolverCached() will always return false after removing operator", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/139", "labels": ["bug", "2 (Med Risk)"], "target": "2021-11-nested-findings", "body": "isResolverCached() will always return false after removing operator"}, {"title": "FeeSplitter: Unbounded number of shareholders can cause DOS", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/137", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2021-11-nested-findings", "body": "FeeSplitter: Unbounded number of shareholders can cause DOS"}, {"title": "NestedFactory: Ensure zero msg.value if transferring from user and inputToken is not ETH ", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/136", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  GreyArt   # Vulnerability details  ## Impact  A user that mistakenly calls either `create()` or `addToken()` with WETH (or another ERC20) as the input token, but includes native ETH with the function call will have his native ETH permanently locked in the contract.  ## Recommended Mitigation Steps  It is best to ensure that `msg.value = 0` in `_transferInputTokens()` for the scenario mentioned above.  ```jsx } else if (address(_inputToken) == ETH) {  ... } else {  require(msg.value == 0, \"NestedFactory::_transferInputTokens: ETH sent for non-ETH transfer\");   _inputToken.safeTransferFrom(_msgSender(), address(this), _inputTokenAmount); } ```  "}, {"title": "FeeSplitter: No sanity check to prevent shareholder from being added twice.", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/135", "labels": ["bug", "2 (Med Risk)"], "target": "2021-11-nested-findings", "body": "FeeSplitter: No sanity check to prevent shareholder from being added twice."}, {"title": "FeeSplitter: ETH_ADDR isn't supported", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/134", "labels": ["bug", "1 (Low Risk)", "disagree with severity"], "target": "2021-11-nested-findings", "body": "FeeSplitter: ETH_ADDR isn't supported"}, {"title": "NestedFactory: _fromReserve param in _submitOutOrders() is redundant", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/128", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  GreyArt   # Vulnerability details  ## Impact  `_submitOutOrders()` is invoked by 2 functions `sellTokensToNft()` and `sellTokensToWallet()`, both of which specify the `_fromReserve` parameter to be `true`. This parameter is therefore unneeded.  ## Recommended Mitigation Steps  ```jsx function _submitOutOrders(   uint256 _nftId,   IERC20 _outputToken,   uint256[] memory _inputTokenAmounts,   Order[] calldata _orders,   bool _reserved ) private returns (uint256 feesAmount, uint256 amountBought) {  ...    IERC20 _inputToken = _transferInputTokens(     _nftId,     IERC20(_orders[i].token),     _inputTokenAmounts[i],     true  ); } ```  "}, {"title": "NestedRecords: createRecord() can have modifier check removed", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/126", "labels": ["bug", "duplicate", "G (Gas Optimization)"], "target": "2021-11-nested-findings", "body": "NestedRecords: createRecord() can have modifier check removed"}, {"title": "NestedRecords: createRecord()'s isActive check is redundant", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/125", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-nested-findings", "body": "NestedRecords: createRecord()'s isActive check is redundant"}, {"title": "NestedRecords: createRecord() can be made internal", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/124", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  GreyArt   # Vulnerability details  ## Impact  `createRecord()` is only invoked by `store()`. Its visibility can therefore be made internal / private.  ## Recommended Mitigation Steps  ```jsx function createRecord(   uint256 _nftId,   address _token,   uint256 _amount,  address _reserve ) internal onlyFactory {...} ```  "}, {"title": "NestedReserve: Redundant valid token address checks", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/123", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  GreyArt   # Vulnerability details  ## Impact  The `transferFromFactory()` function is missing the `valid(address(_token))` modifier that is present in the `transfer()` and `withdraw()` functions.  It is in our opinion that these sanity checks on the token address are redundant, because the transaction will revert anyway in the SafeERC20 library.  ## Recommended Mitigation Steps  Either add in the modifier check for the `transferFromFactory()` function. Alternatively, remove them from all the functions as a gas optimization.  "}, {"title": "MixinOperatorResolver: variables are declared multiple times in rebuildCache()", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/122", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  GreyArt   # Vulnerability details  ## Impact  The `name` and `destination` local variables in the `rebuildCache` function are declared multiple times within the loop. It'll be cheaper to declare them once outside the loop and reuse the variables inside.   ## Recommended Mitigation Steps  ```jsx bytes32 name; address destination; // The resolver must call this function whenever it updates its state for (uint256 i = 0; i < requiredAddresses.length; i++) {  name = requiredAddresses[i];  // Note: can only be invoked once the resolver has all the targets needed added  destination = resolver.getAddress(name);   ... } ```  "}, {"title": "NestedRecords: Unnecessary variable in the Holding struct", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/121", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  GreyArt   # Vulnerability details  ## Impact  It is unnecessary to store the `token` variable in the `Holding` struct because the token is used as the key to access the `Holding` struct.  ## Recommended Mitigation Steps  Remove the `token` variable in the `Holding` struct.  ```jsx /// @dev Info about assets stored in reserves struct Holding {   uint256 amount;   bool isActive; } ```  "}, {"title": "OperatorResolver: importOperators() function redeclares local variable multiple times", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/119", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  GreyArt   # Vulnerability details  ## Impact  The `importOperators()` declares the `name` and `destination` variables multiple times. It'll be cheaper to declare them once outside the loop and reuse the variables inside.   ## Recommended Mitigation Steps  ```jsx bytes32 name; address destination;  for (uint256 i = 0; i < names.length; i++) {  name = names[i];  destination = destinations[i];   operators[name] = destination;   emit OperatorImported(name, destination); } ```  "}, {"title": "Add index param to remove in function argument to reduce gas.", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/115", "labels": ["bug", "duplicate", "G (Gas Optimization)"], "target": "2021-11-nested-findings", "body": "Add index param to remove in function argument to reduce gas."}, {"title": "No used library added", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/114", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  xYrYuYx   # Vulnerability details  ## Impact https://github.com/code-423n4/2021-11-nested/blob/main/contracts/NestedBuybacker.sol#L15  There is only NST.safeTransfer used, and NST is INestedToken interface. SafeERC20 is not used for IERC20 interface.  ## Tools Used  ## Recommended Mitigation Steps Remove Line 79  "}, {"title": "Add zero-address checkers", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/108", "labels": ["bug", "1 (Low Risk)"], "target": "2021-11-nested-findings", "body": "Add zero-address checkers"}, {"title": "Use `calldata` keyword instead of `memory` keyword in function arguments", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/107", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  xYrYuYx   # Vulnerability details  ## Impact `calldata` use less gas than `memory` in function arguments  https://github.com/code-423n4/2021-11-nested/blob/main/contracts/FeeSplitter.sol#L124  ## Tools Used Manual  ## Recommended Mitigation Steps Use `calldata` keyword in function argument instead of `memory`  "}, {"title": "Unused Named Return", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/105", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  ye0lde   # Vulnerability details  ## Impact  Removing unused named return variables can reduce gas usage and improve code clarity.  ## Proof of Concept  Unused named return: https://github.com/code-423n4/2021-11-nested/blob/f646002b692ca5fa3631acfff87dda897541cf41/contracts/NestedFactory.sol#L69  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps Remove the unused named return  "}, {"title": "Missing input validation on array lengths ", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/103", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  ye0lde   # Vulnerability details  ## Impact  The functions below fail to perform input validation on arrays to verify the lengths match.  A mismatch could lead to an exception or undefined behavior.  ## Proof of Concept  names, destinations https://github.com/code-423n4/2021-11-nested/blob/f646002b692ca5fa3631acfff87dda897541cf41/contracts/OperatorResolver.sol#L27-L39  _inputTokenAmounts, orders https://github.com/code-423n4/2021-11-nested/blob/f646002b692ca5fa3631acfff87dda897541cf41/contracts/NestedFactory.sol#L321-L337  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps  Add input validation to check that the length of both arrays match.  "}, {"title": "Use existing memory version of state variables", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/102", "labels": ["bug", "G (Gas Optimization)", "sponsor disputed"], "target": "2021-11-nested-findings", "body": "Use existing memory version of state variables"}, {"title": "transferOwnership should be two step process", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/101", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-11-nested-findings", "body": "transferOwnership should be two step process"}, {"title": "double reading of state variable inside a loop", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/98", "labels": ["bug", "question", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  pants   # Vulnerability details  MixinOperatorResolver.rebuildCache (addressCache[name]), isResolverCached (addressCache[name])  You can cache the value after the first read into a local variable to save the other SLOAD and also the \"out of bounds\" check.  "}, {"title": "reordering struct fields", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/96", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  pants   # Vulnerability details  NestedRecords line 22 - you can save storage by reordering Holding struct fields in the following way:  original:     struct Holding {         address token;         uint256 amount;         bool isActive;     }  change to:      struct Holding {         uint256 amount;         address token;         bool isActive;     }   "}, {"title": "DummyRouter.sol .transfer isn't safe", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/92", "labels": ["bug", "1 (Low Risk)", "sponsor disputed"], "target": "2021-11-nested-findings", "body": "DummyRouter.sol .transfer isn't safe"}, {"title": "WETHMock withdraw function unnecessary safe math", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/90", "labels": ["bug", "G (Gas Optimization)", "sponsor disputed"], "target": "2021-11-nested-findings", "body": "WETHMock withdraw function unnecessary safe math"}, {"title": "Missing events on changes", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/84", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  palina   # Vulnerability details  ## Impact Function performing important changes to contract state should emit events to facilitate monitoring of the protocol operation (e.g., NestedRecords::setReserve(), deleteAsset(), removeNFT()).  ## Proof of Concept setReserve(): https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/NestedRecords.sol#L201 deleteAsset(): https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/NestedRecords.sol#L207 removeNFT(): https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/NestedRecords.sol#L221  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Consider emitting events on the discussed changes. E.g.,  event ReserveUpdated(address newReserve); ... function setReserve(...) {     emit ReserveUpdated(_nextReserve); }  "}, {"title": "setReserve() can be front-run", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/82", "labels": ["bug", "duplicate", "2 (Med Risk)"], "target": "2021-11-nested-findings", "body": "setReserve() can be front-run"}, {"title": "Gas-consuming way to add shareholders", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/81", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-11-nested-findings", "body": "Gas-consuming way to add shareholders"}, {"title": "`NestedFactory.unlockTokens` fails to use safe transfer", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/78", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  elprofesor   # Vulnerability details  ## Impact The use of `_token.transfer()` in `NestedFactory.unlockTokens` may have unintended consequences. ERC20 tokens can implement contra to the EIP20 spec (USDT for instance returns VOID). This may result in tokens that return anything from false to void and these return values would not throw on failure. As a result transfer's in `unlockTokens` may not appropriately throw on failure.  ## Proof of Concept https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/NestedFactory.sol#L271-L273  ## Recommended Mitigation Steps We recommend using OpenZeppelin\u2019s SafeERC20 versions with the `safeTransfer` function that handles the return value check as well as non-standard-compliant tokens.  "}, {"title": "Unchecked return value in triggerForToken()", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/76", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  palina   # Vulnerability details  ## Impact The Nestedbuybacker::triggerForToken() function does not check the return value of the `ExchangeHelpers.fillQuote(_sellToken, _swapTarget, _swapCallData);` call, which returns a boolean. Even if the swap in the fillQuote() is not successful and no NST was bought, the function proceeds with the trigger() function execution. trigger() also does not check if the `balance` variable (indicating the amount of NST bought) is positive, although there is (at best) no point in executing the rest of the function if there's no NST in the contract.  ## Proof of Concept Unchecked result of the fillQuote() call: https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/NestedBuybacker.sol#L101 Missing validation in trigger(): https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/NestedBuybacker.sol#L108  ## Tools Used Manual analysis  ## Recommended Mitigation Steps Add a return value check in the triggerForToken() function: `bool success = ExchangeHelpers.fillQuote(_sellToken, _swapTarget, _swapCallData); require(success);` and/or a `balance` value validation in trigger(): `uint256 balance = NST.balanceOf(address(this)); require(balance > 0);`  "}, {"title": "Public functions can be declared external", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/72", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  palina   # Vulnerability details  ## Impact Functions that are only called from outside the contract can be declared external instead of public since they are more gas-efficient.  ## Proof of Concept NestedBuybacker::setBurnPart(): https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/NestedBuybacker.sol#L81, MixinOperatorResolver::rebuildCache(): https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/MixinOperatorResolver.sol#L29  ## Tools Used Manual analysis  ## Recommended Mitigation Steps Change the 'public' visibility modifier into 'external'.  "}, {"title": "Refactor `FeeSplitter::getAmountDue` to save one variable slot", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/68", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  pmerkleplant   # Vulnerability details  ## Impact Function `getAmountDue` in `FeeSplitter.sol` defines the variable  `totalReceived` in [line 83](https://github.com/code-423n4/2021-11-nested/blob/main/contracts/FeeSplitter.sol#L83) eventhough it is already known if the variable is even necessary.  The variable is uneccessary if `_tokenRecords.totalShares == 0`. Not declaring it, if not necessary, saves gas.  ## Recommended Mitigation Steps Rewrite the function to something like: ``` TokenRecords storage _tokenRecords = tokenRecords[address(_token)]; if (_tokenRecords.totalShares == 0) return 0; uint256 totalReceived = _tokenRecords.totalReleased + _token.balanceOf(address(this)); // Rest same as before ```  "}, {"title": "Remove unnecessary `balanceOf` call in `NestedBuybacker::triggerForToken`", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/65", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  pmerkleplant   # Vulnerability details  Function `triggerForToken` in `NestedBuybacker.sol` makes a `balanceOf` call on the `_sellToken`, see [line 100](https://github.com/code-423n4/2021-11-nested/blob/main/contracts/NestedBuybacker.sol#L100).  However, the result of the call is never used.  It would save gas to remove the unnecessary call and variable declaration.  "}, {"title": "`removeFactory` has `==true` comparison in require statement", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/63", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  loop   # Vulnerability details  The `removeFactory` has an unnecessary `==true` comparison in its require statement. Since require already checks if the condition is `true`, there is no need for it to be compared.  ## Impact Removing `== true` saves a tiny amount of gas if `removeFactory` is called.  ## Proof of Concept https://github.com/code-423n4/2021-11-nested/blob/main/contracts/NestedAsset.sol#L142  "}, {"title": "_sendFees() Repeat SLOAD shareholders In Loop", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/57", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  Meta0xNull   # Vulnerability details  ## Impact _sendFees() repeat Read Storage variable shareholders. Every Storage read is expensive.   ## Proof of Concept https://github.com/code-423n4/2021-11-nested/blob/main/contracts/FeeSplitter.sol#L227-L232  ## Tools Used Manual Review  ## Recommended Mitigation Steps Read the values from storage once, cache them in local variables and then read them again using the local variables. For example:  Shareholder[] shareholders_temp = shareholders;         for (uint256 i = 0; i < shareholders_temp.length; i++) {             _addShares(                 shareholders_temp[i].account,                 _computeShareCount(_amount, shareholders_temp[i].weight, _totalWeights),                 address(_token)             );  "}, {"title": "function mintWithMetadata() Unused", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/55", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-11-nested-findings", "body": "function mintWithMetadata() Unused"}, {"title": "Wrong Error Message in _transferInputTokens()", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/53", "labels": ["bug", "0 (Non-critical)"], "target": "2021-11-nested-findings", "body": "Wrong Error Message in _transferInputTokens()"}, {"title": "ExchangeHelpers: in setMaxAllowance, safeApprove shouldn't be used", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/50", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  PierrickGT   # Vulnerability details  ## Impact In [setMaxAllowance](https://github.com/code-423n4/2021-11-nested/blob/cbd39fe7d76ed8c84eb767a5f3b6eba83e034656/contracts/libraries/ExchangeHelpers.sol#L34), `safeApprove` is used to increase allowance. As stated in the following Pull Request, `safeApprove` has been deprecated in favor of `safeIncreaseAllowance` and `safeDecreaseAllowance`.  https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2268/files  This is because `safeApprove` shouldn't check for allowance, as explained in the issue below:  https://github.com/OpenZeppelin/openzeppelin-contracts/issues/2219  `approve` is actually vulnerable to a sandwich attack as explained in the following document and this check for allowance doesn't actually avoid it.  https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/edit  ## Proof of Concept `safeIncreaseAllowance` should be used to increase allowance and `safeDecreaseAllowance` to decrease allowance to 0. We can also gain in code clarity by refactoring the `if else` statement and calling `_token.safeIncreaseAllowance(_spender, type(uint256).max);` only once.  ## Recommended Mitigation Steps The following changes are recommended.  ``` function setMaxAllowance(IERC20 _token, address _spender) internal {     uint256 _currentAllowance = _token.allowance(address(this), _spender);      if (_currentAllowance != type(uint256).max) {         // Decrease to 0 first for tokens mitigating the race condition         _token.safeDecreaseAllowance(_spender, _currentAllowance);     }      _token.safeIncreaseAllowance(_spender, type(uint256).max); } ```  "}, {"title": "NestedFactory: in deleteAsset and freeToken, tokens should only be declared once ", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/49", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  PierrickGT   # Vulnerability details  ## Impact In [deleteAsset](https://github.com/code-423n4/2021-11-nested/blob/cbd39fe7d76ed8c84eb767a5f3b6eba83e034656/contracts/NestedRecords.sol#L213), `tokens` is declared once in the function and then a second time in the function `freeToken`.  ## Proof of Concept The `freeToken` function being used only in `deleteAsset`, the code from this function can be moved to `deleteAsset` and the function removed. This way, we don't have to pass `tokens` to the `freeToken` function and we avoid declaring it here a second time.  ## Recommended Mitigation Steps The following change is recommended.  ``` function deleteAsset(uint256 _nftId, uint256 _tokenIndex) public onlyFactory {     address[] storage tokens = records[_nftId].tokens;     address token = tokens[_tokenIndex];     Holding memory holding = records[_nftId].holdings[token];      require(holding.isActive, \"NestedRecords: HOLDING_INACTIVE\");      delete records[_nftId].holdings[token];     tokens[_tokenIndex] = tokens[tokens.length - 1];     tokens.pop(); } ```  "}, {"title": "OperatorHelpers.sol: function decodeDataAndRequire state mutability can be restricted to pure", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/48", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  GiveMeTestEther   # Vulnerability details  ## Impact OperatorHelpers.sol: function decodeDataAndRequire state mutability can be restricted to pure We don't read any storage variables, only use the arguments therefore, it can be restricted to pure.  ## Proof of Concept https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/libraries/OperatorHelpers.sol#L45  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps set function state mutability to pure  "}, {"title": "Remove empty file OwnableOperator.so", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/47", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  GiveMeTestEther   # Vulnerability details  ## Impact Empty/useless file OwnableOperator.sol is against best practices / code housekeeping.  ## Proof of Concept https://github.com/code-423n4/2021-11-nested/blob/main/contracts/operators/OwnableOperator.sol  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Delete file  "}, {"title": "Subtraction from totalWeights can be done unchecked to save gas", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/46", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  GiveMeTestEther   # Vulnerability details   ## Impact FeeSplitter.so: totalWeights is the sum of shareholder weights and royaltiesWeight, therefore a subtraction of a shareholder weight or royaltiesWeight can be done unchecked because we can't underflow and save gas.   ## Proof of Concept https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/FeeSplitter.sol#L143  https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/FeeSplitter.sol#L169  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps  https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/FeeSplitter.sol#L143 can be rewritten as:      function sendFees(IERC20 _token, uint256 _amount) external nonReentrant {         _sendFees(_token, _amount, unchecked {totalWeights - royaltiesWeight});     }  https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/FeeSplitter.sol#L169 can be written as unchecked { _totalWeights -= shareholders[_accountIndex].weight; }  "}, {"title": "Different coding style for same pattern: x += y and sometimes x = x + y", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/45", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  GiveMeTestEther   # Vulnerability details  ## Impact  The pattern of adding/subtracting a variable to/from another value is sometimes written as x += y; and sometimes as x = x + y; (x -= y; and sometimes x = x - y;) The shorter version x += y;/x -= y; increases readability.  ## Proof of Concept  https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/FeeSplitter.sol#L241  https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/FeeSplitter.sol#L256  https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/NestedFactory.sol#L229  and possible others  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps use the x += y; / x -= y; pattern   "}, {"title": "Comment for PaymentReceived event should state \"received\" instead of \"released\"", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/44", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  GiveMeTestEther   # Vulnerability details  ## Impact Comment in FeeSplitter  \"/// @dev Emitted when a payment is released\" for the PaymentReceived event should say \"received\" instead of \"released\".  ## Proof of Concept https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/FeeSplitter.sol#L25  ## Tools Used Manal Analysis  ## Recommended Mitigation Steps Change line to: /// @dev Emitted when a payment is received  "}, {"title": "FeeSplitter: totalWeights can be set to 0 by onlyOwner", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/43", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  GiveMeTestEther   # Vulnerability details  ## Impact The storage variable totalWeights can be set 0 by onlyOwner and therefore we would have a division by zero in the function \"_computeShareCount\" https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/FeeSplitter.sol#L268  ## Proof of Concept -Assumption we have one shareholder with weight S1 > 0 and royaltiesWeight > 0. -With the function updateShareholder the onlyOwner sets the S1 of our shareholder to 0.  - updateShareholder: https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/FeeSplitter.sol#L166  - require(_totalWeights > 0, \"FeeSplitter: TOTAL_WEIGHTS_ZERO\") condition is met because _totalWeights is the sum of all shareholder weights + royaltiesWeight, and royaltiesWeight is > 0 - With the function setRoyaltiesWeight the onlyOwner sets the royaltiesWeight to 0.  - setRoyaltiesWeight: https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/FeeSplitter.sol#L94 - => setRoyaltiesWeight is 0 and totalWeights is 0   ## Tools Used Manual Analysis  ## Recommended Mitigation Steps At the end of the function setRoyaltiesWeight check for 0 weight with a require: require(totalWeights > 0, \"FeeSplitter: TOTAL_WEIGHTS_ZERO\"); https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/FeeSplitter.sol#L94  "}, {"title": "Missing events for critical privileged functions", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/42", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  GiveMeTestEther   # Vulnerability details  ## Impact Functions that are only executable by privileged users (e.g. onlyOwner) and have an impact (e.g. financial, trust) on other users should emit events.  ## Proof of Concept https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/FeeSplitter.sol#L94 https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/FeeSplitter.sol#L103 https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/FeeSplitter.sol#L166  https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/NestedFactory.sol#L74 https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/NestedFactory.sol#L79 https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/NestedFactory.sol#L271  and possible other  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Emit events for privileged actions  "}, {"title": "Use SafeERC20 instead of IERC20 in contracts/mocks/DummyRouter.sol ", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/41", "labels": ["bug", "1 (Low Risk)", "sponsor disputed"], "target": "2021-11-nested-findings", "body": "Use SafeERC20 instead of IERC20 in contracts/mocks/DummyRouter.sol "}, {"title": "Indexing parameters of your events", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/40", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-11-nested-findings", "body": "Indexing parameters of your events"}, {"title": "claimFees may end up locking user funds", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/39", "labels": ["bug", "1 (Low Risk)", "disagree with severity"], "target": "2021-11-nested-findings", "body": "claimFees may end up locking user funds"}, {"title": "Adding an if check to avoid unnecessary call", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/38", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-11-nested-findings", "body": "Adding an if check to avoid unnecessary call"}, {"title": "Typo", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/37", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  0xngndev   # Vulnerability details  ## Impact Found the same small typo at NestedBuybacker.sol#constructor::line 54 and at NestedBuybacker.sol#constructor::line 87.  The error messages says: \"NestedBuybacker::constructor: Burn part to high\" It should be \"too high\".  "}, {"title": "Store hash of `type(ZeroExStorage).creationCode` rather than recalculating it on each call", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/35", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  TomFrench   # Vulnerability details  ## Impact  Deployment + runtime gas cost increase  ## Proof of Concept  On each time we calculate the address of `ZeroExStorage` we hash the entirety of the creation code for `ZeroExStorage`. This means that not only do we have to perform a large hash operation over the entire creation bytecode of this contract, we need to store all of this bytecode in the `ZeroExOperator`'s deployed bytecode.  https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/operators/ZeroEx/ZeroExOperator.sol#L61  This hash could be calculated once at deployment and then have this used cheaply each time, reducing both deployment and runtime costs.  ## Recommended Mitigation Steps  Store `keccak256(type(ZeroExStorage).creationCode)` in an `immutable` (not `constant` as this still results in hashing being applied each time) variable.  "}, {"title": "Move from a pull to a push pattern for sending fees to the FeeSplitter", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/34", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-11-nested-findings", "body": "Move from a pull to a push pattern for sending fees to the FeeSplitter"}, {"title": "NestedBuybacker sends NST to NestedReserve with no proper way to retrieve it.", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/33", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-11-nested-findings", "body": "NestedBuybacker sends NST to NestedReserve with no proper way to retrieve it."}, {"title": "1:1 linkage between factory and reserve prevents desired upgradability path.", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/32", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  TomFrench   # Vulnerability details  ## Impact  NFTs can't be managed from future versions of `NestedFactory` without manual migration or removing support for the previous `NestedFactory`.  ## Proof of Concept  From discussion with NestedFinance team members, it's desired that multiple `NestedFactories` can interact with the NFT portfolios and be interoperable into the future.  NestedFinance has two singleton contracts which store the state of NFTs `NestedAsset` and `NestedRecords`  `NestedAsset` allows multiple factories to interact with a given NFT ([asset](https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/NestedAsset.sol#L18-L19)) `NestedRecords` lists a single reserve which holds an NFT's assets ([records](https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/NestedRecords.sol#L32))  This is fine however `NestedFactory` and `NestedReserve` are linked together 1:1 ([factory](https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/NestedFactory.sol#L31), [reserve](https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/NestedReserve.sol#L14))  This means that each NFT can only be managed by a single factory as calls from other factories to the relevant reserve will revert due to insufficient permissions. Should I want to update to use the newest factory I would have to manually migrate my portfolio across.  ## Recommended Mitigation Steps  Allow `NestedReserve` to have multiple factories connect to it. Make sure to have the `NestedReserve` secure from reentrancy attacks utilising multiple factories in parallel.   "}, {"title": "Copy your own portfolio to keep earning royalties ", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/30", "labels": ["bug", "3 (High Risk)", "disagree with severity"], "target": "2021-11-nested-findings", "body": "Copy your own portfolio to keep earning royalties "}, {"title": "Mix of external and public function visibility with the same access modifier", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/29", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  GiveMeTestEther   # Vulnerability details  ## Impact  Functions in the same contract with the same access modifier (e.g. onlyOwner or onlyFactory) have have a mix of public and external visibility.  Set their visibility to external to save gas.  Affected contracts (see ): - NestedRecords - NestedFactory - FeeSplitter - NestedAsset   ## Tools Used Visial Studio Code + Solidity Visual Developer (Plugin)  ## Recommended Mitigation Steps  Set the visibility to external to save gas.   Extract from Solidity Visual Developer (Plugin) of the Contracts and visibility:  |  Contract  |         Type        |       Bases      |                  |                 | |:----------:|:-------------------:|:----------------:|:----------------:|:---------------:| |     \u2514      |  **Function Name**  |  **Visibility**  |  **Mutability**  |  **Modifiers**  | |||||| | **NestedRecords** | Implementation | Ownable ||| | \u2514 | <Constructor> | Public \u2757\ufe0f | \ud83d\uded1  |NO\u2757\ufe0f | | \u2514 | createRecord | Public \u2757\ufe0f | \ud83d\uded1  | onlyFactory | | \u2514 | updateHoldingAmount | Public \u2757\ufe0f | \ud83d\uded1  | onlyFactory | | \u2514 | getAssetTokens | Public \u2757\ufe0f |   |NO\u2757\ufe0f | | \u2514 | freeHolding | Public \u2757\ufe0f | \ud83d\uded1  | onlyFactory | | \u2514 | store | External \u2757\ufe0f | \ud83d\uded1  | onlyFactory | | \u2514 | getAssetHolding | External \u2757\ufe0f |   |NO\u2757\ufe0f | | \u2514 | setFactory | External \u2757\ufe0f | \ud83d\uded1  | onlyOwner | | \u2514 | updateLockTimestamp | External \u2757\ufe0f | \ud83d\uded1  | onlyFactory | | \u2514 | setMaxHoldingsCount | External \u2757\ufe0f | \ud83d\uded1  | onlyOwner | | \u2514 | getAssetReserve | External \u2757\ufe0f |   |NO\u2757\ufe0f | | \u2514 | getAssetTokensLength | External \u2757\ufe0f |   |NO\u2757\ufe0f | | \u2514 | getLockTimestamp | External \u2757\ufe0f |   |NO\u2757\ufe0f | | \u2514 | setReserve | External \u2757\ufe0f | \ud83d\uded1  | onlyFactory | | \u2514 | removeNFT | External \u2757\ufe0f | \ud83d\uded1  | onlyFactory | | \u2514 | deleteAsset | Public \u2757\ufe0f | \ud83d\uded1  | onlyFactory | | \u2514 | freeToken | Private \ud83d\udd10 | \ud83d\uded1  | | |||||| | **NestedFactory** | Implementation | INestedFactory, ReentrancyGuard, Ownable, MixinOperatorResolver, Multicall ||| | \u2514 | <Constructor> | Public \u2757\ufe0f | \ud83d\uded1  | MixinOperatorResolver | | \u2514 | <Receive Ether> | External \u2757\ufe0f |  \ud83d\udcb5 |NO\u2757\ufe0f | | \u2514 | resolverAddressesRequired | Public \u2757\ufe0f |   |NO\u2757\ufe0f | | \u2514 | addOperator | External \u2757\ufe0f | \ud83d\uded1  | onlyOwner | | \u2514 | removeOperator | External \u2757\ufe0f | \ud83d\uded1  | onlyOwner | | \u2514 | setReserve | External \u2757\ufe0f | \ud83d\uded1  | onlyOwner | | \u2514 | setFeeSplitter | External \u2757\ufe0f | \ud83d\uded1  | onlyOwner | | \u2514 | create | External \u2757\ufe0f |  \ud83d\udcb5 | nonReentrant | | \u2514 | addTokens | External \u2757\ufe0f |  \ud83d\udcb5 | nonReentrant onlyTokenOwner | | \u2514 | swapTokenForTokens | External \u2757\ufe0f | \ud83d\uded1  | nonReentrant onlyTokenOwner isUnlocked | | \u2514 | sellTokensToNft | External \u2757\ufe0f | \ud83d\uded1  | nonReentrant onlyTokenOwner isUnlocked | | \u2514 | sellTokensToWallet | External \u2757\ufe0f | \ud83d\uded1  | nonReentrant onlyTokenOwner isUnlocked | | \u2514 | destroy | External \u2757\ufe0f | \ud83d\uded1  | nonReentrant onlyTokenOwner isUnlocked | | \u2514 | withdraw | External \u2757\ufe0f | \ud83d\uded1  | nonReentrant onlyTokenOwner isUnlocked | | \u2514 | increaseLockTimestamp | External \u2757\ufe0f | \ud83d\uded1  | onlyTokenOwner | | \u2514 | unlockTokens | External \u2757\ufe0f | \ud83d\uded1  | onlyOwner | | \u2514 | _submitInOrders | Private \ud83d\udd10 | \ud83d\uded1  | | | \u2514 | _submitOutOrders | Private \ud83d\udd10 | \ud83d\uded1  | | | \u2514 | _submitOrder | Private \ud83d\udd10 | \ud83d\uded1  | | | \u2514 | _safeSubmitOrder | Private \ud83d\udd10 | \ud83d\uded1  | | | \u2514 | _transferToReserveAndStore | Private \ud83d\udd10 | \ud83d\uded1  | | | \u2514 | _transferInputTokens | Private \ud83d\udd10 | \ud83d\uded1  | | | \u2514 | _handleUnderSpending | Private \ud83d\udd10 | \ud83d\uded1  | | | \u2514 | _transferFeeWithRoyalty | Private \ud83d\udd10 | \ud83d\uded1  | | | \u2514 | _decreaseHoldingAmount | Private \ud83d\udd10 | \ud83d\uded1  | | | \u2514 | _safeTransferAndUnwrap | Private \ud83d\udd10 | \ud83d\uded1  | | | \u2514 | _safeTransferWithFees | Private \ud83d\udd10 | \ud83d\uded1  | | | \u2514 | _calculateFees | Private \ud83d\udd10 |   | | |||||| | **FeeSplitter** | Implementation | Ownable, ReentrancyGuard ||| | \u2514 | <Constructor> | Public \u2757\ufe0f | \ud83d\uded1  |NO\u2757\ufe0f | | \u2514 | <Receive Ether> | External \u2757\ufe0f |  \ud83d\udcb5 |NO\u2757\ufe0f | | \u2514 | getAmountDue | Public \u2757\ufe0f |   |NO\u2757\ufe0f | | \u2514 | setRoyaltiesWeight | Public \u2757\ufe0f | \ud83d\uded1  | onlyOwner | | \u2514 | setShareholders | Public \u2757\ufe0f | \ud83d\uded1  | onlyOwner | | \u2514 | releaseToken | Public \u2757\ufe0f | \ud83d\uded1  | nonReentrant | | \u2514 | releaseTokens | External \u2757\ufe0f | \ud83d\uded1  |NO\u2757\ufe0f | | \u2514 | releaseETH | External \u2757\ufe0f | \ud83d\uded1  | nonReentrant | | \u2514 | sendFees | External \u2757\ufe0f | \ud83d\uded1  | nonReentrant | | \u2514 | sendFeesWithRoyalties | External \u2757\ufe0f | \ud83d\uded1  | nonReentrant | | \u2514 | updateShareholder | External \u2757\ufe0f | \ud83d\uded1  | onlyOwner | | \u2514 | totalShares | External \u2757\ufe0f |   |NO\u2757\ufe0f | | \u2514 | totalReleased | External \u2757\ufe0f |   |NO\u2757\ufe0f | | \u2514 | shares | External \u2757\ufe0f |   |NO\u2757\ufe0f | | \u2514 | released | External \u2757\ufe0f |   |NO\u2757\ufe0f | | \u2514 | findShareholder | External \u2757\ufe0f |   |NO\u2757\ufe0f | | \u2514 | _sendFees | Private \ud83d\udd10 | \ud83d\uded1  | | | \u2514 | _addShares | Private \ud83d\udd10 | \ud83d\uded1  | | | \u2514 | _releaseToken | Private \ud83d\udd10 | \ud83d\uded1  | | | \u2514 | _addShareholder | Private \ud83d\udd10 | \ud83d\uded1  | | | \u2514 | _computeShareCount | Private \ud83d\udd10 |   | | |||||| | **NestedAsset** | Implementation | ERC721Enumerable, Ownable ||| | \u2514 | <Constructor> | Public \u2757\ufe0f | \ud83d\uded1  | ERC721 | | \u2514 | tokenURI | Public \u2757\ufe0f |   |NO\u2757\ufe0f | | \u2514 | originalOwner | Public \u2757\ufe0f |   |NO\u2757\ufe0f | | \u2514 | mint | Public \u2757\ufe0f | \ud83d\uded1  | onlyFactory | | \u2514 | mintWithMetadata | External \u2757\ufe0f | \ud83d\uded1  | onlyFactory | | \u2514 | backfillTokenURI | External \u2757\ufe0f | \ud83d\uded1  | onlyFactory onlyTokenOwner | | \u2514 | burn | External \u2757\ufe0f | \ud83d\uded1  | onlyFactory onlyTokenOwner | | \u2514 | setFactory | External \u2757\ufe0f | \ud83d\uded1  | onlyOwner | | \u2514 | removeFactory | External \u2757\ufe0f | \ud83d\uded1  | onlyOwner | | \u2514 | _setTokenURI | Internal \ud83d\udd12 | \ud83d\uded1  | |   Legend  |  Symbol  |  Meaning  | |:--------:|-----------| |    \ud83d\uded1    | Function can modify state | |    \ud83d\udcb5    | Function is payable |   "}, {"title": "More gas efficient calculation of weights", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/28", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  GiveMeTestEther   # Vulnerability details  ## Impact Calculation of the weights in the function \"setRoyaltiesWeight\" of FeeSplitter.sol (row 95) can be done more gas efficient.      function setRoyaltiesWeight(uint256 _weight) public onlyOwner {         totalWeights -= royaltiesWeight;         royaltiesWeight = _weight;         totalWeights += _weight;     }  can be rewritten as      function setRoyaltiesWeight(uint256 _weight) public onlyOwner {         totalWeights = totalWeights - royaltiesWeight + _weight;         royaltiesWeight = _weight;     }  => write only once to the storage of totalWeights.  ## Proof of Concept  ## Tools Used Visual Studio Code  ## Recommended Mitigation Steps see above  "}, {"title": "`NestedReserve.transferFromFactory` function increases deployment gas costs unnecessarily", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/27", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  TomFrench   # Vulnerability details  ## Impact  `NestedReserve.transferFromFactory` is unused and so increases deployment costs for no gain  ## Proof of Concept  `NestedReserve` has a `transferFromFactory` which can be seen not to be used in the codebase (and in the case the `NestedFactory` needs to send tokens to the reserve it can do so directly.)  https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/NestedReserve.sol#L55-L60  ## Recommended Mitigation Steps  Remove this function.  "}, {"title": "FlatOperator can be inlined into NestedFactory to save gas", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/26", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-11-nested-findings", "body": "FlatOperator can be inlined into NestedFactory to save gas"}, {"title": "unchecked { ++i }  is more gas efficient than i++ for loops", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/25", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-11-nested-findings", "body": "unchecked { ++i }  is more gas efficient than i++ for loops"}, {"title": "Multiple Solidity pragma", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/22", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-11-nested-findings", "body": "Multiple Solidity pragma"}, {"title": "Reduce require messages length to save contract size", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/14", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  0xngndev   # Vulnerability details  ## Impact Running a quick contract size check in the NestedFactory contract, I noticed it sat at 27590 bytes, exceeding the allowed 24576 bytes to deploy on mainnet. I removed the require messages alone in that contract and found the contract size dropped to 23172 bytes. Considering you are using large require messages in all the codebase, I would suggest considering a change of approach as to how you expose the error messages. I'll add my suggestions below.  ## Recommended Mitigation Steps Two ways: 1) Shorten the length of the string messages to just the error instead of including the contract and the function. UniswapV3 repo may be a good example of how to do this. You can always explain errors further in the natspec, or in your documentation (you can make a common errors section). 2) Change require statements for if (...) revert CustomError(). Per solidity docs:  \"Using a custom error instance will usually be much cheaper than a string description, because you can use the name of the error to describe it, which is encoded in only four bytes. A longer description can be supplied via NatSpec which does not incur any costs.\"  Link: https://docs.soliditylang.org/en/v0.8.10/control-structures.html?highlight=error#revert  ## Tools Used dapptools make size  "}, {"title": "`updateShareholder` in `FeeSplitter.sol` can be implemented more efficiently", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/11", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  0x0x0x   # Vulnerability details  ## Explanation  `updateShareholder` in `FeeSplitter.sol` can be implemented more efficiently. The updated version consumes less gas and also has the second `require` statement earlier, which reduces  the gas cost in case the statement of second `require` is not fullfilled.   `FeeSplitter.sol` : L166-174: ```     function updateShareholder(uint256 _accountIndex, uint256 _weight) external onlyOwner {         require(_accountIndex + 1 <= shareholders.length, \"FeeSplitter: INVALID_ACCOUNT_INDEX\");         uint256 _totalWeights = totalWeights;         _totalWeights -= shareholders[_accountIndex].weight;         shareholders[_accountIndex].weight = _weight;         _totalWeights += _weight;         require(_totalWeights > 0, \"FeeSplitter: TOTAL_WEIGHTS_ZERO\");         totalWeights = _totalWeights;     } ``` can be replaced with: ```     function updateShareholder(uint256 _accountIndex, uint256 _weight) external onlyOwner {         require(_accountIndex + 1 <= shareholders.length, \"FeeSplitter: INVALID_ACCOUNT_INDEX\");         totalWeights = totalWeights + _weight - shareholders[_accountIndex].weight;         require(_totalWeights > 0, \"FeeSplitter: TOTAL_WEIGHTS_ZERO\");         shareholders[_accountIndex].weight = _weight;     } ``` ## Tools Used  Manual analysis  "}, {"title": "For `uint` replace `> 0` with `!= 0`", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/8", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  0x0x0x   # Vulnerability details  ## Proof of Concept For unsigned integers, it is cheaper to check ` != 0` than ` > 0`. Both provide the same logic. ## Occurences ``` contracts/FeeSplitter.sol:105:        require(_accounts.length > 0 && _accounts.length == _weights.length, \"FeeSplitter: ARRAY_LENGTHS_ERR\"); contracts/FeeSplitter.sol:172:        require(_totalWeights > 0, \"FeeSplitter: TOTAL_WEIGHTS_ZERO\"); contracts/FeeSplitter.sol:263:        require(_weight > 0, \"FeeSplitter: ZERO_WEIGHT\"); contracts/NestedBuybacker.sol:97:        if (feeSplitter.getAmountDue(address(this), _sellToken) > 0) { contracts/NestedFactory.sol:69:        require(i > 0, \"NestedFactory::removeOperator: Cant remove non-existent operator\"); contracts/NestedFactory.sol:94:        require(_orders.length > 0, \"NestedFactory::create: Missing orders\"); contracts/NestedFactory.sol:110:        require(_orders.length > 0, \"NestedFactory::addTokens: Missing orders\"); contracts/NestedFactory.sol:124:        require(_orders.length > 0, \"NestedFactory::swapTokenForTokens: Missing orders\"); contracts/NestedFactory.sol:143:        require(_orders.length > 0, \"NestedFactory::sellTokensToNft: Missing orders\"); contracts/NestedFactory.sol:163:        require(_orders.length > 0, \"NestedFactory::sellTokensToWallet: Missing orders\"); contracts/NestedFactory.sol:194:        require(_orders.length > 0, \"NestedFactory::destroy: Missing orders\"); contracts/NestedFactory.sol:333:            if (_inputTokenAmounts[i] - amountSpent > 0) { contracts/NestedFactory.sol:467:        if (_amountToSpent - _amountSpent > 0) { contracts/NestedRecords.sol:171:        require(_maxHoldingsCount > 0, \"NestedRecords: INVALID_MAX_HOLDINGS\"); contracts/operators/Flat/FlatOperator.sol:18:        require(amount > 0, \"FlatOperator::commitAndRevert: Amount must be greater than zero\"); contracts/operators/ZeroEx/ZeroExOperator.sol:42:        assert(amountBought > 0); contracts/operators/ZeroEx/ZeroExOperator.sol:43:        assert(amountSold > 0); ```  "}, {"title": "Save gas by caching array length used in for loops", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/7", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "Save gas by caching array length used in for loops"}, {"title": "NestedFactory: _transferToReserveAndStore can be simplified to save on gas", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/5", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  PierrickGT   # Vulnerability details  ## Impact In [_transferToReserveAndStore](https://github.com/code-423n4/2021-11-nested/blob/cbd39fe7d76ed8c84eb767a5f3b6eba83e034656/contracts/NestedFactory.sol#L426), `_token` is casted 3 times to `IERC20` and `reserve` is loaded and casted to `address` 4 times. We can simplify the function and save on gas.  ## Proof of Concept `_token` should be passed to the function as an `IERC20`, this way we avoid to cast it 3 times. `reserve` should be stored in a variable to avoid 3 unnecessary sloads and casting.  ## Recommended Mitigation Steps The following changes are recommended.  ```     function _transferToReserveAndStore(         IERC20 _token,         uint256 _amount,         uint256 _nftId     ) private {         address reserveAddress = address(reserve);         uint256 balanceReserveBefore = _token.balanceOf(reserveAddress);          // Send output to reserve         _token.safeTransfer(reserveAddress, _amount);          uint256 balanceReserveAfter = _token.balanceOf(reserveAddress);          nestedRecords.store(_nftId, address(_token), balanceReserveAfter - balanceReserveBefore, reserveAddress);     } ```  After this subsequent change, `_outputToken` will need to be casted to `IERC20` on [L386](https://github.com/code-423n4/2021-11-nested/blob/cbd39fe7d76ed8c84eb767a5f3b6eba83e034656/contracts/NestedFactory.sol#L386).  `_transferToReserveAndStore(IERC20(_outputToken), amounts[0], _nftId);`  And no need to cast `_outputToken` anymore on [L357](https://github.com/code-423n4/2021-11-nested/blob/cbd39fe7d76ed8c84eb767a5f3b6eba83e034656/contracts/NestedFactory.sol#L357).  `_transferToReserveAndStore(_outputToken, amountBought - feesAmount, _nftId);`  "}, {"title": "Weak guarantees on ZeroExOperator using correct create2 salt to recompute storage address", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/4", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  TomFrench   # Vulnerability details  ## Impact  Potential for a broken deploy of operators which use a storage contract (not in the case of `ZeroExOperator` however)  ## Proof of Concept  `ZeroExOperator` uses a create2 salt of `bytes32(\"nested.zeroex.operator\")` to deploy its storage contract and this salt must be used to recompute this address in future.  It's then important to enforce that both steps use the same salt, however this is not strictly enforced. Currently a change to one must be manually updated in the other, if this was not done then calculation of the storage address would be incorrect.  https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/operators/ZeroEx/ZeroExOperator.sol#L15  https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/operators/ZeroEx/ZeroExOperator.sol#L60  This is not an issue in the current case but this is a potential footgun for future operators which use storage.  ## Recommended Mitigation Steps  Place `bytes32(\"nested.zeroex.operator\")` into a constant variable and use this variable instead.  "}, {"title": "ZeroExOperator", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/3", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  TomFrench   # Vulnerability details  ## Impact  Reduced ease of verifying correctness  ## Proof of Concept  `ZeroExOperator` uses the `Create2` library to deploy `ZeroExOperatorStorage`. `Create2` also exposes a `computeAddress` function which can be used to recalculate the address of `ZeroExOperatorStorage` but `ZeroExOperator` instead uses a homebrew calculation in `storageAddress`.  https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/operators/ZeroEx/ZeroExOperator.sol#L55-L65  https://github.com/OpenZeppelin/openzeppelin-contracts/blob/57630d2a6466dff65aa7ca67b3fa23d5e6d1474a/contracts/utils/Create2.sol#L57-L64  The implementation is identical but using standard library code avoids the need for verification and minimises possible mistakes.  ## Recommended Mitigation Steps  Replace `storageAddress` with  ```     function storageAddress(address own) public pure returns (address) {        return Create2.computeAddress(             bytes32(\"nested.zeroex.operator\"),             keccak256(type(ZeroExStorage).creationCode)             own,         );     }  ```  "}, {"title": "use msg.sender rather than _msgSender() in FeeSplitter.receive", "html_url": "https://github.com/code-423n4/2021-11-nested-findings/issues/1", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-nested-findings", "body": "# Handle  TomFrench   # Vulnerability details  ## Impact  Gas costs  ## Proof of Concept  In the `receive` function of `FeeSplitter` we check that the address sending ETH is the WETH contract: https://github.com/code-423n4/2021-11-nested/blob/5d113967cdf7c9ee29802e1ecb176c656386fe9b/contracts/FeeSplitter.sol#L74  As we can safely say that the WETH contract will never send a metatransaction, we can just use msg.sender and avoid the extra gas costs of `_msgSender()`  ## Recommended Mitigation Steps  Replace `_msgSender()` with `msg.sender`  "}, {"title": "MixinPurchase:shareKey allows to generate keys without purchasing", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/242", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2021-11-unlock-findings", "body": "MixinPurchase:shareKey allows to generate keys without purchasing"}, {"title": "address(this).address2Str()", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/241", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-unlock-findings", "body": "address(this).address2Str()"}, {"title": "++/-- are cheapest", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/240", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-unlock-findings", "body": "++/-- are cheapest"}, {"title": "0 valueInETH", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/239", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-unlock-findings", "body": "0 valueInETH"}, {"title": "assigned operations to constant variables", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/238", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-unlock-findings", "body": "assigned operations to constant variables"}, {"title": "timePlusFee = timeRemaining", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/237", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-unlock-findings", "body": "timePlusFee = timeRemaining"}, {"title": "Refund amount and penalty calculation", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/236", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-unlock-findings", "body": "Refund amount and penalty calculation"}, {"title": "Unnecessary checks", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/234", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-unlock-findings", "body": "Unnecessary checks"}, {"title": "Precalculate expressions", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/233", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-unlock-findings", "body": "Precalculate expressions"}, {"title": "Unlock:_deployProxyAdmin return value is not used", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/232", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-unlock-findings", "body": "Unlock:_deployProxyAdmin return value is not used"}, {"title": "Store owners in EnumerableSet", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/231", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-11-unlock-findings", "body": "Store owners in EnumerableSet"}, {"title": "Distribution of tokens in recordKeyPurchase", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/230", "labels": ["bug", "1 (Low Risk)"], "target": "2021-11-unlock-findings", "body": "Distribution of tokens in recordKeyPurchase"}, {"title": "Validations", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/228", "labels": ["bug", "1 (Low Risk)"], "target": "2021-11-unlock-findings", "body": "Validations"}, {"title": "Unlock:createLock no need to define the newLock as payable", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/226", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-unlock-findings", "body": "Unlock:createLock no need to define the newLock as payable"}, {"title": "onKeyPurchase hook expects amount + discount", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/225", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-11-unlock-findings", "body": "onKeyPurchase hook expects amount + discount"}, {"title": "Interface and implementation differ", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/224", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-11-unlock-findings", "body": "Interface and implementation differ"}, {"title": "_cancelAndRefund is not protected from re-entrancy", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/223", "labels": ["bug", "1 (Low Risk)"], "target": "2021-11-unlock-findings", "body": "_cancelAndRefund is not protected from re-entrancy"}, {"title": "tokenByIndex returns wrong token id", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/222", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-unlock-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact function _assignNewTokenId first increments _totalSupply and then assigns token id, so ids start from 1, not 0. However, function tokenByIndex in MixinERC721Enumerable expects the index to be less than totalSupply: ```solidity   /// @notice Enumerate valid NFTs   /// @dev Throws if `_index` >= `totalSupply()`.   /// @param _index A counter less than `totalSupply()`   /// @return The token identifier for the `_index`th NFT,   ///  (sort order not specified)   function tokenByIndex(     uint256 _index   ) public view     returns (uint256)   {     require(_index < _totalSupply, 'OUT_OF_RANGE');     return _index;   } ``` This mismatch between indexes and token ids may trick other platforms or integrations.  ## Recommended Mitigation Steps I think the solution is simply returning index + 1: ```solidity     require(_index < _totalSupply, 'OUT_OF_RANGE');     return _index + 1; // index 0 = token id 1 ```  "}, {"title": "Support of different ERC20 tokens", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/221", "labels": ["bug", "1 (Low Risk)"], "target": "2021-11-unlock-findings", "body": "Support of different ERC20 tokens"}, {"title": "msg.value should be 0 when token is not native", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/220", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-unlock-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact function purchase is payable, thus it should validate that msg.value is 0 when tokenAddress != address(0) to prevent accidental sent Ether.  ## Recommended Mitigation Steps Check no ether was sent when the token is not a native currency.  "}, {"title": "Unable to change token approval when tokenAddress changed", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/215", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-11-unlock-findings", "body": "Unable to change token approval when tokenAddress changed"}, {"title": "Gas optimization: Unused variable `yieldedDiscountTokens`", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/213", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-unlock-findings", "body": "Gas optimization: Unused variable `yieldedDiscountTokens`"}, {"title": "Inconsistent code and comment", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/212", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-11-unlock-findings", "body": "Inconsistent code and comment"}, {"title": "Gas improvement on the nonce increment", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/210", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-unlock-findings", "body": "Gas improvement on the nonce increment"}, {"title": "Inconsistent use of _msgSender()", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/209", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-unlock-findings", "body": "Inconsistent use of _msgSender()"}, {"title": "Incorrect or confusing comments or missing code in tokenOfOwnerByIndex", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/208", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-11-unlock-findings", "body": "Incorrect or confusing comments or missing code in tokenOfOwnerByIndex"}, {"title": "Critical changes should use two-step procedure", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/207", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-11-unlock-findings", "body": "Critical changes should use two-step procedure"}, {"title": "`MixinRefunds.sol#_getCancelAndRefundValue` Cache and read storage variables from the stack can save gas", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/206", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-unlock-findings", "body": "`MixinRefunds.sol#_getCancelAndRefundValue` Cache and read storage variables from the stack can save gas"}, {"title": "Typos", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/205", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-unlock-findings", "body": "Typos"}, {"title": "Missing events for critical operations", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/204", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-unlock-findings", "body": "Missing events for critical operations"}, {"title": "Adding unchecked directive can save gas", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/203", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-unlock-findings", "body": "Adding unchecked directive can save gas"}, {"title": "Race condition on ERC20 approval", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/202", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-11-unlock-findings", "body": "Race condition on ERC20 approval"}, {"title": "Remove unnecessary function can make the code simpler and save some gas", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/200", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-unlock-findings", "body": "Remove unnecessary function can make the code simpler and save some gas"}, {"title": "Avoid unnecessary storage reads can save gas", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/199", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-unlock-findings", "body": "Avoid unnecessary storage reads can save gas"}, {"title": "`MixinPurchase#purchase()` Consider checking if _referrer equals _recipient", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/198", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-11-unlock-findings", "body": "`MixinPurchase#purchase()` Consider checking if _referrer equals _recipient"}, {"title": "Incomplete implementation", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/197", "labels": ["bug", "duplicate", "0 (Non-critical)", "sponsor disputed"], "target": "2021-11-unlock-findings", "body": "Incomplete implementation"}, {"title": "Changing function visibility from public to external can save gas", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/196", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-unlock-findings", "body": "Changing function visibility from public to external can save gas"}, {"title": "Redundant check of `owner() != address(0)`", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/194", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-unlock-findings", "body": "Redundant check of `owner() != address(0)`"}, {"title": "Consider adding `initializer` modifier to _initialize** functions", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/193", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-11-unlock-findings", "body": "Consider adding `initializer` modifier to _initialize** functions"}, {"title": "Malicious user can get infinite free trial by repeatedly refund and repurchase right before the freeTrial ends", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/189", "labels": ["bug", "2 (Med Risk)"], "target": "2021-11-unlock-findings", "body": "Malicious user can get infinite free trial by repeatedly refund and repurchase right before the freeTrial ends"}, {"title": "Wrong design/implementation of freeTrial allows attacker to steal funds from the protocol", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/188", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-11-unlock-findings", "body": "# Handle  WatchPug   # Vulnerability details  The current design/implementation of freeTrial allows users to get full refund before the freeTrial ends. Plus, a user can transfer partial of thier time to another user using `shareKey`.  This makes it possible for the attacker to steal from the protocol by transferring freeTrial time from multiple addresses to one address and adding up to `expirationDuration` and call refund to steal from the protocol.  ### PoC  Given:  - `keyPrice` is 1 ETH; - `expirationDuration` is 360 days; - `freeTrialLength` is 31 days.  The attacker can create two wallet addresses: Alice and Bob.  1. Alice calls `purchase()`, transfer 30 days via `shareKey()` to Bob, then calls `cancelAndRefund()` to get full refund; Repeat 12 times; 2. Bob calls `cancelAndRefund()` and get 1 ETH.  ### Recommendation  Consider disabling `cancelAndRefund()` for users who transferred time to another user.  "}, {"title": "`MixinRefunds.sol#cancelAndRefund()` Potential fund loss on `cancelAndRefund()` for users who purchased multiple times", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/187", "labels": ["bug", "1 (Low Risk)"], "target": "2021-11-unlock-findings", "body": "`MixinRefunds.sol#cancelAndRefund()` Potential fund loss on `cancelAndRefund()` for users who purchased multiple times"}, {"title": "Potential economic attack on UDT grants to the referrer", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/186", "labels": ["bug", "1 (Low Risk)"], "target": "2021-11-unlock-findings", "body": "Potential economic attack on UDT grants to the referrer"}, {"title": "Remove unnecessary variables can make the code simpler and save some gas", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/185", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-unlock-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-12-amun/blob/98f6e2ff91f5fcebc0489f5871183566feaec307/contracts/basket/contracts/singleJoinExit/SingleTokenJoin.sol#L51-L57  ```solidity IERC20 inputToken = IERC20(_joinTokenStruct.inputToken);  inputToken.safeTransferFrom(     msg.sender,     address(this),     _joinTokenStruct.inputAmount ); ```  `inputToken` is unnecessary as it's being used only once. Can be changed to:  ```solidity IERC20(_joinTokenStruct.inputToken).safeTransferFrom(     msg.sender,     address(this),     _joinTokenStruct.inputAmount ); ```  "}, {"title": "Code Style: Unnecessary public function visibility", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/184", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-unlock-findings", "body": "# Handle  WatchPug   # Vulnerability details  It's a best practice to limit the visibility to `external` if the function is expected to be called externally only.  ```solidity=180{185}   /**    * Public function which returns the total number of unique owners (both expired    * and valid).  This may be larger than totalSupply.    */   function numberOfOwners()     public     view     returns (uint)   {     return owners.length;   } ```  `numberOfOwners()` can be changed to `external`.  "}, {"title": "`MixinTransfer.sol#transferFrom` Wrong implementation can potentially allows attackers to reverse transfer and cause fund loss to the users", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/182", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-11-unlock-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/mixins/MixinTransfer.sol#L131-L152  ```solidity     if (toKey.tokenId == 0) {       toKey.tokenId = _tokenId;       _recordOwner(_recipient, _tokenId);       // Clear any previous approvals       _clearApproval(_tokenId);     }      if (previousExpiration <= block.timestamp) {       // The recipient did not have a key, or had a key but it expired. The new expiration is the sender's key expiration       // An expired key is no longer a valid key, so the new tokenID is the sender's tokenID       toKey.expirationTimestamp = fromKey.expirationTimestamp;       toKey.tokenId = _tokenId;        // Reset the key Manager to the key owner       _setKeyManagerOf(_tokenId, address(0));        _recordOwner(_recipient, _tokenId);     } else {       // The recipient has a non expired key. We just add them the corresponding remaining time       // SafeSub is not required since the if confirms `previousExpiration - block.timestamp` cannot underflow       toKey.expirationTimestamp = fromKey.expirationTimestamp + previousExpiration - block.timestamp;     } ```  Based on the context, L131-136 seems to be the logic of handling the case of the recipient with no key, and L138-148 is handing the case of the recipient's key expired.  However, in L131-136, the key manager is not being reset.  This allows attackers to keep the role of key manager after the transfer, and transfer the key back or to another recipient.  ### PoC  Given:  - Alice owns a key that is valid until 1 year later.  1. Alice calls `setKeyManagerOf()`, making herself the keyManager; 2. Alice calls `transferFrom()`, transferring the key to Bob; Bob might have paid a certain amount of money to Alice upon receive of the key; 3. Alice calls `transferFrom()` again, transferring the key back from Bob.  ### Recommendation  Consider resetting the key manager regardless of the status of the recipient's key.  "}, {"title": "`MixinLockCore.sol#updateKeyPricing()` Check of `_tokenAddress` can be done earlier to save gas", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/179", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-unlock-findings", "body": "`MixinLockCore.sol#updateKeyPricing()` Check of `_tokenAddress` can be done earlier to save gas"}, {"title": "`UnlockUtils.sol#uint2Str()` Implementation can be simpler and save some gas", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/178", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-unlock-findings", "body": "`UnlockUtils.sol#uint2Str()` Implementation can be simpler and save some gas"}, {"title": "Unused named returns", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/177", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-unlock-findings", "body": "Unused named returns"}, {"title": "Consider adding storage gaps to `Mixin***` contracts", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/174", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-11-unlock-findings", "body": "Consider adding storage gaps to `Mixin***` contracts"}, {"title": "Constants are not explicitly declared", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/173", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-11-unlock-findings", "body": "Constants are not explicitly declared"}, {"title": "Insufficient input validation", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/171", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-11-unlock-findings", "body": "Insufficient input validation"}, {"title": " PREVENT DIV BY 0", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/170", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-11-unlock-findings", "body": " PREVENT DIV BY 0"}, {"title": "transferOwnership should be two step process", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/169", "labels": ["bug", "0 (Non-critical)", "disagree with severity"], "target": "2021-11-unlock-findings", "body": "transferOwnership should be two step process"}, {"title": "Gas: `_recordOwner` pushes duplicates", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/167", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-unlock-findings", "body": "Gas: `_recordOwner` pushes duplicates"}, {"title": "Inaccurate fees computation", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/165", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-11-unlock-findings", "body": "# Handle  cmichel   # Vulnerability details  The `MixinTransfer.shareKey` function wants to compute a fee such that `time + fee * time == timeRemaining (timePlusFee)`:  ```solidity uint fee = getTransferFee(keyOwner, _timeShared); uint timePlusFee = _timeShared + fee; ```  However, if the time remaining is less than the computed fee time, **the computation changes and a different formula is applied**. The fee is now simply taken on the remaining time.  ```solidity if(timePlusFee < timeRemaining) {   // now we can safely set the time   time = _timeShared;   // deduct time from parent key, including transfer fee   _timeMachine(_tokenId, timePlusFee, false); } else {   // we have to recalculate the fee here   fee = getTransferFee(keyOwner, timeRemaining);   // @audit want it such that time + fee * time == timeRemaining, but fee is taken on timeRemaining instead of time   time = timeRemaining - fee; } ```  It should compute the `time` without fee as `time = timeRemaining / (1.0 + fee_as_decimal)` instead, i.e., `time = BASIS_POINTS_DEN * timeRemaining / (transferFeeBasisPoints + BASIS_POINTS_DEN)`.  #### POC To demonstrate the difference with a 10% fee and a `_timeShared = 10,000s` which should be credited to the `to` account.  The correct time plus fee which is reduced from `from` (as in the `timePlusFee < timeRemaining` branch) would be `10,000 + 10% * 10,000 = 11,000`.  However, if `from` has not enough time remaining and `timePlusFee >= timeRemaining`, the entire time remaining is reduced from `from` but the credited `time` is computed wrongly as: (Let's assume `timeRemaining == timePlusFee`): `time = 11,000 - 10% * 11,000 = 11,000 - 1,100 = 9900`.  They would receive 100 seconds less than what they are owed.  ## Impact When transferring more time than the `from` account has, the credited time is scaled down wrongly and the receiver receives less time (a larger fee is applied).  ## Recommended Mitigation Steps It should change the first `if` branch condition to `timePlusFee <= timeRemaining` (less than or equal). In the `else` branch, it should compute the time without fee as `time = BASIS_POINTS_DEN * timeRemaining / (transferFeeBasisPoints + BASIS_POINTS_DEN)`.  "}, {"title": "DoS when `onKeyPurchaseHook` reverts", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/163", "labels": ["bug", "1 (Low Risk)"], "target": "2021-11-unlock-findings", "body": "DoS when `onKeyPurchaseHook` reverts"}, {"title": "No ERC20 safeApprove called & not success check", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/161", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged", "sponsor confirmed"], "target": "2021-11-unlock-findings", "body": "# Handle  cmichel   # Vulnerability details  Some tokens (like USDT) don't correctly implement the EIP20 standard and their `approve` function returns `void` instead of a success boolean. Calling these functions with the correct EIP20 function signatures will always revert.  For the tokens that return a success value, the contract does not check it.  Non-safe transfers are used in: - `MixinLockCore.approveBeneficiary`: `IERC20Upgradeable(tokenAddress).approve(_spender, _amount)`   ## Impact Tokens that return `false` on a failed `approve` or that don't correctly implement the latest EIP20 spec, like USDT, will be unusable in the protocol as they revert the transaction because of the missing return value.  ## Recommended Mitigation Steps We recommend using OpenZeppelin\u2019s `SafeERC20` versions with the `safeApprove` function that handle the return value check as well as non-standard-compliant tokens.  "}, {"title": "Approvals not cleared after key transfer", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/160", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-11-unlock-findings", "body": "# Handle  cmichel   # Vulnerability details  The locks implement three different approval types, see `onlyKeyManagerOrApproved` for an overview: - key manager (map `keyManagerOf`) - single-person approvals (map `approved`). Cleared by `_clearApproval` or `_setKeyManagerOf` - operator approvals (map `managerToOperatorApproved`)  The `MixinTransfer.transferFrom` requires any of the three approval types in the `onlyKeyManagerOrApproved` modifier on the tokenId to authenticate transfers from `from`.  Notice that if the `to` address previously had a key but it expired only the `_setKeyManagerOf` call is performed, which does not clear `approved` if the key manager was already set to 0:  ```solidity function transferFrom(   address _from,   address _recipient,   uint _tokenId )   public   onlyIfAlive   hasValidKey(_from)   onlyKeyManagerOrApproved(_tokenId) {   // @audit this is skipped if user had a key that expired   if (toKey.tokenId == 0) {     toKey.tokenId = _tokenId;     _recordOwner(_recipient, _tokenId);     // Clear any previous approvals     _clearApproval(_tokenId);   }    if (previousExpiration <= block.timestamp) {     // The recipient did not have a key, or had a key but it expired. The new expiration is the sender's key expiration     // An expired key is no longer a valid key, so the new tokenID is the sender's tokenID     toKey.expirationTimestamp = fromKey.expirationTimestamp;     toKey.tokenId = _tokenId;      // Reset the key Manager to the key owner     // @audit  doesn't clear approval if key manager already was 0     _setKeyManagerOf(_tokenId, address(0));      _recordOwner(_recipient, _tokenId);   }   // ... }  //  function _setKeyManagerOf(   uint _tokenId,   address _keyManager ) internal {   // @audit-ok only clears approved if key manager updated   if(keyManagerOf[_tokenId] != _keyManager) {     keyManagerOf[_tokenId] = _keyManager;     _clearApproval(_tokenId);     emit KeyManagerChanged(_tokenId, address(0));   } } ```  ## Impact It's possible to sell someone a key and then claim it back as the approvals are not always cleared.  ## POC - Attacker A has a valuable key (`tokenId = 42`) with an expiry date far in the future. - A sets approvals for their second attacker controlled account A' by calling `MixinKeys.setApprovalForAll(A', true)`, which sets `managerToOperatorApproved[A][A'] = true`. - A clears the key manager by setting it to zero, for example, by transferring it to a second account that does not have a key yet, this calls the above `_setKeyManagerOf(42, address(0));` in `transferFrom` - A sets single-token approval to A' by calling `MixinKeys.approve(A', 42)`, setting `approved[42] = A'`. - A sells the token to a victim V for a discount (compared to purchasing it from the Lock). The victim needs to have owned a key before which already expired. The `transferFrom(A, V, 42)` call sets the owner of token 42 to `V`, but does not clear the `approved[42] == A'` field as described above. (`_setKeyManagerOf(_tokenId, address(0));` is called but the key manager was already zero, which then does not clear approvals.) - A' can claim back the token by calling `transferFrom(V, A', 42)` and the `onlyKeyManagerOrApproved(42)` modifier will pass as `approved[42] == A'` is still set.  ## Recommended Mitigation Steps The `_setKeyManagerOf` function should not handle clearing approvals of single-token approvals (`approved`) as these are two separate approval types. The `transferFrom` function should always call `_clearApproval` in the `(previousExpiration <= block.timestamp)` case.   "}, {"title": "Can set arbitrary lock templates", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/158", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-unlock-findings", "body": "# Handle  cmichel   # Vulnerability details  The `Unlock.setLockTemplate` function sets the default lock tempalte for new lock creations. However, it does not verify that this lock template is a valid template that was added to `_publicLockVersions` via `addLockTemplate`.  ## Impact A default template with a wrong version number can be set which is incompatible with updating locks through `upgradeLock` (requires `version == currentVersion + 1`).  ## Recommended Mitigation Steps Add new lock templates using `addLockTemplate` first and restrict `setLockTemplate` to only use these templates, not arbitrary code.   "}, {"title": "ERC20 return values not checked", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/157", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-unlock-findings", "body": "ERC20 return values not checked"}, {"title": "Missing scaling factor in `recordKeyPurchase`?", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/156", "labels": ["bug", "help wanted", "2 (Med Risk)"], "target": "2021-11-unlock-findings", "body": "Missing scaling factor in `recordKeyPurchase`?"}, {"title": "Referrer discount token amount can be manipulated", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/155", "labels": ["bug", "2 (Med Risk)"], "target": "2021-11-unlock-findings", "body": "Referrer discount token amount can be manipulated"}, {"title": "Lock template versions can be overwritten", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/154", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-11-unlock-findings", "body": "Lock template versions can be overwritten"}, {"title": "`initialize` functions can be frontrun", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/153", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-11-unlock-findings", "body": "`initialize` functions can be frontrun"}, {"title": "MixinLockCore: use safeApprove from SafeERC20, and do approve(0) before approve(amount)", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/151", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-11-unlock-findings", "body": "MixinLockCore: use safeApprove from SafeERC20, and do approve(0) before approve(amount)"}, {"title": "MixinGrantKeys:grantKeys gas optimizations", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/149", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-unlock-findings", "body": "MixinGrantKeys:grantKeys gas optimizations"}, {"title": "Function grantKeys() - Bulk Send Free Keys Are Not Practical & Gas May Over Block Size Limit", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/147", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-11-unlock-findings", "body": "Function grantKeys() - Bulk Send Free Keys Are Not Practical & Gas May Over Block Size Limit"}, {"title": "Avoiding Initialization of Loop Index If It Is 0", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/146", "labels": ["bug", "0 (Non-critical)"], "target": "2021-11-unlock-findings", "body": "# Handle  Meta0xNull   # Vulnerability details  ## Impact The local variable used as for loop index need not be initialized to 0 because the default value is 0. Avoiding this anti-pattern can save a few opcodes and therefore a tiny bit of gas.  ## Proof of Concept https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/TransferService.sol#L87 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/AuctionBurnReserveSkew.sol#L54 https://github.com/code-423n4/2021-11-malt/blob/main/src/contracts/Malt.sol#L34-L37 More...  ## Tools Used Manual Review  ## Recommended Mitigation Steps Remove explicit 0 initialization of for loop index variable.   Before: for (uint i = 0; After for (uint i;  "}, {"title": "Avoid On Chain Computation That Have Known Answer to Save Gas", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/145", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-unlock-findings", "body": "Avoid On Chain Computation That Have Known Answer to Save Gas"}, {"title": "getTransferFee() Fee Could Be 0", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/140", "labels": ["bug", "1 (Low Risk)"], "target": "2021-11-unlock-findings", "body": "getTransferFee() Fee Could Be 0"}, {"title": "Initialization parameters of new lock template are hardcoded", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/137", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-unlock-findings", "body": "# Handle  kenzo   # Vulnerability details  `setLockTemplate` is initializing the new template using hardcoded values. This means that if a new lock version is set which has different/additional `initialize` parameters, Unlock protocol would have to be updated in order to initialize it.  ## Impact Less convenient adding of new locks as Unlock would have to be upgraded if their initialize function has changed.  ## Proof of Concept `setLockTemplate` uses the following code to initialize the template: ```     IPublicLock(_publicLockAddress).initialize(       address(this), 0, address(0), 0, 0, ''     ); ``` https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/Unlock.sol#L430:#L432 Which is hardcoded. This is unlike `createLock` for example, where the initialize call is being received as parameter, to allow different future versions. https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/Unlock.sol#L219   ## Recommended Mitigation Steps Change `setLockTemplate` so the initializing parameters would be received as parameter.  "}, {"title": "Unlock has incomplete fallback function which may cause loss of funds", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/136", "labels": ["bug", "1 (Low Risk)"], "target": "2021-11-unlock-findings", "body": "Unlock has incomplete fallback function which may cause loss of funds"}, {"title": "MEV miner can mint larger than expected UDT total supply", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/135", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-11-unlock-findings", "body": "# Handle  elprofesor   # Vulnerability details  ## Impact `UnlockProtocol` attempts to calculate gas reimbursement using tx.gasprice, typically users who falsify tx.gasprice would lose gas to miners and therefore not obtain any advantage over the protocol itself. This does present capabilities for miners to extract value, as they can submit their own transactions, or cooperate with a malicious user, reimbursing a portion (or all) or the tx.gasprice used. As the following calculation is made; ```     uint tokensToDistribute = (estimatedGasForPurchase * tx.gasprice) * (125 * 10 ** 18) / 100 / udtPrice; ```  we can see that arbitrary tx.gasprices can rapidly inflate the `tokensToDistribute`. Though capped at maxTokens, this value can be up to half the total supply of UDT, which could dramatically affect the value of UDT potentially leading to lucrative value extractions outside of the pool.  ## Proof of Concept  ## Recommended Mitigation Steps Using an oracle service to determine the average gas price and ensuring it is within some normal bounds that has not been subjected to arbitrary value manipulation.  "}, {"title": "Insufficient version validation causes denial of service for `PublicLock` during lock upgrades", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/134", "labels": ["bug", "1 (Low Risk)"], "target": "2021-11-unlock-findings", "body": "Insufficient version validation causes denial of service for `PublicLock` during lock upgrades"}, {"title": "`Unlock.addLockTemplate` does not adequately increment version, leading to gaps in version", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/133", "labels": ["bug", "1 (Low Risk)"], "target": "2021-11-unlock-findings", "body": "`Unlock.addLockTemplate` does not adequately increment version, leading to gaps in version"}, {"title": "Frontrunning `PublicLock.initialize()` can prevent upgrades due to insufficient access control", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/132", "labels": ["bug", "2 (Med Risk)"], "target": "2021-11-unlock-findings", "body": "Frontrunning `PublicLock.initialize()` can prevent upgrades due to insufficient access control"}, {"title": "Reduce rounding error when minting UDT in Unlock", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/131", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-unlock-findings", "body": "# Handle  HardlyDifficult   # Vulnerability details  ## Impact `maxTokens` in Unlock's `recordKeyPurchase` currently rounds more than is required.  ## Proof of Concept Plug the formula in Wolfgram Alpha to simplify from:  ```             maxTokens = IMintableERC20(udt).balanceOf(address(this)) * valueInETH / (2 + 2 * valueInETH / grossNetworkProduct) / grossNetworkProduct; ```  to ```             maxTokens = IMintableERC20(udt).balanceOf(address(this)) * valueInETH / (2 * (valueInETH + grossNetworkProduct)); ```  Example inputs: ``` balance: 10000 price: 0.012345678912345678 gnp: 1000 + 0.012345678912345678 (for this purchase)  61728394561728390 old formula 61727632492197622 new formula (smaller than old) 61726870441482920.98 actual per wolfgram (smaller than new) 1524120245470 delta old - actual 762050714702 delta new - actual ```  The \"new\" formula proposed above is closer to the expected value. It's also easier to read and saves 123 gas.  ## Tools Used https://www.wolframalpha.com/  ## Recommended Mitigation Steps  "}, {"title": "Gas: remove owners array", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/130", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-unlock-findings", "body": "Gas: remove owners array"}, {"title": "Gas: Cast instead of creating new variables", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/129", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-unlock-findings", "body": "Gas: Cast instead of creating new variables"}, {"title": "Fix event params for `KeyManagerChanged`", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/128", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-unlock-findings", "body": "# Handle  HardlyDifficult   # Vulnerability details  ## Impact KeyManagerChanged does not emit the new manager address as expected. Additionally there's a small gas savings of 1.5k gas by not emitting the event twice in `grantKeys`.  ## Proof of Concept Per the event param names, this event should emit the new keyManager's address. That would allow an indexer such as subgraph to track the current manager for each token. However the event currently emits address(0):  https://github.com/code-423n4/2021-11-unlock/blob/52f3f3d0524dda28aea327181c3479d85782007b/smart-contracts/contracts/mixins/MixinKeys.sol#L229  Change that line to: `emit KeyManagerChanged(_tokenId, _keyManager);`  Additionally this line may be removed: https://github.com/code-423n4/2021-11-unlock/blob/52f3f3d0524dda28aea327181c3479d85782007b/smart-contracts/contracts/mixins/MixinGrantKeys.sol#L48 as the call right before it to `_setKeyManagerOf` will emit the event already.  ## Tools Used `yarn test`  ## Recommended Mitigation Steps When testing this change only one test failed, and it was due to assuming the index of the event: https://github.com/code-423n4/2021-11-unlock/blob/52f3f3d0524dda28aea327181c3479d85782007b/smart-contracts/test/Lock/grantKeys.js#L80  It would be nice to be more robust like some other tests are, e.g. https://github.com/code-423n4/2021-11-unlock/blob/52f3f3d0524dda28aea327181c3479d85782007b/smart-contracts/test/Lock/grantKeys.js#L49   Also add a test to confirm that the keyManager is emitting in the event.  Personally I like Waffle for testing events: https://ethereum-waffle.readthedocs.io/en/latest/getting-started.html?highlight=emits#writing-tests  ```  it('Transfer emits event', async () => {     await expect(token.transfer(walletTo.address, 7))       .to.emit(token, 'Transfer')       .withArgs(wallet.address, walletTo.address, 7);   }); ```  "}, {"title": "Gas: Assume 0 when creating struct", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/127", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-unlock-findings", "body": "Gas: Assume 0 when creating struct"}, {"title": "Gas: Merge callbacks to Unlock on purchase", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/126", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-unlock-findings", "body": "Gas: Merge callbacks to Unlock on purchase"}, {"title": "MixinTransfer:getTransferFee gas optimization with unchecked", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/123", "labels": ["G (Gas Optimization)"], "target": "2021-11-unlock-findings", "body": "MixinTransfer:getTransferFee gas optimization with unchecked"}, {"title": "MixinLockCore.sol has wrong comments", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/122", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-unlock-findings", "body": "# Handle  GiveMeTestEther   # Vulnerability details  ## Impact  Wrong comment for withdraw(): modifier onlyLockManagerOrBeneficiary also allows the beneficiary to call this function and a beneficiary doesn't need to be a key manager/owner  [https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/mixins/MixinLockCore.sol#L123](https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/mixins/MixinLockCore.sol#L123)  Wrong comment for updateBeneficiary(): require statement also allows the beneficiary to call this function and a beneficiary doesn't need to be a key manager/owner  [https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/mixins/MixinLockCore.sol#L189](https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/mixins/MixinLockCore.sol#L189)  ## Recommended Mitigation Steps - Fix comments, because the implementation seems to be correct    "}, {"title": "Use existing memory version of state variables", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/121", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-unlock-findings", "body": "Use existing memory version of state variables"}, {"title": "a single user can become owner of multiple token ids", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/120", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-unlock-findings", "body": "# Handle  GiveMeTestEther   # Vulnerability details  ## Impact / POC  A single user can become the owner of multiple token ids and break the assumption of the comment [https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/mixins/MixinKeys.sol#L181](https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/mixins/MixinKeys.sol#L181) of the function numberOfOwners() that it returns \"total number of unique owners\"   If a key manager/approved transfers a key with transferFrom() [https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/mixins/MixinTransfer.sol#L109](https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/mixins/MixinTransfer.sol#L109) to a recipient that also owns a valid key then we don't go into the \"if block\" L131 and also not into the \"if block\" L138 (this is important s.t. no key owner change happens) and go into the \"else block\" L148 (not really important).   We end with: fromKey.expirationTimestamp = block.timestamp; and fromKey.tokenId = 0;  If the key owner or someone else buys for this key owner again a \"key\" [https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/mixins/MixinPurchase.sol#L51](https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/mixins/MixinPurchase.sol#L51) satisfies the condition idTo ==0 (bcs of tokenId = 0) and in _assignNewTokenId(toKey); the key gets a new token id and the owner gets also registered as the new owner of the new token id in _recordOwner(_recipient, idTo);  The \"old\" key got overwritten but we are now the owner of two token ids.  This breaks the comment of numberOfOwners() that it returns \"total number of unique owners\" but for this the key owner that owns now two token ids, we executed \"_recordOwner\" twice and therefore added the same address twice to the owner array  [https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/mixins/MixinKeys.sol#L327](https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/mixins/MixinKeys.sol#L327)   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  - need to also implement the removal of ownership of a tokenId when it is set 0 zero to be congruent with the state of the key, and also adapt the other logic depending on it  "}, {"title": "Setting the admin in initialize initializeProxyAdmin can be frontrun by an attacker", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/117", "labels": ["bug", "1 (Low Risk)"], "target": "2021-11-unlock-findings", "body": "Setting the admin in initialize initializeProxyAdmin can be frontrun by an attacker"}, {"title": "4 variables are cached and used only once at `Unlock.sol#upgradeLock`", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/116", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-unlock-findings", "body": "4 variables are cached and used only once at `Unlock.sol#upgradeLock`"}, {"title": "`== true` doesn't bring anything", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/115", "labels": ["bug", "0 (Non-critical)"], "target": "2021-11-unlock-findings", "body": "`== true` doesn't bring anything"}, {"title": "`Unlock.sol#RecordKeyPurchases` can be implemented cheaper", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/114", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-unlock-findings", "body": "`Unlock.sol#RecordKeyPurchases` can be implemented cheaper"}, {"title": "Use unchecked operation to save gas", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/111", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-unlock-findings", "body": "Use unchecked operation to save gas"}, {"title": "`MixinGrantKeys.sol` apply requiere statements earlier", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/110", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-unlock-findings", "body": "`MixinGrantKeys.sol` apply requiere statements earlier"}, {"title": "Use safeTransfer consistently instead of transfer", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/109", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-11-unlock-findings", "body": "Use safeTransfer consistently instead of transfer"}, {"title": "Missing input validation on array lengths (MixinGrantKeys.sol)", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/105", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-11-unlock-findings", "body": "Missing input validation on array lengths (MixinGrantKeys.sol)"}, {"title": "Cache length at for loop to save gas", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/103", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-unlock-findings", "body": "Cache length at for loop to save gas"}, {"title": "Setters of `UnlockProtocolGovernor.sol` can be implemented more efficiently", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/101", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-unlock-findings", "body": "Setters of `UnlockProtocolGovernor.sol` can be implemented more efficiently"}, {"title": "`UnlockUtils.sol#address2Str` can be implemented much cheaper", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/98", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-unlock-findings", "body": "`UnlockUtils.sol#address2Str` can be implemented much cheaper"}, {"title": "`freeTrialLength` is used as full refund period", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/96", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-11-unlock-findings", "body": "`freeTrialLength` is used as full refund period"}, {"title": "Remove fallback function", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/94", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-unlock-findings", "body": "# Handle  HardlyDifficult   # Vulnerability details  ## Impact Unimplemented calls do not revert, this may cause unexpected behavior in wallets or other contracts.  ## Proof of Concept Locks are ERC721s, they also implement some ERC20 style calls such as `transfer`. If a wallet or another contract attempted to treat the contract as a ERC77, `send` would incorrectly appear to work but nothing happens under the hood. It would be better if this call reverted so that the user was aware the function is not supported before even broadcasting the transaction (Metamask will warn you if estimate gas fails).  This test currently fails (i.e. calling send does not revert).  ```   it(\"Should fail on unknown calls\", async () => {       const mock777 = await erc777.at(lock.address);       await reverts(         mock777.send(destination, 1, '0x', { from: singleKeyOwner })       )     }) ```  ## Tools Used `yarn test`  ## Recommended Mitigation Steps Remove this line https://github.com/code-423n4/2021-11-unlock/blob/52f3f3d0524dda28aea327181c3479d85782007b/smart-contracts/contracts/PublicLock.sol#L72  Per the comments there is not a clear reason it's currently included. The test suite still passes when it is removed.  "}, {"title": "shareKey onERC721Received tokenId", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/91", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-unlock-findings", "body": "# Handle  HardlyDifficult   # Vulnerability details  ## Impact A contract implementing `ERC721TokenReceiver` is called with a tokenId that was not sent to that address when `shareKey` is used. If the `onERC721Received` implementation included any logic which assumed ownership it may fail, e.g. checking `ownerOf`, `balanceOf` or performing a task such as `transferFrom` to forward the asset to another destination.  ## Proof of Concept `shareKey` accepts a `_tokenId` as the source of expiration time to share. It then either mints a new token for the target account or adds time to their existing key. Either way the receiver has a different tokenId than the one that was passed to the `shareKey` function.  ## Tools Used n/a  ## Recommended Mitigation Steps Change https://github.com/code-423n4/2021-11-unlock/blob/52f3f3d0524dda28aea327181c3479d85782007b/smart-contracts/contracts/mixins/MixinTransfer.sol#L106  from: `require(_checkOnERC721Received(keyOwner, _to, _tokenId, ''), 'NON_COMPLIANT_ERC721_RECEIVER');`  to: `require(_checkOnERC721Received(keyOwner, _to, idTo, ''), 'NON_COMPLIANT_ERC721_RECEIVER');`  "}, {"title": "Unconventional log emittance confuses Etherscan", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/90", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-unlock-findings", "body": "# Handle  kenzo   # Vulnerability details  Unlock doesn't follow standard ERC721 log emittance. This leads to wrong display values regarding to the lock NFT on Etherscan.  ## Impact Etherscan does not show txs correctly, does not count token holders correctly in token page, does not count tokens correctly in user page.  ## Proof of Concept A scenario: - Create a new lock - User 1 mints 1 token - User 1 uses `shareKey` and transfers some amount to User 2 At this point Etherscan will show that 3 transfers have been made, under user 2's address page user 2 has 2 keys , and under lock's holders tab user 2 has 2 keys. All this is obviously wrong. This is probably because the transfer event is emitted twice during shareKey: [here](https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/mixins/MixinTransfer.sol#L87) and [here](https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/mixins/MixinTransfer.sol#L100).  Additionally, if user 1 now calls `Cancel And Refund`, user 1 will still have a key under his tokens in his account, and the lock's token page will still list him as a holder, and the transaction won't get shown in Etherscan's token transfers (unlike contract transactions). Probably because it has not emitted any burn event. It just emits a [CancelKey event](https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/mixins/MixinRefunds.sol#L111).  ## Recommended Mitigation Steps You can align the logs emittance to match regular ERC721 logs if you'd like Etherscan to show correct amounts. It might get confusing to keep it like this.  "}, {"title": "Less than 256 uints are not gas efficient", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/89", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-unlock-findings", "body": "# Handle  defsec   # Vulnerability details  ## Impact  Lower than uint256 size storage instance variables are actually less gas efficient. E.g. using uint32 does not give any efficiency, actually, it is the opposite as EVM operates on default of 256-bit values so uint32 is more expensive in this case as it needs a conversion. It only gives improvements in cases where you can pack variables together, e.g. structs.  ## Proof of Concept  1. Navigate to the following contracts.  ``` https://github.com/XDeFi-tech/xdefi-distribution/blob/master/contracts/XDEFIDistribution.sol#L301 ```  2. Expiry value is just used for the comparison with the block.timestamp.  ## Tools Used  None  ## Recommended Mitigation Steps  Consider to review all uint types. Change them with uint256 If the integer is not necessary to present with uint32.  "}, {"title": "Key transfer will destroy key if from==to", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/87", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-11-unlock-findings", "body": "# Handle  kenzo   # Vulnerability details  If calling `transferFrom` with `_from == _recipient`, the key will get destroyed (meaning the key will be set as expired and set the owner's key to be 0).  ## Impact A key manager or approved might accidently destroy user's token.  Note: this requires user error and so I'm not sure if this is a valid finding. However, few things make me think that it is valid: - Unlock protocol checks for transfer to 0-address, so some input validation is there - Since other entities other than the owner can be allowed to transfer owner's token, it might be best to make sure such accidental mistake could not happen. - This scenario manifests a unique and probably unintended behavior   ## Proof of Concept By following `transferFrom`'s execution: https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/mixins/MixinTransfer.sol#L109:#L166 One can see that in the case where `_from == _recipient` with a valid key: - The function will deduct transfer fee from the key - The function will incorrectly add more time to the key's expiration ([L151](https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/mixins/MixinTransfer.sol#L151)) - The function will expire and reset the key ([L155](https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/mixins/MixinTransfer.sol#L155:#L158)) Therefore, the user will lose his key without getting a refund.  ## Recommended Mitigation Steps Add a require statement in the beginning of `transferFrom`: `require(_from != _recipient, 'TRANSFER_TO_SELF');`  "}, {"title": "Input validation of Zero address on function initialize()", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/86", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor disputed"], "target": "2021-11-unlock-findings", "body": "Input validation of Zero address on function initialize()"}, {"title": "Confliction on double `initialize` functions front-run `minter` ", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/85", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-11-unlock-findings", "body": "Confliction on double `initialize` functions front-run `minter` "}, {"title": "Wrong event parameter emitted at _setKeyManagerOf", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/84", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-unlock-findings", "body": "# Handle  kenzo   # Vulnerability details  `_setKeyManagerOf` always emits `address(0)` as the new key manager.  ## Impact Wrong event emitted.  ## Proof of Concept The code is: `emit KeyManagerChanged(_tokenId, address(0));` https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/mixins/MixinKeys.sol#L229  ## Recommended Mitigation Steps Change line to `emit KeyManagerChanged(_tokenId, _keyManager);`  "}, {"title": "Input validation of Zero address on addLockTemplate", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/83", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-11-unlock-findings", "body": "Input validation of Zero address on addLockTemplate"}, {"title": "Wrong comment in recordKeyPurchase", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/82", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-11-unlock-findings", "body": "Wrong comment in recordKeyPurchase"}, {"title": "Input validation Zero address", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/81", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor acknowledged"], "target": "2021-11-unlock-findings", "body": "Input validation Zero address"}, {"title": "Missing `_beforeTokenTransfer` Token Transfer Handle", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/78", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-unlock-findings", "body": "# Handle  hagrid   # Vulnerability details  ## Details `UnlockDiscountTokenV2.sol` has override for `_afterTokenTransfer` handler function to control events or operations after token transfers. Also, the `UnlockDiscountTokenV2.sol` uses another token contracts from `ERC20Patched.sol`. In `ERC20Patched.sol` contract there are also `_beforeTokenTransfer` transfer handles. However, the `UnlockDiscountTokenV2.sol`  token does not have any override for `_beforeTokenTransfer` method.   ## Impact Contract will not react to any operations before token transfers. If gas calculations are aimed on UnlockToken's transfer, it will not be possible to calculate correct gas amounts without these both handlers (_beforeTokenTransfer and _afterTokenTransfer)  ## Proof of Concept Provide direct links to all referenced code in GitHub. Add screenshots, logs, or any other relevant proof that illustrates the concept.  ## Recommended Mitigation Steps Possible fix is implementing additional override for `_beforeTokenTransfer` method:  ```  function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override(ERC20Upgradeable, ERC20VotesUpgradeable) {     return ERC20VotesUpgradeable._beforeTokenTransfer(from, to, amount);   } ```  "}, {"title": "input validation", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/77", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-11-unlock-findings", "body": "input validation"}, {"title": "Function type from public to external tokenByIndex()", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/76", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-unlock-findings", "body": "# Handle  BouSalman   # Vulnerability details  ## Vulnerability Description Some of the implemented functions inside the smart contracts are of type Public, However these functions are not used within the contracts. The function **tokenByIndex()** is part of the EIP721 which define it as external function.  ## Impact Coding style quality.  ## Proof of Concept https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/mixins/MixinERC721Enumerable.sol#L35  ## Tools Used manual code review.  ## Recommended Mitigation Steps Change the function to external and follow the ERC721 Specs when implementing: https://eips.ethereum.org/EIPS/eip-721#specification  "}, {"title": "Missing event for critical updateBeneficiary function", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/75", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-unlock-findings", "body": "# Handle  BouSalman   # Vulnerability details  ## Vulnerability description  The function **updateBeneficiary** in the **MixinLockCore** smart contract is used to lets the owner of the lock update the beneficiary account which receives funds on withdrawal.   ## Impact Attackers can change the beneficiary address using this function before continue with the withdrawal function. Unlock protocol team and users can't log or monitor this critical changes.  ## Proof of Concept https://github.com/code-423n4/2021-11-unlock/blob/52f3f3d0524dda28aea327181c3479d85782007b/smart-contracts/contracts/mixins/MixinLockCore.sol#L192  ## Tools Used manual code review  ## Recommended Mitigation Steps define event and emit it to track changes done to the system.  "}, {"title": "Unimplemented function computeAvailableDiscountFor ", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/74", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-unlock-findings", "body": "# Handle  harleythedog   # Vulnerability details  ## Impact The function computeAvailableDiscountFor is left unimplemented in Unlock.sol. Recommend implementing this function or removing it.  ## Proof of Concept https://github.com/code-423n4/2021-11-unlock/blob/ec41eada1dd116bcccc5603ce342257584bec783/smart-contracts/contracts/Unlock.sol#L269  ## Tools Used Inspection.  ## Recommended Mitigation Steps Implement function or remove it to save gas.  "}, {"title": "MixinRefunds: frontrun updateKeyPricing() for free profit", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/72", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2021-11-unlock-findings", "body": "MixinRefunds: frontrun updateKeyPricing() for free profit"}, {"title": "Unlock: free UDT arbitrage opportunity", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/70", "labels": ["bug", "2 (Med Risk)"], "target": "2021-11-unlock-findings", "body": "Unlock: free UDT arbitrage opportunity"}, {"title": "MixinPurchase: gas optimisation by relying on 0.8.0 auto revert on underflow.", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/69", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-unlock-findings", "body": "MixinPurchase: gas optimisation by relying on 0.8.0 auto revert on underflow."}, {"title": "MixinRefunds: use variable to save gas", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/68", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-unlock-findings", "body": "MixinRefunds: use variable to save gas"}, {"title": "Unused Named Returns", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/66", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-unlock-findings", "body": "Unused Named Returns"}, {"title": "MixinGrantKeys:grantKeys possible DoS with (Unexpected) revert", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/62", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-11-unlock-findings", "body": "MixinGrantKeys:grantKeys possible DoS with (Unexpected) revert"}, {"title": "MixinFunds:_initializeMixinFunds move the require statement to the beginning of the function so save gas in the case of a revert", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/60", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-unlock-findings", "body": "MixinFunds:_initializeMixinFunds move the require statement to the beginning of the function so save gas in the case of a revert"}, {"title": "grantKeys no check on parameter array lengths and values", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/56", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-11-unlock-findings", "body": "grantKeys no check on parameter array lengths and values"}, {"title": "Missing maxNumberOfKeys checks in shareKey and grantKey", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/55", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-11-unlock-findings", "body": "# Handle  kenzo   # Vulnerability details  More keys can be minted than maxNumberOfKeys since `shareKey` and `grantKey` do not check if the lock is sold out.  ## Impact More keys can be minted than intended.  ## Proof of Concept In both `shareKey` and `grantKey`, if minting a new token, a new token is simply minted (and `_totalSupply` increased) without checking it against `maxNumberOfKeys`. This is unlike `purchase`, which has the `notSoldOut` modifier. `grantKey`: https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/mixins/MixinGrantKeys.sol#L41:#L42 `shareKey`: https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/mixins/MixinTransfer.sol#L83:#L84 Both functions call `_assignNewTokenId` which does not check maxNumberOfKeys.  https://github.com/code-423n4/2021-11-unlock/blob/main/smart-contracts/contracts/mixins/MixinKeys.sol#L311:#L322 So you can say that `_assignNewTokenId` is actually the root of the error, and this is why I am submitting this as 1 finding and not 2 (for grantKey/shareKey).  ## Recommended Mitigation Steps Add a check to `_assignNewTokenId` that will revert if we need to record a new key and `maxNumberOfKeys` has been reached.  "}, {"title": "Redundant check of freeTrialLength == 0", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/54", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-unlock-findings", "body": "Redundant check of freeTrialLength == 0"}, {"title": "Refund mechanism doesn't take into account that key price can change", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/53", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2021-11-unlock-findings", "body": "Refund mechanism doesn't take into account that key price can change"}, {"title": "setKeyManagerOf has no address-0 check", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/52", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-11-unlock-findings", "body": "setKeyManagerOf has no address-0 check"}, {"title": "Key buyers will not be able to get refund if lock manager withdraws profits", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/50", "labels": ["bug", "2 (Med Risk)"], "target": "2021-11-unlock-findings", "body": "Key buyers will not be able to get refund if lock manager withdraws profits"}, {"title": "Use of access control require statement when modifier exists", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/48", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-11-unlock-findings", "body": "Use of access control require statement when modifier exists"}, {"title": "Commented lines of code", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/46", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-11-unlock-findings", "body": "Commented lines of code"}, {"title": "Function spec and implementation difference / strict comparison", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/45", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-11-unlock-findings", "body": "Function spec and implementation difference / strict comparison"}, {"title": "Potential division by 0 in `recordKeyPurchase`", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/43", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-11-unlock-findings", "body": "Potential division by 0 in `recordKeyPurchase`"}, {"title": "Use explicit variables type", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/37", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-11-unlock-findings", "body": "Use explicit variables type"}, {"title": "Long Revert Strings", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/36", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-unlock-findings", "body": "Long Revert Strings"}, {"title": "MixinERC721Enumerable.tokenOfOwnerByIndex - parameter _index can be removed", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/32", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-11-unlock-findings", "body": "MixinERC721Enumerable.tokenOfOwnerByIndex - parameter _index can be removed"}, {"title": "The function MixinLockCore.approveBeneficiary is susceptible to a race condition", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/29", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-11-unlock-findings", "body": "The function MixinLockCore.approveBeneficiary is susceptible to a race condition"}, {"title": "Changes that affect access control should be accompanied by an event", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/28", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-11-unlock-findings", "body": "Changes that affect access control should be accompanied by an event"}, {"title": "Scenario where variable in Unlock.recordKeyPurchase() is not initialized", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/27", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-11-unlock-findings", "body": "Scenario where variable in Unlock.recordKeyPurchase() is not initialized"}, {"title": "Unnecessary function parameter in Unlock.upgradeLock() function", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/25", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-11-unlock-findings", "body": "Unnecessary function parameter in Unlock.upgradeLock() function"}, {"title": "Using uint16 for lock versions increases gas costs for no reason.", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/24", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-unlock-findings", "body": "Using uint16 for lock versions increases gas costs for no reason."}, {"title": "Open TODOs", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/22", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-11-unlock-findings", "body": "Open TODOs"}, {"title": "safeApprove is deprecated. ", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/21", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-11-unlock-findings", "body": "safeApprove is deprecated. "}, {"title": "named return issue", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/20", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-11-unlock-findings", "body": "named return issue"}, {"title": "USE OF FLOATING PRAGMA", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/15", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-11-unlock-findings", "body": "USE OF FLOATING PRAGMA"}, {"title": "USE OF DEPRECATED _SETUPROLE FUNCTION", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/14", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor acknowledged"], "target": "2021-11-unlock-findings", "body": "USE OF DEPRECATED _SETUPROLE FUNCTION"}, {"title": "Upgrade pragma to at least 0.8.4", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/12", "labels": ["bug", "0 (Non-critical)"], "target": "2021-11-unlock-findings", "body": "Upgrade pragma to at least 0.8.4"}, {"title": "Order of layout is wrong in ERC20Patched.sol", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/11", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-11-unlock-findings", "body": "Order of layout is wrong in ERC20Patched.sol"}, {"title": "Order of function is wrong in contracts ERC20PermitUpgradeable, ERC20VotesCompUpgradeable, EIP712Upgradeable", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/9", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-11-unlock-findings", "body": "Order of function is wrong in contracts ERC20PermitUpgradeable, ERC20VotesCompUpgradeable, EIP712Upgradeable"}, {"title": "Function type from public to external", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/5", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-11-unlock-findings", "body": "Function type from public to external"}, {"title": "Unnecessary fallback function", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/4", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-unlock-findings", "body": "Unnecessary fallback function"}, {"title": "Unused function parameters ", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/3", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-11-unlock-findings", "body": "Unused function parameters "}, {"title": "Initializer modifiers should be called in the same way everywhere ", "html_url": "https://github.com/code-423n4/2021-11-unlock-findings/issues/1", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor acknowledged"], "target": "2021-11-unlock-findings", "body": "Initializer modifiers should be called in the same way everywhere "}, {"title": "IsContract Function Usage", "html_url": "https://github.com/code-423n4/2021-12-maple-findings/issues/72", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-12-maple-findings", "body": "IsContract Function Usage"}, {"title": "Fund stuck in `Liquidator` if `stopLiquidation` is called ", "html_url": "https://github.com/code-423n4/2021-12-maple-findings/issues/67", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "sponsor confirmed"], "target": "2021-12-maple-findings", "body": "# Handle  gzeon   # Vulnerability details  ## Impact `stopLiquidation` does not pull fund from `Liquidator` while setting `_liquidator` to address(0). Since the `DebtLocker` own `Liquidator` and there are no way to set `_liquidator` to existing address, fund still in `Liquidator` would be stuck unless `DebtLocker` is upgraded to support such behavior.  Also, when `stopLiquidation` is called, remaining fund in Liquidator can still be liquidated by keepers.  ## Proof of Concept https://github.com/maple-labs/debt-locker/blob/81f55907db7b23d27e839b9f9f73282184ed4744/contracts/DebtLocker.sol#L112 ```     function stopLiquidation() external override {         require(msg.sender == _getPoolDelegate(), \"DL:SL:NOT_PD\");          _liquidator = address(0);          emit LiquidationStopped();     } ```  ## Recommended Mitigation Steps Pull remaining fund in `stopLiquidation`    "}, {"title": "Reuse arithmetic results can save gas ", "html_url": "https://github.com/code-423n4/2021-12-maple-findings/issues/66", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-maple-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/maple-labs/debt-locker/blob/81f55907db7b23d27e839b9f9f73282184ed4744/contracts/DebtLocker.sol#L205-L215  ```solidity function _handleClaimOfRepossessed() internal returns (uint256[7] memory details_) {     ...     details_[0] = recoveredFunds + fundsCaptured;     details_[1] = recoveredFunds > principalToCover ? recoveredFunds - principalToCover : 0;     details_[2] = fundsCaptured;     details_[5] = recoveredFunds > principalToCover ? principalToCover : recoveredFunds;     details_[6] = principalToCover > recoveredFunds ? principalToCover - recoveredFunds : 0;      _fundsToCapture = uint256(0);     _repossessed    = false;      require(ERC20Helper.transfer(fundsAsset, _pool, recoveredFunds + fundsCaptured), \"DL:HCOR:TRANSFER\"); } ```  `recoveredFunds + fundsCaptured` at L215 is calculated before at L205, since it's a checked arithmetic operation with two memory variables, resue the result instead of doing the arithmetic operation again can save gas.  ### Recommendation  Change to:  `require(ERC20Helper.transfer(fundsAsset, _pool, details_[0]), \"DL:HCOR:TRANSFER\");`  "}, {"title": "Avoid unnecessary arithmetic operations can save gas", "html_url": "https://github.com/code-423n4/2021-12-maple-findings/issues/65", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-maple-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-12-perennial/blob/fd7c38823833a51ae0c6ae3856a3d93a7309c0e4/protocol/contracts/product/types/position/PrePosition.sol#L145-L156  ```solidity=145 function computeFee(PrePosition memory self, IProductProvider provider, uint256 toOracleVersion) internal view returns (UFixed18 positionFee) {     Fixed18 oraclePrice = provider.priceAtVersion(toOracleVersion);     Position memory positionDelta = self.openPosition.add(self.closePosition);      (UFixed18 makerNotional, UFixed18 takerNotional) = (         Fixed18Lib.from(positionDelta.maker).mul(oraclePrice).abs(),         Fixed18Lib.from(positionDelta.taker).mul(oraclePrice).abs()     );      positionFee = positionFee.add(makerNotional.mul(provider.safeMakerFee()));     positionFee = positionFee.add(takerNotional.mul(provider.safeTakerFee())); } ```  At L154, `positionFee = positionFee.add(makerNotional.mul(provider.safeMakerFee()));`  can be changed to `positionFee = makerNotional.mul(provider.safeMakerFee());` as `positionFee == 0`.  Futhermore, L154-155 can be combined into:  ```solidity positionFee = makerNotional.mul(provider.safeMakerFee()).add(     takerNotional.mul(provider.safeTakerFee()) ); ```  "}, {"title": "`Liquidator.sol#_locked` Switching between 1, 2 instead of true, false is more gas efficient", "html_url": "https://github.com/code-423n4/2021-12-maple-findings/issues/64", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-maple-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/maple-labs/liquidations/blob/bb09e17b1fac1126ce7734e58c3133be06162590/contracts/Liquidator.sol#L45-L62  ```solidity function liquidatePortion(uint256 swapAmount_, uint256 maxReturnAmount_, bytes calldata data_) external override {     require(!_locked, \"LIQ:LP:LOCKED\");      _locked = true;     ...     _locked = false; } ```  `SSTORE` from false (0) to true (1) (or any non-zero value), the cost is 20000; `SSTORE` from 1 to 2 (or any other non-zero value), the cost is 5000.  By storing the original value once again, a refund is triggered (https://eips.ethereum.org/EIPS/eip-2200).  Since refunds are capped to a percentage of the total transaction's gas, it is best to keep them low, to increase the likelihood of the full refund coming into effect.  Therefore, switching between 1, 2 instead of 0, 1 will be more gas efficient.  See: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/86bd4d73896afcb35a205456e361436701823c7a/contracts/security/ReentrancyGuard.sol#L29-L33  ### Recommendation  Change to:  ```solidity function liquidatePortion(uint256 swapAmount_, uint256 maxReturnAmount_, bytes calldata data_) external override {     require(_locked = 1, \"LIQ:LP:LOCKED\");      _locked = 2;     ...     _locked = 1; } ```  "}, {"title": "Cache external call result in the stack can save gas", "html_url": "https://github.com/code-423n4/2021-12-maple-findings/issues/62", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-maple-findings", "body": "Cache external call result in the stack can save gas"}, {"title": "Consider adding storage gaps to proxied contracts", "html_url": "https://github.com/code-423n4/2021-12-maple-findings/issues/57", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor acknowledged"], "target": "2021-12-maple-findings", "body": "Consider adding storage gaps to proxied contracts"}, {"title": "`makePayment()` Lack of access control allows malicious `lender` to retrieve a large portion of the funds earlier, making the borrower suffer fund loss", "html_url": "https://github.com/code-423n4/2021-12-maple-findings/issues/56", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-12-maple-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/maple-labs/loan/blob/9684bcef06481e493d060974b1777a4517c4e792/contracts/MapleLoan.sol#L86-L93  ```solidity=86 function makePayment(uint256 amount_) external override returns (uint256 principal_, uint256 interest_) {         // The amount specified is an optional amount to be transfer from the caller, as a convenience for EOAs.         require(amount_ == uint256(0) || ERC20Helper.transferFrom(_fundsAsset, msg.sender, address(this), amount_), \"ML:MP:TRANSFER_FROM_FAILED\");          ( principal_, interest_ ) = _makePayment();          emit PaymentMade(principal_, interest_);     } ```  The current implementation allows anyone to call `makePayment()` and repay the loan with `_drawableFunds`.  This makes it possible for a malicious `lender` to call `makePayment()` multiple times right after `fundLoan()` and retrieve most of the funds back immediately, while then `borrower` must continue to make payments or lose the `collateral`.  ### PoC   Given:  - `_collateralRequired` = 1 BTC - `_principalRequested` = 12,000 USDC - `_paymentInterval` = 30 day - `_paymentsRemaining` = 12 - `_gracePeriod` = 1 day - `interestRate_` = 2e17  1. The borrower calls `postCollateral()` and added `1 BTC` as `_collateralAsset`; 2. The lender calls `fundLoan()` and added `12,000 USDC` as  `_fundsAsset`; 3. The lender calls `makePayment()` 11 times, then: - `_drawableFunds` = 96 - `_claimableFunds` = 11903 - `_principal` = 1553  4. The lender calls `_claimFunds()` get 11,903 USDC of `_fundsAsset` back;  Now, for the borrower `1,579 USDC` is due, but only `96 USDC` can be used. The borrower is now forced to pay the interests for the funds that never be used or lose the collateral.  ### Recommendation  Change to:  ```solidity=86 function makePayment(uint256 amount_) external override returns (uint256 principal_, uint256 interest_) {         // The amount specified is an optional amount to be transfer from the caller, as a convenience for EOAs.         require(amount_ == uint256(0) || ERC20Helper.transferFrom(_fundsAsset, msg.sender, address(this), amount_), \"ML:MP:TRANSFER_FROM_FAILED\");          require(msg.sender == _borrower, \"ML:DF:NOT_BORROWER\");              ( principal_, interest_ ) = _makePayment();          emit PaymentMade(principal_, interest_);     } ```  "}, {"title": "Gas Optimization: Use constant instead of block.timestamp", "html_url": "https://github.com/code-423n4/2021-12-maple-findings/issues/55", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-maple-findings", "body": "# Handle  gzeon   # Vulnerability details  ## Impact Use type(uint).max instead of block.timestamp to save gas  https://github.com/maple-labs/liquidations/blob/bb09e17b1fac1126ce7734e58c3133be06162590/contracts/UniswapV2Strategy.sol#L71 https://github.com/maple-labs/liquidations/blob/bb09e17b1fac1126ce7734e58c3133be06162590/contracts/SushiswapStrategy.sol#L71  "}, {"title": "Unchecked return value for `ERC20.approve` call", "html_url": "https://github.com/code-423n4/2021-12-maple-findings/issues/52", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor confirmed"], "target": "2021-12-maple-findings", "body": "# Handle  WatchPug   # Vulnerability details  There are many functions across the codebase that will perform an ERC20.approve() call but does not check the success return value. Some tokens do not revert if the approval failed but return false instead.  Instances include:  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/other/PalmNFTXStakingZap.sol#L167-L167  ```solidity=167 IERC20Upgradeable(address(_pairedToken)).approve(_sushiRouter, type(uint256).max); ```  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/other/PalmNFTXStakingZap.sol#L313  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/other/PalmNFTXStakingZap.sol#L299  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L519  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L538  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L159  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXStakingZap.sol#L398  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXStakingZap.sol#L171  It is usually good to add a require-statement that checks the return value or to use something like `safeApprove`; unless one is sure the given token reverts in case of a failure.  "}, {"title": "Adding unchecked directive can save gas", "html_url": "https://github.com/code-423n4/2021-12-maple-findings/issues/50", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-12-maple-findings", "body": "Adding unchecked directive can save gas"}, {"title": "Unsafe implementation of `fundLoan()` allows attacker to steal collateral from an unfunded loan", "html_url": "https://github.com/code-423n4/2021-12-maple-findings/issues/47", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed"], "target": "2021-12-maple-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/maple-labs/loan/blob/9684bcef06481e493d060974b1777a4517c4e792/contracts/MapleLoanInternals.sol#L257-L273  ```solidity=257     uint256 treasuryFee = (fundsLent_ * ILenderLike(lender_).treasuryFee() * _paymentInterval * _paymentsRemaining) / uint256(365 days * 10_000);      // Transfer delegate fee, if any, to the pool delegate, and decrement drawable funds.     uint256 delegateFee = (fundsLent_ * ILenderLike(lender_).investorFee() * _paymentInterval * _paymentsRemaining) / uint256(365 days * 10_000);      // Drawable funds is the amount funded, minus any fees.     _drawableFunds = fundsLent_ - treasuryFee - delegateFee;      require(         treasuryFee == uint256(0) || ERC20Helper.transfer(_fundsAsset, ILenderLike(lender_).mapleTreasury(), treasuryFee),         \"MLI:FL:T_TRANSFER_FAILED\"     );      require(         delegateFee == uint256(0) || ERC20Helper.transfer(_fundsAsset, ILenderLike(lender_).poolDelegate(), delegateFee),         \"MLI:FL:PD_TRANSFER_FAILED\"         ); ```  In the current implementation, `mapleTreasury`, `poolDelegate` and `treasuryFee` are taken from user input `lender_`, which can be faked by setting up a contract with `ILenderLike` interfaces.  This allows the attacker to set very high fees, making `_drawableFunds` near 0.  Since `mapleTreasury` and `poolDelegate` are also read from `lender_`, `treasuryFee` and `investorFee` can be retrieved back to the attacker.  As a result, the borrower won't get any `_drawableFunds` while also being unable to remove collateral.  ### PoC  Given:  - `_collateralRequired` = 10 BTC - `_principalRequested` = 1,000,000 USDC - `_paymentInterval` = 1 day - `_paymentsRemaining` = 10 - `_gracePeriod` = 1 day  1. Alice (borrower) calls `postCollateral()` and added `10 BTC` as `_collateralAsset`; 2. The attacker calls `fundLoan()` by taking `1,000,000 USDC` of flashloan and using a fake `lender`contract; 3. Alice calls `drawdownFunds()` with any amount > 0 will fail; 4. Alice calls `removeCollateral()` with any amount > 0 will get \"MLI:DF:INSUFFICIENT_COLLATERAL\" error; 5. Unless Alice make payment (which is meaningless), after 2 day, the attacker can call `repossess()` and get `10 BTC`.  ### Recommendation  Consider reading `treasuryFee`, `investorFee`, `mapleTreasury`, `poolDelegate` from an authoritative source instead.  "}, {"title": "Anyone can call `closeLoan()` to close the loan", "html_url": "https://github.com/code-423n4/2021-12-maple-findings/issues/46", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-12-maple-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/maple-labs/loan/blob/9684bcef06481e493d060974b1777a4517c4e792/contracts/MapleLoan.sol#L56-L63  ```solidity=56 function closeLoan(uint256 amount_) external override returns (uint256 principal_, uint256 interest_) {         // The amount specified is an optional amount to be transfer from the caller, as a convenience for EOAs.         require(amount_ == uint256(0) || ERC20Helper.transferFrom(_fundsAsset, msg.sender, address(this), amount_), \"ML:CL:TRANSFER_FROM_FAILED\");          ( principal_, interest_ ) = _closeLoan();          emit LoanClosed(principal_, interest_);     } ```  Based on the context, we believe that the `closeLoan()` should only be called by the `borrower`. However, the current implementation allows anyone to call `closeLoan()` anytime after `fundLoan()`.  If there is no `earlyFee`, this enables a griefing attack, causing the `borrower` and `lender` to abandon this contract and redo everything which costs more gas.  If a platform fee exits, the lender will also suffer fund loss from the platform fee charged in `fundLoan()`.  ### Recommendation  Change to:  ```solidity=56 function closeLoan(uint256 amount_) external override returns (uint256 principal_, uint256 interest_) {         // The amount specified is an optional amount to be transfer from the caller, as a convenience for EOAs.         require(amount_ == uint256(0) || ERC20Helper.transferFrom(_fundsAsset, msg.sender, address(this), amount_), \"ML:CL:TRANSFER_FROM_FAILED\");          require(msg.sender == _borrower, \"ML:DF:NOT_BORROWER\");          ( principal_, interest_ ) = _closeLoan();          emit LoanClosed(principal_, interest_);     } ```  "}, {"title": "Insufficient input validation", "html_url": "https://github.com/code-423n4/2021-12-maple-findings/issues/45", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-12-maple-findings", "body": "Insufficient input validation"}, {"title": "Functionality of liquidation strategies can be broken", "html_url": "https://github.com/code-423n4/2021-12-maple-findings/issues/35", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "sponsor confirmed"], "target": "2021-12-maple-findings", "body": "# Handle  cmichel   # Vulnerability details  The liquidations strategies (`code-423n4/evm-league/56-maple/repo/liquidations-1.0.0-beta.1/contracts/SushiswapStrategy.sol/UniswapStrategy.sol`) check that the current contract balance in the `swap` callback exactly equals the `swapAmount_` parameter from `flashBorrowLiquidation`. (The `swap` is called as a callback from `flashBorrowLiquidation`'s `liquidatePortion`).  ```solidity function swap(     uint256 swapAmount_,     uint256 minReturnAmount_,     address collateralAsset_,     address middleAsset_,     address fundsAsset_,     address profitDestination_ )     external override {     // @audit grifer can send 1 wei. should >=     require(IERC20Like(collateralAsset_).balanceOf(address(this)) == swapAmount_, \"SushiswapStrategy:WRONG_COLLATERAL_AMT\"); } ```  There's a griefing attacker where a keeper tries to liquidate and calls `flashBorrowLiquidation`  but an attacker frontruns this transaction and sends the smallest unit of the `collateralAsset_` to the contract, making this `require` call fail.  ## Impact The important automated liquidation strategies that Keepers might use do not work anymore, no liquidations are done in time, and bad debt can occur.  I'd rate this as high severity as the impact is big and it's also very easy to break this contract entirely with a single transfer: - there's only one strategy contract for many liquidation contracts which means it's important that it's reliable - it's enough to send a few tokens of collateral assets to the contract _once_ to break the `flashBorrowLiquidation/swap` functionality. Because when calling `flashBorrowLiquidation(swapAmount)`, the liquidation contract will always send exactly this `swapAmount` to the strategy, meaning the `IERC20Like(collateralAsset_).balanceOf(address(this)) == swapAmount_` comparison will always fail if there already were tokens in the contract.  ## Recommended Mitigation Steps Use a `IERC20Like(collateralAsset_).balanceOf(address(this)) >= swapAmount_` comparison instead.   "}, {"title": "Same implementation can be registerd for several versions", "html_url": "https://github.com/code-423n4/2021-12-maple-findings/issues/33", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-12-maple-findings", "body": "# Handle  cmichel   # Vulnerability details  It's possible to overwrite the `_versionOf[implementationAddress_]` field through the `proxy-factory-1.0.0-beta.1/contracts/ProxyFactory._registerImplementation` function and register the implementation as several distinct versions.  ```solidity function _registerImplementation(uint256 version_, address implementationAddress_) internal virtual returns (bool success_) {     // Cannot already be registered and cannot be empty implementation.     if (_implementationOf[version_] != address(0) || !_isContract(implementationAddress_)) return false;     _versionOf[implementationAddress_] = version_;     _implementationOf[version_]        = implementationAddress_;      return true; } ```  #### POC - call `_registerImplementation(1, impl)` - call `_registerImplementation(2, impl)`. This does not check that the versions has not already been registered by checking `_versionOf[impl] == 0`. Then the old `_versionOf[impl] = 1` is overwritten with `2`.  ## Recommended Mitigation Steps Check if being able to set a new version for the same contract is desired. If not, add a `_versionOf[impl] == 0` check.  "}, {"title": "Function poolDelegate does not have a named return (DebtLocker.sol)", "html_url": "https://github.com/code-423n4/2021-12-maple-findings/issues/25", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-12-maple-findings", "body": "# Handle  ye0lde   # Vulnerability details  ## Impact  Code clarity or possibly gas savings if all the other named returns are in error.  ## Proof of Concept  Function `poolDelegate` does not have a named return even though its interface definition does. The named return isn't used so the fact that it's missing doesn't matter.  Function `pool` and tens of other functions do have a named return. Most of these named returns are not used and could be deleted. I'm assuming this is a project convention and may be used in off-chain reporting, etc.  https://github.com/maple-labs/debt-locker/blob/81f55907db7b23d27e839b9f9f73282184ed4744/contracts/DebtLocker.sol#L279-L285  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps  Add a named return to function `poolDelegate' for consistency/reporting.  Or if all those other named returns are in error, remove the unused named returns and kick this ticket over to gas optimization.    "}, {"title": "\"> 0\" is less efficient than \"!= 0\" for unsigned integers", "html_url": "https://github.com/code-423n4/2021-12-maple-findings/issues/24", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-maple-findings", "body": "# Handle  WatchPug   # Vulnerability details  It is cheaper to use `!= 0` than `> 0` for uint256.  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/RocketJoeStaking.sol#L101-L101  ```solidity if (user.amount > 0) { ```  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/RocketJoeFactory.sol#L119-L119  ```solidity _tokenAmount > 0, ```  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/LaunchEvent.sol#L338-L338  ```solidity if (rJoeNeeded > 0) { ```  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/LaunchEvent.sol#L355-L355  ```solidity require(_amount > 0, \"LaunchEvent: invalid withdraw amount\"); ```  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/LaunchEvent.sol#L370-L370  ```solidity if (feeAmount > 0) { ```  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/LaunchEvent.sol#L455-L455  ```solidity if (tokenReserve > 0) { ```  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/LaunchEvent.sol#L537-L537  ```solidity if (excessToken > 0) { ```  "}, {"title": "Floating pragma", "html_url": "https://github.com/code-423n4/2021-12-maple-findings/issues/23", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor confirmed"], "target": "2021-12-maple-findings", "body": "# Handle  saian   # Vulnerability details  ## Impact  Contracts should be deployed with the same version of compilers with which it was tested,  Using a unlocked pragma might result in contract being deployed with a version it was not tested with, and might result in bugs and unwanted behaviour.   ## Proof of Concept  Contracts in below repositories :     maple-labs/debt-locker     maple-labs/erc20-helper     maple-labs/loan     maple-labs/maple-proxy-factory     maple-labs/proxy-factory   ## Tools Used  Manual Analysis  ## Recommended Mitigation Steps  Lock the pragma version, it is advised not to use unlocked pragma in production.  "}, {"title": "Typos", "html_url": "https://github.com/code-423n4/2021-12-maple-findings/issues/22", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-12-maple-findings", "body": "Typos"}, {"title": "Must approve 0 first", "html_url": "https://github.com/code-423n4/2021-12-maple-findings/issues/11", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-12-maple-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Lock.sol#L117   # Vulnerability details  ## Impact Some tokens (like USDT) do not work when changing the allowance from an existing non-zero allowance value.They must first be approved by zero and then the actual allowance must be approved.   ## Proof of Concept https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Lock.sol#L117  ```solidity     function claimGovFees() public {         address[] memory assets = bondNFT.getAssets();          for (uint i=0; i < assets.length; i++) {             uint balanceBefore = IERC20(assets[i]).balanceOf(address(this));             IGovNFT(govNFT).claim(assets[i]);             uint balanceAfter = IERC20(assets[i]).balanceOf(address(this));             IERC20(assets[i]).approve(address(bondNFT), type(uint256).max);// @audit this could fail always with some tokens,              bondNFT.distribute(assets[i], balanceAfter - balanceBefore);         }     } ```  ## Tools Used manual revision  ## Recommended Mitigation Steps    Add an approve(0) before approving; ```     function claimGovFees() public {         address[] memory assets = bondNFT.getAssets();          for (uint i=0; i < assets.length; i++) {             uint balanceBefore = IERC20(assets[i]).balanceOf(address(this));             IGovNFT(govNFT).claim(assets[i]);             uint balanceAfter = IERC20(assets[i]).balanceOf(address(this));             IERC20(assets[i]).approve(address(bondNFT), 0);             IERC20(assets[i]).approve(address(bondNFT), type(uint256).max);             bondNFT.distribute(assets[i], balanceAfter - balanceBefore);         }   } ```      "}, {"title": "Open TODOs", "html_url": "https://github.com/code-423n4/2021-12-maple-findings/issues/10", "labels": ["bug", "question", "0 (Non-critical)", "disagree with severity", "sponsor confirmed"], "target": "2021-12-maple-findings", "body": "Open TODOs"}, {"title": "State variables that could be set immutable", "html_url": "https://github.com/code-423n4/2021-12-maple-findings/issues/7", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-maple-findings", "body": "# Handle  robee   # Vulnerability details  In the following files there are state variables that could be set immutable to save gas.  The list of format <solidity file>, <state variable name that could be immutable>:           basket in RebalanceManagerV2.sol         uniSwapLikeRouter in SingleNativeTokenExit.sol         INTERMEDIATE_TOKEN in SingleNativeTokenExit.sol         uniSwapLikeRouter in SingleNativeTokenExitV2.sol         INTERMEDIATE_TOKEN in SingleNativeTokenExitV2.sol         uniSwapLikeRouter in SingleTokenJoin.sol         INTERMEDIATE_TOKEN in SingleTokenJoin.sol         uniSwapLikeRouter in SingleTokenJoinV2.sol         INTERMEDIATE_TOKEN in SingleTokenJoinV2.sol         predicateProxy in MintableERC20.sol         underlying in PolygonERC20Wrapper.sol         childChainManager in PolygonERC20Wrapper.sol  "}, {"title": "Storage double reading. Could save SLOAD", "html_url": "https://github.com/code-423n4/2021-12-maple-findings/issues/4", "labels": ["bug", "duplicate", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-maple-findings", "body": "# Handle  robee   # Vulnerability details  Reading a storage variable is gas costly (SLOAD). In cases of multiple read of a storage variable in the same scope, caching the first read (i.e saving as a local variable) can save gas and decrease the  overall gas uses. The following is a list of functions and the storage variables that you read twice:           CDSTemplate.sol: parameters.getLockup is read twice in withdraw         Factory.sol: registry is read twice in createMarket         IndexTemplate.sol: totalAllocPoint is read twice in set         IndexTemplate.sol: MAGIC_SCALE_1E6 is read twice in withdrawable         PoolTemplate.sol: parameters.getLockup is read twice in withdraw         PoolTemplate.sol: lockedAmount is read twice in utilizationRate         PoolTemplate.sol: MAGIC_SCALE_1E6 is read twice in allocateCredit         PoolTemplate.sol: MAGIC_SCALE_1E6 is read twice in withdrawCredit         PoolTemplate.sol: MAGIC_SCALE_1E6 is read twice in insure         PoolTemplate.sol: MAGIC_SCALE_1E6 is read twice in resume         BondingPremium.sol: k is read twice in getCurrentPremiumRate         BondingPremium.sol: k is read twice in getPremiumRate         BondingPremium.sol: c is read twice in getPremiumRate         BondingPremium.sol: b is read twice in getCurrentPremiumRate         BondingPremium.sol: b is read twice in getPremiumRate         BondingPremium.sol: T_1 is read twice in getCurrentPremiumRate         BondingPremium.sol: T_1 is read twice in getPremiumRate         BondingPremium.sol: BASE is read twice in getCurrentPremiumRate         BondingPremium.sol: BASE is read twice in getPremiumRate         BondingPremium.sol: BASE_x2 is read twice in getCurrentPremiumRate         BondingPremium.sol: BASE_x2 is read twice in getPremiumRate         Vault.sol: token is read twice in repayDebt         Vault.sol: token is read twice in utilize         Vault.sol: token is read twice in withdrawRedundant         Vault.sol: totalAttributions is read twice in attributionValue         Vault.sol: balance is read twice in valueAll         Vault.sol: balance is read twice in withdrawRedundant   "}, {"title": "Short the following require messages", "html_url": "https://github.com/code-423n4/2021-12-maple-findings/issues/3", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-maple-findings", "body": "# Handle  robee   # Vulnerability details  The following require messages are of length more than 32 and we think are short enough to short them into exactly 32 characters such that it will be placed in one slot of memory and the require  function will cost less gas.  The list:           Solidity file: ActivePool.sol, In line 252, Require message length to shorten: 35, The message: ActivePool: Caller is not whitelist         Solidity file: BorrowerOperations.sol, In line 215, Require message length to shorten: 39, The message: BOps: colls and amounts length mismatch         Solidity file: BorrowerOperations.sol, In line 874, Require message length to shorten: 33, The message: BOps: Collateral not in whitelist         Solidity file: CollSurplusPool.sol, In line 167, Require message length to shorten: 40, The message: CollSurplusPool: Caller is not Whitelist         Solidity file: DefaultPool.sol, In line 122, Require message length to shorten: 38, The message: DefaultPool: sending collateral failed         Solidity file: DefaultPool.sol, In line 167, Require message length to shorten: 36, The message: DefaultPool: Caller is not whitelist         Solidity file: LiquitySafeMath128.sol, In line 10, Require message length to shorten: 37, The message: LiquitySafeMath128: addition overflow         Solidity file: LiquitySafeMath128.sol, In line 16, Require message length to shorten: 40, The message: LiquitySafeMath128: subtraction overflow         Solidity file: SafeMath.sol, In line 87, Require message length to shorten: 33, The message: SafeMath: multiplication overflow         Solidity file: Address.sol, In line 115, Require message length to shorten: 38, The message: Address: insufficient balance for call         Solidity file: Address.sol, In line 140, Require message length to shorten: 36, The message: Address: static call to non-contract         Solidity file: SortedTroves.sol, In line 131, Require message length to shorten: 34, The message: SortedTroves: ICR must be positive         Solidity file: SortedTroves.sol, In line 230, Require message length to shorten: 34, The message: SortedTroves: ICR must be positive         Solidity file: StabilityPool.sol, In line 1076, Require message length to shorten: 39, The message: StabilityPool: Caller is not ActivePool         Solidity file: StabilityPool.sol, In line 1095, Require message length to shorten: 40, The message: StabilityPool: User must have no deposit         Solidity file: StabilityPool.sol, In line 1099, Require message length to shorten: 38, The message: StabilityPool: Amount must be non-zero         Solidity file: StabilityPool.sol, In line 1138, Require message length to shorten: 36, The message: DefaultPool: Caller is not whitelist         Solidity file: SortedTrovesTester.sol, In line 23, Require message length to shorten: 34, The message: SortedTroves: ICR must be positive         Solidity file: TroveManagerLiquidations.sol, In line 180, Require message length to shorten: 34, The message: TroveManager: nothing to liquidate         Solidity file: TroveManagerRedemptions.sol, In line 520, Require message length to shorten: 34, The message: must be non zero redemption amount         Solidity file: CommunityIssuance.sol, In line 131, Require message length to shorten: 35, The message: CommunityIssuance: caller is not SP         Solidity file: YETIToken.sol, In line 198, Require message length to shorten: 36, The message: YETI: transfer from the zero address         Solidity file: YETIToken.sol, In line 222, Require message length to shorten: 39, The message: YETI: caller must be the SYETI contract         Solidity file: YUSDToken.sol, In line 294, Require message length to shorten: 37, The message: YUSD: Caller is not the StabilityPool  "}, {"title": "`Timelock` Struct Packing in `Vesting.sol`", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/307", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  leastwood   # Vulnerability details  ## Impact  The `Timelock` struct is used to reference the `releaseTimestamp` and vested `amount` for each vesting. These values can likely be safely stored as `uint64` and `uint192` values respectively, enabling the struct to be stored within a single slot instead of two slots.  ## Proof of Concept  https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L32-L35  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider updating `releaseTimestamp` to `uint64` and `amount` to `uint192` within the `Timelock` struct. It might be worthwhile performing sanity checks when storing these values by using OpenZeppelin's safe math and safe cast libraries.  "}, {"title": "Incorrect `require` Statement in `Vesting.claim()`", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/306", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  leastwood   # Vulnerability details  ## Impact  The `claim()` function asserts that the claimable amount is strictly less than `benTotal` for a given user. However, this does not take into account previously claimed tokens, hence the `require` does not accurately depict its intended behaviour.  ## Proof of Concept  https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L197  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider updating this `require` statement to account for already claimed tokens. This could look like the following: `require(amount.add(benClaimed[msg.sender]) <= benTotal[msg.sender], \"Cannot withdraw more than total vested amount\");`  "}, {"title": "Validations", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/301", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "Validations"}, {"title": "_recordBurn _payer", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/300", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact function _recordBurn does not really need this parameter of address _payer as it is always equal to msg.sender.   Consider replacing: function _recordBurn(address _payer, ... emit Burn(_payer, ...  with: function _recordBurn(... emit Burn(msg.sender, ...   "}, {"title": "Useless nonReentrant", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/293", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact functions validate and modifyInvestor do not need nonReentrant modifier as they do not execute any external calls where you can hook up to re-enter.   "}, {"title": "Optimize structs", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/290", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact Member total_tokens in both structs Airdrop and Investors is practically not used and is a duplicate of the amount so you can remove it to save some storage. Also, gas efficiency can be improved by tightly packing the struct. Struct variables are stored in 32 bytes each so you can group smaller types to occupy less storage, e.g. airdropBalances which are later translated to the amount in Airdrop struct (10**18) can be stored in a smaller version of uint as we know all the exact values at compile time.   "}, {"title": "Itteration over all the timelocks when revoking the user", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/285", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact When revoking the user, there is no need to iterrate over all his timelocks again and calculate the total amount as it should already be stored in a benTotal[_addr] mapping:   uint256 locked = 0;   for (uint256 i = 0; i < timelocks[_addr].length; i++) {       locked = locked.add(timelocks[_addr][i].amount);   }   "}, {"title": "function claim optimizations", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/283", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact function claim can save gas and eliminate duplicate storage access and math operations by caching claimableAmount and re-using it later when setting the benClaimed.   before:   uint256 amount = _claimableAmount(msg.sender).sub(benClaimed[msg.sender]);   ...   benClaimed[msg.sender] = benClaimed[msg.sender].add(amount);  after:   uint256 claimableAmount = _claimableAmount(msg.sender);   uint256 amount = claimableAmount.sub(benClaimed[msg.sender]);   ...   benClaimed[msg.sender] = claimableAmount;  Also, it looks strange that in function revoke the amount is checked with 'assert': assert(amount <= benTotal[_addr]); but in function claim 'require' is used: require(amount <= benTotal[msg.sender], \"Cannot withdraw more than total vested amount\");  In both places probably 'assert' should be used as it is checking a scenario that should never happen under normal circumstances.   "}, {"title": "modifyInvestor does not need to check if _investor is not empty", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/281", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact This check in function modifyInvestor is not neccessary:   require(_investor != address(0), \"Invalid old address\");  as empty address cannot be added in function addInvestor and later this check will fail:   require(investors[_investor].amount != 0);  "}, {"title": "Usage of assert", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/279", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact Contracts use assert() instead of require() in multiple places. Assert is recommended to be used to check for internal errors, or to check invariants.  In your case, I think these validations could better use 'require' as they are likely to be triggered: assert(claimable > 0); assert(airdrop[msg.sender].amount - claimable != 0); assert(block.timestamp - startEpochTime <= RATE_TIME); assert(block.timestamp - initTime >= YEAR * 5);  A similar issue was submitted in a previous contest and was assigned a severity of low: https://github.com/code-423n4/2021-06-realitycards-findings/issues/83  ## Recommended Mitigation Steps Consider replacing 'assert' with 'require' in the cases mentioned above.  "}, {"title": "NFT flashloans can bypass sale constraints", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/276", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2021-11-bootfinance-findings", "body": "NFT flashloans can bypass sale constraints"}, {"title": "burnAddress is not actually meant to burn anything", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/275", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact burnAddress is hardcoded to 0x03Df4ADDfB568b338f6a0266f30458045bbEFbF2. I see this address is a Gnosis safe multisig. So the eth is not actually burned even though I expected the burn by looking at the code. This confusion happens because the codebase was adopted from Vader protocol but with no actual intention of burning.  ## Recommended Mitigation Steps To reduce this confusion and improve the readability of the codebase you should either rename the burn variables and functions or leave it as it is but comment and document the actual mechanics of the sale.   "}, {"title": "_recordBurn does not handle 0 _eth appropriately", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/274", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "_recordBurn does not handle 0 _eth appropriately"}, {"title": "payable vest", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/273", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact There is no reason for the function vest to be 'payable' as it does not handle ether in any way and there is no way to rescue it later in case someone accidentally sends it.  ## Recommended Mitigation Steps Remove 'payable' from the vest function.  "}, {"title": "Adding unchecked directive can save gas", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/261", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "Adding unchecked directive can save gas"}, {"title": "Packing of state variable ", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/258", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  JMukesh   # Vulnerability details  ## Impact bool _iskilled  state variable can be packed with one of the address state variable like {token , owner}  which will save on slot of memory  ## Proof of Concept  https://github.com/code-423n4/2021-11-bootfinance/blob/b4ebd0a5ebcbc24f3d15836cdb9759243fc85868/core-contracts/contracts/sol/BTCPoolDelegator.sol#L55  https://github.com/code-423n4/2021-11-bootfinance/blob/b4ebd0a5ebcbc24f3d15836cdb9759243fc85868/core-contracts/contracts/sol/USDPoolDelegator.sol#L51   ## Tools Used  manual review  ## Recommended Mitigation Steps   "}, {"title": "use of floating pragma", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/257", "labels": ["bug", "0 (Non-critical)"], "target": "2021-11-bootfinance-findings", "body": "use of floating pragma"}, {"title": "wrong operator used in checking the fees, adminfee, withdrawfee", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/254", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  JMukesh   # Vulnerability details  ## Impact wrong operator used in checking the fees, adminfee, withdrawfee instead of      require(_fee < SwapUtils.MAX_SWAP_FEE, \"_fee exceeds maximum\");       _fee < = SwapUtils.Max_Swap_Fee , should be there same with adminfee & withdrawfee becuase in using <= it does not exceed the max value     ## Proof of Concept https://github.com/code-423n4/2021-11-bootfinance/blob/b4ebd0a5ebcbc24f3d15836cdb9759243fc85868/customswap/contracts/Swap.sol#L192   ## Tools Used manual review  ## Recommended Mitigation Steps use correct operator to check the value  "}, {"title": "`SwapUtils.sol` Wrong implementation", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/252", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  WatchPug   # Vulnerability details  Based on the context, the `tokenPrecisionMultipliers` used in price calculation should be calculated in realtime based on `initialTargetPrice`, `futureTargetPrice`, `futureTargetPriceTime` and current time, just like `getA()` and `getA2()`.  However, in the current implementation, `tokenPrecisionMultipliers` used in price calculation is the stored value, it will only be changed when the owner called `rampTargetPrice()` and `stopRampTargetPrice()`.  As a result, the `targetPrice` set by the owner will not be effective until another `targetPrice` is being set or `stopRampTargetPrice()` is called.  ### Recommendation  Consider adding `Swap.targetPrice` and changing the `_xp()` at L661 from:  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L661-L667  ```solidity=661 function _xp(Swap storage self, uint256[] memory balances)     internal     view     returns (uint256[] memory) {     return _xp(balances, self.tokenPrecisionMultipliers); } ```  To:  ```solidity=661 function _xp(Swap storage self, uint256[] memory balances)     internal     view     returns (uint256[] memory) {     uint256[2] memory tokenPrecisionMultipliers = self.tokenPrecisionMultipliers;     tokenPrecisionMultipliers[0] = self.targetPrice.originalPrecisionMultipliers[0].mul(_getTargetPricePrecise(self)).div(WEI_UNIT)     return _xp(balances, tokenPrecisionMultipliers); } ```  "}, {"title": "`Vesting.sol#calcClaimableAmount()` Claimed amount should be excluded in claimable amount", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/248", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-11-bootfinance-findings", "body": "`Vesting.sol#calcClaimableAmount()` Claimed amount should be excluded in claimable amount"}, {"title": "Missing error messages in require statements", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/247", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "Missing error messages in require statements"}, {"title": "`Vesting.sol#_claimableAmount()` Remove unnecessary storage variables can save gas", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/246", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/vesting/contracts/Vesting.sol#L184-L184  ```solidity=184     benVested[_addr][1] = partial_sum; ```  `benVested[_addr][1]` is never used in the contract and the sum of partial claimable vesting is changing every second. Removing it can save gas.  "}, {"title": "Cache external call results can save gas", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/242", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  WatchPug   # Vulnerability details  Every call to an external contract costs a decent amount of gas. For optimization of gas usage, external call results should be cached if they are being used for more than one time.  For example:  `factory.getPair(wavaxAddress, tokenAddress)` and `factory.getPair(tokenAddress, wavaxAddress)` in `LaunchEvent#createPair()`  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/LaunchEvent.sol#L377-L435  ```solidity function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {     // ...     require(         factory.getPair(wavaxAddress, tokenAddress) == address(0) ||             IJoePair(                 IJoeFactory(factory).getPair(wavaxAddress, tokenAddress)             ).totalSupply() ==             0,         \"LaunchEvent: liquid pair already exists\"     );     // ...     pair = IJoePair(factory.getPair(tokenAddress, wavaxAddress));     // ... } ```  note: `factory.getPair(a, b)` \u4e0e  `factory.getPair(b, a)` \u76f8\u540c, see  [code at github](https://github.com/traderjoe-xyz/joe-core/blob/5c2ca96c3835e7f2660f2904a1224bb7c8f3b7a7/contracts/traderjoe/JoeFactory.sol#L41-L42) or [code at avascan](https://avascan.info/blockchain/c/address/0x9Ad6C38BE94206cA50bb0d90783181662f0Cfa10/contract#:~:text=getPair%5Btoken1%5D%5Btoken0%5D%20%3D%20pair%3B%20//%20populate%20mapping%20in%20the%20reverse%20direction)  ```solidity getPair[token0][token1] = pair; getPair[token1][token0] = pair; // populate mapping in the reverse direction ```  `IJoeFactory(factory).getPair(_token, wavax)` in `RocketJoeFactory#createRJLaunchEvent()`  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/RocketJoeFactory.sol#L122-L128  ```solidity require(     IJoeFactory(factory).getPair(_token, wavax) == address(0) ||         IJoePair(IJoeFactory(factory).getPair(_token, wavax))             .totalSupply() ==         0,     \"RJFactory: liquid pair already exists\" ); ```   `token.decimals()` in `LaunchEvent#createPair()`  https://github.com/code-423n4/2022-01-trader-joe/blob/a1579f6453bc4bf9fb0db9c627beaa41135438ed/contracts/LaunchEvent.sol#L395-L405  ```solidity if (     floorPrice > (wavaxReserve * 10**token.decimals()) / tokenAllocated ) {     tokenAllocated = (wavaxReserve * 10**token.decimals()) / floorPrice;     // ... } ```  "}, {"title": "Use literal `2` instead of read from storage for `pooledTokens.length` can save gas", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/241", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  WatchPug   # Vulnerability details  The current design requires the number of pooledTokens to be 2, therefore `pooledTokens.length` can be replaced with literal `2` to save ~100 gas from each storage read (`SLOAD` after Berlin).  Instances include:  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L1027-L1027  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L1068-L1068  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L1082-L1082  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L1169-L1169  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L1230-L1230  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L1332-L1334  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L1369-L1369  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L1421-L1421  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L1447-L1447  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L1471-L1471  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/Swap.sol#L336-L336  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/Swap.sol#L295-L295  "}, {"title": "`SwapUtils.sol#getD()` Remove unnecessary variable and internal call can make the code simpler and save some gas", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/238", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L620-L623  ```solidity=620 function getD(Swap storage self) internal view returns (uint256) {     uint256 a = determineA(self, _xp(self));            // determine the correct A     return getD(_xp(self), a); } ```  `a` is unnecessary as it's being used only once. The result of `_xp(self)` can be cached to avoid calling it twice.  ### Recommendation  Change to:  ```solidity=620 function getD(Swap storage self) internal view returns (uint256) {     uint256[] memory xp = _xp(self);     return getD(xp, determineA(self, xp)); } ```  "}, {"title": "`SwapUtils.sol` Inconsistent parameter value of `lpTokenSupply` among `Liquidity` related events", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/237", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  WatchPug   # Vulnerability details  There are 4 events with the parameter `lpTokenSupply` in `SwapUtils.sol`, but the value of `lpTokenSupply` is not consistent.  For the event `RemoveLiquidityOne`, `lpTokenSupply` is post burn:  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L1349-L1349  ```solidity=1349 emit RemoveLiquidity(msg.sender, amounts, self.lpToken.totalSupply()); ```  For the event `RemoveLiquidityOne`, `lpTokenSupply` is pre burn:  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L1368-L1368  For the event `removeLiquidityImbalance`, `lpTokenSupply` is post burn:  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L1475-L1481  For the event `AddLiquidity`, `lpTokenSupply` is post mint:  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L1261-L1267  ### Recommendation  Given that 3 out of the 4 events are using updated `totalSupply` as `lpTokenSupply`, consider changing `RemoveLiquidityOne` to post burn `totalSupply`.  "}, {"title": "External call can be done later to save gas", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/236", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L1362-L1375  ```solidity=1362 function removeLiquidityOneToken(     Swap storage self,     uint256 tokenAmount,     uint8 tokenIndex,     uint256 minAmount ) external returns (uint256) {     uint256 totalSupply = self.lpToken.totalSupply();     uint256 numTokens = self.pooledTokens.length;     require(         tokenAmount <= self.lpToken.balanceOf(msg.sender),         \">LP.balanceOf\"     );     require(tokenIndex < numTokens, \"Token not found\");  ```  The external call to get the `totalSupply` of the `lpToken` can be done later to avoid unnecessary code execution when the check of `tokenAmount` and `tokenIndex` does not pass.  "}, {"title": "`SwapUtils.sol#getYD()` Remove redundant code can save gas", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/233", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  WatchPug   # Vulnerability details  `getYD()` already `require(tokenIndex < numTokens, \"...\")`, so the check in `getYDC()` is redundant.  Removing it will make the code simpler and save some gas.  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L477-L502  ```solidity=477 function getYDC(     Swap storage self,     uint256 a,     uint8 tokenIndex,     uint256[] memory xp,     uint256 d ) internal view returns (uint256) {     uint256 numTokens = xp.length;     require(tokenIndex < numTokens, \"Token not found\");      // calculate y     uint256 y = getYD(a, tokenIndex, xp, d);     // ... } ```  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L522-L557 ```solidity=522 function getYD(     uint256 a,     uint8 tokenIndex,     uint256[] memory xp,     uint256 d ) internal pure returns (uint256) {     uint256 numTokens = xp.length;     require(tokenIndex < numTokens, \"Token not found\");     // ... } ```   ### Recommendation  Remove the redundant code.  "}, {"title": "Typos", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/230", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "Typos"}, {"title": "Code Style: consistency", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/228", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "Code Style: consistency"}, {"title": "Remove unnecessary variables can save some gas", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/223", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  WatchPug   # Vulnerability details  `transferredDx` is unnecessary, it can be replaced with `dx`.  https://github.com/code-423n4/2021-11-bootfinance/blob/f102ee73eb320532c5a7c1e833f225c479577e39/customswap/contracts/SwapUtils.sol#L1098-L1123  ```solidity=1098{1119-1123} function swap(     Swap storage self,     uint8 tokenIndexFrom,     uint8 tokenIndexTo,     uint256 dx,     uint256 minDy ) external returns (uint256) {     require(         dx <= self.pooledTokens[tokenIndexFrom].balanceOf(msg.sender),         \"Cannot swap more than you own\"     );      // Transfer tokens first to see if a fee was charged on transfer     uint256 beforeBalance =         self.pooledTokens[tokenIndexFrom].balanceOf(address(this));     self.pooledTokens[tokenIndexFrom].safeTransferFrom(         msg.sender,         address(this),         dx     );      // Use the actual transferred amount for AMM math     uint256 transferredDx =         self.pooledTokens[tokenIndexFrom].balanceOf(address(this)).sub(             beforeBalance         );     // ... ```  ### Recommendation  Change to:  ```solidity // Use the actual transferred amount for AMM math uint256 dx =     self.pooledTokens[tokenIndexFrom].balanceOf(address(this)).sub(         beforeBalance     ); // ... ```  "}, {"title": "Tokens with decimals larger than 18 are not supported", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/221", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-11-bootfinance-findings", "body": "Tokens with decimals larger than 18 are not supported"}, {"title": "Gas: Unnecessary msg.sender != 0 check", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/218", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  cmichel   # Vulnerability details  The `AirdropDistribution.claimExact` and `InvestorDistribution.claimExact` functions check that `msg.sender != address(0)`.  This is always true, nobody has the private key of the zero address and it cannot be spoofed. This check can be removed.  "}, {"title": "Gas: Unnecessary length check in `Swap.constructor`", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/217", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  cmichel   # Vulnerability details  The `Swap.constructor` checks if both arrays `_pooledTokens` and `decimals` are of length two, but then does another check if these arrays have the same length.  ```solidity require(     _pooledTokens.length == decimals.length,     \"_pooledTokens decimals mismatch\" ); ```  This check will always be true as it has been checked that both arrays are of length two.  "}, {"title": "Swaps are not split when trade crosses target price", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/216", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  cmichel   # Vulnerability details  The protocol uses two amplifier values A1 and A2 for the swap, depending on the target price, see `SwapUtils.determineA`. The swap curve is therefore a join of two different curves at the target price. When doing a trade that crosses the target price, it should first perform the trade partially with A1 up to the target price, and then the rest of the trade order with A2.  However, the `SwapUtils.swap / _calculateSwap` function does not do this, it only uses the \"new A\", see `getYC` step 5.  ```solidity // 5. Check if we switched A's during the swap if (aNew == a){     // We have used the correct A     return y; } else {    // We have switched A's, do it again with the new A     return getY(self, tokenIndexFrom, tokenIndexTo, x, xp, aNew, d); } ```  ## Impact Trades that cross the target price and would lead to a new amplifier being used are not split up and use the new amplifier for the _entire trade_. This can lead to a worse (better) average execution price than manually splitting the trade into two transactions, first up to but below the target price, and a second one with the rest of the trader order size, using both A1 and A2 values.  In the worst case, it could even be possible to make the entire trade with one amplifier and then sell the swap result again using the other amplifier making a profit.  ## Recommended Mitigation Steps Trades that lead to a change in amplifier value need to be split up into two trades using both amplifiers to correctly calculate the swap result.   "}, {"title": "can withdraw shares on behalf of anyone", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/215", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-11-bootfinance-findings", "body": "can withdraw shares on behalf of anyone"}, {"title": "`BasicSale` uses inaccurate `secondsPerDay` value", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/211", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  cmichel   # Vulnerability details  The `BasicSale` contract uses a `secondsPerDay` value of `84200` but one day has `86400` seconds.  ## Impact The `secondsPerDay` does not reflect seconds per day.  ## Recommended Mitigation Steps Change the value.  "}, {"title": "`BasicSale` has unused ERC20 code", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/210", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  cmichel   # Vulnerability details  The `BasicSale` contract includes ERC20 code like `_balances`, `_allowances` storage variables and `Transfer`, `Approval` events. This code is never used.  ## Impact Unused code can hint at programming or architectural errors.  ## Recommended Mitigation Steps Use it or remove it.  "}, {"title": "# Missing parameter validation", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/209", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  cmichel   # Vulnerability details  Some parameters of functions are not checked for invalid values: - `Swap.setAdminFee`: The `newAdminFee` should be validated the same way as in the constructor - `Swap.setSwapFee`: The `newSwapFee` should be validated the same way as in the constructor - `Swap.setDefaultWithdrawFee`: The `newWithdrawFee` should be validated the same way as in the constructor  ## Impact Wrong user input or wallets defaulting to the zero addresses for a missing input can lead to the contract needing to redeploy or wasted gas.  ## Recommended Mitigation Steps Validate the parameters.  "}, {"title": "Stop ramp target price would create huge arbitrage space.", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/208", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  jonah1005   # Vulnerability details  # Stop ramp target price would create huge arbitrage space. ## Impact `stopRampTargetPrice` would set the `tokenPrecisionMultipliers` to `originalPrecisionMultipliers[0].mul(currentTargetPrice).div(WEI_UNIT);` Once the `tokenPrecisionMultipliers` is changed, the price in the AMM pool would change. Arbitrager can sandwich `stopRampTargetPrice` to gain profit.  Assume the decision is made in the DAO, an attacker can set up the bot once the proposal to `stopRampTargetPrice` has passed. I consider this is a medium-risk issue.  ## Proof of Concept The `precisionMultiplier` is set here: [Swap.sol#L661-L666](https://github.com/code-423n4/2021-11-bootfinance/blob/main/customswap/contracts/Swap.sol#L661-L666)  We can set up a mockSwap with extra `setPrecisionMultiplier` to check the issue. ```solidity     function setPrecisionMultiplier(uint256 multipliers) external {         swapStorage.tokenPrecisionMultipliers[0] = multipliers;      } ```  ```python print(swap.functions.getVirtualPrice().call()) swap.functions.setPrecisionMultiplier(2).transact() print(swap.functions.getVirtualPrice().call())  # output log: #     1000000000000000000 #     1499889859738721606 ``` ## Tools Used None ## Recommended Mitigation Steps Dealing with the target price with multiplier precision seems clever as we can reuse most of the existing code. However, the precision multiplier should be an immutable parameter. Changing it after the pool is setup would create multiple issues. This function could be implemented in a safer way IMHO.  A quick fix I would come up with is to ramp the `tokenPrecisionMultipliers` as the `aPrecise` is ramped. As the `tokenPrecision` is slowly increased/decreased, the arbitrage space would be slower and the profit would (probably) distribute evenly to lpers.  Please refer to `_getAPreceise`'s implementation [SwapUtils.sol#L227-L250](https://github.com/code-423n4/2021-11-bootfinance/blob/main/customswap/contracts/SwapUtils.sol#L227-L250)  "}, {"title": "SwapUtils's getD, getY, getYD functions do repetitive calculations of contant expression within the cycles", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/207", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  hyh   # Vulnerability details  ## Impact  Gas overspending due to excessive operations  ## Proof of Concept  getD, getY, getYD functions calculate mul(d).div(xp[i].mul(numTokens) within the token cycles https://github.com/code-423n4/2021-11-bootfinance/blob/main/customswap/contracts/SwapUtils.sol#L538 https://github.com/code-423n4/2021-11-bootfinance/blob/main/customswap/contracts/SwapUtils.sol#L588 https://github.com/code-423n4/2021-11-bootfinance/blob/main/customswap/contracts/SwapUtils.sol#L861  d, numTokens are constant there, so the divisions are redundant.  ## Recommended Mitigation Steps  Introduce (d / numTokens) variable and simplify the multiplication  Now: uint256 c = d; ... for (uint256 i = 0; i < numTokens; i++) {   if (i != tokenIndex) {     s = s.add(xp[i]);     c = c.mul(d).div(xp[i].mul(numTokens));  To be: uint256 c = d; uint256 d_num = d.div(numTokens); ... for (uint256 i = 0; i < numTokens; i++) {   if (i != tokenIndex) {     s = s.add(xp[i]);     c = c.mul(d_num).div(xp[i]);  "}, {"title": "revoke() Does Not Check Zero Address for _addr", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/202", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  Meta0xNull   # Vulnerability details  ## Impact revoke() Does Not Check Zero Address for _addr  ## Proof of Concept https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L104-L105  more...  ## Tools Used Manual Review  ## Recommended Mitigation Steps Check _addr for Zero Address  "}, {"title": "addInvestor() Does Not Check Availability of investors_supply", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/201", "labels": ["bug", "3 (High Risk)", "sponsor acknowledged"], "target": "2021-11-bootfinance-findings", "body": "addInvestor() Does Not Check Availability of investors_supply"}, {"title": "SwapUtils.calculateTokenAmount does repetitive checks of static condition", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/200", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  hyh   # Vulnerability details  ## Impact  Gas overspending due to excessive operations  ## Proof of Concept  SwapUtils.calculateTokenAmount's 'deposit' bool variable is checked on each iteration, while one check is enough https://github.com/code-423n4/2021-11-bootfinance/blob/main/customswap/contracts/SwapUtils.sol#L1031  ## Recommended Mitigation Steps  It's recommended to separate the cycles:  Now: for (uint256 i = 0; i < numTokens; i++) {   if (deposit) {     balances1[i] = balances1[i].add(amounts[i]);   } else {     balances1[i] = balances1[i].sub(       amounts[i],       \"Cannot withdraw more than available\"     );   } }  To be: if (deposit) {   for (uint256 i = 0; i < numTokens; i++) {    balances1[i] = balances1[i].add(amounts[i]);   } } else {   for (uint256 i = 0; i < numTokens; i++) {    balances1[i] = balances1[i].sub(      amounts[i],      \"Cannot withdraw more than available\"    );   } }   "}, {"title": "SwapUtils's addLiquidity does multiple LP token total supply calls", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/197", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  hyh   # Vulnerability details  ## Impact  Gas overspending due to excessive external function calls  ## Proof of Concept  SwapUtils's addLiquidity function calls LP token totalSupply() several times: 6 code occurrences, one is in cycle. The very last occurrency should be kept as it is, the first 5 of them should be replaced with memory variable as the supply changes only once when LP mint() is called at the end of the function. https://github.com/code-423n4/2021-11-bootfinance/blob/main/customswap/contracts/SwapUtils.sol#L1163  ## Recommended Mitigation Steps  Code update:  Now: if (self.lpToken.totalSupply() != 0) { ...  To be: uint256 lpTotalSupply = self.lpToken.totalSupply(); // storage read and function call if (lpTotalSupply != 0) { ...  "}, {"title": "validate() to Verify Airdrop Address On Chain is Unnecessary", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/195", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  Meta0xNull   # Vulnerability details  ## Impact Verify Airdrop Address Holders On Chain by Spending Gas is Unnecessary and probably cost a lot after adding up everyone cost.  ## Recommended At UI Frontend, wallet eg. Metamask allow UI to Verify Address Holders Without Spending Any Gas.  "}, {"title": "claimExact() Missing Validation As In claim()", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/194", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-11-bootfinance-findings", "body": "claimExact() Missing Validation As In claim()"}, {"title": "SwapUtils.getVirtualPrice double calling to storage reading function _xp(self)", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/193", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  hyh   # Vulnerability details  ## Impact  Gas overspending due to excessive storage reads  ## Proof of Concept  SwapUtils's getVirtualPrice repetitively calls _xp(self), which reads storage https://github.com/code-423n4/2021-11-bootfinance/blob/main/customswap/contracts/SwapUtils.sol#L705  ## Recommended Mitigation Steps  Now: uint256 a = determineA(self, _xp(self)); uint256 d = getD(_xp(self), a);  To be: uint256[] memory xP = _xp(self.balances, self.tokenPrecisionMultipliers); uint256 d = getD(xP, determineA(self, xP));  "}, {"title": "Multiple double storage reading _xp(self) function calls", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/191", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  hyh   # Vulnerability details  ## Impact  Gas overspending due to excessive storage reads and function calls  ## Proof of Concept  SwapUtils's removeLiquidityImbalance does multiple _xp(self) calls, which can be saved to memory when balances don't change inbetween executions https://github.com/code-423n4/2021-11-bootfinance/blob/main/customswap/contracts/SwapUtils.sol#L1415  ## Recommended Mitigation Steps  Now: uint256[] memory balances1 = self.balances; v.preciseA = determineA(self, _xp(self)); v.d0 = getD(_xp(self), v.preciseA); ... v.d1 = getD(_xp(self, balances1), determineA(self, _xp(self, balances1))); ... v.d2 = getD(_xp(self, balances1), determineA(self, _xp(self, balances1)));  To be: uint256[] memory balances1 = self.balances; uint256[] memory tokenPM = self.tokenPrecisionMultipliers; // doesn't change, save and reuse uint256[] memory xP = _xp(balances1, tokenPM); // We already copied self.balances, no need to reread storage v.d0 = getD(xP, determineA(self, xP)); // v.preciseA isn't used elsewhere and can be dropped ... xP = _xp(balances1, tokenPM); // balances1 was modified, recomputing v.d1 = getD(xP, determineA(self, xP)); ... xP = _xp(balances1, tokenPM); // balances1 was modified, recomputing v.d2 = getD(xP, determineA(self, xP));  "}, {"title": "'From' and 'to' tokens are read from storage multiple times in SwapUtils's swap function", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/190", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  hyh   # Vulnerability details  ## Impact  Gas is overspent due to excessive storage reads  ## Proof of Concept  SwapUtils's swap: saving self.pooledTokens[tokenIndexFrom], which do not change, to memory and reusing will reduce gas costs. https://github.com/code-423n4/2021-11-bootfinance/blob/main/customswap/contracts/SwapUtils.sol#L1098  ## Recommended Mitigation Steps  Now: self.pooledTokens[tokenIndexFrom].balanceOf(msg.sender)... ... uint256 beforeBalance = self.pooledTokens[tokenIndexFrom].balanceOf(address(this)); self.pooledTokens[tokenIndexFrom].safeTransferFrom( ... uint256 transferredDx = self.pooledTokens[tokenIndexFrom].balanceOf(address(this)).sub(beforeBalance); To be: IERC20 memory fromToken = self.pooledTokens[tokenIndexFrom]; fromToken.balanceOf(msg.sender)... ... uint256 beforeBalance = fromToken.balanceOf(address(this)); fromToken.safeTransferFrom( ... uint256 transferredDx = fromToken.balanceOf(address(this)).sub(beforeBalance);  "}, {"title": "Vesting.benVested storage variable can be simplified, while _claimableAmount's \"s <= benTotal[_addr]\" check is redundant and to be removed", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/186", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  hyh   # Vulnerability details  ## Proof of Concept  The only usage is in _claimableAmount function and can be rewritten with one uint256 storage variable. https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L183 benVested cannot be used to get current state as it is updated only during claim() and revoke() calls and calcClaimableAmount() to be used instead.  The timelocks totals and benTotal cannot differ as timelocks are updated and deleted in vest() and revoke() functions only correspondingly, while there benTotal is updated with very same amount without any additional conditions. https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L91 https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L128  This way the 's <= benTotal[_addr]' check is redundant and to be removed.  ## Impact  's <= benTotal[_addr]' check can be dangerous: the totals and benTotal cannot differ, while if there would be such a possibility, various attacks might be possible, for example a griefing one, when claim() always fails because of this check, and so on.  I.e. now benVested can be simplified and check is not needed, while if there would be such a situation when it is needed, simple check as it is cannot be sufficient, and some code redesign should be done instead.  ## Recommended Mitigation Steps  Code update: Now: mapping(address => uint256[2]) public benVested; ... uint256 completely_vested = 0; uint256 partial_sum = 0; ... completely_vested = completely_vested.add(timelocks[_addr][i].amount); ... partial_sum = partial_sum.add(claimable); ... benVested[_addr][0] = benVested[_addr][0].add(completely_vested); benVested[_addr][1] = partial_sum; uint256 s = benVested[_addr][0].add(partial_sum); assert(s <= benTotal[_addr]); return s;  To be: mapping(address => uint256) public benVested; ... uint256 currently_vested = 0; ... currently_vested = currently_vested.add(timelocks[_addr][i].amount); ... currently_vested = currently_vested.add(claimable); ... uint256 s = benVested[_addr].add(currently_vested); benVested[_addr] = s; return s;  Also, cleaning in revoke() simplifies to benVested[_addr] = 0; https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L127  "}, {"title": "Get virtual price is not monotonically increasing ", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/185", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  jonah1005   # Vulnerability details  ## Impact There's a feature of `virtualPrice` that is monotonically increasing regardless of the market. This function is heavily used in multiple protocols. e.g.(curve metapool, mim, ...) This is not held in the current implementation of customSwap since `customPrecisionMultipliers` can be changed by changing the target price.  There're two issues here: The meaning of `virtualPrice` would be vague. This may damage the lp providers as the protocol that adopts it may be hacked.  I consider this is a medium-risk issue.  ## Proof of Concept We can set up a mockSwap with extra `setPrecisionMultiplier` to check the issue. ```solidity     function setPrecisionMultiplier(uint256 multipliers) external {         swapStorage.tokenPrecisionMultipliers[0] = multipliers;      } ```  ```python     print(swap.functions.getVirtualPrice().call())     swap.functions.setPrecisionMultiplier(2).transact()     print(swap.functions.getVirtualPrice().call())  # output log: #   1000000000000000000 #   1499889859738721606 ``` ## Tools Used None ## Recommended Mitigation Steps Dealing with the target price with multiplier precision seems clever as we can reuse most of the existing code. However, the precision multiplier should be an immutable parameter. Changing it after the pool is set up would create multiple issues. This function could be implemented in a safer way IMHO.  The quick fix would be to remove the `getVirtualPrice` function. I can't come up with a safe way if other protocol wants to use this function.   "}, {"title": "`customPrecisionMultipliers` would be rounded to zero and break the pool", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/183", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  jonah1005   # Vulnerability details  ## Impact CustomPrecisionMultipliers are set in the constructor: ```solidity         customPrecisionMultipliers[0] = targetPriceStorage.originalPrecisionMultipliers[0].mul(_targetPrice).div(10 ** 18); ``` `originalPrecisionMultipliers` equal to 1 if the token's decimal = 18. The targe price could only be an integer.  If the target price is bigger than 10**18, the user can deposit and trade in the pool. Though, the functionality would be far from the spec.  If the target price is set to be smaller than 10**18, the pool would be broken and all funds would be stuck.  I consider this is a high-risk issue.   ## Proof of Concept Please refer to the implementation. [Swap.sol#L184-L187](https://github.com/code-423n4/2021-11-bootfinance/blob/main/customswap/contracts/Swap.sol#L184-L187)  We can also trigger the bug by setting a pool with target price = 0.5. (0.5 * 10**18) ## Tools Used None ## Recommended Mitigation Steps I recommend providing extra 10**18 in both multipliers. ```solidity         customPrecisionMultipliers[0] = targetPriceStorage.originalPrecisionMultipliers[0].mul(_targetPrice).mul(10**18).div(10 ** 18);         customPrecisionMultipliers[1] = targetPriceStorage.originalPrecisionMultipliers[1].mul(10**18); ``` The customswap only supports two tokens in a pool, there's should be enough space. Recommend the devs to go through the trade-off saddle finance has paid to support multiple tokens. The code could be more clean and efficient if the pools' not support multiple tokens.   "}, {"title": "Use bytes32 instead of string when possible", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/176", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pants   # Vulnerability details  If data can fit into 32 bytes, then you should use bytes32 datatype rather than bytes or strings as it is much cheaper in solidity. Basically, Any fixed size variable in solidity is cheaper than variable size. On the MarketPlace.sol contract, string memory variable can be replaced with bytes32 array. That will save gas on the contract.  An example is revert messages. For example look at line 32 of PublicSale.sol.  "}, {"title": "Use of uint8 for counter in for loop increases gas costs", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/175", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "Use of uint8 for counter in for loop increases gas costs"}, {"title": "Redundant hardhat console import ", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/173", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pants   # Vulnerability details  You import \"import \"./hardhat/console.sol\";\" and all uses are commented. You should also comment the import. SwapUtils line 9  "}, {"title": "Use calldata instead of memory for function parameters", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/172", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  mics   # Vulnerability details  Use calldata instead of memory for function parameters In some cases, having function arguments in calldata instead of memory is more optimal.  Consider the following generic example:  contract C {     function add(uint[] memory arr) external returns (uint sum) {         uint length = arr.length;         for (uint i = 0; i < arr.length; i++) {             sum += arr[i];         }     } } In the above example, the dynamic array arr has the storage location memory. When the function gets called externally, the array values are kept in calldata and copied to memory during ABI decoding (using the opcode calldataload and mstore). And during the for loop, arr[i] accesses the value in memory using a mload. However, for the above example this is inefficient. Consider the following snippet instead:  contract C {     function add(uint[] calldata arr) external returns (uint sum) {         uint length = arr.length;         for (uint i = 0; i < arr.length; i++) {             sum += arr[i];         }     } } In the above snippet, instead of going via memory, the value is directly read from calldata using calldataload. That is, there are no intermediate memory operations that carries this value.  Gas savings: In the former example, the ABI decoding begins with copying value from calldata to memory in a for loop. Each iteration would cost at least 60 gas. In the latter example, this can be completely avoided. This will also reduce the number of instructions and therefore reduces the deploy time cost of the contract.  In short, use calldata instead of memory if the function argument is only read.  Note that in older Solidity versions, changing some function arguments from memory to calldata may cause \"unimplemented feature error\". This can be avoided by using a newer (0.8.*) Solidity compiler.  (non-exhaustive) List of Examples: SwapUtils line 639 USDPoolDelegator line 53 Swap.sol line 135   "}, {"title": "unnecessary variable y in getYD ", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/170", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  mics   # Vulnerability details  You could use the variable d instead of defining a new variable y at line 548 of SwapUtils.sol  "}, {"title": "Missing revert message", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/168", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  mics   # Vulnerability details  Missing revert messages in the following places:  1.  ETHPoolDelegator line 67 2.  BTCPoolDelegator line 67 3.  USDPoolDelegator lines 55, 56  "}, {"title": "Usage of deprecated safeApprove", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/166", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  mics   # Vulnerability details  safeApprove is now deprecated, see the link below. https://github.com/OpenZeppelin/openzeppelin-contracts/blob/566a774222707e424896c0c390a84dc3c13bdcb2/contracts/token/ERC20/utils/SafeERC20.sol#L38.  This appears for example in line 499 of AirdropDistribution.sol.  we recommend as in OpenZepplin documentation \u201cwhenever possible, use safeIncreaseAllowance and safeDecreaseAllowance instead\u201d.     "}, {"title": "Constants should be written in UPPER_CASE", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/165", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pmerkleplant   # Vulnerability details  Constants should be written in UPPER_CASE, see [Solidity naming conventions](https://docs.soliditylang.org/en/v0.4.25/style-guide.html#constants).  Constants breaking this convention:  - `decimals` in `tge/contracts/PublicSale.sol` - `coin` in `tge/contracts/PublicSale.sol` - `secondsPerDay` in `tge/contracts/PublicSale.sol` - `firstEra` in `tge/contracts/PublicSale.sol`  "}, {"title": "Contract `Vesting` should inherit from interface `IVesting`", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/164", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pmerkleplant   # Vulnerability details  Contract `Vesting` in `vesting/contracts/Vesting.sol` should inherit from the interface `IVesting` in `vesting/contracts/interfaces/IVesting.sol` as the contract implements the interface.  "}, {"title": "Functions should be written in mixedCase", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/163", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pmerkleplant   # Vulnerability details  Functions should be written in mixedCase, see [Solidity naming conventions](https://docs.soliditylang.org/en/v0.4.25/style-guide.html#function-names).  Functions breaking this convention:  - Function `_available_supply` in `vesting/contracts/AidropDistribution.sol` - Function `available_supply` in `vesting/contracts/AidropDistribution.sol` - Function `_available_supply` in `vesting/contracts/InvestorDistribution.sol` - Function `available_supply` in `vesting/contracts/InvestorDistribution.sol` - Function `dev_rugpull` in `vesting/contracts/InvestorDistribution.sol`  "}, {"title": "Events should be written in CapWords", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/162", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pmerkleplant   # Vulnerability details  Events should be written in CapWords, see [Solidity naming conventions](https://docs.soliditylang.org/en/v0.4.25/style-guide.html#event-names).  Events breaking this convention:  - `updateMiningParameters` in `vesting/contracts/AidropDistribution.sol` - `updateMiningParameters` in `vesting/contracts/InvestorDistribution.sol`  "}, {"title": "Remove unused variables", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/161", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pmerkleplant   # Vulnerability details  Removing unused variables saves gas and increases code clarity.  Following variables are unused and can be removed:  - `Hour` in `vesting/contracts/AidropDistribution.sol` - `Day` in `vesting/contracts/AirdropDistribution.sol` - `Hour` in `vesting/contracts/InvestorDistribution.sol` - `Day` in `vesting/contracts/InvestorDistribution.sol` - `_balance` in `tge/contracts/PublicSale.sol` - `_allowance` in `tge/contracts/PublicSale.sol`  "}, {"title": "safeERC20 library imported but not used", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/154", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  loop   # Vulnerability details  `AirDropDistribution.sol` and `InvestorDistribution.sol` import the `safeERC20` library but make use of the normal ERC20 `transfer` function rather than `safeTransfer`. Considering this is called on the BOOT token there is likely no need for it to be `safeTransfer`. However, since the library is not used there is no need for it to be imported.   ## Proof of Concept - https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/AirdropDistribution.sol#L12 - https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol#L12  Transfer calls: - https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/AirdropDistribution.sol#L542 - https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/AirdropDistribution.sol#L567  - https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol#L132 - https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol#L156 - https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol#L207  "}, {"title": "Ideal balance is not calculated correctly when providing imbalanced liquidity", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/150", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  jonah1005   # Vulnerability details  ## Impact When a user provides imbalanced liquidity, the fee is calculated according to the ideal balance. In saddle finance, the optimal balance should be the same ratio as in the Pool.  Take, for example, if there's 10000 USD and 10000 DAI in the saddle's USD/DAI pool, the user should get the optimal lp if he provides lp with ratio = 1.  However, if the customSwap pool is created with a target price = 2. The user would get 2 times more lp if he deposits DAI. [SwapUtils.sol#L1227-L1245](https://github.com/code-423n4/2021-11-bootfinance/blob/main/customswap/contracts/SwapUtils.sol#L1227-L1245) The current implementation does not calculates ideal balance correctly.  If the target price is set to be 10, the ideal balance deviates by 10. The fee deviates a lot. I consider this is a high-risk issues.  ## Proof of Concept We can observe the issue if we initiates two pools DAI/LINK pool and set the target price to be 4.  For the first pool, we deposit more dai. ```python     swap = deploy_contract('Swap'          [dai.address, link.address], [18, 18], 'lp', 'lp', 1, 85, 10**7, 0, 0, 4* 10**18)     link.functions.approve(swap.address, deposit_amount).transact()     dai.functions.approve(swap.address, deposit_amount).transact()     previous_lp = lptoken.functions.balanceOf(user).call()     swap.functions.addLiquidity([deposit_amount, deposit_amount // 10], 10, 10**18).transact()     post_lp = lptoken.functions.balanceOf(user).call()     print('get lp', post_lp - previous_lp) ```  For the second pool, one we deposit more dai. ```python     swap = deploy_contract('Swap'          [dai.address, link.address], [18, 18], 'lp', 'lp', 1, 85, 10**7, 0, 0, 4* 10**18)     link.functions.approve(swap.address, deposit_amount).transact()     dai.functions.approve(swap.address, deposit_amount).transact()     previous_lp = lptoken.functions.balanceOf(user).call()     swap.functions.addLiquidity([deposit_amount, deposit_amount // 10], 10, 10**18).transact()     post_lp = lptoken.functions.balanceOf(user).call()     print('get lp', post_lp - previous_lp) ```  We can get roughly 4x more lp in the first case ## Tools Used None ## Recommended Mitigation Steps  The current implementation uses `self.balances`  https://github.com/code-423n4/2021-11-bootfinance/blob/main/customswap/contracts/SwapUtils.sol#L1231-L1236 ```soliditiy             for (uint256 i = 0; i < self.pooledTokens.length; i++) {                 uint256 idealBalance = v.d1.mul(self.balances[i]).div(v.d0);                 fees[i] = feePerToken                     .mul(idealBalance.difference(newBalances[i]))                     .div(FEE_DENOMINATOR);                 self.balances[i] = newBalances[i].sub(                     fees[i].mul(self.adminFee).div(FEE_DENOMINATOR)                 );                 newBalances[i] = newBalances[i].sub(fees[i]);             } ```  Replaces `self.balances` with `_xp(self, newBalances)` would be a simple fix. I consider the team can take balance's weighted pool as a reference. [WeightedMath.sol#L149-L179](https://github.com/balancer-labs/balancer-v2-monorepo/blob/7ff72a23bae6ce0eb5b134953cc7d5b79a19d099/pkg/pool-weighted/contracts/WeightedMath.sol#L149-L179)  "}, {"title": "Reentrancy", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/148", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  0v3rf10w   # Vulnerability details  ## Impact Multiple Reentrancy  ## Proof of Concept Reentrancy in BasicSale.receive() (tge/contracts/PublicSale.sol#148-156)  Reentrancy in BasicSale.burnEtherForMember(address) (tge/contracts/PublicSale.sol#158-166)   State variables written after the external call(s) in all above.  ## Tools Used Manual  ## Recommended Mitigation Steps  "}, {"title": "block timestamp", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/147", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-11-bootfinance-findings", "body": "block timestamp"}, {"title": "Missing Zero-check", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/146", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  0v3rf10w   # Vulnerability details  ## Impact Missing Zero address check  ## Proof of Concept BasicSale.constructor(IERC20,IERC721,IVesting,uint256,uint256,uint256,uint256,address)._burnAddress (tge/contracts/PublicSale.sol#112)  lacks a zero-check on :- burnAddress = _burnAddress (tge/contracts/PublicSale.sol#137)  ## Tools Used Manual  ## Recommended Mitigation Steps Check that the address is zero   "}, {"title": "Unchecked low-level calls", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/145", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  0v3rf10w   # Vulnerability details  ## Impact Unchecked low-level calls  ## Proof of Concept Unchecked cases at 2 places :- BasicSale.receive() (2021-11-bootfinance/tge/contracts/PublicSale.sol#148-156) ignores return value by burnAddress.call{value: msg.value}() (2021-11-bootfinance/tge/contracts/PublicSale.sol#154)  BasicSale.burnEtherForMember(address) (2021-11-bootfinance/tge/contracts/PublicSale.sol#158-166) ignores return value by burnAddress.call{value: msg.value}() (2021-11-bootfinance/tge/contracts/PublicSale.sol#164)   ## Tools Used Manual  ## Recommended Mitigation Steps The return value of the low-level call is not checked, so if the call fails, the Ether will be locked in the contract. If the low level is used to prevent blocking operations, consider logging failed calls.  "}, {"title": "Can not update target price", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/143", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  jonah1005   # Vulnerability details  ## Impact The sanity checks in `rampTargetPrice` are broken [SwapUtils.sol#L1571-L1581](https://github.com/code-423n4/2021-11-bootfinance/blob/main/customswap/contracts/SwapUtils.sol#L1571-L1581) ```solidity         if (futureTargetPricePrecise < initialTargetPricePrecise) {             require(                 futureTargetPricePrecise.mul(MAX_RELATIVE_PRICE_CHANGE).div(WEI_UNIT) >= initialTargetPricePrecise,                 \"futureTargetPrice_ is too small\"             );         } else {             require(                 futureTargetPricePrecise <= initialTargetPricePrecise.mul(MAX_RELATIVE_PRICE_CHANGE).div(WEI_UNIT),                 \"futureTargetPrice_ is too large\"             );         } ``` If `futureTargetPricePrecise` is smaller than `initialTargetPricePrecise` 0.01 of `futureTargetPricePrecise` would never larger than `initialTargetPricePrecise`.  Admin would not be able to ramp the target price. As it's one of the most important features of the customswap, I consider this is a high-risk issue  ## Proof of Concept Here's a web3.py script to demo that it's not possible to change the target price even by 1 wei. ```python     p1, p2, _, _ =swap.functions.targetPriceStorage().call()     future = w3.eth.getBlock(w3.eth.block_number)['timestamp'] + 200 * 24 * 3600      # futureTargetPrice_ is too small     swap.functions.rampTargetPrice(p1 -1, future).transact()     # futureTargetPrice_ is too large     swap.functions.rampTargetPrice(p1 + 1, future).transact() ``` ## Tools Used None ## Recommended Mitigation Steps  Would it be something like: ```solidity         if (futureTargetPricePrecise < initialTargetPricePrecise) {             require(                 futureTargetPricePrecise.mul(MAX_RELATIVE_PRICE_CHANGE + WEI_UNIT).div(WEI_UNIT) >= initialTargetPricePrecise,                 \"futureTargetPrice_ is too small\"             );         } else {             require(                 futureTargetPricePrecise <= initialTargetPricePrecise.mul(MAX_RELATIVE_PRICE_CHANGE + WEI_UNIT).div(WEI_UNIT),                 \"futureTargetPrice_ is too large\"             );         } ``` I believe the dev would spot this mistake if there's a more relaxed timeline.  "}, {"title": "Unclear Commented Out Code", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/140", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  ye0lde   # Vulnerability details  # Vulnerability details  ## Impact  I'm not sure why some of this code is commented out.   It could point to items that are not done or need redesigning, be a mistake, or just be testing overhead.   ## Proof of Concept The commented out code is here:  Unclear: https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/vesting/contracts/Vesting.sol#L27 https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/vesting/contracts/Vesting.sol#L76  Obviously Test related: https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/customswap/contracts/Swap.sol#L187  Guarded launch: https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/customswap/contracts/Swap.sol#L42-L49 https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/customswap/contracts/Swap.sol#L201-L204 https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/customswap/contracts/Swap.sol#L235-L237  ## Tools Used VS Code  ## Recommended Mitigation Steps Review and remove or resolve/document the commented out lines if needed.  "}, {"title": "Rearrange state variables", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/138", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pants   # Vulnerability details  ## Impact In BTCPoolDelegator contract, address state variables `future_owner` in lines 51 and bool state variable `is_killed` in line 55 should be placed one after another. solidity keep storage in 32 bytes slot and can optimize multiple variables that are less than 32 bytes. address is 20 bytes and bool is 1 byte, so it can be placed in one storage slot instead of two.  ## Proof of Concept Tested it on Remix, saves 50 gas per transaction  ## Recommended Mitigation Steps change ``` 50    uint256 public future_admin_fee; 51    address public future_owner; 52 53    uint256 kill_deadline; 54    uint256 constant kill_deadline_dt = 2 * 30 * 86400; 54    bool is_killed; ``` to ``` 50    uint256 public future_admin_fee; 51    uint256 constant kill_deadline_dt = 2 * 30 * 86400; 52 53    uint256 kill_deadline; 54    address public future_owner; 54    bool is_killed; ```  "}, {"title": "Require statement missing in fallback and burnEtherForMember() functions", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/137", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  Reigada   # Vulnerability details  ## Impact The contract BasicSale contains a fallback function and a burnEtherForMember() function with exactly the same implementation. These 2 functions do the following call: _recordBurn(msg.sender, msg.sender, currentEra, currentDay, msg.value);  The _recordBurn function contains the following if block: if (mapEraDay_MemberUnits[_era][_day][_member] == 0) {                              // If hasn't contributed to this Day yet     mapMemberEra_Days[_member][_era].push(_day);                                    // Add it     mapEraDay_MemberCount[_era][_day] += 1;                                         // Count member     mapEraDay_Members[_era][_day].push(_member);                                    // Add member }  What does this mean? If a user performs multiple calls to the contract sending 0 ether as msg.value, the if block will be entered and a new key will be pushed to the mapping. Luckily the cost of an addition to or a read from a mapping does not change with the number of keys mapped. But this would totally mess the function getDaysContributedForEra output. Currently this function is only used as a view function, and not used by the smart contract itself. But it's a risk for future implementations that may make use of it.  ## Proof of Concept >>> user2.transfer(to=publicsale.address, amount=0) Transaction sent: 0xd65ffecd5052314bc09f616461ff6aa9efeb857151c0339dc15653fb90ebb91f   Gas price: 0.0 gwei   Gas limit: 6721975   Nonce: 0   Transaction confirmed   Block: 13577879   Gas used: 117368 (1.75%)  <Transaction '0xd65ffecd5052314bc09f616461ff6aa9efeb857151c0339dc15653fb90ebb91f'>  >>> publicsale.getDaysContributedForEra(user2.address, 1) 1  >>> user2.transfer(to=publicsale.address, amount=0) Transaction sent: 0x0a48f89c1266af2c3eea5cdcec93dae76e4ed2a0936e53e8713d669989b88b19   Gas price: 0.0 gwei   Gas limit: 6721975   Nonce: 1   Transaction confirmed   Block: 13577880   Gas used: 91568 (1.36%)  <Transaction '0x0a48f89c1266af2c3eea5cdcec93dae76e4ed2a0936e53e8713d669989b88b19'>  >>> publicsale.getDaysContributedForEra(user2.address, 1) 2  >>> user2.transfer(to=publicsale.address, amount=0) Transaction sent: 0xeb85e31664eb1578f54daba1be112f9533948d0e2414510874ed55fbb3a9a9e0   Gas price: 0.0 gwei   Gas limit: 6721975   Nonce: 2   Transaction confirmed   Block: 13577881   Gas used: 91568 (1.36%)  <Transaction '0xeb85e31664eb1578f54daba1be112f9533948d0e2414510874ed55fbb3a9a9e0'>  >>> publicsale.getDaysContributedForEra(user2.address, 1) 3  ## Tools Used Manual testing  ## Recommended Mitigation Steps Add the following require statement to the fallback and the burnEtherForMember() functions: require(msg.value > 0, \"Some ether should be sent\")  "}, {"title": "Contract BasicSale is missing an approve(address(vestLock), 2**256-1) call", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/135", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  Reigada   # Vulnerability details  ## Impact As we can see in the contracts AirdropDistribution and InvestorDistribution, they both have the following approve() call: mainToken.approve(address(vestLock), 2**256-1); https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/AirdropDistribution.sol#L499 https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol#L80  This is necessary because both contracts transfer tokens to the vesting contract by calling its vest() function: https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/AirdropDistribution.sol#L544 https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/AirdropDistribution.sol#L569 https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol#L134 https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol#L158  The code of the vest() function in the Vesting contract performs a transfer from msg.sender to Vesting contract address -> vestingToken.transferFrom(msg.sender, address(this), _amount); https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L95  Same is done in the BasicSale contract: https://github.com/code-423n4/2021-11-bootfinance/blob/main/tge/contracts/PublicSale.sol#L225  The problem is that this contract is missing the approve() call. For that reason, the contract is totally useless as the function _withdrawShare() will always revert with the following message: revert reason: ERC20: transfer amount exceeds allowance. This means that all the mainToken sent to the contract would be stuck there forever. No way to retrieve them.  How this issue was not detected in the testing phase? Very simple. The mock used by the team has an empty vest() function that performs no transfer call. https://github.com/code-423n4/2021-11-bootfinance/blob/main/tge/contracts/helper/MockVesting.sol#L10  ## Proof of Concept See below Brownie's custom output: Calling -> publicsale.withdrawShare(1, 1, {'from': user2}) Transaction sent: 0x9976e4f48bd14f9be8e3e0f4d80fdb8f660afab96a7cbd64fa252510154e7fde   Gas price: 0.0 gwei   Gas limit: 6721975   Nonce: 5   BasicSale.withdrawShare confirmed (ERC20: transfer amount exceeds allowance)   Block: 13577532   Gas used: 323334 (4.81%)  Call trace for '0x9976e4f48bd14f9be8e3e0f4d80fdb8f660afab96a7cbd64fa252510154e7fde': Initial call cost  [21344 gas] BasicSale.withdrawShare  0:3724  [16114 / -193010 gas] \u251c\u2500\u2500 BasicSale._withdrawShare  111:1109  [8643 / 63957 gas] \u2502   \u251c\u2500\u2500 BasicSale._updateEmission  116:405  [53294 / 55739 gas] \u2502   \u2502   \u2514\u2500\u2500 BasicSale.getDayEmission  233:248  [2445 gas] \u2502   \u251c\u2500\u2500 BasicSale._processWithdrawal  437:993  [-7726 / -616 gas] \u2502   \u2502   \u251c\u2500\u2500 BasicSale.getEmissionShare  484:859  [4956 / 6919 gas] \u2502   \u2502   \u2502   \u2502 \u2502   \u2502   \u2502   \u2514\u2500\u2500 MockERC20.balanceOf  [STATICCALL]  616:738  [1963 gas] \u2502   \u2502   \u2502           \u251c\u2500\u2500 address: mockerc20.address \u2502   \u2502   \u2502           \u251c\u2500\u2500 input arguments: \u2502   \u2502   \u2502           \u2502   \u2514\u2500\u2500 account: publicsale.address \u2502   \u2502   \u2502           \u2514\u2500\u2500 return value: 100000000000000000000 \u2502   \u2502   \u2502 \u2502   \u2502   \u2514\u2500\u2500 SafeMath.sub  924:984  [191 gas] \u2502   \u2514\u2500\u2500 SafeMath.sub  1040:1100  [191 gas] \u2502 \u251c\u2500\u2500 MockERC20.transfer  [CALL]  1269:1554  [1115 / 30109 gas] \u2502   \u2502   \u251c\u2500\u2500 address: mockerc20.address \u2502   \u2502   \u251c\u2500\u2500 value: 0 \u2502   \u2502   \u251c\u2500\u2500 input arguments: \u2502   \u2502   \u2502   \u251c\u2500\u2500 recipient: user2.address \u2502   \u2502   \u2502   \u2514\u2500\u2500 amount: 27272727272727272727 \u2502   \u2502   \u2514\u2500\u2500 return value: True \u2502   \u2502 \u2502   \u2514\u2500\u2500 ERC20.transfer  1366:1534  [50 / 28994 gas] \u2502       \u2514\u2500\u2500 ERC20._transfer  1374:1526  [28944 gas] \u2514\u2500\u2500 Vesting.vest  [CALL]  1705:3712  [-330491 / -303190 gas]     \u2502   \u251c\u2500\u2500 address: vesting.address     \u2502   \u251c\u2500\u2500 value: 0     \u2502   \u251c\u2500\u2500 input arguments:     \u2502   \u2502   \u251c\u2500\u2500 _beneficiary: user2.address     \u2502   \u2502   \u251c\u2500\u2500 _amount: 63636363636363636363     \u2502   \u2502   \u2514\u2500\u2500 _isRevocable: 0     \u2502   \u2514\u2500\u2500 revert reason: ERC20: transfer amount exceeds allowance <-------------     \u2502     \u251c\u2500\u2500 SafeMath.add  1855:1883  [94 gas]     \u251c\u2500\u2500 SafeMath.add  3182:3210  [94 gas]     \u251c\u2500\u2500 SafeMath.add  3236:3264  [94 gas]     \u2502     \u2514\u2500\u2500 MockERC20.transferFrom  [CALL]  3341:3700  [99923 / 27019 gas]         \u2502   \u251c\u2500\u2500 address: mockerc20.address         \u2502   \u251c\u2500\u2500 value: 0         \u2502   \u251c\u2500\u2500 input arguments:         \u2502   \u2502   \u251c\u2500\u2500 sender: publicsale.address         \u2502   \u2502   \u251c\u2500\u2500 recipient: vesting.address         \u2502   \u2502   \u2514\u2500\u2500 amount: 63636363636363636363         \u2502   \u2514\u2500\u2500 revert reason: ERC20: transfer amount exceeds allowance         \u2502         \u2514\u2500\u2500 ERC20.transferFrom  3465:3700  [-97648 / -72904 gas]             \u2514\u2500\u2500 ERC20._transfer  3473:3625  [24744 gas]  ## Tools Used Manual testing  ## Recommended Mitigation Steps The following approve() call should be added in the constructor of the BasicSale contract: mainToken.approve(address(vestLock), 2**256-1);  "}, {"title": "uint256 is always >= 0", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/133", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  0x0x0x   # Vulnerability details  ## Impact Gas optimization  ## Proof of Concept  On Swap.sol at L190 and L191, it is checked that whether _a and _a2 is bigger equal to 0. Since they are both uint256, this condition is always satisfied. Therefore, those conditions are not required.  ## Tools Used  Manual analysis  "}, {"title": "Overwrite benRevocable", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/132", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact Anyone can call the function vest() of Vesting.sol, for example with a smail \"_amount\" of tokens, for any _beneficiary.  The function overwrites the value of benRevocable[_beneficiary], effectively erasing any previous value.  So you can set any _beneficiary to Revocable. Although revoke() is only callable by the owner, this is circumventing the entire mechanism of benRevocable.  ## Proof of Concept // https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/vesting/contracts/Vesting.sol#L73-L98  function vest(address _beneficiary, uint256 _amount, uint256 _isRevocable) external payable whenNotPaused {         ...         if(_isRevocable == 0){             benRevocable[_beneficiary] = [false,false];  // just overwrites the value         }         else if(_isRevocable == 1){             benRevocable[_beneficiary] = [true,false]; // just overwrites the value         }        ## Tools Used  ## Recommended Mitigation Steps Whitelist the calling of vest() Or check if values for benRevocable are already set.   "}, {"title": "Investor can't claim the last tokens (via claim() )", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/131", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact Suppose you are an investor and want to claim the last part of your claimable tokens (or your entire set of claimable tokens if you haven't claimed anything yet). Then you call the function claim() of InvestorDistribution.sol, which has the following statement: \"require(investors[msg.sender].amount - claimable != 0);\" This statement will prevent you from claiming your tokens because it will stop execution.  Note: with the function claimExact() it is possible to claim the last part.  ## Proof of Concept // https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/vesting/contracts/InvestorDistribution.sol#L113-L128  function claim() external nonReentrant { ...         require(investors[msg.sender].amount - claimable != 0);         investors[msg.sender].amount -= claimable;  ## Tools Used  ## Recommended Mitigation Steps Remove the require statement.   "}, {"title": "Can't claim last part of airdrop", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/130", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact Suppose you are eligible for the last part of your airdrop (or your entire airdrop if you haven't claimed anything yet). Then you call the function claim() of AirdropDistribution.sol, which has the following statement: \"assert(airdrop[msg.sender].amount - claimable != 0);\" This statement will prevent you from claiming your airdrop because it will stop execution.  Note: with the function claimExact() it is possible to claim the last part.  ## Proof of Concept // https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/vesting/contracts/AirdropDistribution.sol#L522-L536  function claim() external nonReentrant {        ..         assert(airdrop[msg.sender].amount - claimable != 0);         airdrop[msg.sender].amount -= claimable;  ## Tools Used  ## Recommended Mitigation Steps Remove the assert statement. Also add the following to validate() , to prevent claiming the airdrop again:       require(validated[msg.sender]== 0, \"Already validated.\");  "}, {"title": "Claim airdrop repeatedly", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/129", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact Suppose someone claims the last part of his airdrop via claimExact() of AirdropDistribution.sol Then airdrop[msg.sender].amount will be set to 0.  Suppose you then call validate() again.  The check \"airdrop[msg.sender].amount == 0\" will allow you to continue, because amount has just be set to 0. In the next part of the function, airdrop[msg.sender] is overwritten with fresh values and airdrop[msg.sender].claimed will be reset to 0.  Now you can claim your airdrop again (as long as there are tokens present in the contract)  Note: The function claim() prevents this from happening via \"assert(airdrop[msg.sender].amount - claimable != 0);\", which has its own problems, see other reported issues.  ## Proof of Concept // https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/vesting/contracts/AirdropDistribution.sol#L555-L563  function claimExact(uint256 _value) external nonReentrant {         require(msg.sender != address(0));         require(airdrop[msg.sender].amount != 0);                  uint256 avail = _available_supply();         uint256 claimable = avail * airdrop[msg.sender].fraction / 10**18; //         if (airdrop[msg.sender].claimed != 0){             claimable -= airdrop[msg.sender].claimed;         }          require(airdrop[msg.sender].amount >= claimable); // amount can be equal to claimable         require(_value <= claimable);                       // _value can be equal to claimable         airdrop[msg.sender].amount -= _value;      // amount will be set to 0 with the last claim   // https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/vesting/contracts/AirdropDistribution.sol#L504-L517 function validate() external nonReentrant {         ...         require(airdrop[msg.sender].amount == 0, \"Already validated.\");         ...              Airdrop memory newAirdrop = Airdrop(airdroppable, 0, airdroppable, 10**18 * airdroppable / airdrop_supply);              airdrop[msg.sender] = newAirdrop;              validated[msg.sender] = 1;   // this is set, but isn't checked on entry of this function  ## Tools Used  ## Recommended Mitigation Steps Add the following to validate() :         require(validated[msg.sender]== 0, \"Already validated.\");  "}, {"title": "No event was emitted while setting fees and admin_fees in constructor", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/128", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  JMukesh   # Vulnerability details  ## Impact Event should be emitted after sensitive action like setting fees, admin_fees otherwise it will be difficult track offchain fees changes  ## Proof of Concept  https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/core-contracts/contracts/sol/BTCPoolDelegator.sol#L57  https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/core-contracts/contracts/sol/ETHPoolDelegator.sol#L58  https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/core-contracts/contracts/sol/USDPoolDelegator.sol#L53  ## Tools Used  manual review ## Recommended Mitigation Steps  event should be emitted after the sensitive action  "}, {"title": "No checking of admin_fee, wether it is <= max_admin_fee ", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/127", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  JMukesh   # Vulnerability details  ## Impact due to lack of checking admin_fee, it can be greater than max_admin_fee  ## Proof of Concept https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/core-contracts/contracts/sol/BTCPoolDelegator.sol#L57  https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/core-contracts/contracts/sol/ETHPoolDelegator.sol#L58  https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/core-contracts/contracts/sol/USDPoolDelegator.sol#L53  ## Tools Used  manual review  ## Recommended Mitigation Steps  add input validation for admin_fee  "}, {"title": "claimExact does not check claimable amount", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/126", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  nathaniel   # Vulnerability details  ## Impact Inconsistency between the `claim()` function and `claimExact()` function, in that `claimExact` does not check the claimable amount. In the scenario where claimable = 0, and `investors[msg.sender].claimed != 0` then it will attempt to underflow. If `_amount` is 0, then it could potentially reach the `vestLock.vest()` function, where it will then revert with the inaccurate message \"amount must be positive\" which doesn't reflect the underlying issue.  ## Proof of Concept https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol#L145 https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol#L121 https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L75  ## Tools Used manual review   ## Recommended Mitigation Steps Add `require(claimable > 0)`  "}, {"title": "Renaming variables for clarity", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/125", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  nathaniel   # Vulnerability details  ## Impact `amount` in the `Investors` struct is vague. It would be assumed to be the invested amount, however this amount decreases when the beneficiary claims. A more appropriate name could be `unclaimed_amount`. `claimable_to_send` is not appropriate name in the `claimExact()` function, as it is not the claimable total, instead `exact_claim_to_send` would make more sense. ## Proof of Concept https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol#L24 https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol#L155   "}, {"title": "Public functions can be external", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/121", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  nathaniel   # Vulnerability details  ## Impact Functions include `updateEmission(), dev_rugpull(), setAdmin(), revoke() ## Proof of Concept https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol#L185 https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol#L203 https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol#L212 https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L104  "}, {"title": "Unable to claim vesting due to unbounded timelock loop", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/120", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  nathaniel   # Vulnerability details  ## Impact The timelocks for any *beneficiary* are unbounded, and can be vested by someone who is not the *beneficiary*. When the array becomes significantly big enough, the vestments will no longer be claimable for the *beneficiary*.  The `vest()` function in Vesting.sol does not check the *beneficiary*, hence anyone can vest for anyone else, pushing a new timelock to the `timelocks[_beneficiary]`. The `_claimableAmount()` function (used by `claim()` function), then loops through the `timelocks[_beneficiary]` to determine the amount to be claimed. A malicious actor can easy repeatedly call the `vest()` function with minute amounts to make the array large enough, such that when it comes to claiming, it will exceed the gas limit and revert, rendering the vestment for the beneficiary unclaimable.  The malicious actor could do this to each *beneficiary*, locking up all the vestments.  ## Proof of Concept https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L81 https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L195 https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L148  ## Tools Used Manual code review  ## Recommended Mitigation Steps - Create a minimum on the vestment amounts, such that it won't be feasible for a malicious actor to create a large amount of vestments. - Restrict the vestment contribution of a *beneficiary* where `require(beneficiary == msg.sender)`  "}, {"title": "Function _getDayEmission can be simplified (PublicSale.sol)", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/118", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  ye0lde   # Vulnerability details  ## Impact  Code clarity  ## Proof of Concept  The function is here: https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/tge/contracts/PublicSale.sol#L291-L298  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps  I suggest making the changes below to simplify:    <code>     function getDayEmission() public view returns (uint) {            return (remainingSupply > emission ? emission : remainingSupply);     } </code>  "}, {"title": "Cache Reference To State Variables \"currentDay, currentEra, emission\" in _updateEmission (PublicSale.sol)", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/117", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  ye0lde   # Vulnerability details  ## Impact  Cache Reference To State Variables \"currentDay, currentEra, emission\" in _updateEmission (PublicSale.sol)  Caching the references to \"currentDay, currentEra, emission\" will decrease gas usage.   ## Proof of Concept  The variables \"currentDay, currentEra, emission\" are referenced 20 times in function \"_updateEmission\" here: https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/tge/contracts/PublicSale.sol#L247-L276  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps  I suggest making the changes below to cache those variables:    <code>  function _updateEmission() private {         uint _now = block.timestamp;                                                                                      // Find now()         if (_now >= nextDayTime) {                                                                                         // If time passed the next Day time                  uint256 _currentDay = currentDay;             uint256 _currentEra = currentEra;             uint256 _emission = emission;              if (remainingSupply > _emission) {                 remainingSupply -= _emission;                                                              }             else {                 remainingSupply = 0;                                                                     }             if (_currentDay >= daysPerEra) {                                                                                 // If time passed the next Era time                 _currentEra += 1; _currentDay = 0;                                                                        // Increment Era, reset Day                 nextEraTime = _now + (secondsPerDay * daysPerEra);                                          // Set next Era time                 _emission = getNextEraEmission();                                                                        // Get correct emission                 mapEra_Emission[currentEra] = _emission;                                                           // Map emission to Era                 emit NewEra(_currentEra, _emission, nextEraTime, totalBurnt);                            // Emit Event             }             _currentDay += 1;                                                                                                     // Increment Day             nextDayTime = _now + secondsPerDay;                                                                  // Set next Day time             _emission = getDayEmission();                                                                                // Check daily Dmission             mapEraDay_EmissionRemaining[_currentEra][_currentDay] = _emission;               // Map emission to Day             uint _era = _currentEra;             uint _day = _currentDay - 1;             if (_currentDay == 1) {                 // new era                 _era = _currentEra - 1;                 _day = daysPerEra;             }              currentDay = _currentDay;             currentEra = _currentEra;             emission = _emission;                 emit NewDay(_currentEra, _currentDay, nextDayTime, mapEraDay_Units[_era][_day], mapEraDay_MemberCount[_era][_day]);         }     } </code>   "}, {"title": "Vesting.revoke is missing a require statement", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/116", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  Reigada   # Vulnerability details  ## Impact In the Vesting contract, the function revoke() sends the vested tokens to the beneficiary and the remaining tokens that are not vested yet are sent to the multisig address. It makes no sense to allow calling this function once the address has already vested the 100% of the tokens (after 1 year in this case -> uint256 _unlockTimestamp = block.timestamp.add(unixYear);).  Basically in this case the function revoke() would behave like a claim() function but doing some extra checks which waste gas (gas paid by the owner of the contract instead of the beneficiary address) and also emitting an extra event -> https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L123  For that reason, it is recommended to add a require statement that handles this case:  uint256 index = timelocks[_addr].length - 1; require (block.timestamp < timelocks[_addr][index].releaseTimestamp, 'Account fully vested');  ## Tools Used Manual testing  ## Recommended Mitigation Steps It is recommended to add a require statement that handles this case in the Vesting.revoke() function:  uint256 index = timelocks[_addr].length - 1; require (block.timestamp < timelocks[_addr][index].releaseTimestamp, 'Account fully vested');  "}, {"title": "Unnecessary require statement in vesting.claim()", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/115", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  Reigada   # Vulnerability details  ## Impact There is an unnecessary require statement in vesting.claim() -> https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L197  This check is already done in https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L186  ## Tools Used Manual testing  ## Recommended Mitigation Steps Remove the require statement in the claim() function as it is totally unnecessary. The check is already performed in the function _claimableAmount(address _addr).  "}, {"title": "Use of uint256 parameter instead of bool", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/112", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  Reigada   # Vulnerability details  ## Impact In the contract Vesting, function vest(), the parameter _isRevocable is declared as an uint256 when it is used as a boolean.  ## Proof of Concept https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L77  ## Tools Used Manual review  ## Recommended Mitigation Steps Declare the parameter _isRevocable as a bool.  "}, {"title": "Check ERC20 token `approve()` function return value", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/109", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  Ruhum   # Vulnerability details  ## Impact With version 4.x of the ERC20 token, the `approve()` function returns a boolean indicating whether it was successful or not.  https://docs.openzeppelin.com/contracts/4.x/api/token/erc20#IERC20-approve-address-uint256-  Best practice is to either check the return value or use `safeApprove()` / `safeIncreaseAllowance()` which will revert if the operation was unsuccessful  https://docs.openzeppelin.com/contracts/4.x/api/token/erc20#SafeERC20-safeApprove-contract-IERC20-address-uint256-  ## Proof of Concept https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/AirdropDistribution.sol#L499  https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol#L80  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps use `safeApprove()` or `safeIncreaseAllowance()`  "}, {"title": "Tokens not recoverable", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/108", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  Reigada   # Vulnerability details  ## Impact In both airdrop contracts: AirdropDistribution and InvestorDistribution, once all the participants have claimed their tokens, some will remain in the contract due to some imprecision in the calculations. There is no function that allows to substract them which means that those tokens will remain stuck in the contracts forever.  I have made the test with just 5 participants: user2, user3, user4, user5 & user6.  uint256[5] airdropBalances =     [     4032000,     4032000,     4032000,     4032000,     4032000     ];  >>> 4032000 * 5 20160000  Initially 20160000 tokens were transferred to the contract  mockToken.transfer(airdropdist.address, 20160000000000000000000000)  After 260 weeks, these were the results:  ----------------> mockToken.balanceOf(airdropdist.address) -> 2842805668532461833600 <-----------------  mockToken.balanceOf(user2) -> 1209429431659888052289865 vesting.benTotal(user2.address) -> 2822002007206405455343415 mockToken.balanceOf(user3) -> 1209429431659888052289984 vesting.benTotal(user3.address) -> 2822002007206405455343296 mockToken.balanceOf(user4) -> 1209429431659888052289984 vesting.benTotal(user4.address) -> 2822002007206405455343296 mockToken.balanceOf(user5) -> 1209429431659888052289984 vesting.benTotal(user5.address) -> 2822002007206405455343296 mockToken.balanceOf(user6) -> 1209429431659888052289984 vesting.benTotal(user6.address) -> 2822002007206405455343296  As we can see above 2842 tokens remain in the contract and there is no way to retrieve them.  ## Tools Used Manual testing / brownie  ## Recommended Mitigation Steps Add an onlyOwner function that allows to retrieve all the remaining tokens once all the participants of the airdrop have claimed the whole amount of their rewards.  "}, {"title": "Incorrect event parameter used in emit", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/105", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-11-bootfinance-findings", "body": "Incorrect event parameter used in emit"}, {"title": "Using ++i consumes less gas than i++", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/104", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-bootfinance-findings", "body": "Using ++i consumes less gas than i++"}, {"title": "Airdrop Supply differs", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/99", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  fr0zn   # Vulnerability details  ## Vulnerability Details On the `AirdropDistribution.sol`, the `airdrop_supply` ([line 462](https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/AirdropDistribution.sol#L462)) value is set to be `20160000`. However, adding all the `airdropBalances` does show that the value should be `20159997` instead.   ## Impact This does cause some operations on the contract to mislead in the results. This is more noticed on bigger airdropped accounts.  ## Proof of Concept Adding all the `airdropBalances` values do show the difference.  ## Tools Used Manual code review  ## Recommended Mitigation Steps The `airdrop_supply` should be reflecting the actual airdropped balance without misleading the total amount. Change the value to `20159997`.  "}, {"title": "Don't allow swapping the same token", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/89", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-11-bootfinance-findings", "body": "Don't allow swapping the same token"}, {"title": "Redundant check on claim", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/97", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  fr0zn   # Vulnerability details  ## Vulnerability Details On the `claim` function ([line 524](https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/AirdropDistribution.sol#L524))  of the `AirdropDistribution.sol` contract, the `validated` check is redundant. The flag is only set when the `validate` function is called. Once validated, the amount will always be different than zero, meaning that the check is not necessary.  ## Impact Gas optimization  ## Tools Used Manual code review  ## Recommended Mitigation Steps The check could be removed for gas optimization.  "}, {"title": "Duplicated code and usage of assert", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/96", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  fr0zn   # Vulnerability details  ## Vulnerability Details The `_available_supply` and `available_supply` functions on the `AirdropDistribution` (lines [601](https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/AirdropDistribution.sol#L601) and [607](https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/AirdropDistribution.sol#L607)) do contain the exact same code.  Furthermore, the `assert` check inside those functions should be changed to a require statement since the check is not an invariant and gas refund should take place if the check fails ([SWC-110](https://swcregistry.io/docs/SWC-110)).  ## Impact Gas optimization  ## Tools Used Manual code review  ## Recommended Mitigation Steps The `available_supply` and `_available_supply` functions should be combined into a single public function (public functions can be used internally without any extra gas) or have the public function call the internal implementation and use the private implementation in the contract.  The `assert` check in the `available_supply` function should be changed to a require statement since the check is not an invariant.  "}, {"title": "Gas optimization on InvestorDistribution.sol", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/94", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  fr0zn   # Vulnerability details  ## Vulnerability Details The `InvestorDistribution` ([InvestorDistribution.sol](https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol)) contract does contain some statements that could be removed to optimize the gas usage.  ## Impact Gas optimization  ## Tools Used Manual code review  ## Recommended Mitigation Steps - Variable set on [Line 77](https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol#L77) can be removed since the implicit value is already zero - On lines 106 and 107 ([here](https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol#L106-L107)), the statement could be changed to a single line containing `delete investors[_investor]`.  "}, {"title": "Invalid return value when calculating claimable amount ", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/92", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-11-bootfinance-findings", "body": "Invalid return value when calculating claimable amount "}, {"title": "State variables could be declared constant", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/88", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  PranavG   # Vulnerability details  ## Impact State variables that never change can be declared constant. This can greatly reduce gas costs. Examples : airdrop_supply in AirdropDistribution.sol(#462) investors_supply in InvestorDistribution.sol(#33)  unixYear in Vesting.sol(#30)  ## Recommended Mitigation Steps Add the constant keyword for state variables whose value never change.  "}, {"title": "Unnecessary imports", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/91", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "Unnecessary imports"}, {"title": "Vesting contract locks tokens for less time than expected", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/82", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  TomFrench   # Vulnerability details  ## Impact  Tokens are locked for 1 day less than specified in spec.  ## Proof of Concept  The vesting period is calculated here in `unixYear`  https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/vesting/contracts/Vesting.sol#L30  This results in a lockup of 364 days rather than the expected 365.  ## Recommended Mitigation Steps  Replace line with `uint256 constant private unixYear = 365 days;`   "}, {"title": "`GaugeController.commit_transfer_ownership()` emits `CommitOwnership` events when the future admin hasn't changed", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/81", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pants   # Vulnerability details  The function `GaugeController.commit_transfer_ownership()` emits `CommitOwnership` events when the future admin hasn't changed and left as it was before that transaction.  ## Impact There is no reason to emit these `CommitOwnership` events because nothing has changed in the system. Such events are only going to confuse users.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit these events only when the new future admin is different than the old one.  "}, {"title": "`GaugeController.apply_transfer_ownership()` emits `ApplyOwnership` events when the admin hasn't changed", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/80", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pants   # Vulnerability details  The function `GaugeController.apply_transfer_ownership()` emits `ApplyOwnership` events when the admin hasn't changed and left as it was before that transaction.  ## Impact There is no reason to emit these `ApplyOwnership` events because nothing has changed in the system. Such events are only going to confuse users.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit these events only when the new admin is different than the old one.  "}, {"title": "Missing emit of initial `ApplyOwnership` event in `GaugeController.__init__()`", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/79", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pants   # Vulnerability details  The function `GaugeController.__init__()` (the constructor) sets the initial admin, but it doesn't emit an appropriate `ApplyOwnership` event.  ## Impact The users won't know who's the initial admin by searching for the first `ApplyOwnership` event, although they should be able to.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit this event.  "}, {"title": "Missing emit of initial `SetAdmin` event in `MainToken.__init__()`", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/78", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pants   # Vulnerability details  The function `MainToken.__init__()` (the constructor) sets the initial admin, but it doesn't emit an appropriate `SetAdmin` event.  ## Impact The users won't know who's the initial admin by searching for the first `SetAdmin` event, although they should be able to.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit this event.  "}, {"title": "`LPToken.approve()` emits `Approval` events when the allowance hasn't changed", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/73", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pants   # Vulnerability details  The function `LPToken.approve()` emits `Approval` events when the allowance hasn't changed and left as it was before that transaction.  ## Impact There is no reason to emit these `Approval` events because nothing has changed in the system. Such events are only going to confuse users.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit these events only when the new allowance is different than the old one.  "}, {"title": "`LPToken.transferFrom()` emits `Transfer` events when `_from` equals `_to`", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/71", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pants   # Vulnerability details  The function `LPToken.transferFrom()` emits `Transfer` events when `_from` equals `_to`.  ## Impact There is no reason to emit these `Transfer` events because nothing has changed in the system. Such events are only going to confuse users.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit these events only when `_from` doesn't equal `_to`.  "}, {"title": "`LPToken.transfer()` and `LPToken.transferFrom()` emit `Transfer` events when the transferred amount is zero", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/70", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pants   # Vulnerability details  The functions `LPToken.transfer()` and `LPToken.transferFrom()` emit `Transfer` events when the transferred amount is zero.  ## Impact There is no reason to emit these `Transfer` events because nothing has changed in the system. Such events are only going to confuse users.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit these events only when the transferred amount is not zero.  "}, {"title": "`LPToken.set_minter()` doesn't check that `_minter` doesn't equal zero", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/69", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pants   # Vulnerability details  The function `LPToken.set_minter()` doesn't check that `_minter` doesn't equal zero before it sets it as the new minter.  ## Impact This function can be invoked by mistake with the zero address as `_minter`, causing the system to lose its minter forever, without the option to set a new minter.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Check that `_minter` doesn't equal zero before setting it as the new minter.  "}, {"title": "`LPToken.__init__()` emits `Transfer` events when the amount minted for `msg.sender` is zero", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/68", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pants   # Vulnerability details  The function `LPToken.__init__()` (the constructor) emits `Transfer` events when the amount minted for `msg.sender` is zero.  ## Impact There is no reason to emit these `Transfer` events because nothing has changed in the system. Such events are only going to confuse users.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit these events only when the amount minted for `msg.sender` is not zero.  "}, {"title": "`MainToken.__init__()` emits `Transfer` events when the amount minted for `msg.sender` is zero (and it is always the case)", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/67", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pants   # Vulnerability details  The function `MainToken.__init__()` (the constructor) emits `Transfer` events when the amount minted for `msg.sender` is zero. This is always the case, as the value of the constant `INITIAL_SUPPLY` is zero.  ## Impact There is no reason to emit these `Transfer` events because nothing has changed in the system. Such events are only going to confuse users.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit these events only when the amount minted for `msg.sender` is not zero.  "}, {"title": "`MainToken.set_mint_multisig()` doesn't check that `_minting_multisig` doesn't equal zero", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/66", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pants   # Vulnerability details  The function `MainToken.set_mint_multisig()` doesn't check that `_minting_multisig` doesn't equal zero before it sets it as the new `minting_multisig`.  ## Impact This function can be invoked by mistake with the zero address as `_minting_multisig`, causing the system to lose its `minting_multisig` forever, without the option to set a new `minting_multisig`.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Check that `_minting_multisig` doesn't equal zero before setting it as the new `minting_multisig`.  "}, {"title": "`MainToken.set_mint_multisig()` emits `SetMintMultisig` events when `minting_multisig` hasn't changed", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/64", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pants   # Vulnerability details  The function `MainToken.set_mint_multisig()` emits `SetMintMultisig` events when `minting_multisig` hasn't changed, and left as it was before that transaction.  ## Impact There is no reason to emit these `SetMintMultisig` events because nothing has changed in the system. Such events are only going to confuse users.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit these events only when the new `minting_multisig` is different than the old one.  "}, {"title": "`MainToken.set_admin()` emits `SetAdmin` events when the admin hasn't changed", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/63", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pants   # Vulnerability details  The function `MainToken.set_admin()` emits `SetAdmin` events when the admin hasn't changed and left as it was before that transaction.  ## Impact There is no reason to emit these `SetAdmin` events because nothing has changed in the system. Such events are only going to confuse users.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit these events only when the new admin is different than the old one.  "}, {"title": "`MainToken.set_minter()` emits `SetMinter` events when the minter hasn't changed", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/62", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pants   # Vulnerability details  The function `MainToken.set_minter()` emits `SetMinter` events when the minter hasn't changed and left as it was before that transaction.  ## Impact There is no reason to emit these `SetMinter` events because nothing has changed in the system. Such events are only going to confuse users.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit these events only when the new minter is different than the old one.  "}, {"title": "`MainToken.burn()` emits `Transfer` events when the burned amount is zero", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/61", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pants   # Vulnerability details  The function `MainToken.burn()` emits `Transfer` events when the burned amount is zero.  ## Impact There is no reason to emit these `Transfer` events because nothing has changed in the system. Such events are only going to confuse users.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit these events only when the burned amount is not zero.  "}, {"title": "`MainToken.mint()` and `MainToken.mint_dev()` emit `Transfer` events when the minted amount is zero", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/60", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pants   # Vulnerability details  The functions `MainToken.mint()` and `MainToken.mint_dev()` emit `Transfer` events when the minted amount is zero.  ## Impact There is no reason to emit these `Transfer` events because nothing has changed in the system. Such events are only going to confuse users.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit these events only when the minted amount is not zero.  "}, {"title": "`MainToken.approve()` emits `Approval` events when the allowance hasn't changed", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/54", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pants   # Vulnerability details  The function `MainToken.approve()` emits `Approval` events when the allowance hasn't changed and left as it was before that transaction.  ## Impact There is no reason to emit these `Approval` events because nothing has changed in the system. Such events are only going to confuse users.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit these events only when the new allowance is different than the old one.  "}, {"title": "`MainToken.transferFrom()` emits `Transfer` events when `_from` equals `_to`", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/52", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pants   # Vulnerability details  The function `MainToken.transferFrom()` emits `Transfer` events when `_from` equals `_to`.  ## Impact There is no reason to emit these `Transfer` events because nothing has changed in the system. Such events are only going to confuse users.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit these events only when `_from` doesn't equal `_to`.  "}, {"title": "`MainToken.transfer()` and `MainToken.transferFrom()` emit `Transfer` events when the transferred amount is zero", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/51", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pants   # Vulnerability details  The functions `MainToken.transfer()` and `MainToken.transferFrom()` emit `Transfer` events when the transferred amount is zero.  ## Impact There is no reason to emit these `Transfer` events because nothing has changed in the system. Such events are only going to confuse users.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit these events only when the transferred amount is not zero.  "}, {"title": "`PoolGauge.withdraw()` emits `Withdraw` events when the withdrawn amount is zero", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/49", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pants   # Vulnerability details  The function `PoolGauge.withdraw()` emits `Withdraw` events when the withdrawn amount is zero.  ## Impact There is no reason to emit these `Withdraw` events because nothing has changed in the system. Such events are only going to confuse users.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit these events only when the withdrawn amount is not zero.  "}, {"title": "`PoolGauge.deposit()` emits `Deposit` events when the deposited amount is zero", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/48", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pants   # Vulnerability details  The function `PoolGauge.deposit()` emits `Deposit` events when the deposited amount is zero.  ## Impact There is no reason to emit these `Deposit` events because nothing has changed in the system. Such events are only going to confuse users.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit these events only when the deposited amount is not zero.  "}, {"title": "`PoolGauge.withdraw()` can be optimized when `_value` equals zero", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/47", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pants   # Vulnerability details  The function `PoolGauge.withdraw()` doesn't have to execute these lines of code when `_value` equals zero: ``` _balance: uint256 = self.balanceOf[msg.sender] - _value _supply: uint256 = self.totalSupply - _value self.balanceOf[msg.sender] = _balance self.totalSupply = _supply  self._update_liquidity_limit(msg.sender, _balance, _supply)  assert ERC20(self.lp_token).transfer(msg.sender, _value) ```  ## Impact There is no reason to execute these lines of code if `_value` equals zero because they won't affect the system. An identical optimization is already implemented in `PoolGauge.deposit()`.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Execute these lines of code only if `_value` doesn't equal zero.  "}, {"title": "`Token.approve()` emits `Approval` events when the allowence hasn't changed", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/46", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pants   # Vulnerability details  The function `Token.approve()` emits `Approval` events when the allowance hasn't changed and left as it was before that transaction.  ## Impact There is no reason to emit these `Approval` events because nothing has changed in the system. Such events are only going to confuse users.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit these events only when the new allowance is different than the old one.  "}, {"title": "`Token.transferFrom()` emits `Transfer` events when `_from` equals `_to`", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/44", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pants   # Vulnerability details  The function `Token.transferFrom()` emits `Transfer` events when `_from` equals `_to`.  ## Impact There is no reason to emit these `Transfer` events because nothing has changed in the system. Such events are only going to confuse users.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit these events only when `_from` doesn't equal `_to`.  "}, {"title": "`Token.transfer()` and `Token.transferFrom()` emit `Transfer` events when the transferred amount is zero", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/43", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pants   # Vulnerability details  The functions `Token.transfer()` and `Token.transferFrom()` emit `Transfer` events when the transferred amount is zero.  ## Impact There is no reason to emit these `Transfer` events because nothing has changed in the system. Such events are only going to confuse users.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Emit these events only when the transferred amount is not zero.  "}, {"title": "Array out-of-bounds errors in `USDPoolDelegator`", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/39", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pants   # Vulnerability details  The functions `USDPoolDelegator.balances()`, `USDPoolDelegator.coins()` and `USDPoolDelegator.underlying_coins()` accept an argument called `i` and use it as an index to determine which element in the `_balances` / `_coins` / `_underlying_coins` array should be loaded and returned. However, these functions don't check that the index they receive as an argument actually fits the bounds of the array.  ## Impact If the index exceeds the array length, there will be a revert with no informative error message. The user wouldn't know what caused the revert.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Add an appropriate require statement to each of these functions to validate that the given argument fits the `_balances` / `_coins` / `_underlying_coins` array bounds.  "}, {"title": "Array out-of-bounds errors in `ETHPoolDelegator`", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/38", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pants   # Vulnerability details  The functions `ETHPoolDelegator.balances()` and `ETHPoolDelegator.coins()` accept an argument called `i` and use it as an index to determine which element in the `_balances` / `_coins` array should be loaded and returned. However, these functions don't check that the index they receive as an argument actually fits the bounds of the array.  ## Impact If the index exceeds the array length, there will be a revert with no informative error message. The user wouldn't know what caused the revert.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Add an appropriate require statement to each of these functions to validate that the given argument fits the `_balances` / `_coins` array bounds.  "}, {"title": "Array out-of-bounds errors in `BTCPoolDelegator`", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/37", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pants   # Vulnerability details  The functions `BTCPoolDelegator.balances()` and `BTCPoolDelegator.coins()` accept an argument called `i` and use it as an index to determine which element in the `_balances` / `_coins` array should be loaded and returned. However, these functions don't check that the index they receive as an argument actually fits the bounds of the array.  ## Impact If the index exceed the array length, there will be a revert with no informative error message. The user wouldn't know what caused the revert.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Add an appropriate require statement to each of these functions to validate that the given argument fits the `_balances` / `_coins` array bounds.  "}, {"title": "No Transfer Ownership Pattern", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/35", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "No Transfer Ownership Pattern"}, {"title": "If statement in _updateEmission() can be removed", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/34", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  Reigada   # Vulnerability details  ## Impact The if statement in _updateEmission() can be removed as the condition is already checked in updateEmission() https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/AirdropDistribution.sol#L596 https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/InvestorDistribution.sol#L186  ## Proof of Concept     function _updateEmission() private {         if (block.timestamp >= startEpochTime + RATE_TIME) {             miningEpoch += 1;             startEpochTime = startEpochTime.add(RATE_TIME);             startEpochSupply = startEpochSupply.add(rate.mul(RATE_TIME));              if (miningEpoch < INITIAL_RATE_EPOCH_CUTTOF) {                 rate = rate.mul(EPOCH_INFLATION).div(100000);             }             else {                 rate = 0;             }             emit updateMiningParameters(block.timestamp, rate, startEpochSupply);         }     }      //Update emission to be called at every step change to update emission inflation     function updateEmission() public {         require(block.timestamp >= startEpochTime + RATE_TIME, \"Too soon\"); // Condition already checked here         _updateEmission();     }  ## Tools Used Manual testing  ## Recommended Mitigation Steps Remove the if condition in the _updateEmission() private function  "}, {"title": "Lack of maximum and minimum vesting amount check on the vesting function", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/32", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  defsec   # Vulnerability details  ## Impact  During the code review, It has been seen maxVesting amount is disabled. However, there is no maximum and minimum vesting amount defined. Users can vest small amount. For the protocol liquditiy calculation maximum and minimum threshold should be defined.   ## Proof of Concept  1. Navigate to the following contract.  \"\"\" https://github.com/code-423n4/2021-11-bootfinance/blob/main/vesting/contracts/Vesting.sol#L76 \"\"\"  2. Vesting amount didnt check.  ## Tools Used  Review  ## Recommended Mitigation Steps  It is suggested to check maximum/minimum vesting amount on the contract.   "}, {"title": "Unchecked transfers", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/31", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Lines of code  https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/Comptroller.sol#L1380 https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/Accountant/AccountantDelegate.sol#L87 https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/Accountant/AccountantDelegate.sol#L89 https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/Treasury/TreasuryDelegate.sol#L52 https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/Treasury/TreasuryDelegate.sol#L56 https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/CErc20.sol#L128 https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/CEther.sol#L150 https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/Treasury/TreasuryDelegate.sol#L52 https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/Treasury/TreasuryDelegate.sol#L56   # Vulnerability details  ## Impact Multiple calls to transfer are frequently done without checking the results. For certain ERC20 tokens, if insufficient tokens are present, no revert occurs but a result of \u201cfalse\u201d is returned. It\u2019s important to check this, users or admin could gain or lose tokens if return value of transfer() is not checked.  The following functions are affected: Comptroller.grantCompInternal() - https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/Comptroller.sol#L1380 AccountantDelegate.sweepInterest() - https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/Accountant/AccountantDelegate.sol#L87 AccountantDelegate.sweepInterest() - https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/Accountant/AccountantDelegate.sol#L89 TreasuryDelegate.sendFund() - https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/Treasury/TreasuryDelegate.sol#L52 TreasuryDelegate.sendFund() - https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/Treasury/TreasuryDelegate.sol#L56 CErc20.sweepToken() - https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/CErc20.sol#L128 CEther.doTransferOut() - https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/CEther.sol#L150 TreasuryDelegate.sendFund() - https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/Treasury/TreasuryDelegate.sol#L52 TreasuryDelegate.sendFund() - https://github.com/Plex-Engineer/lending-market/blob/755424c1f9ab3f9f0408443e6606f94e4f08a990/contracts/Treasury/TreasuryDelegate.sol#L56  ## Tools Used Slither and manual review  ## Recommended Mitigation Steps Check the returned values of transfers or use a SafeERC20 transfer.  "}, {"title": "Upgrade pragma to at least 0.8.4", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/29", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "Upgrade pragma to at least 0.8.4"}, {"title": "getEmissionShare Can Be Rewritten To Be More Efficient (PublicSale.sol)", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/28", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  ye0lde   # Vulnerability details  ## Impact  getEmissionShare Can Be Rewritten To Be More Efficient (PublicSale.sol)  The \"else\" and returning 0, can be eliminated.  The existing but unused named return variable \"value\" can be used instead of a return statement. These changes reduce gas and improve code clarity.  ## Proof of Concept  The getEmissionShare function is here: https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/tge/contracts/PublicSale.sol#L231-L245  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps I recommend rewriting it as follows: <code>     function getEmissionShare(uint era, uint day, address member) public view returns (uint value) {           uint memberUnits = mapEraDay_MemberUnits[era][day][member];                         // Get Member Units                  if (memberUnits != 0) {             uint totalUnits = mapEraDay_UnitsRemaining[era][day];                           // Get Total Units             uint emissionRemaining = mapEraDay_EmissionRemaining[era][day];     // Get emission remaining for Day             uint balance = mainToken.balanceOf(address(this));             if (emissionRemaining > balance) {                 emissionRemaining = balance;                                                // In case less than required emission             }             value = (emissionRemaining * memberUnits) / totalUnits;         // Calculate share         }     }    </code>  "}, {"title": "_processWithdrawal Can Be Rewritten To Be More Efficient (PublicSale.sol)", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/27", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  ye0lde   # Vulnerability details  ## Impact  _processWithdrawal Can Be Rewritten To Be More Efficient (PublicSale.sol)  The \"else\", the setting of \"value to 0\", and the return statement can be eliminated to reduce gas and improve code clarity.  ## Proof of Concept  The _processWithdrawal function is here: https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/tge/contracts/PublicSale.sol#L212-L229  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps I recommend rewriting it as follows: <code>     function _processWithdrawal (uint _era, uint _day, address _member) private returns (uint value) {           uint memberUnits = mapEraDay_MemberUnits[_era][_day][_member]; // Get Member Units                  if (memberUnits != 0) {             value = getEmissionShare(_era, _day, _member);          // Get the emission Share for Member             mapEraDay_MemberUnits[_era][_day][_member] = 0;  // Set to 0 since it will be withdrawn             mapEraDay_UnitsRemaining[_era][_day] = mapEraDay_UnitsRemaining[_era][_day].sub(memberUnits);  // Decrement Member Units             mapEraDay_EmissionRemaining[_era][_day] = mapEraDay_EmissionRemaining[_era][_day].sub(value);  // Decrement emission             totalEmitted += value;                                                 // Add to Total Emitted             uint256 v_value = value * 3 / 10;                                 // Transfer 30%, lock the rest in vesting contract                          mainToken.transfer(_member, v_value);                      // ERC20 transfer function             vestLock.vest(_member, value - v_value, 0);             emit Withdrawal(msg.sender, _member, _era, _day, value, mapEraDay_EmissionRemaining[_era][_day]);         }     } </code>  "}, {"title": "_withdrawShare Can Be Rewritten To Be More Efficient (PublicSale.sol)", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/26", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  ye0lde   # Vulnerability details  ## Impact  The \"else if\", the second call to _processWithdrawal, and the return statement can be eliminated to reduce gas and improve code clarity.  ## Proof of Concept  The _withdrawShare function is here: https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/tge/contracts/PublicSale.sol#L201-L210  ## Tools Used Visual Studio Code  ## Recommended Mitigation Steps I recommend rewriting it as follows: <code>  function _withdrawShare (uint _era, uint _day, address _member) private returns (uint value) {  _updateEmission();    if (_era < currentEra ||                                                          // Allow if in previous Era                                                                          (_era == currentEra && _day < currentDay)) {                // or current Era and previous day    value = _processWithdrawal(_era, _day, _member);   // Process Withdrawal      }   } </code>  "}, {"title": "Unused Named Returns (PublicSale.sol)", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/25", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  ye0lde   # Vulnerability details  ## Impact  Removing unused named return variables can reduce gas usage and improve code clarity.  ## Proof of Concept  https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/tge/contracts/PublicSale.sol#L187 https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/tge/contracts/PublicSale.sol#L194 https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/tge/contracts/PublicSale.sol#L231  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps Remove the unused named returns  "}, {"title": "Long Revert Strings", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/23", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "Long Revert Strings"}, {"title": "Unnecessary \"else if\" in function vest (Vesting.sol)", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/22", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  ye0lde   # Vulnerability details  ## Impact  The \"else if(_isRevocable == 1)\" is not needed and can be removed to save gas and improve code clarity.  ## Proof of Concept  The \"_isRevocable\" variable is guaranteed to be 0 or 1 here: https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/vesting/contracts/Vesting.sol#L77  But it is treated like it can have some other value here: https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/vesting/contracts/Vesting.sol#L83-L88  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps Rewrite these lines https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/vesting/contracts/Vesting.sol#L83-L88 to <code>  benRevocable[_beneficiary] = (_isRevocable == 0) ? [false,false] : [true,false]; </code>  "}, {"title": "internal functions could be set private", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/18", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pants   # Vulnerability details  Since no contract inherent from SwapUtils all internal functions could be set private. For example  getD could be set private to save gas.  "}, {"title": "optimizing for loops by caching array length", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/14", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pants   # Vulnerability details  optimizing for loops by caching memory array length, instead of calling it every time.  For example at Swap.sol at time 158 you should have  uint8 len = _pooledTokens.length and in the next line define the forloop with stop condition of  i<len  This appears in many places in the code. At some places you did cached the array length correctly.   "}, {"title": "double reading of memory inside a loop without caching", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/13", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pants   # Vulnerability details  When double reading a variable from memory the gas efficient way is to cache it and use the cached value.   For example in line 537, 538 of SwapUtils.sol you have two accesses to xp[i]. You can save xp[i] as local variable and then use it instead at the second time.  "}, {"title": "admin can override investor and stuck its funds in the system ", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/11", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pants   # Vulnerability details  An admin can (by mistake maybe) addInvestor with address that already exists. This way its funds are locked in the system and cannot be withdrawn, even by the admin.    "}, {"title": "multiple reading of state variables without caching", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/9", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pants   # Vulnerability details  In InvestorDistribution line 103 you read investors[_investor] multiple times (only at this function investors[_investor] is read 6 times). You could cache the value and call the cached value instead. Investors x = investors[_investor]; And then use x.amount, x.claimed, etc.  "}, {"title": "too many bits to describe small quantities ", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/8", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pants   # Vulnerability details  In InvestorDistribution you generally use uint256 for every quantity, although 256 bits are much more than necessary. For example for Investor structure you can change all to uint128, and for every normal use it will not affect and save gas.  "}, {"title": "Unnecessary use of safeMath", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/7", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  pants   # Vulnerability details  In InvestorDistribution at line 19 you have      using SafeMath for uint256;  although you use solidity >0.8.0 therefore you don't need to use safeMath for uint256  "}, {"title": "Numerous gas optimizations in SwapUtils.sol", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/6", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  tqts   # Vulnerability details  ## Impact Several references to storage can be cached to save significant amounts of gas.  ## Proof of Concept File lines are stated in Mitigation Steps.  ## Tools Used Manual review   ## Recommended Mitigation Steps  #### In function calculateWithdrawOneTokenDY (L406) ``` uint256 _pooledTokensLength = self.pooledTokens.length; ``` The value is used twice, so one SLOAD is saved.  #### In function _calculateRemoveLiquidity (L953) ``` uint256 _pooledTokensLength = self.pooledTokens.length; ``` The value is used twice, one of those as condition in a for loop, so at least _pooledTokensLength SLOADS are saved.  #### In function _feePerToken (L1080) ``` uint256 _pooledTokensLength = self.pooledTokens.length; ``` The value is used twice, so one SLOAD is saved.  #### In function swap (L1098) ``` IERC20 tokenFrom = self.pooledTokens[tokenIndexFrom]; ``` The value is used 4 times, so 3 SLOADs are saved. However, this causes a stack too deep error in line 1129. To mitigate this, replace lines 1129-1132 for: ``` uint256 dyAdminFee = dyFee.mul(self.adminFee).div(FEE_DENOMINATOR);         dyAdminFee = dyAdminFee.div(self.tokenPrecisionMultipliers[tokenIndexTo]); ```  #### In function addLiquidity (L1163) ``` uint256 _pooledTokensLength = self.pooledTokens.length; uint256 _lpTokenTotalSupply = self.lpToken.totalSupply(); ``` _pooledTokensLength is used 4 times. 3 SLOADs saved. _lpTokenTotalSupply is used 6 times, however the one in line 1266 is called after a mint() so it's not the same value and thus can't be replaced. 4 SLOADs saved.  #### In function _updateUserWithdrawFee (L1290) ``` uint256 _withdrawFee = self.defaultWithdrawFee; ``` The value is used 3 times, so 2 SLOADs are saved.  #### In function removeLiquidityImbalance (L1415) ``` uint256 _pooledTokensLength = self.pooledTokens.length; ``` The value is used 5 times, twice as a for condition, so at least 2 + _pooledTokensLength SLOADs are saved.  "}, {"title": "No need to initialize variables with default values", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/5", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  jah   # Vulnerability details  ## Impact  If a variable is not set/initialized, it is assumed to have the default value (0, false, 0x0 etc depending on the data type). If you explicitly initialize it with its default value, you are just wasting gas. ## Proof of Concept https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/core-contracts/contracts/sol/BTCPoolDelegator.sol#L77 https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/core-contracts/contracts/sol/ETHPoolDelegator.sol#L77 https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/core-contracts/contracts/sol/USDPoolDelegator.sol#L66  https://blog.polymath.network/solidity-tips-and-tricks-to-save-gas-and-reduce-bytecode-size-c44580b218e6  ## Tools Used Manual analysis  ## Recommended Mitigation Steps  "}, {"title": "Redundant check", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/2", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  tqts   # Vulnerability details  ## Impact According to the comment in line 148 of Swap.sol, the function checks for _pooledTokens and precisions parameters, however, the require at line 151 is redundant, as it will pass if both previous checks passed.  ## Proof of Concept https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/customswap/contracts/Swap.sol#L151  ## Tools Used  ## Recommended Mitigation Steps Remove the require, or change it to validate the correct precision parameters.  "}, {"title": "No usage of immutable keyword leaves free gas savings on the table", "html_url": "https://github.com/code-423n4/2021-11-bootfinance-findings/issues/1", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-bootfinance-findings", "body": "# Handle  TomFrench   # Vulnerability details  ## Impact  Increased gas costs + risk of accidental changes to values expected to be fixed.  ## Proof of Concept  Several contracts contain variables which are set at deploy time and never changed again. For example see `PublicSale.sol`  https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/tge/contracts/PublicSale.sol#L70-L81  Since solidity 0.6.5, variables can be marked `immutable` which avoids the need for SLOADs when reading these variables - decreasing gas costs and protecting against accidentally modifying these variables.  https://blog.soliditylang.org/2020/05/13/immutable-keyword/#:~:text=With%20version%200.6.,time%20of%20a%20deployed%20contract.  ## Tools Used  Manual inspection  ## Recommended Mitigation Steps  Inspect all contracts for variables which are set once and then never modified, apply `immutable` keyword and adjust constructors to not read these values (instead use passed parameters)  "}, {"title": "Migrate from NonFungiblePositionManager to UniV3Pool directly", "html_url": "https://github.com/code-423n4/2021-12-mellow-findings/issues/133", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-12-mellow-findings", "body": "Migrate from NonFungiblePositionManager to UniV3Pool directly"}, {"title": "Make deposit efficient ", "html_url": "https://github.com/code-423n4/2021-12-mellow-findings/issues/132", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-12-mellow-findings", "body": "Make deposit efficient "}, {"title": "What you guys mean by this line ? Its redundant imo", "html_url": "https://github.com/code-423n4/2021-12-mellow-findings/issues/130", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2021-12-mellow-findings", "body": "# Handle  0x421f   # Vulnerability details  This one  https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/YearnVault.sol#L99  Its maybe gap in my knowledge, but I have never seen this pattern  What it does ?  "}, {"title": "No need of separate indexing (NFT_ID => Vault Address)", "html_url": "https://github.com/code-423n4/2021-12-mellow-findings/issues/129", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-12-mellow-findings", "body": "# Handle  0x421f   # Vulnerability details  If we see vault registry   https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/VaultRegistry.sol#L18  There are two mappings on L18 and L19  On 18 its map(address) => nftID, which is fine  but one on 19. we can remove,  Nft IDs are incremental, and are stored in same position in _vaults[] array so it can be accessed like for id of x => _vaults[x-1]  with this we dont need to maintain it whenever new vault is deployed, again saving gas cost :)  "}, {"title": "Skip initialization of factory address in vault governance by predicting it before hand", "html_url": "https://github.com/code-423n4/2021-12-mellow-findings/issues/127", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-12-mellow-findings", "body": "Skip initialization of factory address in vault governance by predicting it before hand"}, {"title": "Save Gas With The Unchecked Keyword", "html_url": "https://github.com/code-423n4/2021-12-mellow-findings/issues/123", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-12-mellow-findings", "body": "Save Gas With The Unchecked Keyword"}, {"title": " Constant variables can be immutable (DefaultAccessControl.sol)", "html_url": "https://github.com/code-423n4/2021-12-mellow-findings/issues/122", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-12-mellow-findings", "body": "# Handle  ye0lde   # Vulnerability details  ## Impact  Changing the variables from constant to immutable will reduce keccak operations and save gas.  ## Proof of Concept  The variables that can be changed from `constant` to `immutable` are here: https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/contracts/DefaultAccessControl.sol#L11-L12  A previous finding with additional explanation and a pointer to the Ethereum/solidity issue is here: https://github.com/code-423n4/2021-10-slingshot-findings/issues/3  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps Change the constant variables to immutable.  "}, {"title": "`YearnVault.sol#pull()` will most certainly fail", "html_url": "https://github.com/code-423n4/2021-12-mellow-findings/issues/121", "labels": ["bug", "3 (High Risk)", "resolved", "sponsor confirmed"], "target": "2021-12-mellow-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/test_brownie/contracts/YearnVault.sol#L84-L101  ```solidity=84     for (uint256 i = 0; i < _yTokens.length; i++) {         if (tokenAmounts[i] == 0) {             continue;         }          IYearnVault yToken = IYearnVault(_yTokens[i]);         uint256 yTokenAmount = ((tokenAmounts[i] * (10**yToken.decimals())) / yToken.pricePerShare());         uint256 balance = yToken.balanceOf(address(this));         if (yTokenAmount > balance) {             yTokenAmount = balance;         }         if (yTokenAmount == 0) {             continue;         }         yToken.withdraw(yTokenAmount, to, maxLoss);         (tokenAmounts[i], address(this));     }     actualTokenAmounts = tokenAmounts; ```  The actual token withdrew from `yToken.withdraw()` will most certainly be less than the `tokenAmounts[i]`, due to precision loss in the calculation of `yTokenAmount`.  As a result, `IERC20(_vaultTokens[i]).safeTransfer(to, actualTokenAmounts[i]);` in `LpIssuer.sol#withdraw()` will revert due to insufficant balance.   ### Recommendation  Change to:  ```solidity=98 tokenAmounts[i] = yToken.withdraw(yTokenAmount, to, maxLoss); ```  "}, {"title": "`AaveVault.sol#_pull()` may return wrong `actualTokenAmounts`", "html_url": "https://github.com/code-423n4/2021-12-mellow-findings/issues/119", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2021-12-mellow-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-12-mellow/blob/6679e2dd118b33481ee81ad013ece4ea723327b5/mellow-vaults/test_brownie/contracts/AaveVault.sol#L80-L94  ```solidity=80 function _pull(         address to,         uint256[] memory tokenAmounts,         bytes memory     ) internal override returns (uint256[] memory actualTokenAmounts) {         address[] memory tokens = _vaultTokens;         for (uint256 i = 0; i < _aTokens.length; i++) {             if ((_tvls[i] == 0) || (tokenAmounts[i] == 0)) {                 continue;             }             _lendingPool().withdraw(tokens[i], tokenAmounts[i], to);         }         updateTvls();         actualTokenAmounts = tokenAmounts;     } ```  In Aave LendingPool, the actual amount withdrawn may be different from the requested amount, we suggest using the return amount as `actualTokenAmount`.  https://github.com/aave/protocol-v2/blob/master/contracts/protocol/lendingpool/LendingPool.sol#L155-L157  ```solidity if (amount == type(uint256).max) {     amountToWithdraw = userBalance; } ```  ### Recommendation  Change to:  ```solidity function _pull(         address to,         uint256[] memory tokenAmounts,         bytes memory     ) internal override returns (uint256[] memory actualTokenAmounts) {         address[] memory tokens = _vaultTokens;         for (uint256 i = 0; i < _aTokens.length; i++) {             if ((_tvls[i] == 0) || (tokenAmounts[i] == 0)) {                 continue;             }             tokenAmounts[i] = _lendingPool().withdraw(tokens[i], tokenAmounts[i], to);         }         updateTvls();         actualTokenAmounts = tokenAmounts;     } ```  "}, {"title": "pre-calculate expressions that do not change", "html_url": "https://github.com/code-423n4/2021-12-mellow-findings/issues/118", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-12-mellow-findings", "body": "pre-calculate expressions that do not change"}, {"title": "adminApprove will not work", "html_url": "https://github.com/code-423n4/2021-12-mellow-findings/issues/117", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2021-12-mellow-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact function adminApprove intends to allow an admin to approve NFTs on behalf of users: ```solidity   function adminApprove(address newAddress, uint256 nft) external {     require(_isProtocolAdmin(_msgSender()), ExceptionsLibrary.ADMIN);     IERC721(address(this)).approve(newAddress, nft);   } ```  However, when it calls .approve, it will check the ownership again, so only the calls from admin and owner/approved will pass: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/ERC721.sol#L116-L119  This makes this function ineffective.  ## Recommended Mitigation Steps Based on my understanding, it should call ._approve(...).  "}, {"title": " The Contract Should Approve(0) first", "html_url": "https://github.com/code-423n4/2021-12-mellow-findings/issues/115", "labels": ["bug", "1 (Low Risk)"], "target": "2021-12-mellow-findings", "body": " The Contract Should Approve(0) first"}, {"title": "`UniV3Vault` does not distribute fee earning to depositor", "html_url": "https://github.com/code-423n4/2021-12-mellow-findings/issues/111", "labels": ["bug", "1 (Low Risk)", "sponsor disputed"], "target": "2021-12-mellow-findings", "body": "`UniV3Vault` does not distribute fee earning to depositor"}]