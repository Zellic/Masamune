[{"title": "Unnecessary imports", "html_url": "https://github.com/code-423n4/2021-10-pooltogether-findings/issues/50", "labels": ["bug", "sponsor confirmed", "0 (Non-critical)", "disagree with severity", "resolved"], "target": "2021-10-pooltogether-findings", "body": "# Handle  PranavG   # Vulnerability details  ## Impact MathUtils.sol has unused import at line #5: import \"@openzeppelin/contracts/math/SafeMath.sol\"; The import is not used in any way.   ## Recommended Mitigation Steps Remove it to improve readability of the code.  "}, {"title": "Less than 256 uints are not efficient", "html_url": "https://github.com/code-423n4/2021-10-pooltogether-findings/issues/49", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-10-pooltogether-findings", "body": "Less than 256 uints are not efficient"}, {"title": "function _getPrizeSplitAmount can be refactored", "html_url": "https://github.com/code-423n4/2021-10-pooltogether-findings/issues/48", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "resolved"], "target": "2021-10-pooltogether-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact If you want to save some gas you can get rid of _getPrizeSplitAmount and calculate the split directly in _distributePrizeSplits as this function is internal and is only called once so there is no actual need for reusability here and removing this extra call will make the execution cheaper.  ## Recommended Mitigation Steps Consider moving the logic of _getPrizeSplitAmount  directly to _distributePrizeSplits.  "}, {"title": "Immutable variables", "html_url": "https://github.com/code-423n4/2021-10-pooltogether-findings/issues/47", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "resolved"], "target": "2021-10-pooltogether-findings", "body": "Immutable variables"}, {"title": "staticcall may return true for an invalid _yieldSource", "html_url": "https://github.com/code-423n4/2021-10-pooltogether-findings/issues/45", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "resolved"], "target": "2021-10-pooltogether-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact Low-level calls like staticcall return true even if the account called is non-existent (per EVM design) so this hack in YieldSourcePrizePool constructor will not work in certain cases:         // A hack to determine whether it's an actual yield source         (bool succeeded, ) = address(_yieldSource).staticcall(             abi.encodePacked(_yieldSource.depositToken.selector)         );  You can try to pass an EOA address and see that it will return true.  ## Recommended Mitigation Steps Account existence must be checked prior to calling. A similar issue was submitted in a previous contest and assigned a severity of low, you can find more details here: https://github.com/code-423n4/2021-04-basedloans-findings/issues/16  "}, {"title": "calculateNextBeaconPeriodStartTime casts timestamp to uint64", "html_url": "https://github.com/code-423n4/2021-10-pooltogether-findings/issues/44", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "resolved"], "target": "2021-10-pooltogether-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact function calculateNextBeaconPeriodStartTime accepts _time as a type of uint256 but later explicitly casts it to uint64. While this function is not used internally, it behaves incorrectly when passed a value that uint64 does not hold (for such values it will return a max value of uint64). I don't see a reason why you can't directly accept uint64 here.  ## Recommended Mitigation Steps Change parameter type to uint64.  "}, {"title": "Unnecessary Addition In Loop (PrizeDistributionBuffer.sol)", "html_url": "https://github.com/code-423n4/2021-10-pooltogether-findings/issues/43", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-10-pooltogether-findings", "body": "Unnecessary Addition In Loop (PrizeDistributionBuffer.sol)"}, {"title": "`PrizeDistributor.sol#claim()` Remove redundant check can save gas", "html_url": "https://github.com/code-423n4/2021-10-pooltogether-findings/issues/41", "labels": ["bug", "G (Gas Optimization)", "resolved"], "target": "2021-10-pooltogether-findings", "body": "`PrizeDistributor.sol#claim()` Remove redundant check can save gas"}, {"title": "`PrizeSplit.sol#_totalPrizeSplitPercentageAmount()` Avoid unnecessary copy from storage to memory can save gas", "html_url": "https://github.com/code-423n4/2021-10-pooltogether-findings/issues/40", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "resolved"], "target": "2021-10-pooltogether-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/pooltogether/v4-core/blob/055335bf9b09e3f4bbe11a788710dd04d827bf37/contracts/prize-strategy/PrizeSplit.sol#L135-L136  ```solidity PrizeSplitConfig memory split = _prizeSplits[index]; _tempTotalPercentage = _tempTotalPercentage + split.percentage; ```  Only `percentage` of the `PrizeSplitConfig` struct is accessed, however, the current implementation created a memory variable that will load `_prizeSplits[index]` and copy to memory, this is unnecessary and gas inefficient.  ### Recommendation  Change to:  ```solidity _tempTotalPercentage = _tempTotalPercentage + split.percentage; ```  "}, {"title": "Adding unchecked directive can save gas", "html_url": "https://github.com/code-423n4/2021-10-pooltogether-findings/issues/38", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "resolved"], "target": "2021-10-pooltogether-findings", "body": "Adding unchecked directive can save gas"}, {"title": "`PrizePool.sol#_canDeposit()` Remove redundant code can make the code simpler and save some gas", "html_url": "https://github.com/code-423n4/2021-10-pooltogether-findings/issues/37", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "resolved"], "target": "2021-10-pooltogether-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/pooltogether/v4-core/blob/055335bf9b09e3f4bbe11a788710dd04d827bf37/contracts/prize-pool/PrizePool.sol#L361-L368  ```solidity function _canDeposit(address _user, uint256 _amount) internal view returns (bool) {     ITicket _ticket = ticket;     uint256 _balanceCap = balanceCap;      if (_balanceCap == type(uint256).max) return true;      return (_ticket.balanceOf(_user) + _amount <= _balanceCap); } ```  `ITicket _ticket = ticket;` is redundant, removing it will also avoid a `sload` if returned when `_balanceCap == type(uint256).max`.  ### Recommendation  Change to:  ```solidity function _canDeposit(address _user, uint256 _amount) internal view returns (bool) {      uint256 _balanceCap = balanceCap;      if (_balanceCap == type(uint256).max) return true;      return (ticket.balanceOf(_user) + _amount <= _balanceCap); } ```  "}, {"title": "`PrizePool.sol#setTicket()` Remove unnecessary variable can make the code simpler and save some gas", "html_url": "https://github.com/code-423n4/2021-10-pooltogether-findings/issues/36", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "resolved"], "target": "2021-10-pooltogether-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/pooltogether/v4-core/blob/055335bf9b09e3f4bbe11a788710dd04d827bf37/contracts/prize-pool/PrizePool.sol#L284-L297  ```solidity function setTicket(ITicket _ticket) external override onlyOwner returns (bool) {     address _ticketAddress = address(_ticket);      require(_ticketAddress != address(0), \"PrizePool/ticket-not-zero-address\"); ... ```  `_ticketAddress` is unnecessary as it's being used only once.  ### Recommendation  Change to:  ```solidity function setTicket(ITicket _ticket) external override onlyOwner returns (bool) {     require(address(_ticket) != address(0), \"PrizePool/ticket-not-zero-address\"); ... ```  "}, {"title": "`PrizeSplit.sol#distribute()` The value of the event parameter is wrong", "html_url": "https://github.com/code-423n4/2021-10-pooltogether-findings/issues/35", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "resolved"], "target": "2021-10-pooltogether-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/pooltogether/v4-core/blob/055335bf9b09e3f4bbe11a788710dd04d827bf37/contracts/prize-strategy/PrizeSplitStrategy.sol#L51-L61  ```solidity function distribute() external override returns (uint256) {     uint256 prize = prizePool.captureAwardBalance();      if (prize == 0) return 0;      _distributePrizeSplits(prize);      emit Distributed(prize);      return prize; } ```  Based on the context, the value of the parameter of the `Distributed` event should be the distributed prize amount, which can be calculated based on the return value of `_distributePrizeSplits`.  ### Recommendation  Change to:  ```solidity  event Distributed(uint256 totalPrizeCaptured, uint256 totalPrizeDistributed);  function distribute() external override returns (uint256) {     uint256 prize = prizePool.captureAwardBalance();      if (prize == 0) return 0;      uint remainingPrize = _distributePrizeSplits(prize);      emit Distributed(prize, prize - remainingPrize);      return prize; } ```  "}, {"title": "The formula of number of prizes for a degree is wrong", "html_url": "https://github.com/code-423n4/2021-10-pooltogether-findings/issues/33", "labels": ["bug", "sponsor confirmed", "3 (High Risk)", "resolved"], "target": "2021-10-pooltogether-findings", "body": "# Handle  WatchPug   # Vulnerability details  The formula of the number of prizes for a degree per the document: https://v4.docs.pooltogether.com/protocol/concepts/prize-distribution/#splitting-the-prizes is: ``` Number of prizes for a degree = (2^bit range)^degree - (2^bit range)^(degree-1) - (2^bit range)^(degree-2) - ... ``` Should be changed to: ``` Number of prizes for a degree = (2^bit range)^degree - (2^bit range)^(degree-1) ``` or ``` Number of prizes for a degree = 2^(bit range * degree) - 2^(bit range * (degree-1)) ```  ### Impact  Per the document:  > prize for a degree = total prize * degree percentage / number of prizes for a degree  Due to the miscalculation of `number of prizes for a degree`, it will be smaller than expected, as a result, `prize for a degree` will be larger than expected. Making the protocol giving out more prizes than designed.  ### Proof  > We will use `f(bitRange, degree)` to represent `numberOfPrizesForDegree(bitRangeSize, degree)`.  #### Proof: (method 1)  ```tex 2 ^ {bitRange \\times n} = f(bitRange, n) + f(bitRange, n-1) + f(bitRange, n-2) + ... + f(bitRange, 1) + f(bitRange, 0) f(bitRange, n) = 2 ^ {bitRange \\times n} - ( f(bitRange, n-1) + f(bitRange, n-2) + ... + f(bitRange, 1) + f(bitRange, 0) ) f(bitRange, n) = 2 ^ {bitRange \\times n} - f(bitRange, n-1) - ( f(bitRange, n-2) + ... + f(bitRange, 1) + f(bitRange, 0) )  Because:  2 ^ {bitRange \\times (n-1)} = f(bitRange, n-1) + f(bitRange, n-2) + ... + f(bitRange, 1) + f(bitRange, 0) 2 ^ {bitRange \\times (n-1)} - f(bitRange, n-1) = f(bitRange, n-2) + ... + f(bitRange, 1) + f(bitRange, 0)  Therefore:  f(bitRange, n) = 2 ^ {bitRange \\times n} - f(bitRange, n-1) - ( 2 ^ {bitRange \\times (n-1)} - f(bitRange, n-1) ) f(bitRange, n) = 2 ^ {bitRange \\times n} - f(bitRange, n-1) - 2 ^ {bitRange \\times (n-1)} + f(bitRange, n-1) f(bitRange, n) = 2 ^ {bitRange \\times n} - 2 ^ {bitRange \\times (n-1)} ```  Because `2^x = 1 << x`  Therefore, when `n > 0`:  ``` f(bitRange, n) = ( 1 << bitRange * n ) - ( 1 << bitRange * (n - 1) ) ```  QED.  #### Proof: (method 2)  By definition, `degree n` is constructed by 3 chunks:  -  The first N numbers, must equal the matching numbers. Number of possible values: `1`; -  The N-th number, must not equal the N-th matching number. Number of possible values: `2^bitRange - 1` -  From N (not include) until the end. Number of possible values: `2 ^ (bitRange * (n-1))`  Therefore, total `numberOfPrizesForDegree` will be:  ```tex f(bitRange, n) = (2 ^ {bitRange} - 1) \\times 2 ^ {bitRange \\times (n - 1)} f(bitRange, n) = 2 ^ {bitRange} \\times 2 ^ {bitRange \\times (n - 1)} - 2 ^ {bitRange \\times (n - 1)} f(bitRange, n) = 2 ^ {bitRange + bitRange \\times (n - 1)} - 2 ^ {bitRange \\times (n - 1)} f(bitRange, n) = 2 ^ {bitRange + bitRange \\times n - bitRange} - 2 ^ {bitRange \\times (n - 1)} f(bitRange, n) = 2 ^ {bitRange \\times n} - 2 ^ {bitRange \\times (n - 1)} ```  QED.  ### Recommendation  https://github.com/pooltogether/v4-core/blob/055335bf9b09e3f4bbe11a788710dd04d827bf37/contracts/DrawCalculator.sol#L423-L431   ```solidity=412{423-431} /**     * @notice Calculates the number of prizes for a given prizeDistributionIndex     * @param _bitRangeSize Bit range size for Draw     * @param _prizeTierIndex Index of the prize tier array to calculate     * @return returns the fraction of the total prize (base 1e18)     */ function _numberOfPrizesForIndex(uint8 _bitRangeSize, uint256 _prizeTierIndex)     internal     pure     returns (uint256) {     uint256 bitRangeDecimal = 2**uint256(_bitRangeSize);     uint256 numberOfPrizesForIndex = bitRangeDecimal**_prizeTierIndex;      while (_prizeTierIndex > 0) {         numberOfPrizesForIndex -= bitRangeDecimal**(_prizeTierIndex - 1);         _prizeTierIndex--;     }      return numberOfPrizesForIndex; } ```  L423-431 should change to:  ```solidity if (_prizeTierIndex > 0) {     return ( 1 << _bitRangeSize * _prizeTierIndex ) - ( 1 << _bitRangeSize * (_prizeTierIndex - 1) ); } else {     return 1; } ```  BTW, the comment on L416 is wrong:  - seems like it's copied from _calculatePrizeTierFraction() - plus, it's not base 1e18 but base 1e9  "}, {"title": "Deposits don't work with fee-on transfer tokens", "html_url": "https://github.com/code-423n4/2021-10-pooltogether-findings/issues/30", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2021-10-pooltogether-findings", "body": "Deposits don't work with fee-on transfer tokens"}, {"title": "Gas: `PrizePool.captureAwardBalance` computation can be simplified", "html_url": "https://github.com/code-423n4/2021-10-pooltogether-findings/issues/29", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "resolved"], "target": "2021-10-pooltogether-findings", "body": "# Handle  cmichel   # Vulnerability details  The `PrizePool.captureAwardBalance` function always sets `_currentAwardBalance = currentAwardBalance` where `currentAwardBalance = currentAwardBalance + unaccountedPrizeBalance = currentAwardBalance + totalInterest - currentAwardBalance = totalInterest`.  Save a checked math addition by just setting `_currentAwardBalance = totalInterest` immediately.  "}, {"title": "`PrizePool` uses `ERC20` for `ERC721`", "html_url": "https://github.com/code-423n4/2021-10-pooltogether-findings/issues/28", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "resolved"], "target": "2021-10-pooltogether-findings", "body": "# Handle  cmichel   # Vulnerability details  The `PrizePool` defines `using SafeERC20 for IERC721;` which means the `SafeERC20.safeTransferFrom` function will be used in `awardExternalERC721`. However, this function is just a wrapper for `contract.transferFrom` with a return-value and success check.  Thus this call actually calls `ERC721.transferFrom` instead of `ERC721.safeTransferFrom` and does not call the important `onERC721Received` check for contracts.  ## Impact ERC721s can be awarded to contracts that don't know how to handle it and they can get stuck.  ## Recommended Mitigation Steps Remove the `using SafeERC20 for IERC721;` line.   "}, {"title": "Reserve does not correctly implement RingBuffer", "html_url": "https://github.com/code-423n4/2021-10-pooltogether-findings/issues/26", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "resolved"], "target": "2021-10-pooltogether-findings", "body": "# Handle  cmichel   # Vulnerability details  The `Reserve` does not correctly use ring buffers to get the oldest / newest elements if the array is full (observations larger than cardinality) in which case it should wrap around.  `getReserveAccumulatedBetween` always picks `reserveAccumulators[_cardinality - 1]`. `_checkpoint` tries to write to `reserveAccumulators[cardinality++]` which will break once `cardinality` reaches `MAX_CARDINALITY`.  The `TwabLib` library has a correct `oldestTwab/newestTwab` implementation using the `RingBufferLib` that wraps around if needed.  ## Impact Anyone can send 1 wei to the reserve and call `checkpoint` on it until the `MAX_CARDINALITY` is reached. Afterwards, trying to write any new checkpoints will fail as `_checkpoint` now tries to write to `cardinality=MAX_CARDINALITY+1` which is out of bounds of the `reserveAccumulators`.  The reserve is broken and cannot withdraw funds anymore. The gas costs for such an attack are very high and would take ~7 years if writing every block, making it probably not worth fixing.  ## Recommended Mitigation Steps Correctly implement the ring buffer usage like in `TwabLib`.   "}, {"title": "Anyone can claim prizes on behalf of someone", "html_url": "https://github.com/code-423n4/2021-10-pooltogether-findings/issues/25", "labels": ["bug", "invalid", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-10-pooltogether-findings", "body": "Anyone can claim prizes on behalf of someone"}, {"title": "Unbounded iteration over picks when `claim`ing draws", "html_url": "https://github.com/code-423n4/2021-10-pooltogether-findings/issues/24", "labels": ["bug", "sponsor acknowledged", "0 (Non-critical)"], "target": "2021-10-pooltogether-findings", "body": "Unbounded iteration over picks when `claim`ing draws"}, {"title": "Wrong comment regarding decimal precision of `_calculatePrizeTierFraction`", "html_url": "https://github.com/code-423n4/2021-10-pooltogether-findings/issues/22", "labels": ["bug", "sponsor confirmed", "0 (Non-critical)", "resolved"], "target": "2021-10-pooltogether-findings", "body": "# Handle  cmichel   # Vulnerability details  The `_calculatePrizeTierFraction` docs say \"returns the fraction of the total prize (base 1e18)\", but it's base 1e9. Code seems to be correct.  "}, {"title": "Gas: Bitmasks creation can be simplified", "html_url": "https://github.com/code-423n4/2021-10-pooltogether-findings/issues/21", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "resolved"], "target": "2021-10-pooltogether-findings", "body": "# Handle  cmichel   # Vulnerability details  In `DrawCalculator._createBitMasks`, the bit masks can just be created by shifting the previous (potentially already shifted) masks by the bit range. It saves on multiplications and, for me, this is also more intuitive than the current algorithm.  Some pseudocode: ```solidity function _createBitMasks(IPrizeDistributionBuffer.PrizeDistribution memory _prizeDistribution)     internal     pure     returns (uint256[] memory) {     uint256[] memory masks = new uint256[](_prizeDistribution.matchCardinality);     uint256 _bitRangeMaskValue = (2**_prizeDistribution.bitRangeSize) - 1; // get a decimal representation of bitRangeSize, for example 0xF for bitRangeSize = 4      if(_prizeDistribution.matchCardinality == 0) return masks;      masks[0] = _bitRangeMaskValue;     for (uint8 maskIndex = 1; maskIndex < _prizeDistribution.matchCardinality; maskIndex++) {         // shift by the \"size\" of the bit mask each time, 0xF, 0xF0, 0xF00, 0xF000, etc.         masks[maskIndex] = masks[maskIndex - 1] << _prizeDistribution.bitRangeSize;     }      return masks; } ```  "}, {"title": "Gas: Default case of `_calculateTierIndex` can return `0`", "html_url": "https://github.com/code-423n4/2021-10-pooltogether-findings/issues/20", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "resolved"], "target": "2021-10-pooltogether-findings", "body": "# Handle  cmichel   # Vulnerability details  If all masks match the `DrawCalculator._calculateTierIndex` function returns `masksLength - numberOfMatches` but it will always be zero at this point as `masksLength == numberOfMatches`. So just returning zero here would lead to saving a checked subtraction.  "}, {"title": "Should `safeApprove(0)` first", "html_url": "https://github.com/code-423n4/2021-10-pooltogether-findings/issues/19", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-10-pooltogether-findings", "body": "Should `safeApprove(0)` first"}, {"title": "Usage of deprecated `safeApprove`", "html_url": "https://github.com/code-423n4/2021-10-pooltogether-findings/issues/18", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "resolved"], "target": "2021-10-pooltogether-findings", "body": "# Handle  cmichel   # Vulnerability details  Description: `safeApprove` is now deprecated, see [this comment](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/566a774222707e424896c0c390a84dc3c13bdcb2/contracts/token/ERC20/utils/SafeERC20.sol#L38).  ## Impact When using one of these unsupported tokens, all transactions revert and the protocol cannot be used.  ## Recommended Mitigation Steps As per OpenZepplin documentation \u201cwhenever possible, use `safeIncreaseAllowance` and `safeDecreaseAllowance` instead\u201d.   "}, {"title": "PrizeSplit uint8 limits", "html_url": "https://github.com/code-423n4/2021-10-pooltogether-findings/issues/17", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "resolved"], "target": "2021-10-pooltogether-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact In the contract PrizeSplit.sol, uint8 is used in a few places. This limits the addressable size of _prizeSplits.  In practice you would probably not split prizes in more than 256 ways, but checking for this is safer.  ## Proof of Concept https://github.com/pooltogether/v4-core/blob/master/contracts/prize-strategy/PrizeSplit.sol#L86-L87  function setPrizeSplit(PrizeSplitConfig memory _prizeSplit, uint8 _prizeSplitIndex)  https://github.com/pooltogether/v4-core/blob/master/contracts/prize-strategy/PrizeSplit.sol#L130-L140  for (uint8 index = 0; index < prizeSplitsLength; index++) {  ## Tools Used  ## Recommended Mitigation Steps Add the following  to function setPrizeSplits:    require(newPrizeSplitsLength <= type(uint8).max))  or replace uint8 with uint256 in PrizeSplit.sol   "}, {"title": "Gas improvement _transferTwab", "html_url": "https://github.com/code-423n4/2021-10-pooltogether-findings/issues/16", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "resolved"], "target": "2021-10-pooltogether-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact I've found some gas improvements for _transferTwab, see below.  ## Proof of Concept https://github.com/pooltogether/v4-core/blob/master/contracts/Ticket.sol#L296-L313  ## Tools Used  ## Recommended Mitigation Steps   function _transferTwab(address _from, address _to, uint256 _amount) internal {         if (_from==_to) return; // no need to transfer if both are the same         if (_from != address(0)) {             _decreaseUserTwab(_from, _amount);             if (_to == address(0)) _decreaseTotalSupplyTwab(_amount);         }                 if (_to != address(0)) {                     _increaseUserTwab(_to, _amount);             if (_from == address(0)) _increaseTotalSupplyTwab(_amount);         }     }  "}, {"title": "Unnecessary Multiple Return Statements (PrizePool.sol)", "html_url": "https://github.com/code-423n4/2021-10-pooltogether-findings/issues/15", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "resolved"], "target": "2021-10-pooltogether-findings", "body": "# Handle  ye0lde   # Vulnerability details  ## Impact  Gas savings and code clarity  ## Proof of Concept  PrizePool.sol: https://github.com/pooltogether/v4-core/blob/35b00f710db422a6193131b7dc2de5202dc4677c/contracts/prize-pool/PrizePool.sol#L383-L387  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps Replace this https://github.com/pooltogether/v4-core/blob/35b00f710db422a6193131b7dc2de5202dc4677c/contracts/prize-pool/PrizePool.sol#L383-L387 with <code> return (ticket == _controlledToken)  </code>  "}, {"title": "double reading from memory inside a for loop.", "html_url": "https://github.com/code-423n4/2021-10-pooltogether-findings/issues/11", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "resolved"], "target": "2021-10-pooltogether-findings", "body": "# Handle  pants   # Vulnerability details  See for example the AssetsManager.rebalance function. There you read the value moneyMarkets[i] twice at the same iteration instead of caching it. This happens in the same file in many other places, deposit, withdraw and more. Inside a loop caching is very important.   "}, {"title": "No need to put ReentrnacyGaurd on PrizePool.constructor.", "html_url": "https://github.com/code-423n4/2021-10-pooltogether-findings/issues/10", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-10-pooltogether-findings", "body": "No need to put ReentrnacyGaurd on PrizePool.constructor."}, {"title": "++i is more gas efficient than i++ for loops.", "html_url": "https://github.com/code-423n4/2021-10-pooltogether-findings/issues/6", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-10-pooltogether-findings", "body": "++i is more gas efficient than i++ for loops."}, {"title": "PrizePoolHarness._supply -a return without specifying return value", "html_url": "https://github.com/code-423n4/2021-10-pooltogether-findings/issues/1", "labels": ["bug", "sponsor disputed", "0 (Non-critical)", "disagree with severity"], "target": "2021-10-pooltogether-findings", "body": "PrizePoolHarness._supply -a return without specifying return value"}, {"title": "Limit on growth size of pool - bond size", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/275", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-09-defiprotocol-findings", "body": "Limit on growth size of pool - bond size"}, {"title": "No input validation on parameter changes", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/274", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-09-defiprotocol-findings", "body": "No input validation on parameter changes"}, {"title": "Unnecessary require check", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/273", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  tensors   # Vulnerability details  ## Impact In L92 of Basket.sol there is an unnecessary require check that the user balance is greater than or equal to amount. If the amount is larger than user balance then the _burn() method will fail, causing the function to revert anyway.  ## Proof of Concept https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L92  ## Recommended Mitigation Steps Remove the unnecessary check.  "}, {"title": "block.timestamp is a better timer than block.number", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/271", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-09-defiprotocol-findings", "body": "block.timestamp is a better timer than block.number"}, {"title": "Add nonreentrant modifiers to external methods in 2 files", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/270", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  tensors   # Vulnerability details  I recommend adding reentrancy checks throughout Basket.sol and Auction.sol using a mutex lock. Many external calls are made to potentially unsafe token contracts. In the case that not all token contracts are properly vetted, this preventative step could be worthwhile.  "}, {"title": "Owner can steal all Basket funds during auction", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/265", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  0xsanson   # Vulnerability details  ## Impact The owner of Factory contract can modify the values of `auctionMultiplier` and `auctionDecrement` at any time. During an auction, these values are used to calculate `newRatio` and thereby `tokensNeeded`: specifically, it's easy to set the factory parameters so that `tokensNeeded = 0` (or close to zero) for every token. This way the owner can participate at an auction, change the parameters, and get the underlying tokens from a Basket without transferring any pending tokens.  ## Proof of Concept https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Auction.sol#L89-L99  ## Tools Used editor  ## Recommended Mitigation Steps Consider adding a Timelock to these Factory functions. Otherwise a way to not modify them if an auction is ongoing (maybe Auction saves the values it reads when `startAuction` is called).  "}, {"title": "`handleFees` reverts if supply is zero", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/264", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  0xsanson   # Vulnerability details  ## Impact In Basket.sol, `handleFees` computes the following: `uint256 newIbRatio = ibRatio * startSupply / totalSupply()`.  In the case that `totalSupply() = 0` (every holder burned their basket), the function reverts since there's a 0/0. This issue won't let new people mint, since `handleFees` is called before any minting.  ## Proof of Concept https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Basket.sol#L124  ## Tools Used editor  ## Recommended Mitigation Steps Consider adding a check before the division. ``` if (startSupply == 0) {  return; } ```  "}, {"title": "Event BasketLicenseProposed needs an idNumber", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/263", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  0xsanson   # Vulnerability details  ## Impact The function `Factory.proposeBasketLicense` at the end emits `BasketLicenseProposed(msg.sender, tokenName)` and returns the id of the proposal. This `id` should also be written to the log, since it's needed by the proposer (for createBasket), and they may not see the return value of an external function.  ## Proof of Concept https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Factory.sol#L87-L90  ## Tools Used editor  ## Recommended Mitigation Steps Consider redefining the event to contain the id of the proposal.  "}, {"title": "`bondTimestamp` is not a timestamp but a blocknumber", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/261", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor acknowledged"], "target": "2021-09-defiprotocol-findings", "body": "`bondTimestamp` is not a timestamp but a blocknumber"}, {"title": "Lack of revert messages", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/258", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor acknowledged"], "target": "2021-09-defiprotocol-findings", "body": "Lack of revert messages"}, {"title": "`mintTo` arguments order", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/257", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  0xsanson   # Vulnerability details  ## Impact In Basket.sol, there is a function `mintTo(uint256 amount, address to)`. It's best practice to use as first argument `to`, and as second `amount`; see also the order used in L84 (_mint(to, amount)) and L86 (Minted(to, amount)).  ## Proof of Concept https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Basket.sol#L76  ## Tools Used editor  ## Recommended Mitigation Steps Consider switching the arguments (also don't forget to change the calls to the function).  "}, {"title": "Same tokens added to bounty", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/253", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-09-defiprotocol-findings", "body": "Same tokens added to bounty"}, {"title": "pack structs *3", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/252", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-09-defiprotocol-findings", "body": "pack structs *3"}, {"title": "Naming", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/250", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor acknowledged"], "target": "2021-09-defiprotocol-findings", "body": "Naming"}, {"title": "`burn` and `mintTo` in `Basket.sol` vulnerable to reentrancy", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/248", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2021-09-defiprotocol-findings", "body": "`burn` and `mintTo` in `Basket.sol` vulnerable to reentrancy"}, {"title": "Unecessary transfer trips", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/245", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-09-defiprotocol-findings", "body": "Unecessary transfer trips"}, {"title": "Auction multiplier set to zero", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/242", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor acknowledged"], "target": "2021-09-defiprotocol-findings", "body": "Auction multiplier set to zero"}, {"title": "Set functions to external.", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/240", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  goatbug   # Vulnerability details  ## Impact Long list of functions should be set from public to external since they are not called anywhere by the contract itself.     ## Proof of Concept  There are too many to list them all from all the contracts.  Just some examples in the Factory contract.  There are lots in every contract that should rather be external.      function setMinLicenseFee(uint256 newMinLicenseFee) public override onlyOwner {         minLicenseFee = newMinLicenseFee;     }      function setAuctionDecrement(uint256 newAuctionDecrement) public override onlyOwner {         auctionDecrement = newAuctionDecrement;     }      function setAuctionMultiplier(uint256 newAuctionMultiplier) public override onlyOwner {         auctionMultiplier = newAuctionMultiplier;     }      function setBondPercentDiv(uint256 newBondPercentDiv) public override onlyOwner {         bondPercentDiv = newBondPercentDiv;     }      function setOwnerSplit(uint256 newOwnerSplit) public override onlyOwner {         require(newOwnerSplit <= 2e17); // 20%          ownerSplit = newOwnerSplit;     }  ## Tools Used  ## Recommended Mitigation Steps  "}, {"title": "Gas optimation proposal struct", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/238", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  goatbug   # Vulnerability details  ## Impact Use less storage slots  ## Proof of Concept     struct Proposal {         uint256 licenseFee;         string tokenName;         string tokenSymbol;         address proposer;         address[] tokens;         uint256[] weights;         address basket;     } License fee is a smaller number does not need to be uint256.   Could use an 8 bit value and pack it comfortable with one of the addresses to save a full storage slot.   ## Tools Used  ## Recommended Mitigation Steps  "}, {"title": "Gas saving: pack struct", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/237", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-09-defiprotocol-findings", "body": "Gas saving: pack struct"}, {"title": "Fee on transfer tokens can lead to incorrect approval", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/236", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2021-09-defiprotocol-findings", "body": "Fee on transfer tokens can lead to incorrect approval"}, {"title": "Proposals can never get created due to reaching `block.gaslimit`", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/235", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-09-defiprotocol-findings", "body": "Proposals can never get created due to reaching `block.gaslimit`"}, {"title": "Sanity checks when the contract parameters are updated", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/234", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-09-defiprotocol-findings", "body": "Sanity checks when the contract parameters are updated"}, {"title": "The increment in for loop post condition can be made unchecked", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/232", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-09-defiprotocol-findings", "body": "The increment in for loop post condition can be made unchecked"}, {"title": "Replace `tokenList.length` by existing variable `length`", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/230", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  hrkrshnn   # Vulnerability details  ## Replace `tokenList.length` by existing variable `length`  ``` diff modified   contracts/contracts/Basket.sol @@ -61,7 +61,7 @@ contract Basket is IBasket, ERC20Upgradeable {              require(_tokens[i] != address(0));              require(_weights[i] > 0);  -            for (uint256 x = 0; x < tokenList.length; x++) { +            for (uint256 x = 0; x < length; x++) {                  require(_tokens[i] != tokenList[x]);              } ```  Context: <https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Basket.sol#L64>  The value `tokenList.length` is read from memory and therefore requires a `mload(...)` (6 gas for `push memory_offset` + `mload`). On the other hand, this value is already available in the stack as `length` and could just be `dup-ed` (3 gas). Saves 3 gas for each loop iteration of the interior loop.   "}, {"title": "Use `calldata` instead of `memory` for function parameters", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/229", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "Use `calldata` instead of `memory` for function parameters"}, {"title": "Gas: Can save an sload in `changeLicenseFee`", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/228", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  cmichel   # Vulnerability details  The `if`-branch of `Basket.changeLicenseFee` function ensures that `pendingLicenseFee.licenseFee == newLicenseFee` which means setting `licenseFee = newLicenseFee` is equivalent to `licenseFee = pendingLicenseFee.licenseFee` but the former saves an expensive storage load operation.  "}, {"title": "Gas: Can save an sload in `changePublisher`", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/227", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  cmichel   # Vulnerability details  The `if`-branch of `Basket.changePublisher` function ensures that `pendingPublisher.publisher == newPublisher` which means setting `publisher = newPublisher` is equivalent to `publisher = pendingPublisher.publisher` but the former saves an expensive storage load operation.  "}, {"title": "Gas: Factory parameter can be removed from Auction", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/225", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  cmichel   # Vulnerability details  The `Auction.initialize` function accepts a `factory_` parameter. However, as this contract is always initialized directly from the factory, it can just use `msg.sender`.  ## Recommended Mitigation Steps Removing the additional `factory_` parameter and using `msg.sender` instead will save gas. This is already done for the other `Basket` contract.   "}, {"title": "`newIbRatio` update math depends on how often it's called", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/224", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-09-defiprotocol-findings", "body": "`newIbRatio` update math depends on how often it's called"}, {"title": "Re-entrancy in `settleAuction` allow stealing all funds", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/223", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  cmichel   # Vulnerability details  Note that the `Basket` contract approved the `Auction` contract with all tokens and the `settleAuction` function allows the auction bonder to transfer all funds out of the basket to themselves. The only limiting factor is the check afterwards that needs to be abided by. It checks if enough tokens are still in the basket after settlement:  ``` // this is the safety check if basket still has all the tokens after removing arbitrary amounts for (uint256 i = 0; i < pendingWeights.length; i++) {     uint256 tokensNeeded = basketAsERC20.totalSupply() * pendingWeights[i] * newRatio / BASE / BASE;     require(IERC20(pendingTokens[i]).balanceOf(address(basket)) >= tokensNeeded); } ```  The bonder can pass in any `inputTokens`, even malicious ones they created. This allows them to re-enter the `settleAuction` multiple times for the same auction.  Calling this function at the correct time (such that `bondTimestamp - auctionStart` makes `newRatio < basket.ibRatio()`), the attacker can drain more funds each time, eventually draining the entire basket.  ## POC Assume that the current `basket.ibRatio` is `1e18` (the initial value). The basket publisher calls `basket.publishNewIndex` with some tokens and weights. For simplicity, assume that the pending `tokens` are the same as tokens as before, only the weights are different, i.e., this would just rebalance the portfolio. The function call then starts the auction.  The important step to note is that the `tokensNeeded` value in `settleAuction` determines how many tokens need to stay in the `basket`. If we can continuously lower this value, we can keep removing tokens from the `basket` until it is empty.  The `tokensNeeded` variable is computed as `basketAsERC20.totalSupply() * pendingWeights[i] * newRatio / BASE / BASE`. The only variable that changes in the computation when re-entering the function is `newRatio` (no basket tokens are burned, and the pending weights are never cleared).  Thus if we can show that `newRatio` decreases on each re-entrant call, we can move out more and more funds each time.  #### newRatio decreases on each call After some time, the attacker calls `bondForRebalance`. This determines the `bondTimestamp - auctionStart` value in `settleAuction`. The attack is possible as soon as `newRatio < basket.ibRatio()`. For example, using the standard parameters the calculation would be:  ```solidity // a = 2 * ibRatio uint256 a = factory.auctionMultiplier() * basket.ibRatio(); // b = (bondTimestamp - auctionStart) * 1e14 uint256 b = (bondTimestamp - auctionStart) * BASE / factory.auctionDecrement(); // newRatio = a - b = 2 * ibRatio - (bondTimestamp - auctionStart) * 1e14 uint256 newRatio = a - b; ```  With our initial assumption of `ibRatio = 1e18` and calling `bondForRebalance` after 11,000 seconds (~3 hours) we will get our result that `newRatio` is less than the initial `ibRatio`:  ```python newRatio = a - b = 2 * 1e18 - (11000) * 1e14 = 2e18 - 1.1e18 = 0.9e18 < 1e18 = basket.ibRatio ```  > This seems to be a reasonable value (when the pending tokens and weights are equal in value to the previous ones) as no other bonder would want to call this earlier such when `newRatio > basket.ibRatio` as they would put in more total value in tokens as they can take out of the basket.  #### re-enter on settleAuction The attacker creates a custom token `attackerToken` that re-enters the `Auction.settleAuction` function on `transferFrom` with parameters we will specify.  They call `settleAuction` with `inputTokens = [attackerToken]` to re-enter several times.  In the inner-most call where `newRatio = 0.9e18`, they choose the `inputTokens`/`outputTokens` parameters in a way to pass the initial `require(IERC20(pendingTokens[i]).balanceOf(address(basket)) >= tokensNeeded);` check - transferring out any other tokens of `basket` with `outputTokens`.  The function will continue to run and call `basket.setNewWeights();` and `basket.updateIBRatio(newRatio);` which will set the new weights (but not clear the pending ones) and set the new `basket.ibRatio`.  Execution then jumps to the 2nd inner call after the `IERC20(inputTokens[i]=attackerToken).safeTransferFrom(...)` and has the chance to transfer out tokens again. It will compute `newRatio` with the new lowered `basket.ibRatio` of `0.9e18`: `newRatio = a - b = 2 * 0.9e18 - 1.1e18 = 0.7e18`. Therefore, `tokensNeeded` is lowered as well and the attacker was allowed to transfer out more tokens having carefully chosen `outputWeights`.  This repeats with `newRatio = 0.3`.  The attack is quite complicated and requires carefully precomputing and then setting the parameters, as well as sending back the `bondAmount` tokens to the `auction` contract which are then each time transferred back in the function body. But I believe this should work.  ## Impact The basket funds can be stolen.  ## Recommended Mitigation Steps Add re-entrancy checks (for example, OpenZeppelin's \"locks\") to the `settleAuction` function.    "}, {"title": "Setting wrong publisher cannot be undone", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/222", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  cmichel   # Vulnerability details  The `Basket.changePublisher` function is used for both setting a new pending publisher as well as accepting the publisher transfer **from** the pending publisher.  ## Impact Once a pending publisher has been set, no other publisher can be set and if the pending publisher does not accept it, the contract is locked out of setting any other publishers. Setting a wrong publisher can naturally occur.  ## Recommended Mitigation Steps Add an option to set a new pending publisher even if there already is a pending publisher.   "}, {"title": "Re-entrancy in `Factory.createBasket`", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/219", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  cmichel   # Vulnerability details  A basket creator can specify a custom token that allows them to re-enter in `Factory.createBasket`.  ## Impact As new auction and basket contracts are created every time, no cross-basket issues arise. However, note that the official `BasketCreated` event is emitted for all of them, but only the last basket is stored for the `idNumber`. This could lead to issues for some backend / frontend scripts that use the `BasketCreated` event.  ## Recommended Mitigation Steps Set `_proposals[idNumber].basket = address(newBasket);` immediately after the `newBasket` contract clone has been created to avoid the re-entrancy.   "}, {"title": "Wrong constant for `ONE_DAY`", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/218", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-09-defiprotocol-findings", "body": "Wrong constant for `ONE_DAY`"}, {"title": "Style issues", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/217", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-09-defiprotocol-findings", "body": "Style issues"}, {"title": "Eliminate hasBonded", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/216", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-09-defiprotocol-findings", "body": "Eliminate hasBonded"}, {"title": "newIbRatio is not really useful", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/215", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact It is unclear why you need this new local variable called newIbRatio if you instantly update and use the storage variable afterwards:   uint256 newIbRatio = ibRatio * startSupply / totalSupply();   ibRatio = newIbRatio;  ## Recommended Mitigation Steps   ibRatio = ibRatio * startSupply / totalSupply();  "}, {"title": "Mint fees can be simplified", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/214", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact This can be refactored to improve precision and gas usage:   _mint(publisher, fee * (BASE - factory.ownerSplit()) / BASE);   _mint(Ownable(address(factory)).owner(), fee * factory.ownerSplit() / BASE);  ## Recommended Mitigation Steps Proposed solution:   uint256 factoryOwnerFee = fee * factory.ownerSplit() / BASE;   uint256 publisherFee = fee - factoryOwnerFee;   _mint(Ownable(address(factory)).owner(), factoryOwnerFee);   _mint(publisher, publisherFee); This will result in fewer math operations and better precision cuz multiplication and division are replaced with subtraction.  "}, {"title": "Dead code", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/211", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "Dead code"}, {"title": "Double division by BASE", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/210", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact This double division by BASE can be eliminated to improve precision and reduce gas costs:    uint256 tokensNeeded = basketAsERC20.totalSupply() * pendingWeights[i] * newRatio / BASE / BASE;  ## Recommended Mitigation Steps if you introduce a constant variable, e.g.:    uint256 private constant BASE_2X = BASE * 2;    uint256 tokensNeeded = basketAsERC20.totalSupply() * pendingWeights[i] * newRatio / BASE_2X;  "}, {"title": "Check the actual amounts transferred", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/206", "labels": ["bug", "duplicate", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-09-defiprotocol-findings", "body": "Check the actual amounts transferred"}, {"title": "emit NewIBRatio in function initialize", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/205", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact I think function initialize should also emit NewIBRatio event as it sets the initial value:  ibRatio = BASE;  ## Recommended Mitigation Steps emit NewIBRatio(ibRatio) in function initialize.  "}, {"title": "Hardcoding numbers is error-prone", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/203", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact Hardcoding numbers that depend on other variables is error-prone, e.g.     require(newOwnerSplit <= 2e17); // 20% You must not forget to update this if you decide to change the BASE value.  ## Recommended Mitigation Steps  Better define a separate constant that directly depends on the BASE, e.g.:     uint256 private constant MAX_OWNER_SPLIT = BASE / 5; // 20%     require(newOwnerSplit <= MAX_OWNER_SPLIT);  "}, {"title": "Inconvenient to find bounty ids", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/202", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact In function settleAuction user needs to decide what bounties he/she wants to claim:     function settleAuction(         uint256[] memory bountyIDs     ...     withdrawBounty(bountyIDs); but bounties are stored in a private variable:    Bounty[] private _bounties; and there are no getter (view) functions to view bounties so I think that makes it very inconvenient for the end-user to find the appropriate ids that are relevant, especially considering there could be SPAM bounties as anyone can call addBounty.  ## Recommended Mitigation Steps Consider exposing public view functions to view bounties.  "}, {"title": "licenseFee state variable not checked for maximum value (Basket.sol)", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/200", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "sponsor acknowledged"], "target": "2021-09-defiprotocol-findings", "body": "licenseFee state variable not checked for maximum value (Basket.sol)"}, {"title": "redundant code (unused variables)", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/198", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  hack3r-0m   # Vulnerability details  https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Auction.sol#L14  BLOCK_DECREMENT is never used.  "}, {"title": "Use safeTransfer instead of transfer", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/196", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  hack3r-0m   # Vulnerability details  https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Auction.sol#L146   `transfer()` might return false instead of reverting, in this case, ignoring return value leads to considering it successful.  use `safeTransfer()` or check the return value if length of returned data is > 0.  "}, {"title": "block timestamp manipulation can cause fees change", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/195", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-09-defiprotocol-findings", "body": "block timestamp manipulation can cause fees change"}, {"title": "Lack of Event Logging and Input Validation", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/193", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "sponsor acknowledged"], "target": "2021-09-defiprotocol-findings", "body": "Lack of Event Logging and Input Validation"}, {"title": "`onlyOwner` Role Can Unintentionally Influence `settleAuction()`", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/192", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2021-09-defiprotocol-findings", "body": "`onlyOwner` Role Can Unintentionally Influence `settleAuction()`"}, {"title": "Max approvals are risky if contract is malicious/compromised\u2028", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/191", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-09-defiprotocol-findings", "body": "Max approvals are risky if contract is malicious/compromised\u2028"}, {"title": "Recognize the risk of using approve", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/190", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  While safeApprove is used in the Factory contract, the use of ERC20 approve in approveUnderlying() (instead of safeApprove) is presumably to handle the reapprovals during changing of index but is susceptible to the historical ERC20 approve() race condition.  ## Proof of Concept  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L226  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Factory.sol#L106  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps  Be aware that this is susceptible to race-condition but this it unlikely a concern because the spender is always the auction contract which is cloned and therefore trusted.  "}, {"title": "Resetting partial struct fields is risky", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/189", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-09-defiprotocol-findings", "body": "Resetting partial struct fields is risky"}, {"title": "2-step change of publisher address and licenseFee does not generate warning event\u2028", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/188", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact Another big aspect of a 2-step change, such as done with changePublisher() and changeLicenseFee(), is to generate an event when the new address or license fee is registered for change, pending the timelock duration. This is to warn protocol users that a pending change is upcoming (after the timelock) via offchain signalling so they can monitor/notice and decide to engage/exit based on their perception of the impact from the change.  The current implementation only emits an event when the pending change is enforced but not when it is made pending which does not provide one of the biggest benefits of a 2-step change.  ## Proof of Concept  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L143-L147  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L161-L165  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Add another event when the new publisher or licenseFee is made pending.  "}, {"title": " Incorrectly used new publisher and new licenseFee cannot be changed", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/186", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact A big aspect of a 2-step change, such as done with changePublisher() and changeLicenseFee(), is to allow any incorrectly used new addresses/values to be changed during the timelock period. This requires allowing the newPublisher or newLicenseFee to be a different value from the one used during the earlier approve and resetting the timelock again.  The current implementation only allows setting it once to a non-zero address/value and prevents any such corrections from being made (by checking that the address/value used is the same as that used during the first approve) which enforces the timelock to prevent surprises to users but does not provide the other accident benefits of using a timelock.  ## Proof of Concept  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L137  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L136-L147  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L155  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L154-L165  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps  Recommend adding \"&& pendingPublisher.publisher == newPublisher\u201d and \"&& pendingLicenseFee.licenseFee == newLicenseFee\" to the if conditional predicate expression along with removing of the require() statement for equality check inside the conditional, to allow resetting the pending address/value to a new one if previously used one was incorrect.  "}, {"title": "Publisher role cannot be renounced", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/185", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Renouncing ownership is desirable in certain scenarios and is typically allowed by libraries such as Ownable.  The same may be true of the publisher role in this protocol as well to prevent changing the license fee or re-indexing the basket forever.   This is typically done by assigning a zero address to such a role i.e. burning it. However, by requiring any new proposed publisher address to be != zero address, the current implementation does not provide an option to renounce a publisher role by burning it.  ## Proof of Concept  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L134  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Consider adding support to renounce the publisher role or specify why this is not a desirable requirement for the protocol.  "}, {"title": "Using the latest compiler version may be susceptible to undiscovered bugs", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/180", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-09-defiprotocol-findings", "body": "Using the latest compiler version may be susceptible to undiscovered bugs"}, {"title": "Missing emission of basket ID and token composition", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/178", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor acknowledged"], "target": "2021-09-defiprotocol-findings", "body": "Missing emission of basket ID and token composition"}, {"title": "Missing support for (preventing) use of deflationary tokens in baskets", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/177", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-09-defiprotocol-findings", "body": "Missing support for (preventing) use of deflationary tokens in baskets"}, {"title": "Risk of duplicate/scam basket token names/symbols may trick users", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/176", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-09-defiprotocol-findings", "body": "Risk of duplicate/scam basket token names/symbols may trick users"}, {"title": "Hardcoded constants are risky", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/174", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Hardcoded constants in code is risky for auditability/readability/maintainability. The Factory contract uses 2e17 as a threshold check for ownerSplit instead of using a contract constant as done in other places.  ## Proof of Concept https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Factory.sol#L56  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Create a contract constant and use that as done in other places.  "}, {"title": "Missing sanity/threshold checks on critical contract parameter initializations", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/173", "labels": ["bug", "1 (Low Risk)"], "target": "2021-09-defiprotocol-findings", "body": "Missing sanity/threshold checks on critical contract parameter initializations"}, {"title": "Missing timelocks for critical protocol parameter setters by owner\u2028", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/172", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-09-defiprotocol-findings", "body": "Missing timelocks for critical protocol parameter setters by owner\u2028"}, {"title": "Missing events for critical protocol parameter setters by owner", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/171", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  None of the Factory owner setter functions emit events to record these changes on-chain for off-chain monitors/tools/interfaces to register the updates and react if necessary.  The impact of this is that a malicious/compromised/careless owner can intentionally/accidentally changes the minLicenseFee, auctionDecrement, auctionMultiplier, bondPercentDiv or ownerSplit values that significantly change the security/financial posture/perception of the protocol. No events are emitted and users may lose funds/confidence without being a chance to exit/engage protocol. The protocol takes a reputation hit.   See similar high-severity finding in\u00a0OpenZeppelin\u2019s Audit of Audius (https://blog.openzeppelin.com/audius-contracts-audit/#high)\u00a0and medium-severity finding\u00a0OpenZeppelin\u2019s Audit of UMA Phase 4: https://blog.openzeppelin.com/uma-audit-phase-4/.  ## Proof of Concept  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Factory.sol#L39-L41  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Factory.sol#L43-L45  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Factory.sol#L47-L49  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Factory.sol#L51-L53  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Factory.sol#L55-L59   ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Recommend to consider emitting events when protocol critical values are updated by owner. This will be more transparent and it will make it easier to keep track of the status of the system.  "}, {"title": "Lack of indexed event parameters will affect offchain monitoring", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/169", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor acknowledged"], "target": "2021-09-defiprotocol-findings", "body": "Lack of indexed event parameters will affect offchain monitoring"}, {"title": "Incorrect data location specifier can be abused to cause DoS and fund loss", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/168", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The withdrawBounty() loops through the _bounties array looking for active bounties and transferring amounts from active ones. However, the data location specifier used for bounty is memory which makes a copy of the _bounties array member instead of a reference. So when bounty.active is set to false, this is changing only the memory copy and not the array element of the storage variable. This results in bounties never being set to inactive, keeping them always active forever and every withdrawBounty() will attempt to transfer bounty amount from the Auction contract to the msg.sender.  Therefore, while the transfer will work the first time, subsequent attempts to claim this bounty will revert on transfer (because the Auction contract will not have required amount of bounty tokens) causing withdrawBounty() to always revert and therefore preventing settling of any auction.   A malicious attacker can add a tiny bounty on any/every Auction contract to prevent any reindexing on that contract to happen because it will always revert on auction settling. This can be used to cause DoS on any auctionBonder so as to make them lose their bondAmount because their bonded auction cannot be settled.  ## Proof of Concept  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Auction.sol#L143  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Auction.sol#L143-L147  https://docs.soliditylang.org/en/v0.8.7/types.html#data-location-and-assignment-behaviour  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Recommend changing storage specifier of bounty to \"storage\" instead of \u201cmemory\".  "}, {"title": "Bounty list is never pruned to remove inactive bounties", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/165", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Given that there is no removal of claimed/inactive bounties, the bounty list could grow very long over time requiring a lot of gas for traversal.  ## Proof of Concept  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Auction.sol#L126-L151  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Recommend pruning the claimed bounties by deleting them from the list.  "}, {"title": "Missing interfaces to determine available bounties", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/164", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor acknowledged"], "target": "2021-09-defiprotocol-findings", "body": "Missing interfaces to determine available bounties"}, {"title": "Event params are of no practical value", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/163", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  hack3r-0m   # Vulnerability details  https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Factory.sol#L87  ``` emit BasketLicenseProposed(msg.sender, tokenName); ```  same event can be emitted with excat same parameters multiple times causing confusion to actors relying on it.   Mitigation:  Add proposal id or some other parameter  "}, {"title": "Malicious tokens can execute arbitrary code", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/162", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-09-defiprotocol-findings", "body": "Malicious tokens can execute arbitrary code"}, {"title": "Gas Optimization Wrt. Token Uniqueness", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/160", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  leastwood   # Vulnerability details  ## Impact  The `validateWeights()` function can be better optimised by using a hashmap to measure token uniqueness. Currently, the function utilises an `O(n^2)` solution. By first iterating through each hashmap index for `_tokens`, any previously set tokens can be first cleared . This improves the current solution to `O(n)`.  ## Proof of Concept  https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Basket.sol#L53-L70  ## Tools Used  Manual code review  ## Recommended Mitigation Steps  Consider using a hashmap to measure token uniqueness. However, this hashmap needs to first be cleared out before using it each time in `validateWeights()`.  "}, {"title": "Missing check for auctionOngoing is risky", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/157", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  killAuction() is missing a require() to check that auctionOngoing == true before setting it to false. While currently, the caller publishNewIndex() in Basket has this condition checked, any other usages may accidentally call this when auction is not ongoing.  ## Proof of Concept https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Auction.sol#L43-L45  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L175-L187  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Add require(auctionOngoing == true)  "}, {"title": "Unused constant", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/156", "labels": ["bug", "G (Gas Optimization)", "disagree with severity", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Unused constant BLOCK_DECREMENT may be an indication of missing logic or redundant code. In this case, this appears to be a redundant constant same as Factory.auctionDecrement.  ## Proof of Concept  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Auction.sol#L14  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Use the constant or remove it.  "}, {"title": "Choose either explicit return or named return, not both", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/154", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Choosing either named return or explicit instead of specifying both may reduce gas due to unnecessary bytecode introduced. proposeBasketLicense() uses a named return variable which is never assigned and instead uses an explicit return statement.  ## Proof of Concept  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Factory.sol#L71  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Factory.sol#L90  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Choose either explicit return or named return, not both  "}, {"title": "Avoiding unnecessary return can save gas", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/153", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact Unnecessary return of argument value via state variable which costs a SLOAD, returns the same value as argument back to caller where the return value is ignored.  ## Proof of Concept  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L221  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L216-L222  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Auction.sol#L104  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps  Remove return value for this function.  "}, {"title": "Loop can be skipped for i == 0", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/151", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-09-defiprotocol-findings", "body": "Loop can be skipped for i == 0"}, {"title": "Unnecessary initialization of loop index variable", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/150", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-09-defiprotocol-findings", "body": "Unnecessary initialization of loop index variable"}, {"title": "Using delete to clear variables instead of zero assignment\u2028", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/149", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-09-defiprotocol-findings", "body": "Using delete to clear variables instead of zero assignment\u2028"}, {"title": "Caching return values of external calls in local/memory variables avoids CALLs to save gas\u2028", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/147", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  There are places across contracts where the same external calls are made multiple times within a function. Caching return values of such calls in local/memory variables avoids CALLs to save gas. CALLs cost 2600 gas after Berlin upgrade. MLOADs cost only 3 gas units.  ## Proof of Concept  Cache factory.ownerSplit() return value to save 2600 gas in this function which gets called at every mint/burn.: https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L120-L121  Hoist basketAsERC20.totalSupply() external call out of the loop because it remains the same and each call costs 2600 gas: https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Auction.sol#L96-L99  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Cache return values of external calls in local/memory variables  "}, {"title": "Caching state variables in local/memory variables avoids SLOADs to save gas", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/145", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "Caching state variables in local/memory variables avoids SLOADs to save gas"}, {"title": "Avoiding state variables in emits saves gas\u2028", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/143", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-09-defiprotocol-findings", "body": "Avoiding state variables in emits saves gas\u2028"}, {"title": "Lack of guarded launch approach may be risky", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/139", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-09-defiprotocol-findings", "body": "Lack of guarded launch approach may be risky"}, {"title": "`Auction.sol#initialize()` Use msg.sender rather than factory_ parameter can save gas", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/137", "labels": ["bug", "duplicate", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Auction.sol#L47-L52  `Auction.sol#initialize()` is using the factory_ parameter as the value of `factory`, while `Basket.sol#initialize()` uses `msg.sender`.  https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Basket.sol#L39  Consider changing to `msg.sender` and remove the `factory_` parameter for the purpose of consistency and gas saving.  "}, {"title": "`Auction.sol#settleAuction()` Mishandling bounty state could potentially disrupt `settleAuction()`", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/136", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Auction.sol#L143  ```solidity=140 function withdrawBounty(uint256[] memory bountyIds) internal {     // withdraw bounties     for (uint256 i = 0; i < bountyIds.length; i++) {         Bounty memory bounty = _bounties[bountyIds[i]];         require(bounty.active);          IERC20(bounty.token).transfer(msg.sender, bounty.amount);         bounty.active = false;          emit BountyClaimed(msg.sender, bounty.token, bounty.amount, bountyIds[i]);     } } ```  In the `withdrawBounty` function, `bounty.active` should be set to `false` when the bounty is claimed.  However, since `bounty` is stored in memory, the state update will not succeed.  ### Impact  An auction successfully bonded by a regular user won't be able to be settled if they passed seemly active bountyIds, and the bonder will lose the bond.   ### Proof of Concept  1. Create an auction; 2. Add a bounty; 3. Auction settled with bounty claimed; 4. Create a new auction; 5. Add a new bounty; 6. Calling `settleAuction()` with the bountyIds of the 2 seemly active bounties always reverts.  ### Recommended Mitigation Steps  Change to:  ```solidity= Bounty storage bounty = _bounties[bountyIds[i]]; ```  "}, {"title": "Adding unchecked directive can save gas", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/135", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-09-defiprotocol-findings", "body": "Adding unchecked directive can save gas"}, {"title": "`Basket.sol#auctionBurn()` A failed auction will freeze part of the funds", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/134", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Basket.sol#L102-L108  Given the `auctionBurn()` function will `_burn()` the auction bond without updating the `ibRatio`. Once the bond of a failed auction is burned, the proportional underlying tokens won't be able to be withdrawn, in other words, being frozen in the contract.  ### Proof of Concept  With the configuration of:  basket.ibRatio = 1e18 factory.bondPercentDiv = 400 basket.totalSupply = 400 basket.tokens = [BTC, ETH] basket.weights = [1, 1]  1. Create an auction; 2. Bond with 1 BASKET TOKEN; 3. Wait for 24 hrs and call `auctionBurn()`;  `basket.ibRatio` remains to be 1e18; basket.totalSupply = 399.  Burn 1 BASKET TOKEN will only get back 1 BTC and 1 ETH, which means, there are 1 BTC and 1 ETH frozen in the contract.  ### Recommended Mitigation Steps  Change to:  ```solidity= function auctionBurn(uint256 amount) onlyAuction external override {     handleFees();     uint256 startSupply = totalSupply();     _burn(msg.sender, amount);      uint256 newIbRatio = ibRatio * startSupply / (startSupply - amount);     ibRatio = newIbRatio;      emit NewIBRatio(newIbRatio);     emit Burned(msg.sender, amount); } ```  "}, {"title": "Fee calculation is potentially incorrect", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/129", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  itsmeSTYJ   # Vulnerability details  ## Impact More fees are actually charged than intended   ## Mitigation Steps  [Basket.sol line 118](https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Basket.sol#L118)   Assume that license fee is 10% i.e. 1e17 and time diff = half a year.   When you calculate `feePct`, you expect to get 5e16 since that's 5% and the actual amount of fee to be charged should be totalSupply * feePct (5) / BASE (100) but on line 118, we are actually dividing by BASE - feePct i.e. 95.   5 / 95 = 0.052 instead of the intended 0.05.  Solution is to replace `BASE - feePct` in the denominator with `BASE`.  "}, {"title": " Protocol owner fee limit not verified correctly (Factory.sol)", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/127", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-09-defiprotocol-findings", "body": " Protocol owner fee limit not verified correctly (Factory.sol)"}, {"title": "Settle Time Limit not set correctly (Auction.sol)", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/126", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-09-defiprotocol-findings", "body": "Settle Time Limit not set correctly (Auction.sol)"}, {"title": "Variable assignment has no effect", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/124", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  nikitastupin   # Vulnerability details  Here https://github.com/code-423n4/2021-09-defiProtocol/blob/e6dcf43a2f03aa65e04f0edc8ed1d7272677fabe/contracts/contracts/Auction.sol#L143-L143 the `bounty` variable is copied from Storage to Memory. Later it's assigned to false https://github.com/code-423n4/2021-09-defiProtocol/blob/e6dcf43a2f03aa65e04f0edc8ed1d7272677fabe/contracts/contracts/Auction.sol#L147. However, this assignment has no effect because `bounty` variable located at Memory so it's basically just thrown away when loop iteration finishes.  I think the intention was to make the `bounty.active` false so the same bounty isn't claimed twice or more times https://github.com/code-423n4/2021-09-defiProtocol/blob/e6dcf43a2f03aa65e04f0edc8ed1d7272677fabe/contracts/contracts/Auction.sol#L144. However, the `bounty.active` will always be true because it never changes to false except for https://github.com/code-423n4/2021-09-defiProtocol/blob/e6dcf43a2f03aa65e04f0edc8ed1d7272677fabe/contracts/contracts/Auction.sol#L147 (which has no effect).  ## Impact  I don't see the direct impact here, however it may arise with the future changes to the contracts.  ## Proof of Concept  I'll write a PoC if needed.  ## Recommended Mitigation Steps  Do `_bounties[bountyIds[i]].active = false` instead of `bounty.active = false` if you need this check or just remove `bounty.active = false` and `require(bounty.active)` lines to save a gas otherwise.  "}, {"title": "Timelocked functions doesn't emit proposal events", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/123", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  nikitastupin   # Vulnerability details  Usually timelock is used in order to give a users of a protocol time to react on protocol changes (e.g. to withdraw their funds). Thus timelock implementations have Proposal and Execution steps. The main way to monitor blockchain changes and react to them is to listen for emitted events. However, none of the timelocked functions (`changePublisher`, `changeLicenseFee`, `publishNewIndex`) emits an event on Proposal step (e.g. https://github.com/code-423n4/2021-09-defiProtocol/blob/e6dcf43a2f03aa65e04f0edc8ed1d7272677fabe/contracts/contracts/Basket.sol#L144-L147), they emit an event only on Execution step (e.g. https://github.com/code-423n4/2021-09-defiProtocol/blob/e6dcf43a2f03aa65e04f0edc8ed1d7272677fabe/contracts/contracts/Basket.sol#L143-L143).  ## Impact  Events aren't emitted at critical functions.  ## Proof of Concept  I'll write a PoC if needed.  ## Recommended Mitigation Steps  Add events after (1) https://github.com/code-423n4/2021-09-defiProtocol/blob/e6dcf43a2f03aa65e04f0edc8ed1d7272677fabe/contracts/contracts/Basket.sol#L145-L146, (2) https://github.com/code-423n4/2021-09-defiProtocol/blob/e6dcf43a2f03aa65e04f0edc8ed1d7272677fabe/contracts/contracts/Basket.sol#L163-L164, (3) https://github.com/code-423n4/2021-09-defiProtocol/blob/e6dcf43a2f03aa65e04f0edc8ed1d7272677fabe/contracts/contracts/Basket.sol#L189-L192 and https://github.com/code-423n4/2021-09-defiProtocol/blob/e6dcf43a2f03aa65e04f0edc8ed1d7272677fabe/contracts/contracts/Basket.sol#L182-L186.  "}, {"title": "Timelock period may be less than 24 hours because it depends on `block.number` instead of `block.timestamp`", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/122", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-09-defiprotocol-findings", "body": "Timelock period may be less than 24 hours because it depends on `block.number` instead of `block.timestamp`"}, {"title": "lack of checks in `Factory::setBondPercentDiv` allow owner to prevent bonding in Auction::bondForRebalance()", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/121", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor acknowledged"], "target": "2021-09-defiprotocol-findings", "body": "lack of checks in `Factory::setBondPercentDiv` allow owner to prevent bonding in Auction::bondForRebalance()"}, {"title": "lack of checks in Factory.setAuctionMultiplier", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/120", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-09-defiprotocol-findings", "body": "lack of checks in Factory.setAuctionMultiplier"}, {"title": "Factory.sol - lack of checks in `setAuctionDecrement` will cause reverts in Auction::settleAuction()", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/119", "labels": ["bug", "2 (Med Risk)", "disagree with severity", "sponsor acknowledged"], "target": "2021-09-defiprotocol-findings", "body": "Factory.sol - lack of checks in `setAuctionDecrement` will cause reverts in Auction::settleAuction()"}, {"title": "Factory.sol - lack of checks for setMinLicenseFee", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/118", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-09-defiprotocol-findings", "body": "Factory.sol - lack of checks for setMinLicenseFee"}, {"title": "specs not according to the docs", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/115", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-09-defiprotocol-findings", "body": "specs not according to the docs"}, {"title": "use of approve() instead of safeApprove()", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/114", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  JMukesh   # Vulnerability details  ## Impact by using approve() , we are not checking the value returned by the approve ,wether it got failed or successfully executed. so it is safe to use safeApproval()  ## Proof of Concept  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L226  ## Tools Used manual review  ## Recommended Mitigation Steps use safeApprove()  "}, {"title": "lack of checking of array length", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/111", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  JMukesh   # Vulnerability details  ## Impact due to lack of checking of array parameters in settleAuction()  , these array parameters can have different length which can lead to error.  inputWeight is iterated over the length of inputToken if one of the parameter have less length than other one will become inaccessible   which can lead to error  ## Proof of Concept  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Auction.sol#L69  ## Tools Used  manual review  ## Recommended Mitigation Steps  "}, {"title": "Packing storage variables in Auction would save gas", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/109", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-09-defiprotocol-findings", "body": "Packing storage variables in Auction would save gas"}, {"title": "settleAuction should be external and arguments should use calldata", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/108", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  t11s   # Vulnerability details  ## Impact Gas is wasted making `settleAuction` public, and using `memory` Instead of calldata for its arguments.  ## Proof of Concept  https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Auction.sol#L69  "}, {"title": "licenseFee can be greater than BASE", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/104", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2021-09-defiprotocol-findings", "body": "licenseFee can be greater than BASE"}, {"title": "tokensNeeded can potentially be 0", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/101", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  itsmeSTYJ   # Vulnerability details  ## Impact  If tokensNeeded is 0, it is possible to remove all the funds in the basket since no tokens are required to pass the balanceOf checks. The chances of this happening is very unlikely however it is better to be safe than sorry.   ## Recommended Mitigation Steps  Add a require statement to check that the numerator (`basketAsERC20.totalSupply() * pendingWeights[i] * newRatio`) is greater than or eq to the denominator (`BASE * BASE`). This will ensure that it can never round down i.e. tokensNeeded can never be 0.  "}, {"title": "Suggestion for incentive alignment", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/99", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-09-defiprotocol-findings", "body": "Suggestion for incentive alignment"}, {"title": "Misleading variable names", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/98", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-09-defiprotocol-findings", "body": "Misleading variable names"}, {"title": "Use CEI pattern to align w/ best practices", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/97", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-09-defiprotocol-findings", "body": "Use CEI pattern to align w/ best practices"}, {"title": "Only validateWeights when it is needed", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/95", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-09-defiprotocol-findings", "body": "Only validateWeights when it is needed"}, {"title": "set lastFee in initialize() function", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/94", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  itsmeSTYJ   # Vulnerability details  ## Impact  Gas optimisation  ## Recommended Mitigation Steps  The if branch in the handleFee() function is only there to handle the very first time handleFees are called. Thereafter, this condition will always fail so it makes more sense to initialize it with the initialize() function.  ```jsx function initialize(IFactory.Proposal memory proposal, IAuction auction_) public override {     publisher = proposal.proposer;     licenseFee = proposal.licenseFee;     factory = IFactory(msg.sender);     auction = auction_;     ibRatio = BASE;     tokens = proposal.tokens;     weights = proposal.weights;   lastFee = block.timestamp;      // updated lastFee here     approveUnderlying(address(auction));      __ERC20_init(proposal.tokenName, proposal.tokenSymbol); } ...  function handleFees() private {     // if (lastFee == 0) {            // delete this     //     lastFee = block.timestamp; // delete this     // } else {                       // delete this     uint256 startSupply = totalSupply();      uint256 timeDiff = (block.timestamp - lastFee);     uint256 feePct = timeDiff * licenseFee / ONE_YEAR;     uint256 fee = startSupply * feePct / (BASE - feePct);      _mint(publisher, fee * (BASE - factory.ownerSplit()) / BASE);     _mint(Ownable(address(factory)).owner(), fee * factory.ownerSplit() / BASE);     lastFee = block.timestamp;      uint256 newIbRatio = ibRatio * startSupply / totalSupply();     ibRatio = newIbRatio;      emit NewIBRatio(ibRatio);     // }                              // delete this } ```  "}, {"title": "Transfer tokens directly to the basket", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/92", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-09-defiprotocol-findings", "body": "Transfer tokens directly to the basket"}, {"title": "`Auction.sol#settleAuction()` late auction bond could potentially not being able to be settled, cause funds loss to bonder", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/90", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  WatchPug   # Vulnerability details  The `newRatio` that determines `tokensNeeded` to settle the auction is calculated based on `auctionMultiplier`, `bondTimestamp - auctionStart` and `auctionDecrement`.  ```solidity= uint256 a = factory.auctionMultiplier() * basket.ibRatio(); uint256 b = (bondTimestamp - auctionStart) * BASE / factory.auctionDecrement(); uint256 newRatio = a - b; ```  However, if an auction is bonded late (`bondTimestamp - auctionStart` is a large number), and/or the `auctionMultiplier` is small enough, and/or the `auctionDecrement` is small enough, that makes `b` to be greater than `a`, so that `uint256 newRatio = a - b;` will revert on underflow.  This might seem to be an edge case issue, but considering that a rebalance auction of a bag of shitcoin to high-value tokens might just end up being bonded at the last minute, with a `newRatio` near zero. When we take the time between the bonder submits the transaction and it got packed into a block, it's quite possible that the final `bondTimestamp` gets large enough to revet `a - b`.  ### Impact  An auction successfully bonded by a regular user won't be able to be settled, and the user will lose the bond.  ### Proof of Concept  With the configuration of:  basket.ibRatio = 1e18 factory.auctionDecrement = 5760 (Blocks per day) factory.auctionMultiplier = 2  1. Create an auction; 2. The auction remain inactive (not get bonded) for more than 2 days (>11,520 blocks); 3. Call `bondForRebalance()` and it will succeed; 4. Calling `settleAuction()` will always revert.  ### Recommended Mitigation Steps  Calculate and require `newRatio > 0` in `bondForRebalance()`, or limit the max value of decrement and make sure newRatio always > 0 in `settleAuction()`.  "}, {"title": "`Factory.sol` Lack of two-step procedure and/or input validation routines for critical operations leaves them error-prone", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/89", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-09-defiprotocol-findings", "body": "`Factory.sol` Lack of two-step procedure and/or input validation routines for critical operations leaves them error-prone"}, {"title": "Missing Zero-Address Checks", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/86", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-09-defiprotocol-findings", "body": "Missing Zero-Address Checks"}, {"title": "Redundant Balance Check", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/85", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  shenwilly   # Vulnerability details  ## Impact OpenZeppelin ERC20Upgradeable `_burn` already checks for account balance, so another check is unnecessary.   ## Proof of Concept https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L92   ## Recommended Mitigation Steps Remove the require statement  "}, {"title": "Lack of zero ratio validation", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/83", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  defsec   # Vulnerability details  ## Impact  During the manual code review, It has been observed that zero value has not been checked on that \"ibRatio\" variable. That can cause  miscalculation of the liquidity.   ## Proof of Concept  1. Navigate to \"https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Basket.sol\" 2. Go to the line #217.  \"\"\"         ibRatio = newRatio; \"\"\"  3. Onlyauction modifier can assign ibRation to 0. 4. That can affect tokenAmount on the function.   \"\"\"     function pushUnderlying(uint256 amount, address to) private {         for (uint256 i = 0; i < weights.length; i++) {             uint256 tokenAmount = amount * weights[i] * ibRatio / BASE / BASE;             IERC20(tokens[i]).safeTransfer(to, tokenAmount);         }     } \"\"\"  ## Tools Used  None  ## Recommended Mitigation Steps  Validate to ibRatio variable is more than zero.  \"\"\" require(ibRation > 0 , \"ibRatio should be more than zero\"); \"\"\"  "}, {"title": "`Auction.sol#settleAuction()` addBounty with a fake token could potentially disrupt `settleAuction()`", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/82", "labels": ["bug", "1 (Low Risk)"], "target": "2021-09-defiprotocol-findings", "body": "`Auction.sol#settleAuction()` addBounty with a fake token could potentially disrupt `settleAuction()`"}, {"title": "User can mint miniscule amount of shares, later withdraw miniscule more than deposited", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/81", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  kenzo   # Vulnerability details  If a user is minting small amount of shares (like 1 - amount depends on baskets weights), the calculated amount of tokens to pull from the user can be less than 1, and therefore no tokens will be pulled. However the shares would still be minted. If the user does this a few times, he could then withdraw the total minted shares and end up with more tokens than he started with - although a miniscule amount.  ## Impact User can end up with more tokens than he started with. However, I didn't find a way for the user to get an amount to make this a feasible attack. He gets dust. However he can still get more than he deserves. If for some reason the basket weights grow in a substantial amount, this could give the user more tokens that he didn't pay for.  ## Proof of Concept Add the following test to Basket.test.js. The user starts with 5e18 UNI, 1e18 COMP, 1e18 AAVE, and ends with 5e18+4, 1e18+4, 1e18+4. ``` it(\"should give to user more than he deserves\", async () => {         await UNI.connect(owner).mint(ethers.BigNumber.from(UNI_WEIGHT).mul(1000000));         await COMP.connect(owner).mint(ethers.BigNumber.from(COMP_WEIGHT).mul(1000000));         await AAVE.connect(owner).mint(ethers.BigNumber.from(AAVE_WEIGHT).mul(1000000));            await UNI.connect(owner).approve(basket.address, ethers.BigNumber.from(UNI_WEIGHT).mul(1000000));         await COMP.connect(owner).approve(basket.address, ethers.BigNumber.from(COMP_WEIGHT).mul(1000000));         await AAVE.connect(owner).approve(basket.address, ethers.BigNumber.from(AAVE_WEIGHT).mul(1000000));            console.log(\"User balance before minting:\");         console.log(\"UNI balance: \" + (await UNI.balanceOf(owner.address)).toString());         console.log(\"COMP balance: \" + (await COMP.balanceOf(owner.address)).toString());         console.log(\"AAVE balance: \" + (await AAVE.balanceOf(owner.address)).toString());                   await basket.connect(owner).mint(ethers.BigNumber.from(1).div(1));         await basket.connect(owner).mint(ethers.BigNumber.from(1).div(1));         await basket.connect(owner).mint(ethers.BigNumber.from(1).div(1));         await basket.connect(owner).mint(ethers.BigNumber.from(1).div(1));         await basket.connect(owner).mint(ethers.BigNumber.from(1).div(1));          console.log(\"\\nUser balance after minting 1 share 5 times:\");         console.log(\"UNI balance: \" + (await UNI.balanceOf(owner.address)).toString());         console.log(\"COMP balance: \" + (await COMP.balanceOf(owner.address)).toString());         console.log(\"AAVE balance: \" + (await AAVE.balanceOf(owner.address)).toString());          await basket.connect(owner).burn(await basket.balanceOf(owner.address));         console.log(\"\\nUser balance after burning all shares:\");         console.log(\"UNI balance: \" + (await UNI.balanceOf(owner.address)).toString());         console.log(\"COMP balance: \" + (await COMP.balanceOf(owner.address)).toString());         console.log(\"AAVE balance: \" + (await AAVE.balanceOf(owner.address)).toString());     }); ```  ## Tools Used Manual analysis, hardhat.  ## Recommended Mitigation Steps Add a check to ```pullUnderlying```: ``` require(tokenAmount > 0); ``` I think it makes sense that if a user is trying to mint an amount so small that no tokens could be pulled from him, the mint request should be denied. Per my tests, for an initial ibRatio, this number (the minimal amount of shares that can be minted) is 2 for weights in magnitude of 1e18, and if the weights are eg. smaller by 100, this number will be 101.  "}, {"title": "`Auction.sol#bondTimestamp` Misleading name", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/80", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-09-defiprotocol-findings", "body": "`Auction.sol#bondTimestamp` Misleading name"}, {"title": "`Basket.sol#handleFees()` could potentially cause disruption of minting and burning", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/79", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Basket.sol#L110-L129  ```solidity= function handleFees() private {     if (lastFee == 0) {         lastFee = block.timestamp;     } else {         uint256 startSupply = totalSupply();          uint256 timeDiff = (block.timestamp - lastFee);         uint256 feePct = timeDiff * licenseFee / ONE_YEAR;         uint256 fee = startSupply * feePct / (BASE - feePct);          _mint(publisher, fee * (BASE - factory.ownerSplit()) / BASE);         _mint(Ownable(address(factory)).owner(), fee * factory.ownerSplit() / BASE);         lastFee = block.timestamp;          uint256 newIbRatio = ibRatio * startSupply / totalSupply();         ibRatio = newIbRatio;          emit NewIBRatio(ibRatio);     } } ```  `timeDiff * licenseFee` can be greater than `ONE_YEAR` when `timeDiff` and/or `licenseFee` is large enough, which makes `feePct` to be greater than `BASE` so that `BASE - feePct` will revert on underflow.   ## Impact  Minting and burning of the basket token are being disrupted until the publisher update the `licenseFee`.  ## Proof of Concept  1. Create a basket with a `licenseFee` of `1e19` or 1000% per year and mint 1 basket token; 2. The basket remain inactive (not being minted or burned) for 2 months; 3. Calling `mint` and `burn` reverts at `handleFees()`.  ## Recommended Mitigation Steps  Limit the max value of `feePct`.  "}, {"title": "Use calldata instead of memory in function parameter declarations", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/75", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  chasemartin01   # Vulnerability details  ## Impact Gas optimisation  ## Example As an example, you can change the declaration of `inputTokens`, `inputWeights`, `outputTokens`, `outputWeights` to be `calldata` as a gas optimisation  https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Auction.sol#L69-L75  There's other instances of this in `Basket.sol` and`Factory.sol` ## Explanation When you specify `memory` for a function param for an external function, the following happens: the compiler copies elements from `calldata` to `memory` (using the opcode `calldatacopy`.) Note that there is also the opcode `calldataload` to read an offset from `calldata`. By changing the location from `memory` to `calldata`, you avoid this expensive copy from `calldata` to `memory`, while managing to do exactly what's needed.  ## Tools Used Manual analysis  ## Recommended Mitigation Steps Change all instances of `memory` to `calldata` where the function parameter isn't being modified  "}, {"title": "Not handling approve return value", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/73", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  WatchPug   # Vulnerability details  As defined in the ERC20 Specification, the approve function returns a bool that signals the success of the call. However, in `Basket.sol#approveUnderlying()` the value returned from calls to approve is ignored.  https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Basket.sol#L224-L228  ## Recommended Mitigation Steps  To handle calls to approve safely, consider using the safeApprove function in OpenZeppelin\u2019s SafeERC20 contract for all approvals.  "}, {"title": "`proposal` declared as both a function and a Proposal in Factory", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/71", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  loop   # Vulnerability details  `proposal` is declared as both a function name and the name for a Proposal object.  ## Proof of Concept Factory.sol line 35: `function proposal(uint256 proposalId) external override view returns (Proposal memory) {` Factory.sol line 77: `Proposal memory proposal = Proposal({`  ## Tools Used Remix  ## Recommended Mitigation Steps Change function name to `getProposal` to avoid double naming and be more in line with other getter/setter functions used.  "}, {"title": "Use of uint rather than uint256", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/69", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  loop   # Vulnerability details  In basket.sol there is one use of `uint` rather than `uint256`, which is used in the rest of the codebase.  ## Impact No real impact considering `uint` functions as a `uint256`.  ## Proof of Concept Basket.sol - line 60: `for (uint i = 0; i < length; i++) {`  "}, {"title": "Code lacking comments/spec", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/68", "labels": ["bug", "0 (Non-critical)", "1 (Low Risk)", "disagree with severity", "sponsor acknowledged"], "target": "2021-09-defiprotocol-findings", "body": "Code lacking comments/spec"}, {"title": "Bonding mechanism allows malicious user to DOS auctions", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/66", "labels": ["bug", "duplicate", "2 (Med Risk)", "sponsor acknowledged"], "target": "2021-09-defiprotocol-findings", "body": "Bonding mechanism allows malicious user to DOS auctions"}, {"title": "Basket becomes unusable if everybody burns their shares", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/64", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  kenzo   # Vulnerability details  While handling the fees, the contract calculates the new ibRatio by dividing by totalSupply. This can be 0 leading to a division by 0.  ## Impact If everybody burns their shares, in the next mint, totalSupply will be 0, handleFees will revert, and so nobody will be able to use the basket anymore.  ## Proof of Concept Vulnerable line: https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L124 You can add the following test to Basket.test.js and see that it reverts (..after you remove \"nonReentrant\" from \"mint\", see other issue): it(\"should divide by 0\", async () => {     await basket.connect(addr1).burn(await basket.balanceOf(addr1.address));     await basket.connect(addr2).burn(await basket.balanceOf(addr2.address));      await UNI.connect(addr1).approve(basket.address, ethers.BigNumber.from(1));     await COMP.connect(addr1).approve(basket.address, ethers.BigNumber.from(1));     await AAVE.connect(addr1).approve(basket.address, ethers.BigNumber.from(1));     await basket.connect(addr1).mint(ethers.BigNumber.from(1)); });   ## Tools Used Manual analysis, hardhat.  ## Recommended Mitigation Steps Add a check to handleFees: if totalSupply= 0, you can just return, no need to calculate new ibRatio / fees. You might want to reset ibRatio to BASE at this point.  "}, {"title": "Basket will break and lock all user funds if not used in 100 years", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/63", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  kenzo   # Vulnerability details  The ```handleFees``` function divides by ```(BASE - ((block.timestamp - lastFee)* licenseFee / ONE_YEAR))```. For initial BASE of 1e18 and licenseFee of 1e16, it means that if nobody calls this function in 100 years, the function will divide by 0.  ## Impact After 100 years of no usage, handleFees will always revert and nobody will be able to mint, burn etc'.  ## Proof of Concept Vulnerable line which will divide by 0: https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L118 To test this, you can deploy to testnet a contract, then use a time machine to travel to 100 years in the future and try to use mint(). If for some reason you don't want to use your time machine, you may use this function to simulate the passage of time: ``` async function skipTime(seconds) {   let blockNumber = await hre.network.provider.request({     method: \"eth_blockNumber\",     params: [],   });   let block = await ethers.provider.getBlock(blockNumber[\"result\"]);   await hre.network.provider.request({     method: \"evm_mine\",     params: [block[\"timestamp\"]+seconds],   }); } ```  ## Tools Used Manual analysis, hardhat, time machine.  ## Recommended Mitigation Steps Tell your grandchildren to call mint(1) in 99 years.  "}, {"title": "Missing Transfer Ownership Pattern", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/62", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "sponsor acknowledged"], "target": "2021-09-defiprotocol-findings", "body": "Missing Transfer Ownership Pattern"}, {"title": "Inaccurate log emitted at deleteNewIndex", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/58", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  kenzo   # Vulnerability details  The DeletedNewIndex log emits \"publisher\", but it might be the auction that called the function. Note: the event is defined as: event DeletedNewIndex(address _publisher); So if you wanted to anyway emit just the publisher, this is not a bug. However as this function call be called from both publisher and auction, I have a feeling you wanted to emit the msg.sender.  ## Impact Inaccurate data supplied.  ## Proof of Concept https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L208  ## Tools Used Manual analysis  ## Recommended Mitigation Steps Emit msg.sender instead of publisher.  "}, {"title": "BLOCK_DECREMENT not used", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/57", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-09-defiprotocol-findings", "body": "BLOCK_DECREMENT not used"}, {"title": "Scoop ERC20 tokens from basket contract", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/56", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2021-09-defiprotocol-findings", "body": "Scoop ERC20 tokens from basket contract"}, {"title": "malicious tokens could be added with addBounty", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/55", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-09-defiprotocol-findings", "body": "malicious tokens could be added with addBounty"}, {"title": "handleFees() only mint when necessary", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/53", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact If the functions mintTo and burn of Basket.sol are called twice in the same block then block.timestamp will stay the same and timeDiff ==0. Then it is not necessary to _mint () tokens, as this will be 0 tokens anyway.  So checking for timeDiff ==0 could save a bit of gas.  ## Proof of Concept https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Basket.sol#L110  function handleFees() private {         if (lastFee == 0) {             lastFee = block.timestamp;         } else {             uint256 startSupply = totalSupply();              uint256 timeDiff = (block.timestamp - lastFee);             uint256 feePct = timeDiff * licenseFee / ONE_YEAR;             uint256 fee = startSupply * feePct / (BASE - feePct);              _mint(publisher, fee * (BASE - factory.ownerSplit()) / BASE);             _mint(Ownable(address(factory)).owner(), fee * factory.ownerSplit() / BASE);             lastFee = block.timestamp;             uint256 newIbRatio = ibRatio * startSupply / totalSupply();             ibRatio = newIbRatio;              emit NewIBRatio(ibRatio);         }     } ## Tools Used  ## Recommended Mitigation Steps Add an extra if in the following way:   function handleFees() private {         if (lastFee == 0) {             lastFee = block.timestamp;         } else {             uint256 startSupply = totalSupply();             uint256 timeDiff = (block.timestamp - lastFee);             if (timeDiff !=0) {                                                                      // ===> extra if                 uint256 feePct = timeDiff * licenseFee / ONE_YEAR;                 uint256 fee = startSupply * feePct / (BASE - feePct);                 _mint(publisher, fee * (BASE - factory.ownerSplit()) / BASE);                 _mint(Ownable(address(factory)).owner(), fee * factory.ownerSplit() / BASE);                 lastFee = block.timestamp;                 uint256 newIbRatio = ibRatio * startSupply / totalSupply();                 ibRatio = newIbRatio;                 emit NewIBRatio(ibRatio);            }         }     }     "}, {"title": "handleFees() will revert if licenseFee is too high", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/52", "labels": ["bug", "1 (Low Risk)"], "target": "2021-09-defiprotocol-findings", "body": "handleFees() will revert if licenseFee is too high"}, {"title": "More readable constants", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/51", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-09-defiprotocol-findings", "body": "More readable constants"}, {"title": "initialize of Basket.sol is missing initializer ", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/50", "labels": ["bug", "duplicate", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact When using the Openzeppelin upgradability pattern, the initialize() function should you the modifier initializer. However the initialize() function of Basket.sol doesn't have this modifier.  This won't give problems in practice because __ERC20_init() does have this modifier and prevents initialize() from being called twice. However forks of the projects or future developers might not be aware of this any make risky changes.  ## Proof of Concept https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Basket.sol#L36 import { ERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";  contract Basket is IBasket, ERC20Upgradeable { ..  function initialize(IFactory.Proposal memory proposal, IAuction auction_) public override {        ...          __ERC20_init(proposal.tokenName, proposal.tokenSymbol);     }  ## Tools Used  ## Recommended Mitigation Steps Add the modifier initializer to the function initialize()  "}, {"title": "Auction settler can steal user funds if bond timestamp is high enough", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/45", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  kenzo   # Vulnerability details  After an auction has started, as time passes and according to the bondTimestamp, newRatio (which starts at 2*ibRatio) gets smaller and smaller and therefore less and less tokens need to remain in the basket. This is not capped, and after a while, newRatio can become smaller than current ibRatio.  ## Impact If for some reason nobody has settled an auction and the publisher didn't stop it, a malicious user can wait until newRatio < ibRatio, or even until newRatio ~= 0 (for an initial ibRatio of ~1e18 this happens after less than 3.5 days after auction started), and then bond and settle and steal user funds.  ## Proof of Concept These are the vulnerable lines: https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Auction.sol#L89:#L99 ```         uint256 a = factory.auctionMultiplier() * basket.ibRatio();         uint256 b = (bondTimestamp - auctionStart) * BASE / factory.auctionDecrement();         uint256 newRatio = a - b;          for (uint256 i = 0; i < pendingWeights.length; i++) {             uint256 tokensNeeded = basketAsERC20.totalSupply() * pendingWeights[i] * newRatio / BASE / BASE;             require(IERC20(pendingTokens[i]).balanceOf(address(basket)) >= tokensNeeded);         } ``` The function verifies that ```pendingTokens[i].balanceOf(basket) >= basketAsERC20.totalSupply() * pendingWeights[i] * newRatio / BASE / BASE```. This is the formula that will be used later to mint/burn/withdraw user funds. As bondTimestamp increases, newRatio will get smaller, and there is no check on this. After a while we'll arrive at a point where ```newRatio ~= 0```, so ```tokensNeeded = newRatio*(...) ~= 0```, so the attacker could withdraw nearly all the tokens using outputTokens and outputWeights, and leave just scraps in the basket.  ## Tools Used Manual analysis, hardhat.  ## Recommended Mitigation Steps Your needed condition/math might be different, and you might also choose to burn the bond while you're at it, but I think at the minimum you should add a sanity check in settleAuction: ``` require (newRatio > basket.ibRatio()); ```  "}, {"title": "Redundant call to external contract, result can be saved", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/43", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  kenzo   # Vulnerability details  When using few times an unchanging value from external contract call, the result can be saved and used without recalling the external contract.  ## Impact Some gas can be saved.  ## Proof of Concept In settleAuction, the basket's totalSupply stays constant through the loop's iterations. ``` for (uint256 i = 0; i < pendingWeights.length; i++) {             uint256 tokensNeeded = basketAsERC20.totalSupply() * pendingWeights[i] * newRatio / BASE / BASE;             require(IERC20(pendingTokens[i]).balanceOf(address(basket)) >= tokensNeeded);         } ``` https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Auction.sol#L97  ## Tools Used Manual analysis, hardhat  ## Recommended Mitigation Steps Save basketAsERC20.totalSupply() to a local variable outside the loop, and use that variable inside the loop.  "}, {"title": "No minimum rate in the auction may break the protocol under network failure", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/42", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  jonah1005   # Vulnerability details  ## Impact The aution contract decides a new `ibRatio` in the function `settleAuction`. [Auction.sol#L89-L91](https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Auction.sol#L89-L91)  ```solidity         uint256 a = factory.auctionMultiplier() * basket.ibRatio();         uint256 b = (bondTimestamp - auctionStart) * BASE / factory.auctionDecrement();         uint256 newRatio = a - b; ```  There's a chance that `newRatio` would be really close to zero. This imposes too much risk on the protocol. The network may not really be healthy all the time. Solana and Arbitrum were down and Ethereum was suffered a forking issue recently. Also, the network may be jammed from time to time. This could cause huge damage to a protocol. Please refer to [Black Thursday for makerdao 8.32 million was liquidated for 0 dai](https://medium.com/@whiterabbit_hq/black-thursday-for-makerdao-8-32-million-was-liquidated-for-0-dai-36b83cac56b6)  Given the chance that all user may lose their money, I consider this is a medium-risk issue.   ## Proof of Concept [Black Thursfay for makerdao 8.32 million was liquidated for 0 dai](https://medium.com/@whiterabbit_hq/black-thursday-for-makerdao-8-32-million-was-liquidated-for-0-dai-36b83cac56b6) [bug-impacting-over-50-of-ethereum-clients-leads-to-fork](https://www.theblockcrypto.com/post/115822/bug-impacting-over-50-of-ethereum-clients-leads-to-fork)  ## Tools Used None  ## Recommended Mitigation Steps  I recommend setting a minimum `ibRatio` when a publisher publishes a new index. The auction should be killed if the `ibRatio` is too low.  "}, {"title": " settleAuction may be impossible if locked at a wrong time.", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/41", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  jonah1005   # Vulnerability details  ## Impact The aution contract decides a new `ibRatio` in the function `settleAuction`. [Auction.sol#L89-L91](https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Auction.sol#L89-L91)  ```solidity         uint256 a = factory.auctionMultiplier() * basket.ibRatio();         uint256 b = (bondTimestamp - auctionStart) * BASE / factory.auctionDecrement();         uint256 newRatio = a - b; ```  In this equation, `a` would not always be greater than `b`. The ` auctionBonder` may lock the token in `bondForRebalance()` at a point that `a-b` would always revert.  The contract should not allow users to lock the token at the point that not gonna succeed. Given the possible (huge) loss of the user may suffer, I consider this is a medium-risk issue.   ## Proof of Concept Here's a web3.py script to trigger this bug. ```python basket.functions.publishNewIndex([dai.address], [deposit_amount]).transact()  for i in range(4 * 60 * 24):     w3.provider.make_request('evm_mine', []) basket.functions.publishNewIndex([dai.address], [deposit_amount]).transact()  print('auction on going', auction.functions.auctionOngoing().call()) for i in range(20000):     w3.provider.make_request('evm_mine', [])  all_token = basket.functions.balanceOf(user).call() basket.functions.approve(auction.address, all_token).transact() auction.functions.bondForRebalance().transact() # error Log # {'code': -32603, 'message': 'Error: VM Exception while processing transaction: reverted with panic code 0x11 (Arithmetic operation underflowed or overflowed outside of an unchecked block)'} auction.functions.settleAuction([], [], [], [], []).transact() ```   ## Tools Used None  ## Recommended Mitigation Steps Recommend to calculate the new irate in `bondForRebalance`. I understand the `auctionBonder` should take the risk to get the profit. However, the contract should protect the user in the first place when this auction is doomed to fail.  "}, {"title": "Restore state to 0 if not needed anymore", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/40", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  kenzo   # Vulnerability details  In some places where data is discarded such as ```bondBurn```, part of the data is set to 0 (```auctionBonder```), and other parts are not (```bondTimestamp```). Setting unnecessary data back to 0 will save gas.  ## Impact Almost 2000 gas saved for each variable reset. In some places, like ```createBasket``` (which only needs to save the proposal's \"basket\" field after creating the basket), this can save almost 15000 gas.  ## Proof of Concept Places where data is not reset: Factory's createBasket (set all _proposals[idNumber]'s fields to be 0 except basket) https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Factory.sol#L112 Basket's changePublisher: (set pendingPublisher.block = 0) https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L141 Basket's changeLicenseFee: (set pendingLicenseFee.block = 0) https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L159 Basket's setNewWeights and deleteNewIndex: (set pendingWeights.tokens and pendingWeights.weights to empty arrays) https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L200 https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L212 Auction's killAuction: (set auctionStart = 0) https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Auction.sol#L44 Auction's settleAuction: (set bondTimestamp, auctionBonder = 0) https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Auction.sol#L107 Auction's bondBurn: (set bondTimestamp = 0) https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Auction.sol#L120 Auction's withdrawBounty: (set bounty.token, bounty.token = 0) https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Auction.sol#L148  ## Tools Used Manual analysis, hardhat.  ## Recommended Mitigation Steps Detailed above.  "}, {"title": "Unnecessary initializing of variable to 0", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/39", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-09-defiprotocol-findings", "body": "Unnecessary initializing of variable to 0"}, {"title": "Unsafe approve would halt the auction and burn the bond", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/35", "labels": ["bug", "duplicate", "2 (Med Risk)"], "target": "2021-09-defiprotocol-findings", "body": "Unsafe approve would halt the auction and burn the bond"}, {"title": "Reentrancy in settleAuction(): malicious publisher can bypass index timelock mechanism, inject malicious index, and rug the basket", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/31", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  kenzo   # Vulnerability details  The settleAuction() function calls withdrawBounty() before setting auctionOngoing = false, thereby allowing reentrancy.  ## Impact A malicious publisher can bypass the index timelock mechanism and publish new index which the basket's users won't have time to respond to. At worst case, this means setting weights that allow the publisher to withdraw all the basket's underlying funds for himself, under the guise of a valid new index.  ## Proof of Concept 1. The publisher (a contract) will propose new valid index and bond the auction. To settle the auction, the publisher will execute the following steps in the same transaction: 2. Add a bounty of an ERC20 contract with a malicious transfer() function. 3. Settle the valid new weights correctly (using settleAuction() with the correct parameters, and passing the malicious bounty id). 4. settleAuction() will call withdrawBounty() which upon transfer will call the publisher's malicious ERC20 contract. 5. The contract will call settleAuction() again, with empty parameters. Since the previous call's effects have already set all the requirements to be met, settleAuction() will finish correctly and call setNewWeights() which will set the new valid weights and set pendingWeights.pending = false. 6. Still inside the malicious ERC20 contract transfer function, the attacker will now call the basket's publishNewIndex(), with weights that will transfer all the funds to him upon his burning of shares. This call will succeed to set new pending weights as the previous step set pendingWeights.pending = false. 7. Now the malicious withdrawBounty() has ended, and the original settleAuction() is resuming, but now with malicious weights in pendingWeights (set in step 6). settleAuction() will now call setNewWeights() which will set the basket's weights to be the malicious pending weights. 8. Now settleAuction has finished, and the publisher (within the same transaction) will burn() all his shares of the basket, thereby transferring all the tokens to himself.  POC exploit: Password to both files: \"exploit\". AttackPublisher.sol , to be put under contracts/contracts/Exploit: https://pastebin.com/efHZjstS ExploitPublisher.test.js , to be put under contracts/test: https://pastebin.com/knBtcWkk  ## Tools Used Manual analysis, hardhat.  ## Recommended Mitigation Steps In settleAuction(), move basketAsERC20.transfer() and withdrawBounty() to the end of the function, conforming with Checks Effects Interactions pattern.  "}, {"title": "Cannot change pending while timelocked", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/30", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  joeysantoro   # Vulnerability details  ## Impact If any of the timelocked variables of a basket are pending a change, a transaction to change the target will revert during the timelock window.  ## Proof of Concept Publisher wants to change license fee. They submit a change request but fat finger with the wrong value. The only way to change the pending licenseFee is to complete the change to the incorrect value (after timelock period) then resubmit a new request.  In the case of changing index this can be mitigated by using deleteNewIndex(), however changePublisher and changeLicenseFee cannot be mitigated.  ## Recommended Mitigation Steps Introduce a \"setPendingX\" method for each of  liscenceFee, publisher, and index. This cleanly separates the logic and allows for overwrite of pending during timelock window.  "}, {"title": "DAO is fee recipient / cannot revoke owner", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/27", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-09-defiprotocol-findings", "body": "DAO is fee recipient / cannot revoke owner"}, {"title": "Global bounties variable and 0 bounty allow dos in bounty functionality of basket", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/25", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  csanuragjain   # Vulnerability details  ## Impact It was observed that _bounties variable is global per basket. Also you are allowed to add 0 amount in bounty. This means if user adds uint256 max times bounty with amount 0, no one can add further bounty on this basket  ## Proof of Concept 1. User calls addBounty function with amount 0 uint256 max times  ```     function addBounty(IERC20 token, uint256 amount) public override returns (uint256) {         // add bounty to basket         token.safeTransferFrom(msg.sender, address(this), amount);         _bounties.push(Bounty({             token: address(token),             amount: amount,             active: true         }));          uint256 id = _bounties.length - 1;         emit BountyAdded(token, amount, id);         return id;     } ```  2. Now noone can call bounty on this basket anymore  ## Recommended Mitigation Steps _bounties should be cleared once auction has been settled  "}, {"title": "Zero weighted baskets are allowed to steal funds", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/21", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  csanuragjain   # Vulnerability details  ## Impact It was observed that Publisher is allowed to create a basket with zero token and weight. This can lead to user fund stealing as described in below poc The issue was discovered in validateWeights function of Basket contract   ## Proof of Concept 1. User proposes a new Basket with 0 tokens and weights using proposeBasketLicense function in Factory contract  ```  Proposal memory proposal = Proposal({             licenseFee: 10,             tokenName: abc,             tokenSymbol: aa,             proposer: 0xabc,             tokens: {},             weights: {},             basket: address(0)         }); ```  2. validateWeights function is called and it returns success as the only check performed is _tokens.length == _weights.length (0=0)  ```     function validateWeights(address[] memory _tokens, uint256[] memory _weights) public override pure {         require(_tokens.length == _weights.length);         uint256 length = _tokens.length;         address[] memory tokenList = new address[](length);          // check uniqueness of tokens and not token(0)          for (uint i = 0; i < length; i++) {            ...         }     } ```  3. A new proposal gets created  ``` _proposals.push(proposal); ```  4. User creates new Basket with this proposal using createBasket function  ``` function createBasket(uint256 idNumber) external override returns (IBasket) {         Proposal memory bProposal = _proposals[idNumber];         require(bProposal.basket == address(0));          ....          for (uint256 i = 0; i < bProposal.weights.length; i++) {             ...         }   ...         return newBasket;     } ```  5. Since no weights and tokens were in this proposal so no token transfer is required (bProposal.weights.length will be 0 so loop won't run)  6. Basket gets created and user becomes publisher for this basket  ```         newBasket.mintTo(BASE, msg.sender);         _proposals[idNumber].basket = address(newBasket); ```  7. Publisher owned address calls the mint function with say amount 10 on Basket.sol contract  ```     function mint(uint256 amount) public override {         mintTo(amount, msg.sender);     }      function mintTo(uint256 amount, address to) public override {         ...          pullUnderlying(amount, msg.sender);          _mint(to, amount);          ...     } ```  8. Since there is no weights so pullUnderlying function does nothing (weights.length is 0)  ```     function pullUnderlying(uint256 amount, address from) private {         for (uint256 i = 0; i < weights.length; i++) {             uint256 tokenAmount = amount * weights[i] * ibRatio / BASE / BASE;             IERC20(tokens[i]).safeTransferFrom(from, address(this), tokenAmount);         }     } ```  9. Full amount 10 is minted to Publisher owned address setting balanceOf(msg.sender) = 10  ``` _mint(to, amount); ```  10. Now Publisher calls the publishNewIndex to set new weights. Since pendingWeights.pending is false, else condition gets executed  ```     function publishNewIndex(address[] memory _tokens, uint256[] memory _weights) onlyPublisher public override {         validateWeights(_tokens, _weights);          if (pendingWeights.pending) {             require(block.number >= pendingWeights.block + TIMELOCK_DURATION);             if (auction.auctionOngoing() == false) {                 auction.startAuction();                  emit PublishedNewIndex(publisher);             } else if (auction.hasBonded()) {              } else {                 auction.killAuction();                  pendingWeights.tokens = _tokens;                 pendingWeights.weights = _weights;                 pendingWeights.block = block.number;             }         } else {             pendingWeights.pending = true;             pendingWeights.tokens = _tokens;             pendingWeights.weights = _weights;             pendingWeights.block = block.number;         }     } ```   11. Publisher calls the publishNewIndex again which starts the Auction. This auction is later settled using the settleAuction function in Auction contract  12. Publisher owned address can now call burn and get the amount 10 even though he never made the payment since his balanceOf(msg.sender) = 10 (Step 9)  ```     function burn(uint256 amount) public override {         require(auction.auctionOngoing() == false);         require(amount > 0);         require(balanceOf(msg.sender) >= amount);          handleFees();          pushUnderlying(amount, msg.sender);         _burn(msg.sender, amount);                  emit Burned(msg.sender, amount);     } ```  ## Recommended Mitigation Steps Change validateWeights to check for 0 length token  ```     function validateWeights(address[] memory _tokens, uint256[] memory _weights) public override pure {         require(_tokens.length>0);   ...     } ```  "}, {"title": "Require statement can be moved to start of function", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/19", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  bw   # Vulnerability details  ## Impact  A [require](https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Factory.sol#L74) statement in `Factory.sol` could be performed prior to an expensive cross contract call, reducing the amount of gas wasted if the validation fails.  ## Proof of Concept  https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Factory.sol#L74  ## Tools Used  N/A  ## Recommended Mitigation Steps  Move the require statement before `basketImpl.validateWeights(tokens, weights);`  "}, {"title": "Uninitialized Implementation Contracts", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/18", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  bw   # Vulnerability details  ## Impact  The implementation contracts that are used by proxies are not initialized by default, this creates the possibility that the contracts will not be initialized after deployment.  Uninitialized implementations could result in Denial of Service exploits. This often involves initializing the contract so that it is possible to `delegatecall` into a contract that has the `selfdestruct` opcode.   The contracts in-scope did not contain any `delegatecalls` that could be exploited. However, it is still regarded as best practice to ensure that the contracts cannot be initialized after deployment.  ## Proof of Concept  As a defence in-depth measure, the implementations should be initialized during deployed by adding the following: ```diff diff --git a/contracts/contracts/Auction.sol b/contracts/contracts/Auction.sol index f07df8b..f7c21eb 100644 --- a/contracts/contracts/Auction.sol +++ b/contracts/contracts/Auction.sol @@ -44,6 +44,10 @@ contract Auction is IAuction {          auctionOngoing = false;      }   +    constructor() { +        initialized = true; +    } +      function initialize(address basket_, address factory_) public override {          require(!initialized);          basket = IBasket(basket_); diff --git a/contracts/contracts/Basket.sol b/contracts/contracts/Basket.sol index 5fef21b..4549365 100644 --- a/contracts/contracts/Basket.sol +++ b/contracts/contracts/Basket.sol @@ -33,6 +33,10 @@ contract Basket is IBasket, ERC20Upgradeable {        uint256 public override lastFee;   +    constructor() { +        __ERC20_init(\"\",  \"\"); +    } +      function initialize(IFactory.Proposal memory proposal, IAuction auction_) public override {          publisher = proposal.proposer;          licenseFee = proposal.licenseFee; ```  * https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Auction.sol#L9 * https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Basket.sol#L12  ## Tools Used  N/A  ## Recommended Mitigation Steps  Initialize implementations during deployment by adding a constructor.     "}, {"title": "Events not emitted for parameter changes ", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/17", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor acknowledged"], "target": "2021-09-defiprotocol-findings", "body": "Events not emitted for parameter changes "}, {"title": "Runtime constants not defined as immutable", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/15", "labels": ["bug", "duplicate", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  bw   # Vulnerability details  ## Impact The [`Factory.sol`](https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Factory.sol#L19) contract made use of a number of `public` variables that were set only in the constructor and would remain constant. These variables were consuming storage slots, which unnecessarily increased the deployment and runtime gas costs of the contract.  For more information regarding the `immutable` keyword: https://blog.soliditylang.org/2020/05/13/immutable-keyword/  ## Proof of Concept  ### Code Diff  ```diff diff --git a/contracts/contracts/Factory.sol b/contracts/contracts/Factory.sol index 271945d..3bbdd4f 100644 --- a/contracts/contracts/Factory.sol +++ b/contracts/contracts/Factory.sol @@ -23,8 +23,8 @@ contract Factory is IFactory, Ownable {        Proposal[] private _proposals;   -    IAuction public override auctionImpl; -    IBasket public override basketImpl; +    IAuction public immutable override auctionImpl; +    IBasket public immutable override basketImpl;        uint256 public override minLicenseFee = 1e15; // 1e15 0.1%      uint256 public override auctionDecrement = 10000; ```  ### Gas Improvement  ```diff diff --git a/base.gas b/factory-immutable.gas index 9d48ade..1447433 100644 --- a/base.gas +++ b/factory-immutable.gas @@ -23,9 +23,9 @@  \u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7  |  ERC20Upgradeable  \u00b7  approve               \u00b7          -  \u00b7          -  \u00b7    48900  \u00b7            3  \u00b7          -  \u2502  \u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 -|  Factory           \u00b7  createBasket          \u00b7     880031  \u00b7     908831  \u00b7   882911  \u00b7           10  \u00b7          -  \u2502 +|  Factory           \u00b7  createBasket          \u00b7     875780  \u00b7     904580  \u00b7   878660  \u00b7           10  \u00b7          -  \u2502  \u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 -|  Factory           \u00b7  proposeBasketLicense  \u00b7     335488  \u00b7     335512  \u00b7   335505  \u00b7           12  \u00b7          -  \u2502 +|  Factory           \u00b7  proposeBasketLicense  \u00b7     333388  \u00b7     333412  \u00b7   333405  \u00b7           12  \u00b7          -  \u2502  \u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7  |  Factory           \u00b7  setOwnerSplit         \u00b7          -  \u00b7          -  \u00b7    46173  \u00b7            1  \u00b7          -  \u2502  \u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 @@ -39,7 +39,7 @@  \u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7  |  Basket                                     \u00b7          -  \u00b7          -  \u00b7  2390793  \u00b7          8 %  \u00b7          -  \u2502  \u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 -|  Factory                                    \u00b7          -  \u00b7          -  \u00b7  1706801  \u00b7        5.7 %  \u00b7          -  \u2502 +|  Factory                                    \u00b7          -  \u00b7          -  \u00b7  1684215  \u00b7        5.6 %  \u00b7          -  \u2502  \u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7|\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7  |  TestToken                                  \u00b7     653145  \u00b7     653193  \u00b7   653163  \u00b7        2.2 %  \u00b7          -  \u2502  \u00b7---------------------------------------------|-------------|-------------|-----------|---------------|-------------\u00b7  ```  By removing the `public` keyword from all variables that are not required (which are only used in the unit tests), the deployment costs can be further reduced.  ## Tools Used  https://www.npmjs.com/package/hardhat-gas-reporter  ## Recommended Mitigation Steps  Add the immutable key word to all variables that are only set during the constructor.   "}, {"title": "Some variables type should be changed ", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/7", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-09-defiprotocol-findings", "body": "Some variables type should be changed "}, {"title": "Lack of input validation in initialize function of Basket.sol ", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/5", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor acknowledged"], "target": "2021-09-defiprotocol-findings", "body": "Lack of input validation in initialize function of Basket.sol "}, {"title": "Gas Saving by changing the visibility of initialize function from public to externa in basket.sol", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/4", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-defiprotocol-findings", "body": "# Handle  jah   # Vulnerability details  ## Impact the initialize function will not be called from the contract and  it  doesn't require public visibility so the visibility should be changed to external to save gas as  described in https://mudit.blog/solidity-gas-optimization-tips/: \u201cFor all the public functions, the input parameters are copied to memory automatically, and it costs gas. If your function is only called externally, then you should explicitly mark it as external. External function\u2019s parameters are not copied into memory but are read from calldata directly. This small optimization in your solidity code can save you a lot of gas when the function input parameters are huge.\u201d     ## Proof of Concept https://github.com/code-423n4/2021-09-defiProtocol/blob/52b74824c42acbcd64248f68c40128fe3a82caf6/contracts/contracts/Basket.sol#L36  ## Tools Used manual analysis  ## Recommended Mitigation Steps change the visibility to external  "}, {"title": "initialize function in basket.sol can be front-run", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/3", "labels": ["bug", "1 (Low Risk)"], "target": "2021-09-defiprotocol-findings", "body": "initialize function in basket.sol can be front-run"}, {"title": "Lack of input validation in  initialize function of  Auction.sol", "html_url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/1", "labels": ["bug", "0 (Non-critical)", "disagree with severity", "sponsor acknowledged"], "target": "2021-09-defiprotocol-findings", "body": "Lack of input validation in  initialize function of  Auction.sol"}, {"title": "Sanity check on the lower and upper ticks", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/93", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-09-sushitrident-2-findings", "body": "# Handle  broccoli   # Vulnerability details  ## Impact  In the `burn` and `swap` functions of `ConcentratedLiquidityPool`, the lower tick is not explicitly checked to be less than the upper tick. Besides, the ticks are not checked to be at least the minimum tick and at most the maximum tick.  ## Proof of Concept  Referenced code: [Ticks.sol#L68-L70](https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/libraries/concentratedPool/Ticks.sol#L68-L70)  ## Recommended Mitigation Steps  Add sanity checks on the lower and upper ticks in critical functions (see the referenced line of code, for example).  "}, {"title": "Incorrect comparison in the `_updatePosition` of `ConcentratedLiquidityPool`", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/91", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-09-sushitrident-2-findings", "body": "Incorrect comparison in the `_updatePosition` of `ConcentratedLiquidityPool`"}, {"title": "Timestamp underflow error in `swap` function of `ConcentratedLiquidityPool`", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/90", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-09-sushitrident-2-findings", "body": "Timestamp underflow error in `swap` function of `ConcentratedLiquidityPool`"}, {"title": "Users cannot receive rewards from `ConcentratedLiquidityPoolManager` if their liquidity is too large", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/88", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2021-09-sushitrident-2-findings", "body": "Users cannot receive rewards from `ConcentratedLiquidityPoolManager` if their liquidity is too large"}, {"title": "Wrong usage of `positionId` in `ConcentratedLiquidityPoolManager`", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/86", "labels": ["bug", "duplicate", "3 (High Risk)", "sponsor disputed"], "target": "2021-09-sushitrident-2-findings", "body": "Wrong usage of `positionId` in `ConcentratedLiquidityPoolManager`"}, {"title": "Overflow in the `mint` function of `ConcentratedLiquidityPool` causes LPs' funds to be stolen", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/84", "labels": ["bug", "3 (High Risk)", "sponsor disputed"], "target": "2021-09-sushitrident-2-findings", "body": "Overflow in the `mint` function of `ConcentratedLiquidityPool` causes LPs' funds to be stolen"}, {"title": "Incorrect usage of typecasting in `_getAmountsForLiquidity` lets an attacker steal funds from the pool", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/83", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-09-sushitrident-2-findings", "body": "# Handle  broccoli   # Vulnerability details  ## Impact  The `_getAmountsForLiquidity` function of `ConcentratedLiquidityPool` explicitly converts the result of `DyDxMath.getDy` and `DyDxMath.getDx` from type `uint256` to type `uint128`. The explicit casting without checking whether the integer exceeds the maximum number (i.e., `type(uint128).max`) could cause incorrect results being used. Specifically, an attacker could exploit this bug to mint a large amount of liquidity but only pay a little of `token0` or `token1` to the pool and effectively steal other's funds when burning his liquidity.  ## Proof of Concept  1. Suppose that the current price is at the tick `500000`, an attacker calls the `mint` function with the following parameters:  ``` mintParams.lower = 100000 mintParams.upper = 500000 mintParams.amount1Desired = (1 << 128) + 71914955423 # a carefully chosen number mintParams.amount0Desired = 0 ```  2. Since the current price is equal to the upper price, we have  ``` _liquidity = mintParams.amount1Desired * (1 << 96) // (priceUpper - priceLower)            = 4731732988155153573010127840 ```  3. The amounts of `token0` and `token1` that the attacker has to pay is  ``` amount0Actual = 0 amount1Actual = uint128(DyDxMath.getDy(_liquidity, priceLower, priceUpper, true))               = uint128(_liquidity * (priceUpper - priceLower) // (1 << 96)) # round up               = uint128(340282366920938463463374607456141861046)             # exceed the max               = 24373649590                                                  # truncated ```  4. The attacker only pays `24373649590` of `token1` to get `4731732988155153573010127840` of the liquidity, which he could burn to get more `token1`. As a result, the attacker is stealing the funds from the pool and could potentially drain it.  Referenced code: [ConcentratedLiquidityPool.sol#L480](https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/pool/concentrated/ConcentratedLiquidityPool.sol#L480) [concentratedPool/DyDxMath.sol#L15](https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/libraries/concentratedPool/DyDxMath.sol#L15) [concentratedPool/DyDxMath.sol#L30](https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/libraries/concentratedPool/DyDxMath.sol#L30)  ## Recommended Mitigation Steps  Check whether the result of `DyDxMath.getDy` or `DyDxMath.getDx` exceeds `type(uint128).max` or not. If so, then revert the transaction. Or consider using the [`SafeCast` library](https://docs.openzeppelin.com/contracts/3.x/api/utils#SafeCast) from OpenZeppelin instead.  "}, {"title": "`incentiveId <= incentiveCount[pool]` is bad and can be removed", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/79", "labels": ["bug", "duplicate", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-09-sushitrident-2-findings", "body": "# Handle  0xsanson   # Vulnerability details  ## Impact When an user subscribes to an incentive using ConcentratedLiquidityPoolManager's `subscribe`, the function checks that `incentiveId` is appropriate: ```js require(incentiveId <= incentiveCount[pool], \"NOT_INCENTIVE\"); ``` This check is actually incorrect, and it should use a `<` instead of `<=`.  If this was the only requirement, it would be possible to subscribe to the next incentive, causing some problems. Fortunately the next line saves the day: `require(block.timestamp > incentive.startTime && block.timestamp < incentive.endTime, \"TIMED_OUT\");` this fails for uninitiated incentives.  ## Proof of Concept https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/pool/concentrated/ConcentratedLiquidityPoolManager.sol#L72  ## Tools Used editor  ## Recommended Mitigation Steps Consider removing this requirement to save gas. The check for existing pool is already considered when looking at `block.timestamp < incentive.endTime`.  "}, {"title": "`subscribe` can be called by anyone", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/77", "labels": ["bug", "1 (Low Risk)", "sponsor disputed"], "target": "2021-09-sushitrident-2-findings", "body": "`subscribe` can be called by anyone"}, {"title": "`addIncentive` may need more inputs checked", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/76", "labels": ["bug", "duplicate", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-09-sushitrident-2-findings", "body": "`addIncentive` may need more inputs checked"}, {"title": "`addIncentive` and `reclaimIncentive` can be external", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/75", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-sushitrident-2-findings", "body": "# Handle  0xsanson   # Vulnerability details  ## Impact Function `addIncentive` and `reclaimIncentive` in ConcentratedLiquidityPoolManager can be `external` instead of `public` to save gas.  ## Proof of Concept https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/pool/concentrated/ConcentratedLiquidityPoolManager.sol#L36 https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/pool/concentrated/ConcentratedLiquidityPoolManager.sol#L49  ## Tools Used editor  "}, {"title": "Style issues", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/74", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-09-sushitrident-2-findings", "body": "Style issues"}, {"title": "Useless state variable wETH", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/73", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-sushitrident-2-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact contract ConcentratedLiquidityPosition has a state variable 'wETH' but it is not being used in any meaningful way. So you can remove it to save some gas.  ## Recommended Mitigation Steps Remove useless state variables.  "}, {"title": "Unused import", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/72", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-sushitrident-2-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact There is an unused import: import \"../../interfaces/ITridentRouter.sol\"; in ConcentratedLiquidityPosition. It will increase the size of deployment with no real benefit.  ## Recommended Mitigation Steps Consider removing this unused import to save some gas.   "}, {"title": "Boundaries for timestamp values", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/68", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-09-sushitrident-2-findings", "body": "Boundaries for timestamp values"}, {"title": "Handle of deflationary tokens", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/65", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-09-sushitrident-2-findings", "body": "Handle of deflationary tokens"}, {"title": "uint32 for timestamps", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/63", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-09-sushitrident-2-findings", "body": "uint32 for timestamps"}, {"title": "Inclusive conditions", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/62", "labels": ["bug", "1 (Low Risk)", "sponsor disputed"], "target": "2021-09-sushitrident-2-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact Conditions should be inclusive >= or <= : ```solidity   require(       baseTokenQty > _baseTokenQtyMin,       \"MathLib: INSUFFICIENT_BASE_TOKEN_QTY\"   );   require(       quoteTokenQty > _quoteTokenQtyMin,       \"MathLib: INSUFFICIENT_QUOTE_TOKEN_QTY\"   );   require(       _baseTokenQtyMin < maxBaseTokenQty,       \"MathLib: INSUFFICIENT_DECAY\"   );   require(       _quoteTokenQtyMin < maxQuoteTokenQty,       \"MathLib: INSUFFICIENT_DECAY\"   ); ```  Otherwise, these functions will fail when e.g. baseTokenQty = _baseTokenQtyMin when the end-user expects it to pass through.  "}, {"title": "_burn should decrement totalSupply", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/60", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-09-sushitrident-2-findings", "body": "_burn should decrement totalSupply"}, {"title": "Replace hex numbers with .selector", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/58", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-09-sushitrident-2-findings", "body": "Replace hex numbers with .selector"}, {"title": "Struct could be optimized for saving gas", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/57", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-sushitrident-2-findings", "body": "# Handle  WatchPug   # Vulnerability details  Members of structs should be grouped into bunches of 32 bytes for saving gas.  For example:  https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/pool/concentrated/ConcentratedLiquidityPoolManager.sol#L15-L23  `ConcentratedLiquidityPoolManager.sol#Incentive` `rewardsUnclaimed` and `secondsClaimed` can be moved to the bottom to optimize for Variable Packing.  "}, {"title": "Cache storage variables in the stack can save gas", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/56", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-09-sushitrident-2-findings", "body": "# Handle  WatchPug   # Vulnerability details  For the storage variables that will be accessed multiple times, cache them in the stack can save ~100 gas from each extra read (`SLOAD` after Berlin).  For example:  - `vaultFactory` in `NFTXVaultUpgradeable#_chargeAndDistributeFees()`      https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXVaultUpgradeable.sol#L470-L484      ```solidity=470     function _chargeAndDistributeFees(address user, uint256 amount) internal virtual {         // Do not charge fees if the zap contract is calling         // Added in v1.0.3. Changed to mapping in v1.0.5.         if (vaultFactory.excludedFromFees(msg.sender)) {             return;         }                  // Mint fees directly to the distributor and distribute.         if (amount > 0) {             address feeDistributor = vaultFactory.feeDistributor();             // Changed to a _transfer() in v1.0.3.             _transfer(user, feeDistributor, amount);             INFTXFeeDistributor(feeDistributor).distribute(vaultId);         }     }     ```  "}, {"title": "Adding unchecked directive can save gas", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/55", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-09-sushitrident-2-findings", "body": "Adding unchecked directive can save gas"}, {"title": "`ConcentratedLiquidityPoolManager.sol#reclaimIncentive` Misleading error message", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/54", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-09-sushitrident-2-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/pool/concentrated/ConcentratedLiquidityPoolManager.sol#L58  ```solidity function reclaimIncentive(     IConcentratedLiquidityPool pool,     uint256 incentiveId,     uint256 amount,     address receiver,     bool unwrapBento ) public {     Incentive storage incentive = incentives[pool][incentiveId];     require(incentive.owner == msg.sender, \"NOT_OWNER\");     require(incentive.expiry < block.timestamp, \"EXPIRED\");     require(incentive.rewardsUnclaimed >= amount, \"ALREADY_CLAIMED\");     _transfer(incentive.token, address(this), receiver, amount, unwrapBento);     emit ReclaimIncentive(pool, incentiveId); } ```  When the current time is before the `incentive.expiry` time, the error message should be `NOT_EXPIRED` instead of `EXPIRED`.  "}, {"title": "`ConcentratedLiquidityPosition.sol#collect()` Users may get double the amount of yield when they call `collect()` before `burn()`", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/53", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-09-sushitrident-2-findings", "body": "# Handle  WatchPug   # Vulnerability details  When a user calls `ConcentratedLiquidityPosition.sol#collect()` to collect their yield, it calcuates the yield based on `position.pool.rangeFeeGrowth()` and `position.feeGrowthInside0, position.feeGrowthInside1`:  https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/pool/concentrated/ConcentratedLiquidityPosition.sol#L75-L101  When there are enough tokens in `bento.balanceOf`, it will not call `position.pool.collect()` to collect fees from the pool.  This makes the user who `collect()` their yield when there is enough balance to get double yield when they call `burn()` to remove liquidity. Because `burn()` will automatically collect fees on the pool contract.  ## Impact  The yield belongs to other users will be diluted.  ## Recommended Mitigation Steps  Consider making `ConcentratedLiquidityPosition.sol#burn()` call `position.pool.collect()` before `position.pool.burn()`. User will need to call `ConcentratedLiquidityPosition.sol#collect()` to collect unclaimed fees after `burn()`.  Or `ConcentratedLiquidityPosition.sol#collect()` can be changed into a `public` method and `ConcentratedLiquidityPosition.sol#burn()` can call it after `position.pool.burn()`.  "}, {"title": "`ConcentratedLiquidityPosition.sol#burn()` Wrong implementation allows attackers to steal yield", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/52", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-09-sushitrident-2-findings", "body": "# Handle  WatchPug   # Vulnerability details  When a user calls `ConcentratedLiquidityPosition.sol#burn()` to burn their liquidity, it calls `ConcentratedLiquidityPool.sol#burn()` -> `_updatePosition()`:  https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/pool/concentrated/ConcentratedLiquidityPool.sol#L525-L553  The `_updatePosition()` function will return `amount0fees` and `amount1fees` of the whole position with the `lower` and `upper` tick and send them to the `recipient` alongside the burned liquidity amounts.  ## Proof of Concept  1. Alice minted $10000 worth of liquidity with `lower` and `upper` tick set to 99 and 199; 2. Alice accumulated $1000 worth of fee in token0 and token1; 3. The attacker can mint a small amount ($1 worth) of liquidity using the same `lower` and `upper` tick; 4. The attacker calls `ConcentratedLiquidityPosition.sol#burn()` to steal all the unclaimed yield with the ticks of (99, 199) include the $1000 worth of yield from Alice.  ## Recommended Mitigation Steps  Consider making `ConcentratedLiquidityPosition.sol#burn()` always use `address(this)` as `recipient` in:  ```solidity position.pool.burn(abi.encode(position.lower, position.upper, amount, recipient, unwrapBento)); ```  and transfer proper amounts to the user.  "}, {"title": "Burning does not update reserves", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/51", "labels": ["bug", "duplicate", "3 (High Risk)", "sponsor confirmed"], "target": "2021-09-sushitrident-2-findings", "body": "# Handle  cmichel   # Vulnerability details  The `ConcentratedLiquidityPool.burn` function sends out `amount0`/`amount1` tokens but only updates the reserves by decreasing it by the **fees of these amounts**.  ```solidity unchecked {     // @audit decreases by fees only, not by amount0/amount1     reserve0 -= uint128(amount0fees);     reserve1 -= uint128(amount1fees); } ```  This leads to the pool having wrong reserves after any `burn` action. The pool's balance will be much lower than the reserve variables.  ## Impact As the pool's actual balance will be much lower than the reserve variables, `mint`ing and `swap`ing will not work correctly either. This is because of the `amount0Actual + reserve0 <= _balance(token0)` check in `mint` using a much higher `reserve0` amount than the actual balance (already including the transferred assets from the user). An LP provider will have to make up for the missing reserve decrease from `burn` and pay more tokens.  The same holds true for `swap` which performs the same check in `_updateReserves`.  The pool essentially becomes unusable after a `burn` as LPs / traders need to pay more tokens.  ## Recommended Mitigation Steps The reserve should be decreased by what is transferred out. In `burn`'s case this is `amount0` / `amount1`.   "}, {"title": "Unsafe cast in ConcentratedLiquidityPool burn leads to attack", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/50", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-09-sushitrident-2-findings", "body": "# Handle  cmichel   # Vulnerability details  The `ConcentratedLiquidityPool.burn` function performs an unsafe cast of a `uint128` type to a _signed_ integer.  ```solidity (uint256 amount0fees, uint256 amount1fees) = _updatePosition(msg.sender, lower, upper, -int128(amount)); ```  Note that `amount` is chosen by the caller and when choosing `amount = 2**128 - 1`, this is interpreted as `0xFFFFFFFFF... = -1` as a signed integer. Thus `-(-1)=1` adds 1 liquidity unit to the position  This allows an attacker to not only mint LP tokens for free but as this is the `burn` function it also redeems token0/1 amounts according to the unmodified `uint128` `amount` which is an extremely large value.  ## POC I created this POC that implements a hardhat test and shows how to steal the pool tokens.  Choosing the correct `amount` of liquidity to burn and `lower, upper` ticks is not straight-forward because of two competing constraints: 1. the `-int128(amount)` must be less than `MAX_TICK_LIQUIDITY` (see `_updatePosition`). This drives the the `amount` up to its max value (as the max `uint128` value is -1 => -(-1)=1 is very low) 2. The redeemed `amount0, amount1` values must be less than the current pool balance as the transfers would otherwise fail. This drives the `amount` down. However, by choosing a smart `lower` and `upper` tick range we can redeem fewer tokens for the same liquidity.  This example shows how to steal 99% of the `token0` pool reserves: https://gist.github.com/MrToph/1731dd6947073343cf6f942985d556a6  ## Impact An attacker can steal the pool tokens.  ## Recommended Mitigation Steps Even though Solidity 0.8.x is used, type casts do not throw an error. A [`SafeCast` library](https://docs.openzeppelin.com/contracts/4.x/api/utils#SafeCast) must be used everywhere a typecast is done.   "}, {"title": "Gas: `ConcentratedLiquidityPoolManager.addIncentive` ", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/49", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-sushitrident-2-findings", "body": "# Handle  cmichel   # Vulnerability details  The `ConcentratedLiquidityPoolManager.addIncentive` performs an unnecessary check:  ```solidity require(current <= incentive.endTime, \"ALREADY_ENDED\"); ```  As it already checks that `current <= incentive.startTime` and `incentive.startTime < incentive.endTime`, this check is unnecessary and will always be true by transitivity.  ## Recommended Mitigation Steps Remove the check to save on gas.  "}, {"title": "`TridentNFT` signature malleability", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/48", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-09-sushitrident-2-findings", "body": "`TridentNFT` signature malleability"}, {"title": "`TridentNFT.safeTransferFrom` now EIP-721 compliant", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/47", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-09-sushitrident-2-findings", "body": "`TridentNFT.safeTransferFrom` now EIP-721 compliant"}, {"title": "`TridentNFT._mint` can mint to zero address", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/46", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-09-sushitrident-2-findings", "body": "`TridentNFT._mint` can mint to zero address"}, {"title": "`TridentNFT.permitAll` prviliges discrepancy for operator", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/45", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-09-sushitrident-2-findings", "body": "# Handle  cmichel   # Vulnerability details  The `TridentNFT.permitAll` function allows the operator (`isApprovedForAll[owner][recoveredAddress]`) to change the operator (and lock themself out). The same functionality without permits does not work as `setApprovalForAll` requires the `owner` authority.  ## Impact `permitAll` should have the same auth checks as `setApprovalForAll` and not allow the `operator` to change the operator.  ## Recommended Mitigation Steps Remove the `|| isApprovedForAll[owner][recoveredAddress]` from the `require` statement.   "}, {"title": "`TridentNFT.permit` should always check `recoveredAddress != 0`", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/44", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-09-sushitrident-2-findings", "body": "# Handle  cmichel   # Vulnerability details  The `TridentNFT.permit` function ignores the `recoveredAddress != 0` check if `isApprovedForAll[owner][recoveredAddress]` is true.  ## Impact If a user accidentally set the zero address as the operator, tokens can be stolen by anyone as a wrong signature yield `recoveredAddress == 0`.  ## Recommended Mitigation Steps Change the `require` logic to `recoveredAddress != address(0) && (recoveredAddress == owner) || isApprovedForAll[owner][recoveredAddress])`.   "}, {"title": "`TridentNFT` ignores `from`", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/43", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-09-sushitrident-2-findings", "body": "`TridentNFT` ignores `from`"}, {"title": "Incentive should check that it hasn't started yet", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/42", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-09-sushitrident-2-findings", "body": "# Handle  cmichel   # Vulnerability details  The `ConcentratedLiquidityPoolManager.addIncentive` function can add an incentive that already has a non-zero `incentive.secondsClaimed`.  ## Impact Rewards will be wrong.  ## Recommended Mitigation Steps Add a check: `require(incentive.secondsClaimed == 0, \"!secondsClaimed\")`.   "}, {"title": "Cannot claim reward", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/41", "labels": ["bug", "duplicate", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-09-sushitrident-2-findings", "body": "# Handle  cmichel   # Vulnerability details  The `ConcentratedLiquidityPoolManager.claimReward` requires `stake.initialized` but it is never set. It also performs a strange computation as `128 - incentive.secondsClaimed` which will almost always underflow and revert the transaction.  ## Impact One cannot claim rewards.  ## Recommended Mitigation Steps Rethink how claiming rewards should work.   "}, {"title": "Wrong inequality when trying to subscribe to an incentive", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/40", "labels": ["bug", "1 (Low Risk)", "sponsor disputed"], "target": "2021-09-sushitrident-2-findings", "body": "Wrong inequality when trying to subscribe to an incentive"}, {"title": "`ConcentratedLiquidityPoolManager`'s incentives can be stolen", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/37", "labels": ["bug", "duplicate", "3 (High Risk)", "sponsor confirmed"], "target": "2021-09-sushitrident-2-findings", "body": "# Handle  cmichel   # Vulnerability details  The `ConcentratedLiquidityPoolManager` keeps all tokens for all incentives in the same contract. The `reclaimIncentive` function does not reduce the `incentive.rewardsUnclaimed` field and thus one can reclaim tokens several times. This allows anyone to steal all tokens from all incentives by creating an incentive themself, and once it's expired, repeatedly claim the unclaimed rewards until the token balance is empty.  ## POC - Attacker creates an incentive for a non-existent pool using a random address for `pool` (This is done such that no other user can claim rewards as we need a non-zero `rewardsUnclaimed` balance for expiry). They choose the `incentive.token` to be the token they want to steal from other incentives. (for example, `WETH`, `USDC`, or `SUSHI`) They choose the `startTime, endTime, expiry` such that the checks pass, i.e., starting and ending in a few seconds from now, expiring in 5 weeks. Then they choose a non-zero `rewardsUnclaimed` and transfer the `incentive.token` to the PoolManager. - Attacker waits for 5 weeks until the incentive is expired - Attacker can now call `reclaimIncentive(pool, incentiveId, amount=incentive.rewardsUnclaimed, attacker, false)` to withdraw `incentive.rewardsUnclaimed` of `incentive.token` from the pool manager. - As the `incentive.rewardsUnclaimed` variable has not been decreased, they can keep calling `reclaimIncentive` until the pool is drained.  ## Impact An attacker can steal all tokens in the PoolManager.  ## Recommended Mitigation Steps In `reclaimIncentive`, reduce `incentive.rewardsUnclaimed` by the withdrawn `amount`.   "}, {"title": "Wrong inequality when adding/removing liquidity in current price range", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/34", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-09-sushitrident-2-findings", "body": "# Handle  cmichel   # Vulnerability details  The `ConcentratedLiquidityPool.mint/burn` functions add/remove `liquidity` when `(priceLower < currentPrice && currentPrice < priceUpper)`. Shouldn't it also be changed if `priceLower == currentPrice`?  ## Impact Pools that mint/burn liquidity at a time where the `currentPrice` is right at the lower price range do not work correctly and will lead to wrong swap amounts.  ## Recommended Mitigation Steps Change the inequalities to `if (priceLower <= currentPrice && currentPrice < priceUpper)`.   "}, {"title": "`ConcentratedLiquidityPool`s can be created with the same tokens", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/33", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-09-sushitrident-2-findings", "body": "# Handle  cmichel   # Vulnerability details  The `ConcentratedLiquidityPool.constructor` does not check that `_token0 != _token1`. The pool factory does not ensure this either.  ## Impact Pools can be created using the same token. This should be prevented as it does not make sense.  ## Recommended Mitigation Steps Add a `_token0 != _token1` check to the constructor.   "}, {"title": "`ConcentratedLiquidityPool.Sync` event never used", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/32", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-09-sushitrident-2-findings", "body": "`ConcentratedLiquidityPool.Sync` event never used"}, {"title": "`Ticks.cross` wrong comment?", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/31", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-09-sushitrident-2-findings", "body": "`Ticks.cross` wrong comment?"}, {"title": "`DyDxMath.getLiquidityForAmounts` underflows", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/30", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-09-sushitrident-2-findings", "body": "# Handle  cmichel   # Vulnerability details  The `DyDxMath.getLiquidityForAmounts/getDx/getDy` functions perform unchecked computations on `priceUpper - priceLower` but they do not check that `priceUpper >= priceLower`.  ## Impact The values can underflow and return much lower liquidity or much higher token amounts than expected.  The calling functions (`mint` and `burn`) also do not check this. For `mint`, it fails further down the callstack at `Ticks.insert`, but `burn` does not fail.  ## Recommended Mitigation Steps Check that the `lower` and `upper` from the provided parameters for `mint` and `burn` are indeed sorted, i.e., `lower < upper`. It should be checked explicitly at the start of the function.   "}, {"title": " No sanity check of `_price` in the constructor", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/28", "labels": ["bug", "1 (Low Risk)", "sponsor disputed"], "target": "2021-09-sushitrident-2-findings", "body": " No sanity check of `_price` in the constructor"}, {"title": "range fee growth underflow", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/25", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-09-sushitrident-2-findings", "body": "# Handle  broccoli   # Vulnerability details  # range fee growth underflow ## Impact The function `RangeFeeGrowth` [ConcentratedLiquidityPool.sol#L601-L633](https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/pool/concentrated/ConcentratedLiquidityPool.sol#L601-L633) would revert the transaction in some cases.  When a pool cross a tick, it only updates either `feeGrowthOutside0` or `feeGrowthOutside1`. [Ticks.sol#L23-L53](https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/libraries/concentratedPool/Ticks.sol#L23-L53)  `RangeFeeGrowth` calculates the fee as follow: ```solidity             feeGrowthInside0 = _feeGrowthGlobal0 - feeGrowthBelow0 - feeGrowthAbove0;             feeGrowthInside1 = _feeGrowthGlobal1 - feeGrowthBelow1 - feeGrowthAbove1; ```  `feeGrowthBelow + feeGrowthAbove` is not necessary smaller than `_feeGrowthGlobal`. Please see `POC`.   Users can not provide liquidity or burn liquidity. Fund will get stocked in the contract. I consider this is a high-risk issue.  ## Proof of Concept ```python     # This is the wrapper.     # def add_liquidity(pool, amount, lower, upper)     # def swap(pool, buy, amount)      add_liquidity(pool, deposit_amount, -800, 500)     add_liquidity(pool, deposit_amount, 400, 700)     # We cross the tick here to trigger the bug.      swap(pool, False, deposit_amount)     # Only tick 700's feeGrowthOutside1 is updated      swap(pool, True, deposit_amount)     # Only tick 500's feeGrowthOutside0 is updated          # current tick at -800      # this would revert     # feeGrowthBelow1 = feeGrowthGlobal1     # feeGrowthGlobal1 - feeGrowthBelow1 - feeGrowthAbove1 would revert     # user would not be able to mint/withdraw/cross this tick. The pool is broken     add_liquidity(pool, deposit_amount, 400, 700) ``` ## Tools Used Hardhat  ## Recommended Mitigation Steps  It's either modify the tick's algo or `RangeFeeGrowth`. The quick-fix I come up with is to deal with the fee in `RangeFeeGrowth`. However, I recommend the team to go through tick's logic again.  "}, {"title": "`ConcentratedLiquidityPool.burn()` Wrong implementation", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/24", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-09-sushitrident-2-findings", "body": "# Handle  WatchPug   # Vulnerability details  The reserves should be updated once LP tokens are burned to match the actual total bento shares hold by the pool.  However, the current implementation only updated reserves with the fees subtracted.  Makes the `reserve0` and `reserve1` smaller than the current `balance0` and `balance1`.  ## Impact  As a result, many essential features of the contract will malfunction, includes `swap()` and `mint()`.  ## Recommended Mitigation Steps  https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/pool/concentrated/ConcentratedLiquidityPool.sol#L263-L267  Change:  ```         unchecked {             reserve0 -= uint128(amount0fees);             reserve1 -= uint128(amount1fees);         }  ``` to:  ```         unchecked {             reserve0 -= uint128(amount0);             reserve1 -= uint128(amount1);         } ```  "}, {"title": "ConcentratedLiquidityPoolManager.sol#claimReward() and reclaimIncentive() will fail when incentive.token is token0 or token1", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/23", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-09-sushitrident-2-findings", "body": "# Handle  WatchPug   # Vulnerability details  In `ConcentratedLiquidityPosition.collect()`, balances of token0 and token1 in bento will be used to pay the fees.  https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/pool/concentrated/ConcentratedLiquidityPosition.sol#L103-L116  ```     uint256 balance0 = bento.balanceOf(token0, address(this));     uint256 balance1 = bento.balanceOf(token1, address(this));     if (balance0 < token0amount || balance1 < token1amount) {         (uint256 amount0fees, uint256 amount1fees) = position.pool.collect(position.lower, position.upper, address(this), false);          uint256 newBalance0 = amount0fees + balance0;         uint256 newBalance1 = amount1fees + balance1;          /// @dev Rounding errors due to frequent claiming of other users in the same position may cost us some raw         if (token0amount > newBalance0) token0amount = newBalance0;         if (token1amount > newBalance1) token1amount = newBalance1;     }     _transfer(token0, address(this), recipient, token0amount, unwrapBento);     _transfer(token1, address(this), recipient, token1amount, unwrapBento);  ```  In the case of someone add an incentive with `token0` or `token1`, the incentive in the balance of bento will be used to pay fees until the balance is completely consumed.  As a result, when a user calls `claimReward()`, the contract may not have enough balance to pay (it supposed to have it), cause the transaction to fail.  https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/pool/concentrated/ConcentratedLiquidityPoolManager.sol#L78-L100 ``` function claimReward(         uint256 positionId,         uint256 incentiveId,         address recipient,         bool unwrapBento     ) public {         require(ownerOf[positionId] == msg.sender, \"OWNER\");         Position memory position = positions[positionId];         IConcentratedLiquidityPool pool = position.pool;         Incentive storage incentive = incentives[position.pool][positionId];         Stake storage stake = stakes[positionId][incentiveId];         require(stake.initialized, \"UNINITIALIZED\");         uint256 secondsPerLiquidityInside = pool.rangeSecondsInside(position.lower, position.upper) - stake.secondsInsideLast;         uint256 secondsInside = secondsPerLiquidityInside * position.liquidity;         uint256 maxTime = incentive.endTime < block.timestamp ? block.timestamp : incentive.endTime;         uint256 secondsUnclaimed = (maxTime - incentive.startTime) << (128 - incentive.secondsClaimed);         uint256 rewards = (incentive.rewardsUnclaimed * secondsInside) / secondsUnclaimed;         incentive.rewardsUnclaimed -= rewards;         incentive.secondsClaimed += uint160(secondsInside);         stake.secondsInsideLast += uint160(secondsPerLiquidityInside);         _transfer(incentive.token, address(this), recipient, rewards, unwrapBento);         emit ClaimReward(positionId, incentiveId, recipient);     } ```  The same issue applies to `reclaimIncentive()` as well.  https://github.com/sushiswap/trident/blob/c405f3402a1ed336244053f8186742d2da5975e9/contracts/pool/concentrated/ConcentratedLiquidityPoolManager.sol#L49-L62 ``` function reclaimIncentive(     IConcentratedLiquidityPool pool,     uint256 incentiveId,     uint256 amount,     address receiver,     bool unwrapBento ) public {     Incentive storage incentive = incentives[pool][incentiveId];     require(incentive.owner == msg.sender, \"NOT_OWNER\");     require(incentive.expiry < block.timestamp, \"EXPIRED\");     require(incentive.rewardsUnclaimed >= amount, \"ALREADY_CLAIMED\");     _transfer(incentive.token, address(this), receiver, amount, unwrapBento);     emit ReclaimIncentive(pool, incentiveId); } ```  ## Recommendation  Consider making adding `token0` or `token1` as incentives disallowed, or keep a record of total remaining incentive amounts for the incentive tokens and avoid consuming these revered balances when `collect()`.  "}, {"title": "Spelling Errors", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/22", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-09-sushitrident-2-findings", "body": "Spelling Errors"}, {"title": "Ticks: getMaxLiquidity() formula should be explained", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/21", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-09-sushitrident-2-findings", "body": "Ticks: getMaxLiquidity() formula should be explained"}, {"title": "ConcentratedLiquidityPoolHelper: getTickState() might run out of gas", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/17", "labels": ["bug", "duplicate", "2 (Med Risk)", "sponsor acknowledged"], "target": "2021-09-sushitrident-2-findings", "body": "ConcentratedLiquidityPoolHelper: getTickState() might run out of gas"}, {"title": "ConcentratedLiquidityPool: incorrect feeGrowthGlobal accounting when crossing ticks", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/16", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-09-sushitrident-2-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  Swap fees are taken from the output. Hence, if swapping token0 for token1 (`zeroForOne` is true), then fees are taken in token1. We see this to be the case in the initialization of feeGrowthGlobal in the swap cache   `feeGrowthGlobal = zeroForOne ? feeGrowthGlobal1 : feeGrowthGlobal0;`  and in `_updateFees()`.  However, looking at `Ticks.cross()`, the logic is the reverse, which causes wrong fee accounting.  ```jsx if (zeroForOne) {  ...  ticks[nextTickToCross].feeGrowthOutside0 = feeGrowthGlobal - ticks[nextTickToCross].feeGrowthOutside0; } else {  ...  ticks[nextTickToCross].feeGrowthOutside1 = feeGrowthGlobal - ticks[nextTickToCross].feeGrowthOutside1; } ```  ### Recommended Mitigation Steps  Switch the `0` and `1` in `Ticks.cross()`.  ```jsx if (zeroForOne) {  ...  // feeGrowthGlobal = feeGrowthGlobal1  ticks[nextTickToCross].feeGrowthOutside1 = feeGrowthGlobal - ticks[nextTickToCross].feeGrowthOutside1; } else {  ...  // feeGrowthGlobal = feeGrowthGlobal0  ticks[nextTickToCross].feeGrowthOutside0 = feeGrowthGlobal - ticks[nextTickToCross].feeGrowthOutside0; } ```  "}, {"title": "ConcentratedLiquidityPool: secondsPerLiquidity should be modified whenever pool liquidity changes", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/15", "labels": ["bug", "3 (High Risk)", "sponsor disputed"], "target": "2021-09-sushitrident-2-findings", "body": "ConcentratedLiquidityPool: secondsPerLiquidity should be modified whenever pool liquidity changes"}, {"title": "ConcentratedLiquidityPool: rangeFeeGrowth and secondsPerLiquidity math needs to be unchecked", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/13", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-09-sushitrident-2-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  The fee growth mechanism, and by extension, secondsPerLiquidity mechanism of Uniswap V3 has the ability to underflow. It is therefore a necessity for the math to (ironically) be unsafe / unchecked.   ### Proof of Concept  Assume the following scenario and initial conditions:  - Price at parity (nearestTick is 0) - tickSpacing of 10 - Swaps only increase the price (nearestTick moves up only) - feeGrowthGlobal initializes with 0, increases by 1 for every tick moved for simplicity - Existing positions that provide enough liquidity and enable nearestTick to be set to values in the example - Every tick initialized in the example is \u2264 nearestTick, so that its feeGrowthOutside = feeGrowthGlobal  1. When nearestTick is at 40, Alice creates a position for uninitialised ticks [-20, 30]. The ticks are initialized, resulting in their feeGrowthOutside values to be set to 40. 2. nearestTick moves to 50. Bob creates a position with ticks [20, 30] (tick 20 is uninitialised, 30 was initialized from Alice's mint). tick 20 will therefore have a feeGrowthOutside of 50. 3. Let us calculate `rangeFeeGrowth(20,30)`.     - lowerTick = 20, upperTick = 30     - feeGrowthBelow = 50 (lowerTick's feeGrowthOutside) since lowerTick < currentTick     - feeGrowthAbove = 50 - 40 = 10 (feeGrowthGlobal - upperTick's feeGrowthOutside) since upperTick < currentTick     - feeGrowthInside                  = feeGrowthGlobal - feeGrowthBelow - feeGrowthAbove                  = 50 - 50 - 10                  = -10           We therefore have negative feeGrowthInside.  This behaviour is actually acceptable, because the important thing about this mechanism is the relative values to each other, not the absolute values themselves.  ### Recommended Mitigation Steps  `rangeFeeGrowth()` and `rangeSecondsInside()` has to be unchecked. In addition, the subtraction of feeGrowthInside values should also be unchecked in `_updatePosition()` and `ConcentratedLiquidityPosition#collect()`.  The same also applies for the subtraction of `pool.rangeSecondsInside` and `stake.secondsInsideLast` in `claimReward()` and `getReward()` of the `ConcentratedLiquidityPoolManager` contract.  "}, {"title": "ConcentratedLiquidityPool: MAX_TICK_LIQUIDITY is checked incorrectly", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/12", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged", "disagree with severity"], "target": "2021-09-sushitrident-2-findings", "body": "ConcentratedLiquidityPool: MAX_TICK_LIQUIDITY is checked incorrectly"}, {"title": "ConcentratedLiquidityPool: initialPrice should be checked to be within allowable range", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/11", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-09-sushitrident-2-findings", "body": "# Handle  hickuphh3   # Vulnerability details  ### Impact  No check is performed for the initial price. This means that it can be set to be below the `MIN_SQRT_RATIO` or above `MAX_SQRT_RATIO` (Eg. zero value), which will prevent the usability of all other functions (minting, swapping, burning).  For example, `Ticks.insert()` would fail when attempting to calculate `actualNearestTick = TickMath.getTickAtSqrtRatio(currentPrice);`, which means no one will be able to mint positions.  ### Recommended Mitigation Steps  Check the `initialPrice` is within the acceptable range, ie. `MIN_SQRT_RATIO <= initialPrice <= MAX_SQRT_RATIO`  "}, {"title": "Incentives for different pools should differ by a large factor", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/10", "labels": ["bug", "2 (Med Risk)", "sponsor disputed"], "target": "2021-09-sushitrident-2-findings", "body": "Incentives for different pools should differ by a large factor"}, {"title": "Possible attacks on Seconds * Liquidity calculation", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/8", "labels": ["bug", "3 (High Risk)", "sponsor acknowledged"], "target": "2021-09-sushitrident-2-findings", "body": "Possible attacks on Seconds * Liquidity calculation"}, {"title": "Consider using solidity version 0.8.8", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/7", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-09-sushitrident-2-findings", "body": "Consider using solidity version 0.8.8"}, {"title": "Implement or remove functions", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/6", "labels": ["bug", "1 (Low Risk)", "sponsor disputed"], "target": "2021-09-sushitrident-2-findings", "body": "Implement or remove functions"}, {"title": "Possible underflow if other checks aren't used", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/5", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged", "disagree with severity"], "target": "2021-09-sushitrident-2-findings", "body": "Possible underflow if other checks aren't used"}, {"title": "Unlocked Pragma Statements", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/3", "labels": ["bug", "1 (Low Risk)", "sponsor disputed"], "target": "2021-09-sushitrident-2-findings", "body": "Unlocked Pragma Statements"}, {"title": "Understanding the fee growth mechanism (why nearestTick is unsuitable)", "html_url": "https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/1", "labels": ["bug", "3 (High Risk)", "sponsor acknowledged"], "target": "2021-09-sushitrident-2-findings", "body": "Understanding the fee growth mechanism (why nearestTick is unsuitable)"}, {"title": "depositYieldBearing didn't check address != 0", "html_url": "https://github.com/code-423n4/2021-10-tempus-findings/issues/48", "labels": ["bug", "sponsor confirmed", "disagree with severity", "0 (Non-critical)", "resolved"], "target": "2021-10-tempus-findings", "body": "# Handle  pants   # Vulnerability details    "}, {"title": "`internal` functions can be `private`", "html_url": "https://github.com/code-423n4/2021-10-tempus-findings/issues/46", "labels": ["bug", "sponsor disputed", "0 (Non-critical)"], "target": "2021-10-tempus-findings", "body": "`internal` functions can be `private`"}, {"title": "`public` functions can be `external`", "html_url": "https://github.com/code-423n4/2021-10-tempus-findings/issues/45", "labels": ["bug", "sponsor confirmed", "G (Gas Optimization)", "resolved"], "target": "2021-10-tempus-findings", "body": "# Handle  pants   # Vulnerability details  These `public` functions are never called by their contract: - `TempusAMM.getSwapAmountToEndWithEqualShares()` - `TempusAMM.getRate()` - `AaveTempusPool.currentInterestRate()` - `AaveTempusPool.numAssetsPerYieldToken()` - `AaveTempusPool.numYieldTokensPerAsset()` - `CompoundTempusPool.currentInterestRate()` - `CompoundTempusPool.numAssetsPerYieldToken()` - `CompoundTempusPool.numYieldTokensPerAsset()` - `LidoTempusPool.currentInterestRate()` - `LidoTempusPool.numAssetsPerYieldToken()` - `LidoTempusPool.numYieldTokensPerAsset()` - `ERC20FixedSupply.decimals()` - `ERC20OwnerMintableToken.burn()` - `ERC20OwnerMintableToken.burnFrom()` - `PoolShare.decimals()` - `PermanentlyOwnable.renounceOwnership()` - `TempusController.depositYieldBearing()` - `TempusController.depositBacking()` - `TempusController.redeemToYieldBearing()` - `TempusController.redeemToBacking()` - `TempusPool.estimatedMintedShares()` - `TempusPool.estimatedRedeem()`  Therefore, their visibility can be reduced to `external`.  ## Impact `external` functions are cheaper than `public` functions.  ## Proof of Concept https://gus-tavo-guim.medium.com/public-vs-external-functions-in-solidity-b46bcf0ba3ac  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Define these functions as `external`.  "}, {"title": "Prefix increaments are cheaper than postfix increaments", "html_url": "https://github.com/code-423n4/2021-10-tempus-findings/issues/40", "labels": ["bug", "sponsor acknowledged", "G (Gas Optimization)"], "target": "2021-10-tempus-findings", "body": "Prefix increaments are cheaper than postfix increaments"}, {"title": "Open TODOs", "html_url": "https://github.com/code-423n4/2021-10-tempus-findings/issues/39", "labels": ["bug", "sponsor confirmed", "1 (Low Risk)", "resolved"], "target": "2021-10-tempus-findings", "body": "# Handle  ye0lde   # Vulnerability details  # Vulnerability details  ## Impact Open TODOs can point to architecture or programming issues that still need to be resolved.  ## Proof of Concept The TODO is here: https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/libraries/NFTTokenURIScaffold.sol#L87  ## Tools Used VS Code  ## Recommended Mitigation Steps Consider resolving the TODO before deploying.  "}, {"title": "Use of uint8 for counter in for loop increases gas costs", "html_url": "https://github.com/code-423n4/2021-10-tempus-findings/issues/38", "labels": ["bug", "sponsor confirmed", "G (Gas Optimization)", "resolved"], "target": "2021-10-tempus-findings", "body": "# Handle  pants   # Vulnerability details  On L158 of swap.sol, you use a uint8 as the for loop variable:  Due to how the EVM natively works on 256 numbers, using a 8 bit number here introduces additional costs as the EVM has to properly enforce the limits of this smaller type.  See the warning at this link: https://docs.soliditylang.org/en/v0.8.0/internals/layout_in_storage.html#layout-of-state-variables-in-storage  "}, {"title": "getAMMOrderedAmounts and _exitTempusAmmAndRedeem functions use explicit token comparison for ordering instead of relying on Balancer's PoolTokens", "html_url": "https://github.com/code-423n4/2021-10-tempus-findings/issues/37", "labels": ["bug", "sponsor confirmed", "0 (Non-critical)", "resolved"], "target": "2021-10-tempus-findings", "body": "# Handle  hyh   # Vulnerability details  ## Vulnerability Details getAMMOrderedAmounts, https://github.com/code-423n4/2021-10-tempus/blob/main/contracts/TempusController.sol#L692, and _exitTempusAmmAndRedeem, https://github.com/code-423n4/2021-10-tempus/blob/main/contracts/TempusController.sol#L644, functions use explicit token comparison for ordering, while it is based on current Balancer pool implementation, which can change, leading to contract logic discrepancies.  In the same time _getAMMDetailsAndEnsureInitialized (https://github.com/code-423n4/2021-10-tempus/blob/main/contracts/TempusController.sol#L673) do rely on PoolTokens, which obtain token list in Balancer's call sequence as follows: PoolTokens._getPoolTokens -> TwoTokenPoolsBalance._getTwoTokenPoolTokens -> TwoTokenPoolsBalance._getTwoTokenPoolBalances -> TwoTokenPoolsBalance._twoTokenPoolTokens[].  TwoTokenPoolsBalance._twoTokenPoolTokens[] is ordered during _registerTwoTokenPoolTokens, but this is current implementation.  It is safer to use vault.getPoolTokens(poolId) in getAMMOrderedAmounts to obtain an ordered pair.  This can matter as AMM token usage isn't symmetric (https://github.com/code-423n4/2021-10-tempus/blob/main/contracts/TempusController.sol#L84).  ## Impact Probability here is low and risk rating is minimal, but the impact can vary as TempusController contract  logic rely on token ordering.  "}, {"title": "for loop with _TOTAL_TOKENS", "html_url": "https://github.com/code-423n4/2021-10-tempus-findings/issues/36", "labels": ["bug", "sponsor confirmed", "G (Gas Optimization)", "resolved"], "target": "2021-10-tempus-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact The loop here is not really necessary as _TOTAL_TOKENS is a constant of 2 so there is always just 1 iteration:         for (uint256 i = 1; i < _TOTAL_TOKENS; ++i) {             uint256 currentBalance = balances[i];             if (currentBalance > maxBalance) {                 chosenTokenIndex = i;                 maxBalance = currentBalance;             }         }  ## Recommended Mitigation Steps Consider if you want to reduce gas usage by eliminating this loop here but taking the risk that _TOTAL_TOKENS will not be updated to a different value.  "}, {"title": "Unused imports", "html_url": "https://github.com/code-423n4/2021-10-tempus-findings/issues/33", "labels": ["bug", "sponsor confirmed", "G (Gas Optimization)", "resolved"], "target": "2021-10-tempus-findings", "body": "Unused imports"}, {"title": "Lack of validation for Maturity Date", "html_url": "https://github.com/code-423n4/2021-10-tempus-findings/issues/32", "labels": ["bug", "sponsor disputed", "disagree with severity", "0 (Non-critical)"], "target": "2021-10-tempus-findings", "body": "Lack of validation for Maturity Date"}, {"title": "Cache array length in for loops can save gas", "html_url": "https://github.com/code-423n4/2021-10-tempus-findings/issues/31", "labels": ["bug", "sponsor acknowledged", "G (Gas Optimization)"], "target": "2021-10-tempus-findings", "body": "Cache array length in for loops can save gas"}, {"title": "Adding unchecked directive can save gas", "html_url": "https://github.com/code-423n4/2021-10-tempus-findings/issues/30", "labels": ["bug", "sponsor confirmed", "G (Gas Optimization)", "resolved"], "target": "2021-10-tempus-findings", "body": "Adding unchecked directive can save gas"}, {"title": "Typos", "html_url": "https://github.com/code-423n4/2021-10-tempus-findings/issues/29", "labels": ["bug", "sponsor confirmed", "0 (Non-critical)", "resolved"], "target": "2021-10-tempus-findings", "body": "# Handle  ye0lde   # Vulnerability details  ## Impact Typos  ## Proof of Concept The typos are here:  `vaulId` https://github.com/code-423n4/2022-01-yield/blob/e946f40239b33812e54fafc700eb2298df1a2579/contracts/ConvexModule.sol#L14 https://github.com/code-423n4/2022-01-yield/blob/e946f40239b33812e54fafc700eb2298df1a2579/contracts/ConvexModule.sol#L25  ## Tools Used VS Code  ## Recommended Mitigation Steps Correct the typos  "}, {"title": "Long Revert Strings", "html_url": "https://github.com/code-423n4/2021-10-tempus-findings/issues/28", "labels": ["bug", "sponsor acknowledged", "G (Gas Optimization)"], "target": "2021-10-tempus-findings", "body": "# Handle  ye0lde   # Vulnerability details  ## Impact  Shortening revert strings to fit in 32 bytes will decrease deployment time gas and will decrease runtime gas when the revert condition has been met.    Revert strings that are longer than 32 bytes require at least one additional mstore, along with additional overhead for computing memory offset, etc.  ## Proof of Concept  Revert strings > 32 bytes are here: https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/customswap/contracts/Swap.sol#L149-L150 https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/customswap/contracts/SwapUtils.sol#L1625 https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/customswap/contracts/SwapUtils.sol#L1679  https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/vesting/contracts/Vesting.sol#L105 https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/vesting/contracts/Vesting.sol#L194-L197  https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/tge/contracts/PublicSale.sol#L152 https://github.com/code-423n4/2021-11-bootfinance/blob/7c457b2b5ba6b2c887dafdf7428fd577e405d652/tge/contracts/PublicSale.sol#L162  ## Tools Used Visual Studio Code  ## Recommended Mitigation Steps Shorten the revert strings to fit in 32 bytes.    "}, {"title": "Gas: `ERC20OwnerMintableToken.burn` should use caller", "html_url": "https://github.com/code-423n4/2021-10-tempus-findings/issues/27", "labels": ["bug", "sponsor disputed", "G (Gas Optimization)"], "target": "2021-10-tempus-findings", "body": "Gas: `ERC20OwnerMintableToken.burn` should use caller"}, {"title": "Gas: Don't store cToken twice", "html_url": "https://github.com/code-423n4/2021-10-tempus-findings/issues/26", "labels": ["bug", "sponsor confirmed", "G (Gas Optimization)", "resolved"], "target": "2021-10-tempus-findings", "body": "# Handle  cmichel   # Vulnerability details  In `CompoundTempusPool`, the `cToken` and the base class' `yieldBearingToken` storage fields are the same. Remove the `cToken` field and the assignment in the constructor to save gas.   "}, {"title": "`_setAmplificationData` should clear upper bits of values", "html_url": "https://github.com/code-423n4/2021-10-tempus-findings/issues/25", "labels": ["bug", "sponsor disputed", "0 (Non-critical)"], "target": "2021-10-tempus-findings", "body": "`_setAmplificationData` should clear upper bits of values"}, {"title": "`transferFees` may not be the contract itself", "html_url": "https://github.com/code-423n4/2021-10-tempus-findings/issues/24", "labels": ["bug", "sponsor acknowledged", "disagree with severity", "0 (Non-critical)"], "target": "2021-10-tempus-findings", "body": "`transferFees` may not be the contract itself"}, {"title": "No `swap` slippage checks", "html_url": "https://github.com/code-423n4/2021-10-tempus-findings/issues/23", "labels": ["bug", "sponsor confirmed", "1 (Low Risk)", "resolved"], "target": "2021-10-tempus-findings", "body": "# Handle  cmichel   # Vulnerability details  The (second) `TempusController._exitTempusAmmAndRedeem` function swaps the difference of yield and principal shares using the AMM.  ```solidity swap(     tempusAMM,     tempusAMM.getSwapAmountToEndWithEqualShares(principals, yields, maxLeftoverShares),     tokenIn,     tokenOut,     0 // @audit min return of zero ); // yields and principals are updated to the received amounts and redeemed // ... ```  It does not use a min return value for this swap and it is, therefore, susceptible to sandwich attacks.  > A common attack in DeFi is the sandwich attack. Upon observing a trade of asset X for asset Y, an attacker frontruns the victim trade by also buying asset Y, lets the victim execute the trade, and then backruns (executes after) the victim by trading back the amount gained in the first trade. Intuitively, one uses the knowledge that someone\u2019s going to buy an asset, and that this trade will increase its price, to make a profit. The attacker\u2019s plan is to buy this asset cheap, let the victim buy at an increased price, and then sell the received amount again at a higher price afterwards.  ## Impact Trades can happen at a bad price and lead to receiving fewer tokens than at a fair market price. The attacker's profit is the user's loss.  ## Recommended Mitigation Steps Add minimum return amount checks. Accept a function parameter that can be chosen by the transaction sender, then check that the actually received amount is above this parameter. Similar to `minLpAmountsOut` but for the yields & principal shares (or the redeemed tokens).  "}, {"title": "`exitTempusAMM` can be made to fail", "html_url": "https://github.com/code-423n4/2021-10-tempus-findings/issues/21", "labels": ["bug", "sponsor confirmed", "2 (Med Risk)", "resolved"], "target": "2021-10-tempus-findings", "body": "# Handle  cmichel   # Vulnerability details  There's a griefing attack where an attacker can make any user transaction for `TempusController.exitTempusAMM` fail. In `_exitTempusAMM`, the user exits their LP position and claims back yield and principal shares. The LP amounts to redeem are determined by the function parameter `lpTokensAmount`. A final `assert(tempusAMM.balanceOf(address(this)) == 0)` statement checks that the LP token amount of the contract is zero after the exit. This is only true if no other LP shares were already in the contract.  However, an attacker can frontrun this call and send the smallest unit of LP shares to the contract which then makes the original deposit-and-fix transaction fail.  ## Impact All `exitTempusAMM` calls can be made to fail and this function becomes unusable.  ## Recommended Mitigation Steps Remove the `assert` check.  "}, {"title": "`depositAndFix` can be made to fail", "html_url": "https://github.com/code-423n4/2021-10-tempus-findings/issues/20", "labels": ["bug", "sponsor confirmed", "2 (Med Risk)", "resolved"], "target": "2021-10-tempus-findings", "body": "# Handle  cmichel   # Vulnerability details  There's a griefing attack where an attacker can make any user transaction for `TempusController.depositAndFix` fail. In `_depositAndFix`, `swapAmount` many yield shares are swapped to principal where `swapAmount` is derived from the function arguments. A final `assert(yieldShares.balanceOf(address(this)) == 0)` statement checks that the yield shares of the contract are zero after the swap. This is only true if no other yield shares were already in the contract.  However, an attacker can frontrun this call and send the smallest unit of yield shares to the contract which then makes the original deposit-and-fix transaction fail.  ## Impact All `depositAndFix` calls can be made to fail and this function becomes unusable.  ## Recommended Mitigation Steps Remove the `assert` check.  "}, {"title": "TempusAMM freezing all actions except proportional exit on maturity seems unnecessary", "html_url": "https://github.com/code-423n4/2021-10-tempus-findings/issues/18", "labels": ["bug", "sponsor confirmed", "G (Gas Optimization)", "resolved"], "target": "2021-10-tempus-findings", "body": "# Handle  TomFrench   # Vulnerability details  ## Impact  Reduced flexibility of AMM + additional gas costs on swaps  ## Proof of Concept  As the relative payouts of the principal and yield tokens are fixed at the point of finalisation, there's no need to freeze the AMM as it will just rapidly be arbed to the final prices of each token. No funds will be lost by LPs.  Making this change would reduce gas costs as swaps won't have to check maturity (load the TempusPool then perform SLOAD for maturity state variable).  ## Recommended Mitigation Steps  Remove `beforeMaturity` modifier from AMM.  "}, {"title": "Inheritance from BaseGeneralPool is unused", "html_url": "https://github.com/code-423n4/2021-10-tempus-findings/issues/17", "labels": ["bug", "sponsor confirmed", "G (Gas Optimization)", "resolved"], "target": "2021-10-tempus-findings", "body": "# Handle  TomFrench   # Vulnerability details  ## Impact  ## Proof of Concept  As the `TempusAmm` only ever registers with the Balancer Vault with the two token specialization the `GeneralPool` interface will never be used as the Vault will call the `MinimalSwapInfoPool` hooks instead.  https://github.com/code-423n4/2021-10-tempus/blob/63f7639aad08f2bba717830ed81e0649f7fc23ee/contracts/amm/TempusAMM.sol#L107-L110  See here in the Balancer Vault code:  https://github.com/balancer-labs/balancer-v2-monorepo/blob/62c5cba7cae1d481f913c90fe0d9d94e101570c5/pkg/vault/contracts/Swaps.sol#L287-L292  ## Recommended Mitigation Steps  Remove the inheritance from `BaseGeneralPool` and remove the functions highlighted in the link below. This will help reduce bytecode from the AMM factory and reduce deployment costs.  https://github.com/code-423n4/2021-10-tempus/blob/63f7639aad08f2bba717830ed81e0649f7fc23ee/contracts/amm/TempusAMM.sol#L283-L309  "}, {"title": "Repeated token transfers on deposits are unnecessary", "html_url": "https://github.com/code-423n4/2021-10-tempus-findings/issues/16", "labels": ["bug", "sponsor confirmed", "G (Gas Optimization)", "resolved"], "target": "2021-10-tempus-findings", "body": "# Handle  TomFrench   # Vulnerability details  ## Impact  Higher gas costs on transfers of tokens from user to TempusPool  ## Proof of Concept  Following the flow of tokens from the user to their the `TempusPool contract`:  1. User calls `TempusController.depositBacking`, `TempusController` transfers user's tokens to itself and approves relevant `TempusPool`  https://github.com/code-423n4/2021-10-tempus/blob/63f7639aad08f2bba717830ed81e0649f7fc23ee/contracts/TempusController.sol#L412-L414  2. `TempusController` calls `TempusPool.deposit` which in turn transfers tokens from the `TempusController` and then invests them.  https://github.com/code-423n4/2021-10-tempus/blob/63f7639aad08f2bba717830ed81e0649f7fc23ee/contracts/TempusPool.sol#L178  This first transfer is then superfluous as the `TempusPool` trusts the `TempusController` (it's the only contract which may call `deposit`). We're then incurring the costs of 1 `transfer` and 1 `approve` unnecessarily.  ## Recommended Mitigation Steps  As `TempusPool` trusts `TempusController`, `TempusController` can transfer the tokens directly to `TempusPool` and just tell it how much has been deposited.  L412-L414 of `TempusController.sol` would then be replaced with: ``` // Deposit to directly to targetPool uint transferredYBT = yieldBearingToken.untrustedTransferFrom(msg.sender, targetPool, yieldTokenAmount); ```  "}, {"title": "Use of `matured` storage variable is unnecessary", "html_url": "https://github.com/code-423n4/2021-10-tempus-findings/issues/15", "labels": ["bug", "sponsor confirmed", "G (Gas Optimization)", "resolved"], "target": "2021-10-tempus-findings", "body": "# Handle  TomFrench   # Vulnerability details  ## Impact  Increased gas costs on several `TempusPool` functions  ## Proof of Concept  `TempusPool`s have a `finalize` function which checks whether `block.timestamp >= maturityTime` and flips the `maturity` storage variable as well as setting `maturityInterestRate` to the current interest rate.  https://github.com/tempus-finance/tempus-protocol/blob/0240b4d172d7aa093a70e0401f4140c99aa30dc6/contracts/TempusPool.sol#L126-L135  `maturity` is used in several places to check whether the pool has expired however checking this variable is more expensive than checking `block.timestamp >= maturityTime` (due to the need for a SLOAD whereas `maturityTime` is immutable so no SLOAD is needed). I'd recommend making a `function matured() public view` to keep the readability.  However `maturityInterestRate` still needs to be set correctly. This could be done by reading the current interest rate when `matured()` returns true but `maturityInterestRate == 0` this could cause issues with some functions which are currently view functions however.   ## Recommended Mitigation Steps  Half solution:  Replace `matured` state variable with a `matured()` view function which returns `maturityInterestRate > 0`. This removes an SSTORE from `finalize` and an `SLOAD` from any function which uses `maturityInterestRate` as you can just check if it's greater than zero to see if the pool has matured.  Full solution:   Replace `matured` state variable with a `matured()` view function which returns  `block.timestamp >= maturityTime`. This combined with setting `maturityInterestRate` when you see that `matured() == true` and `maturityInterestRate == 0` would remove the need for the `finalize` function entirely.  "}, {"title": "Aave/Compound pools result in liquidity mining returns being lost", "html_url": "https://github.com/code-423n4/2021-10-tempus-findings/issues/14", "labels": ["bug", "0 (Non-critical)"], "target": "2021-10-tempus-findings", "body": "Aave/Compound pools result in liquidity mining returns being lost"}, {"title": "cToken funds are locked if Compound's exchange rate is 0", "html_url": "https://github.com/code-423n4/2021-10-tempus-findings/issues/13", "labels": ["bug", "sponsor disputed", "0 (Non-critical)"], "target": "2021-10-tempus-findings", "body": "cToken funds are locked if Compound's exchange rate is 0"}, {"title": "Param `initInterestRate` in `TempusPool::constructor` should not be 0", "html_url": "https://github.com/code-423n4/2021-10-tempus-findings/issues/12", "labels": ["bug", "sponsor confirmed", "1 (Low Risk)", "resolved"], "target": "2021-10-tempus-findings", "body": "# Handle  pmerkleplant   # Vulnerability details  ## Impact If `initInterestRate` in the `TempusPool`'s constructor is given as 0,  no funds can be withdrawn as `getRedemptionAmounts()` always panic errors with _division by 0_ ([link](https://github.com/code-423n4/2021-10-tempus/blob/main/contracts/TempusPool.sol#L305)).  ## Recommended Mitigation Steps It should be stated in the constructor's specs that `initInterestRate` should not be 0.  "}, {"title": "Make `protocolName` variables in protocol pools constant", "html_url": "https://github.com/code-423n4/2021-10-tempus-findings/issues/11", "labels": ["bug", "sponsor confirmed", "G (Gas Optimization)", "resolved"], "target": "2021-10-tempus-findings", "body": "# Handle  pmerkleplant   # Vulnerability details  ## Impact The `protocolName` variables in the protocol-specific `TempusPool`s are set as _immutable_ but could be set as _constant_.  See [Compound](https://github.com/code-423n4/2021-10-tempus/blob/main/contracts/pools/CompoundTempusPool.sol#L19),  [Aave](https://github.com/code-423n4/2021-10-tempus/blob/main/contracts/pools/AaveTempusPool.sol#L18),  [Lido](https://github.com/code-423n4/2021-10-tempus/blob/main/contracts/pools/LidoTempusPool.sol#L9).  "}, {"title": "Steal tokens from TempusController", "html_url": "https://github.com/code-423n4/2021-10-tempus-findings/issues/10", "labels": ["bug", "sponsor confirmed", "disagree with severity", "3 (High Risk)", "resolved"], "target": "2021-10-tempus-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The function _depositAndProvideLiquidity can be used go retrieve arbitrary ERC20 tokens from the TempusController.sol contract.  As the test contract of TempusController.sol https://goerli.etherscan.io/address/0xd4330638b87f97ec1605d7ec7d67ea1de5dd7aaa shows, it has indeed ERC20 tokens.  The problem is due to the fact that you supply an arbitrary tempusAMM to depositAndProvideLiquidity and thus to _depositAndProvideLiquidity.  tempusAMM could be a fake contract that supplies values that are completely fake.  At the end of the function _depositAndProvideLiquidity, ERC20 tokens are send to the user. If you can manipulate the variables ammTokens,  mintedShares  and sharesUsed you can send back any tokens held in the contract \"ammTokens[0].safeTransfer(msg.sender, mintedShares - sharesUsed[0]);\"  The Proof of Concept shows an approach to do this.    ## Proof of Concept https://github.com/code-423n4/2021-10-tempus/blob/63f7639aad08f2bba717830ed81e0649f7fc23ee/contracts/TempusController.sol#L73-L79  https://github.com/code-423n4/2021-10-tempus/blob/63f7639aad08f2bba717830ed81e0649f7fc23ee/contracts/TempusController.sol#L304-L335  Create a fake Vault contract (fakeVault) with the following functions: fakeVault.getPoolTokens(poolId) --> returns {TokenToSteal1,TokenToSteal2},{fakeBalance1,fakeBalance2},0 fakeVault.JoinPoolRequest() --> do nothing fakeVault.joinPool() --> do nothing  Create a fake Pool contract (fakePool) with the following functions: fakePool.yieldBearingToken() --> returns fakeYieldBearingToken fakePool.deposit() --> returns fakeMintedShares,....  Create a fake ammTokens contract with the following functions: tempusAMM.getVault() --> returns fakeVault tempusAMM.getPoolId() --> returns 0 tempusAMM.tempusPool() --> returns fakePool   call depositAndProvideLiquidity(fakeTempusAMM,1,false) // false -> yieldBearingToken _getAMMDetailsAndEnsureInitialized returns fakeVault,0, {token1,token2},{balance1,balance2} _deposit(fakePool,1,false) calls _depositYieldBearing which calls fakePool.deposit()  and returns fakeMintedShares _provideLiquidity(...)  calculates a vale of ammLiquidityProvisionAmounts _provideLiquidity(...)  skips the safeTransferFrom because sender == address(this))  the calls to fakeVault.JoinPoolRequest() and fakeVault.joinPool() can be faked. _provideLiquidity(...)  returns the value ammLiquidityProvisionAmounts  Now fakeMintedShares - ammLiquidityProvisionAmounts number of TokenToSteal1 and TokenToSteal2 are transferred to msg.sender  As you can both manipulate TokenToSteal1 and fakeMintedShares, you can transfer any token to msg.sender  ## Tools Used  ## Recommended Mitigation Steps Create a whitelist for tempusAMMs   "}, {"title": "PermanentlyOwnable does not prevent transferring ownership to a dead address.", "html_url": "https://github.com/code-423n4/2021-10-tempus-findings/issues/9", "labels": ["bug", "sponsor confirmed", "1 (Low Risk)", "resolved"], "target": "2021-10-tempus-findings", "body": "# Handle  chenyu   # Vulnerability details  ## Impact [PermanentlyOwnable](https://github.com/code-423n4/2021-10-tempus/blob/main/contracts/utils/PermanentlyOwnable.sol) does not prevent transferring to a dead address. It's possible to have a human error that transfers the contract ownership to a address not owned by the old owner.  ## Recommended Mitigation Steps Recommend a two step transfer that owner nominates an account, then the nominated account call an accept function to ensure the nominated account is valid.  "}, {"title": "Manipulating updateInterestRate() in Tempus Pools to mint more Principal and Yield Tokens Than They Should", "html_url": "https://github.com/code-423n4/2021-10-tempus-findings/issues/8", "labels": ["bug", "sponsor disputed", "0 (Non-critical)"], "target": "2021-10-tempus-findings", "body": "Manipulating updateInterestRate() in Tempus Pools to mint more Principal and Yield Tokens Than They Should"}, {"title": "Scaling factors for token 0/1 might swap in TempusAMM constructor.", "html_url": "https://github.com/code-423n4/2021-10-tempus-findings/issues/7", "labels": ["bug", "sponsor confirmed", "1 (Low Risk)", "resolved"], "target": "2021-10-tempus-findings", "body": "# Handle  chenyu   # Vulnerability details  ## Impact In TempusAMM constructor [L138](https://github.com/code-423n4/2021-10-tempus/blob/63f7639aad08f2bba717830ed81e0649f7fc23ee/contracts/amm/TempusAMM.sol#L138), the scaling factor 0 always maps to yieldShare, and scaling factor 1 always maps to principalShare, even though in L134 the two token might swap if principalShare < yieldShare, which makes _token0 = principalShare and _token1 = yieldShare, but scaling factor 0 is based on yieldShare.  Later [_scalingFactor](https://github.com/code-423n4/2021-10-tempus/blob/63f7639aad08f2bba717830ed81e0649f7fc23ee/contracts/amm/TempusAMM.sol#L802) is based on _token0, so it might get the wrong scaling factor if principalShare and yieldShare had swapped.  ## Recommended Mitigation Steps Update the lines to ```         _scalingFactor0 = _computeScalingFactor(IERC20(address(_token0)));         _scalingFactor1 = _computeScalingFactor(IERC20(address(_token1))); ```  "}, {"title": "No zero address check for controller in TempusPool", "html_url": "https://github.com/code-423n4/2021-10-tempus-findings/issues/6", "labels": ["bug", "sponsor confirmed", "disagree with severity", "0 (Non-critical)", "resolved"], "target": "2021-10-tempus-findings", "body": "# Handle  loop   # Vulnerability details  TempusPool needs to be initialized with a valid and existing controller. When initializing a pool `address controller` is passed to the constructor of a pool implementation. This `address` is then passed as `address ctrl` to the TempusPool constructor where it is set to the immutable `address controller`. If a pool accidentally gets initialized with the zero address passed to the constructor there is no way to change it and the pool needs to be reinitialized.  ## Proof of Concept https://github.com/code-423n4/2021-10-tempus/blob/main/contracts/TempusPool.sol#L66-L100  ## Recommended Mitigation Steps Add something along the lines of `require(ctrl != address(0), \"controller can not be zero` to avoid potential invalid pool initializations.   "}, {"title": "Improper Access Control", "html_url": "https://github.com/code-423n4/2021-10-tempus-findings/issues/5", "labels": ["bug", "sponsor disputed", "disagree with severity", "0 (Non-critical)"], "target": "2021-10-tempus-findings", "body": "# Lines of code  https://github.com/code-423n4/2022-04-dualityfocus/blob/f21ef7708c9335ee1996142e2581cb8714a525c9/contracts/compound_rari_fork/CToken.sol#L1641   # Vulnerability details  ## Impact  In the referenced code this line,  `require(msg.sender != admin, \"caller not admin\");` is meant to prevent non-admins from calling the function however it instead prevents admins from calling the function and allows anyone else to. This could lead to defacing the token i.e changing the name to something offensive like Shit Token, Poo Coin, etc.  ## Recommended Mitigation Steps  Adjust the require statement to reflect it's intended function i.e ` require(msg.sender == admin, \"caller not admin\");`  "}, {"title": "Named Return Issues", "html_url": "https://github.com/code-423n4/2021-10-tempus-findings/issues/4", "labels": ["bug", "sponsor confirmed", "G (Gas Optimization)", "resolved"], "target": "2021-10-tempus-findings", "body": "# Handle  ye0lde   # Vulnerability details  ## Impact  Removing unused named return variables can reduce gas usage and improve code clarity.  ## Proof of Concept  AaveTempusPool.sol: Unused named return https://github.com/code-423n4/2021-10-tempus/blob/63f7639aad08f2bba717830ed81e0649f7fc23ee/contracts/pools/AaveTempusPool.sol#L74  LidoTempusPool.sol: Unused named return https://github.com/code-423n4/2021-10-tempus/blob/63f7639aad08f2bba717830ed81e0649f7fc23ee/contracts/pools/LidoTempusPool.sol#L59  TempusAMM.sol: Unneeded return https://github.com/code-423n4/2021-10-tempus/blob/63f7639aad08f2bba717830ed81e0649f7fc23ee/contracts/amm/TempusAMM.sol#L533  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps Remove the unused named return variables or return.  "}, {"title": "Hex selector", "html_url": "https://github.com/code-423n4/2021-10-ambire-findings/issues/66", "labels": ["bug", "sponsor acknowledged", "0 (Non-critical)", "resolved"], "target": "2021-10-ambire-findings", "body": "Hex selector"}, {"title": "Only prepare tx when the fee is present", "html_url": "https://github.com/code-423n4/2021-10-ambire-findings/issues/65", "labels": ["bug", "sponsor acknowledged", "G (Gas Optimization)", "resolved"], "target": "2021-10-ambire-findings", "body": "Only prepare tx when the fee is present"}, {"title": "LibBytes uses itself", "html_url": "https://github.com/code-423n4/2021-10-ambire-findings/issues/58", "labels": ["bug", "sponsor confirmed", "G (Gas Optimization)", "resolved"], "target": "2021-10-ambire-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact I don't think it's necessary for the library to use itself here:   library LibBytes {     using LibBytes for bytes;  ## Recommended Mitigation Steps Remove this 'using' statement as it does not give anything in this case.  "}, {"title": "Duplicate math operations", "html_url": "https://github.com/code-423n4/2021-10-ambire-findings/issues/57", "labels": ["bug", "sponsor confirmed", "G (Gas Optimization)", "resolved"], "target": "2021-10-ambire-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact First perform the addition and only then check the length to avoid this duplicate math operation:     require(b.length >= index + 32, \"BytesLib: length\");     // Arrays are prefixed by a 256 bit length parameter     index += 32; Or if you want to stay with this approach, then at least consider using the 'unchecked' keyword when this addition is performed the second time as then ready know this can't overflow. Also, in function recoverAddrImpl the same operation is performed twice:   sig.length - 33  ## Recommended Mitigation Steps Refactor duplicate math operations.  "}, {"title": "ecrecover may return empty address", "html_url": "https://github.com/code-423n4/2021-10-ambire-findings/issues/56", "labels": ["bug", "sponsor confirmed", "1 (Low Risk)", "resolved"], "target": "2021-10-ambire-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact There is a common issue that ecrecover returns empty (0x0) address when the signature is invalid. function recoverAddrImpl should check that before returning the result of ecrecover.  ## Recommended Mitigation Steps See the solution here: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.0/contracts/cryptography/ECDSA.sol#L68  "}, {"title": "block.chainid may change in case of a hardfork", "html_url": "https://github.com/code-423n4/2021-10-ambire-findings/issues/55", "labels": ["bug", "sponsor confirmed", "1 (Low Risk)", "resolved"], "target": "2021-10-ambire-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact The 'DOMAIN_SEPARATOR' is not recalculated in the case of a hard fork. The variable DOMAIN_SEPARATOR in contract QuickAccManager is cached in the contract storage and will not change after being initialized. However, if a hard fork happens after the contract deployment, the domain would become invalid on one of the forked chains due to the block.chainid has changed.  A similar issue was reported in a previous contest and was assigned a severity of low: https://github.com/code-423n4/2021-06-realitycards-findings/issues/166  ## Recommended Mitigation Steps An elegant solution that you may consider applying is from Sushi Trident: https://github.com/sushiswap/trident/blob/concentrated/contracts/pool/concentrated/TridentNFT.sol#L47-L62  "}, {"title": "Hardcoded WETH", "html_url": "https://github.com/code-423n4/2021-10-ambire-findings/issues/54", "labels": ["bug", "sponsor confirmed", "1 (Low Risk)", "resolved"], "target": "2021-10-ambire-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact WETH address is hardcoded but it may differ on other chains, e.g. Polygon, so make sure to check this before deploying and update if neccessary:   address constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;  ## Recommended Mitigation Steps You should consider injecting WETH address via the constructor.  "}, {"title": "lack of require message", "html_url": "https://github.com/code-423n4/2021-10-ambire-findings/issues/53", "labels": ["bug", "sponsor confirmed", "0 (Non-critical)", "resolved"], "target": "2021-10-ambire-findings", "body": "lack of require message"}, {"title": "use of floating pragma", "html_url": "https://github.com/code-423n4/2021-10-ambire-findings/issues/51", "labels": ["bug", "sponsor confirmed", "0 (Non-critical)", "resolved"], "target": "2021-10-ambire-findings", "body": "use of floating pragma"}, {"title": "No account existence check for low-level call", "html_url": "https://github.com/code-423n4/2021-10-ambire-findings/issues/48", "labels": ["bug", "invalid", "sponsor disputed", "1 (Low Risk)"], "target": "2021-10-ambire-findings", "body": "No account existence check for low-level call"}, {"title": "Adding unchecked directive can save gas", "html_url": "https://github.com/code-423n4/2021-10-ambire-findings/issues/46", "labels": ["bug", "sponsor acknowledged", "G (Gas Optimization)", "resolved"], "target": "2021-10-ambire-findings", "body": "Adding unchecked directive can save gas"}, {"title": "Inconsistent code style of for loops", "html_url": "https://github.com/code-423n4/2021-10-ambire-findings/issues/45", "labels": ["bug", "sponsor confirmed", "0 (Non-critical)", "resolved"], "target": "2021-10-ambire-findings", "body": "# Handle  WatchPug   # Vulnerability details  Most of the for loops in the codebase use `<` to control the loop:  ```solidity for (uint i=0; i<len; i++) { ```  However, in `Zapper.sol`, all 7 for loops are using `!=`:  https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/wallet/Zapper.sol#L79-L79  ```solidity for (uint i=0; i!=spenders.length; i++) { ```  https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/wallet/Zapper.sol#L87-L87   https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/wallet/Zapper.sol#L110-L110  https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/wallet/Zapper.sol#L126-L126  https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/wallet/Zapper.sol#L131-L131  Using `for (uint i=0; i!=len; i++) {}` to control for loops introduces inconsistent code style.  ### Recommendation  Change from `!=` to `<` for all for loops.  "}, {"title": "Gas: `SignatureValidatorV2.recoverAddrImpl` should use `else if`", "html_url": "https://github.com/code-423n4/2021-10-ambire-findings/issues/42", "labels": ["bug", "sponsor confirmed", "G (Gas Optimization)", "resolved"], "target": "2021-10-ambire-findings", "body": "# Handle  cmichel   # Vulnerability details  The `SignatureValidatorV2.recoverAddrImpl` function currently uses three `if (mode == *)` checks but the modes are all distinct enum values and therefore an `else if` can be used. This is more efficient because if the first branch is already matched, there's no need to check the `mode` against the remaining values anymore.  "}, {"title": "Gas: `BytesLib` addition can be unchecked", "html_url": "https://github.com/code-423n4/2021-10-ambire-findings/issues/41", "labels": ["bug", "sponsor confirmed", "G (Gas Optimization)", "resolved"], "target": "2021-10-ambire-findings", "body": "# Handle  cmichel   # Vulnerability details  The `index += 32` addition in `readBytes32` can be put in an `unsafe` block as the array length is already checked to be greater than the addition.  "}, {"title": "QuickAccManager Smart Contract signature verification can be exploited", "html_url": "https://github.com/code-423n4/2021-10-ambire-findings/issues/40", "labels": ["bug", "sponsor confirmed", "3 (High Risk)", "resolved"], "target": "2021-10-ambire-findings", "body": "# Handle  cmichel   # Vulnerability details  Several different signature modes can be used and `Identity.execute` forwards the `signature` parameter to the `SignatureValidator` library. The returned `signer` is then used for the `privileges` check:  ```solidity address signer = SignatureValidator.recoverAddrImpl(hash, signature, true); // signer will be QuickAccountContract require(privileges[signer] != bytes32(0), 'INSUFFICIENT_PRIVILEGE'); ```  It's possible to create a smart contract mode signature (`SignatureMode.SmartWallet`) for arbitrary transactions as the `QuickAccManager.isValidSignature` uses an attacker-controlled `id` identity contract for the privileges check. An attacker can just create an attacker contract returning the desired values and the smart-wallet signature appears to be valid:  ```solidity // @audit id is attacker-controlled (address payable id, uint timelock, bytes memory sig1, bytes memory sig2) = abi.decode(signature, (address, uint, bytes, bytes)); // @audit this may not be used for authorization, attacker can return desired value if (Identity(id).privileges(address(this)) == accHash) {   // bytes4(keccak256(\"isValidSignature(bytes32,bytes)\")   return 0x1626ba7e; } else {   return 0xffffffff; } ```  ## POC  Assume an `Identity` contract is set up with a `QuickAccManager` as the `privileges` account, i.e. `privileges[accHash] != 0`.  We can construct a `SignatureMode.SmartWallet` signature for an _arbitrary_ hash: 1. Call `Identity.execute(txns, spoofedSignature)` where `spoofedSignature = abi.encode(attackerContract, timelock=0, sig1=0, sig2=0, address(quickAccountManager), SignatureMode.SmartWallet)` 2. This will call `recoverAddrImpl(txnsHash, spoofedSignature, true)`, decode the bytes **at the end** of `spoofedSignature` and determine `mode = SignatureMode.SmartWallet` and `wallet = quickAccountManager`. It will cut off these arguments and call `quickAccountManager.isValidSignature(txnsHash, (attackerContract, 0, 0, 0))` 3. The `QuickAccManager` will decode the signature, construct `accHash` which is the hash of all zeroes (due to failed signatures returning 0). It will then call `attacker.privileges(address(this))` and the attacker contract can return the `accHash` that matches an account hash of failed signatures, i.e., `keccak256(abi.encode(QuickAccount(0,0,0)))`. The comparison is satisfied and it returns the success value. 4. The checks in `Identity.execute` pass and the transactions `txns` are executed.  ## Impact Any `Identity` contract using `QuickAccManager` can be exploited. Funds can then be stolen from the wallet.  ## Recommendation The issue is that `QuickAccManager` blindly trusts the values in `signature`. It might be enough to remove the `id` from the `signature` and use `msg.sender` as the identity instead: `Identity(msg.sender).privileges(address(this)) == accHash`. This seems to work with the current `Identity` implementation but might not work if this is extended and the `isValidSignature` is called from another contract and wants to verify a signature on a different identity. In that case, the `Identity/SignatureValidator` may not blindly forward the attacker-supplied signature and instead needs to re-encode the parameters with trusted values before calling `QuickAccManager`.   "}, {"title": "Signature replay attacks for different identities (nonce on wrong party)", "html_url": "https://github.com/code-423n4/2021-10-ambire-findings/issues/39", "labels": ["bug", "duplicate", "sponsor confirmed", "3 (High Risk)", "resolved"], "target": "2021-10-ambire-findings", "body": "# Handle  cmichel   # Vulnerability details  A single `QuickAccount` can serve as the \"privilege\" for multiple identities, see the comment in `QuickAccManager.sol`:  > NOTE: a single accHash can control multiple identities, as long as those identities set it's hash in privileges[address(this)]. this is by design  If there exist two different identities that _both share the same QuickAccount_ (`identity1.privileges(address(this)) == identity2.privileges(address(this)) == accHash`) the following attack is possible in `QuickAccManager.send`:  Upon observing a valid `send` on the first identity, the same transactions can be replayed on the second identity by an attacker by calling `send` with the same arguments and just changing the `identity` to the second identity.  This is because the `identity` is not part of the `hash`. Including the **nonce of** the identity in the hash is not enough.  Two fresh identities will both take on nonces on zero and lead to the same hash.  ## Impact Transactions on one identity can be replayed on another one if it uses the same `QuickAccount`. For example, a transaction paying a contractor can be replayed by the contract on the second identity earning the payment twice.  ## Recommended Mitigation Steps 1. Nonces should not be indexed by the identity but by the `accHash`. This is because nonces are used to stop replay attacks and thus need to be on the _signer_ (`QuickAccount` in this case), not on the target contract to call. 2. The `identity` _address_ itself needs to be part of `hash` as otherwise the `send` can be frontrun and executed by anyone on the other identity by switching out the `identity` parameter.  ## Other occurrences This issue of using the wrong nonce (on the `identity` which means the nonces repeat per identity) and not including `identity` address leads to other attacks throughout the `QuickAccManager`: - `cancel`: attacker can use the same signature to cancel the same transactions on the second identity - `execScheduled`: can frontrun this call and execute it on the second identity instead. This will make the original transaction fail as `scheduled[hash]` is deleted. - `sendTransfer`: same transfers can be replayed on second identity - `sendTxns`: same transactions can be replayed on second identity   "}, {"title": "No check for signature malleability", "html_url": "https://github.com/code-423n4/2021-10-ambire-findings/issues/38", "labels": ["bug", "sponsor acknowledged", "0 (Non-critical)", "resolved"], "target": "2021-10-ambire-findings", "body": "No check for signature malleability"}, {"title": "If zero address is added as privilege anyone can execute arbitrary transactions", "html_url": "https://github.com/code-423n4/2021-10-ambire-findings/issues/37", "labels": ["bug", "sponsor confirmed", "1 (Low Risk)", "resolved"], "target": "2021-10-ambire-findings", "body": "# Handle  cmichel   # Vulnerability details  The `SignatureValidator.recoverAddrImpl` function does not revert on invalid signatures and returns zero instead. Thus if anyone added the zero address to their `privileges` by accident, funds can be stolen in `Identity.execute`.  ## Recommended Mitigation Steps Unless there's a valid reason for the `SignatureMode.NoSig` mode, consider reverting if `ecrecover` returns the zero address indicating an invalid signature.   "}, {"title": "`Identity` fallback returns too many bytes", "html_url": "https://github.com/code-423n4/2021-10-ambire-findings/issues/36", "labels": ["bug", "sponsor acknowledged", "0 (Non-critical)", "resolved"], "target": "2021-10-ambire-findings", "body": "`Identity` fallback returns too many bytes"}, {"title": "No ERC20 safe* versions called & no return values checked", "html_url": "https://github.com/code-423n4/2021-10-ambire-findings/issues/35", "labels": ["bug", "duplicate", "sponsor acknowledged", "disagree with severity", "0 (Non-critical)", "resolved"], "target": "2021-10-ambire-findings", "body": "No ERC20 safe* versions called & no return values checked"}, {"title": "`Zapper` only works for whitelisted tokens", "html_url": "https://github.com/code-423n4/2021-10-ambire-findings/issues/33", "labels": ["bug", "sponsor disputed", "0 (Non-critical)"], "target": "2021-10-ambire-findings", "body": "`Zapper` only works for whitelisted tokens"}, {"title": "`Zapper` should safeApprove(0) first", "html_url": "https://github.com/code-423n4/2021-10-ambire-findings/issues/32", "labels": ["bug", "sponsor acknowledged", "1 (Low Risk)", "resolved"], "target": "2021-10-ambire-findings", "body": "`Zapper` should safeApprove(0) first"}, {"title": "`QuickAccManager.sol` Constants should be marked as `constant`", "html_url": "https://github.com/code-423n4/2021-10-ambire-findings/issues/31", "labels": ["bug", "sponsor confirmed", "G (Gas Optimization)", "resolved"], "target": "2021-10-ambire-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/wallet/QuickAccManager.sol#L128-L128  The variables `TRANSFER_TYPEHASH`, `TXNS_TYPEHASH`, `BUNDLE_TYPEHASH` are named in all caps, which implies that they are constants. However, they are not being marked as `constant`. Mark them as `constant` can also help save some gas.  "}, {"title": "Cache storage variables in the stack can save gas", "html_url": "https://github.com/code-423n4/2021-10-ambire-findings/issues/30", "labels": ["bug", "sponsor confirmed", "G (Gas Optimization)", "resolved"], "target": "2021-10-ambire-findings", "body": "Cache storage variables in the stack can save gas"}, {"title": "Unnecessary storage variables", "html_url": "https://github.com/code-423n4/2021-10-ambire-findings/issues/29", "labels": ["bug", "sponsor confirmed", "G (Gas Optimization)", "resolved"], "target": "2021-10-ambire-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/wallet/Zapper.sol#L69-L72  Some storage variables include `admin`, `lendingPool` and `aaveRefCode` are unnecessary as they will never be changed.  Change to `immutable` can save gas.  "}, {"title": "`Zapper.sol#tradeV3Single()` Remove unnecessary variable can make the code simpler and save gas", "html_url": "https://github.com/code-423n4/2021-10-ambire-findings/issues/28", "labels": ["bug", "sponsor confirmed", "G (Gas Optimization)", "resolved"], "target": "2021-10-ambire-findings", "body": "# Handle  WatchPug   # Vulnerability details  At L149, `params.recipient` is read and put into a local variable `recipient`. However, `recipient` is only read once when `wrapOutputToLending` is true. Thus, the variable `recipient` is unnecessary.  https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/wallet/Zapper.sol#L147-L159  ```solidity=147 function tradeV3Single(ISwapRouter uniV3Router, ISwapRouter.ExactInputSingleParams calldata params, bool wrapOutputToLending) external returns (uint) {     ISwapRouter.ExactInputSingleParams memory tradeParams = params;     address recipient = params.recipient;     if(wrapOutputToLending) {         tradeParams.recipient = address(this);     }      uint amountOut = uniV3Router.exactInputSingle(tradeParams);     if(wrapOutputToLending) {         lendingPool.deposit(params.tokenOut, amountOut, recipient, aaveRefCode);     }     return amountOut; } ```  ### Recommendation  Change to:  ```solidity=147 function tradeV3Single(ISwapRouter uniV3Router, ISwapRouter.ExactInputSingleParams calldata params, bool wrapOutputToLending) external returns (uint) {     ISwapRouter.ExactInputSingleParams memory tradeParams = params;     if(wrapOutputToLending) {         tradeParams.recipient = address(this);     }      uint amountOut = uniV3Router.exactInputSingle(tradeParams);     if(wrapOutputToLending) {         lendingPool.deposit(params.tokenOut, amountOut, params.recipient, aaveRefCode);     }     return amountOut; } ```  "}, {"title": "`Zapper.sol#wrapETH()` Use `WETH.deposit` can save some gas", "html_url": "https://github.com/code-423n4/2021-10-ambire-findings/issues/27", "labels": ["bug", "sponsor confirmed", "G (Gas Optimization)", "resolved"], "target": "2021-10-ambire-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/wallet/Zapper.sol#L137-L140  ```solidity function wrapETH() payable external {     // TODO: it may be slightly cheaper to call deposit() directly     payable(WETH).transfer(msg.value); } ```  ### Recommendation  Change to:  ```solidity interface IWETH {     function deposit() external payable; } function wrapETH() payable external {     IWETH(WETH).deposit{ value: msg.value }(); } ```  "}, {"title": "Cache array length in for loops can save gas", "html_url": "https://github.com/code-423n4/2021-10-ambire-findings/issues/26", "labels": ["bug", "sponsor confirmed", "G (Gas Optimization)", "resolved"], "target": "2021-10-ambire-findings", "body": "Cache array length in for loops can save gas"}, {"title": "`QuickAccManager.sol#send()` Avoid unnecessary read from storage can save gas", "html_url": "https://github.com/code-423n4/2021-10-ambire-findings/issues/25", "labels": ["bug", "sponsor confirmed", "G (Gas Optimization)", "resolved"], "target": "2021-10-ambire-findings", "body": "# Handle  WatchPug   # Vulnerability details  In `QuickAccManager.sol#send()`, `nonces[address(identity)]` is being read 2 times (1st at L58, 2nd at L64), the second read is unnecessary, cache it in the stack at the first read can save some gas.  https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/wallet/QuickAccManager.sol#L55-L67  ```solidity=55{58,64} function send(Identity identity, QuickAccount calldata acc, DualSig calldata sigs, Identity.Transaction[] calldata txns) external {     bytes32 accHash = keccak256(abi.encode(acc));     require(identity.privileges(address(this)) == accHash, 'WRONG_ACC_OR_NO_PRIV');     uint initialNonce = nonces[address(identity)];     // Security: we must also hash in the hash of the QuickAccount, otherwise the sig of one key can be reused across multiple accs     bytes32 hash = keccak256(abi.encode(         address(this),         block.chainid,         accHash,         nonces[address(identity)]++,         txns,         sigs.isBothSigned     )); ```  ### Recommendation  Change to:  ```solidity=55{58,64} function send(Identity identity, QuickAccount calldata acc, DualSig calldata sigs, Identity.Transaction[] calldata txns) external {     bytes32 accHash = keccak256(abi.encode(acc));     require(identity.privileges(address(this)) == accHash, 'WRONG_ACC_OR_NO_PRIV');     uint initialNonce = nonces[address(identity)]++;     // Security: we must also hash in the hash of the QuickAccount, otherwise the sig of one key can be reused across multiple accs     bytes32 hash = keccak256(abi.encode(         address(this),         block.chainid,         accHash,         initialNonce,         txns,         sigs.isBothSigned     )); ```  "}, {"title": "Assignment Of Variable To Default (Identity.sol)", "html_url": "https://github.com/code-423n4/2021-10-ambire-findings/issues/17", "labels": ["bug", "sponsor confirmed", "G (Gas Optimization)", "resolved"], "target": "2021-10-ambire-findings", "body": "# Handle  ye0lde   # Vulnerability details  ## Impact  A variable is being assigned its default value which is unnecessary. Removing the assignment will save gas when deploying.  ## Proof of Concept  https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/Identity.sol#L9  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps Remove the assignment.  "}, {"title": "Long Revert Strings", "html_url": "https://github.com/code-423n4/2021-10-ambire-findings/issues/16", "labels": ["bug", "sponsor confirmed", "G (Gas Optimization)", "resolved"], "target": "2021-10-ambire-findings", "body": "Long Revert Strings"}, {"title": "Compare with 0 and 1 in a more efficient way", "html_url": "https://github.com/code-423n4/2021-10-ambire-findings/issues/15", "labels": ["bug", "sponsor confirmed", "G (Gas Optimization)", "resolved"], "target": "2021-10-ambire-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact In the function setAddrPrivilege of Identity.sol the value of privileges[addr] is compare to 0 and 1 in the following way: \"if (privileges[addr] != bytes32(0) && privileges[addr] != bytes32(uint(1)))\"  As 0 and 1 are adjacent, you could also check \"uint(privileges[addr]) > 1\". This saves a (small amount) of gas.  ## Proof of Concept https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/Identity.sol#L59  ## Tools Used  ## Recommended Mitigation Steps replace if (privileges[addr] != bytes32(0) && privileges[addr] != bytes32(uint(1))) ... with if (uint(privileges[addr]) > 1) ...  "}, {"title": "Safe some gas on the nonce increment", "html_url": "https://github.com/code-423n4/2021-10-ambire-findings/issues/14", "labels": ["bug", "sponsor acknowledged", "G (Gas Optimization)", "resolved"], "target": "2021-10-ambire-findings", "body": "Safe some gas on the nonce increment"}, {"title": "Prevent execution with invalid signatures", "html_url": "https://github.com/code-423n4/2021-10-ambire-findings/issues/13", "labels": ["bug", "duplicate", "sponsor confirmed", "disagree with severity", "3 (High Risk)", "resolved"], "target": "2021-10-ambire-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact Suppose one of the supplied addrs[i] to the constructor of Identity.sol happens to be 0 ( by accident).  In that case: privileges[0] = 1  Now suppose you call execute() with an invalid signature, then recoverAddrImpl will return a value of 0 and thus signer=0. If you then check \"privileges[signer] !=0\"  this will be true and anyone can perform any transaction.  This is clearly an unwanted situation.  ## Proof of Concept https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/Identity.sol#L23-L30  https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/Identity.sol#L97-L98  ## Tools Used  ## Recommended Mitigation Steps In the constructor of Identity.sol, add in the for loop the following: require (addrs[i] !=0,\"Zero not allowed\");  "}, {"title": "Some code is commented out", "html_url": "https://github.com/code-423n4/2021-10-ambire-findings/issues/11", "labels": ["bug", "sponsor acknowledged", "0 (Non-critical)", "resolved"], "target": "2021-10-ambire-findings", "body": "Some code is commented out"}, {"title": "IdentityFactory.withdraw can be external", "html_url": "https://github.com/code-423n4/2021-10-ambire-findings/issues/10", "labels": ["bug", "sponsor confirmed", "G (Gas Optimization)", "resolved"], "target": "2021-10-ambire-findings", "body": "# Handle  loop   # Vulnerability details  The `withdraw` function in `IdentityFactory.sol` is declared as public but can be external since it is not used internally.  ## Impact Saves some gas in case it ever needs to be called.  ## Proof of Concept https://github.com/code-423n4/2021-10-ambire/blob/main/contracts/IdentityFactory.sol#L52  "}, {"title": "Set `QuickAccManager::CANCEL_PREFIX` as constant", "html_url": "https://github.com/code-423n4/2021-10-ambire-findings/issues/7", "labels": ["bug", "sponsor confirmed", "G (Gas Optimization)", "resolved"], "target": "2021-10-ambire-findings", "body": "# Handle  pmerkleplant   # Vulnerability details  ## Impact Variable `CANCEL_PREFIX` in the `QuickAccManager` is never reset after initialization. Declaring it as a constant saves gas.  "}, {"title": "Set `IdentityFactory::creator` as immutable", "html_url": "https://github.com/code-423n4/2021-10-ambire-findings/issues/6", "labels": ["bug", "sponsor confirmed", "G (Gas Optimization)", "resolved"], "target": "2021-10-ambire-findings", "body": "# Handle  pmerkleplant   # Vulnerability details  ## Impact Variable `creator` in the `IdentityFactory` is never reset after initialization in the constructor. Declaring it as immutable saves gas.  "}, {"title": "Set `QuickAccManager::DOMAIN_SEPARATOR` as immutable", "html_url": "https://github.com/code-423n4/2021-10-ambire-findings/issues/4", "labels": ["bug", "sponsor confirmed", "G (Gas Optimization)", "resolved"], "target": "2021-10-ambire-findings", "body": "# Handle  pmerkleplant   # Vulnerability details  ## Impact Variable `DOMAIN_SEPARATOR` in the `QuickAccManager` is never reset after initialization in the constructor. Declaring it as immutable saves gas.  "}, {"title": "Address with privilege for QuickAccount with `address(0)`'s can execute arbitrary transactions", "html_url": "https://github.com/code-423n4/2021-10-ambire-findings/issues/3", "labels": ["bug", "sponsor confirmed", "disagree with severity", "1 (Low Risk)", "resolved"], "target": "2021-10-ambire-findings", "body": "# Handle  pmerkleplant   # Vulnerability details  ## Impact If a caller has privileges for a QuickAccount consisting of two `address(0)`'s, then the caller can execute arbitrary transactions through the  `QuicAccManager::send()` function.  ## Proof of Concept A caller of the `QuickAccManager::send()` needs to be privileged for the  QuickAccount the caller provides as argument ([line 57](https://github.com/code-423n4/2021-10-ambire/blob/main/contracts/wallet/QuickAccManager.sol#L57)).  As an arbitrary value can be set as `privileged[caller]` in `Indentity.sol`, so can a QuickAccount struct consisting of two `address(0)`'s.  The following calls to `SignatureValidator::recoverAddr()` (line 69, 70 and 73) can be made to always return `address(0)` if the signature has  `SignatureMode.NoSig`.  As the signature is provided as argument in `QuickAccManager::send()`, the  caller has total control of it.  The checks in line [69, 70](https://github.com/code-423n4/2021-10-ambire/blob/main/contracts/wallet/QuickAccManager.sol#L69) and [73](https://github.com/code-423n4/2021-10-ambire/blob/main/contracts/wallet/QuickAccManager.sol#L73) now always pass as long as the accounts in the QuickAccount struct are  `address(0)` too.  Therefore, a caller with permissions for such a QuickAccount can execute and  schedule arbitrary transactions without the need for valid signatures.  ## Tools Used -  ## Recommended Mitigation Steps Add a check in the `QuickAccManager::send()` function to forbid  QuickAccounts with `address(0)`.  "}, {"title": "`QuickAccManager.sol#cancel()` Wrong `hashTx` makes it impossible to cancel a scheduled transaction", "html_url": "https://github.com/code-423n4/2021-10-ambire-findings/issues/1", "labels": ["bug", "sponsor confirmed", "3 (High Risk)", "resolved"], "target": "2021-10-ambire-findings", "body": "# Handle  WatchPug   # Vulnerability details  In `QuickAccManager.sol#cancel()`, the `hashTx` to identify the transaction to be canceled is wrong. The last parameter is missing.  As a result, users will be unable to cancel a scheduled transaction.  https://github.com/code-423n4/2021-10-ambire/blob/bc01af4df3f70d1629c4e22a72c19e6a814db70d/contracts/wallet/QuickAccManager.sol#L91-L91  ```solidity=81{91} function cancel(Identity identity, QuickAccount calldata acc, uint nonce, bytes calldata sig, Identity.Transaction[] calldata txns) external {     bytes32 accHash = keccak256(abi.encode(acc));     require(identity.privileges(address(this)) == accHash, 'WRONG_ACC_OR_NO_PRIV');      bytes32 hash = keccak256(abi.encode(CANCEL_PREFIX, address(this), block.chainid, accHash, nonce, txns, false));     address signer = SignatureValidator.recoverAddr(hash, sig);     require(signer == acc.one || signer == acc.two, 'INVALID_SIGNATURE');      // @NOTE: should we allow cancelling even when it's matured? probably not, otherwise there's a minor grief     // opportunity: someone wants to cancel post-maturity, and you front them with execScheduled     bytes32 hashTx = keccak256(abi.encode(address(this), block.chainid, accHash, nonce, txns));     require(scheduled[hashTx] != 0 && block.timestamp < scheduled[hashTx], 'TOO_LATE');     delete scheduled[hashTx];      emit LogCancelled(hashTx, accHash, signer, block.timestamp); } ```  ### Recommendation  Change to:  ```solidity bytes32 hashTx = keccak256(abi.encode(address(this), block.chainid, accHash, nonce, txns, false)); ```  "}, {"title": "Math's operations order in Swivel's functions", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/162", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-swivel-findings", "body": "# Handle  0xsanson   # Vulnerability details  ## Impact There are multiple instances of divisions performed before multiplications, whereas the opposite is generally suggested. To mitigate the precision loss, a factor like `1e18` is multiplied and then divided, but this solution is arbitrary and can be avoided.  For example: ```js uint256 principalFilled = (((a * 1e18) / o.premium) * o.principal) / 1e18; ```  can be rewritten like: ```js uint256 principalFilled = a * o.principal / o.premium; ```  ## Proof of Concept Run `grep '1e18' Swivel.sol` for a complete list.  ## Tools Used grep, editor  ## Recommended Mitigation Steps Suggested checking all instances and trying to simplify the math.  "}, {"title": "Better Math in `calculateReturn`", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/161", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-swivel-findings", "body": "# Handle  0xsanson   # Vulnerability details  ## Impact `Marketplace.calculateReturn` can be rewritten from: ```js function calculateReturn(address u, uint256 m, uint256 a) internal returns (uint256) {   // calculate difference between the cToken exchange rate @ maturity and the current cToken exchange rate   uint256 yield = ((CErc20(markets[u][m].cTokenAddr).exchangeRateCurrent() * 1e26) / maturityRate[u][m]) - 1e26;   uint256 interest = (yield * a) / 1e26;    // calculate the total amount of underlying principle to return   return a + interest; } ```  to: ```js function calculateReturn(address u, uint256 m, uint256 a) internal returns (uint256) {   uint256 rate = CErc20(markets[u][m].cTokenAddr).exchangeRateCurrent();   return  a*rate/ maturityRate[u][m]; } ```  Less math operations means less approximations and less gas used.  ## Proof of Concept https://github.com/Swivel-Finance/gost/blob/v2/test/marketplace/MarketPlace.sol#L160-L167  ## Tools Used editor  "}, {"title": "balanceOf should be a _view_ function", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/157", "labels": ["bug", "duplicate", "0 (Non-critical)", "disagree with severity"], "target": "2021-09-swivel-findings", "body": "balanceOf should be a _view_ function"}, {"title": "fee-on-transfer underlying can cause problems", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/156", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged", "disagree with severity"], "target": "2021-09-swivel-findings", "body": "fee-on-transfer underlying can cause problems"}, {"title": "Unsafe handling of underlying tokens", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/155", "labels": ["bug", "duplicate", "3 (High Risk)"], "target": "2021-09-swivel-findings", "body": "Unsafe handling of underlying tokens"}, {"title": "Style issues", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/153", "labels": ["bug", "duplicate", "0 (Non-critical)"], "target": "2021-09-swivel-findings", "body": "Style issues"}, {"title": "'matured' can be replaced by 'maturityRate' > 0", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/151", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-swivel-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact boolean flag 'matured' could be removed if you agree to accept maturityRate > 0 as a matured vault, basically replacing:   require(!matured, 'already matured'); with:   require(maturityRate == 0, 'already matured'); This would eliminate one storage variable and thus reduce gas usage. The risk is that exchangeRateCurrent can never be 0 as this would mean an immature state.  ## Recommended Mitigation Steps Consider getting rid of 'matured' as per suggestion.   "}, {"title": "Functions returning boolean", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/149", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-swivel-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact It is unclear why there are many functions that always return a boolean value of true. While this may be your agreed practice that you try to follow, it also incurs more gas consumption as the caller needs to receive and check these returned values.  ## Recommended Mitigation Steps If you want to optimize for gas, consider dropping return values for functions that actually do not need them.  "}, {"title": "'onlyAdmin' and 'onlySwivel' modifiers", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/148", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-swivel-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact Having both modifiers 'onlyAdmin' and 'onlySwivel' is not only more expensive but also misleading as these modifiers basically do the same job of checking an address against msg.sender.  ## Recommended Mitigation Steps Better have a generalized modifier, something like onlyAddress(address a), and re-use it with both admin and swivel:   modifier onlyAddress(address a) {     require(msg.sender == a, 'sender not authorized');     _;   }   onlyAddress(admin)   onlyAddress(swivel)  "}, {"title": "'mature' and 'maturityRate' do not need separate mappings", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/147", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged", "sponsor disputed"], "target": "2021-09-swivel-findings", "body": "'mature' and 'maturityRate' do not need separate mappings"}, {"title": "Can cancel the same order again", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/145", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-09-swivel-findings", "body": "Can cancel the same order again"}, {"title": "Underlying can be fetched from cToken", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/142", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "disagree with severity"], "target": "2021-09-swivel-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact When creating the market (function createMarket), you do not need to specify the address of underlying, it would be less error-prone to dynamically get this from cToken: https://github.com/compound-finance/compound-protocol/blob/master/contracts/CTokenInterfaces.sol#L254   ## Recommended Mitigation Steps While only the admin can create new markets, I think it would still be nice to algorithmically ensure that this underlying token belongs to this cToken and do not leave a chance for human errors.  "}, {"title": "Validations in setFee", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/137", "labels": ["bug", "duplicate", "1 (Low Risk)"], "target": "2021-09-swivel-findings", "body": "Validations in setFee"}, {"title": "Return value of transferNotionalFee", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/135", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged", "sponsor disputed"], "target": "2021-09-swivel-findings", "body": "Return value of transferNotionalFee"}, {"title": "Magic Number 1e26 would best replace by a constant in `VaultTracker`", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/131", "labels": ["bug", "duplicate", "0 (Non-critical)"], "target": "2021-09-swivel-findings", "body": "Magic Number 1e26 would best replace by a constant in `VaultTracker`"}, {"title": "The requires used in `p2pVaultExchange` `transferVaultNotional` in Marketplace.sol are not necessary", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/130", "labels": ["bug", "0 (Non-critical)"], "target": "2021-09-swivel-findings", "body": "The requires used in `p2pVaultExchange` `transferVaultNotional` in Marketplace.sol are not necessary"}, {"title": "Redundant `require` in Swivel.sol", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/129", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-swivel-findings", "body": "# Handle  GalloDaSballo   # Vulnerability details  ## Impact The line:     require(MarketPlace(marketPlace).p2pZcTokenExchange(o.underlying, o.maturity, o.maker, msg.sender, a), 'zcToken exchange failed');  in Swivel.sol https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/swivel/Swivel.sol#L171  Is checking for the return value of `MarketPlace.p2pZcTokenExchange`, however `p2pZcTokenExchange` will always return true or revert  As such the require is not necessary, and doesn't provide any additional guarantees.  ## Recommended Mitigation Steps  Replace `     require(MarketPlace(marketPlace).p2pZcTokenExchange(o.underlying, o.maturity, o.maker, msg.sender, a), 'zcToken exchange failed'); `  With  ` MarketPlace(marketPlace).p2pZcTokenExchange(o.underlying, o.maturity, o.maker, msg.sender, a) `  "}, {"title": "require(mPlace.custodialExit) in Swivel.sol is redundant", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/128", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-swivel-findings", "body": "# Handle  GalloDaSballo   # Vulnerability details  ## Impact The function `custodialExit` in Marketplace.sol: https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/marketplace/MarketPlace.sol#L194  Always returns true or reverts  In swivel.sol the check  `require(mPlace.custodialExit(o.underlying, o.maturity, o.maker, msg.sender, a), 'custodial exit failed'); ` will always pass, unless the function `custodialExit` reverts  This extra require is not necessary, and provides no additional guarantees as `custodialExit` will always return true or revert   ## Recommended Mitigation Steps Replace ` require(mPlace.custodialExit(o.underlying, o.maturity, o.maker, msg.sender, a), 'custodial exit failed'); `  With ` mPlace.custodialExit(o.underlying, o.maturity, o.maker, msg.sender, a) `  "}, {"title": "Swivel.sol - marketplace is an immutable address, yet is always casted to MarketPlace - store as MarketPlace to make code cleaner", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/125", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-09-swivel-findings", "body": "# Handle  GalloDaSballo   # Vulnerability details  ## Impact The variable `marketplace` in Swivel.sol https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/swivel/Swivel.sol#L21  is stored as an immutable address  However, every single instance of it's usage casts it to `MarketPlace`  Would recommend storing `marketplace` as `MarketPlace` to make the code cleaner   ## Recommended Mitigation Steps Replace `  address public immutable marketPlace; ` With `   Marketplace public immutable marketPlace; `  "}, {"title": "swivel and marketPlace contract does not implement the mechanisim to renounce the role of admin", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/119", "labels": ["bug", "duplicate", "1 (Low Risk)"], "target": "2021-09-swivel-findings", "body": "swivel and marketPlace contract does not implement the mechanisim to renounce the role of admin"}, {"title": "Bounded array lengths or checking gasleft will save gas from OOGs", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/116", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged", "sponsor confirmed"], "target": "2021-09-swivel-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Swivel initiate() and exit() functions accept unbounded arrays from users which may lead to OOG exceptions with insufficient gas sent in transaction.  ## Proof of Concept  https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/swivel/Swivel.sol#L55-L77  https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/swivel/Swivel.sol#L209-L234  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Bounding array lengths or checking gasleft are a good idea to reduce risk of OOG and save user\u2019s gas.  "}, {"title": "Avoiding initialization of loop index can save a little gas", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/115", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-swivel-findings", "body": "Avoiding initialization of loop index can save a little gas"}, {"title": "Converting fenominator to a static array will save storage slots and gas", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/114", "labels": ["bug", "duplicate", "G (Gas Optimization)"], "target": "2021-09-swivel-findings", "body": "Converting fenominator to a static array will save storage slots and gas"}, {"title": "+= can be replaced by =", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/113", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-swivel-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  to.notional += a  can be replaced by to.notional = a because to.notional = 0 in the else part. This will save a few MLOADs.  ## Proof of Concept  https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/vaulttracker/VaultTracker.sol#L189  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps  Replace to.notional += a  by to.notional = a  "}, {"title": " Input validation on amount > 0 will save gas", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/112", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-09-swivel-findings", "body": " Input validation on amount > 0 will save gas"}, {"title": "Removing redundant require() can save gas", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/111", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-swivel-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The require(matureMarket(u, m) is redundant because matureMarket always returns true and reverts if any of its require() check fails.  Removing this can save a little gas.  ## Proof of Concept  https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/marketplace/MarketPlace.sol#L127  https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/marketplace/MarketPlace.sol#L75-L91  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps  Remove redundant require()  "}, {"title": "Caching state variables in local/memory variables avoids SLOADs to save gas", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/110", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-swivel-findings", "body": "Caching state variables in local/memory variables avoids SLOADs to save gas"}, {"title": "Missing input validation, threshold check, event and timelock in setFee function", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/108", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-09-swivel-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  The setFee onlyAdmin function sets the fee denominator but does not perform input validation to check that the fenominator index is between 0-3 which are the only valid values for [zcTokenInitiate, zcTokenExit, vaultInitiate, vaultExit].  The onlyAdmin function performs no threshold check on the new values, emits no event and immediately changes the fenominator value to any arbitrary value proposed by the admin.  ## Proof of Concept  https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/swivel/Swivel.sol#L399-L405  https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/swivel/Swivel.sol#L23-L24  https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/swivel/Swivel.sol#L46  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps  Add input validation, threshold check, event and timelock  "}, {"title": "Missing input validation & event in emergency blockWithdrawal could be risky", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/107", "labels": ["bug", "duplicate", "1 (Low Risk)"], "target": "2021-09-swivel-findings", "body": "Missing input validation & event in emergency blockWithdrawal could be risky"}, {"title": "Missing input validation on array length match", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/105", "labels": ["bug", "duplicate", "1 (Low Risk)"], "target": "2021-09-swivel-findings", "body": "Missing input validation on array length match"}, {"title": "Compact signatures not being supported could lead to DoS", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/104", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged", "sponsor confirmed"], "target": "2021-09-swivel-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  This implementation of Sig.sol doesn\u2019t support compact signature (EIP-2098), where signature length can be 64 bytes instead of 65, as supported in the widely used OpenZeppelin\u2019s ECDSA library. This lack of support could lead to DoS for users/clients that use compact signatures.  ## Proof of Concept  https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/swivel/Sig.sol#L41  See https://github.com/OpenZeppelin/openzeppelin-contracts/blob/1b27c13096d6e4389d62e7b0766a1db53fbb3f1b/contracts/utils/cryptography/ECDSA.sol#L57  https://eips.ethereum.org/EIPS/eip-2098  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Consider adding support for compact signatures, use OZ ECDSA library or highlight in documentation about this lack of support for EIP-2098.  "}, {"title": "Missing input validation may cause revert due to underflow", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/102", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-09-swivel-findings", "body": "Missing input validation may cause revert due to underflow"}, {"title": "Missing event & timelock for critical onlyAdmin functions", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/101", "labels": ["bug", "2 (Med Risk)"], "target": "2021-09-swivel-findings", "body": "Missing event & timelock for critical onlyAdmin functions"}, {"title": "Missing zero-address checks", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/100", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-09-swivel-findings", "body": "Missing zero-address checks"}, {"title": "Use of ecrecover is susceptible to signature malleability", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/99", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "disagree with severity"], "target": "2021-09-swivel-findings", "body": "Use of ecrecover is susceptible to signature malleability"}, {"title": "Static chainID could allow replay attacks on chain splits", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/98", "labels": ["bug", "duplicate", "1 (Low Risk)"], "target": "2021-09-swivel-findings", "body": "Static chainID could allow replay attacks on chain splits"}, {"title": "Previously created markets can be overwritten", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/97", "labels": ["bug", "duplicate", "2 (Med Risk)"], "target": "2021-09-swivel-findings", "body": "Previously created markets can be overwritten"}, {"title": "Missing event and timelock for setSwivelAddress", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/96", "labels": ["bug", "duplicate", "1 (Low Risk)"], "target": "2021-09-swivel-findings", "body": "Missing event and timelock for setSwivelAddress"}, {"title": "Admin is a single-point of failure without any mitigations", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/95", "labels": ["bug", "duplicate", "2 (Med Risk)", "sponsor acknowledged"], "target": "2021-09-swivel-findings", "body": "Admin is a single-point of failure without any mitigations"}, {"title": "Missing guarded launch", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/94", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged", "disagree with severity"], "target": "2021-09-swivel-findings", "body": "Missing guarded launch"}, {"title": "Abstract contracts should really be interfaces", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/93", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-09-swivel-findings", "body": "# Handle  0xRajeev   # Vulnerability details  ## Impact  Interfaces are not allowed to define any functions while abstract contracts can have a few defined functions (with at least one undefined function). Abstract contracts declared in the project should really be interfaces because they do not define any functions.   Keeping them abstract is risky because they allow defining functions that may be mistakenly exposed in inherited contracts. Interfaces by design prevent this security risk.  ## Proof of Concept  https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/swivel/Abstracts.sol#L5-L40  ## Tools Used Manual Analysis  ## Recommended Mitigation Steps Convert contracts that do not define any functions to interfaces.  "}, {"title": "Different parameter used in  while emitting event", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/90", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "disagree with severity"], "target": "2021-09-swivel-findings", "body": "# Handle  JMukesh   # Vulnerability details  ## Impact In matureMarket(address u, uint256 m) function , different parameter is used in event      emit Mature(u, m, block.timestamp, currentExchangeRate);  maturity rate should before matured timestamp //   event Mature(address indexed underlying, uint256 indexed maturity, uint256 maturityRate, uint256 matured);  impact of this can be severe .   This   error   may   negatively   impact    off-chain   tools   that   are   monitoring   events data  ## Proof of Concept https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/marketplace/MarketPlace.sol#L88  ## Tools Used manual review  ## Recommended Mitigation Steps   "}, {"title": "Gas: Approve `cToken` address only once for underlying", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/87", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-swivel-findings", "body": "# Handle  cmichel   # Vulnerability details  The `Swivel` contract approves the `cToken` address whenever it wants to mint `cTokens` upon order fulfilment, see `initiateVaultFillingZcTokenInitiate`.  It could just approve the `cToken` contract once for each market underlying it supports with the max value and save the approval call for each order fulfilment.   "}, {"title": "Wrong yield computation upon maturity", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/85", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-09-swivel-findings", "body": "Wrong yield computation upon maturity"}, {"title": "Infinite mint by transferring nTokens to self", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/81", "labels": ["bug", "duplicate", "3 (High Risk)"], "target": "2021-09-swivel-findings", "body": "Infinite mint by transferring nTokens to self"}, {"title": "Lack of Pause Mechanism", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/76", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged", "sponsor disputed", "disagree with severity"], "target": "2021-09-swivel-findings", "body": "Lack of Pause Mechanism"}, {"title": "Potential Reentrancy when Initiating and Exiting Positions", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/75", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-09-swivel-findings", "body": "Potential Reentrancy when Initiating and Exiting Positions"}, {"title": "Swivel Markets are not Isolated", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/73", "labels": ["bug", "1 (Low Risk)", "sponsor disputed"], "target": "2021-09-swivel-findings", "body": "Swivel Markets are not Isolated"}, {"title": "Missing Dev Comments", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/71", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-09-swivel-findings", "body": "# Handle  leastwood   # Vulnerability details  ## Impact  The `cTokenAddress()` getter function in `MarketPlace.sol` is missing relevant dev comments and appropriate matching syntax. `address a` does not correctly match the proper representation which is the underlying token, typically referenced as `address u`.  ## Proof of Concept  https://github.com/Swivel-Finance/gost/blob/v2/test/marketplace/MarketPlace.sol#L169-L171  ## Tools Used  Manual code review  ## Recommended Mitigation Steps  Consider adding relevant dev comments and updating `address a` -> `address u` to better reflect its meaning.  "}, {"title": "Gas Savings Upon Market Creation", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/70", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-09-swivel-findings", "body": "Gas Savings Upon Market Creation"}, {"title": "Lack of Proper Revert Messages", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/68", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-09-swivel-findings", "body": "Lack of Proper Revert Messages"}, {"title": "Open TODOs in Codebase", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/67", "labels": ["bug", "duplicate", "1 (Low Risk)"], "target": "2021-09-swivel-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact There are TODOs left in the code. While this does not cause any direct issue, it indicates a bad smell and uncertainty. In previous reports, such submissions were assigned a score of 'low' so I think it's a fair game to submit this as an issue here also.  Reference: https://github.com/code-423n4/2021-09-swivel-findings/issues/67 https://github.com/code-423n4/2021-10-tempus-findings/issues/39  Also, there are some misleading comments, e.g.: ```solidity     /// @notice Internal update function to price, cap, and pay funding.     function update () public virtual returns ( ``` the comment says that function is internal but it is actually declared as public.  ## Recommended Mitigation Steps Consider implementing or removing TODOs and updating misleading comments.  "}, {"title": "transferNotionalFrom doesn't check from != to", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/65", "labels": ["bug", "duplicate", "3 (High Risk)", "sponsor confirmed"], "target": "2021-09-swivel-findings", "body": "# Handle  gpersoon   # Vulnerability details  # Impact The function transferNotionalFrom of VaultTracker.sol uses temporary variables to store the balances. If the \"from\" and \"to\" address are the same then the balance of \"from\" is overwritten by the balance of \"to\". This means the balance of \"from\" and \"to\" are increased and no balances are decreased, effectively printing money.  Note: transferNotionalFrom can be called via transferVaultNotional by everyone.  ## Proof of Concept https://github.com/Swivel-Finance/gost/blob/v2/test/vaulttracker/VaultTracker.sol#L144-L196   function transferNotionalFrom(address f, address t, uint256 a) external onlyAdmin(admin) returns (bool) {     Vault memory from = vaults[f];     Vault memory to = vaults[t];     ...     vaults[f] = from;     ...     vaults[t] = to;    // if f==t then this will overwrite vaults[f]    https://github.com/Swivel-Finance/gost/blob/v2/test/marketplace/MarketPlace.sol#L234-L238 function transferVaultNotional(address u, uint256 m, address t, uint256 a) public returns (bool) {     require(VaultTracker(markets[u][m].vaultAddr).transferNotionalFrom(msg.sender, t, a), 'vault transfer failed');     ## Tools Used  ## Recommended Mitigation Steps Add something like the following:    require (f != t,\"Same\");  "}, {"title": "Prevent underflow in require", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/62", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "sponsor disputed", "disagree with severity"], "target": "2021-09-swivel-findings", "body": "# Handle  gpersoon   # Vulnerability details  ## Impact The contract Swivel.sol contains a few of the following requires:  require(a <= (o.premium - filled[hash]), 'taker amount > available volume');    If \"o.premium\" happens to be smaller than \"filled[hash]\", a revert will occur at \"o.premium - filled[hash]\" and no error message will be displayed.  Also note the statements use slightly different syntax with the parentheses.   ## Proof of Concept Swivel.sol:    require(a <= (o.premium    - filled[hash]),  'taker amount > available volume'); Swivel.sol:    require((a <= o.principal  - filled[hash]),  'taker amount > available volume');  // slightly different syntax Swivel.sol:    require(a <= ((o.principal - filled[hash])), 'taker amount > available volume');  // slightly different syntax Swivel.sol:    require(a <= (o.premium    - filled[hash]),  'taker amount > available volume'); Swivel.sol:    require(a <= (o.premium    - filled[hash]),  'taker amount > available volume'); Swivel.sol:    require(a <= (o.principal  - filled[hash]),  'taker amount > available volume'); Swivel.sol:    require(a <= (o.principal  - filled[hash]),  'taker amount > available volume'); Swivel.sol:    require(a <= (o.premium    - filled[hash]),  'taker amount > available volume');  ## Tools Used  ## Recommended Mitigation Steps replace  require(a <= (o.xxxx - filled[hash]), 'taker amount > available volume');   with  require( (a + filled[hash]) <= o.xxxx), 'taker amount > available volume');  Use the same parentheses structure everywhere.  "}, {"title": "return value of 0 from ecrecover not checked", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/61", "labels": ["bug", "duplicate", "3 (High Risk)"], "target": "2021-09-swivel-findings", "body": "return value of 0 from ecrecover not checked"}, {"title": "Double Spending. No decreaseAllowance()/ IncreaseAllowance()", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/53", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged", "sponsor disputed"], "target": "2021-09-swivel-findings", "body": "Double Spending. No decreaseAllowance()/ IncreaseAllowance()"}, {"title": "Missing initial ownership event", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/49", "labels": ["bug", "0 (Non-critical)", "sponsor disputed", "disagree with severity"], "target": "2021-09-swivel-findings", "body": "Missing initial ownership event"}, {"title": "Sig.split function could be private instead internal.", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/44", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-swivel-findings", "body": "# Handle  pants   # Vulnerability details  The Sig.split function (defined at Line 40 of Sig library) is called only inside the library. Thus function could be set as private.  https://github.com/Swivel-Finance/gost/blob/v2/test/swivel/Sig.sol#L40  ## Recommended Mitigation Steps Make it private :)  ## Tool Used Manual code review.   "}, {"title": "Title: Double reading from calldata o", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/43", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "sponsor disputed"], "target": "2021-09-swivel-findings", "body": "# Handle  pants   # Vulnerability details  At both line 59 and 61 the code reads o[i]. It happens inside a loop therefore the best practice which is more gas efficient is to cache o[i] once and use it instead.  https://github.com/Swivel-Finance/gost/blob/v2/test/swivel/Swivel.sol#L59  ## Tool Used Manual code review.   "}, {"title": "Complex state variable copied to memory in redeemZcToken (MarketPlace.sol)", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/41", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-09-swivel-findings", "body": "# Handle  ye0lde   # Vulnerability details  ## Impact Operating on a copy of a state variable seems inefficient and confusing in this case.   From a \"gas\" standpoint it's less efficient.  And future changes could render the addresses in the copied struct invalid if functions being called in redeemZcToken operate on the original state variable.  ## Proof of Concept The copy occurs here: https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/marketplace/MarketPlace.sol#L123  The \"mkt\" variable is referenced here: https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/marketplace/MarketPlace.sol#L131  ## Tools Used VS Code  ## Recommended Mitigation Steps Remove line #123: https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/marketplace/MarketPlace.sol#L123  Replace \"mkt\" with \"markets[u][m]\" in line #131 https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/marketplace/MarketPlace.sol#L131   "}, {"title": "Swivel: Taker is charged fees twice in exitVaultFillingVaultInitiate", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/39", "labels": ["bug", "3 (High Risk)", "sponsor confirmed"], "target": "2021-09-swivel-findings", "body": "# Handle  itsmeSTYJ   # Vulnerability details  ## Impact  Taker is charged fees twice in `exitVaultFillingVaultInitiate()` . Maker is transferring less than premiumFilled to taker and then taker is expected to pay fees i.e. taker's net balance is premiumFilled - 2*fee  ## Recommended Mitigation Steps  ```jsx function exitVaultFillingVaultInitiate(Hash.Order calldata o, uint256 a, Sig.Components calldata c) internal {     bytes32 hash = validOrderHash(o, c);      require(a <= (o.principal - filled[hash]), 'taker amount > available volume');          filled[hash] += a;              uint256 premiumFilled = (((a * 1e18) / o.principal) * o.premium) / 1e18;     uint256 fee = ((premiumFilled * 1e18) / fenominator[3]) / 1e18;      Erc20 uToken = Erc20(o.underlying);     // transfer premium from maker to sender     uToken.transferFrom(o.maker, msg.sender, premiumFilled);      // transfer fee in underlying to swivel from sender     uToken.transferFrom(msg.sender, address(this), fee);      // transfer <a> vault.notional (nTokens) from sender to maker     require(MarketPlace(marketPlace).p2pVaultExchange(o.underlying, o.maturity, msg.sender, o.maker, a), 'vault exchange failed');      emit Exit(o.key, hash, o.maker, o.vault, o.exit, msg.sender, a, premiumFilled); } ```  "}, {"title": "Swivel: implementation for initiateZcTokenFillingZcTokenExit is incorrect", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/38", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-09-swivel-findings", "body": "# Handle  itsmeSTYJ   # Vulnerability details  ## Impact  In `initiateZcTokenFillingZcTokenExit()` , this comment `// transfer underlying tokens - the premium paid + fee in underlying to swivel (from sender)`  is incorrect because you are actually transferring the underlying tokens - premium paid to the maker (from sender) AND you have to pay fee separately to swivel.  initiateZCTokenFillingZcTokenExit means I want to sell my nTokens so that means `a` is the amount of principal I want to fill. Let's use a hypothetical example where I (taker) wants to fill 10 units of ZcTokenExit for maker.  1. I transfer 10 units of underlying to Swivel. The net balances are: me (-a), swivel (+a) 2. I transfer fee (in underlying) to Swivel. The net balances are: me (-a-fee), swivel (+a+fee)  3. Swivel initiates my position, sends me the ZcToken and sends Maker the nTokens 4. Maker pays me premiumFilled for the nTokens. The net balances are: me (-a-fee+premiumsFilled), swivel (+a+fee), maker (-premiumsFilled) 5. Maker closes position. The net balances are: me (-a-fee+premiumsFilled), swivel (+fee), maker (-premiumsFilled+a)  So effectively, I (taker) should be paying a-premium to maker and fee to swivel.  ## Recommended Mitigation Steps  ```jsx function initiateZcTokenFillingZcTokenExit(Hash.Order calldata o, uint256 a, Sig.Components calldata c) internal {     bytes32 hash = validOrderHash(o, c);      require(a <= o.principal - filled[hash]), 'taker amount > available volume'); // Note: you don't need to wrap these in brackets because if you look at the https://docs.soliditylang.org/en/latest/cheatsheet.html#order-of-precedence-of-operators, subtraction will always go before comparison       filled[hash] += a;      uint256 premiumFilled = (((a * 1e18) / o.principal) * o.premium) / 1e18;     uint256 fee = ((premiumFilled * 1e18) / fenominator[0]) / 1e18;      // transfer underlying tokens - the premium paid in underlying to maker (from sender)     Erc20(o.underlying).transferFrom(msg.sender, o.maker, a - premiumFilled);   Erc20(o.underlying).transferFrom(msg.sender, swivel, fee);     // transfer <a> zcTokens between users in marketplace     require(MarketPlace(marketPlace).p2pZcTokenExchange(o.underlying, o.maturity, o.maker, msg.sender, a), 'zcToken exchange failed');                  emit Initiate(o.key, hash, o.maker, o.vault, o.exit, msg.sender, a, premiumFilled); } ```  "}, {"title": "Swivel: Implement check effect interaction to align with best practices", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/37", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-09-swivel-findings", "body": "# Handle  itsmeSTYJ   # Vulnerability details  ## Impact  There is no impact to the funds but to align with [best practices]([https://fravoll.github.io/solidity-patterns/checks_effects_interactions.html](https://fravoll.github.io/solidity-patterns/checks_effects_interactions.html)), it is always better to update internal state before any external function calls.  ## Recommended Mitigation Steps  For functions `exitVaultFillingZcTokenExit()` and `exitZcTokenFillingVaultExit()`, you should do `mPlace.custodialExit(...)` to update the internal accounting before transferring the tokens out.  "}, {"title": "Swivel: Incorrect dev comments for the 4 initiate functions", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/35", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-09-swivel-findings", "body": "# Handle  itsmeSTYJ   # Vulnerability details  ## Impact  Misleading comments  ## Recommended Mitigation Steps  For these 4 functions, it should say \"taker's init\" instead of \"taker's exit\"  "}, {"title": "VaultTracker.sol: init sVault.exchangeRate in constructor", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/31", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-swivel-findings", "body": "# Handle  itsmeSTYJ   # Vulnerability details  ## Impact  Gas optimisation. In the function `transferNotionalFee()`,  `sVault.exchangeRate` is only 0 for the very first time this function is called so the if check to see if `sVault.exchangeRate != 0` is only used once to handle this edge case.  It makes more sense to set the exchangeRate when the vault is created and remove these if conditions.  ## Recommended Mitigation Steps  ```jsx constructor(uint256 m, address c, address s) {    admin = msg.sender;    maturity = m;    cTokenAddr = c;    swivel = s;   uint256 exchangeRate = CErc20(cTokenAddr).exchangeRateCurrent();   vault[swivel] = Vault({        notional: 0,        redeemable: 0,        exchangeRate: exchangeRate    }); } ... function transferNotionalFee(address f, uint256 a) external onlyAdmin(admin) returns(bool) {     Vault memory oVault = vaults[f];     Vault memory sVault = vaults[swivel];      // remove notional from its owner     oVault.notional -= a;      uint256 exchangeRate = CErc20(cTokenAddr).exchangeRateCurrent();     uint256 yield;     uint256 interest;      // check if exchangeRate has been stored already this block. If not, calculate marginal interest + store exchangeRate     if (sVault.exchangeRate != exchangeRate) {        // if market has matured, calculate marginal interest between the maturity rate and previous position exchange rate        // otherwise, calculate marginal exchange rate between current and previous exchange rate.        if (matured) {            // calculate marginal interest            yield = ((maturityRate * 1e26) / sVault.exchangeRate) - 1e26;        } else {            yield = ((exchangeRate * 1e26) / sVault.exchangeRate) - 1e26;        }          interest = (yield * sVault.notional) / 1e26;        sVault.redeemable += interest;       sVault.exchangeRate = exchangeRate;     }      // add notional to swivel's vault     sVault.notional += a;      // store the adjusted vaults     vaults[swivel] = sVault;     vaults[f] = oVault;     return true;   } ```  "}, {"title": "VaultTracker.sol: pass in exchangeRate as a variable to matureVault()", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/30", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-swivel-findings", "body": "# Handle  itsmeSTYJ   # Vulnerability details  ## Impact  Since you are already querying the exchangeRate for the current block in `MarketPlace.matureMarket()` , might as well pass it along to `VaultTracker.sol` instead of querying it a second time.  ## Recommended Mitigation Steps  ```jsx // In VaultTracker.sol function matureVault(uint256 _maturityRate) external onlyAdmin(admin) returns (bool) {    require(!matured, 'already matured');    require(block.timestamp >= maturity, 'maturity has not been reached');    matured = true;   maturityRate = _maturityRate;    return true; } ```  ```jsx // In MarketPlace.sol function matureMarket(address u, uint256 m) public returns (bool) {    require(!mature[u][m], 'market already matured');    require(block.timestamp >= ZcToken(markets[u][m].zcTokenAddr).maturity(), \"maturity not reached\");      // set the base maturity cToken exchange rate at maturity to the current cToken exchange rate    uint256 currentExchangeRate = CErc20(markets[u][m].cTokenAddr).exchangeRateCurrent();    maturityRate[u][m] = currentExchangeRate;    // set the maturity state to true (for zcb market)    mature[u][m] = true;      // set vault \"matured\" to true   require(VaultTracker(markets[u][m].vaultAddr).matureVault(currentExchangeRate), 'maturity not reached');      emit Mature(u, m, block.timestamp, currentExchangeRate);      return true; } ```  "}, {"title": "MarketPlace.sol: Remove maturity from VaultTracker and ZcToken", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/29", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged", "sponsor confirmed"], "target": "2021-09-swivel-findings", "body": "# Handle  itsmeSTYJ   # Vulnerability details  ## Impact  You don't need to store maturity in `VaultTracker.sol` or `ZcToken.sol` because `mapping (address => mapping (uint256 => bool)) public mature;` should already cover it. This will help to remove unnecessary external calls and also reduce the number of maturity checks.  ## Recommended Mitigation Steps  ```jsx // In MarketPlace.sol function createMarket(    address u,    uint256 m,    address c,    string memory n,    string memory s,    uint8 d ) public onlyAdmin(admin) returns (bool) {    require(swivel != address(0), 'swivel contract address not set');    // TODO can we live with the factory pattern here both bytecode size wise and CREATE opcode cost wise?   address zctAddr = address(new ZcToken(u, n, s, d));    address vAddr = address(new VaultTracker(c, swivel));    markets[u][m] = Market(c, zctAddr, vAddr);      emit Create(u, m, c, zctAddr, vAddr);      return true; } ... function matureMarket(address u, uint256 m) public returns (bool) {   require(block.timestamp >= m, \"maturity not reached\");    require(!mature[u][m], 'market already matured');      // set the base maturity cToken exchange rate at maturity to the current cToken exchange rate    uint256 currentExchangeRate = CErc20(markets[u][m].cTokenAddr).exchangeRateCurrent();    maturityRate[u][m] = currentExchangeRate;    // set the maturity state to true (for zcb market)    mature[u][m] = true;      // set vault \"matured\" to true    require(VaultTracker(markets[u][m].vaultAddr).matureVault(), 'maturity not reached');      emit Mature(u, m, block.timestamp, currentExchangeRate);      return true; } ```  ```jsx  // In VaultTracker.sol ... // uint256 public immutable maturity; // deleted this ... constructor(address c, address s) {    admin = msg.sender;    cTokenAddr = c;    swivel = s; } ... function matureVault() external onlyAdmin(admin) returns (bool) {    matured = true;    maturityRate = CErc20(cTokenAddr).exchangeRateCurrent();    return true; } ```  ```jsx // uint256 public immutable maturity; // deleted this ... constructor(address u, string memory n, string memory s, uint8 d) Erc2612(n, s, d) {    admin = msg.sender;    underlying = u; } ```  "}, {"title": "VaultTracker.sol: Gas optimisation for addNotional", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/28", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed", "sponsor disputed"], "target": "2021-09-swivel-findings", "body": "# Handle  itsmeSTYJ   # Vulnerability details  ## Impact  Gas op. Since vlt.notional has to be updated in both branches of the if check, you can take vlt.notional out of both branches and skip the else check.  ## Recommended Mitigation Steps  ```jsx function addNotional(address o, uint256 a) public onlyAdmin(admin) returns (bool) {   uint256 exchangeRate = CErc20(cTokenAddr).exchangeRateCurrent();   Vault memory vlt = vaults[o];      if (vlt.notional > 0) {      uint256 yield;      uint256 interest;          // if market has matured, calculate marginal interest between the maturity rate and previous position exchange rate      // otherwise, calculate marginal exchange rate between current and previous exchange rate.      if (matured) { // Calculate marginal interest         yield = ((maturityRate * 1e26) / vlt.exchangeRate) - 1e26;      } else {         yield = ((exchangeRate * 1e26) / vlt.exchangeRate) - 1e26;      }          interest = (yield * vlt.notional) / 1e26;      // add interest and amount to position, reset cToken exchange rate      vlt.redeemable += interest;       }      vlt.notional += a;   vlt.exchangeRate = exchangeRate;   vaults[o] = vlt;      return true; } ```  "}, {"title": "Use bytes32 rather than string/bytes", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/21", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-swivel-findings", "body": "# Handle  defsec   # Vulnerability details  ## Impact  If data can fit into 32 bytes, then you should use bytes32 datatype rather than bytes or strings as it is much cheaper in solidity. Basically, Any fixed size variable in solidity is cheaper than variable size. On the MarketPlace.sol contract, string memory variable can be replaced with bytes32 array. That will save gas on the contract.   ## Proof of Concept  1. Navigate to \"https://github.com/Swivel-Finance/gost/blob/v2/test/marketplace/MarketPlace.sol\" contract. 2. Investigate createMarket function. n and s variables can be replaced with bytes32 variable.  ```   function createMarket(     address u,     uint256 m,     address c,     string memory n,     string memory s,     uint8 d   ) public onlyAdmin(admin) returns (bool) {     require(swivel != address(0), 'swivel contract address not set');     // TODO can we live with the factory pattern here both bytecode size wise and CREATE opcode cost wise?     address zctAddr = address(new ZcToken(u, m, n, s, d));     address vAddr = address(new VaultTracker(m, c, swivel));     markets[u][m] = Market(c, zctAddr, vAddr);      emit Create(u, m, c, zctAddr, vAddr);      return true;   } ```  ## Tools Used  None  ## Recommended Mitigation Steps  Consider to replace string variables with bytes32. That should be definitely cheaper.   "}, {"title": "Return value of transferNotionalFee ignored", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/16", "labels": ["bug", "0 (Non-critical)", "sponsor disputed"], "target": "2021-09-swivel-findings", "body": "Return value of transferNotionalFee ignored"}, {"title": "Array .length Used Directly In For Loops", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/15", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-09-swivel-findings", "body": "# Handle  ye0lde   # Vulnerability details  ## Impact  There is additional gas usage when an array's length value is used directly in a \"for\" loop.  ## Proof of Concept  The array's length value is used directly in a for loop here: https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/swivel/Swivel.sol#L57 https://github.com/Swivel-Finance/gost/blob/5fb7ad62f1f3a962c7bf5348560fe88de0618bae/test/swivel/Swivel.sol#L211   ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps Change the loops above from: <code> for (uint256 i=0; i < o.length; i++) </code>  to <code> unit256 length = o.length; for (uint256 i=0; i < length; i++) </code>  When I tested these changes there was a small gas saving.   "}, {"title": "createMarket function missing parameter description", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/3", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "disagree with severity"], "target": "2021-09-swivel-findings", "body": "# Handle  loop   # Vulnerability details  the parameter `uint8 d` of the `createMarket` function is lacking a parameter description in function spec.    ## Impact No direct impact, but with the parameter naming scheme of only using the first letter of its description the parameter spec is essential.  ## Proof of Concept Code snippet for funciton spec + declaration: ``` /// @notice Allows the owner to create new markets /// @param u Underlying token address associated with the new market /// @param m Maturity timestamp of the new market /// @param c cToken address associated with underlying for the new market /// @param n Name of the new zcToken market /// @param s Symbol of the new zcToken market function createMarket(     address u,     uint256 m,     address c,     string memory n,     string memory s,     uint8 d ) public onlyAdmin(admin) returns (bool) ```  ## Recommended Mitigation Steps Add parameter spec for `uint8 d`  "}, {"title": "Wrong parameter name used in function spec", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/2", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed", "disagree with severity"], "target": "2021-09-swivel-findings", "body": "# Handle  loop   # Vulnerability details  Line 124 of Swivel.sol describes the parameter `uint256 a`, but has wrong parameter name: `/// @param o Amount of volume (principal) being filled by the taker's exit`  ## Impact No direct impact apart from code readability  ## Proof of Concept Code snippet for function declaration + spec: ``` /// @notice Allows a user to initiate a zcToken by filling an offline vault initiate order   /// @dev This method should pass (underlying, maturity, sender, maker, a) to MarketPlace.custodialInitiate   /// @param o Order being filled   /// @param o Amount of volume (principal) being filled by the taker's exit   /// @param c Components of a valid ECDSA signature   function initiateZcTokenFillingVaultInitiate(Hash.Order calldata o, uint256 a, Sig.Components calldata c) internal ```  ## Recommended Mitigation Steps Change the second `o` to `a`  "}, {"title": "Bytes constant more efficient than string literal", "html_url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/1", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-09-swivel-findings", "body": "Bytes constant more efficient than string literal"}, {"title": "token out of range check can be simplified", "html_url": "https://github.com/code-423n4/2021-10-tracer-findings/issues/37", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-tracer-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact Because 'token' is of type uint here, this comparison can be simplified to reduce gas costs:   require(token == 0 || token == 1, \"Pool: token out of range\"); //before  ## Recommended Mitigation Steps   require(token < 2, \"Pool: token out of range\"); //after  "}, {"title": "Useless multiplication by 1", "html_url": "https://github.com/code-423n4/2021-10-tracer-findings/issues/36", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-tracer-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact Uneccesarry multiplication by 1 here:   require(initialization._fee < 1 * PoolSwapLibrary.WAD_PRECISION, \"Fee >= 100%\");  ## Recommended Mitigation Steps   require(initialization._fee < PoolSwapLibrary.WAD_PRECISION, \"Fee >= 100%\");  "}, {"title": "Unused imports", "html_url": "https://github.com/code-423n4/2021-10-tracer-findings/issues/33", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-10-tracer-findings", "body": "Unused imports"}, {"title": "Immutable state variables", "html_url": "https://github.com/code-423n4/2021-10-tracer-findings/issues/32", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-tracer-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact There are variables that do not change so they can be marked as immutable to greatly improve the gast costs. Examples of such variables are: scaler and oracle in ChainlinkOracleWrapper, factory in PoolCommitterDeployer, poolName in LeveragedPool and there are many more.  ## Recommended Mitigation Steps Consider applying 'immutable' to reduce gas costs.   "}, {"title": "Unused state variables", "html_url": "https://github.com/code-423n4/2021-10-tracer-findings/issues/31", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-tracer-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact Unused state variables: ```solidity     uint256 public constant BPT_TOKEN_PRECISION = 1e18;     uint256 internal constant ETH_PRECISION = 1e18;     uint32 public refundGasPrice; ``` Either remove them or use them where intended.  "}, {"title": "BLOCK_TIME of Arbitrum is less than 13 seconds", "html_url": "https://github.com/code-423n4/2021-10-tracer-findings/issues/30", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "disagree with severity"], "target": "2021-10-tracer-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact It is unclear why the block time is based on ETH mainnet 13s intervals, when in Arbitrum where these contracts are supposed to be deployed block times are faster:     uint256 public constant BLOCK_TIME = 13; /* in seconds */ I wanted to ask this Tracer's representative on Discord but received no answer so submitting this and you can decide if that was intentional.    "}, {"title": "Adding unchecked directive can save gas", "html_url": "https://github.com/code-423n4/2021-10-tracer-findings/issues/27", "labels": ["bug", "duplicate", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-tracer-findings", "body": "Adding unchecked directive can save gas"}, {"title": "`PoolKeeper.sol#performUpkeepSinglePool()` Wrong implementation allows attacker to interfere the upkeep of pools", "html_url": "https://github.com/code-423n4/2021-10-tracer-findings/issues/26", "labels": ["bug", "1 (Low Risk)", "disagree with severity"], "target": "2021-10-tracer-findings", "body": "`PoolKeeper.sol#performUpkeepSinglePool()` Wrong implementation allows attacker to interfere the upkeep of pools"}, {"title": "Wrong keeper reward computation", "html_url": "https://github.com/code-423n4/2021-10-tracer-findings/issues/23", "labels": ["bug", "sponsor confirmed", "2 (Med Risk)"], "target": "2021-10-tracer-findings", "body": "# Handle  cmichel   # Vulnerability details  The `PoolKeeper.keeperReward` computation mixes WADs and Quads which leads to issues. 1. Note that `keeperTip` returns values where `1` = `1%`, and `100 = 100%`, the same way `BASE_TIP = 5 = 5%`. Thus `_tipPercent = ABDKMathQuad.fromUInt(keeperTip)` is a Quad value of this keeper tip, and not in \"wad units\" as the comment above it says.  ```solidity // @audit \ud83d\udc47 this comment is not correct, it's in Quad units // tip percent in wad units bytes16 _tipPercent = ABDKMathQuad.fromUInt(keeperTip(_savedPreviousUpdatedTimestamp, _poolInterval)); ```  2. Now the `wadRewardValue` interprets `_tipPercent` as a WAD + Quad value which ultimately leads to significantly fewer keeper rewards: It tries to compute `_keeperGas + _keeperGas * _tipPercent` and to compute `_keeperGas * _tipPercent` it does a wrong division by `fixedPoint` (1e18 as a quad value) because it think the `_tipPercent` is a WAD value (100%=1e18) as a quad, when indeed `100%=100`. It seems like it should divide by `100` as a quad instead.  ``` ABDKMathQuad.add(     ABDKMathQuad.fromUInt(_keeperGas),     // @audit there's no need to divide by fixedPoint, he wants _keeperGas * _tipPercent and _tipPercent is a quad quad_99 / quad_100     ABDKMathQuad.div((ABDKMathQuad.mul(ABDKMathQuad.fromUInt(_keeperGas), _tipPercent)), ABDKMathQuad.fromUInt(100)) ) ```  ## Impact The keeper rewards are off as the `_keeperGas * _tipPercent` is divided by 1e18 instead of 1e2. Keeper will just receive their `_keeperGas` cost but the tip part will be close to zero every time.  ## Recommended Mitigation Steps Generally, I'd say the contract mixes quad and WAD units where it doesn't have to do it. Usually, you either use WAD or Quad math but not both at the same time. This complicates the code. I'd make `keeperTip()`  return a `byte16` Quad value as a percentage where `100% = ABDKMathQuad.fromUInt(1)`. This temporary float result can then be used in a different ABDKMathQuad computation.  Alternatively, divide by 100 as a quad instead of 1e18 as a quad because `_tipPercent` is not a WAD value, but simply a percentage where `1 = 1%`.  ```solidity ABDKMathQuad.add(     ABDKMathQuad.fromUInt(_keeperGas),     // @audit there's no need to divide by fixedPoint, he wants _keeperGas * _tipPercent and _tipPercent is a quad quad_99 / quad_100     ABDKMathQuad.div((ABDKMathQuad.mul(ABDKMathQuad.fromUInt(_keeperGas), _tipPercent)), ABDKMathQuad.fromUInt(100)) ) ```   "}, {"title": "Gas: Inefficient modulo computation", "html_url": "https://github.com/code-423n4/2021-10-tracer-findings/issues/22", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-tracer-findings", "body": "# Handle  cmichel   # Vulnerability details  `PoolFactory.uint2str` computes `i % 10` as `uint8(_i - (_i / 10) * 10)`. This intuitively seems more gas-expensive than doing `i % 10`. Consider using `i % 10` instead which also makes the code simpler to read.   "}, {"title": "Validate max fee", "html_url": "https://github.com/code-423n4/2021-10-tracer-findings/issues/21", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "disagree with severity"], "target": "2021-10-tracer-findings", "body": "# Handle  cmichel   # Vulnerability details  `PoolFactory.setFee` does not check if the `_fee` parameter is at most 100%.  ## Impact Setting a very high fee, even above 100%, will lead to the pool's funds being drained.  ## Recommended Mitigation Steps Validate `_fee` against a reasonable max-fee value, ideally < 100%.   "}, {"title": "No ERC20 `safeApprove` versions called", "html_url": "https://github.com/code-423n4/2021-10-tracer-findings/issues/20", "labels": ["bug", "sponsor disputed", "1 (Low Risk)"], "target": "2021-10-tracer-findings", "body": "No ERC20 `safeApprove` versions called"}, {"title": "`uncommit` sends tokens to the wrong user", "html_url": "https://github.com/code-423n4/2021-10-tracer-findings/issues/19", "labels": ["bug", "2 (Med Risk)", "disagree with severity"], "target": "2021-10-tracer-findings", "body": "`uncommit` sends tokens to the wrong user"}, {"title": "Deposits don't work with fee-on transfer tokens", "html_url": "https://github.com/code-423n4/2021-10-tracer-findings/issues/17", "labels": ["bug", "sponsor disputed", "2 (Med Risk)"], "target": "2021-10-tracer-findings", "body": "Deposits don't work with fee-on transfer tokens"}, {"title": "Gas: `transferGovernance` can save an sload", "html_url": "https://github.com/code-423n4/2021-10-tracer-findings/issues/16", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-tracer-findings", "body": "# Handle  cmichel   # Vulnerability details  The `LeveragedPool.transferGovernance` function emits an event and reads the new governance variable from storage.  ```solidity emit ProvisionalGovernanceChanged(provisionalGovernance); ```  It is cheaper to use the `_governance` parameter instead which is the same value.   "}, {"title": "Unsafe `int256` casts in `executePriceChange`", "html_url": "https://github.com/code-423n4/2021-10-tracer-findings/issues/14", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged", "disagree with severity"], "target": "2021-10-tracer-findings", "body": "Unsafe `int256` casts in `executePriceChange`"}, {"title": "Revert in `poolUpkeep`", "html_url": "https://github.com/code-423n4/2021-10-tracer-findings/issues/13", "labels": ["bug", "sponsor disputed", "1 (Low Risk)"], "target": "2021-10-tracer-findings", "body": "Revert in `poolUpkeep`"}, {"title": "Gas: shadow pools are only required for burn types", "html_url": "https://github.com/code-423n4/2021-10-tracer-findings/issues/12", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-tracer-findings", "body": "# Handle  cmichel   # Vulnerability details  The `PoolCommiter.shadowPools` track commitments for all four `Long/Short Mint/Burn` types and uses these to reconstruct the initial total supply to correctly compute the token amounts for the sequence of commitments (as short/long tokens already get burned in the commitment phase and reduced the total supply). However, the two burn types `LongBurn` and `ShortBurn` are all that's needed for the reconstruction which can be seen from the fact that `shadowPools[.]` is only accessed with them.  #### Recommendation Only store `shadowPools` for `LongBurn` and `ShortBurn` types, and remove the `shadowPools[_commitType] = shadowPools[_commitType] - _commit.amount;` statement in `_uncommit` which is unnecessary for the mints as it just pays out what's already tracked in the commitments (`_commit`).   "}, {"title": "Missing parameter validation", "html_url": "https://github.com/code-423n4/2021-10-tracer-findings/issues/11", "labels": ["bug", "duplicate", "0 (Non-critical)", "sponsor confirmed", "disagree with severity"], "target": "2021-10-tracer-findings", "body": "Missing parameter validation"}, {"title": "LeveragedPool has require statements which are also checked in library", "html_url": "https://github.com/code-423n4/2021-10-tracer-findings/issues/10", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-tracer-findings", "body": "# Handle  loop   # Vulnerability details  When making external calls to ERC20 functions LeveragedPool checks for zero addresses. These checks are already available in the OpenZeppelin ERC20 implementation which is used. This results in redundant checks which increase gas costs when calling these functions.   ## Proof of Concept Require statements used in LeveragedPool: - https://github.com/tracer-protocol/perpetual-pools-contracts/blob/646360b0549962352fe0c3f5b214ff8b5f73ba51/contracts/implementation/LeveragedPool.sol#L148 - https://github.com/tracer-protocol/perpetual-pools-contracts/blob/646360b0549962352fe0c3f5b214ff8b5f73ba51/contracts/implementation/LeveragedPool.sol#L163-L164 - https://github.com/tracer-protocol/perpetual-pools-contracts/blob/646360b0549962352fe0c3f5b214ff8b5f73ba51/contracts/implementation/LeveragedPool.sol#L234 - https://github.com/tracer-protocol/perpetual-pools-contracts/blob/646360b0549962352fe0c3f5b214ff8b5f73ba51/contracts/implementation/LeveragedPool.sol#L251  Checks in OpenZeppelin implementation: - https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol#L225-L226 - https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol#L252 - https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol#L275  ## Tools Used Remix  "}, {"title": "Contradiction in comment/require statement", "html_url": "https://github.com/code-423n4/2021-10-tracer-findings/issues/7", "labels": ["bug", "sponsor confirmed", "1 (Low Risk)"], "target": "2021-10-tracer-findings", "body": "# Handle  loop   # Vulnerability details  The comment for the `withdrawQuote()` function states 'Pool must not be paused'. Require statement requires paused to be true.  ## Impact Comment seems to be wrong, so no direct impact on functioning of protocol.  ## Proof of Concept Comment: https://github.com/tracer-protocol/perpetual-pools-contracts/blob/646360b0549962352fe0c3f5b214ff8b5f73ba51/contracts/implementation/LeveragedPool.sol#L359  Require: https://github.com/tracer-protocol/perpetual-pools-contracts/blob/646360b0549962352fe0c3f5b214ff8b5f73ba51/contracts/implementation/LeveragedPool.sol#L363  "}, {"title": "Unused Named Returns Can Be Removed", "html_url": "https://github.com/code-423n4/2021-10-tracer-findings/issues/6", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-tracer-findings", "body": "# Handle  ye0lde   # Vulnerability details  ## Impact  Removing unused named return variables can reduce gas usage and improve code clarity.  ## Proof of Concept  The unused named return variables are here.  ChainlinkOracleWrapper.sol: https://github.com/tracer-protocol/perpetual-pools-contracts/blob/646360b0549962352fe0c3f5b214ff8b5f73ba51/contracts/implementation/ChainlinkOracleWrapper.sol#L57-L67  LeveragedPool.sol https://github.com/tracer-protocol/perpetual-pools-contracts/blob/646360b0549962352fe0c3f5b214ff8b5f73ba51/contracts/implementation/LeveragedPool.sol#L327-L340 https://github.com/tracer-protocol/perpetual-pools-contracts/blob/646360b0549962352fe0c3f5b214ff8b5f73ba51/contracts/implementation/LeveragedPool.sol#L353-L355  ## Tools Used Visual Studio Code  ## Recommended Mitigation Steps Remove the unused named return variables or use them instead of creating additional variables.   "}, {"title": "Minimize Storage Slots (LeveragedPool.sol)", "html_url": "https://github.com/code-423n4/2021-10-tracer-findings/issues/3", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-tracer-findings", "body": "# Handle  ye0lde   # Vulnerability details  ## Impact  It is possible to minimize the number of storage slots used by rearranging the state variables in a more efficient way.  ## Proof of Concept In  LeveragedPool.sol: https://github.com/tracer-protocol/perpetual-pools-contracts/blob/646360b0549962352fe0c3f5b214ff8b5f73ba51/contracts/implementation/LeveragedPool.sol#L22-L44  ## Tools Used Visual Studio Code  ## Recommended Mitigation Steps Arrange the uint32, bytes32, and bool variables such that they fit into the same slot.   "}, {"title": "Set initial value for lastFee", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/91", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-defiprotocol-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact function handleFees can become cheaper by eliminating this surrounding if/else statement if you initially assign the value to the lastFee upon creation or initialization.  ## Recommended Mitigation Steps   uint256 public override lastFee = block.timestamp; or in function initialize as it will get this value anyway when doing the initial mintTo. But then you would probably need to skip handleFees if the timeDiff is 0.  "}, {"title": "Cache factory.ownerSplit()", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/89", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-defiprotocol-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact function handleFees calls factory.ownerSplit() twice. To save some gas and reduce the number of external calls, you should save the value after the first call and re-use it later.  ## Recommended Mitigation Steps Cache factory.ownerSplit() in a local variable and re-use it.  "}, {"title": "Cache basketAsERC20.totalSupply()", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/88", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-defiprotocol-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact Here basketAsERC20.totalSupply() does not change inside the loop so it can be called outside the loop to avoid multiple duplicate external calls:   uint256 tokensNeeded = basketAsERC20.totalSupply() * pendingWeights[i] * newRatio / BASE / BASE;  ## Recommended Mitigation Steps Cache basketAsERC20.totalSupply() in a temporary variable and re-use it.  "}, {"title": "There may be no bounties or user is not interested in any of them", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/87", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-defiprotocol-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact function settleAuction could skip withdrawBounty if there are no bounties.  ## Recommended Mitigation Steps if (bountyIDs.length > 0) {   withdrawBounty(bountyIDs); }   "}, {"title": "How much to approve before calling mintTo", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/86", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-10-defiprotocol-findings", "body": "How much to approve before calling mintTo"}, {"title": "createBasket re-entrancy", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/85", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-10-defiprotocol-findings", "body": "# Handle  pauliax   # Vulnerability details  ## Impact function createBasket in Factory should also be nonReentrant as it interacts with various tokens inside the loop and these tokens may contain callback hooks.  ## Recommended Mitigation Steps Add nonReentrant modifier to the declaration of createBasket.  "}, {"title": "Validations", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/84", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged", "disagree with severity"], "target": "2021-10-defiprotocol-findings", "body": "Validations"}, {"title": "Missing events for owner only functions that change critical parameters", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/82", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "disagree with severity"], "target": "2021-10-defiprotocol-findings", "body": "# Handle  defsec   # Vulnerability details  ## Impact  Owner only functions that change critical parameters should emit events. Events allow capturing the changed parameters so that off-chain tools/interfaces can register such changes with timelocks that allow users to evaluate them and consider if they would like to engage/exit based on how they perceive the changes as affecting the trustworthiness of the protocol or profitability of the implemented financial services. The alternative of directly querying on-chain contract state for such changes is not considered practical for most users/usages.  Missing events and timelocks do not promote transparency and if such changes immediately affect users\u2019 perception of fairness or trustworthiness, they could exit the protocol causing a reduction in liquidity which could negatively impact protocol TVL and reputation.  There are owner functions that do not emit any events in UserManager.sol.  ## Proof of Concept   Missing events  https://github.com/code-423n4/2021-10-union/blob/main/contracts/user/UserManager.sol#L156  https://github.com/code-423n4/2021-10-union/blob/main/contracts/user/UserManager.sol#L160   See similar High-severity H03 finding OpenZeppelin\u2019s Audit of Audius (https://blog.openzeppelin.com/audius-contracts-audit/#high) and Medium-severity M01 finding OpenZeppelin\u2019s Audit of UMA Phase 4 (https://blog.openzeppelin.com/uma-audit-phase-4/)   ## Tools Used  None  ## Recommended Mitigation Steps  Add events to all owner/admin functions that change critical parameters.  "}, {"title": " Missing events for basket only functions that change critical parameters", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/81", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed", "disagree with severity"], "target": "2021-10-defiprotocol-findings", "body": "# Handle  defsec   # Vulnerability details  ## Impact  Owner only functions that change critical parameters should emit events. Events allow capturing the changed parameters so that off-chain tools/interfaces can register such changes with timelocks that allow users to evaluate them and consider if they would like to engage/exit based on how they perceive the changes as affecting the trustworthiness of the protocol or profitability of the implemented financial services. The alternative of directly querying on-chain contract state for such changes is not considered practical for most users/usages.  Missing events and timelocks do not promote transparency and if such changes immediately affect users\u2019 perception of fairness or trustworthiness, they could exit the protocol causing a reduction in liquidity which could negatively impact protocol TVL and reputation.  There are basket functions that do not emit any events in Auction.sol.   Missing event :   https://github.com/code-423n4/2021-10-defiprotocol/blob/7ca848f2779e2e64ed0b4756c02f0137ecd73e50/contracts/contracts/Auction.sol#L44   ## Proof of Concept  See similar High-severity H03 finding OpenZeppelin\u2019s Audit of Audius (https://blog.openzeppelin.com/audius-contracts-audit/#high) and Medium-severity M01 finding OpenZeppelin\u2019s Audit of UMA Phase 4 (https://blog.openzeppelin.com/uma-audit-phase-4/)   ## Tools Used  ## Recommended Mitigation Steps  Add events to all owner/admin functions that change critical parameters.   "}, {"title": "Sensitive variables should not be able to be changed easily", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/80", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-10-defiprotocol-findings", "body": "Sensitive variables should not be able to be changed easily"}, {"title": "Fee on transfer tokens do not work within the protocol", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/78", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2021-10-defiprotocol-findings", "body": "Fee on transfer tokens do not work within the protocol"}, {"title": "Lack of Documentation on key functions", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/77", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-10-defiprotocol-findings", "body": "Lack of Documentation on key functions"}, {"title": "Input Validation on Factory.sol", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/75", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-10-defiprotocol-findings", "body": "Input Validation on Factory.sol"}, {"title": "Increase optimizer runs", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/74", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-10-defiprotocol-findings", "body": "Increase optimizer runs"}, {"title": "Remove hardhat import", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/73", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-10-defiprotocol-findings", "body": "Remove hardhat import"}, {"title": "uint256 can be lowered to unitX with X < 256 in some cases", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/72", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-10-defiprotocol-findings", "body": "uint256 can be lowered to unitX with X < 256 in some cases"}, {"title": "Unchecked modifiers should be used when over/under-flow isnt an issue to save gas", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/71", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-10-defiprotocol-findings", "body": "Unchecked modifiers should be used when over/under-flow isnt an issue to save gas"}, {"title": "Uninitialized variables are automatically set to 0", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/70", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-10-defiprotocol-findings", "body": "Uninitialized variables are automatically set to 0"}, {"title": "`Basket.sol` should use the Upgradeable variant of OpenZeppelin Contracts", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/68", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-10-defiprotocol-findings", "body": "`Basket.sol` should use the Upgradeable variant of OpenZeppelin Contracts"}, {"title": "`Basket.sol#changePublisher()` Remove redundant assertion can save gas", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/64", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-defiprotocol-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-10-defiprotocol/blob/7ca848f2779e2e64ed0b4756c02f0137ecd73e50/contracts/contracts/Basket.sol#L147-L152  ```solidity function changePublisher(address newPublisher) onlyPublisher public override {         require(newPublisher != address(0));          if (pendingPublisher.publisher != address(0) && pendingPublisher.publisher == newPublisher) {             require(block.number >= pendingPublisher.block + TIMELOCK_DURATION);             publisher = newPublisher; ```  `pendingPublisher.publisher` will never be `address(0)` if `newPublisher != address(0)` and `pendingPublisher.publisher == newPublisher`.  Removing `pendingPublisher.publisher != address(0)` can make the code simpler and save some gas.  ### Recommendation  Remove the redundant assertion.  "}, {"title": "Basket: No need for initialized variable", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/63", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-10-defiprotocol-findings", "body": "Basket: No need for initialized variable"}, {"title": "`Basket.sol#changeLicenseFee()` Remove redundant check can save gas", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/62", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-defiprotocol-findings", "body": "# Handle  WatchPug   # Vulnerability details  `Basket.sol#changeLicenseFee()` checks for `pendingLicenseFee.licenseFee  != 0`, while the assertion above already making sure that `newLicenseFee >= factory.minLicenseFee()`.  If we can make sure `factory.minLicenseFee() > 0`, then the check of `pendingLicenseFee.licenseFee != 0` will be redundant.  Removing it will make the code simpler and save some gas.  https://github.com/code-423n4/2021-10-defiprotocol/blob/7ca848f2779e2e64ed0b4756c02f0137ecd73e50/contracts/contracts/Basket.sol#L167-L170  ```solidity function changeLicenseFee(uint256 newLicenseFee) onlyPublisher public override {     require(newLicenseFee >= factory.minLicenseFee() && newLicenseFee != licenseFee);     if (pendingLicenseFee.licenseFee != 0 && pendingLicenseFee.licenseFee == newLicenseFee) {         require(block.number >= pendingLicenseFee.block + TIMELOCK_DURATION); ```  https://github.com/code-423n4/2021-10-defiprotocol/blob/7ca848f2779e2e64ed0b4756c02f0137ecd73e50/contracts/contracts/Factory.sol#L39-L41  ```solidity function setMinLicenseFee(uint256 newMinLicenseFee) public override onlyOwner {     minLicenseFee = newMinLicenseFee; } ```  ### Recommendation  Consider adding `require(newMinLicenseFee > 0);` to `Factory.sol#setMinLicenseFee()`.  Remove the redundant check.  "}, {"title": "`Basket.sol#changePublisher()` Insufficient input validation", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/61", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-10-defiprotocol-findings", "body": "# Handle  WatchPug   # Vulnerability details  As per the test, changePublisher to the current publisher should not be allowed:  https://github.com/code-423n4/2021-10-defiprotocol/blob/7ca848f2779e2e64ed0b4756c02f0137ecd73e50/contracts/test/Basket.test.js#L122-L122  ```javascript let publisher = await basket.publisher(); expect(publisher).to.equal(addr2.address);  await expect(basket.connect(addr2).changePublisher(addr2.address)).to.be.reverted; ```  However, there is no such check to make sure that.  https://github.com/code-423n4/2021-10-defiprotocol/blob/7ca848f2779e2e64ed0b4756c02f0137ecd73e50/contracts/contracts/Basket.sol#L147-L148  ```solidity function changePublisher(address newPublisher) onlyPublisher public override {     require(newPublisher != address(0)); ```  ### Recommendation  Change to:  ```solidity function changePublisher(address newPublisher) onlyPublisher public override {     require(newPublisher != address(0) && newPublisher != publisher); ```  "}, {"title": "`Basket.sol` should have methods to cancel pending changes", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/60", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-10-defiprotocol-findings", "body": "# Handle  WatchPug   # Vulnerability details  While changing publisher and licenseFee is timelocked, there are no methods to cancel pending changes.  As a result, wrong changes may not be able to get canceled  https://github.com/code-423n4/2021-10-defiprotocol/blob/7ca848f2779e2e64ed0b4756c02f0137ecd73e50/contracts/contracts/Basket.sol#L147-L163  ```solidity function changePublisher(address newPublisher) onlyPublisher public override {     require(newPublisher != address(0));      if (pendingPublisher.publisher != address(0) && pendingPublisher.publisher == newPublisher) {         require(block.number >= pendingPublisher.block + TIMELOCK_DURATION);         publisher = newPublisher;          pendingPublisher.publisher = address(0);          emit ChangedPublisher(publisher);     } else {         pendingPublisher.publisher = newPublisher;         pendingPublisher.block = block.number;          emit NewPublisherSubmitted(newPublisher);     } } ```  https://github.com/code-423n4/2021-10-defiprotocol/blob/7ca848f2779e2e64ed0b4756c02f0137ecd73e50/contracts/contracts/Basket.sol#L167-L182  ```solidity function changeLicenseFee(uint256 newLicenseFee) onlyPublisher public override {     require(newLicenseFee >= factory.minLicenseFee() && newLicenseFee != licenseFee);     if (pendingLicenseFee.licenseFee != 0 && pendingLicenseFee.licenseFee == newLicenseFee) {         require(block.number >= pendingLicenseFee.block + TIMELOCK_DURATION);         licenseFee = newLicenseFee;          pendingLicenseFee.licenseFee = 0;          emit ChangedLicenseFee(licenseFee);     } else {         pendingLicenseFee.licenseFee = newLicenseFee;         pendingLicenseFee.block = block.number;          emit NewLicenseFeeSubmitted(newLicenseFee);     } } ```  ### Recommendation  Consider adding methods to cancel pending changes.  "}, {"title": "`Basket.sol#mint()` Malfunction due to extra `nonReentrant` modifier", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/59", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-10-defiprotocol-findings", "body": "# Handle  WatchPug   # Vulnerability details  https://github.com/code-423n4/2021-10-defiprotocol/blob/7ca848f2779e2e64ed0b4756c02f0137ecd73e50/contracts/contracts/Basket.sol#L83-L88  ```solidity function mint(uint256 amount) public nonReentrant override {     mintTo(amount, msg.sender); }  function mintTo(uint256 amount, address to) public nonReentrant override {     require(auction.auctionOngoing() == false); ```  The `mint()` method is malfunction because of the extra `nonReentrant` modifier, as `mintTo` already has a `nonReentrant` modifier.  ### Recommendation  Change to:  ```solidity function mint(uint256 amount) public override {     mintTo(amount, msg.sender); } ```  "}, {"title": "Tests are broken", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/58", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-10-defiprotocol-findings", "body": "Tests are broken"}, {"title": "Unnecessary new list in Basket's validateWeights()", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/56", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-defiprotocol-findings", "body": "# Handle  kenzo   # Vulnerability details  # Vulnerability details  The function creates and populates a new array to check for duplicates, this is not necessary.  ## Impact Some amount of gas unnecessarily spent.  ## Proof of Concept The relevant area: https://github.com/code-423n4/2021-10-defiprotocol/blob/main/contracts/contracts/Basket.sol#L71:#L80 ## Tools Used Manual analysis, hardhat gas estimator.  ## Recommended Mitigation Steps Change the check to the following: ``` for (uint i = 0; i < length; i++) {   require(_tokens[i] != address(0));   require(_weights[i] > 0);   for (uint256 x = 0; x < i; x++) {       require(_tokens[i] != _tokens[x]);   } } ```  "}, {"title": "Restore state to 0 if not needed anymore", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/53", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-10-defiprotocol-findings", "body": "Restore state to 0 if not needed anymore"}, {"title": "Auction bonder can steal user funds if bond block is high enough", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/51", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-10-defiprotocol-findings", "body": "# Handle  kenzo   # Vulnerability details  After an auction has started, as time passes and according to the bondBlock, newRatio (which starts at 2*ibRatio) gets smaller and smaller and therefore less and less tokens need to remain in the basket. This is not capped, and after a while, newRatio can become smaller than current ibRatio.  ## Impact If for some reason nobody has bonded and settled an auction and the publisher didn't stop it, a malicious user can wait until newRatio < ibRatio, or even until newRatio ~= 0 (for an initial ibRatio of ~1e18 this happens after less than 3.5 days after auction started), and then bond and settle and steal user funds.  ## Proof of Concept These are the vulnerable lines: https://github.com/code-423n4/2021-10-defiprotocol/blob/main/contracts/contracts/Auction.sol#L95:#L105 ```         uint256 a = factory.auctionMultiplier() * basket.ibRatio();         uint256 b = (bondBlock - auctionStart) * BASE / factory.auctionDecrement();         uint256 newRatio = a - b;          (address[] memory pendingTokens, uint256[] memory pendingWeights) = basket.getPendingWeights();         IERC20 basketAsERC20 = IERC20(address(basket));          for (uint256 i = 0; i < pendingWeights.length; i++) {             uint256 tokensNeeded = basketAsERC20.totalSupply() * pendingWeights[i] * newRatio / BASE / BASE;             require(IERC20(pendingTokens[i]).balanceOf(address(basket)) >= tokensNeeded);         }  ``` The function verifies that ```pendingTokens[i].balanceOf(basket) >= basketAsERC20.totalSupply() * pendingWeights[i] * newRatio / BASE / BASE```. This is the formula that will be used later to mint/burn/withdraw user funds. As bondBlock increases, newRatio will get smaller, and there is no check on this. After a while we'll arrive at a point where ```newRatio ~= 0```, so ```tokensNeeded = newRatio*(...) ~= 0```, so the attacker could withdraw nearly all the tokens using outputTokens and outputWeights, and leave just scraps in the basket.  ## Tools Used Manual analysis, hardhat.  ## Recommended Mitigation Steps Your needed condition/math might be different, and you might also choose to burn the bond while you're at it, but I think at the minimum you should add a sanity check in settleAuction: ``` require (newRatio > basket.ibRatio()); ``` Maybe you would require newRatio to be > BASE but not sure.  "}, {"title": "Inaccurate log emitted at deleteNewIndex", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/50", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-10-defiprotocol-findings", "body": "Inaccurate log emitted at deleteNewIndex"}, {"title": "Basket becomes unusable if everybody burns their shares", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/49", "labels": ["bug", "2 (Med Risk)", "sponsor confirmed"], "target": "2021-10-defiprotocol-findings", "body": "Basket becomes unusable if everybody burns their shares"}, {"title": "Bonding mechanism allows malicious user to DOS auctions", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/48", "labels": ["bug", "3 (High Risk)", "sponsor acknowledged"], "target": "2021-10-defiprotocol-findings", "body": "Bonding mechanism allows malicious user to DOS auctions"}, {"title": "Comparisons to boolean constant", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/47", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-10-defiprotocol-findings", "body": "Comparisons to boolean constant"}, {"title": "Minimize Storage Slots (Auction.sol)", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/46", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-defiprotocol-findings", "body": "# Handle  ye0lde   # Vulnerability details  ## Impact It is possible to minimize the number of storage slots used by rearranging the state variables in a more efficient way.  ## Proof of Concept In Auction.sol: https://github.com/code-423n4/2021-10-defiprotocol/blob/7ca848f2779e2e64ed0b4756c02f0137ecd73e50/contracts/contracts/Auction.sol#L16-L28  ## Tools Used Visual Studio Code, Remix  ## Recommended Mitigation Steps Arrange the bool and address variables such that they fit into the same slot. For example: <code>     uint256 private constant BASE = 1e18;     uint256 private constant ONE_DAY = 4 * 60 * 24; // one day in blocks          bool public override auctionOngoing;     bool public override hasBonded;     bool public override initialized;     address public override auctionBonder;          uint256 public override auctionStart; </code>        "}, {"title": "`nonReentrant` modifier should be used before any other modifier", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/45", "labels": ["bug", "0 (Non-critical)", "sponsor confirmed"], "target": "2021-10-defiprotocol-findings", "body": "# Handle  pants   # Vulnerability details  The function `Basket.auctionBurn()` uses the `onlyAuction` and `nonReentrant` modifier, with this order.  ## Impact The `nonReentrant` modifier doesn't protect agains reentrancy during the execution of the first modifier. Practically, there cannot be any reentrancy there when considering the current implementation of `onlyAuction`, but it is still a best practice recommendation for safe programming.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Use the `nonReentrant` modifier before any other modifier.  "}, {"title": "Events in `IAuction` don't use the `indexed` keyword", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/44", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-10-defiprotocol-findings", "body": "Events in `IAuction` don't use the `indexed` keyword"}, {"title": "`Factory.proposeBasketLicense()` and `IFactory.proposeBasketLicense()` accept arguments with different data locations", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/43", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-10-defiprotocol-findings", "body": "# Handle  pants   # Vulnerability details  The function `Factory.proposeBasketLicense()` claims to override `IFactory.proposeBasketLicense()`, but some of their arguments have different data locations.  ## Impact Mismatching data locations in overrides have unexpected behavior.  ## Proof of Concept https://github.com/ethereum/solidity/issues/10900  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Modify the data locations of the arguments to match between `Factory.proposeBasketLicense()` and `IFactory.proposeBasketLicense()`.  "}, {"title": "`Basket.publishNewIndex()` and `IBasket.publishNewIndex()` accept arguments with different data locations", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/42", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-10-defiprotocol-findings", "body": "# Handle  pants   # Vulnerability details  The function `Basket.publishNewIndex()` claims to override `IBasket.publishNewIndex()`, but their arguments have different data locations.  ## Impact Mismatching data locations in overrides have unexpected behavior.  ## Proof of Concept https://github.com/ethereum/solidity/issues/10900  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Modify the data locations of the arguments to match between `Basket.publishNewIndex()` and `IBasket.publishNewIndex()`.  "}, {"title": "`Auction.settleAuction()` and `IAuction.settleAuction()` accept arguments with different data locations", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/41", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-10-defiprotocol-findings", "body": "# Handle  pants   # Vulnerability details  The function `Auction.settleAuction()` claims to override `IAuction.settleAuction()`, but their arguments have different data locations.  ## Impact Mismatching data locations in overrides have unexpected behavior.  ## Proof of Concept https://github.com/ethereum/solidity/issues/10900  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Modify the data locations of the arguments to match between `Auction.settleAuction()` and `IAuction.settleAuction()`.  "}, {"title": "Empty `else if` block in `Basket.publishNewIndex()`", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/38", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-defiprotocol-findings", "body": "# Handle  pants   # Vulnerability details  The function `Basket.publishNewIndex()` contains the following code: ``` if (auction.auctionOngoing() == false) {  // ... } else if (auction.hasBonded()) {  } else {  // ... } ```  ## Impact Empty code blocks increase gas costs (add overheads) and make the code less readable.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Get rid of the empty block by changing this code to: ``` if (auction.auctionOngoing() == false) {  // ... } else if (!auction.hasBonded()) {  // ... } ```  "}, {"title": "Unnecessary `SLOAD`s and `MLOAD`s in for-each loops", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/36", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-defiprotocol-findings", "body": "# Handle  pants   # Vulnerability details  There are many for loops that follows this for-each pattern: ``` for (uint256 i = 0; i < array.length; i++) {  // do something with `array[i]` } ```  In such for loops, the `array.length` is read on every iteration, instead of caching it once in a local variable and read it from there.  ## Impact Storage reads are much more expensive than reading local variables. Memory reads are a bit more expensive than reading local variables.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Read these values from storage / memory once, cache them in local variables and then read them again from the local variables. For example: ``` uint256 length = array.length; for (uint256 i = 0; i < length; i++) {  // do something with `array[i]` } ```  "}, {"title": "Unnecessary `SLOAD`s in `Factory`", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/35", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-defiprotocol-findings", "body": "# Handle  pants   # Vulnerability details  The functions `Factory.getProposalWeights()` and `Factory.createBasket()` read values from storage multiple times instead of caching them in local variables: - `Factory.getProposalWeights()` reads `_proposals[id]` twice. - `Factory.createBasket()` reads `_proposals[idNumber]` twice.  ## Impact Storage reads are much more expensive than reading local variables.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Read these values from storage once, cache them in local variables and then read them again from the local variables.  "}, {"title": "Unnecessary `SLOAD`s in `Basket`", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/34", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-defiprotocol-findings", "body": "# Handle  pants   # Vulnerability details  The functions `Basket.handleFees()`, `Basket.changePublisher()`, `Basket.changeLicenseFee()`, `Basket.publishNewIndex()`, `Basket.deleteNewIndex()`, `Basket.updateIBRatio()`, `Basket.approveUnderlying()`, `Basket.pushUnderlying()` and `Basket.pullUnderlying()` read values from storage multiple times instead of caching them in local variables: - `Basket.handleFees()` reads `lastFee` up to twice, `factory` 3 times and `ibRatio` once (when `newIbRatio` can be used). - `Basket.changePublisher()` reads `pendingPublisher.publisher` up to twice and `publisher` up to once (when `newPublisher` can be used). - `Basket.changeLicenseFee()` reads `pendingLicenseFee.licenseFee` up to twice and `licenseFee` up to once (when `newLicenseFee` can be used). - `Basket.publishNewIndex()` reads `auction` up to 3 times and `licenseFee` up to once (when `newLicenseFee` can be used). - `Basket.deleteNewIndex()` reads `publisher` twice and `auction` up to twice. - `Basket.updateIBRatio()` reads `ibRatio` twice. - `Basket.approveUnderlying()` reads `tokens[i]` twice. - `Basket.pushUnderlying()` reads `ibRatio` once per iteration. - `Basket.pullUnderlying()` reads `ibRatio` once per iteration.  ## Impact Storage reads are much more expensive than reading local variables.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Read these values from storage once, cache them in local variables and then read them again from the local variables.  "}, {"title": "Unnecessary `SLOAD`s in `Auction`", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/33", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-defiprotocol-findings", "body": "# Handle  pants   # Vulnerability details  The functions `Auction.bondForRebalance()`, `Auction.settleAuction()`, `Auction.bondBurn()` and `Auction.withdrawBounty()` read values from storage multiple times instead of caching them in local variables: - `Auction.bondForRebalance()` reads `bondAmount` twice. - `Auction.settleAuction()` reads `bondBlock` twice, `basket` 8 times and `factory` twice. - `Auction.bondBurn()` reads `basket` twice and `bondAmount` twice. - `Auction.withdrawBounty()` reads `bounty.token` twice and `bounty.amount` twice.  ## Impact Storage reads are much more expensive than reading local variables.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Read these values from storage once, cache them in local variables and then read them again from the local variables.  "}, {"title": "Inconsistent naming of a function's argument in `Factory`", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/32", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-10-defiprotocol-findings", "body": "Inconsistent naming of a function's argument in `Factory`"}, {"title": "Array out-of-bounds error in `Auction`", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/31", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-10-defiprotocol-findings", "body": "# Handle  pants   # Vulnerability details  The function `Auction.withdrawBounty()` accept an argument called `bountyIds` and use it as indices to determine which elements in the `_bounties` array should be loaded and treated. However, this function don't check that the indices it receives as an argument actually fits the bounds of the `_bounties` array.  ## Impact If one of the indices exceed the array length, there will be a revert with no informative error message. The user wouldn't know what caused the revert.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Add an appropriate require statement to this function to validate that the given argument fits the `_bounties` array bounds.  "}, {"title": "Array out-of-bounds errors in `Factory`", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/30", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-10-defiprotocol-findings", "body": "# Handle  pants   # Vulnerability details  The functions `Factory.proposal()`, `Factory.getProposalWeights()` and `Factory.createBasket()` accept an argument called `proposalId`, `id` or `idNumber`, respectively, and use it as an index to determine which element in the `_proposals` array should be loaded and treated. However, these functions don't check that the index they receive as an argument actually fits the bounds of the `_proposals` array.  ## Impact If the index exceed the array length, there will be a revert with no informative error message. The user wouldn't know what caused the revert.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Add an appropriate require statement to each of these functions to validate that the given argument fits the `_proposals` array bounds.  "}, {"title": "Unnecessary require statement in `Auction.initialize()` and `Basket.initialize()`", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/29", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-defiprotocol-findings", "body": "# Handle  pants   # Vulnerability details  The functions `Auction.initialize()` and `Basket.initialize()` look like this: ``` require(address(factory) == address(0)); require(!initialized); // ... factory = ...; // ... initialized = true;  ```  The second require statement is enough to make sure that these functions can only be called once. The first require statement is redundent.  ## Impact A redundent operation is executing.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Remove the first require statement in these functions.  "}, {"title": "Unnecessary checked arithmetic in for loops", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/28", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-10-defiprotocol-findings", "body": "# Handle  WatchPug   # Vulnerability details  There is no risk of overflow caused by increamenting the iteration index in for loops (the `i++` in for `for (uint256 i; i < ids.length; i++)`).  Increments perform overflow checks that are not necessary in this case.  ### Recommendation  Surround the increment expressions with an `unchecked { ... }` block to avoid the default overflow checks. For example, change the for loop:   https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/libraries/PayMath.sol#L21-L33  ```solidity for (uint256 i; i < ids.length; i++) {     IPair.Due memory due = pair.dueOf(maturity, address(collateralizedDebt), ids[i]);      if (assetsIn[i] > due.debt) assetsIn[i] = due.debt;     if (msg.sender == collateralizedDebt.ownerOf(ids[i])) {         uint256 _collateralOut = due.collateral;         if (due.debt > 0) {             _collateralOut *= assetsIn[i];             _collateralOut /= due.debt;         }         collateralsOut[i] = _collateralOut.toUint112();     } } ```  to:  ```solidity for (uint256 i; i < ids.length;) {     IPair.Due memory due = pair.dueOf(maturity, address(collateralizedDebt), ids[i]);      if (assetsIn[i] > due.debt) assetsIn[i] = due.debt;     if (msg.sender == collateralizedDebt.ownerOf(ids[i])) {         uint256 _collateralOut = due.collateral;         if (due.debt > 0) {             _collateralOut *= assetsIn[i];             _collateralOut /= due.debt;         }         collateralsOut[i] = _collateralOut.toUint112();     }      unchecked { ++i; } } ```   "}, {"title": "Unnecessary checked arithmetic in `Basket.handleFees()`", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/27", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-10-defiprotocol-findings", "body": "Unnecessary checked arithmetic in `Basket.handleFees()`"}, {"title": "Unnecessary checked arithmetic in `Auction.addBounty()` and `Factory.proposeBasketLicense()`", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/26", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-10-defiprotocol-findings", "body": "Unnecessary checked arithmetic in `Auction.addBounty()` and `Factory.proposeBasketLicense()`"}, {"title": "Unnecessary checked arithmetic in `Auction.settleAuction()`, `Auction.bondBurn()`, `Basket.changePublisher()`, `Basket.changeLicenseFee()` and `Basket.publishNewIndex()`", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/25", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-10-defiprotocol-findings", "body": "Unnecessary checked arithmetic in `Auction.settleAuction()`, `Auction.bondBurn()`, `Basket.changePublisher()`, `Basket.changeLicenseFee()` and `Basket.publishNewIndex()`"}, {"title": "Setting `Factory.auctionDecrement` to zero causes Denial of Service in `Auction.settleAuction()`", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/24", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2021-10-defiprotocol-findings", "body": "Setting `Factory.auctionDecrement` to zero causes Denial of Service in `Auction.settleAuction()`"}, {"title": "Setting `Factory.bondPercentDiv` to zero cause Denial of Service in `Auction.bondForRebalance()`", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/23", "labels": ["bug", "2 (Med Risk)", "sponsor acknowledged"], "target": "2021-10-defiprotocol-findings", "body": "Setting `Factory.bondPercentDiv` to zero cause Denial of Service in `Auction.bondForRebalance()`"}, {"title": "Prefix increament is cheaper than postfix increament", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/22", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-10-defiprotocol-findings", "body": "Prefix increament is cheaper than postfix increament"}, {"title": "Unnecessary cast in `Basket.onlyPublisher()`", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/21", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-defiprotocol-findings", "body": "# Handle  pants   # Vulnerability details  The modifier `Basket.onlyPublisher()` casts `publisher` to type `address`, although it is already a variable of type `address`.  ## Impact A redundent operation is executing.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Remove the cast to `address`.  "}, {"title": "Unnecessary cast in `Factory.proposeBasketLicense()`", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/20", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-defiprotocol-findings", "body": "# Handle  pants   # Vulnerability details  The function `Factory.proposeBasketLicense()` casts `msg.sender` to type `address`, although it is already a variable of type `address`.  ## Impact A redundent operation is executing.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Remove the cast to `address`.  "}, {"title": "Require statements without messages in `Factory`", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/18", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-10-defiprotocol-findings", "body": "Require statements without messages in `Factory`"}, {"title": "Require statements without messages in `Basket`", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/17", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-10-defiprotocol-findings", "body": "Require statements without messages in `Basket`"}, {"title": "Require statements without messages in `Auction`", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/16", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-10-defiprotocol-findings", "body": "Require statements without messages in `Auction`"}, {"title": "`internal` function in `Auction` can be `private`", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/15", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-defiprotocol-findings", "body": "# Handle  pants   # Vulnerability details  The `internal` function `Auction.withdrawBounty()` is never called by a contract that inherits `Auction`. Therefore, its visibility can be reduced to `private`.  ## Impact `private` functions are cheaper than `internal` functions.  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Define this function as `private`.  "}, {"title": "`public` functions in `Factory` can be `external`", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/14", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-defiprotocol-findings", "body": "# Handle  pants   # Vulnerability details  The `public` functions `Factory.setMinLicenseFee()`, `Factory.setAuctionDecrement()`, `Factory.setAuctionMultiplier()`, `Factory.setBondPercentDiv()`, `Factory.setOwnerSplit()` and `Factory.proposeBasketLicense()` are never called by `Factory`. Therefore, their visibility can be reduced to `external`.  ## Impact `external` functions are cheaper than `public` functions.  ## Proof of Concept https://gus-tavo-guim.medium.com/public-vs-external-functions-in-solidity-b46bcf0ba3ac  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Define these functions as `public`.  "}, {"title": "`public` functions in `Basket` can be `external`", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/13", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-defiprotocol-findings", "body": "# Handle  pants   # Vulnerability details  The `public` functions `Basket.mint()`, `Basket.burn()`, `Basket.changePublisher()`, `Basket.changeLicenseFee()`, `Basket.publishNewIndex()` and `Basket.deleteNewIndex()` are never called by `Basket`. Therefore, their visibility can be reduced to `external`.  ## Impact `external` functions are cheaper than `public` functions.  ## Proof of Concept https://gus-tavo-guim.medium.com/public-vs-external-functions-in-solidity-b46bcf0ba3ac  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Define these functions as `public`.  "}, {"title": "`public` functions in `Auction` can be `external`", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/12", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-defiprotocol-findings", "body": "# Handle  pants   # Vulnerability details  The `public` functions `Auction.startAuction()`, `Auction.killAuction()`, `Auction.initialize()`, `Auction.bondForRebalance()`, `Auction.settleAuction()` and `Auction.addBounty()` are never called by `Auction`. Therefore, their visibility can be reduced to `external`.  ## Impact `external` functions are cheaper than `public` functions.  ## Proof of Concept https://gus-tavo-guim.medium.com/public-vs-external-functions-in-solidity-b46bcf0ba3ac  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Define these functions as `public`.  "}, {"title": "State variables in `Factory` can be `immutable`", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/11", "labels": ["bug", "G (Gas Optimization)", "sponsor confirmed"], "target": "2021-10-defiprotocol-findings", "body": "# Handle  pants   # Vulnerability details  The state variables `Factory.auctionImpl` and `Factory.basketImpl` can be `immutable` since they are only set once, at the constructor.  ## Impact Reading from immutable state variables is much cheaper than from regular state variables.  ## Proof of Concept https://blog.soliditylang.org/2020/05/13/immutable-keyword/  ## Tool Used Manual code review.  ## Recommended Mitigation Steps Define these state variables as `immutable`.  "}, {"title": "Open TODOs in `Factory`", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/10", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-10-defiprotocol-findings", "body": "Open TODOs in `Factory`"}, {"title": "Open TODOs in `Basket`", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/9", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-10-defiprotocol-findings", "body": "Open TODOs in `Basket`"}, {"title": "Open TODOs in `Auction`", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/8", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-10-defiprotocol-findings", "body": "Open TODOs in `Auction`"}, {"title": "Open TODOs in `IFactory`", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/7", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-10-defiprotocol-findings", "body": "Open TODOs in `IFactory`"}, {"title": "Open TODOs in `IBasket`", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/6", "labels": ["bug", "0 (Non-critical)", "sponsor acknowledged"], "target": "2021-10-defiprotocol-findings", "body": "Open TODOs in `IBasket`"}, {"title": "Unused Named Returns Can Be Removed", "html_url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/4", "labels": ["bug", "G (Gas Optimization)", "sponsor acknowledged"], "target": "2021-10-defiprotocol-findings", "body": "Unused Named Returns Can Be Removed"}, {"title": "Token Can Deny Execution of `sweepFees()` Function", "html_url": "https://github.com/code-423n4/2021-10-tally-findings/issues/81", "labels": ["bug", "1 (Low Risk)", "disagree with severity", "sponsor acknowledged"], "target": "2021-10-tally-findings", "body": "Token Can Deny Execution of `sweepFees()` Function"}, {"title": "`Ownable` Contract Does Not Implement Two-Step Transfer Ownership Pattern", "html_url": "https://github.com/code-423n4/2021-10-tally-findings/issues/78", "labels": ["bug", "1 (Low Risk)", "sponsor confirmed"], "target": "2021-10-tally-findings", "body": "# Handle  leastwood   # Vulnerability details  ## Impact  `Swap.sol` inherits OpenZeppelin's `Ownable` contract which enables the `onlyOwner` role to transfer ownership to another address. It's possible that the `onlyOwner` role mistakenly transfers ownership to the wrong address, resulting in a loss of the `onlyOwner` role.  ## Proof of Concept  https://github.com/code-423n4/2021-10-tally/blob/main/contracts/governance/EmergencyGovernable.sol https://github.com/code-423n4/2021-10-tally/blob/main/contracts/swap/Swap.sol  ## Tools Used  Manual code review.  ## Recommended Mitigation Steps  Consider overriding the `transferOwnership()` function to first nominate an address as the pending owner and implementing an `acceptOwnership()` function which is called by the pending owner to confirm the transfer. Alternatively, as the `onlyOwner` role is not used throughout the contract, it may be useful to remove this contract entirely from the `EmergencyGovernable.sol` contract.  "}, {"title": "Open TODOs", "html_url": "https://github.com/code-423n4/2021-10-tally-findings/issues/75", "labels": ["bug", "1 (Low Risk)", "sponsor acknowledged"], "target": "2021-10-tally-findings", "body": "Open TODOs"}, {"title": "Unnecessary `CALLDATALOAD`s in for-each loops", "html_url": "https://github.com/code-423n4/2021-10-tally-findings/issues/74", "labels": ["bug", "G (Gas Optimization)"], "target": "2021-10-tally-findings", "body": "Unnecessary `CALLDATALOAD`s in for-each loops"}]